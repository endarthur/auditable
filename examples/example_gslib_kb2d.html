<!DOCTYPE html>
<!-- auditable — a reactive computational notebook in a single HTML file -->
<!-- https://github.com/endarthur/auditable — MIT license -->
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Auditable — KB2D — 2D kriging</title>
<style>
:root {
  --bg: #0a0a0a;
  --bg1: #111;
  --bg2: #1a1a1a;
  --border: #222;
  --border-hi: #333;
  --fg: #aaa;
  --fg-dim: #555;
  --fg-bright: #ccc;
  --accent: #c89b3c;
  --accent-dim: #8a6c2a;
  --err: #a33;
  --ok: #3a7;
  --mono: 'Courier New', Courier, monospace;
  --editor-font-size: 13px;
}

* { margin: 0; padding: 0; box-sizing: border-box; }

/* scrollbar */
::-webkit-scrollbar { width: 6px; height: 6px; }
::-webkit-scrollbar-track { background: var(--bg); }
::-webkit-scrollbar-thumb { background: var(--border-hi); border-radius: 0; }
::-webkit-scrollbar-thumb:hover { background: var(--fg-dim); }
textarea::-webkit-scrollbar-thumb { background: var(--border); }
@supports (scrollbar-color: auto) {
  * { scrollbar-color: var(--border-hi) var(--bg); scrollbar-width: thin; }
}

html, body {
  background: var(--bg);
  color: var(--fg);
  font-family: var(--mono);
  font-size: 13px;
  line-height: 1.5;
  min-height: 100vh;
}

/* ── TOOLBAR ── */
.toolbar {
  position: sticky;
  top: 0;
  z-index: 100;
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 6px 12px;
  background: var(--bg);
  border-bottom: 1px solid var(--border);
}

.toolbar-title {
  font-size: 11px;
  letter-spacing: 3px;
  text-transform: uppercase;
  color: var(--accent);
  opacity: 0.8;
  user-select: none;
}

.toolbar-sep {
  width: 1px;
  height: 16px;
  background: var(--border);
  margin: 0 4px;
}

.toolbar-filename {
  font-size: 12px;
  color: var(--fg-dim);
  flex: 1;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.toolbar-filename input {
  background: none;
  border: none;
  border-bottom: 1px solid transparent;
  color: var(--fg);
  font-family: var(--mono);
  font-size: 12px;
  outline: none;
  width: 200px;
}
.toolbar-filename input:focus {
  border-bottom-color: var(--accent-dim);
}

button {
  background: var(--bg2);
  border: 1px solid var(--border);
  color: var(--fg-dim);
  font-family: var(--mono);
  font-size: 10px;
  letter-spacing: 1px;
  text-transform: uppercase;
  padding: 4px 10px;
  cursor: pointer;
  transition: border-color 0.15s, color 0.15s;
}
button:hover {
  border-color: var(--border-hi);
  color: var(--fg);
}
button.accent {
  border-color: var(--accent-dim);
  color: var(--accent);
}
button.accent:hover {
  border-color: var(--accent);
}

/* ── TOOLBAR BADGES ── */
.toolbar-badges {
  display: inline-flex;
  gap: 4px;
  margin-left: 6px;
  align-items: center;
}
.toolbar-badge {
  font-size: 9px;
  letter-spacing: 0.5px;
  padding: 1px 4px;
  border-radius: 2px;
  user-select: none;
  opacity: 0.85;
}
.toolbar-badge-signed {
  color: var(--ok);
  border: 1px solid color-mix(in srgb, var(--ok) 40%, transparent);
}
.toolbar-badge-packed {
  color: var(--fg-dim);
  border: 1px solid var(--border);
}

/* ── SPLIT SAVE BUTTON ── */
.save-split {
  display: inline-flex;
  position: relative;
}
.save-split button:first-child {
  border-right: none;
  border-radius: 3px 0 0 3px;
}
.save-caret {
  border-radius: 0 3px 3px 0 !important;
  padding: 4px 4px !important;
  font-size: 10px;
}
.save-tray {
  display: none;
  position: absolute;
  right: 0;
  top: 100%;
  margin-top: 4px;
  background: var(--bg);
  border: 1px solid var(--border);
  z-index: 100;
  min-width: 120px;
}
.save-tray.open { display: flex; flex-direction: column; }
.save-tray button {
  border: none;
  border-bottom: 1px solid var(--border);
  text-align: left;
  padding: 6px 10px;
  white-space: nowrap;
  font-size: 12px;
}
.save-tray button:last-child { border-bottom: none; }
.save-tray button:hover { background: var(--bg-hi); }

/* ── TRANSPORT CONTROLS ── */
.transport {
  display: inline-flex;
  border: 1px solid var(--border);
}
.transport button {
  border: none;
  border-right: 1px solid var(--border);
  padding: 4px 8px;
}
.transport button:last-child { border-right: none; }
.transport button.autorun-on {
  background: #33aa77;
  color: #111;
}
.transport button.autorun-off {
  background: #dd4444;
  color: #111;
}

.toolbar-right {
  margin-left: auto;
  display: flex;
  align-items: center;
  gap: 8px;
}

/* ── TOOLBAR OVERFLOW MENU ── */
.toolbar-overflow {
  position: relative;
  display: inline-block;
}
.toolbar-overflow-tray {
  display: none;
  position: absolute;
  top: 100%;
  right: 0;
  background: var(--bg1);
  border: 1px solid var(--border);
  z-index: 200;
  flex-direction: column;
  min-width: 140px;
}
.toolbar-overflow-tray button {
  border: none;
  border-bottom: 1px solid var(--border);
  text-align: left;
  padding: 8px 12px;
  background: var(--bg1);
  white-space: nowrap;
}
.toolbar-overflow-tray button:last-child { border-bottom: none; }
.toolbar-overflow-tray button:hover { background: var(--bg2); color: var(--fg-bright); }
.toolbar-overflow.open .toolbar-overflow-tray { display: flex; }

/* ── BOTTOM ACTION BAR ── */
.action-bar { display: none; }

/* ── ACTION BAR TRAYS ── */
.action-add-tray,
.action-more-tray {
  display: none;
  position: absolute;
  bottom: 100%;
  background: var(--bg1);
  border: 1px solid var(--border);
  flex-direction: column;
  z-index: 200;
}
.action-add-tray { left: 0; min-width: 120px; }
.action-more-tray { right: 0; min-width: 120px; }
.action-add-tray.open,
.action-more-tray.open { display: flex; }
.action-add-tray button,
.action-more-tray button {
  min-height: 48px;
  border: none;
  border-bottom: 1px solid var(--border);
  text-align: left;
  padding: 8px 16px;
  background: var(--bg1);
  color: var(--fg);
  font-family: var(--mono);
  font-size: 12px;
  letter-spacing: 1px;
  text-transform: uppercase;
}
.action-add-tray button:last-child,
.action-more-tray button:last-child { border-bottom: none; }
.action-add-tray button:hover,
.action-more-tray button:hover { background: var(--bg2); color: var(--fg-bright); }
.action-more-tray button.active-mode { color: var(--accent); }

/* ── CELL INSERT / CONVERT BUTTONS (touch only) ── */
.cell-insert { display: none; }
.cell-convert { display: none; }

/* ── CELL TYPE PICKER ── */
.cell-type-picker {
  display: none;
  gap: 2px;
  padding: 2px 8px 4px;
}
.cell-type-picker.open { display: flex; }
.cell-type-picker button {
  font-size: 9px;
  padding: 2px 8px;
  background: var(--bg2);
  border: 1px solid var(--border);
  color: var(--fg-dim);
  font-family: var(--mono);
  letter-spacing: 1px;
  text-transform: uppercase;
}
.cell-type-picker button:hover {
  border-color: var(--accent-dim);
  color: var(--accent);
}

/* ── CELL INSERT PICKER ── */
.cell-insert-picker {
  display: none;
  gap: 2px;
  position: absolute;
  background: var(--bg1);
  border: 1px solid var(--border);
  padding: 4px;
  z-index: 200;
}
.cell-insert-picker.open { display: flex; }
.cell-insert-picker button {
  font-size: 9px;
  padding: 4px 8px;
  background: var(--bg2);
  border: 1px solid var(--border);
  color: var(--fg-dim);
  font-family: var(--mono);
  letter-spacing: 1px;
  text-transform: uppercase;
  min-height: 36px;
}
.cell-insert-picker button:hover {
  border-color: var(--accent-dim);
  color: var(--accent);
}

/* ── TOOLBAR STATUS (mobile cell count) ── */
.toolbar-status { display: none; }

/* ── NOTEBOOK ── */
.notebook {
  max-width: 860px;
  margin: 0 auto;
  padding: 16px 12px 120px;
}

/* ── CELL ── */
.cell {
  position: relative;
  margin: 6px 0;
  border-left: 2px solid transparent;
  transition: border-color 0.15s;
}
.cell:hover {
  border-left-color: var(--border-hi);
}
.cell.selected {
  border-left-color: var(--accent);
}
.cell.selected .cell-header {
  opacity: 1;
}
.cell.manual .cell-type::after {
  content: ' \00b7 manual';
  color: var(--accent-dim);
}
.cell.stale {
  border-left-color: var(--accent-dim);
}
.cell.error {
  border-left-color: var(--err);
}
.cell.fresh {
  border-left-color: var(--ok);
  transition: border-color 0.5s;
}

/* cell header — type label + controls */
.cell-header {
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 2px 8px;
  opacity: 0;
  transition: opacity 0.15s;
  user-select: none;
}
.cell:hover .cell-header,
.cell:focus-within .cell-header {
  opacity: 1;
}

.cell.collapsed .cell-code,
.cell.collapsed .cell-md-edit,
.cell.collapsed .cell-css-edit,
.cell.collapsed .cell-html-edit {
  display: none !important;
}
.cell.collapsed .cell-type::before {
  content: '\25b8 ';
}
.cell:not(.collapsed) .cell-type::before {
  content: '\25be ';
}
.cell-type {
  cursor: pointer;
  user-select: none;
  font-size: 9px;
  letter-spacing: 2px;
  text-transform: uppercase;
  color: var(--fg-dim);
}
.cell[data-type="code"] .cell-type { color: #7aabcf; }
.cell[data-type="css"]  .cell-type { color: #d4955a; }
.cell[data-type="html"] .cell-type { color: #6dbfb8; }
.cell[data-type="md"]   .cell-type { color: var(--fg-dim); }

.cell-btn {
  background: none;
  border: none;
  color: var(--fg-dim);
  font-family: var(--mono);
  font-size: 10px;
  padding: 0 4px;
  cursor: pointer;
}
.cell-btn:hover { color: var(--fg); }
.cell-btn.del:hover { color: var(--err); }

/* ── CODE CELL ── */
.cell-code {
  position: relative;
}

.editor-wrap {
  --gutter: 36px;
  position: relative;
  overflow: hidden;
}

.line-numbers {
  position: absolute;
  top: 0; left: 0; bottom: 0;
  width: var(--gutter);
  padding: 8px 4px 8px 0;
  font-family: var(--mono);
  font-size: var(--editor-font-size);
  line-height: 1.5;
  text-align: right;
  color: var(--fg-dim);
  background: var(--bg1);
  border-right: 1px solid var(--border);
  border-top: 1px solid var(--border);
  border-bottom: 1px solid var(--border);
  border-left: 1px solid var(--border);
  overflow: hidden;
  z-index: 3;
  pointer-events: none;
  white-space: pre;
  box-sizing: border-box;
}

:root.hide-line-numbers .line-numbers { display: none; }
:root.hide-line-numbers .editor-wrap { --gutter: 0px; }

.cell-code textarea {
  display: block;
  width: 100%;
  background: transparent;
  border: 1px solid var(--border);
  color: var(--fg-bright);
  caret-color: var(--fg-bright);
  font-family: var(--mono);
  font-size: var(--editor-font-size);
  line-height: 1.5;
  padding: 8px 10px 8px calc(var(--gutter) + 10px);
  resize: vertical;
  min-height: 38px;
  outline: none;
  tab-size: 2;
  white-space: pre;
  overflow-x: auto;
  position: relative;
  z-index: 2;
  -webkit-text-fill-color: transparent;
}
.cell-code textarea::selection {
  -webkit-text-fill-color: var(--fg-bright);
  background: rgba(200,155,60,0.25);
}
.cell-code textarea:focus + .highlight-layer {
  border-color: var(--border-hi);
}
.cell-code textarea:focus ~ .line-numbers {
  border-color: var(--border-hi);
}

.highlight-layer {
  position: absolute;
  top: 0; left: 0; right: 0; bottom: 0;
  background: var(--bg1);
  border: 1px solid var(--border);
  padding: 8px 10px 8px calc(var(--gutter) + 10px);
  font-family: var(--mono);
  font-size: var(--editor-font-size);
  line-height: 1.5;
  tab-size: 2;
  white-space: pre;
  overflow: hidden;
  z-index: 1;
  pointer-events: none;
  color: var(--fg-bright);
}

/* syntax tokens */
.hl-kw { color: #7a9ec7; }
.hl-str { color: var(--accent); }
.hl-num { color: #8cb878; }
.hl-cmt { color: #555; font-style: italic; }
.hl-fn { color: #c4a6d0; }
.hl-const { color: #d09870; }
.hl-op { color: #888; }
.hl-punc { color: #666; }

/* CSS syntax tokens */
.hl-atrule { color: #7aabcf; }
.hl-prop { color: #7aabcf; }
.hl-sel { color: #d4955a; }
.hl-color { color: var(--accent); }
.hl-important { color: #d4555a; font-weight: bold; }

/* HTML syntax tokens */
.hl-tag { color: #6dbfb8; }
.hl-attr { color: #7aabcf; }
.hl-expr { color: var(--accent); }

.hl-swatch {
  display: inline-block;
  width: 10px;
  height: 10px;
  border: 1px solid var(--border-hi);
  vertical-align: middle;
  margin-right: 2px;
  cursor: pointer;
  pointer-events: auto;
}

.cell-output {
  padding: 4px 10px;
  min-height: 0;
  font-size: 12px;
  color: var(--fg);
  white-space: pre-wrap;
  word-break: break-all;
}
.cell-output:empty {
  display: none;
}
.cell-output.error {
  color: var(--err);
}

.cell-output canvas {
  max-width: 100%;
  display: block;
  margin: 4px 0;
}

.cell-output table {
  border-collapse: collapse;
  font-size: 11px;
  margin: 4px 0;
}
.cell-output table th,
.cell-output table td {
  border: 1px solid var(--border);
  padding: 2px 8px;
}
.cell-output table th {
  color: var(--accent);
  font-weight: normal;
  text-transform: uppercase;
  font-size: 9px;
  letter-spacing: 1px;
}

/* ── CSS CELL ── */
.cell-css-view {
  padding: 6px 10px;
  color: var(--fg-dim);
  cursor: text;
  min-height: 24px;
  font-size: 11px;
  font-style: italic;
}
.cell-css-view:empty::before {
  content: '(empty stylesheet)';
}

.cell-css-edit textarea {
  display: block;
  width: 100%;
  background: transparent;
  border: 1px solid var(--border);
  color: var(--fg-bright);
  caret-color: var(--fg-bright);
  font-family: var(--mono);
  font-size: var(--editor-font-size);
  line-height: 1.5;
  padding: 8px 10px 8px calc(var(--gutter) + 10px);
  resize: vertical;
  min-height: 38px;
  outline: none;
  tab-size: 2;
  white-space: pre;
  overflow-x: auto;
  position: relative;
  z-index: 2;
  -webkit-text-fill-color: transparent;
}
.cell-css-edit textarea::selection {
  -webkit-text-fill-color: var(--fg-bright);
  background: rgba(200,155,60,0.25);
}
.cell-css-edit textarea:focus + .highlight-layer {
  border-color: var(--border-hi);
}
.cell-css-edit textarea:focus ~ .line-numbers {
  border-color: var(--border-hi);
}

/* ── HTML CELL ── */
.cell-html-view {
  padding: 6px 10px;
  color: var(--fg);
  cursor: text;
  min-height: 24px;
}
.cell-html-view:empty::before {
  content: '(empty html template)';
  color: var(--fg-dim);
  font-style: italic;
  font-size: 11px;
}
.cell-html-edit textarea {
  display: block;
  width: 100%;
  background: transparent;
  border: 1px solid var(--border);
  color: var(--fg-bright);
  caret-color: var(--fg-bright);
  font-family: var(--mono);
  font-size: var(--editor-font-size);
  line-height: 1.5;
  padding: 8px 10px 8px calc(var(--gutter) + 10px);
  resize: vertical;
  min-height: 38px;
  outline: none;
  tab-size: 2;
  white-space: pre;
  overflow-x: auto;
  position: relative;
  z-index: 2;
  -webkit-text-fill-color: transparent;
}
.cell-html-edit textarea::selection {
  -webkit-text-fill-color: var(--fg-bright);
  background: rgba(200,155,60,0.25);
}
.cell-html-edit textarea:focus + .highlight-layer {
  border-color: var(--border-hi);
}
.cell-html-edit textarea:focus ~ .line-numbers {
  border-color: var(--border-hi);
}

/* ── MARKDOWN CELL ── */
.cell-md-view {
  padding: 6px 10px;
  color: var(--fg);
  cursor: text;
  min-height: 24px;
}
.cell-md-view:empty::before {
  content: '(empty markdown cell)';
  color: var(--fg-dim);
  font-style: italic;
  font-size: 11px;
}
.cell-md-view h1, .cell-md-view h2, .cell-md-view h3 {
  color: var(--fg-bright);
  font-weight: normal;
  margin: 4px 0;
}
.cell-md-view h1 { font-size: 18px; letter-spacing: 2px; }
.cell-md-view h2 { font-size: 15px; letter-spacing: 1px; color: var(--accent); }
.cell-md-view h3 { font-size: 13px; }
.cell-md-view p { margin: 4px 0; }
.cell-md-view code {
  background: var(--bg2);
  padding: 1px 4px;
  font-size: 12px;
}
.cell-md-view strong { color: var(--fg-bright); }
.cell-md-view em { font-style: italic; }
.cell-md-view a { color: var(--accent); }
.cell-md-view table {
  border-collapse: collapse;
  font-size: 11px;
  margin: 4px 0;
}
.cell-md-view table th,
.cell-md-view table td {
  border: 1px solid var(--border);
  padding: 2px 8px;
}
.cell-md-view table th {
  color: var(--accent);
  font-weight: normal;
  text-transform: uppercase;
  font-size: 9px;
  letter-spacing: 1px;
}

.cell-md-edit textarea {
  display: block;
  width: 100%;
  background: var(--bg1);
  border: 1px solid var(--border);
  color: var(--fg-bright);
  font-family: var(--mono);
  font-size: var(--editor-font-size);
  line-height: 1.5;
  padding: 8px 10px;
  resize: vertical;
  min-height: 38px;
  outline: none;
}

/* ── PRESENTATION MODE ── */
body.presenting .toolbar { display: none; }
body.presenting .cell-header { display: none; }
body.presenting .cell-code { display: none; }
body.presenting .cell-md-edit { display: none !important; }
body.presenting .cell-css-edit { display: none; }
body.presenting .cell-css-view { display: none; }
body.presenting .cell-html-edit { display: none !important; }
body.presenting .cell { border-left: none; margin: 0; }
body.presenting .cell:hover { border-left: none; }
body.presenting .insert-bar { display: none; }
body.presenting .notebook { max-width: 900px; padding-top: 40px; }
body.presenting .statusbar { display: none; }
body.presenting .present-hidden { display: none; }
body.presenting .present-exit {
  display: block;
  position: fixed;
  top: 12px;
  right: 12px;
  z-index: 200;
}
.present-exit { display: none; }

/* ── INSERT BAR (between cells) ── */
.insert-bar {
  height: 16px;
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  margin: -6px 0;
}
.insert-bar::before {
  content: '';
  position: absolute;
  left: 20px;
  right: 20px;
  top: 50%;
  height: 1px;
  background: var(--border);
  opacity: 0;
  transition: opacity 0.15s;
}
.insert-bar:hover::before { opacity: 1; }
.insert-bar .insert-btns {
  display: flex;
  gap: 4px;
  opacity: 0;
  transition: opacity 0.15s;
  position: relative;
  z-index: 10;
}
.insert-bar:hover .insert-btns { opacity: 1; }
.insert-bar .insert-btns button {
  font-size: 9px;
  padding: 1px 8px;
  background: var(--bg);
  border: 1px solid var(--border);
  color: var(--fg-dim);
}
.insert-bar .insert-btns button:hover {
  border-color: var(--accent-dim);
  color: var(--accent);
}

/* ── ADD CELL BAR ── */
.add-bar {
  display: flex;
  justify-content: center;
  gap: 8px;
  padding: 6px 0;
  opacity: 0;
  transition: opacity 0.15s;
}
.notebook:hover .add-bar,
.add-bar.visible {
  opacity: 0.5;
}
.add-bar:hover {
  opacity: 1 !important;
}

/* ── WIDGET CLASSES ── */
.cell-widget {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 2px 0;
  font-size: 12px;
  color: var(--fg-dim);
}
.cell-widget-label {
  min-width: 80px;
  font-size: 10px;
  letter-spacing: 1px;
  text-transform: uppercase;
  color: var(--fg-dim);
}
.cell-widget input[type="range"] {
  flex: 1;
  accent-color: var(--accent);
  max-width: 200px;
}
.cell-widget select {
  background: var(--bg2);
  border: 1px solid var(--border);
  color: var(--fg-bright);
  font-family: var(--mono);
  font-size: 12px;
  padding: 2px 4px;
}
.cell-widget input[type="checkbox"] {
  accent-color: var(--accent);
}
.cell-widget input[type="text"] {
  background: var(--bg2);
  border: 1px solid var(--border);
  color: var(--fg-bright);
  font-family: var(--mono);
  font-size: 12px;
  padding: 2px 6px;
  flex: 1;
  max-width: 200px;
}
.cell-widget-val {
  min-width: 40px;
  text-align: right;
  color: var(--fg-bright);
  font-size: 12px;
}

/* ── STATUS BAR ── */
.statusbar {
  position: fixed;
  bottom: 0;
  left: 0;
  right: 0;
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 4px 12px;
  background: var(--bg);
  border-top: 1px solid var(--border);
  font-size: 10px;
  color: var(--fg-dim);
  letter-spacing: 1px;
  z-index: 100;
}
.statusbar .status-size { color: var(--fg-dim); }
.statusbar .status-cells { color: var(--fg-dim); }
.statusbar .status-msg { flex: 1; text-align: right; }
.statusbar .status-msg.ok { color: var(--ok); }
.statusbar .status-msg.warn { color: var(--accent); }
.statusbar .status-msg.err { color: var(--err); }
.statusbar .status-attr { margin-left: auto; display: flex; align-items: center; gap: 6px; }
.statusbar .status-attr a {
  color: var(--fg-dim);
  text-decoration: none;
  transition: color 0.2s;
}
.statusbar .status-attr a:hover { color: var(--accent); }
.statusbar .status-attr svg { vertical-align: middle; }

/* ── EMPTY STATE ── */
.empty-state {
  text-align: center;
  padding: 80px 20px;
  color: var(--fg-dim);
}
.empty-state .logo {
  font-size: 11px;
  letter-spacing: 4px;
  text-transform: uppercase;
  color: var(--accent);
  margin-bottom: 16px;
}
.empty-state .tagline {
  font-size: 11px;
  margin-bottom: 24px;
}

.help-overlay {
  display: none;
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.85);
  z-index: 1000;
  overflow-y: auto;
  padding: 40px;
}
.help-overlay.visible { display: flex; justify-content: center; }
.help-content {
  position: relative;
  max-width: 600px;
  width: 100%;
  color: var(--fg);
  font-family: var(--mono);
  font-size: 13px;
  line-height: 1.8;
}
.help-content h2 {
  color: var(--accent);
  font-size: 14px;
  letter-spacing: 2px;
  text-transform: uppercase;
  margin: 24px 0 8px 0;
  border-bottom: 1px solid var(--border);
  padding-bottom: 4px;
}
.help-content h2:first-child { margin-top: 0; }
.help-row {
  display: flex;
  justify-content: space-between;
  padding: 2px 0;
}
.help-key {
  background: var(--bg2);
  border: 1px solid var(--border);
  border-radius: 3px;
  padding: 0 6px;
  font-size: 11px;
  color: var(--fg-bright);
  min-width: 80px;
  text-align: center;
  display: inline-block;
}
.help-desc { color: var(--fg); }
.help-close {
  color: var(--accent-dim);
  font-size: 11px;
  text-align: center;
  margin-top: 24px;
  letter-spacing: 1px;
}
.help-close-btn {
  position: absolute;
  top: 0;
  right: 0;
  background: none;
  border: 1px solid var(--border);
  color: var(--fg-dim);
  font-size: 20px;
  width: 44px;
  height: 44px;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 0;
  cursor: pointer;
  text-transform: none;
  letter-spacing: 0;
}
.help-close-btn:hover {
  border-color: var(--err);
  color: var(--err);
}

/* ── SETTINGS PANEL ── */
.settings-overlay {
  display: none;
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.5);
  z-index: 1000;
}
.settings-overlay.visible { display: block; }
.settings-panel {
  display: none;
  position: fixed;
  top: 0;
  right: 0;
  bottom: 0;
  width: 280px;
  max-width: 90vw;
  background: var(--bg1);
  border-left: 1px solid var(--border);
  padding: 20px;
  overflow-y: auto;
  z-index: 1001;
  font-family: var(--mono);
  font-size: 12px;
  color: var(--fg);
}
.settings-close {
  position: absolute;
  top: 12px;
  right: 12px;
  background: none;
  border: 1px solid var(--border);
  color: var(--fg-dim);
  font-size: 18px;
  width: 32px;
  height: 32px;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 0;
  cursor: pointer;
  text-transform: none;
  letter-spacing: 0;
}
.settings-close:hover {
  border-color: var(--err);
  color: var(--err);
}

.settings-panel h2 {
  color: var(--accent);
  font-size: 11px;
  letter-spacing: 2px;
  text-transform: uppercase;
  margin: 20px 0 10px 0;
}
.settings-panel h2:first-child { margin-top: 0; }
.settings-row {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 6px 0;
}
.settings-row label { color: var(--fg-dim); font-size: 11px; }
.settings-row select,
.settings-row input[type="range"] {
  background: var(--bg2);
  border: 1px solid var(--border);
  color: var(--fg-bright);
  font-family: var(--mono);
  font-size: 11px;
  padding: 2px 4px;
}
.settings-row input[type="range"] {
  accent-color: var(--accent);
  width: 100px;
}
.settings-val {
  min-width: 30px;
  text-align: right;
  color: var(--fg-bright);
  font-size: 11px;
}

/* ── SETTINGS DESCRIPTIONS ── */
.settings-desc {
  color: var(--fg-dim);
  font-size: 10px;
  line-height: 1.5;
  padding: 4px 0 8px;
}
.settings-desc strong {
  color: var(--fg);
}

/* ── HIDE RUN TOGGLE ── */
html.hide-run-toggle #autorunBtn,
html.hide-run-toggle #autorunBtnMobile { display: none; }

/* ── MODULE LIST (settings panel) ── */
.module-row {
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 4px 0;
  font-size: 11px;
}
.module-url {
  flex: 1;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  color: var(--fg);
}
.module-info {
  color: var(--fg-dim);
  white-space: nowrap;
  font-size: 10px;
}
.module-remove {
  background: none;
  border: none;
  color: var(--fg-dim);
  font-size: 14px;
  padding: 0 2px;
  cursor: pointer;
  line-height: 1;
  text-transform: none;
  letter-spacing: 0;
}
.module-remove:hover { color: var(--err); }
.module-total {
  padding: 4px 0;
  font-size: 10px;
  color: var(--fg-dim);
  border-top: 1px solid var(--border);
  text-align: right;
}
.module-empty {
  color: var(--fg-dim);
  font-size: 11px;
  font-style: italic;
  padding: 4px 0;
}
/* ── UPDATE PANEL ── */
.update-overlay {
  display: none;
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.5);
  z-index: 1000;
}
.update-overlay.visible { display: block; }
.update-panel {
  display: none;
  position: fixed;
  top: 0;
  right: 0;
  bottom: 0;
  width: 280px;
  max-width: 90vw;
  background: var(--bg1);
  border-left: 1px solid var(--border);
  padding: 20px;
  overflow-y: auto;
  z-index: 1001;
  font-family: var(--mono);
  font-size: 12px;
  color: var(--fg);
}
.update-panel h2 {
  color: var(--accent);
  font-size: 11px;
  letter-spacing: 2px;
  text-transform: uppercase;
  margin: 0 0 12px 0;
}
.update-panel .settings-row {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 6px 0;
}
.update-panel .settings-row label { color: var(--fg-dim); font-size: 11px; }
.update-actions {
  display: flex;
  flex-direction: column;
  gap: 6px;
  padding: 8px 0;
}
.update-actions button {
  width: 100%;
  padding: 8px 10px;
}
.update-status {
  font-size: 11px;
  padding: 8px 0;
  line-height: 1.5;
}
.update-status strong { color: var(--fg-bright); }
.update-status button {
  display: block;
  width: 100%;
  margin-top: 8px;
  padding: 8px 10px;
  border-color: var(--accent-dim);
  color: var(--accent);
}
.update-status button:hover {
  border-color: var(--accent);
}
.update-ok { color: var(--ok); }
.update-err { color: var(--err); }
.update-warn { color: var(--accent); }
.update-available { color: var(--fg); }
.update-notes {
  color: var(--fg-dim);
  font-size: 11px;
  padding: 6px 0;
  max-height: 120px;
  overflow-y: auto;
  line-height: 1.4;
}
.update-notes p { margin: 0 0 4px; }
.update-notes ul { margin: 2px 0; padding-left: 16px; }
.update-notes li { margin: 1px 0; }
.update-notes h1, .update-notes h2, .update-notes h3 { font-size: 11px; margin: 4px 0 2px; color: var(--fg); }
.update-confirm {
  display: flex;
  gap: 8px;
  padding: 6px 0;
}
.update-confirm button { width: auto; }
.update-sig {
  font-size: 11px;
}
.update-key-truncated {
  cursor: pointer;
}
.update-key-truncated:hover {
  color: var(--accent);
}
.update-key-expanded {
  word-break: break-all;
  user-select: all;
  cursor: pointer;
  color: var(--fg-bright);
}
/* ── UPDATE BUTTON IN OVERFLOW TRAY ── */
.toolbar-update-btn {
  color: var(--accent) !important;
}

.settings-about {
  margin-top: 24px;
  padding-top: 12px;
  border-top: 1px solid var(--border);
  font-size: 11px;
  color: var(--fg-dim);
  display: flex;
  flex-direction: column;
  gap: 2px;
}
.settings-about a {
  color: var(--accent);
  text-decoration: none;
}
.settings-about a:hover { text-decoration: underline; }

/* ── FIND BAR ── */
.find-bar {
  display: none;
  flex-direction: column;
  position: sticky;
  top: 33px;
  z-index: 99;
  float: right;
  max-width: 400px;
  width: 100%;
  background: var(--bg1);
  border: 1px solid var(--border);
  border-top: none;
  padding: 6px 8px;
  gap: 4px;
}
.find-row {
  display: flex;
  align-items: center;
  gap: 4px;
}
.find-replace-row {
  display: none;
  align-items: center;
  gap: 4px;
}
.find-bar.show-replace .find-replace-row { display: flex; }
.find-bar input[type="text"] {
  flex: 1;
  background: var(--bg2);
  border: 1px solid var(--border);
  color: var(--fg-bright);
  font-family: var(--mono);
  font-size: 12px;
  padding: 4px 8px;
  outline: none;
  min-width: 0;
}
.find-bar input[type="text"]:focus {
  border-color: var(--border-hi);
}
.find-count {
  font-size: 10px;
  color: var(--fg-dim);
  white-space: nowrap;
  min-width: 50px;
  text-align: center;
  letter-spacing: 1px;
}
.find-bar button {
  padding: 3px 8px;
  font-size: 10px;
  min-width: 28px;
}
.find-bar button.active {
  color: var(--accent);
  border-color: var(--accent-dim);
}
body.presenting .find-bar { display: none !important; }

/* ── SEARCH OVERLAY ── */
.search-overlay {
  position: absolute;
  top: 0; left: 0; right: 0; bottom: 0;
  padding: 8px 10px 8px calc(var(--gutter) + 10px);
  font-family: var(--mono);
  font-size: var(--editor-font-size);
  line-height: 1.5;
  tab-size: 2;
  white-space: pre;
  overflow: hidden;
  z-index: 1;
  pointer-events: none;
  color: transparent;
  border: 1px solid transparent;
}
.search-overlay-md {
  padding: 8px 10px;
}
.md-search-wrap {
  position: relative;
}
.search-match {
  background: rgba(200,155,60,0.25);
  color: transparent;
}
.search-match-current {
  background: rgba(200,155,60,0.5);
  outline: 1px solid var(--accent);
}

/* ── AUTOCOMPLETE MENU ── */
.ac-menu {
  position: absolute;
  z-index: 10;
  background: #1e1e1e;
  border: 1px solid #444;
  border-radius: 3px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.4);
  max-height: 200px;
  overflow-y: auto;
  font-family: var(--mono);
  font-size: var(--editor-font-size);
  min-width: 120px;
}
.ac-item {
  padding: 2px 8px;
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 6px;
  white-space: nowrap;
}
.ac-item.active,
.ac-item:hover {
  background: rgba(200,155,60,0.2);
}
.ac-kind {
  width: 16px;
  height: 16px;
  border-radius: 2px;
  font-size: 10px;
  text-align: center;
  line-height: 16px;
  flex-shrink: 0;
}
.ac-kind-var, .ac-kind-def { color: #5ca7e4; }
.ac-kind-fn { color: #c89b3c; }
.ac-kind-kw { color: #cc7832; }
.ac-kind-const { color: #9876aa; }
.ac-kind-prop { color: #6a8759; }
.ac-text { color: var(--fg-bright); }
.ac-detail {
  margin-left: auto;
  padding-left: 12px;
  color: var(--fg-dim);
  font-size: 11px;
}
.ac-match { font-weight: bold; }
.ac-sig-hint {
  position: absolute;
  z-index: 10;
  background: #1e1e1e;
  border: 1px solid #444;
  border-radius: 3px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.4);
  padding: 3px 8px;
  font-family: var(--mono);
  font-size: var(--editor-font-size);
  white-space: nowrap;
  display: flex;
  gap: 10px;
  align-items: baseline;
}
.ac-sig-fn { color: var(--fg-bright); }
.ac-sig-active { color: var(--accent); font-weight: bold; text-decoration: underline; }
.ac-sig-desc { color: var(--fg-dim); font-size: 11px; }
:root.light .ac-sig-hint {
  background: #eae8e3;
  border-color: #b0ab9f;
  box-shadow: 0 2px 8px rgba(0,0,0,0.15);
}
:root.light .ac-menu {
  background: #eae8e3;
  border-color: #b0ab9f;
  box-shadow: 0 2px 8px rgba(0,0,0,0.15);
}
:root.light .ac-item.active,
:root.light .ac-item:hover {
  background: rgba(153,107,31,0.15);
}

/* ── WORKSHOP PANEL ── */
.workshop-overlay {
  display: none;
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.3);
  z-index: 900;
}
.workshop-overlay.visible { display: block; }
.workshop-panel {
  position: fixed;
  top: 0;
  right: -380px;
  bottom: 0;
  width: 360px;
  max-width: 90vw;
  background: var(--bg1);
  border-left: 1px solid var(--border);
  z-index: 901;
  display: flex;
  flex-direction: column;
  font-family: var(--mono);
  font-size: 13px;
  color: var(--fg);
  transition: right 0.25s ease;
  overflow: hidden;
}
.workshop-panel.open { right: 0; }
.workshop-tab {
  position: fixed;
  right: 0;
  top: 50%;
  transform: translateY(-50%) rotate(180deg);
  writing-mode: vertical-rl;
  background: var(--bg1);
  border: 1px solid var(--border);
  border-right: none;
  color: var(--accent);
  font-family: var(--mono);
  font-size: 10px;
  letter-spacing: 2px;
  text-transform: uppercase;
  padding: 10px 5px;
  cursor: pointer;
  z-index: 902;
  transition: right 0.25s ease;
}
.workshop-tab:hover { background: var(--bg2); }
.workshop-panel.open ~ .workshop-tab { right: min(360px, 90vw); }
.workshop-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 16px 16px 12px;
  border-bottom: 1px solid var(--border);
}
.workshop-title {
  color: var(--accent);
  font-size: 11px;
  letter-spacing: 2px;
  text-transform: uppercase;
}
.workshop-close {
  background: none;
  border: 1px solid var(--border);
  color: var(--fg-dim);
  font-size: 18px;
  width: 28px; height: 28px;
  display: flex; align-items: center; justify-content: center;
  padding: 0; cursor: pointer;
  text-transform: none;
  letter-spacing: 0;
}
.workshop-close:hover { border-color: var(--err); color: var(--err); }
.workshop-body {
  flex: 1;
  overflow-y: auto;
  padding: 16px;
  line-height: 1.6;
}
.workshop-body h1, .workshop-body h2, .workshop-body h3 {
  color: var(--fg-bright);
  margin: 1em 0 0.5em;
}
.workshop-body h1:first-child, .workshop-body h2:first-child, .workshop-body h3:first-child {
  margin-top: 0;
}
.workshop-body code {
  background: var(--bg2);
  padding: 1px 4px;
  font-size: 0.9em;
}
.workshop-body strong { color: var(--accent); }
.workshop-pips {
  display: flex;
  justify-content: center;
  gap: 6px;
  padding: 8px 16px;
}
.workshop-pip {
  width: 8px; height: 8px;
  border-radius: 50%;
  background: var(--border);
  cursor: pointer;
}
.workshop-pip.done { background: var(--fg-dim); }
.workshop-pip.active { background: var(--accent); }
.workshop-nav {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 12px 16px;
  border-top: 1px solid var(--border);
}
.workshop-nav button {
  background: var(--bg2);
  border: 1px solid var(--border);
  color: var(--fg);
  font-family: var(--mono);
  font-size: 11px;
  padding: 4px 12px;
  cursor: pointer;
}
.workshop-nav button:hover { border-color: var(--accent); color: var(--accent); }
.workshop-nav button:disabled { opacity: 0.3; cursor: default; }
.workshop-nav button:disabled:hover { border-color: var(--border); color: var(--fg); }
.workshop-counter { color: var(--fg-dim); font-size: 11px; }

/* ── LIGHT THEME ── */
:root.light {
  --bg: #f5f4f0;
  --bg1: #eae8e3;
  --bg2: #dedad3;
  --border: #ccc8bf;
  --border-hi: #b0ab9f;
  --fg: #444;
  --fg-dim: #888;
  --fg-bright: #222;
  --accent: #996b1f;
  --accent-dim: #b8924a;
  --err: #c33;
  --ok: #287;
}
:root.light .cell[data-type="code"] .cell-type { color: #4a7a9e; }
:root.light .cell[data-type="css"]  .cell-type { color: #a56e33; }
:root.light .cell[data-type="html"] .cell-type { color: #3d8a83; }
:root.light ::-webkit-scrollbar-track { background: var(--bg); }
:root.light ::-webkit-scrollbar-thumb { background: var(--border-hi); }

/* ── TOUCH / HEADER MODES ── */
@media (hover: none) {
  .insert-bar { display: none; }
  .cell.selected .cell-insert { display: inline; }
  .cell.selected .cell-convert { display: inline; }
  .cell.selected .cell-header {
    gap: 2px;
  }
  .cell.selected .cell-btn {
    min-height: 36px;
    min-width: 36px;
    font-size: 14px;
    display: inline-flex;
    align-items: center;
    justify-content: center;
  }
}

/* compact header: ellipsis indicator, full controls on select */
@media (hover: none) {
  :root:not(.header-always):not(.header-hover) .cell-header > * { display: none; }
  :root:not(.header-always):not(.header-hover) .cell-header {
    opacity: 1;
    justify-content: center;
    padding: 1px 8px;
  }
  :root:not(.header-always):not(.header-hover) .cell-header::before {
    content: '\22ef';
    color: var(--fg-dim);
    font-size: 12px;
    opacity: 0.4;
  }
  :root:not(.header-always):not(.header-hover) .cell.selected .cell-header > * { display: inline; }
  :root:not(.header-always):not(.header-hover) .cell.selected .cell-header::before { display: none; }
  :root:not(.header-always):not(.header-hover) .cell.selected .cell-header {
    justify-content: flex-start;
    padding: 2px 8px;
  }
}

/* header-always: full header visible on all devices */
:root.header-always .cell-header { opacity: 0.6; }
:root.header-always .cell:hover .cell-header,
:root.header-always .cell.selected .cell-header { opacity: 1; }

/* header-compact: forced compact mode on all devices */
:root.header-compact .cell-header > * { display: none; }
:root.header-compact .cell-header {
  opacity: 1 !important;
  justify-content: center;
  padding: 1px 8px;
}
:root.header-compact .cell-header::before {
  content: '\22ef';
  color: var(--fg-dim);
  font-size: 12px;
  opacity: 0.4;
}
:root.header-compact .cell.selected .cell-header > * { display: inline; }
:root.header-compact .cell.selected .cell-header::before { display: none; }
:root.header-compact .cell.selected .cell-header {
  justify-content: flex-start;
  padding: 2px 8px;
}

/* ── RESPONSIVE ── */
@media (max-width: 640px) {
  /* slim top toolbar: filename + cell count only */
  .toolbar {
    flex-wrap: nowrap;
    gap: 4px;
    padding: 6px 8px;
  }
  .toolbar-title { display: none; }
  .toolbar-sep { display: none; }
  .toolbar .toolbar-add, .toolbar .toolbar-secondary { display: none; }
  .transport { display: none; }
  .toolbar-right { display: none; }
  .toolbar-filename { flex: 1; }
  .toolbar-filename input { width: 100%; }
  .toolbar-status {
    display: inline;
    font-size: 10px;
    color: var(--fg-dim);
    white-space: nowrap;
    letter-spacing: 1px;
  }

  /* bottom action bar replaces statusbar */
  .statusbar {
    display: block;
    padding: 0;
    height: 48px;
  }
  .statusbar .status-size,
  .statusbar .status-cells,
  .statusbar .status-msg,
  .statusbar .status-attr { display: none; }
  .action-bar {
    display: grid;
    grid-template-columns: repeat(5, 1fr);
    height: 48px;
  }
  /* wrapper divs for tray positioning must fill their grid cell */
  .action-bar > div {
    position: relative;
    display: flex;
  }
  .action-bar > div > button {
    flex: 1;
  }
  /* style only the 5 action buttons, not tray buttons */
  .action-bar > button,
  .action-bar > div > button {
    min-height: 48px;
    border: none;
    border-right: 1px solid var(--border);
    background: var(--bg);
    font-family: var(--mono);
    font-size: 16px;
    color: var(--fg);
    padding: 0;
    letter-spacing: 0;
    text-transform: none;
  }
  .action-bar > :last-child > button,
  .action-bar > button:last-child { border-right: none; }
  .action-bar > button:active,
  .action-bar > div > button:active { background: var(--bg2); }
  .action-bar > button.autorun-on,
  .action-bar > div > button.autorun-on {
    background: #33aa77;
    color: #111;
  }
  .action-bar > button.autorun-off,
  .action-bar > div > button.autorun-off {
    background: #dd4444;
    color: #111;
  }

  .find-bar { max-width: 100%; float: none; }
  .notebook { padding: 8px 6px 100px; }
  .cell-header { padding: 2px 4px; }
  .settings-close { width: 44px; height: 44px; font-size: 22px; }
  .settings-row { padding: 10px 0; }
  .settings-row select { min-height: 44px; font-size: 14px; padding: 4px 8px; }
  .settings-row input[type="range"] { height: 44px; }
  .help-overlay { padding: 20px 12px; }
  .settings-panel { width: 260px; }
}

</style>
</head>
<body>

<div class="help-overlay" id="helpOverlay">
<div class="help-content">
<button class="help-close-btn" onclick="$('#helpOverlay').classList.remove('visible')">&#x00d7;</button>
<h2>command mode</h2>
<div class="help-row"><span class="help-key">&#x2191; / k</span><span class="help-desc">select cell above</span></div>
<div class="help-row"><span class="help-key">&#x2193; / j</span><span class="help-desc">select cell below</span></div>
<div class="help-row"><span class="help-key">Enter</span><span class="help-desc">edit selected cell</span></div>
<div class="help-row"><span class="help-key">a</span><span class="help-desc">insert cell above</span></div>
<div class="help-row"><span class="help-key">b</span><span class="help-desc">insert cell below</span></div>
<div class="help-row"><span class="help-key">d d</span><span class="help-desc">delete cell</span></div>
<div class="help-row"><span class="help-key">z</span><span class="help-desc">undo delete</span></div>
<div class="help-row"><span class="help-key">c</span><span class="help-desc">copy cell</span></div>
<div class="help-row"><span class="help-key">v</span><span class="help-desc">paste cell below</span></div>
<div class="help-row"><span class="help-key">x</span><span class="help-desc">cut cell</span></div>
<div class="help-row"><span class="help-key">m</span><span class="help-desc">convert to markdown</span></div>
<div class="help-row"><span class="help-key">y</span><span class="help-desc">convert to code</span></div>
<div class="help-row"><span class="help-key">s</span><span class="help-desc">convert to css</span></div>
<div class="help-row"><span class="help-key">t</span><span class="help-desc">convert to html template</span></div>
<div class="help-row"><span class="help-key">h</span><span class="help-desc">collapse / expand cell</span></div>
<div class="help-row"><span class="help-key">l</span><span class="help-desc">toggle line numbers</span></div>
<div class="help-row"><span class="help-key">p</span><span class="help-desc">presentation mode</span></div>

<h2>edit mode</h2>
<div class="help-row"><span class="help-key">Esc</span><span class="help-desc">exit to command mode</span></div>
<div class="help-row"><span class="help-key">Ctrl+Enter</span><span class="help-desc">run cell</span></div>
<div class="help-row"><span class="help-key">Shift+Enter</span><span class="help-desc">run cell + advance</span></div>
<div class="help-row"><span class="help-key">Ctrl+/</span><span class="help-desc">toggle comment</span></div>
<div class="help-row"><span class="help-key">Tab</span><span class="help-desc">indent</span></div>
<div class="help-row"><span class="help-key">Shift+Tab</span><span class="help-desc">unindent</span></div>

<h2>global</h2>
<div class="help-row"><span class="help-key">F1</span><span class="help-desc">toggle this help</span></div>
<div class="help-row"><span class="help-key">Ctrl+S</span><span class="help-desc">save notebook</span></div>
<div class="help-row"><span class="help-key">Ctrl+F</span><span class="help-desc">find in notebook</span></div>
<div class="help-row"><span class="help-key">Ctrl+H</span><span class="help-desc">find and replace</span></div>

<h2>toolbar</h2>
<div class="help-row"><span class="help-key">&#x23f5; step</span><span class="help-desc">run selected cell</span></div>
<div class="help-row"><span class="help-key">&#x25b6;/&#x2016;</span><span class="help-desc">toggle reactive mode (autorun)</span></div>
<div class="help-row"><span class="help-key">&#x25b6;&#x25b6; run all</span><span class="help-desc">run all cells</span></div>

<h2>builtins</h2>
<div class="help-row"><span class="help-key">display()</span><span class="help-desc">show text, objects, or DOM elements</span></div>
<div class="help-row"><span class="help-key">canvas(w,h)</span><span class="help-desc">create a canvas element</span></div>
<div class="help-row"><span class="help-key">table(data)</span><span class="help-desc">render array of objects as table</span></div>
<div class="help-row"><span class="help-key">slider()</span><span class="help-desc">reactive range input</span></div>
<div class="help-row"><span class="help-key">dropdown()</span><span class="help-desc">reactive select input</span></div>
<div class="help-row"><span class="help-key">checkbox()</span><span class="help-desc">reactive boolean input</span></div>
<div class="help-row"><span class="help-key">textInput()</span><span class="help-desc">reactive text input</span></div>
<div class="help-row"><span class="help-key">load(url)</span><span class="help-desc">import ESM module (cached)</span></div>
<div class="help-row"><span class="help-key">install(url)</span><span class="help-desc">import + embed in HTML on save</span></div>
<div class="help-row"><span class="help-key">installBinary(url)</span><span class="help-desc">fetch binary asset + embed gzipped</span></div>
<div class="help-row"><span class="help-key">invalidation</span><span class="help-desc">promise that resolves before cell re-runs</span></div>
<div class="help-row"><span class="help-key">md``</span><span class="help-desc">markdown tagged template</span></div>
<div class="help-row"><span class="help-key">html``</span><span class="help-desc">HTML tagged template</span></div>
<div class="help-row"><span class="help-key">css``</span><span class="help-desc">CSS tagged template</span></div>
<div class="help-row"><span class="help-key">workshop(pages)</span><span class="help-desc">interactive side panel with pages</span></div>
<div class="help-row"><span class="help-key">notebook</span><span class="help-desc">API for cells, scope, scrollTo, focus</span></div>

<h2>directives</h2>
<div class="help-row"><span class="help-key">// %manual</span><span class="help-desc">skip cell on reactive updates</span></div>
<div class="help-row"><span class="help-key">// %norun</span><span class="help-desc">skip cell on Run All</span></div>
<div class="help-row"><span class="help-key">// %hide</span><span class="help-desc">hide cell in present mode</span></div>
<div class="help-row"><span class="help-key">// %cellName &lt;label&gt;</span><span class="help-desc">name cell in DevTools</span></div>
<div class="help-row"><span class="help-key">// %outputId &lt;id&gt;</span><span class="help-desc">set id on output div</span></div>
<div class="help-row"><span class="help-key">// %outputClass &lt;cls&gt;</span><span class="help-desc">add classes to output div</span></div>
<div class="help-row"><span class="help-key">// %goto &lt;label&gt;</span><span class="help-desc">jump to named cell after execution</span></div>
<div class="help-row"><span class="help-key">// %collapsed</span><span class="help-desc">start cell collapsed</span></div>

<div class="help-close">press F1 or Esc to close</div>
</div>
</div>

<div class="settings-overlay" id="settingsOverlay" onclick="if(event.target===this)toggleSettings()"></div>
<div class="settings-panel" id="settingsPanel">
  <button class="settings-close" onclick="toggleSettings()">&#x00d7;</button>
  <h2>theme</h2>
  <div class="settings-row">
    <label>color scheme</label>
    <select id="setTheme" onchange="applyTheme(this.value)">
      <option value="dark">dark</option>
      <option value="light">light</option>
    </select>
  </div>

  <h2>editor</h2>
  <div class="settings-row">
    <label>font size</label>
    <input type="range" id="setFontSize" min="10" max="20" value="13" oninput="applyFontSize(this.value)">
    <span class="settings-val" id="setFontSizeVal">13</span>
  </div>
  <div class="settings-row">
    <label>line numbers</label>
    <select id="setLineNumbers" onchange="applyLineNumbers(this.value)">
      <option value="on" selected>on</option>
      <option value="off">off</option>
    </select>
  </div>

  <h2>notebook</h2>
  <div class="settings-row">
    <label>max width</label>
    <select id="setWidth" onchange="applyWidth(this.value)">
      <option value="720">narrow</option>
      <option value="860" selected>default</option>
      <option value="1100">wide</option>
      <option value="100%">full</option>
    </select>
  </div>
  <div class="settings-row">
    <label>cell header</label>
    <select id="setHeader" onchange="applyHeader(this.value)">
      <option value="auto" selected>auto</option>
      <option value="always">always visible</option>
      <option value="compact">compact</option>
      <option value="hover">hover only</option>
    </select>
  </div>

  <h2>execution</h2>
  <div class="settings-row">
    <label>mode</label>
    <select id="setExecMode" onchange="applyExecMode(this.value)">
      <option value="reactive">reactive</option>
      <option value="manual">manual</option>
    </select>
  </div>
  <div class="settings-row">
    <label>run on load</label>
    <select id="setRunOnLoad" onchange="applyRunOnLoad(this.value)">
      <option value="yes">yes</option>
      <option value="no">no</option>
    </select>
  </div>
  <div class="settings-row">
    <label>show run toggle</label>
    <select id="setShowToggle" onchange="applyShowToggle(this.value)">
      <option value="yes">yes</option>
      <option value="no">no</option>
    </select>
  </div>
  <div class="settings-desc">
    <strong>reactive</strong>: cells auto-run on edit, changes propagate.<br>
    <strong>manual</strong>: only Ctrl+Enter, Shift+Enter, or Run All.
  </div>
  <div class="settings-row">
    <label>global override</label>
    <select id="setGlobalExecMode" onchange="applyGlobalExecMode(this.value)">
      <option value="">(notebook default)</option>
      <option value="reactive">always reactive</option>
      <option value="manual">always manual</option>
    </select>
  </div>
  <div class="settings-row">
    <label>global run on load</label>
    <select id="setGlobalRunOnLoad" onchange="applyGlobalRunOnLoad(this.value)">
      <option value="">(notebook default)</option>
      <option value="yes">always run</option>
      <option value="no">never run</option>
    </select>
  </div>

  <h2>modules</h2>
  <div id="moduleList"></div>
  <h2>binaries</h2>
  <div id="binaryList"></div>

  <div class="settings-about">
    <span id="aboutVersion"></span>
    <span id="aboutBuild"></span>
    <span id="aboutRuntime"></span>
    <a href="https://github.com/endarthur/auditable" target="_blank">github.com/endarthur/auditable</a>
  </div>
</div>

<div class="update-overlay" id="updateOverlay" onclick="if(event.target===this)toggleUpdate()"></div>
<div class="update-panel" id="updatePanel">
  <button class="settings-close" onclick="toggleUpdate()">&#x00d7;</button>
  <h2>update</h2>
  <div class="settings-row">
    <label>version</label>
    <span id="updateCurrentVer">v0.0.0</span>
  </div>
  <div class="settings-row">
    <label>release</label>
    <span id="updateRelease">dev</span>
  </div>
  <div class="settings-row">
    <label>signature</label>
    <span id="updateSigStatus" class="update-sig">checking...</span>
  </div>
  <div class="settings-row">
    <label>public key</label>
    <span id="updatePubKey" class="update-sig">-</span>
  </div>
  <div id="updateStatus" class="update-status"></div>
  <div class="update-actions">
    <button id="updateCheckBtn" onclick="checkForUpdate()">check for updates</button>
    <button onclick="updateFromFile()">update from file</button>
  </div>
</div>

<div class="toolbar">
  <span class="toolbar-title">auditable</span>
  <span class="toolbar-badges" id="toolbarBadges"></span>
  <span class="toolbar-sep"></span>
  <span class="toolbar-filename">
    <input type="text" id="docTitle" value="KB2D — 2D kriging" spellcheck="false">
  </span>
  <span class="toolbar-status" id="toolbarStatus"></span>
  <button class="toolbar-add" onclick="addCellWithUndo('code','',S.selectedId)">+ code</button>
  <button class="toolbar-add" onclick="addCellWithUndo('md','',S.selectedId)">+ md</button>
  <button class="toolbar-secondary" onclick="addCellWithUndo('css','',S.selectedId)">+ css</button>
  <button class="toolbar-secondary" onclick="addCellWithUndo('html','',S.selectedId)">+ html</button>
  <span class="toolbar-sep"></span>
  <span class="transport">
    <button onclick="runSelectedCell()" title="run cell + advance (Shift+Enter)">&#x23f5;</button>
    <button id="autorunBtn" class="autorun-on" onclick="toggleAutorun()" title="reactive mode &#x2014; cells auto-run on edit">&#x25b6;</button>
    <button onclick="runAll()" title="run all cells">&#x25b6;&#x25b6;</button>
  </span>
  <span class="toolbar-right">
    <span class="save-split">
      <button class="accent" onclick="saveNotebook()"><span id="saveLabel">save</span></button><button class="accent save-caret" onclick="toggleSaveTray()">&#x25be;</button>
      <div class="save-tray" id="saveTray">
        <button onclick="setSaveMode('normal');saveNotebook()">save</button>
        <button onclick="setSaveMode('packed');saveNotebook()">save packed</button>
        <button onclick="exportAsTxt();toggleSaveTray()">export .txt</button>
      </div>
    </span>
    <div class="toolbar-overflow">
      <button onclick="toggleToolbarMenu()" title="more">&#x22ef;</button>
      <div class="toolbar-overflow-tray">
        <button onclick="newNotebook();toggleToolbarMenu()">new</button>
        <button onclick="collapseAll();toggleToolbarMenu()">collapse all</button>
        <button onclick="expandAll();toggleToolbarMenu()">expand all</button>
        <button onclick="$('#helpOverlay').classList.toggle('visible');toggleToolbarMenu()">help (F1)</button>
        <button onclick="toggleSettings();toggleToolbarMenu()">settings</button>
        <button class="toolbar-update-btn" onclick="toggleUpdate();toggleToolbarMenu()">update</button>
        <button onclick="togglePresent();toggleToolbarMenu()">present</button>
        <button onclick="openFind(false);toggleToolbarMenu()">find (Ctrl+F)</button>
      </div>
    </div>
  </span>
</div>

<div class="find-bar" id="findBar">
  <div class="find-row">
    <input type="text" id="findInput" placeholder="find" spellcheck="false" autocomplete="off">
    <span class="find-count" id="findCount"></span>
    <button id="findRegexBtn" title="use regex">.*</button>
    <button id="findCaseBtn" title="match case">Aa</button>
    <button id="findPrevBtn" title="previous (Shift+Enter)">&#x2191;</button>
    <button id="findNextBtn" title="next (Enter)">&#x2193;</button>
    <button id="findCloseBtn" title="close (Esc)">&#x00d7;</button>
  </div>
  <div class="find-replace-row" id="findReplaceRow">
    <input type="text" id="replaceInput" placeholder="replace" spellcheck="false" autocomplete="off">
    <button id="findReplaceBtn">replace</button>
    <button id="findReplaceAllBtn">all</button>
  </div>
</div>

<button class="present-exit" onclick="togglePresent()">&#x2715; exit</button>

<div class="notebook" id="notebook">
  <!-- cells go here -->
</div>

<div class="statusbar">
  <span class="status-size" id="statusSize"></span>
  <span class="status-cells" id="statusCells">0 cells</span>
  <span class="status-msg" id="statusMsg"></span>
  <span class="status-attr">
    <a href="https://endarthur.github.io" target="_blank">endarthur</a>
    <span>&middot;</span>
    <a href="https://gentropic.org" target="_blank">geoscientific chaos union</a>
    <span>&middot;</span>
    <a href="https://github.com/endarthur/auditable" target="_blank" title="source on GitHub"><svg width="14" height="14" viewBox="0 0 16 16" fill="currentColor"><path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"/></svg></a>
  </span>
  <div class="action-bar">
    <div>
      <div class="action-add-tray">
        <button onclick="insertAt(S.selectedId,'code');toggleAddTray()">+ code</button>
        <button onclick="insertAt(S.selectedId,'md');toggleAddTray()">+ md</button>
        <button onclick="insertAt(S.selectedId,'css');toggleAddTray()">+ css</button>
        <button onclick="insertAt(S.selectedId,'html');toggleAddTray()">+ html</button>
      </div>
      <button class="action-add" onclick="toggleAddTray()">+</button>
    </div>
    <button onclick="runSelectedCell()" title="run cell + advance">&#x23f5;</button>
    <button id="autorunBtnMobile" class="autorun-on" onclick="toggleAutorun()" title="autorun">&#x25b6;</button>
    <button onclick="runAll()" title="run all">&#x25b6;&#x25b6;</button>
    <div>
      <div class="action-more-tray">
        <button onclick="newNotebook();toggleMoreTray()">new</button>
        <button id="mobileSaveBtn" class="active-mode" onclick="setSaveMode('normal');saveNotebook();toggleMoreTray()">save</button>
        <button id="mobilePackBtn" onclick="setSaveMode('packed');saveNotebook();toggleMoreTray()">save packed</button>
        <button onclick="collapseAll();toggleMoreTray()">collapse all</button>
        <button onclick="expandAll();toggleMoreTray()">expand all</button>
        <button onclick="$('#helpOverlay').classList.toggle('visible');toggleMoreTray()">help</button>
        <button onclick="toggleSettings();toggleMoreTray()">settings</button>
        <button class="toolbar-update-btn" onclick="toggleUpdate();toggleMoreTray()">update</button>
        <button onclick="togglePresent();toggleMoreTray()">present</button>
        <button onclick="openFind(false);toggleMoreTray()">find</button>
      </div>
      <button class="action-more" onclick="toggleMoreTray()">&#x22ef;</button>
    </div>
  </div>
</div>


<!-- cell data: JSON array of {type, code, collapsed?} -->
<!--AUDITABLE-DATA
[{"type":"md","code":"# KB2D — 2D kriging in WebAssembly\n\nordinary kriging on a 2D grid, using the [GSLIB](https://geostatisticslessons.com/lessons/gslib) `kb2d` program compiled from [atra](ext/atra/SPEC.md) to WebAssembly. adjust the variogram model, range, sill, and nugget to see how they shape the interpolated surface. compare with the [IDW example](example_idw.html) or the [SGSIM example](example_gslib_sgsim.html) — kriging accounts for spatial correlation structure, IDW does not."},{"type":"code","code":"// parameters\nconst modelNames = [\"spherical\", \"exponential\", \"gaussian\"];\nconst modelIdx = ui.dropdown(\"variogram model\", modelNames);\n\nconst range0 = ui.slider(\"range\", 0.35, {min: 0.05, max: 1.0, step: 0.01});\nconst sill = ui.slider(\"sill (cc)\", 0.8, {min: 0.1, max: 2.0, step: 0.05});\nconst nugget = ui.slider(\"nugget (c\\u2080)\", 0.1, {min: 0.0, max: 0.5, step: 0.01});\nconst nPts = ui.slider(\"samples\", 20, {min: 5, max: 60, step: 1});\nconst gridN = ui.slider(\"grid\", 60, {min: 20, max: 120, step: 5});\nconst showPts = ui.checkbox(\"show samples\", true);\nconst showVar = ui.checkbox(\"show variance\", false);"},{"type":"code","code":"// generate seeded sample data\nfunction mulberry32(a) {\n  return function() {\n    a |= 0; a = a + 0x6D2B79F5 | 0;\n    let t = Math.imul(a ^ a >>> 15, 1 | a);\n    t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;\n    return ((t ^ t >>> 14) >>> 0) / 4294967296;\n  };\n}\nconst rng = mulberry32(42);\n\nconst samples = [];\nfor (let i = 0; i < nPts; i++) {\n  const x = rng(), y = rng();\n  const trend = 0.5 * Math.sin(x * 4) * Math.cos(y * 3) + 0.5;\n  samples.push([x, y, 0.3 * rng() + 0.7 * trend]);\n}"},{"type":"code","code":"// run kb2d\nconst { kb2d } = await load(\"@atra/gslib\");\nconst t0 = performance.now();\nconst result = kb2d({\n  data: samples,\n  grid: { nx: gridN, ny: gridN, xsiz: 1/gridN, ysiz: 1/gridN },\n  variogram: { nugget, structures: [{ type: modelIdx, contribution: sill, range: range0 }] },\n  search: { radius: 2.0, ndmax: Math.min(nPts, 20) },\n});\nconst elapsed = (performance.now() - t0).toFixed(2);\nconst est = result.est, estv = result.var;"},{"type":"code","code":"// render\nfunction viridis(t) {\n  t = Math.max(0, Math.min(1, t));\n  const r = Math.round(255 * Math.max(0, Math.min(1,\n    0.267 + t * (0.004 + t * (5.294 + t * (-14.05 + t * 8.5))))));\n  const g = Math.round(255 * Math.max(0, Math.min(1,\n    0.004 + t * (1.384 + t * (0.098 + t * (-2.74 + t * 2.23))))));\n  const b = Math.round(255 * Math.max(0, Math.min(1,\n    0.329 + t * (1.44 + t * (-5.11 + t * (6.87 + t * -3.57))))));\n  return `rgb(${r},${g},${b})`;\n}\n\nfunction magma(t) {\n  t = Math.max(0, Math.min(1, t));\n  const r = Math.round(255 * Math.max(0, Math.min(1,\n    -0.002 + t * (0.804 + t * (6.37 + t * (-15.96 + t * 9.78))))));\n  const g = Math.round(255 * Math.max(0, Math.min(1,\n    0.0 + t * (-0.398 + t * (4.23 + t * (-7.76 + t * 4.95))))));\n  const b = Math.round(255 * Math.max(0, Math.min(1,\n    0.015 + t * (2.68 + t * (-9.39 + t * (14.23 + t * -6.53))))));\n  return `rgb(${r},${g},${b})`;\n}\n\nconst data = showVar ? estv : est;\nconst cmap = showVar ? magma : viridis;\n\nlet vmin = Infinity, vmax = -Infinity;\nfor (let i = 0; i < data.length; i++) {\n  if (data[i] < -900) continue; // skip UNEST\n  if (data[i] < vmin) vmin = data[i];\n  if (data[i] > vmax) vmax = data[i];\n}\nconst vrange = vmax - vmin || 1;\n\nconst size = Math.min(500, window.innerWidth - 80);\nconst c = ui.canvas(size, size);\nconst ctx = c.getContext(\"2d\");\n\nconst cellW = size / gridN;\nfor (let iy = 0; iy < gridN; iy++) {\n  for (let ix = 0; ix < gridN; ix++) {\n    const v = data[iy * gridN + ix];\n    if (v < -900) { ctx.fillStyle = \"#222\"; }\n    else { ctx.fillStyle = cmap((v - vmin) / vrange); }\n    ctx.fillRect(ix * cellW, iy * cellW, cellW + 0.5, cellW + 0.5);\n  }\n}\n\nif (showPts) {\n  for (const [sx, sy, sv] of samples) {\n    ctx.beginPath();\n    ctx.arc(sx * size, sy * size, 4, 0, Math.PI * 2);\n    ctx.fillStyle = \"#fff\";\n    ctx.fill();\n    ctx.lineWidth = 1.5;\n    ctx.strokeStyle = \"#000\";\n    ctx.stroke();\n  }\n}\n\nconst label = showVar ? \"kriging variance\" : \"kriging estimate\";\nui.display(`${label} \\u00b7 ${modelIdx} \\u00b7 ${gridN}\\u00d7${gridN} grid \\u00b7 ${nPts} samples \\u00b7 ${elapsed} ms`);"},{"type":"md","code":"**how it works:** `kb2d` solves the kriging system for each grid node — a linear system whose coefficients come from the variogram model evaluated at inter-sample distances. the **nugget** adds a discontinuity at the origin (measurement noise), the **sill** is the maximum variance, and the **range** controls how far spatial correlation extends. toggle **show variance** to see the kriging variance — it's lowest near sample points and highest where data is sparse, regardless of the actual values.\n\nthe full GSLIB `kb2d` program (with `setrot`, `cova3`, `ksol`) runs as pre-compiled WebAssembly via `load(\"@atra/gslib\")`. the same binary includes all 23 GSLIB routines — `sgsim`, `kt3d`, `nscore`, and more."}]
AUDITABLE-DATA-->
<!-- installed modules: base64-encoded JSON mapping URLs to {source, cellId} -->
<!--AUDITABLE-MODULES
eyJAYXRyYS9nc2xpYiI6eyJzb3VyY2UiOiIvLyBnc2xpYiDigJQgY29tcGlsZWQgYnkgYXRyYWNc
bmNvbnN0IF9ieXRlcyA9IG5ldyBVaW50OEFycmF5KFswLDk3LDExNSwxMDksMSwwLDAsMCwxLDEz
Miw0LDIzLDk2LDEsMTI0LDEsMTI0LDk2LDIsMTI0LDEyNCwxLDEyNCw5NiwxLDEyNywxLDEyNCw5
NiwzLDEyNCwxMjcsMTI3LDAsOTYsNiwxMjQsMTI0LDEyNCwxMjQsMTI0LDEyNCwxLDEyNCw5Niw2
LDEyNywxMjcsMTI3LDEyNywxMjQsMTI3LDAsOTYsNSwxMjcsMTI0LDEyNCwxMjQsMTI3LDAsOTYs
NywxMjQsMTI0LDEyNCwxMjQsMTI0LDEyNywxMjcsMCw5Niw4LDEyNCwxMjQsMTI0LDEyNCwxMjQs
MTI0LDEyNywxMjcsMSwxMjQsOTYsOCwxMjcsMTI3LDEyNywxMjcsMTI3LDEyNywxMjcsMTI3LDAs
OTYsMTMsMTI3LDEyNywxMjcsMTI3LDEyNywxMjcsMTI3LDEyNywxMjcsMTI3LDEyNCwxMjQsMTI3
LDAsOTYsMTEsMTI0LDEyNywxMjcsMTI3LDEyNCwxMjQsMTI3LDEyNCwxMjcsMTI0LDEyNywxLDEy
NCw5NiwxNCwxMjQsMTI0LDEyNCwxMjQsMTI0LDEyNCwxMjcsMTI0LDEyNywxMjcsMTI3LDEyNywx
MjcsMTI3LDAsOTYsMjQsMTI3LDEyNCwxMjQsMTI3LDEyNCwxMjQsMTI3LDEyNCwxMjQsMTI3LDEy
NywxMjcsMTI3LDEyNywxMjcsMTI3LDEyNywxMjcsMTI3LDEyNywxMjcsMTI3LDEyNywxMjcsMCw5
NiwxMywxMjcsMTI0LDEyNywxMjQsMTI3LDEyNCwxMjcsMTI3LDEyNCwxMjcsMTI3LDEyNywxMjcs
MCw5NiwzMiwxMjQsMTI0LDEyNCwxMjQsMTI3LDEyNywxMjcsMTI3LDEyNywxMjcsMTI3LDEyNywx
MjcsMTI3LDEyNywxMjcsMTI3LDEyNywxMjcsMTI0LDEyNCwxMjcsMTI0LDEyNCwxMjcsMTI0LDEy
NCwxMjcsMTI3LDEyNywxMjcsMTI3LDAsOTYsNSwxMjcsMTI3LDEyNywxMjcsMTI3LDAsOTYsMzks
MTI3LDEyNywxMjQsMTI0LDEyNCwxMjQsMTI3LDEyNywxMjcsMTI3LDEyNywxMjcsMTI3LDEyNywx
MjQsMTI3LDEyNCwxMjcsMTI0LDEyNywxMjcsMTI3LDEyNywxMjcsMTI3LDEyNywxMjcsMTI3LDEy
NywxMjcsMTI3LDEyNywxMjcsMTI3LDEyNywxMjcsMTI3LDEyNywxMjcsMCw5Niw2MiwxMjcsMTI3
LDEyNywxMjQsMTI0LDEyNCwxMjQsMTI0LDEyNCwxMjcsMTI3LDEyNywxMjcsMTI3LDEyNywxMjcs
MTI3LDEyNywxMjcsMTI3LDEyNCwxMjQsMTI0LDEyNCwxMjQsMTI0LDEyNywxMjQsMTI3LDEyNywx
MjQsMTI3LDEyNywxMjcsMTI3LDEyNywxMjcsMTI3LDEyNywxMjcsMTI3LDEyNywxMjcsMTI3LDEy
NywxMjcsMTI3LDEyNywxMjcsMTI3LDEyNywxMjcsMTI3LDEyNywxMjcsMTI3LDEyNywxMjcsMTI3
LDEyNywxMjcsMTI3LDAsOTYsMjgsMTI3LDEyNCwxMjcsMTI3LDEyNywxMjcsMTI3LDEyNywxMjQs
MTI3LDEyNywxMjcsMTI0LDEyNCwxMjQsMTI3LDEyNywxMjcsMTI3LDEyNywxMjcsMTI3LDEyNywx
MjcsMTI3LDEyNywxMjcsMTI3LDAsOTYsMjksMTI3LDEyNywxMjcsMTI3LDEyNywxMjcsMTI3LDEy
NCwxMjQsMTI0LDEyNCwxMjQsMTI0LDEyNywxMjcsMTI3LDEyNywxMjcsMTI3LDEyNywxMjcsMTI3
LDEyNywxMjcsMTI3LDEyNywxMjcsMTI3LDEyNywwLDk2LDUwLDEyNywxMjcsMTI3LDEyNCwxMjQs
MTI0LDEyNywxMjQsMTI3LDEyNywxMjcsMTI3LDEyNywxMjcsMTI3LDEyNywxMjcsMTI3LDEyNywx
MjcsMTI3LDEyNywxMjcsMTI3LDEyNywxMjcsMTI3LDEyNywxMjcsMTI3LDEyNCwxMjcsMTI3LDEy
NywxMjcsMTI3LDEyNCwxMjcsMTI3LDEyNywxMjcsMTI0LDEyNywxMjcsMTI3LDEyNywxMjcsMTI3
LDEyNywxMjcsMCw5Niw3MywxMjcsMTI3LDEyNywxMjQsMTI0LDEyNCwxMjQsMTI0LDEyNCwxMjcs
MTI3LDEyNywxMjcsMTI3LDEyNywxMjcsMTI0LDEyNywxMjcsMTI0LDEyNCwxMjQsMTI0LDEyNCwx
MjQsMTI3LDEyNywxMjcsMTI3LDEyNCwxMjcsMTI3LDEyNywxMjcsMTI3LDEyNCwxMjcsMTI3LDEy
NywxMjcsMTI3LDEyNywxMjcsMTI3LDEyNywxMjcsMTI3LDEyNywxMjcsMTI3LDEyNywxMjQsMTI3
LDEyNywxMjcsMTI3LDEyNywxMjcsMTI3LDEyNywxMjcsMTI3LDEyNywxMjcsMTI3LDEyNywxMjcs
MTI3LDEyNywxMjcsMTI3LDEyNywxMjcsMCwyLDY5LDYsNCwxMDksOTcsMTE2LDEwNCwyLDEwOCwx
MTAsMCwwLDQsMTA5LDk3LDExNiwxMDQsMywxMDEsMTIwLDExMiwwLDAsNCwxMDksOTcsMTE2LDEw
NCwzLDExMiwxMTEsMTE5LDAsMSw0LDEwOSw5NywxMTYsMTA0LDMsMTE1LDEwNSwxMTAsMCwwLDQs
MTA5LDk3LDExNiwxMDQsMyw5OSwxMTEsMTE1LDAsMCwzLDEwMSwxMTAsMTE4LDYsMTA5LDEwMSwx
MDksMTExLDExNCwxMjEsMiwwLDEsMywyNCwyMywyLDMsMCw0LDUsNiw3LDgsOSwxMCwxMSwxMiwx
MywxNCwxNSwxNiwxNiwxNywxOCwxOSwyMCwyMSwyMiw3LDIxMSwyLDIzLDEyLDEwMywxMTUsMTA4
LDEwNSw5OCw0Niw5Nyw5OSwxMTEsMTE0LDExMCwxMDUsMCw1LDEyLDEwMywxMTUsMTA4LDEwNSw5
OCw0NiwxMDMsOTcsMTE3LDEwNSwxMTAsMTE4LDAsNiwxMCwxMDMsMTE1LDEwOCwxMDUsOTgsNDYs
MTAzLDk5LDExNywxMDksMCw3LDEyLDEwMywxMTUsMTA4LDEwNSw5OCw0NiwxMTIsMTExLDExOSwx
MDUsMTEwLDExNiwwLDgsMTIsMTAzLDExNSwxMDgsMTA1LDk4LDQ2LDEwOCwxMTEsOTksOTcsMTE2
LDEwMSwwLDksMTMsMTAzLDExNSwxMDgsMTA1LDk4LDQ2LDEwMywxMDEsMTE2LDEwNSwxMTAsMTAw
LDEyMCwwLDEwLDEyLDEwMywxMTUsMTA4LDEwNSw5OCw0NiwxMTUsMTAxLDExNiwxMTQsMTExLDEx
NiwwLDExLDEyLDEwMywxMTUsMTA4LDEwNSw5OCw0NiwxMTUsMTEzLDEwMCwxMDUsMTE1LDExNiww
LDEyLDEyLDEwMywxMTUsMTA4LDEwNSw5OCw0NiwxMTUsMTExLDExNCwxMTYsMTAxLDEwOSwwLDEz
LDEyLDEwMywxMTUsMTA4LDEwNSw5OCw0NiwxMTAsMTE1LDk5LDExMSwxMTQsMTAxLDAsMTQsMTIs
MTAzLDExNSwxMDgsMTA1LDk4LDQ2LDk4LDk3LDk5LDEwNywxMTYsMTE0LDAsMTUsMTEsMTAzLDEx
NSwxMDgsMTA1LDk4LDQ2LDk5LDExMSwxMTgsOTcsNTEsMCwxNiwxMywxMDMsMTE1LDEwOCwxMDUs
OTgsNDYsMTE1LDEwMSwxMTYsMTE1LDExNywxMTIsMTE0LDAsMTcsMTMsMTAzLDExNSwxMDgsMTA1
LDk4LDQ2LDExMiwxMDUsOTksMTA3LDExNSwxMTcsMTEyLDAsMTgsMTQsMTAzLDExNSwxMDgsMTA1
LDk4LDQ2LDExNSwxMTQsOTksMTA0LDExNSwxMTcsMTEyLDExNCwwLDE5LDEwLDEwMywxMTUsMTA4
LDEwNSw5OCw0NiwxMDcsMTE1LDExMSwxMDgsMCwyMCwxMSwxMDMsMTE1LDEwOCwxMDUsOTgsNDYs
MTA3LDExNiwxMTUsMTExLDEwOCwwLDIxLDEwLDEwMywxMTUsMTA4LDEwNSw5OCw0NiwxMDcsOTgs
NTAsMTAwLDAsMjIsMTAsMTAzLDExNSwxMDgsMTA1LDk4LDQ2LDEwNywxMTYsNTEsMTAwLDAsMjMs
MTIsMTAzLDExNSwxMDgsMTA1LDk4LDQ2LDk5LDExNiw5Nyw5OCwxMDgsMTAxLDAsMjQsMTIsMTAz
LDExNSwxMDgsMTA1LDk4LDQ2LDExNSwxMTQsOTksMTA0LDExMCwxMDAsMCwyNSwxMSwxMDMsMTE1
LDEwOCwxMDUsOTgsNDYsMTA3LDExNCwxMDUsMTAzLDEwMSwwLDI2LDExLDEwMywxMTUsMTA4LDEw
NSw5OCw0NiwxMTUsMTAzLDExNSwxMDUsMTA5LDAsMjcsMTAsMTQ1LDE3NSwxLDIzLDE1NywxLDIs
MSwxMjcsMSwxMjQsNjUsMCwzMywxLDIsNjQsMyw2NCwzMiwxLDY1LDEyLDc4LDEzLDEsMzIsMCwz
MiwxLDY1LDEsMTA2LDY1LDQsMTA4LDEwNiwzMiwwLDMyLDEsNjUsMSwxMDYsNjUsNCwxMDgsMTA2
LDQwLDIsMCwzMiwwLDMyLDEsNjUsNCwxMDgsMTA2LDQwLDIsMCwxMDYsNTQsMiwwLDMyLDAsMzIs
MSw2NSwxLDEwNiw2NSw0LDEwOCwxMDYsNDAsMiwwLDY1LDEyOCwxMjgsMTI4LDEyOCw0LDc4LDQs
NjQsMzIsMCwzMiwxLDY1LDEsMTA2LDY1LDQsMTA4LDEwNiwzMiwwLDMyLDEsNjUsMSwxMDYsNjUs
NCwxMDgsMTA2LDQwLDIsMCw2NSwxMjgsMTI4LDEyOCwxMjgsNCwxMDcsNTQsMiwwLDExLDMyLDEs
NjUsMSwxMDYsMzMsMSwxMiwwLDExLDExLDMyLDAsNjUsMTIsNjUsNCwxMDgsMTA2LDQwLDIsMCwx
ODMsNjgsMCwwLDAsMCwwLDAsMjA4LDY1LDE2MywzMywyLDMyLDIsMTEsMTM1LDMsMSwyLDEyNCwz
MiwyLDY1LDAsNjUsNCwxMDgsMTA2LDY1LDEsNTQsMiwwLDMyLDAsNjgsMTg3LDE4OSwyMTUsMjE3
LDIyMywxMjQsMjE5LDYxLDk5LDQsNjQsMzIsMSw2NSwwLDY1LDgsMTA4LDEwNiw2OCwwLDAsMCwz
Miw5NSwxNjAsMiw2NiwxNTQsNTcsMywwLDE1LDExLDMyLDAsNjgsMCwwLDAsMCwwLDAsMjQwLDYz
LDY4LDE4NywxODksMjE1LDIxNywyMjMsMTI0LDIxOSw2MSwxNjEsMTAwLDQsNjQsMzIsMSw2NSww
LDY1LDgsMTA4LDEwNiw2OCwwLDAsMCwzMiw5NSwxNjAsMiw2Niw1NywzLDAsMTUsMTEsMzIsMiw2
NSwwLDY1LDQsMTA4LDEwNiw2NSwwLDU0LDIsMCwzMiwwLDMzLDMsMzIsMCw2OCwwLDAsMCwwLDAs
MCwyMjQsNjMsMTAwLDQsNjQsNjgsMCwwLDAsMCwwLDAsMjQwLDYzLDMyLDMsMTYxLDMzLDMsMTEs
MzIsMSw2NSwwLDY1LDgsMTA4LDEwNiw2OCwwLDAsMCwwLDAsMCwwLDAsNTcsMywwLDMyLDAsNjgs
MCwwLDAsMCwwLDAsMjI0LDYzLDk3LDQsNjQsMTUsMTEsNjgsMCwwLDAsMCwwLDAsMjQwLDYzLDMy
LDMsMzIsMywxNjIsMTYzLDE2LDAsMTU5LDMzLDQsMzIsMSw2NSwwLDY1LDgsMTA4LDEwNiwzMiw0
LDMyLDQsNjgsOTgsMjYsMjM3LDE5NSwxNzQsMjAwLDcsNjMsMTU0LDE2Miw2OCw0OCwxNjgsMTM1
LDExNSwyMDQsMjMzLDE0OCw2MywxNTQsMTYwLDMyLDQsMTYyLDY4LDcwLDI0MSwxMDMsOTIsNzUs
MjMxLDIxMyw2MywxNTQsMTYwLDMyLDQsMTYyLDY4LDAsMCwwLDAsMCwwLDI0MCw2MywxNTQsMTYw
LDMyLDQsMTYyLDY4LDU1LDI0Miw3OCwxOTgsMTE2LDE1OSwyMTIsNjMsMTU0LDE2MCwzMiw0LDY4
LDEzNiw2OSw3LDIxOCwxOTUsMTUwLDExMSw2MywxNjIsNjgsMTA0LDk1LDEwMCw2MiwxMTUsMTI5
LDE4Niw2MywxNjAsMzIsNCwxNjIsNjgsODQsMjQwLDUyLDE3NiwyMDQsMjU0LDIyNCw2MywxNjAs
MzIsNCwxNjIsNjgsNDcsMTg5LDEzNyw0LDE2OSwyMTMsMjI2LDYzLDE2MCwzMiw0LDE2Miw2OCw4
NCwyNDcsMjA0LDE1NywyMzAsMTEwLDE4NSw2MywxNjAsMTYzLDE2MCw1NywzLDAsMzIsMCw2OCww
LDAsMCwwLDAsMCwyMjQsNjMsMTAxLDQsNjQsMzIsMSw2NSwwLDY1LDgsMTA4LDEwNiw2OCwwLDAs
MCwwLDAsMCwwLDAsMzIsMSw2NSwwLDY1LDgsMTA4LDEwNiw0MywzLDAsMTYxLDU3LDMsMCwxMSwx
MSwyNTUsMSwxLDQsMTI0LDMyLDAsMzMsMSwzMiwxLDY4LDAsMCwwLDAsMCwwLDAsMCw5OSw0LDY0
LDY4LDAsMCwwLDAsMCwwLDAsMCwzMiwxLDE2MSwzMywxLDExLDY4LDAsMCwwLDAsMCwwLDI0MCw2
Myw2OCwwLDAsMCwwLDAsMCwyNDAsNjMsNjgsMTQsMTYsMTEzLDI0LDExMywxNjYsMjA1LDYzLDMy
LDEsMTYyLDE2MCwxNjMsMzMsMiwzMiwyLDY4LDIzNiwyNDgsMTQ2LDU4LDE5MSwxMTIsMjEyLDYz
LDMyLDIsNjgsOTEsNTAsMTY4LDIyOSwyNDAsMjA5LDIxNCw2MywxNTQsMzIsMiw2OCwxMDQsOTQs
OTUsMiwyMzksMTI4LDI1Miw2MywzMiwyLDY4LDIwOCwxMjAsMjQyLDc4LDIyMSwzNSwyNTMsNjMs
MTU0LDMyLDIsNjgsNjcsNDEsMjQ0LDIxNCwyMDUsNzIsMjQ1LDYzLDE2MiwxNjAsMTYyLDE2MCwx
NjIsMTYwLDE2MiwxNjAsMTYyLDMzLDQsNjgsMCwwLDAsMCwwLDAsMCwwLDMzLDMsMzIsMSw2OCww
LDAsMCwwLDAsMCwyNCw2NCwxMDEsNCw2NCw2OCwwLDAsMCwwLDAsMCwwLDAsMzIsMSwzMiwxLDE2
Miw2OCwwLDAsMCwwLDAsMCwwLDY0LDE2MywxNjEsMTYsMSw2OCwxNjAsODQsMTg0LDUxLDY5LDEz
NiwyMTcsNjMsMTYyLDMzLDMsMTEsNjgsMCwwLDAsMCwwLDAsMjQwLDYzLDMyLDMsMzIsNCwxNjIs
MTYxLDMzLDQsMzIsMCw2OCwwLDAsMCwwLDAsMCwwLDAsMTAyLDQsNjQsMzIsNCwxNSwxMSw2OCww
LDAsMCwwLDAsMCwyNDAsNjMsMzIsNCwxNjEsMzMsNCwzMiw0LDExLDY4LDEsMSwxMjQsMzIsMSwz
MiwwLDE2MSw2OCwzNSw2NiwxNDYsMTIsMTYxLDE1NiwxOTksNTksOTksNCw2NCwzMiwzLDMyLDIs
MTYwLDY4LDAsMCwwLDAsMCwwLDAsNjQsMTYzLDMzLDYsNSwzMiwyLDMyLDMsMzIsMiwxNjEsMzIs
NCwzMiwwLDE2MSwzMiwxLDMyLDAsMTYxLDE2MywzMiw1LDE2LDIsMTYyLDE2MCwzMyw2LDExLDMy
LDYsMTEsMTUwLDEsMSwzLDEyNywzMiwyLDY1LDEsMTA3LDMzLDYsMzIsMywzMyw3LDMyLDAsMzIs
MSw2NSwxLDEwNyw2NSw4LDEwOCwxMDYsNDMsMywwLDMyLDQsMTAxLDQsNjQsMzIsNSw2NSwwLDY1
LDQsMTA4LDEwNiwzMiwzLDU0LDIsMCwxNSwxMSwyLDY0LDMsNjQsMzIsNywzMiw2LDEwNyw2NSwx
LDc0LDY5LDEzLDEsMzIsNywzMiw2LDEwNiw2NSwyLDEwOSwzMyw4LDMyLDAsMzIsMyw2NSwxLDEw
Nyw2NSw4LDEwOCwxMDYsNDMsMywwLDMyLDAsMzIsMiw2NSwxLDEwNyw2NSw4LDEwOCwxMDYsNDMs
MywwLDEwMCwzMiw0LDMyLDAsMzIsOCw2NSwxLDEwNyw2NSw4LDEwOCwxMDYsNDMsMywwLDEwMCw3
MCw0LDY0LDMyLDgsMzMsNiw1LDMyLDgsMzMsNywxMSwxMiwwLDExLDExLDMyLDUsNjUsMCw2NSw0
LDEwOCwxMDYsMzIsNiw1NCwyLDAsMTEsMTI1LDEsMSwxMjcsMzIsMywzMiwxLDE2MSwzMiwyLDE2
Myw2OCwwLDAsMCwwLDAsMCwyMjQsNjMsMTYwLDE1NiwxNzAsMzMsNSwzMiw1LDY1LDAsNzIsNCw2
NCwzMiw0LDY1LDAsNjUsNCwxMDgsMTA2LDY1LDAsNTQsMiwwLDMyLDQsNjUsMSw2NSw0LDEwOCwx
MDYsNjUsMCw1NCwyLDAsNSwzMiw1LDMyLDAsNzgsNCw2NCwzMiw0LDY1LDAsNjUsNCwxMDgsMTA2
LDMyLDAsNjUsMSwxMDcsNTQsMiwwLDMyLDQsNjUsMSw2NSw0LDEwOCwxMDYsNjUsMCw1NCwyLDAs
NSwzMiw0LDY1LDAsNjUsNCwxMDgsMTA2LDMyLDUsNTQsMiwwLDMyLDQsNjUsMSw2NSw0LDEwOCwx
MDYsNjUsMSw1NCwyLDAsMTEsMTEsMTEsMjQ5LDMsMiwxMSwxMjQsMSwxMjcsMzIsMCw2OCwwLDAs
MCwwLDAsMCwwLDAsMTAyLDMyLDAsNjgsMCwwLDAsMCwwLDIyNCwxMTIsNjQsOTksMTEzLDQsNjQs
NjgsMCwwLDAsMCwwLDEyOCw4Niw2NCwzMiwwLDE2MSw2OCw4MCw2OSw4Miw4NCwyNTEsMzMsOSw2
NCwxNjIsNjgsMCwwLDAsMCwwLDEyOCwxMDIsNjQsMTYzLDMzLDcsNSw2OCwwLDAsMCwwLDAsMzIs
MTI0LDY0LDMyLDAsMTYxLDY4LDgwLDY5LDgyLDg0LDI1MSwzMyw5LDY0LDE2Miw2OCwwLDAsMCww
LDAsMTI4LDEwMiw2NCwxNjMsMzMsNywxMSw2OCwwLDAsMCwwLDAsMCwyNDAsNjMsMTU0LDMyLDEs
MTYyLDY4LDgwLDY5LDgyLDg0LDI1MSwzMyw5LDY0LDE2Miw2OCwwLDAsMCwwLDAsMTI4LDEwMiw2
NCwxNjMsMzMsOCwzMiwyLDY4LDgwLDY5LDgyLDg0LDI1MSwzMyw5LDY0LDE2Miw2OCwwLDAsMCww
LDAsMTI4LDEwMiw2NCwxNjMsMzMsOSwzMiw3LDE2LDMsMzMsMTAsMzIsOCwxNiwzLDMzLDExLDMy
LDksMTYsMywzMywxMiwzMiw3LDE2LDQsMzMsMTMsMzIsOCwxNiw0LDMzLDE0LDMyLDksMTYsNCwz
MywxNSw2OCwwLDAsMCwwLDAsMCwyNDAsNjMsMzIsMyw2OCwzNSw2NiwxNDYsMTIsMTYxLDE1Niwx
OTksNTksMTY1LDE2MywzMywxNiw2OCwwLDAsMCwwLDAsMCwyNDAsNjMsMzIsNCw2OCwzNSw2Niwx
NDYsMTIsMTYxLDE1NiwxOTksNTksMTY1LDE2MywzMywxNywzMiw1LDY1LDksMTA4LDMzLDE4LDMy
LDYsMzIsMTgsNjUsMCwxMDYsNjUsOCwxMDgsMTA2LDMyLDE0LDMyLDEzLDE2Miw1NywzLDAsMzIs
NiwzMiwxOCw2NSwxLDEwNiw2NSw4LDEwOCwxMDYsMzIsMTQsMzIsMTAsMTYyLDU3LDMsMCwzMiw2
LDMyLDE4LDY1LDIsMTA2LDY1LDgsMTA4LDEwNiw2OCwwLDAsMCwwLDAsMCwwLDAsMzIsMTEsMTYx
LDU3LDMsMCwzMiw2LDMyLDE4LDY1LDMsMTA2LDY1LDgsMTA4LDEwNiwzMiwxNiw2OCwwLDAsMCww
LDAsMCwwLDAsMzIsMTUsMzIsMTAsMTYyLDE2MSwzMiwxMiwzMiwxMSwxNjIsMzIsMTMsMTYyLDE2
MCwxNjIsNTcsMywwLDMyLDYsMzIsMTgsNjUsNCwxMDYsNjUsOCwxMDgsMTA2LDMyLDE2LDMyLDE1
LDMyLDEzLDE2MiwzMiwxMiwzMiwxMSwxNjIsMzIsMTAsMTYyLDE2MCwxNjIsNTcsMywwLDMyLDYs
MzIsMTgsNjUsNSwxMDYsNjUsOCwxMDgsMTA2LDMyLDE2LDMyLDEyLDMyLDE0LDE2MiwxNjIsNTcs
MywwLDMyLDYsMzIsMTgsNjUsNiwxMDYsNjUsOCwxMDgsMTA2LDMyLDE3LDMyLDEyLDMyLDEwLDE2
MiwzMiwxNSwzMiwxMSwxNjIsMzIsMTMsMTYyLDE2MCwxNjIsNTcsMywwLDMyLDYsMzIsMTgsNjUs
NywxMDYsNjUsOCwxMDgsMTA2LDMyLDE3LDY4LDAsMCwwLDAsMCwwLDAsMCwzMiwxMiwzMiwxMywx
NjIsMTYxLDMyLDE1LDMyLDExLDE2MiwzMiwxMCwxNjIsMTYwLDE2Miw1NywzLDAsMzIsNiwzMiwx
OCw2NSw4LDEwNiw2NSw4LDEwOCwxMDYsMzIsMTcsMzIsMTUsMzIsMTQsMTYyLDE2Miw1NywzLDAs
MTEsMTU4LDEsMyw0LDEyNCwyLDEyNywxLDEyNCwzMiwwLDMyLDMsMTYxLDMzLDgsMzIsMSwzMiw0
LDE2MSwzMyw5LDMyLDIsMzIsNSwxNjEsMzMsMTAsMzIsNiw2NSw5LDEwOCwzMywxMyw2OCwwLDAs
MCwwLDAsMCwwLDAsMzMsMTQsNjUsMCwzMywxMiwyLDY0LDMsNjQsMzIsMTIsNjUsMyw3OCwxMywx
LDMyLDcsMzIsMTMsMzIsMTIsNjUsMywxMDgsMTA2LDY1LDAsMTA2LDY1LDgsMTA4LDEwNiw0Mywz
LDAsMzIsOCwxNjIsMzIsNywzMiwxMywzMiwxMiw2NSwzLDEwOCwxMDYsNjUsMSwxMDYsNjUsOCwx
MDgsMTA2LDQzLDMsMCwzMiw5LDE2MiwxNjAsMzIsNywzMiwxMywzMiwxMiw2NSwzLDEwOCwxMDYs
NjUsMiwxMDYsNjUsOCwxMDgsMTA2LDQzLDMsMCwzMiwxMCwxNjIsMTYwLDMzLDExLDMyLDE0LDMy
LDExLDMyLDExLDE2MiwxNjAsMzMsMTQsMzIsMTIsNjUsMSwxMDYsMzMsMTIsMTIsMCwxMSwxMSwz
MiwxNCwxMSwxOTEsNywyLDYsMTI3LDYsMTI0LDMyLDEsNjUsMSwxMDcsMzMsOSw2NSwxLDMzLDEx
LDMyLDAsMzMsOCwzMiw2LDY1LDAsNjUsNCwxMDgsMTA2LDMyLDgsNTQsMiwwLDMyLDcsNjUsMCw2
NSw0LDEwOCwxMDYsMzIsOSw1NCwyLDAsMiw2NCwzLDY0LDMyLDExLDY1LDAsNzQsNjksMTMsMSwz
MiwxMSw2NSwxLDEwNywzMywxMSwzMiw2LDMyLDExLDY1LDQsMTA4LDEwNiw0MCwyLDAsMzMsOCwz
Miw3LDMyLDExLDY1LDQsMTA4LDEwNiw0MCwyLDAsMzMsOSwyLDY0LDMsNjQsMzIsOSwzMiw4LDEw
Nyw2NSwxLDc0LDY5LDEzLDEsMzIsOSwzMiw4LDEwNiw2NSwyLDEwOSwzMywxMiwzMiwyLDMyLDEy
LDY1LDgsMTA4LDEwNiw0MywzLDAsMzMsMTQsMzIsMiwzMiwxMiw2NSw4LDEwOCwxMDYsMzIsMiwz
Miw4LDY1LDgsMTA4LDEwNiw0MywzLDAsNTcsMywwLDMyLDUsNjUsMSw3OCw0LDY0LDMyLDMsMzIs
MTIsNjUsOCwxMDgsMTA2LDQzLDMsMCwzMywxNiwzMiwzLDMyLDEyLDY1LDgsMTA4LDEwNiwzMiwz
LDMyLDgsNjUsOCwxMDgsMTA2LDQzLDMsMCw1NywzLDAsMTEsMzIsNSw2NSwyLDc4LDQsNjQsMzIs
NCwzMiwxMiw2NSw4LDEwOCwxMDYsNDMsMywwLDMzLDE4LDMyLDQsMzIsMTIsNjUsOCwxMDgsMTA2
LDMyLDQsMzIsOCw2NSw4LDEwOCwxMDYsNDMsMywwLDU3LDMsMCwxMSwzMiw5LDMzLDEzLDMyLDgs
NjUsMSwxMDYsMzMsMTAsMiw2NCwzLDY0LDMyLDEwLDMyLDEzLDc2LDY5LDEzLDEsMiw2NCwzLDY0
LDMyLDEwLDMyLDEzLDc2LDMyLDIsMzIsMTAsNjUsOCwxMDgsMTA2LDQzLDMsMCwzMiwxNCwxMDEs
MTEzLDY5LDEzLDEsMzIsMTAsNjUsMSwxMDYsMzMsMTAsMTIsMCwxMSwxMSwzMiwxMCwzMiwxMyw3
NCw0LDY0LDEyLDIsMTEsMiw2NCwzLDY0LDMyLDEzLDMyLDEwLDc4LDMyLDIsMzIsMTMsNjUsOCwx
MDgsMTA2LDQzLDMsMCwzMiwxNCwxMDIsMTEzLDY5LDEzLDEsMzIsMTMsNjUsMSwxMDcsMzMsMTMs
MTIsMCwxMSwxMSwzMiwxMywzMiwxMCw3Miw0LDY0LDEyLDIsMTEsMzIsMiwzMiwxMCw2NSw4LDEw
OCwxMDYsNDMsMywwLDMzLDE1LDMyLDIsMzIsMTAsNjUsOCwxMDgsMTA2LDMyLDIsMzIsMTMsNjUs
OCwxMDgsMTA2LDQzLDMsMCw1NywzLDAsMzIsMiwzMiwxMyw2NSw4LDEwOCwxMDYsMzIsMTUsNTcs
MywwLDMyLDUsNjUsMSw3OCw0LDY0LDMyLDMsMzIsMTAsNjUsOCwxMDgsMTA2LDQzLDMsMCwzMywx
NywzMiwzLDMyLDEwLDY1LDgsMTA4LDEwNiwzMiwzLDMyLDEzLDY1LDgsMTA4LDEwNiw0MywzLDAs
NTcsMywwLDMyLDMsMzIsMTMsNjUsOCwxMDgsMTA2LDMyLDE3LDU3LDMsMCwxMSwzMiw1LDY1LDIs
NzgsNCw2NCwzMiw0LDMyLDEwLDY1LDgsMTA4LDEwNiw0MywzLDAsMzMsMTksMzIsNCwzMiwxMCw2
NSw4LDEwOCwxMDYsMzIsNCwzMiwxMyw2NSw4LDEwOCwxMDYsNDMsMywwLDU3LDMsMCwzMiw0LDMy
LDEzLDY1LDgsMTA4LDEwNiwzMiwxOSw1NywzLDAsMTEsMzIsMTAsNjUsMSwxMDYsMzMsMTAsMzIs
MTMsNjUsMSwxMDcsMzMsMTMsMTIsMCwxMSwxMSwzMiwxMCw2NSwxLDEwNywzMywxMywzMiwyLDMy
LDgsNjUsOCwxMDgsMTA2LDMyLDIsMzIsMTMsNjUsOCwxMDgsMTA2LDQzLDMsMCw1NywzLDAsMzIs
MiwzMiwxMyw2NSw4LDEwOCwxMDYsMzIsMTQsNTcsMywwLDMyLDUsNjUsMSw3OCw0LDY0LDMyLDMs
MzIsOCw2NSw4LDEwOCwxMDYsMzIsMywzMiwxMyw2NSw4LDEwOCwxMDYsNDMsMywwLDU3LDMsMCwz
MiwzLDMyLDEzLDY1LDgsMTA4LDEwNiwzMiwxNiw1NywzLDAsMTEsMzIsNSw2NSwyLDc4LDQsNjQs
MzIsNCwzMiw4LDY1LDgsMTA4LDEwNiwzMiw0LDMyLDEzLDY1LDgsMTA4LDEwNiw0MywzLDAsNTcs
MywwLDMyLDQsMzIsMTMsNjUsOCwxMDgsMTA2LDMyLDE4LDU3LDMsMCwxMSwzMiwxMywzMiw4LDEw
NywzMiw5LDMyLDEzLDEwNyw3NCw0LDY0LDMyLDYsMzIsMTEsNjUsNCwxMDgsMTA2LDMyLDgsNTQs
MiwwLDMyLDcsMzIsMTEsNjUsNCwxMDgsMTA2LDMyLDEzLDY1LDEsMTA3LDU0LDIsMCwzMiwxMyw2
NSwxLDEwNiwzMyw4LDUsMzIsNiwzMiwxMSw2NSw0LDEwOCwxMDYsMzIsMTMsNjUsMSwxMDYsNTQs
MiwwLDMyLDcsMzIsMTEsNjUsNCwxMDgsMTA2LDMyLDksNTQsMiwwLDMyLDEzLDY1LDEsMTA3LDMz
LDksMTEsMzIsMTEsNjUsMSwxMDYsMzMsMTEsMTIsMCwxMSwxMSwzMiw5LDMyLDgsNzQsNCw2NCwz
MiwyLDMyLDgsNjUsOCwxMDgsMTA2LDQzLDMsMCwzMiwyLDMyLDksNjUsOCwxMDgsMTA2LDQzLDMs
MCwxMDAsNCw2NCwzMiwyLDMyLDgsNjUsOCwxMDgsMTA2LDQzLDMsMCwzMywxNSwzMiwyLDMyLDgs
NjUsOCwxMDgsMTA2LDMyLDIsMzIsOSw2NSw4LDEwOCwxMDYsNDMsMywwLDU3LDMsMCwzMiwyLDMy
LDksNjUsOCwxMDgsMTA2LDMyLDE1LDU3LDMsMCwzMiw1LDY1LDEsNzgsNCw2NCwzMiwzLDMyLDgs
NjUsOCwxMDgsMTA2LDQzLDMsMCwzMywxNywzMiwzLDMyLDgsNjUsOCwxMDgsMTA2LDMyLDMsMzIs
OSw2NSw4LDEwOCwxMDYsNDMsMywwLDU3LDMsMCwzMiwzLDMyLDksNjUsOCwxMDgsMTA2LDMyLDE3
LDU3LDMsMCwxMSwzMiw1LDY1LDIsNzgsNCw2NCwzMiw0LDMyLDgsNjUsOCwxMDgsMTA2LDQzLDMs
MCwzMywxOSwzMiw0LDMyLDgsNjUsOCwxMDgsMTA2LDMyLDQsMzIsOSw2NSw4LDEwOCwxMDYsNDMs
MywwLDU3LDMsMCwzMiw0LDMyLDksNjUsOCwxMDgsMTA2LDMyLDE5LDU3LDMsMCwxMSwxMSwxMSwx
MiwwLDExLDExLDExLDI0NiwyLDIsMSwxMjcsMywxMjQsMzIsNyw2NSwwLDY1LDQsMTA4LDEwNiw2
NSwwLDU0LDIsMCw2OCwwLDAsMCwwLDAsMCwwLDAsMzMsMTQsNjUsMCwzMywxMywyLDY0LDMsNjQs
MzIsMTMsMzIsMCw3OCwxMywxLDMyLDMsMzIsMTMsNjUsOCwxMDgsMTA2LDMyLDEzLDE4Myw1Nywz
LDAsMzIsMSwzMiwxMyw2NSw4LDEwOCwxMDYsNDMsMywwLDMyLDEwLDEwMiwzMiwxLDMyLDEzLDY1
LDgsMTA4LDEwNiw0MywzLDAsMzIsMTEsOTksMTEzLDQsNjQsMzIsMTIsNjUsMCw3MCw0LDY0LDMy
LDE0LDY4LDAsMCwwLDAsMCwwLDI0MCw2MywxNjAsMzMsMTQsNSwzMiwxNCwzMiwyLDMyLDEzLDY1
LDgsMTA4LDEwNiw0MywzLDAsMTYwLDMzLDE0LDExLDExLDMyLDEzLDY1LDEsMTA2LDMzLDEzLDEy
LDAsMTEsMTEsMzIsMCw2NSwxLDcyLDMyLDE0LDY4LDM1LDY2LDE0NiwxMiwxNjEsMTU2LDE5OSw1
OSw5OSwxMTQsNCw2NCwzMiw3LDY1LDAsNjUsNCwxMDgsMTA2LDY1LDEsNTQsMiwwLDE1LDExLDY1
LDAsMzIsMCwzMiwxLDMyLDIsMzIsMyw2NSwyLDMyLDgsMzIsOSwxNiwxMyw2OCwwLDAsMCwwLDAs
MCwwLDAsMzMsMTUsNjgsMCwwLDAsMCwwLDAsMCwwLDMzLDE2LDY1LDAsMzMsMTMsMiw2NCwzLDY0
LDMyLDEzLDMyLDAsNzgsMTMsMSwzMiwxMiw2NSwwLDcwLDQsNjQsMzIsMTYsNjgsMCwwLDAsMCww
LDAsMjQwLDYzLDMyLDE0LDE2MywxNjAsMzMsMTYsNSwzMiwxNiwzMiwyLDMyLDEzLDY1LDgsMTA4
LDEwNiw0MywzLDAsMzIsMTQsMTYzLDE2MCwzMywxNiwxMSwzMiwyLDMyLDEzLDY1LDgsMTA4LDEw
NiwzMiwxNiwzMiwxNSwxNjAsNjgsMCwwLDAsMCwwLDAsMCw2NCwxNjMsNTcsMywwLDMyLDE2LDMz
LDE1LDMyLDIsMzIsMTMsNjUsOCwxMDgsMTA2LDQzLDMsMCwzMiw1LDMyLDYsMTYsNiwzMiw0LDMy
LDEzLDY1LDgsMTA4LDEwNiwzMiw1LDY1LDAsNjUsOCwxMDgsMTA2LDQzLDMsMCw1NywzLDAsMzIs
MTMsNjUsMSwxMDYsMzMsMTMsMTIsMCwxMSwxMSw2NSwwLDMyLDAsMzIsMywzMiwxLDMyLDQsNjUs
MiwzMiw4LDMyLDksMTYsMTMsMTEsMTYwLDQsMyw1LDEyNCwxLDEyNywxLDEyNCwzMiwwLDMyLDMs
NjUsMCw2NSw4LDEwOCwxMDYsNDMsMywwLDEwMSw0LDY0LDMyLDIsNjUsMCw2NSw4LDEwOCwxMDYs
NDMsMywwLDMzLDE3LDMyLDMsNjUsMCw2NSw4LDEwOCwxMDYsNDMsMywwLDE2LDcsMzMsMTEsMzIs
MCwxNiw3LDMzLDEzLDMyLDYsNjUsMSw3MCw0LDY0LDY4LDAsMCwwLDAsMCwwLDAsMCwzMiwxMSwz
Miw0LDMyLDIsNjUsMCw2NSw4LDEwOCwxMDYsNDMsMywwLDMyLDEzLDY4LDAsMCwwLDAsMCwwLDI0
MCw2MywxNiw4LDMzLDE3LDUsMzIsNiw2NSwyLDcwLDQsNjQsNjgsMCwwLDAsMCwwLDAsMjQwLDYz
LDMyLDcsMTYzLDMzLDE0LDY4LDAsMCwwLDAsMCwwLDAsMCwzMiwxMSwzMiw0LDMyLDIsNjUsMCw2
NSw4LDEwOCwxMDYsNDMsMywwLDMyLDEzLDMyLDE0LDE2LDgsMzMsMTcsMTEsMTEsNSwzMiwwLDMy
LDMsMzIsMSw2NSwxLDEwNyw2NSw4LDEwOCwxMDYsNDMsMywwLDEwMiw0LDY0LDMyLDIsMzIsMSw2
NSwxLDEwNyw2NSw4LDEwOCwxMDYsNDMsMywwLDMzLDE3LDMyLDMsMzIsMSw2NSwxLDEwNyw2NSw4
LDEwOCwxMDYsNDMsMywwLDE2LDcsMzMsMTIsMzIsMCwxNiw3LDMzLDEzLDMyLDgsNjUsMSw3MCw0
LDY0LDMyLDEyLDY4LDAsMCwwLDAsMCwwLDI0MCw2MywzMiwyLDMyLDEsNjUsMSwxMDcsNjUsOCwx
MDgsMTA2LDQzLDMsMCwzMiw1LDMyLDEzLDY4LDAsMCwwLDAsMCwwLDI0MCw2MywxNiw4LDMzLDE3
LDUsMzIsOCw2NSwyLDcwLDQsNjQsNjgsMCwwLDAsMCwwLDAsMjQwLDYzLDMyLDksMTYzLDMzLDE0
LDMyLDEyLDY4LDAsMCwwLDAsMCwwLDI0MCw2MywzMiwyLDMyLDEsNjUsMSwxMDcsNjUsOCwxMDgs
MTA2LDQzLDMsMCwzMiw1LDMyLDEzLDMyLDE0LDE2LDgsMzMsMTcsNSwzMiw4LDY1LDQsNzAsNCw2
NCwzMiwyLDMyLDEsNjUsMSwxMDcsNjUsOCwxMDgsMTA2LDQzLDMsMCwzMiw5LDE2LDIsNjgsMCww
LDAsMCwwLDAsMjQwLDYzLDMyLDMsMzIsMSw2NSwxLDEwNyw2NSw4LDEwOCwxMDYsNDMsMywwLDE2
LDcsMTYxLDE2MiwzMywxNSwzMiwxNSw2OCwwLDAsMCwwLDAsMCwyNDAsNjMsMzIsMCwxNiw3LDE2
MSwxNjMsNjgsMCwwLDAsMCwwLDAsMjQwLDYzLDMyLDksMTYzLDE2LDIsMzMsMTcsMTEsMTEsMTEs
NSwzMiwzLDMyLDEsNjUsMSwzMiwxLDMyLDAsMzIsMTAsMTYsOSwzMiwxMCw2NSwwLDY1LDQsMTA4
LDEwNiw0MCwyLDAsMzMsMTYsMzIsMTYsNjUsMSw3Miw0LDY0LDY1LDEsMzMsMTYsMTEsMzIsMTYs
MzIsMSw2NSwxLDEwNyw3NCw0LDY0LDMyLDEsNjUsMSwxMDcsMzMsMTYsMTEsMzIsMywzMiwxNiw2
NSwxLDEwNyw2NSw4LDEwOCwxMDYsNDMsMywwLDMyLDMsMzIsMTYsNjUsOCwxMDgsMTA2LDQzLDMs
MCwzMiwyLDMyLDE2LDY1LDEsMTA3LDY1LDgsMTA4LDEwNiw0MywzLDAsMzIsMiwzMiwxNiw2NSw4
LDEwOCwxMDYsNDMsMywwLDMyLDAsNjgsMCwwLDAsMCwwLDAsMjQwLDYzLDE2LDgsMzMsMTcsMTEs
MTEsMzIsMTcsMTEsMjIxLDQsMiwyLDEyNyw1LDEyNCwzMiw3LDMzLDE2LDY1LDAsMzMsMTQsMiw2
NCwzLDY0LDMyLDE0LDMyLDYsNzgsMTMsMSwzMiw4LDMyLDE0LDY1LDQsMTA4LDEwNiw0MCwyLDAs
NjUsNCw3MCw0LDY0LDMyLDE2LDY4LDAsMCwwLDAsMCw1NiwxNDMsNjQsMTYwLDMzLDE2LDUsMzIs
MTYsMzIsOSwzMiwxNCw2NSw4LDEwOCwxMDYsNDMsMywwLDE2MCwzMywxNiwxMSwzMiwxNCw2NSwx
LDEwNiwzMywxNCwxMiwwLDExLDExLDMyLDAsMzIsMSwzMiwyLDMyLDMsMzIsNCwzMiw1LDMyLDEx
LDMyLDEyLDE2LDEyLDMzLDE4LDMyLDE4LDY4LDI0MSwxMDQsMjI3LDEzNiwxODEsMjQ4LDIyOCw2
Miw5OSw0LDY0LDMyLDEzLDY1LDAsNjUsOCwxMDgsMTA2LDMyLDE2LDU3LDMsMCwzMiwxMyw2NSwx
LDY1LDgsMTA4LDEwNiwzMiwxNiw1NywzLDAsMTUsMTEsNjgsMCwwLDAsMCwwLDAsMCwwLDMzLDE3
LDY1LDAsMzMsMTQsMiw2NCwzLDY0LDMyLDE0LDMyLDYsNzgsMTMsMSwzMiwxNCw2NSwwLDcxLDQs
NjQsMzIsMTEsMzIsMTQsMTA2LDMzLDE1LDMyLDAsMzIsMSwzMiwyLDMyLDMsMzIsNCwzMiw1LDMy
LDE1LDMyLDEyLDE2LDEyLDMzLDE4LDExLDMyLDE4LDE1OSwzMywxOSwzMiw4LDMyLDE0LDY1LDQs
MTA4LDEwNiw0MCwyLDAsNjUsMSw3MCw0LDY0LDMyLDE5LDMyLDEwLDMyLDE0LDY1LDgsMTA4LDEw
Niw0MywzLDAsMTYzLDMzLDIwLDMyLDIwLDY4LDAsMCwwLDAsMCwwLDI0MCw2Myw5OSw0LDY0LDMy
LDE3LDMyLDksMzIsMTQsNjUsOCwxMDgsMTA2LDQzLDMsMCw2OCwwLDAsMCwwLDAsMCwyNDAsNjMs
MzIsMjAsNjgsMCwwLDAsMCwwLDAsMjQ4LDYzLDY4LDAsMCwwLDAsMCwwLDIyNCw2MywzMiwyMCwx
NjIsMzIsMjAsMTYyLDE2MSwxNjIsMTYxLDE2MiwxNjAsMzMsMTcsMTEsNSwzMiw4LDMyLDE0LDY1
LDQsMTA4LDEwNiw0MCwyLDAsNjUsMiw3MCw0LDY0LDMyLDE3LDMyLDksMzIsMTQsNjUsOCwxMDgs
MTA2LDQzLDMsMCw2OCwwLDAsMCwwLDAsMCw4LDY0LDE1NCwzMiwxOSwxNjIsMzIsMTAsMzIsMTQs
NjUsOCwxMDgsMTA2LDQzLDMsMCwxNjMsMTYsMSwxNjIsMTYwLDMzLDE3LDUsMzIsOCwzMiwxNCw2
NSw0LDEwOCwxMDYsNDAsMiwwLDY1LDMsNzAsNCw2NCwzMiwxNywzMiw5LDMyLDE0LDY1LDgsMTA4
LDEwNiw0MywzLDAsNjgsMCwwLDAsMCwwLDAsOCw2NCwxNTQsMzIsMTksMzIsMTAsMzIsMTQsNjUs
OCwxMDgsMTA2LDQzLDMsMCwxNjMsMTYyLDMyLDE5LDMyLDEwLDMyLDE0LDY1LDgsMTA4LDEwNiw0
MywzLDAsMTYzLDE2MiwxNiwxLDE2MiwxNjAsMzMsMTcsNSwzMiw4LDMyLDE0LDY1LDQsMTA4LDEw
Niw0MCwyLDAsNjUsNCw3MCw0LDY0LDMyLDE3LDMyLDE2LDE2MCwzMiw5LDMyLDE0LDY1LDgsMTA4
LDEwNiw0MywzLDAsMzIsMTksMzIsMTAsMzIsMTQsNjUsOCwxMDgsMTA2LDQzLDMsMCwxNiwyLDE2
MiwxNjEsMzMsMTcsNSwzMiw4LDMyLDE0LDY1LDQsMTA4LDEwNiw0MCwyLDAsNjUsNSw3MCw0LDY0
LDMyLDE3LDMyLDksMzIsMTQsNjUsOCwxMDgsMTA2LDQzLDMsMCwzMiwxOSwzMiwxMCwzMiwxNCw2
NSw4LDEwOCwxMDYsNDMsMywwLDE2Myw2OCwyNDEsMjEyLDIwMCw4MywyNTEsMzMsOSw2NCwxNjIs
MTYsNCwxNjIsMTYwLDMzLDE3LDExLDExLDExLDExLDExLDMyLDE0LDY1LDEsMTA2LDMzLDE0LDEy
LDAsMTEsMTEsMzIsMTMsNjUsMCw2NSw4LDEwOCwxMDYsMzIsMTYsNTcsMywwLDMyLDEzLDY1LDEs
NjUsOCwxMDgsMTA2LDMyLDE3LDU3LDMsMCwxMSwxODMsOCwzLDMsMTI3LDYsMTI0LDgsMTI3LDMy
LDAsMzIsMjAsMzIsMCwzMiwyMCw3MiwyNywzMywyNCwzMiwzLDMyLDIxLDMyLDMsMzIsMjEsNzIs
MjcsMzMsMjUsMzIsNiwzMiwyMiwzMiw2LDMyLDIyLDcyLDI3LDMzLDI2LDMyLDAsMTgzLDMyLDIs
MTYyLDMyLDI0LDE4MywxNjMsMzMsMjcsMzIsMywxODMsMzIsNSwxNjIsMzIsMjUsMTgzLDE2Mywz
MywyOCwzMiw2LDE4MywzMiw4LDE2MiwzMiwyNiwxODMsMTYzLDMzLDI5LDMyLDEsNjgsMCwwLDAs
MCwwLDAsMjI0LDYzLDMyLDIsMTYyLDE2MSw2OCwwLDAsMCwwLDAsMCwyMjQsNjMsMzIsMjcsMTYy
LDE2MCwzMywzMCwzMiw0LDY4LDAsMCwwLDAsMCwwLDIyNCw2MywzMiw1LDE2MiwxNjEsNjgsMCww
LDAsMCwwLDAsMjI0LDYzLDMyLDI4LDE2MiwxNjAsMzMsMzEsMzIsNyw2OCwwLDAsMCwwLDAsMCwy
MjQsNjMsMzIsOCwxNjIsMTYxLDY4LDAsMCwwLDAsMCwwLDIyNCw2MywzMiwyOSwxNjIsMTYwLDMz
LDMyLDMyLDI0LDMyLDI1LDEwOCwzMiwyNiwxMDgsMzMsMzgsNjUsMCwzMywzMywyLDY0LDMsNjQs
MzIsMzMsMzIsMzgsNzgsMTMsMSwzMiwxNSwzMiwzMyw2NSw0LDEwOCwxMDYsNjUsMCw1NCwyLDAs
MzIsMzMsNjUsMSwxMDYsMzMsMzMsMTIsMCwxMSwxMSw2NSwwLDMzLDMzLDIsNjQsMyw2NCwzMiwz
MywzMiw5LDc4LDEzLDEsMzIsMjQsMzIsMzAsMzIsMjcsMzIsMTAsMzIsMzMsNjUsOCwxMDgsMTA2
LDQzLDMsMCwzMiwxNiwxNiwxMCwzMiwxNiw2NSwwLDY1LDQsMTA4LDEwNiw0MCwyLDAsMzMsMzUs
MzIsMjUsMzIsMzEsMzIsMjgsMzIsMTEsMzIsMzMsNjUsOCwxMDgsMTA2LDQzLDMsMCwzMiwxNiwx
NiwxMCwzMiwxNiw2NSwwLDY1LDQsMTA4LDEwNiw0MCwyLDAsMzMsMzYsMzIsMjYsMzIsMzIsMzIs
MjksMzIsMTIsMzIsMzMsNjUsOCwxMDgsMTA2LDQzLDMsMCwzMiwxNiwxNiwxMCwzMiwxNiw2NSww
LDY1LDQsMTA4LDEwNiw0MCwyLDAsMzMsMzcsMzIsMzUsMzIsMzYsMzIsMjQsMTA4LDEwNiwzMiwz
NywzMiwyNCwxMDgsMzIsMjUsMTA4LDEwNiwzMywzNCwzMiwxNCwzMiwzMyw2NSw4LDEwOCwxMDYs
MzIsMzQsMTgzLDU3LDMsMCwzMiwxNSwzMiwzNCw2NSw0LDEwOCwxMDYsMzIsMTUsMzIsMzQsNjUs
NCwxMDgsMTA2LDQwLDIsMCw2NSwxLDEwNiw1NCwyLDAsMzIsMzMsNjUsMSwxMDYsMzMsMzMsMTIs
MCwxMSwxMSw2NSwwLDMzLDM0LDY1LDAsMzMsMzMsMiw2NCwzLDY0LDMyLDMzLDMyLDM4LDc4LDEz
LDEsMzIsMTUsMzIsMzMsNjUsNCwxMDgsMTA2LDQwLDIsMCwzMywzNSwzMiwxNSwzMiwzMyw2NSw0
LDEwOCwxMDYsMzIsMzQsNTQsMiwwLDMyLDM0LDMyLDM1LDEwNiwzMywzNCwzMiwzMyw2NSwxLDEw
NiwzMywzMywxMiwwLDExLDExLDY1LDAsMzMsMzMsMiw2NCwzLDY0LDMyLDMzLDMyLDksNzgsMTMs
MSwzMiwxNCwzMiwzMyw2NSw4LDEwOCwxMDYsNDMsMywwLDE3MCwzMywzNCwzMiwxNywzMiwxNSwz
MiwzNCw2NSw0LDEwOCwxMDYsNDAsMiwwLDY1LDQsMTA4LDEwNiwzMiwzMyw1NCwyLDAsMzIsMTUs
MzIsMzQsNjUsNCwxMDgsMTA2LDMyLDE1LDMyLDM0LDY1LDQsMTA4LDEwNiw0MCwyLDAsNjUsMSwx
MDYsNTQsMiwwLDMyLDMzLDY1LDEsMTA2LDMzLDMzLDEyLDAsMTEsMTEsNjUsMCwzMywzMywyLDY0
LDMsNjQsMzIsMzMsMzIsOSw3OCwxMywxLDMyLDE3LDMyLDMzLDY1LDQsMTA4LDEwNiw0MCwyLDAs
MzIsMzMsNzEsMzIsMTcsMzIsMzMsNjUsNCwxMDgsMTA2LDQwLDIsMCw2NSwwLDc4LDExMyw0LDY0
LDMyLDIzLDY1LDksNjUsOCwxMDgsMTA2LDMyLDEwLDMyLDMzLDY1LDgsMTA4LDEwNiw0MywzLDAs
NTcsMywwLDMyLDIzLDY1LDEwLDY1LDgsMTA4LDEwNiwzMiwxMSwzMiwzMyw2NSw4LDEwOCwxMDYs
NDMsMywwLDU3LDMsMCwzMiwyMyw2NSwxMSw2NSw4LDEwOCwxMDYsMzIsMTIsMzIsMzMsNjUsOCwx
MDgsMTA2LDQzLDMsMCw1NywzLDAsMzIsMjMsNjUsMTIsNjUsOCwxMDgsMTA2LDMyLDEzLDMyLDMz
LDY1LDgsMTA4LDEwNiw0MywzLDAsNTcsMywwLDMyLDMzLDMzLDM5LDMyLDE3LDMyLDMzLDY1LDQs
MTA4LDEwNiw0MCwyLDAsMzMsNDAsMiw2NCwzLDY0LDMyLDQwLDMyLDMzLDcxLDY5LDEzLDEsMzIs
MTAsMzIsMzksNjUsOCwxMDgsMTA2LDMyLDEwLDMyLDQwLDY1LDgsMTA4LDEwNiw0MywzLDAsNTcs
MywwLDMyLDExLDMyLDM5LDY1LDgsMTA4LDEwNiwzMiwxMSwzMiw0MCw2NSw4LDEwOCwxMDYsNDMs
MywwLDU3LDMsMCwzMiwxMiwzMiwzOSw2NSw4LDEwOCwxMDYsMzIsMTIsMzIsNDAsNjUsOCwxMDgs
MTA2LDQzLDMsMCw1NywzLDAsMzIsMTMsMzIsMzksNjUsOCwxMDgsMTA2LDMyLDEzLDMyLDQwLDY1
LDgsMTA4LDEwNiw0MywzLDAsNTcsMywwLDMyLDE3LDMyLDM5LDY1LDQsMTA4LDEwNiw2NSwwLDY1
LDEsMTA3LDU0LDIsMCwzMiw0MCwzMywzOSwzMiwxNywzMiwzOSw2NSw0LDEwOCwxMDYsNDAsMiww
LDMzLDQwLDEyLDAsMTEsMTEsMzIsMTAsMzIsMzksNjUsOCwxMDgsMTA2LDMyLDIzLDY1LDksNjUs
OCwxMDgsMTA2LDQzLDMsMCw1NywzLDAsMzIsMTEsMzIsMzksNjUsOCwxMDgsMTA2LDMyLDIzLDY1
LDEwLDY1LDgsMTA4LDEwNiw0MywzLDAsNTcsMywwLDMyLDEyLDMyLDM5LDY1LDgsMTA4LDEwNiwz
MiwyMyw2NSwxMSw2NSw4LDEwOCwxMDYsNDMsMywwLDU3LDMsMCwzMiwxMywzMiwzOSw2NSw4LDEw
OCwxMDYsMzIsMjMsNjUsMTIsNjUsOCwxMDgsMTA2LDQzLDMsMCw1NywzLDAsMzIsMTcsMzIsMzks
NjUsNCwxMDgsMTA2LDY1LDAsNjUsMSwxMDcsNTQsMiwwLDExLDMyLDMzLDY1LDEsMTA2LDMzLDMz
LDEyLDAsMTEsMTEsMzIsMjMsNjUsMCw2NSw4LDEwOCwxMDYsMzIsMjQsMTgzLDU3LDMsMCwzMiwy
Myw2NSwxLDY1LDgsMTA4LDEwNiwzMiwyNSwxODMsNTcsMywwLDMyLDIzLDY1LDIsNjUsOCwxMDgs
MTA2LDMyLDI2LDE4Myw1NywzLDAsMzIsMjMsNjUsMyw2NSw4LDEwOCwxMDYsMzIsMzAsNTcsMyww
LDMyLDIzLDY1LDQsNjUsOCwxMDgsMTA2LDMyLDMxLDU3LDMsMCwzMiwyMyw2NSw1LDY1LDgsMTA4
LDEwNiwzMiwzMiw1NywzLDAsMzIsMjMsNjUsNiw2NSw4LDEwOCwxMDYsMzIsMjcsNTcsMywwLDMy
LDIzLDY1LDcsNjUsOCwxMDgsMTA2LDMyLDI4LDU3LDMsMCwzMiwyMyw2NSw4LDY1LDgsMTA4LDEw
NiwzMiwyOSw1NywzLDAsMTEsMTYzLDQsMyw5LDEyNyw4LDEyNCwxLDEyNyw2NSwwLDMzLDMwLDY1
LDAsMzIsMCw2NSwxLDEwNywxMDcsMzMsMTMsMiw2NCwzLDY0LDMyLDEzLDMyLDAsNzgsMTMsMSw2
NSwwLDMyLDIsNjUsMSwxMDcsMTA3LDMzLDE0LDIsNjQsMyw2NCwzMiwxNCwzMiwyLDc4LDEzLDEs
NjUsMCwzMiw0LDY1LDEsMTA3LDEwNywzMywxNSwyLDY0LDMsNjQsMzIsMTUsMzIsNCw3OCwxMywx
LDMyLDEzLDE4MywzMiwxLDE2MiwzMywyMiwzMiwxNCwxODMsMzIsMywxNjIsMzMsMjMsMzIsMTUs
MTgzLDMyLDUsMTYyLDMzLDI0LDY4LDgwLDIzOSwyMjYsMjE0LDIyOCwyNiw3NSw2OCwzMywyOCw2
NSwwLDY1LDEsMTA3LDMzLDE2LDIsNjQsMyw2NCwzMiwxNiw2NSwyLDc4LDEzLDEsNjUsMCw2NSwx
LDEwNywzMywxNywyLDY0LDMsNjQsMzIsMTcsNjUsMiw3OCwxMywxLDY1LDAsNjUsMSwxMDcsMzMs
MTgsMiw2NCwzLDY0LDMyLDE4LDY1LDIsNzgsMTMsMSw2NSwwLDY1LDEsMTA3LDMzLDE5LDIsNjQs
Myw2NCwzMiwxOSw2NSwyLDc4LDEzLDEsNjUsMCw2NSwxLDEwNywzMywyMCwyLDY0LDMsNjQsMzIs
MjAsNjUsMiw3OCwxMywxLDY1LDAsNjUsMSwxMDcsMzMsMjEsMiw2NCwzLDY0LDMyLDIxLDY1LDIs
NzgsMTMsMSwzMiwxNiw2NSwwLDcxLDMyLDE3LDY1LDAsNzEsMTEzLDMyLDE4LDY1LDAsNzEsMTEz
LDMyLDE5LDY1LDAsNzEsMTEzLDMyLDIwLDY1LDAsNzEsMTEzLDMyLDIxLDY1LDAsNzEsMTEzLDQs
NjQsMzIsMTYsMzIsMTksMTA3LDE4Myw2OCwwLDAsMCwwLDAsMCwyMjQsNjMsMTYyLDMyLDEsMTYy
LDMyLDIyLDE2MCwzMywyNSwzMiwxNywzMiwyMCwxMDcsMTgzLDY4LDAsMCwwLDAsMCwwLDIyNCw2
MywxNjIsMzIsMywxNjIsMzIsMjMsMTYwLDMzLDI2LDMyLDE4LDMyLDIxLDEwNywxODMsNjgsMCww
LDAsMCwwLDAsMjI0LDYzLDE2MiwzMiw1LDE2MiwzMiwyNCwxNjAsMzMsMjcsNjgsMCwwLDAsMCww
LDAsMCwwLDY4LDAsMCwwLDAsMCwwLDAsMCw2OCwwLDAsMCwwLDAsMCwwLDAsMzIsMjUsMzIsMjYs
MzIsMjcsMzIsNiwzMiw3LDE2LDEyLDMzLDI5LDMyLDI5LDMyLDI4LDk5LDQsNjQsMzIsMjksMzMs
MjgsMTEsMTEsMzIsMjEsNjUsMSwxMDYsMzMsMjEsMTIsMCwxMSwxMSwzMiwyMCw2NSwxLDEwNiwz
MywyMCwxMiwwLDExLDExLDMyLDE5LDY1LDEsMTA2LDMzLDE5LDEyLDAsMTEsMTEsMzIsMTgsNjUs
MSwxMDYsMzMsMTgsMTIsMCwxMSwxMSwzMiwxNyw2NSwxLDEwNiwzMywxNywxMiwwLDExLDExLDMy
LDE2LDY1LDEsMTA2LDMzLDE2LDEyLDAsMTEsMTEsMzIsMjgsMzIsOCwxMDEsNCw2NCwzMiwxMCwz
MiwzMCw2NSw0LDEwOCwxMDYsMzIsMTMsNTQsMiwwLDMyLDExLDMyLDMwLDY1LDQsMTA4LDEwNiwz
MiwxNCw1NCwyLDAsMzIsMTIsMzIsMzAsNjUsNCwxMDgsMTA2LDMyLDE1LDU0LDIsMCwzMiwzMCw2
NSwxLDEwNiwzMywzMCwxMSwzMiwxNSw2NSwxLDEwNiwzMywxNSwxMiwwLDExLDExLDMyLDE0LDY1
LDEsMTA2LDMzLDE0LDEyLDAsMTEsMTEsMzIsMTMsNjUsMSwxMDYsMzMsMTMsMTIsMCwxMSwxMSwz
Miw5LDY1LDAsNjUsNCwxMDgsMTA2LDMyLDMwLDU0LDIsMCwxMSwxNTQsOCw1LDEyLDEyNywxLDEy
NCwzLDEyNyw0LDEyNCwxLDEyNywzMiwxOCwzMiwxOSwzMiwyMCwzMiwwLDMyLDI4LDE2LDEwLDMy
LDI4LDY1LDAsNjUsNCwxMDgsMTA2LDQwLDIsMCwzMywzMiwzMiwyMSwzMiwyMiwzMiwyMywzMiwx
LDMyLDI4LDE2LDEwLDMyLDI4LDY1LDAsNjUsNCwxMDgsMTA2LDQwLDIsMCwzMywzMywzMiwyNCwz
MiwyNSwzMiwyNiwzMiwyLDMyLDI4LDE2LDEwLDMyLDI4LDY1LDAsNjUsNCwxMDgsMTA2LDQwLDIs
MCwzMywzNCw2NSwwLDMzLDQxLDY1LDAsMzMsMzUsMiw2NCwzLDY0LDMyLDM1LDMyLDYsNzgsMTMs
MSwzMiwzMiwzMiw3LDMyLDM1LDY1LDQsMTA4LDEwNiw0MCwyLDAsMTA2LDMzLDM2LDMyLDMzLDMy
LDgsMzIsMzUsNjUsNCwxMDgsMTA2LDQwLDIsMCwxMDYsMzMsMzcsMzIsMzQsMzIsOSwzMiwzNSw2
NSw0LDEwOCwxMDYsNDAsMiwwLDEwNiwzMywzOCwzMiwzNiw2NSwwLDcyLDMyLDM2LDMyLDE4LDc4
LDExNCwzMiwzNyw2NSwwLDcyLDExNCwzMiwzNywzMiwyMSw3OCwxMTQsMzIsMzgsNjUsMCw3Miwx
MTQsMzIsMzgsMzIsMjQsNzgsMTE0LDQsNjQsNSwzMiwzNiwzMiwzNywzMiwxOCwxMDgsMTA2LDMy
LDM4LDMyLDE4LDEwOCwzMiwyMSwxMDgsMTA2LDMzLDM5LDMyLDM5LDY1LDAsNzAsNCw2NCwzMiwx
Nyw2NSwwLDY1LDQsMTA4LDEwNiw0MCwyLDAsMzMsNDAsNjUsMCwzMyw0Miw1LDMyLDE3LDMyLDM5
LDY1LDQsMTA4LDEwNiw0MCwyLDAsMzIsMTcsMzIsMzksNjUsMSwxMDcsNjUsNCwxMDgsMTA2LDQw
LDIsMCwxMDcsMzMsNDAsMzIsMTcsMzIsMzksNjUsMSwxMDcsNjUsNCwxMDgsMTA2LDQwLDIsMCwz
Myw0MiwxMSw2NSwwLDMzLDQzLDIsNjQsMyw2NCwzMiw0MywzMiw0MCw3OCwxMywxLDMyLDAsMzIs
MSwzMiwyLDMyLDEyLDMyLDQyLDY1LDgsMTA4LDEwNiw0MywzLDAsMzIsMTMsMzIsNDIsNjUsOCwx
MDgsMTA2LDQzLDMsMCwzMiwxNCwzMiw0Miw2NSw4LDEwOCwxMDYsNDMsMywwLDMyLDQsMzIsNSwx
NiwxMiwzMyw0NCwzMiw0NCwzMiwzLDEwMSw0LDY0LDMyLDE2LDMyLDQxLDY1LDgsMTA4LDEwNiwz
Miw0MiwxODMsNTcsMywwLDMyLDE1LDMyLDQxLDY1LDgsMTA4LDEwNiwzMiw0NCw1NywzLDAsMzIs
NDEsNjUsMSwxMDYsMzMsNDEsMTEsMzIsNDIsNjUsMSwxMDYsMzMsNDIsMzIsNDMsNjUsMSwxMDYs
MzMsNDMsMTIsMCwxMSwxMSwxMSwzMiwzNSw2NSwxLDEwNiwzMywzNSwxMiwwLDExLDExLDMyLDQx
LDY1LDEsNzQsNCw2NCw2NSwwLDMyLDQxLDMyLDE1LDMyLDE2LDMyLDE2LDY1LDEsMzIsMzAsMzIs
MzEsMTYsMTMsMTEsMzIsMTAsNjUsMCw3Niw0LDY0LDMyLDI3LDY1LDAsNjUsOCwxMDgsMTA2LDMy
LDQxLDE4Myw1NywzLDAsMzIsMjcsNjUsMSw2NSw4LDEwOCwxMDYsNjgsMCwwLDAsMCwwLDAsMCww
LDU3LDMsMCwxNSwxMSw2NSwwLDMzLDQyLDIsNjQsMyw2NCwzMiw0Miw2NSw4LDc4LDEzLDEsMzIs
MjksMzIsNDIsNjUsNCwxMDgsMTA2LDY1LDAsNTQsMiwwLDMyLDQyLDY1LDEsMTA2LDMzLDQyLDEy
LDAsMTEsMTEsNjUsOCwzMiwxMCwxMDgsMzMsNDYsNjUsMCwzMyw0NSw2NSwwLDMzLDQzLDIsNjQs
Myw2NCwzMiw0MywzMiw0MSw3OCwxMywxLDMyLDE2LDMyLDQzLDY1LDgsMTA4LDEwNiw0MywzLDAs
MTcwLDMzLDUyLDMyLDE1LDMyLDQzLDY1LDgsMTA4LDEwNiw0MywzLDAsMzMsNTEsMzIsMTIsMzIs
NTIsNjUsOCwxMDgsMTA2LDQzLDMsMCwzMiwwLDE2MSwzMyw0OCwzMiwxMywzMiw1Miw2NSw4LDEw
OCwxMDYsNDMsMywwLDMyLDEsMTYxLDMzLDQ5LDMyLDE0LDMyLDUyLDY1LDgsMTA4LDEwNiw0Mywz
LDAsMzIsMiwxNjEsMzMsNTAsMzIsNTAsNjgsMCwwLDAsMCwwLDAsMCwwLDEwMiw0LDY0LDY1LDMs
MzMsNDcsMzIsNDgsNjgsMCwwLDAsMCwwLDAsMCwwLDEwMSwzMiw0OSw2OCwwLDAsMCwwLDAsMCww
LDAsMTAwLDExMyw0LDY0LDY1LDAsMzMsNDcsMTEsMzIsNDgsNjgsMCwwLDAsMCwwLDAsMCwwLDEw
MCwzMiw0OSw2OCwwLDAsMCwwLDAsMCwwLDAsMTAyLDExMyw0LDY0LDY1LDEsMzMsNDcsMTEsMzIs
NDgsNjgsMCwwLDAsMCwwLDAsMCwwLDk5LDMyLDQ5LDY4LDAsMCwwLDAsMCwwLDAsMCwxMDEsMTEz
LDQsNjQsNjUsMiwzMyw0NywxMSw1LDY1LDcsMzMsNDcsMzIsNDgsNjgsMCwwLDAsMCwwLDAsMCww
LDEwMSwzMiw0OSw2OCwwLDAsMCwwLDAsMCwwLDAsMTAwLDExMyw0LDY0LDY1LDQsMzMsNDcsMTEs
MzIsNDgsNjgsMCwwLDAsMCwwLDAsMCwwLDEwMCwzMiw0OSw2OCwwLDAsMCwwLDAsMCwwLDAsMTAy
LDExMyw0LDY0LDY1LDUsMzMsNDcsMTEsMzIsNDgsNjgsMCwwLDAsMCwwLDAsMCwwLDk5LDMyLDQ5
LDY4LDAsMCwwLDAsMCwwLDAsMCwxMDEsMTEzLDQsNjQsNjUsNiwzMyw0NywxMSwxMSwzMiwyOSwz
Miw0Nyw2NSw0LDEwOCwxMDYsMzIsMjksMzIsNDcsNjUsNCwxMDgsMTA2LDQwLDIsMCw2NSwxLDEw
Niw1NCwyLDAsMzIsMjksMzIsNDcsNjUsNCwxMDgsMTA2LDQwLDIsMCwzMiwxMCw3Niw0LDY0LDMy
LDE2LDMyLDQ1LDY1LDgsMTA4LDEwNiwzMiw1MiwxODMsNTcsMywwLDMyLDE1LDMyLDQ1LDY1LDgs
MTA4LDEwNiwzMiw1MSw1NywzLDAsMzIsNDUsNjUsMSwxMDYsMzMsNDUsMzIsNDUsMzIsNDYsNzAs
NCw2NCwxMiwzLDExLDExLDMyLDQzLDY1LDEsMTA2LDMzLDQzLDEyLDAsMTEsMTEsMzIsNDUsMzMs
NDEsMzIsMjcsNjUsMSw2NSw4LDEwOCwxMDYsNjgsMCwwLDAsMCwwLDAsMCwwLDU3LDMsMCw2NSww
LDMzLDQyLDIsNjQsMyw2NCwzMiw0Miw2NSw4LDc4LDEzLDEsMzIsMjksMzIsNDIsNjUsNCwxMDgs
MTA2LDQwLDIsMCw2NSwwLDc0LDQsNjQsMzIsMjcsNjUsMSw2NSw4LDEwOCwxMDYsMzIsMjcsNjUs
MSw2NSw4LDEwOCwxMDYsNDMsMywwLDY4LDAsMCwwLDAsMCwwLDI0MCw2MywxNjAsNTcsMywwLDEx
LDMyLDQyLDY1LDEsMTA2LDMzLDQyLDEyLDAsMTEsMTEsMzIsMjcsNjUsMCw2NSw4LDEwOCwxMDYs
MzIsNDEsMTgzLDU3LDMsMCwxMSwxNzAsNSwyLDksMTI3LDQsMTI0LDY4LDcyLDE3NSwxODgsMTU0
LDI0MiwyMTUsMTIyLDYyLDMzLDE3LDMyLDAsNjUsMSw3Niw0LDY0LDMyLDQsNjUsMCw2NSw4LDEw
OCwxMDYsNjgsMCwwLDAsMCwwLDAsMjQwLDYzLDE1NCw1NywzLDAsMTUsMTEsMzIsNCw2NSwwLDY1
LDgsMTA4LDEwNiw2OCwwLDAsMCwwLDAsMCwwLDAsNTcsMywwLDMyLDAsNjUsMSwxMDcsMzMsNSw2
NSwwLDMzLDksNjUsMSwzMyw2LDIsNjQsMyw2NCwzMiw2LDMyLDUsNjUsMSwxMDYsNzgsMTMsMSwz
Miw5LDMyLDYsMTA2LDMzLDksMzIsMSwzMiw5LDY1LDEsMTA3LDY1LDgsMTA4LDEwNiw0MywzLDAs
MzMsMTQsMzIsMTQsMTUzLDMyLDE3LDk5LDQsNjQsMzIsNCw2NSwwLDY1LDgsMTA4LDEwNiwzMiw2
LDE4Myw1NywzLDAsMTUsMTEsNjgsMCwwLDAsMCwwLDAsMjQwLDYzLDMyLDE0LDE2MywzMywxNSw2
NSwwLDMzLDEzLDMyLDksMzMsMTAsMzIsNiwzMyw3LDIsNjQsMyw2NCwzMiw3LDMyLDUsNjUsMSwx
MDYsNzgsMTMsMSwzMiwxMCwzMywxMiwzMiwxMCwzMiw3LDEwNiwzMywxMCwzMiwxLDMyLDEwLDY1
LDEsMTA3LDY1LDgsMTA4LDEwNiw0MywzLDAsMzIsMTUsMTYyLDMzLDE2LDMyLDEzLDY1LDEsMTA2
LDMzLDEzLDMyLDEwLDMyLDYsMTA3LDY1LDEsMTA2LDMzLDExLDMyLDcsMzMsOCwyLDY0LDMsNjQs
MzIsOCwzMiw1LDY1LDEsMTA2LDc4LDEzLDEsMzIsMTEsMzIsOCwxMDYsMzMsMTEsMzIsMTIsMzIs
OCwxMDYsMzMsMTIsMzIsMSwzMiwxMSw2NSwxLDEwNyw2NSw4LDEwOCwxMDYsMzIsMSwzMiwxMSw2
NSwxLDEwNyw2NSw4LDEwOCwxMDYsNDMsMywwLDMyLDE2LDMyLDEsMzIsMTIsNjUsMSwxMDcsNjUs
OCwxMDgsMTA2LDQzLDMsMCwxNjIsMTYxLDU3LDMsMCwzMiw4LDY1LDEsMTA2LDMzLDgsMTIsMCwx
MSwxMSwzMiwyLDMyLDYsMzIsMTMsMTA2LDY1LDEsMTA3LDY1LDgsMTA4LDEwNiwzMiwyLDMyLDYs
MzIsMTMsMTA2LDY1LDEsMTA3LDY1LDgsMTA4LDEwNiw0MywzLDAsMzIsMTYsMzIsMiwzMiw2LDY1
LDEsMTA3LDY1LDgsMTA4LDEwNiw0MywzLDAsMTYyLDE2MSw1NywzLDAsMzIsNyw2NSwxLDEwNiwz
Myw3LDEyLDAsMTEsMTEsMzIsNiw2NSwxLDEwNiwzMyw2LDEyLDAsMTEsMTEsMzIsMCwzMiwwLDY1
LDEsMTA2LDEwOCw2NSwyLDEwOSwzMywxMSwzMiwxLDMyLDExLDY1LDEsMTA3LDY1LDgsMTA4LDEw
Niw0MywzLDAsMTUzLDMyLDE3LDk5LDQsNjQsMzIsNCw2NSwwLDY1LDgsMTA4LDEwNiwzMiwwLDE4
Myw1NywzLDAsMTUsMTEsNjgsMCwwLDAsMCwwLDAsMjQwLDYzLDMyLDEsMzIsMTEsNjUsMSwxMDcs
NjUsOCwxMDgsMTA2LDQzLDMsMCwxNjMsMzMsMTUsMzIsMywzMiwwLDY1LDEsMTA3LDY1LDgsMTA4
LDEwNiwzMiwyLDMyLDAsNjUsMSwxMDcsNjUsOCwxMDgsMTA2LDQzLDMsMCwzMiwxNSwxNjIsNTcs
MywwLDMyLDAsMzMsNywzMiwxMSwzMyw5LDY1LDEsMzMsMTAsMiw2NCwzLDY0LDMyLDEwLDMyLDUs
NjUsMSwxMDYsNzgsMTMsMSwzMiw5LDMyLDcsMTA3LDMzLDksNjgsMCwwLDAsMCwwLDAsMjQwLDYz
LDMyLDEsMzIsOSw2NSwxLDEwNyw2NSw4LDEwOCwxMDYsNDMsMywwLDE2MywzMywxNSwzMiw3LDY1
LDEsMTA3LDMzLDcsMzIsMiwzMiw3LDY1LDEsMTA3LDY1LDgsMTA4LDEwNiw0MywzLDAsMzMsMTYs
MzIsOSwzMywxMSwzMiw3LDMzLDgsMiw2NCwzLDY0LDMyLDgsMzIsNSw2NSwxLDEwNiw3OCwxMywx
LDMyLDExLDMyLDgsMTA2LDMzLDExLDMyLDE2LDMyLDEsMzIsMTEsNjUsMSwxMDcsNjUsOCwxMDgs
MTA2LDQzLDMsMCwzMiwzLDMyLDgsNjUsOCwxMDgsMTA2LDQzLDMsMCwxNjIsMTYxLDMzLDE2LDMy
LDgsNjUsMSwxMDYsMzMsOCwxMiwwLDExLDExLDMyLDMsMzIsNyw2NSwxLDEwNyw2NSw4LDEwOCwx
MDYsMzIsMTYsMzIsMTUsMTYyLDU3LDMsMCwzMiwxMCw2NSwxLDEwNiwzMywxMCwxMiwwLDExLDEx
LDExLDIyNSw3LDIsMTIsMTI3LDIsMTI0LDY4LDE4NywxODksMjE1LDIxNywyMjMsMTI0LDIxOSw2
MSwzMywxOCwzMiwwLDY1LDEsNzYsNCw2NCwzMiw0LDY1LDAsNjUsOCwxMDgsMTA2LDY4LDAsMCww
LDAsMCwwLDI0MCw2MywxNTQsNTcsMywwLDE1LDExLDMyLDQsNjUsMCw2NSw4LDEwOCwxMDYsNjgs
MCwwLDAsMCwwLDAsMCwwLDU3LDMsMCwzMiwwLDY1LDEsMTA3LDMzLDUsNjUsMCwzMyw2LDIsNjQs
Myw2NCwzMiw2LDMyLDUsNzgsMTMsMSwzMiw2LDY1LDEsMTA2LDMzLDcsMzIsNiwzMiwwLDEwOCwz
Miw2LDEwNiwzMywxMCwzMiwxMCwzMywxMSwzMiw2LDMzLDEyLDMyLDEwLDMzLDEzLDMyLDcsMzMs
OCwyLDY0LDMsNjQsMzIsOCwzMiwwLDc4LDEzLDEsMzIsMTMsNjUsMSwxMDYsMzMsMTMsMzIsMSwz
MiwxMyw2NSw4LDEwOCwxMDYsNDMsMywwLDE1MywzMiwxLDMyLDExLDY1LDgsMTA4LDEwNiw0Mywz
LDAsMTUzLDEwMCw0LDY0LDMyLDEzLDMzLDExLDMyLDgsMzMsMTIsMTEsMzIsOCw2NSwxLDEwNiwz
Myw4LDEyLDAsMTEsMTEsMzIsMSwzMiwxMSw2NSw4LDEwOCwxMDYsNDMsMywwLDMzLDE3LDMyLDEs
MzIsMTEsNjUsOCwxMDgsMTA2LDMyLDEsMzIsMTAsNjUsOCwxMDgsMTA2LDQzLDMsMCw1NywzLDAs
MzIsMSwzMiwxMCw2NSw4LDEwOCwxMDYsMzIsMTcsNTcsMywwLDMyLDEsMzIsMTAsNjUsOCwxMDgs
MTA2LDQzLDMsMCwxNTMsMzIsMTgsOTksNCw2NCwzMiw0LDY1LDAsNjUsOCwxMDgsMTA2LDMyLDYs
NjUsMSwxMDYsMTgzLDU3LDMsMCwxNSwxMSwzMiwxMCwzMywxMywzMiw3LDMzLDgsMiw2NCwzLDY0
LDMyLDgsMzIsMCw3OCwxMywxLDMyLDEzLDY1LDEsMTA2LDMzLDEzLDMyLDEsMzIsMTMsNjUsOCwx
MDgsMTA2LDY4LDAsMCwwLDAsMCwwLDAsMCwzMiwxLDMyLDEzLDY1LDgsMTA4LDEwNiw0MywzLDAs
MzIsMSwzMiwxMCw2NSw4LDEwOCwxMDYsNDMsMywwLDE2MywxNjEsNTcsMywwLDMyLDgsNjUsMSwx
MDYsMzMsOCwxMiwwLDExLDExLDMyLDEwLDMzLDE0LDMyLDExLDMzLDE1LDMyLDcsMzMsOSwyLDY0
LDMsNjQsMzIsOSwzMiwwLDc4LDEzLDEsMzIsMTQsMzIsMCwxMDYsMzMsMTQsMzIsMTUsMzIsMCwx
MDYsMzMsMTUsMzIsMSwzMiwxNSw2NSw4LDEwOCwxMDYsNDMsMywwLDMzLDE3LDMyLDEsMzIsMTUs
NjUsOCwxMDgsMTA2LDMyLDEsMzIsMTQsNjUsOCwxMDgsMTA2LDQzLDMsMCw1NywzLDAsMzIsMSwz
MiwxNCw2NSw4LDEwOCwxMDYsMzIsMTcsNTcsMywwLDMyLDE0LDMzLDEzLDMyLDEwLDMzLDE2LDMy
LDcsMzMsOCwyLDY0LDMsNjQsMzIsOCwzMiwwLDc4LDEzLDEsMzIsMTMsNjUsMSwxMDYsMzMsMTMs
MzIsMTYsNjUsMSwxMDYsMzMsMTYsMzIsMSwzMiwxMyw2NSw4LDEwOCwxMDYsMzIsMSwzMiwxMyw2
NSw4LDEwOCwxMDYsNDMsMywwLDMyLDEsMzIsMTYsNjUsOCwxMDgsMTA2LDQzLDMsMCwzMiwxLDMy
LDE0LDY1LDgsMTA4LDEwNiw0MywzLDAsMTYyLDE2MCw1NywzLDAsMzIsOCw2NSwxLDEwNiwzMyw4
LDEyLDAsMTEsMTEsMzIsOSw2NSwxLDEwNiwzMyw5LDEyLDAsMTEsMTEsMzIsMiwzMiwxMiw2NSw4
LDEwOCwxMDYsNDMsMywwLDMzLDE3LDMyLDIsMzIsMTIsNjUsOCwxMDgsMTA2LDMyLDIsMzIsNiw2
NSw4LDEwOCwxMDYsNDMsMywwLDU3LDMsMCwzMiwyLDMyLDYsNjUsOCwxMDgsMTA2LDMyLDE3LDU3
LDMsMCwzMiw2LDMzLDE0LDMyLDEwLDMzLDE1LDMyLDcsMzMsOSwyLDY0LDMsNjQsMzIsOSwzMiww
LDc4LDEzLDEsMzIsMTQsNjUsMSwxMDYsMzMsMTQsMzIsMTUsNjUsMSwxMDYsMzMsMTUsMzIsMiwz
MiwxNCw2NSw4LDEwOCwxMDYsMzIsMiwzMiwxNCw2NSw4LDEwOCwxMDYsNDMsMywwLDMyLDIsMzIs
Niw2NSw4LDEwOCwxMDYsNDMsMywwLDMyLDEsMzIsMTUsNjUsOCwxMDgsMTA2LDQzLDMsMCwxNjIs
MTYwLDU3LDMsMCwzMiw5LDY1LDEsMTA2LDMzLDksMTIsMCwxMSwxMSwzMiw2LDY1LDEsMTA2LDMz
LDYsMTIsMCwxMSwxMSwzMiwwLDMyLDAsMTA4LDY1LDEsMTA3LDMzLDEwLDMyLDEsMzIsMTAsNjUs
OCwxMDgsMTA2LDQzLDMsMCwxNTMsMzIsMTgsOTksNCw2NCwzMiw0LDY1LDAsNjUsOCwxMDgsMTA2
LDMyLDAsMTgzLDU3LDMsMCwxNSwxMSw2NSwxLDMzLDYsMiw2NCwzLDY0LDMyLDYsMzIsMCw3OCwx
MywxLDMyLDAsMzIsNiwxMDcsMzMsOCwzMiw4LDMyLDAsMTA4LDMyLDgsMTA2LDMzLDEwLDMyLDIs
MzIsOCw2NSw4LDEwOCwxMDYsMzIsMiwzMiw4LDY1LDgsMTA4LDEwNiw0MywzLDAsMzIsMSwzMiwx
MCw2NSw4LDEwOCwxMDYsNDMsMywwLDE2Myw1NywzLDAsNjgsMCwwLDAsMCwwLDAsMCwwLDMyLDIs
MzIsOCw2NSw4LDEwOCwxMDYsNDMsMywwLDE2MSwzMywxNywzMiw4LDMyLDAsMTA4LDMzLDEzLDY1
LDAsMzMsOSwyLDY0LDMsNjQsMzIsOSwzMiw4LDc4LDEzLDEsMzIsMiwzMiw5LDY1LDgsMTA4LDEw
NiwzMiwyLDMyLDksNjUsOCwxMDgsMTA2LDQzLDMsMCwzMiwxLDMyLDEzLDMyLDksMTA2LDY1LDgs
MTA4LDEwNiw0MywzLDAsMzIsMTcsMTYyLDE2MCw1NywzLDAsMzIsOSw2NSwxLDEwNiwzMyw5LDEy
LDAsMTEsMTEsMzIsNiw2NSwxLDEwNiwzMyw2LDEyLDAsMTEsMTEsMzIsMiw2NSwwLDY1LDgsMTA4
LDEwNiwzMiwyLDY1LDAsNjUsOCwxMDgsMTA2LDQzLDMsMCwzMiwxLDY1LDAsNjUsOCwxMDgsMTA2
LDQzLDMsMCwxNjMsNTcsMywwLDY1LDAsMzMsOCwyLDY0LDMsNjQsMzIsOCwzMiwwLDc4LDEzLDEs
MzIsMywzMiw4LDY1LDgsMTA4LDEwNiwzMiwyLDMyLDgsNjUsOCwxMDgsMTA2LDQzLDMsMCw1Nywz
LDAsMzIsOCw2NSwxLDEwNiwzMyw4LDEyLDAsMTEsMTEsMTEsMTYyLDIxLDYsNSwxMjcsNiwxMjQs
NCwxMjcsMTAsMTI0LDksMTI3LDEsMTI0LDMyLDYsMzIsNywxMDgsMzMsNTAsMzIsNCwzMiw2LDE4
Myw2OCwwLDAsMCwwLDAsMCwyNDAsNjMsMTY1LDE2MywzMyw2MiwzMiw1LDMyLDcsMTgzLDY4LDAs
MCwwLDAsMCwwLDI0MCw2MywxNjUsMTYzLDMzLDYzLDY4LDAsMCwwLDAsMCwwLDIyNCw2MywxNTQs
MzIsNCwzMiw2MiwxNjAsMTYyLDMzLDQ0LDY1LDAsMzMsNjQsNjUsMCwzMywzOSwyLDY0LDMsNjQs
MzIsMzksMzIsNiw3OCwxMywxLDMyLDQ0LDMyLDYyLDE2MCwzMyw0NCw2OCwwLDAsMCwwLDAsMCwy
MjQsNjMsMTU0LDMyLDUsMzIsNjMsMTYwLDE2MiwzMyw0NSw2NSwwLDMzLDQwLDIsNjQsMyw2NCwz
Miw0MCwzMiw3LDc4LDEzLDEsMzIsNDUsMzIsNjMsMTYwLDMzLDQ1LDMyLDM1LDMyLDY0LDY1LDgs
MTA4LDEwNiwzMiw0NCw1NywzLDAsMzIsMzYsMzIsNjQsNjUsOCwxMDgsMTA2LDMyLDQ1LDU3LDMs
MCwzMiw2NCw2NSwxLDEwNiwzMyw2NCwzMiw0MCw2NSwxLDEwNiwzMyw0MCwxMiwwLDExLDExLDMy
LDM5LDY1LDEsMTA2LDMzLDM5LDEyLDAsMTEsMTEsMzIsMTQsMzIsMTQsMTYyLDMzLDQ5LDMyLDM1
LDY1LDAsNjUsOCwxMDgsMTA2LDQzLDMsMCwzMiwzNiw2NSwwLDY1LDgsMTA4LDEwNiw0MywzLDAs
NjgsMCwwLDAsMCwwLDAsMCwwLDMyLDM1LDY1LDAsNjUsOCwxMDgsMTA2LDQzLDMsMCwzMiwzNiw2
NSwwLDY1LDgsMTA4LDEwNiw0MywzLDAsNjgsMCwwLDAsMCwwLDAsMCwwLDMyLDE3LDMyLDE4LDMy
LDE5LDMyLDIwLDMyLDIxLDMyLDIyLDMyLDIzLDMyLDM3LDE2LDE2LDMyLDM3LDY1LDAsNjUsOCwx
MDgsMTA2LDQzLDMsMCwzMyw1NywzMiw1MCw2NSwxLDc2LDQsNjQsMzIsMzcsNjUsMCw2NSw4LDEw
OCwxMDYsNDMsMywwLDMzLDU0LDUsNjgsMCwwLDAsMCwwLDAsMCwwLDMzLDU0LDY1LDAsMzMsNjQs
Miw2NCwzLDY0LDMyLDY0LDMyLDUwLDc4LDEzLDEsNjUsMCwzMyw2NSwyLDY0LDMsNjQsMzIsNjUs
MzIsNTAsNzgsMTMsMSwzMiwzNSwzMiw2NCw2NSw4LDEwOCwxMDYsNDMsMywwLDMyLDM2LDMyLDY0
LDY1LDgsMTA4LDEwNiw0MywzLDAsNjgsMCwwLDAsMCwwLDAsMCwwLDMyLDM1LDMyLDY1LDY1LDgs
MTA4LDEwNiw0MywzLDAsMzIsMzYsMzIsNjUsNjUsOCwxMDgsMTA2LDQzLDMsMCw2OCwwLDAsMCww
LDAsMCwwLDAsMzIsMTcsMzIsMTgsMzIsMTksMzIsMjAsMzIsMjEsMzIsMjIsMzIsMjMsMzIsMzcs
MTYsMTYsMzIsMzcsNjUsMSw2NSw4LDEwOCwxMDYsNDMsMywwLDMzLDU1LDMyLDY0LDMyLDY1LDcw
LDQsNjQsMzIsNTUsMzIsMTgsMTYxLDMzLDU1LDExLDMyLDU0LDMyLDU1LDE2MCwzMyw1NCwzMiw2
NSw2NSwxLDEwNiwzMyw2NSwxMiwwLDExLDExLDMyLDY0LDY1LDEsMTA2LDMzLDY0LDEyLDAsMTEs
MTEsMzIsNTQsMzIsNTAsMzIsNTAsMTA4LDE4MywxNjMsMzMsNTQsMTEsNjUsMCwzMyw0MCwyLDY0
LDMsNjQsMzIsNDAsMzIsMSw3OCwxMywxLDMyLDMsMzIsNDAsMTgzLDMyLDUsMTYyLDE2MCwzMyw0
NSw2NSwwLDMzLDM5LDIsNjQsMyw2NCwzMiwzOSwzMiwwLDc4LDEzLDEsMzIsMiwzMiwzOSwxODMs
MzIsNCwxNjIsMTYwLDMzLDQ0LDMyLDM5LDMyLDQwLDMyLDAsMTA4LDEwNiwzMyw3Miw2NSwwLDMz
LDUxLDY1LDAsMzMsNDMsMiw2NCwzLDY0LDMyLDQzLDMyLDEzLDc4LDEzLDEsMzIsMjksMzIsNDMs
NjUsOCwxMDgsMTA2LDY4LDY0LDE0MCwxODEsMTIwLDI5LDE3NSwyMSw2OCw1NywzLDAsMzIsMzAs
MzIsNDMsNjUsOCwxMDgsMTA2LDY4LDAsMCwwLDAsMCwwLDAsMCw1NywzLDAsMzIsNDMsNjUsMSwx
MDYsMzMsNDMsMTIsMCwxMSwxMSw2NSwwLDMzLDQxLDIsNjQsMyw2NCwzMiw0MSwzMiw4LDc4LDEz
LDEsMzIsOSwzMiw0MSw2NSw4LDEwOCwxMDYsNDMsMywwLDMyLDQ0LDE2MSwzMyw0NiwzMiwxMCwz
Miw0MSw2NSw4LDEwOCwxMDYsNDMsMywwLDMyLDQ1LDE2MSwzMyw0NywzMiw0NiwzMiw0NiwxNjIs
MzIsNDcsMzIsNDcsMTYyLDE2MCwzMyw0OCw2NSwwLDMzLDY2LDMyLDQ4LDMyLDQ5LDEwMCw0LDY0
LDY1LDEsMzMsNjYsMTEsMzIsNjYsNjUsMCw3MCwzMiw1MSwzMiwxMyw3MCwxMTMsNCw2NCwzMiw0
OCwzMiwyOSwzMiw1MSw2NSwxLDEwNyw2NSw4LDEwOCwxMDYsNDMsMywwLDEwMCw0LDY0LDY1LDEs
MzMsNjYsMTEsMTEsMzIsNjYsNjUsMCw3MCw0LDY0LDMyLDUxLDMyLDEzLDcyLDQsNjQsMzIsNTEs
NjUsMSwxMDYsMzMsNTEsMTEsMzIsMzAsMzIsNTEsNjUsMSwxMDcsNjUsOCwxMDgsMTA2LDMyLDQx
LDE4Myw1NywzLDAsMzIsMjksMzIsNTEsNjUsMSwxMDcsNjUsOCwxMDgsMTA2LDMyLDQ4LDU3LDMs
MCwzMiw1MSw2NSwxLDEwNywzMyw2Nyw2NSwwLDMzLDY2LDIsNjQsMyw2NCwzMiw2NiwzMiw2Nyw3
OCwxMywxLDMyLDQ4LDMyLDI5LDMyLDY2LDY1LDgsMTA4LDEwNiw0MywzLDAsOTksNCw2NCw2NSww
LDMzLDY4LDIsNjQsMyw2NCwzMiw2OCwzMiw2NywzMiw2NiwxMDcsNzgsMTMsMSwzMiw2Nyw2NSwx
LDEwNywzMiw2OCwxMDcsMzMsNjUsMzIsMjksMzIsNjUsNjUsMSwxMDYsNjUsOCwxMDgsMTA2LDMy
LDI5LDMyLDY1LDY1LDgsMTA4LDEwNiw0MywzLDAsNTcsMywwLDMyLDMwLDMyLDY1LDY1LDEsMTA2
LDY1LDgsMTA4LDEwNiwzMiwzMCwzMiw2NSw2NSw4LDEwOCwxMDYsNDMsMywwLDU3LDMsMCwzMiw2
OCw2NSwxLDEwNiwzMyw2OCwxMiwwLDExLDExLDMyLDI5LDMyLDY2LDY1LDgsMTA4LDEwNiwzMiw0
OCw1NywzLDAsMzIsMzAsMzIsNjYsNjUsOCwxMDgsMTA2LDMyLDQxLDE4Myw1NywzLDAsMTIsMiwx
MSwzMiw2Niw2NSwxLDEwNiwzMyw2NiwxMiwwLDExLDExLDExLDMyLDQxLDY1LDEsMTA2LDMzLDQx
LDEyLDAsMTEsMTEsMzIsNTEsMzIsMTIsNzIsNCw2NCwzMiwyNCwzMiw3Miw2NSw4LDEwOCwxMDYs
NjgsMCwwLDAsMCwwLDU2LDE0Myw2NCwxNTQsNTcsMywwLDMyLDI1LDMyLDcyLDY1LDgsMTA4LDEw
Niw2OCwwLDAsMCwwLDAsNTYsMTQzLDY0LDE1NCw1NywzLDAsNSwzMiw1MSw2NSwxLDcwLDQsNjQs
MzIsMzAsNjUsMCw2NSw4LDEwOCwxMDYsNDMsMywwLDE3MCwzMyw3MCwzMiwyNiw2NSwwLDY1LDgs
MTA4LDEwNiw0MywzLDAsMzIsMjcsNjUsMCw2NSw4LDEwOCwxMDYsNDMsMywwLDY4LDAsMCwwLDAs
MCwwLDAsMCwzMiwyNiw2NSwwLDY1LDgsMTA4LDEwNiw0MywzLDAsMzIsMjcsNjUsMCw2NSw4LDEw
OCwxMDYsNDMsMywwLDY4LDAsMCwwLDAsMCwwLDAsMCwzMiwxNywzMiwxOCwzMiwxOSwzMiwyMCwz
MiwyMSwzMiwyMiwzMiwyMywzMiwzNywxNiwxNiwzMiwzNyw2NSwwLDY1LDgsMTA4LDEwNiw0Mywz
LDAsMzMsNTgsMzIsOSwzMiw3MCw2NSw4LDEwOCwxMDYsNDMsMywwLDMyLDQ0LDE2MSwzMyw1OSwz
MiwxMCwzMiw3MCw2NSw4LDEwOCwxMDYsNDMsMywwLDMyLDQ1LDE2MSwzMyw2MCwzMiw1MCw2NSwx
LDc2LDQsNjQsMzIsNTksMzIsNjAsNjgsMCwwLDAsMCwwLDAsMCwwLDMyLDM1LDY1LDAsNjUsOCwx
MDgsMTA2LDQzLDMsMCwzMiwzNiw2NSwwLDY1LDgsMTA4LDEwNiw0MywzLDAsNjgsMCwwLDAsMCww
LDAsMCwwLDMyLDE3LDMyLDE4LDMyLDE5LDMyLDIwLDMyLDIxLDMyLDIyLDMyLDIzLDMyLDM3LDE2
LDE2LDMyLDM3LDY1LDEsNjUsOCwxMDgsMTA2LDQzLDMsMCwzMyw1Niw1LDY4LDAsMCwwLDAsMCww
LDAsMCwzMyw1Niw2NSwwLDMzLDY0LDIsNjQsMyw2NCwzMiw2NCwzMiw1MCw3OCwxMywxLDMyLDU5
LDMyLDYwLDY4LDAsMCwwLDAsMCwwLDAsMCwzMiwzNSwzMiw2NCw2NSw4LDEwOCwxMDYsNDMsMyww
LDMyLDM2LDMyLDY0LDY1LDgsMTA4LDEwNiw0MywzLDAsNjgsMCwwLDAsMCwwLDAsMCwwLDMyLDE3
LDMyLDE4LDMyLDE5LDMyLDIwLDMyLDIxLDMyLDIyLDMyLDIzLDMyLDM3LDE2LDE2LDMyLDU2LDMy
LDM3LDY1LDEsNjUsOCwxMDgsMTA2LDQzLDMsMCwxNjAsMzMsNTYsMzIsNTksMzIsMzUsMzIsNjQs
NjUsOCwxMDgsMTA2LDQzLDMsMCwxNjEsMzMsNDYsMzIsNjAsMzIsMzYsMzIsNjQsNjUsOCwxMDgs
MTA2LDQzLDMsMCwxNjEsMzMsNDcsMzIsNDYsMzIsNDYsMTYyLDMyLDQ3LDMyLDQ3LDE2MiwxNjAs
NjgsMTg3LDE4OSwyMTUsMjE3LDIyMywxMjQsMjE5LDYxLDk5LDQsNjQsMzIsNTYsMzIsMTgsMTYx
LDMzLDU2LDExLDMyLDY0LDY1LDEsMTA2LDMzLDY0LDEyLDAsMTEsMTEsMzIsNTYsMzIsNTAsMTgz
LDE2MywzMyw1NiwxMSwzMiwxNSw2NSwwLDcwLDQsNjQsMzIsMzMsNjUsMCw2NSw4LDEwOCwxMDYs
MzIsNTYsMzIsNTQsMTYzLDU3LDMsMCwzMiwyNCwzMiw3Miw2NSw4LDEwOCwxMDYsMzIsMzMsNjUs
MCw2NSw4LDEwOCwxMDYsNDMsMywwLDMyLDExLDMyLDcwLDY1LDgsMTA4LDEwNiw0MywzLDAsMTYy
LDY4LDAsMCwwLDAsMCwwLDI0MCw2MywzMiwzMyw2NSwwLDY1LDgsMTA4LDEwNiw0MywzLDAsMTYx
LDMyLDE2LDE2MiwxNjAsNTcsMywwLDMyLDI1LDMyLDcyLDY1LDgsMTA4LDEwNiwzMiw1NCwzMiwz
Myw2NSwwLDY1LDgsMTA4LDEwNiw0MywzLDAsMzIsNTYsMTYyLDE2MSw1NywzLDAsNSwzMiwyNCwz
Miw3Miw2NSw4LDEwOCwxMDYsMzIsMTEsMzIsNzAsNjUsOCwxMDgsMTA2LDQzLDMsMCw1NywzLDAs
MzIsMjUsMzIsNzIsNjUsOCwxMDgsMTA2LDMyLDU0LDY4LDAsMCwwLDAsMCwwLDAsNjQsMzIsNTYs
MTYyLDE2MSwzMiw1OCwxNjAsNTcsMywwLDExLDUsNjUsMCwzMyw0MiwyLDY0LDMsNjQsMzIsNDIs
MzIsNTEsNzgsMTMsMSwzMiwzMCwzMiw0Miw2NSw4LDEwOCwxMDYsNDMsMywwLDE3MCwzMyw3MCwz
MiwyNiwzMiw0Miw2NSw4LDEwOCwxMDYsMzIsOSwzMiw3MCw2NSw4LDEwOCwxMDYsNDMsMywwLDU3
LDMsMCwzMiwyNywzMiw0Miw2NSw4LDEwOCwxMDYsMzIsMTAsMzIsNzAsNjUsOCwxMDgsMTA2LDQz
LDMsMCw1NywzLDAsMzIsMjgsMzIsNDIsNjUsOCwxMDgsMTA2LDMyLDExLDMyLDcwLDY1LDgsMTA4
LDEwNiw0MywzLDAsNTcsMywwLDMyLDQyLDY1LDEsMTA2LDMzLDQyLDEyLDAsMTEsMTEsMzIsNTEs
MzIsMTUsMTA2LDMzLDUyLDMyLDUyLDY1LDEsMTA2LDMyLDUyLDEwOCw2NSwyLDEwOSwzMyw1Myw2
NSwwLDMzLDcxLDY1LDAsMzMsNjUsMiw2NCwzLDY0LDMyLDY1LDMyLDUxLDc4LDEzLDEsNjUsMCwz
Myw2NCwyLDY0LDMsNjQsMzIsNjQsMzIsNjUsNjUsMSwxMDYsNzgsMTMsMSwzMiwyNiwzMiw2NCw2
NSw4LDEwOCwxMDYsNDMsMywwLDMyLDI3LDMyLDY0LDY1LDgsMTA4LDEwNiw0MywzLDAsNjgsMCww
LDAsMCwwLDAsMCwwLDMyLDI2LDMyLDY1LDY1LDgsMTA4LDEwNiw0MywzLDAsMzIsMjcsMzIsNjUs
NjUsOCwxMDgsMTA2LDQzLDMsMCw2OCwwLDAsMCwwLDAsMCwwLDAsMzIsMTcsMzIsMTgsMzIsMTks
MzIsMjAsMzIsMjEsMzIsMjIsMzIsMjMsMzIsMzcsMTYsMTYsMzIsMzQsMzIsNzEsNjUsOCwxMDgs
MTA2LDMyLDM3LDY1LDEsNjUsOCwxMDgsMTA2LDQzLDMsMCw1NywzLDAsMzIsNzEsNjUsMSwxMDYs
MzMsNzEsMzIsNjQsNjUsMSwxMDYsMzMsNjQsMTIsMCwxMSwxMSwzMiwyNiwzMiw2NSw2NSw4LDEw
OCwxMDYsNDMsMywwLDMyLDQ0LDE2MSwzMyw1OSwzMiwyNywzMiw2NSw2NSw4LDEwOCwxMDYsNDMs
MywwLDMyLDQ1LDE2MSwzMyw2MCwzMiw1MCw2NSwxLDc2LDQsNjQsMzIsNTksMzIsNjAsNjgsMCww
LDAsMCwwLDAsMCwwLDMyLDM1LDY1LDAsNjUsOCwxMDgsMTA2LDQzLDMsMCwzMiwzNiw2NSwwLDY1
LDgsMTA4LDEwNiw0MywzLDAsNjgsMCwwLDAsMCwwLDAsMCwwLDMyLDE3LDMyLDE4LDMyLDE5LDMy
LDIwLDMyLDIxLDMyLDIyLDMyLDIzLDMyLDM3LDE2LDE2LDMyLDM3LDY1LDEsNjUsOCwxMDgsMTA2
LDQzLDMsMCwzMyw1Niw1LDY4LDAsMCwwLDAsMCwwLDAsMCwzMyw1Niw2NSwwLDMzLDY0LDIsNjQs
Myw2NCwzMiw2NCwzMiw1MCw3OCwxMywxLDMyLDU5LDMyLDYwLDY4LDAsMCwwLDAsMCwwLDAsMCwz
MiwzNSwzMiw2NCw2NSw4LDEwOCwxMDYsNDMsMywwLDMyLDM2LDMyLDY0LDY1LDgsMTA4LDEwNiw0
MywzLDAsNjgsMCwwLDAsMCwwLDAsMCwwLDMyLDE3LDMyLDE4LDMyLDE5LDMyLDIwLDMyLDIxLDMy
LDIyLDMyLDIzLDMyLDM3LDE2LDE2LDMyLDU2LDMyLDM3LDY1LDEsNjUsOCwxMDgsMTA2LDQzLDMs
MCwxNjAsMzMsNTYsMzIsNTksMzIsMzUsMzIsNjQsNjUsOCwxMDgsMTA2LDQzLDMsMCwxNjEsMzMs
NDYsMzIsNjAsMzIsMzYsMzIsNjQsNjUsOCwxMDgsMTA2LDQzLDMsMCwxNjEsMzMsNDcsMzIsNDYs
MzIsNDYsMTYyLDMyLDQ3LDMyLDQ3LDE2MiwxNjAsNjgsMTg3LDE4OSwyMTUsMjE3LDIyMywxMjQs
MjE5LDYxLDk5LDQsNjQsMzIsNTYsMzIsMTgsMTYxLDMzLDU2LDExLDMyLDY0LDY1LDEsMTA2LDMz
LDY0LDEyLDAsMTEsMTEsMzIsNTYsMzIsNTAsMTgzLDE2MywzMyw1NiwxMSwzMiwzMSwzMiw2NSw2
NSw4LDEwOCwxMDYsMzIsNTYsNTcsMywwLDMyLDMyLDMyLDY1LDY1LDgsMTA4LDEwNiwzMiw1Niw1
NywzLDAsMzIsNjUsNjUsMSwxMDYsMzMsNjUsMTIsMCwxMSwxMSwzMiwxNSw2NSwxLDcwLDQsNjQs
NjUsMCwzMyw2NCwyLDY0LDMsNjQsMzIsNjQsMzIsNTEsNzgsMTMsMSwzMiwzNCwzMiw3MSw2NSw4
LDEwOCwxMDYsMzIsNTcsNTcsMywwLDMyLDcxLDY1LDEsMTA2LDMzLDcxLDMyLDY0LDY1LDEsMTA2
LDMzLDY0LDEyLDAsMTEsMTEsMzIsMzQsMzIsNzEsNjUsOCwxMDgsMTA2LDY4LDAsMCwwLDAsMCww
LDAsMCw1NywzLDAsMzIsMzEsMzIsNTIsNjUsMSwxMDcsNjUsOCwxMDgsMTA2LDMyLDU3LDU3LDMs
MCwzMiwzMiwzMiw1Miw2NSwxLDEwNyw2NSw4LDEwOCwxMDYsMzIsNTcsNTcsMywwLDExLDMyLDUy
LDMyLDM0LDMyLDMxLDMyLDMzLDMyLDM4LDE2LDIwLDMyLDM4LDY1LDAsNjUsOCwxMDgsMTA2LDQz
LDMsMCwzMyw3MywzMiw3Myw2OCwwLDAsMCwwLDAsMCwwLDAsOTgsNCw2NCwzMiwyNCwzMiw3Miw2
NSw4LDEwOCwxMDYsNjgsMCwwLDAsMCwwLDU2LDE0Myw2NCwxNTQsNTcsMywwLDMyLDI1LDMyLDcy
LDY1LDgsMTA4LDEwNiw2OCwwLDAsMCwwLDAsNTYsMTQzLDY0LDE1NCw1NywzLDAsNSw2OCwwLDAs
MCwwLDAsMCwwLDAsMzMsNjEsMzIsMjQsMzIsNzIsNjUsOCwxMDgsMTA2LDY4LDAsMCwwLDAsMCww
LDAsMCw1NywzLDAsMzIsMjUsMzIsNzIsNjUsOCwxMDgsMTA2LDMyLDU0LDU3LDMsMCwzMiwxNSw2
NSwxLDcwLDQsNjQsMzIsMjUsMzIsNzIsNjUsOCwxMDgsMTA2LDMyLDI1LDMyLDcyLDY1LDgsMTA4
LDEwNiw0MywzLDAsMzIsMzMsMzIsNTEsNjUsOCwxMDgsMTA2LDQzLDMsMCwzMiw1NywxNjIsMTYx
LDU3LDMsMCwxMSw2NSwwLDMzLDY0LDIsNjQsMyw2NCwzMiw2NCwzMiw1MSw3OCwxMywxLDMyLDYx
LDMyLDMzLDMyLDY0LDY1LDgsMTA4LDEwNiw0MywzLDAsMTYwLDMzLDYxLDMyLDI0LDMyLDcyLDY1
LDgsMTA4LDEwNiwzMiwyNCwzMiw3Miw2NSw4LDEwOCwxMDYsNDMsMywwLDMyLDMzLDMyLDY0LDY1
LDgsMTA4LDEwNiw0MywzLDAsMzIsMjgsMzIsNjQsNjUsOCwxMDgsMTA2LDQzLDMsMCwxNjIsMTYw
LDU3LDMsMCwzMiwyNSwzMiw3Miw2NSw4LDEwOCwxMDYsMzIsMjUsMzIsNzIsNjUsOCwxMDgsMTA2
LDQzLDMsMCwzMiwzMywzMiw2NCw2NSw4LDEwOCwxMDYsNDMsMywwLDMyLDMyLDMyLDY0LDY1LDgs
MTA4LDEwNiw0MywzLDAsMTYyLDE2MSw1NywzLDAsMzIsNjQsNjUsMSwxMDYsMzMsNjQsMTIsMCwx
MSwxMSwzMiwxNSw2NSwwLDcwLDQsNjQsMzIsMjQsMzIsNzIsNjUsOCwxMDgsMTA2LDMyLDI0LDMy
LDcyLDY1LDgsMTA4LDEwNiw0MywzLDAsNjgsMCwwLDAsMCwwLDAsMjQwLDYzLDMyLDYxLDE2MSwz
MiwxNiwxNjIsMTYwLDU3LDMsMCwxMSwxMSwxMSwxMSwzMiwzOSw2NSwxLDEwNiwzMywzOSwxMiww
LDExLDExLDMyLDQwLDY1LDEsMTA2LDMzLDQwLDEyLDAsMTEsMTEsMTEsMTMwLDQ0LDExLDUsMTI3
LDMsMTI0LDUsMTI3LDgsMTI0LDYsMTI3LDYsMTI0LDMsMTI3LDYsMTI0LDEsMTI3LDcsMTI0LDEs
MTI3LDMyLDIwLDMyLDIwLDE2MiwzMyw4MiwzMiwzMCwzMyw4MCw2NSwwLDMzLDg1LDIsNjQsMyw2
NCwzMiw4NSwzMiwyOSw3OCwxMywxLDMyLDMxLDMyLDg1LDY1LDQsMTA4LDEwNiw0MCwyLDAsNjUs
NCw3MCw0LDY0LDMyLDgwLDY4LDAsMCwwLDAsMCw1NiwxNDMsNjQsMTYwLDMzLDgwLDUsMzIsODAs
MzIsMzIsMzIsODUsNjUsOCwxMDgsMTA2LDQzLDMsMCwxNjAsMzMsODAsMTEsMzIsODUsNjUsMSwx
MDYsMzMsODUsMTIsMCwxMSwxMSwzMiw4Miw2OCwwLDAsMCwwLDAsMCwyNDAsNjMsOTksNCw2NCw2
OCwwLDAsMCwwLDAsMCwwLDY0LDMyLDIwLDE2MiwzMiw4MCw2OCw0NSw2NywyOCwyMzUsMjI2LDU0
LDI2LDYzLDE2NSwxNjMsMzMsODEsNSw2OCwwLDAsMCwwLDAsMCwxNiw2NCwzMiw4MiwxNjIsMzIs
ODAsNjgsNDUsNjcsMjgsMjM1LDIyNiw1NCwyNiw2MywxNjUsMTYzLDMzLDgxLDExLDY4LDAsMCww
LDAsMCwwLDI0MCw2MywzMiw4MSwxNjMsMzMsODEsMzIsMzQsMzIsMjksMTA2LDMzLDgzLDY1LDEs
MzMsNzMsNjUsMCwzMyw4NSwyLDY0LDMsNjQsMzIsODUsNjUsOSw3OCwxMywxLDMyLDczLDMyLDI4
LDMyLDg1LDY1LDQsMTA4LDEwNiw0MCwyLDAsMTA2LDMzLDczLDMyLDg1LDY1LDEsMTA2LDMzLDg1
LDEyLDAsMTEsMTEsMzIsMjYsNjUsMyw3MCw0LDY0LDMyLDczLDY1LDEsMTA2LDMzLDczLDExLDMy
LDI2LDY1LDAsNzAsMzIsMjYsNjUsMiw3MCwxMTQsNCw2NCw2NSwwLDMzLDczLDExLDMyLDksMzIs
MTAsMTA4LDMyLDExLDEwOCwzMyw3MCwzMiw2LDMyLDksMTgzLDY4LDAsMCwwLDAsMCwwLDI0MCw2
MywxNjUsMTYzLDMzLDkyLDMyLDcsMzIsMTAsMTgzLDY4LDAsMCwwLDAsMCwwLDI0MCw2MywxNjUs
MTYzLDMzLDkzLDMyLDgsMzIsMTEsMTgzLDY4LDAsMCwwLDAsMCwwLDI0MCw2MywxNjUsMTYzLDMz
LDk0LDY1LDAsMzMsODUsNjgsMCwwLDAsMCwwLDAsMjI0LDYzLDE1NCwzMiw2LDMyLDkyLDE2MCwx
NjIsMzMsNjcsNjUsMCwzMyw2MiwyLDY0LDMsNjQsMzIsNjIsMzIsOSw3OCwxMywxLDMyLDY3LDMy
LDkyLDE2MCwzMyw2Nyw2OCwwLDAsMCwwLDAsMCwyMjQsNjMsMTU0LDMyLDcsMzIsOTMsMTYwLDE2
MiwzMyw2OCw2NSwwLDMzLDYzLDIsNjQsMyw2NCwzMiw2MywzMiwxMCw3OCwxMywxLDMyLDY4LDMy
LDkzLDE2MCwzMyw2OCw2OCwwLDAsMCwwLDAsMCwyMjQsNjMsMTU0LDMyLDgsMzIsOTQsMTYwLDE2
MiwzMyw2OSw2NSwwLDMzLDY0LDIsNjQsMyw2NCwzMiw2NCwzMiwxMSw3OCwxMywxLDMyLDY5LDMy
LDk0LDE2MCwzMyw2OSwzMiw1MywzMiw4NSw2NSw4LDEwOCwxMDYsMzIsNjcsNjgsMCwwLDAsMCww
LDAsMjI0LDYzLDMyLDYsMTYyLDE2MCw1NywzLDAsMzIsNTQsMzIsODUsNjUsOCwxMDgsMTA2LDMy
LDY4LDY4LDAsMCwwLDAsMCwwLDIyNCw2MywzMiw3LDE2MiwxNjAsNTcsMywwLDMyLDU1LDMyLDg1
LDY1LDgsMTA4LDEwNiwzMiw2OSw2OCwwLDAsMCwwLDAsMCwyMjQsNjMsMzIsOCwxNjIsMTYwLDU3
LDMsMCwzMiw4NSw2NSwxLDEwNiwzMyw4NSwzMiw2NCw2NSwxLDEwNiwzMyw2NCwxMiwwLDExLDEx
LDMyLDYzLDY1LDEsMTA2LDMzLDYzLDEyLDAsMTEsMTEsMzIsNjIsNjUsMSwxMDYsMzMsNjIsMTIs
MCwxMSwxMSwzMiw1Myw2NSwwLDY1LDgsMTA4LDEwNiw0MywzLDAsMzIsNTQsNjUsMCw2NSw4LDEw
OCwxMDYsNDMsMywwLDMyLDU1LDY1LDAsNjUsOCwxMDgsMTA2LDQzLDMsMCwzMiw1Myw2NSwwLDY1
LDgsMTA4LDEwNiw0MywzLDAsMzIsNTQsNjUsMCw2NSw4LDEwOCwxMDYsNDMsMywwLDMyLDU1LDY1
LDAsNjUsOCwxMDgsMTA2LDQzLDMsMCwzMiwyOSwzMiwzMCwzMiwzMSwzMiwzMiwzMiwzMywzMiwz
NCwzMiwzNSwzMiw1NywxNiwxNiwzMiw1Nyw2NSwwLDY1LDgsMTA4LDEwNiw0MywzLDAsMzMsNzks
MzIsNTcsNjUsMCw2NSw4LDEwOCwxMDYsNDMsMywwLDMzLDc1LDMyLDcwLDY1LDEsNzQsNCw2NCw2
OCwwLDAsMCwwLDAsMCwwLDAsMzMsNzUsNjUsMCwzMyw4NSwyLDY0LDMsNjQsMzIsODUsMzIsNzAs
NzgsMTMsMSw2NSwwLDMzLDg2LDIsNjQsMyw2NCwzMiw4NiwzMiw3MCw3OCwxMywxLDMyLDUzLDMy
LDg1LDY1LDgsMTA4LDEwNiw0MywzLDAsMzIsNTQsMzIsODUsNjUsOCwxMDgsMTA2LDQzLDMsMCwz
Miw1NSwzMiw4NSw2NSw4LDEwOCwxMDYsNDMsMywwLDMyLDUzLDMyLDg2LDY1LDgsMTA4LDEwNiw0
MywzLDAsMzIsNTQsMzIsODYsNjUsOCwxMDgsMTA2LDQzLDMsMCwzMiw1NSwzMiw4Niw2NSw4LDEw
OCwxMDYsNDMsMywwLDMyLDI5LDMyLDMwLDMyLDMxLDMyLDMyLDMyLDMzLDMyLDM0LDMyLDM1LDMy
LDU3LDE2LDE2LDMyLDU3LDY1LDEsNjUsOCwxMDgsMTA2LDQzLDMsMCwzMyw3NiwzMiw4NSwzMiw4
Niw3MCw0LDY0LDMyLDc2LDMyLDMwLDE2MSwzMyw3NiwxMSwzMiw3NSwzMiw3NiwxNjAsMzMsNzUs
MzIsODYsNjUsMSwxMDYsMzMsODYsMTIsMCwxMSwxMSwzMiw4NSw2NSwxLDEwNiwzMyw4NSwxMiww
LDExLDExLDMyLDc1LDMyLDcwLDMyLDcwLDEwOCwxODMsMTYzLDMzLDc1LDExLDY1LDAsMzMsODUs
Miw2NCwzLDY0LDMyLDg1LDY1LDksNzgsMTMsMSwzMiw0MSw2NSw5LDMyLDg1LDEwNiw2NSw4LDEw
OCwxMDYsNjgsMCwwLDAsMCwwLDAsMCwwLDU3LDMsMCwzMiw4NSw2NSwxLDEwNiwzMyw4NSwxMiww
LDExLDExLDY1LDAsMzMsODUsMiw2NCwzLDY0LDMyLDg1LDMyLDcwLDc4LDEzLDEsMzIsNDEsNjUs
OSw2NSw4LDEwOCwxMDYsMzIsNDEsNjUsOSw2NSw4LDEwOCwxMDYsNDMsMywwLDMyLDUzLDMyLDg1
LDY1LDgsMTA4LDEwNiw0MywzLDAsMTYwLDU3LDMsMCwzMiw0MSw2NSwxMCw2NSw4LDEwOCwxMDYs
MzIsNDEsNjUsMTAsNjUsOCwxMDgsMTA2LDQzLDMsMCwzMiw1NCwzMiw4NSw2NSw4LDEwOCwxMDYs
NDMsMywwLDE2MCw1NywzLDAsMzIsNDEsNjUsMTEsNjUsOCwxMDgsMTA2LDMyLDQxLDY1LDExLDY1
LDgsMTA4LDEwNiw0MywzLDAsMzIsNTUsMzIsODUsNjUsOCwxMDgsMTA2LDQzLDMsMCwxNjAsNTcs
MywwLDMyLDQxLDY1LDEyLDY1LDgsMTA4LDEwNiwzMiw0MSw2NSwxMiw2NSw4LDEwOCwxMDYsNDMs
MywwLDMyLDUzLDMyLDg1LDY1LDgsMTA4LDEwNiw0MywzLDAsMzIsNTMsMzIsODUsNjUsOCwxMDgs
MTA2LDQzLDMsMCwxNjIsMTYwLDU3LDMsMCwzMiw0MSw2NSwxMyw2NSw4LDEwOCwxMDYsMzIsNDEs
NjUsMTMsNjUsOCwxMDgsMTA2LDQzLDMsMCwzMiw1NCwzMiw4NSw2NSw4LDEwOCwxMDYsNDMsMyww
LDMyLDU0LDMyLDg1LDY1LDgsMTA4LDEwNiw0MywzLDAsMTYyLDE2MCw1NywzLDAsMzIsNDEsNjUs
MTQsNjUsOCwxMDgsMTA2LDMyLDQxLDY1LDE0LDY1LDgsMTA4LDEwNiw0MywzLDAsMzIsNTUsMzIs
ODUsNjUsOCwxMDgsMTA2LDQzLDMsMCwzMiw1NSwzMiw4NSw2NSw4LDEwOCwxMDYsNDMsMywwLDE2
MiwxNjAsNTcsMywwLDMyLDQxLDY1LDE1LDY1LDgsMTA4LDEwNiwzMiw0MSw2NSwxNSw2NSw4LDEw
OCwxMDYsNDMsMywwLDMyLDUzLDMyLDg1LDY1LDgsMTA4LDEwNiw0MywzLDAsMzIsNTQsMzIsODUs
NjUsOCwxMDgsMTA2LDQzLDMsMCwxNjIsMTYwLDU3LDMsMCwzMiw0MSw2NSwxNiw2NSw4LDEwOCwx
MDYsMzIsNDEsNjUsMTYsNjUsOCwxMDgsMTA2LDQzLDMsMCwzMiw1MywzMiw4NSw2NSw4LDEwOCwx
MDYsNDMsMywwLDMyLDU1LDMyLDg1LDY1LDgsMTA4LDEwNiw0MywzLDAsMTYyLDE2MCw1NywzLDAs
MzIsNDEsNjUsMTcsNjUsOCwxMDgsMTA2LDMyLDQxLDY1LDE3LDY1LDgsMTA4LDEwNiw0MywzLDAs
MzIsNTQsMzIsODUsNjUsOCwxMDgsMTA2LDQzLDMsMCwzMiw1NSwzMiw4NSw2NSw4LDEwOCwxMDYs
NDMsMywwLDE2MiwxNjAsNTcsMywwLDMyLDg1LDY1LDEsMTA2LDMzLDg1LDEyLDAsMTEsMTEsNjUs
MCwzMyw4NSwyLDY0LDMsNjQsMzIsODUsNjUsOSw3OCwxMywxLDMyLDQxLDY1LDksMzIsODUsMTA2
LDY1LDgsMTA4LDEwNiwzMiw0MSw2NSw5LDMyLDg1LDEwNiw2NSw4LDEwOCwxMDYsNDMsMywwLDMy
LDcwLDE4Myw2OCwwLDAsMCwwLDAsMCwyNDAsNjMsMTY1LDE2MywzMiw4MSwxNjIsNTcsMywwLDMy
LDg1LDY1LDEsMTA2LDMzLDg1LDEyLDAsMTEsMTEsMzIsNDEsNjUsMCw2NSw4LDEwOCwxMDYsNDMs
MywwLDE3MCwzMyw5NSwzMiw0MSw2NSwxLDY1LDgsMTA4LDEwNiw0MywzLDAsMTcwLDMzLDk2LDMy
LDQxLDY1LDIsNjUsOCwxMDgsMTA2LDQzLDMsMCwxNzAsMzMsOTcsMzIsNDEsNjUsMyw2NSw4LDEw
OCwxMDYsNDMsMywwLDMzLDk4LDMyLDQxLDY1LDQsNjUsOCwxMDgsMTA2LDQzLDMsMCwzMyw5OSwz
Miw0MSw2NSw1LDY1LDgsMTA4LDEwNiw0MywzLDAsMzMsMTAwLDMyLDQxLDY1LDYsNjUsOCwxMDgs
MTA2LDQzLDMsMCwzMywxMDEsMzIsNDEsNjUsNyw2NSw4LDEwOCwxMDYsNDMsMywwLDMzLDEwMiwz
Miw0MSw2NSw4LDY1LDgsMTA4LDEwNiw0MywzLDAsMzMsMTAzLDMyLDAsMzIsMSwxMDgsMzMsMTA0
LDY1LDAsMzMsNjUsMiw2NCwzLDY0LDMyLDY1LDMyLDAsMzIsMSwxMDgsMzIsMiwxMDgsNzgsMTMs
MSwzMiw2NSwzMiwxMDQsMTA5LDMzLDY0LDMyLDY1LDMyLDY0LDMyLDEwNCwxMDgsMTA3LDMyLDAs
MTA5LDMzLDYzLDMyLDY1LDMyLDY0LDMyLDEwNCwxMDgsMTA3LDMyLDYzLDMyLDAsMTA4LDEwNywz
Myw2MiwzMiwzLDMyLDYyLDE4MywzMiw2LDE2MiwxNjAsMzMsNjcsMzIsNCwzMiw2MywxODMsMzIs
NywxNjIsMTYwLDMzLDY4LDMyLDUsMzIsNjQsMTgzLDMyLDgsMTYyLDE2MCwzMyw2OSwzMiw2NSwz
Myw2Niw2NSwwLDMzLDExMiwzMiw2NywzMiw2OCwzMiw2OSwzMiw4MiwzMiw4MywzMiwzNSwzMiwz
NiwzMiwzNywzMiwzOCwzMiwzOSw2NSwwLDMyLDEyLDMyLDEzLDMyLDE0LDMyLDE1LDMyLDQ0LDMy
LDU2LDMyLDQwLDMyLDk1LDMyLDk4LDMyLDEwMSwzMiw5NiwzMiw5OSwzMiwxMDIsMzIsOTcsMzIs
MTAwLDMyLDEwMywzMiw1NywzMiw1OSwzMiw1OCwzMiw2MCwzMiw2MSwxNiwxOSwzMiw1Nyw2NSww
LDY1LDgsMTA4LDEwNiw0MywzLDAsMTcwLDMzLDc0LDY1LDAsMzMsNzEsNjUsMCwzMyw4NSwyLDY0
LDMsNjQsMzIsODUsMzIsNzQsNzgsMTMsMSwzMiw1NiwzMiw4NSw2NSw4LDEwOCwxMDYsNDMsMyww
LDY4LDAsMCwwLDAsMCwwLDIyNCw2MywxNjAsMTcwLDMzLDg0LDMyLDcxLDMyLDE5LDcyLDQsNjQs
MzIsNDQsMzIsNzEsNjUsOCwxMDgsMTA2LDMyLDEzLDMyLDg0LDY1LDgsMTA4LDEwNiw0MywzLDAs
MzIsNjcsMTYxLDY4LDAsMCwwLDAsMCwwLDIyNCw2MywzMiw2LDE2MiwxNjAsNTcsMywwLDMyLDQ1
LDMyLDcxLDY1LDgsMTA4LDEwNiwzMiwxNCwzMiw4NCw2NSw4LDEwOCwxMDYsNDMsMywwLDMyLDY4
LDE2MSw2OCwwLDAsMCwwLDAsMCwyMjQsNjMsMzIsNywxNjIsMTYwLDU3LDMsMCwzMiw0NiwzMiw3
MSw2NSw4LDEwOCwxMDYsMzIsMTUsMzIsODQsNjUsOCwxMDgsMTA2LDQzLDMsMCwzMiw2OSwxNjEs
NjgsMCwwLDAsMCwwLDAsMjI0LDYzLDMyLDgsMTYyLDE2MCw1NywzLDAsMzIsNDcsMzIsNzEsNjUs
OCwxMDgsMTA2LDMyLDE2LDMyLDg0LDY1LDgsMTA4LDEwNiw0MywzLDAsNTcsMywwLDMyLDQ4LDMy
LDcxLDY1LDgsMTA4LDEwNiwzMiwxNywzMiw4NCw2NSw4LDEwOCwxMDYsNDMsMywwLDU3LDMsMCwz
Miw3MSw2NSwxLDEwNiwzMyw3MSwxMSwzMiw4NSw2NSwxLDEwNiwzMyw4NSwxMiwwLDExLDExLDMy
LDcxLDMyLDE4LDcyLDQsNjQsMzIsNDIsMzIsNjYsNjUsOCwxMDgsMTA2LDY4LDAsMCwwLDAsMCw1
NiwxNDMsNjQsMTU0LDU3LDMsMCwzMiw0MywzMiw2Niw2NSw4LDEwOCwxMDYsNjgsMCwwLDAsMCww
LDU2LDE0Myw2NCwxNTQsNTcsMywwLDY1LDEsMzMsMTEyLDExLDMyLDExMiw2NSwwLDcwLDMyLDcx
LDY1LDEsNzgsMTEzLDMyLDcxLDMyLDczLDc2LDExMyw0LDY0LDMyLDQyLDMyLDY2LDY1LDgsMTA4
LDEwNiw2OCwwLDAsMCwwLDAsNTYsMTQzLDY0LDE1NCw1NywzLDAsMzIsNDMsMzIsNjYsNjUsOCwx
MDgsMTA2LDY4LDAsMCwwLDAsMCw1NiwxNDMsNjQsMTU0LDU3LDMsMCw2NSwxLDMzLDExMiwxMSwz
MiwxMTIsNjUsMCw3MCwzMiw3MSw2NSwxLDc2LDExMyw0LDY0LDMyLDQ0LDY1LDAsNjUsOCwxMDgs
MTA2LDQzLDMsMCwzMiw0NSw2NSwwLDY1LDgsMTA4LDEwNiw0MywzLDAsMzIsNDYsNjUsMCw2NSw4
LDEwOCwxMDYsNDMsMywwLDMyLDQ0LDY1LDAsNjUsOCwxMDgsMTA2LDQzLDMsMCwzMiw0NSw2NSww
LDY1LDgsMTA4LDEwNiw0MywzLDAsMzIsNDYsNjUsMCw2NSw4LDEwOCwxMDYsNDMsMywwLDMyLDI5
LDMyLDMwLDMyLDMxLDMyLDMyLDMyLDMzLDMyLDM0LDMyLDM1LDMyLDU3LDE2LDE2LDMyLDU3LDY1
LDAsNjUsOCwxMDgsMTA2LDQzLDMsMCwzMyw3OCwzMiw3MCw2NSwxLDc2LDQsNjQsMzIsNDQsNjUs
MCw2NSw4LDEwOCwxMDYsNDMsMywwLDMyLDQ1LDY1LDAsNjUsOCwxMDgsMTA2LDQzLDMsMCwzMiw0
Niw2NSwwLDY1LDgsMTA4LDEwNiw0MywzLDAsMzIsNTMsNjUsMCw2NSw4LDEwOCwxMDYsNDMsMyww
LDMyLDU0LDY1LDAsNjUsOCwxMDgsMTA2LDQzLDMsMCwzMiw1NSw2NSwwLDY1LDgsMTA4LDEwNiw0
MywzLDAsMzIsMjksMzIsMzAsMzIsMzEsMzIsMzIsMzIsMzMsMzIsMzQsMzIsMzUsMzIsNTcsMTYs
MTYsMzIsNTcsNjUsMSw2NSw4LDEwOCwxMDYsNDMsMywwLDMzLDc3LDUsNjgsMCwwLDAsMCwwLDAs
MCwwLDMzLDc3LDY1LDAsMzMsODUsMiw2NCwzLDY0LDMyLDg1LDMyLDcwLDc4LDEzLDEsMzIsNDQs
NjUsMCw2NSw4LDEwOCwxMDYsNDMsMywwLDMyLDQ1LDY1LDAsNjUsOCwxMDgsMTA2LDQzLDMsMCwz
Miw0Niw2NSwwLDY1LDgsMTA4LDEwNiw0MywzLDAsMzIsNTMsMzIsODUsNjUsOCwxMDgsMTA2LDQz
LDMsMCwzMiw1NCwzMiw4NSw2NSw4LDEwOCwxMDYsNDMsMywwLDMyLDU1LDMyLDg1LDY1LDgsMTA4
LDEwNiw0MywzLDAsMzIsMjksMzIsMzAsMzIsMzEsMzIsMzIsMzIsMzMsMzIsMzQsMzIsMzUsMzIs
NTcsMTYsMTYsMzIsNzcsMzIsNTcsNjUsMSw2NSw4LDEwOCwxMDYsNDMsMywwLDE2MCwzMyw3Nywz
Miw0NCw2NSwwLDY1LDgsMTA4LDEwNiw0MywzLDAsMzIsNTMsMzIsODUsNjUsOCwxMDgsMTA2LDQz
LDMsMCwxNjEsMzMsODksMzIsNDUsNjUsMCw2NSw4LDEwOCwxMDYsNDMsMywwLDMyLDU0LDMyLDg1
LDY1LDgsMTA4LDEwNiw0MywzLDAsMTYxLDMzLDkwLDMyLDQ2LDY1LDAsNjUsOCwxMDgsMTA2LDQz
LDMsMCwzMiw1NSwzMiw4NSw2NSw4LDEwOCwxMDYsNDMsMywwLDE2MSwzMyw5MSwzMiw4OSwzMiw4
OSwxNjIsMzIsOTAsMzIsOTAsMTYyLDE2MCwzMiw5MSwzMiw5MSwxNjIsMTYwLDY4LDE0MSwyMzcs
MTgxLDE2MCwyNDcsMTk4LDE3Niw2Miw5OSw0LDY0LDMyLDc3LDMyLDMwLDE2MSwzMyw3NywxMSwz
Miw4NSw2NSwxLDEwNiwzMyw4NSwxMiwwLDExLDExLDMyLDc3LDMyLDcwLDE4MywxNjMsMzMsNzcs
MTEsMzIsMjcsMzMsMTEwLDMyLDI2LDY1LDIsNzAsNCw2NCwzMiw0OCw2NSwwLDY1LDgsMTA4LDEw
Niw0MywzLDAsMzMsMTEwLDExLDMyLDI2LDY1LDAsNzAsMzIsMjYsNjUsMiw3MCwxMTQsNCw2NCwz
Miw3NywzMiw3OCwxNjMsMzMsMTA2LDMyLDQyLDMyLDY2LDY1LDgsMTA4LDEwNiwzMiwxMDYsMzIs
NDcsNjUsMCw2NSw4LDEwOCwxMDYsNDMsMywwLDE2Miw2OCwwLDAsMCwwLDAsMCwyNDAsNjMsMzIs
MTA2LDE2MSwzMiwxMTAsMTYyLDE2MCw1NywzLDAsMzIsNDMsMzIsNjYsNjUsOCwxMDgsMTA2LDMy
LDc1LDMyLDEwNiwzMiw3NywxNjIsMTYxLDU3LDMsMCw1LDMyLDQyLDMyLDY2LDY1LDgsMTA4LDEw
NiwzMiw0Nyw2NSwwLDY1LDgsMTA4LDEwNiw0MywzLDAsNTcsMywwLDMyLDQzLDMyLDY2LDY1LDgs
MTA4LDEwNiwzMiw3NSw2OCwwLDAsMCwwLDAsMCwwLDY0LDMyLDc3LDE2MiwxNjEsMzIsNzgsMTYw
LDU3LDMsMCwxMSw2NSwxLDMzLDExMiwxMSwzMiwxMTIsNjUsMCw3MCw0LDY0LDMyLDczLDMyLDcx
LDEwNiwzMyw3Miw2NSwwLDMzLDg1LDIsNjQsMyw2NCwzMiw4NSwzMiw3MiwzMiw3MiwxMDgsNzgs
MTMsMSwzMiw1MiwzMiw4NSw2NSw4LDEwOCwxMDYsNjgsMCwwLDAsMCwwLDAsMCwwLDU3LDMsMCwz
Miw4NSw2NSwxLDEwNiwzMyw4NSwxMiwwLDExLDExLDY1LDAsMzMsODUsMiw2NCwzLDY0LDMyLDg1
LDMyLDcxLDc4LDEzLDEsMzIsODUsMzMsODYsMiw2NCwzLDY0LDMyLDg2LDMyLDcxLDc4LDEzLDEs
MzIsNDQsMzIsODUsNjUsOCwxMDgsMTA2LDQzLDMsMCwzMiw0NSwzMiw4NSw2NSw4LDEwOCwxMDYs
NDMsMywwLDMyLDQ2LDMyLDg1LDY1LDgsMTA4LDEwNiw0MywzLDAsMzIsNDQsMzIsODYsNjUsOCwx
MDgsMTA2LDQzLDMsMCwzMiw0NSwzMiw4Niw2NSw4LDEwOCwxMDYsNDMsMywwLDMyLDQ2LDMyLDg2
LDY1LDgsMTA4LDEwNiw0MywzLDAsMzIsMjksMzIsMzAsMzIsMzEsMzIsMzIsMzIsMzMsMzIsMzQs
MzIsMzUsMzIsNTcsMTYsMTYsMzIsNTcsNjUsMSw2NSw4LDEwOCwxMDYsNDMsMywwLDMzLDc2LDMy
LDUyLDMyLDg2LDMyLDcyLDEwOCwzMiw4NSwxMDYsNjUsOCwxMDgsMTA2LDMyLDc2LDU3LDMsMCwz
Miw1MiwzMiw4NSwzMiw3MiwxMDgsMzIsODYsMTA2LDY1LDgsMTA4LDEwNiwzMiw3Niw1NywzLDAs
MzIsODYsNjUsMSwxMDYsMzMsODYsMTIsMCwxMSwxMSwzMiw4NSw2NSwxLDEwNiwzMyw4NSwxMiww
LDExLDExLDMyLDcyLDMyLDcxLDc0LDQsNjQsNjUsMCwzMyw4NSwyLDY0LDMsNjQsMzIsODUsMzIs
NzEsNzgsMTMsMSwzMiw1MiwzMiw3MSwzMiw3MiwxMDgsMzIsODUsMTA2LDY1LDgsMTA4LDEwNiwz
Miw3OSw1NywzLDAsMzIsNTIsMzIsODUsMzIsNzIsMTA4LDMyLDcxLDEwNiw2NSw4LDEwOCwxMDYs
MzIsNzksNTcsMywwLDMyLDg1LDY1LDEsMTA2LDMzLDg1LDEyLDAsMTEsMTEsMTEsNjUsMCwzMyw4
NSwyLDY0LDMsNjQsMzIsODUsMzIsNzEsNzgsMTMsMSwzMiw3MCw2NSwxLDc2LDQsNjQsMzIsNDQs
MzIsODUsNjUsOCwxMDgsMTA2LDQzLDMsMCwzMiw0NSwzMiw4NSw2NSw4LDEwOCwxMDYsNDMsMyww
LDMyLDQ2LDMyLDg1LDY1LDgsMTA4LDEwNiw0MywzLDAsMzIsNTMsNjUsMCw2NSw4LDEwOCwxMDYs
NDMsMywwLDMyLDU0LDY1LDAsNjUsOCwxMDgsMTA2LDQzLDMsMCwzMiw1NSw2NSwwLDY1LDgsMTA4
LDEwNiw0MywzLDAsMzIsMjksMzIsMzAsMzIsMzEsMzIsMzIsMzIsMzMsMzIsMzQsMzIsMzUsMzIs
NTcsMTYsMTYsMzIsNTcsNjUsMSw2NSw4LDEwOCwxMDYsNDMsMywwLDMzLDc3LDUsNjgsMCwwLDAs
MCwwLDAsMCwwLDMzLDc3LDY1LDAsMzMsODYsMiw2NCwzLDY0LDMyLDg2LDMyLDcwLDc4LDEzLDEs
MzIsNDQsMzIsODUsNjUsOCwxMDgsMTA2LDQzLDMsMCwzMiw0NSwzMiw4NSw2NSw4LDEwOCwxMDYs
NDMsMywwLDMyLDQ2LDMyLDg1LDY1LDgsMTA4LDEwNiw0MywzLDAsMzIsNTMsMzIsODYsNjUsOCwx
MDgsMTA2LDQzLDMsMCwzMiw1NCwzMiw4Niw2NSw4LDEwOCwxMDYsNDMsMywwLDMyLDU1LDMyLDg2
LDY1LDgsMTA4LDEwNiw0MywzLDAsMzIsMjksMzIsMzAsMzIsMzEsMzIsMzIsMzIsMzMsMzIsMzQs
MzIsMzUsMzIsNTcsMTYsMTYsMzIsNzcsMzIsNTcsNjUsMSw2NSw4LDEwOCwxMDYsNDMsMywwLDE2
MCwzMyw3NywzMiw0NCwzMiw4NSw2NSw4LDEwOCwxMDYsNDMsMywwLDMyLDUzLDMyLDg2LDY1LDgs
MTA4LDEwNiw0MywzLDAsMTYxLDMzLDg5LDMyLDQ1LDMyLDg1LDY1LDgsMTA4LDEwNiw0MywzLDAs
MzIsNTQsMzIsODYsNjUsOCwxMDgsMTA2LDQzLDMsMCwxNjEsMzMsOTAsMzIsNDYsMzIsODUsNjUs
OCwxMDgsMTA2LDQzLDMsMCwzMiw1NSwzMiw4Niw2NSw4LDEwOCwxMDYsNDMsMywwLDE2MSwzMyw5
MSwzMiw4OSwzMiw4OSwxNjIsMzIsOTAsMzIsOTAsMTYyLDE2MCwzMiw5MSwzMiw5MSwxNjIsMTYw
LDY4LDE0MSwyMzcsMTgxLDE2MCwyNDcsMTk4LDE3Niw2Miw5OSw0LDY0LDMyLDc3LDMyLDMwLDE2
MSwzMyw3NywxMSwzMiw4Niw2NSwxLDEwNiwzMyw4NiwxMiwwLDExLDExLDMyLDc3LDMyLDcwLDE4
MywxNjMsMzMsNzcsMTEsMzIsNDksMzIsODUsNjUsOCwxMDgsMTA2LDMyLDc3LDU3LDMsMCwzMiw1
MCwzMiw4NSw2NSw4LDEwOCwxMDYsMzIsNzcsNTcsMywwLDMyLDg1LDY1LDEsMTA2LDMzLDg1LDEy
LDAsMTEsMTEsMzIsNzIsMzIsNzEsNzQsNCw2NCwzMiw0OSwzMiw3MSw2NSw4LDEwOCwxMDYsMzIs
NzksNTcsMywwLDMyLDUwLDMyLDcxLDY1LDgsMTA4LDEwNiwzMiw3OSw1NywzLDAsMTEsMzIsNzEs
MzMsODgsMzIsMjgsNjUsMCw2NSw0LDEwOCwxMDYsNDAsMiwwLDY1LDEsNzAsNCw2NCwzMiw4OCw2
NSwxLDEwNiwzMyw4OCw2NSwwLDMzLDg3LDIsNjQsMyw2NCwzMiw4NywzMiw3MSw3OCwxMywxLDMy
LDUyLDMyLDg4LDMyLDcyLDEwOCwzMiw4NywxMDYsNjUsOCwxMDgsMTA2LDMyLDQ0LDMyLDg3LDY1
LDgsMTA4LDEwNiw0MywzLDAsMzIsODEsMTYyLDU3LDMsMCwzMiw1MiwzMiw4NywzMiw3MiwxMDgs
MzIsODgsMTA2LDY1LDgsMTA4LDEwNiwzMiw0NCwzMiw4Nyw2NSw4LDEwOCwxMDYsNDMsMywwLDMy
LDgxLDE2Miw1NywzLDAsMzIsODcsNjUsMSwxMDYsMzMsODcsMTIsMCwxMSwxMSwzMiw0OSwzMiw4
OCw2NSw4LDEwOCwxMDYsMzIsNDEsNjUsOSw2NSw4LDEwOCwxMDYsNDMsMywwLDU3LDMsMCwzMiw1
MCwzMiw4OCw2NSw4LDEwOCwxMDYsMzIsNDEsNjUsOSw2NSw4LDEwOCwxMDYsNDMsMywwLDU3LDMs
MCwxMSwzMiwyOCw2NSwxLDY1LDQsMTA4LDEwNiw0MCwyLDAsNjUsMSw3MCw0LDY0LDMyLDg4LDY1
LDEsMTA2LDMzLDg4LDY1LDAsMzMsODcsMiw2NCwzLDY0LDMyLDg3LDMyLDcxLDc4LDEzLDEsMzIs
NTIsMzIsODgsMzIsNzIsMTA4LDMyLDg3LDEwNiw2NSw4LDEwOCwxMDYsMzIsNDUsMzIsODcsNjUs
OCwxMDgsMTA2LDQzLDMsMCwzMiw4MSwxNjIsNTcsMywwLDMyLDUyLDMyLDg3LDMyLDcyLDEwOCwz
Miw4OCwxMDYsNjUsOCwxMDgsMTA2LDMyLDQ1LDMyLDg3LDY1LDgsMTA4LDEwNiw0MywzLDAsMzIs
ODEsMTYyLDU3LDMsMCwzMiw4Nyw2NSwxLDEwNiwzMyw4NywxMiwwLDExLDExLDMyLDQ5LDMyLDg4
LDY1LDgsMTA4LDEwNiwzMiw0MSw2NSwxMCw2NSw4LDEwOCwxMDYsNDMsMywwLDU3LDMsMCwzMiw1
MCwzMiw4OCw2NSw4LDEwOCwxMDYsMzIsNDEsNjUsMTAsNjUsOCwxMDgsMTA2LDQzLDMsMCw1Nywz
LDAsMTEsMzIsMjgsNjUsMiw2NSw0LDEwOCwxMDYsNDAsMiwwLDY1LDEsNzAsNCw2NCwzMiw4OCw2
NSwxLDEwNiwzMyw4OCw2NSwwLDMzLDg3LDIsNjQsMyw2NCwzMiw4NywzMiw3MSw3OCwxMywxLDMy
LDUyLDMyLDg4LDMyLDcyLDEwOCwzMiw4NywxMDYsNjUsOCwxMDgsMTA2LDMyLDQ2LDMyLDg3LDY1
LDgsMTA4LDEwNiw0MywzLDAsMzIsODEsMTYyLDU3LDMsMCwzMiw1MiwzMiw4NywzMiw3MiwxMDgs
MzIsODgsMTA2LDY1LDgsMTA4LDEwNiwzMiw0NiwzMiw4Nyw2NSw4LDEwOCwxMDYsNDMsMywwLDMy
LDgxLDE2Miw1NywzLDAsMzIsODcsNjUsMSwxMDYsMzMsODcsMTIsMCwxMSwxMSwzMiw0OSwzMiw4
OCw2NSw4LDEwOCwxMDYsMzIsNDEsNjUsMTEsNjUsOCwxMDgsMTA2LDQzLDMsMCw1NywzLDAsMzIs
NTAsMzIsODgsNjUsOCwxMDgsMTA2LDMyLDQxLDY1LDExLDY1LDgsMTA4LDEwNiw0MywzLDAsNTcs
MywwLDExLDMyLDI4LDY1LDMsNjUsNCwxMDgsMTA2LDQwLDIsMCw2NSwxLDcwLDQsNjQsMzIsODgs
NjUsMSwxMDYsMzMsODgsNjUsMCwzMyw4NywyLDY0LDMsNjQsMzIsODcsMzIsNzEsNzgsMTMsMSwz
Miw1MiwzMiw4OCwzMiw3MiwxMDgsMzIsODcsMTA2LDY1LDgsMTA4LDEwNiwzMiw0NCwzMiw4Nyw2
NSw4LDEwOCwxMDYsNDMsMywwLDMyLDQ0LDMyLDg3LDY1LDgsMTA4LDEwNiw0MywzLDAsMTYyLDMy
LDgxLDE2Miw1NywzLDAsMzIsNTIsMzIsODcsMzIsNzIsMTA4LDMyLDg4LDEwNiw2NSw4LDEwOCwx
MDYsMzIsNDQsMzIsODcsNjUsOCwxMDgsMTA2LDQzLDMsMCwzMiw0NCwzMiw4Nyw2NSw4LDEwOCwx
MDYsNDMsMywwLDE2MiwzMiw4MSwxNjIsNTcsMywwLDMyLDg3LDY1LDEsMTA2LDMzLDg3LDEyLDAs
MTEsMTEsMzIsNDksMzIsODgsNjUsOCwxMDgsMTA2LDMyLDQxLDY1LDEyLDY1LDgsMTA4LDEwNiw0
MywzLDAsNTcsMywwLDMyLDUwLDMyLDg4LDY1LDgsMTA4LDEwNiwzMiw0MSw2NSwxMiw2NSw4LDEw
OCwxMDYsNDMsMywwLDU3LDMsMCwxMSwzMiwyOCw2NSw0LDY1LDQsMTA4LDEwNiw0MCwyLDAsNjUs
MSw3MCw0LDY0LDMyLDg4LDY1LDEsMTA2LDMzLDg4LDY1LDAsMzMsODcsMiw2NCwzLDY0LDMyLDg3
LDMyLDcxLDc4LDEzLDEsMzIsNTIsMzIsODgsMzIsNzIsMTA4LDMyLDg3LDEwNiw2NSw4LDEwOCwx
MDYsMzIsNDUsMzIsODcsNjUsOCwxMDgsMTA2LDQzLDMsMCwzMiw0NSwzMiw4Nyw2NSw4LDEwOCwx
MDYsNDMsMywwLDE2MiwzMiw4MSwxNjIsNTcsMywwLDMyLDUyLDMyLDg3LDMyLDcyLDEwOCwzMiw4
OCwxMDYsNjUsOCwxMDgsMTA2LDMyLDQ1LDMyLDg3LDY1LDgsMTA4LDEwNiw0MywzLDAsMzIsNDUs
MzIsODcsNjUsOCwxMDgsMTA2LDQzLDMsMCwxNjIsMzIsODEsMTYyLDU3LDMsMCwzMiw4Nyw2NSwx
LDEwNiwzMyw4NywxMiwwLDExLDExLDMyLDQ5LDMyLDg4LDY1LDgsMTA4LDEwNiwzMiw0MSw2NSwx
Myw2NSw4LDEwOCwxMDYsNDMsMywwLDU3LDMsMCwzMiw1MCwzMiw4OCw2NSw4LDEwOCwxMDYsMzIs
NDEsNjUsMTMsNjUsOCwxMDgsMTA2LDQzLDMsMCw1NywzLDAsMTEsMzIsMjgsNjUsNSw2NSw0LDEw
OCwxMDYsNDAsMiwwLDY1LDEsNzAsNCw2NCwzMiw4OCw2NSwxLDEwNiwzMyw4OCw2NSwwLDMzLDg3
LDIsNjQsMyw2NCwzMiw4NywzMiw3MSw3OCwxMywxLDMyLDUyLDMyLDg4LDMyLDcyLDEwOCwzMiw4
NywxMDYsNjUsOCwxMDgsMTA2LDMyLDQ2LDMyLDg3LDY1LDgsMTA4LDEwNiw0MywzLDAsMzIsNDYs
MzIsODcsNjUsOCwxMDgsMTA2LDQzLDMsMCwxNjIsMzIsODEsMTYyLDU3LDMsMCwzMiw1MiwzMiw4
NywzMiw3MiwxMDgsMzIsODgsMTA2LDY1LDgsMTA4LDEwNiwzMiw0NiwzMiw4Nyw2NSw4LDEwOCwx
MDYsNDMsMywwLDMyLDQ2LDMyLDg3LDY1LDgsMTA4LDEwNiw0MywzLDAsMTYyLDMyLDgxLDE2Miw1
NywzLDAsMzIsODcsNjUsMSwxMDYsMzMsODcsMTIsMCwxMSwxMSwzMiw0OSwzMiw4OCw2NSw4LDEw
OCwxMDYsMzIsNDEsNjUsMTQsNjUsOCwxMDgsMTA2LDQzLDMsMCw1NywzLDAsMzIsNTAsMzIsODgs
NjUsOCwxMDgsMTA2LDMyLDQxLDY1LDE0LDY1LDgsMTA4LDEwNiw0MywzLDAsNTcsMywwLDExLDMy
LDI4LDY1LDYsNjUsNCwxMDgsMTA2LDQwLDIsMCw2NSwxLDcwLDQsNjQsMzIsODgsNjUsMSwxMDYs
MzMsODgsNjUsMCwzMyw4NywyLDY0LDMsNjQsMzIsODcsMzIsNzEsNzgsMTMsMSwzMiw1MiwzMiw4
OCwzMiw3MiwxMDgsMzIsODcsMTA2LDY1LDgsMTA4LDEwNiwzMiw0NCwzMiw4Nyw2NSw4LDEwOCwx
MDYsNDMsMywwLDMyLDQ1LDMyLDg3LDY1LDgsMTA4LDEwNiw0MywzLDAsMTYyLDMyLDgxLDE2Miw1
NywzLDAsMzIsNTIsMzIsODcsMzIsNzIsMTA4LDMyLDg4LDEwNiw2NSw4LDEwOCwxMDYsMzIsNDQs
MzIsODcsNjUsOCwxMDgsMTA2LDQzLDMsMCwzMiw0NSwzMiw4Nyw2NSw4LDEwOCwxMDYsNDMsMyww
LDE2MiwzMiw4MSwxNjIsNTcsMywwLDMyLDg3LDY1LDEsMTA2LDMzLDg3LDEyLDAsMTEsMTEsMzIs
NDksMzIsODgsNjUsOCwxMDgsMTA2LDMyLDQxLDY1LDE1LDY1LDgsMTA4LDEwNiw0MywzLDAsNTcs
MywwLDMyLDUwLDMyLDg4LDY1LDgsMTA4LDEwNiwzMiw0MSw2NSwxNSw2NSw4LDEwOCwxMDYsNDMs
MywwLDU3LDMsMCwxMSwzMiwyOCw2NSw3LDY1LDQsMTA4LDEwNiw0MCwyLDAsNjUsMSw3MCw0LDY0
LDMyLDg4LDY1LDEsMTA2LDMzLDg4LDY1LDAsMzMsODcsMiw2NCwzLDY0LDMyLDg3LDMyLDcxLDc4
LDEzLDEsMzIsNTIsMzIsODgsMzIsNzIsMTA4LDMyLDg3LDEwNiw2NSw4LDEwOCwxMDYsMzIsNDQs
MzIsODcsNjUsOCwxMDgsMTA2LDQzLDMsMCwzMiw0NiwzMiw4Nyw2NSw4LDEwOCwxMDYsNDMsMyww
LDE2MiwzMiw4MSwxNjIsNTcsMywwLDMyLDUyLDMyLDg3LDMyLDcyLDEwOCwzMiw4OCwxMDYsNjUs
OCwxMDgsMTA2LDMyLDQ0LDMyLDg3LDY1LDgsMTA4LDEwNiw0MywzLDAsMzIsNDYsMzIsODcsNjUs
OCwxMDgsMTA2LDQzLDMsMCwxNjIsMzIsODEsMTYyLDU3LDMsMCwzMiw4Nyw2NSwxLDEwNiwzMyw4
NywxMiwwLDExLDExLDMyLDQ5LDMyLDg4LDY1LDgsMTA4LDEwNiwzMiw0MSw2NSwxNiw2NSw4LDEw
OCwxMDYsNDMsMywwLDU3LDMsMCwzMiw1MCwzMiw4OCw2NSw4LDEwOCwxMDYsMzIsNDEsNjUsMTYs
NjUsOCwxMDgsMTA2LDQzLDMsMCw1NywzLDAsMTEsMzIsMjgsNjUsOCw2NSw0LDEwOCwxMDYsNDAs
MiwwLDY1LDEsNzAsNCw2NCwzMiw4OCw2NSwxLDEwNiwzMyw4OCw2NSwwLDMzLDg3LDIsNjQsMyw2
NCwzMiw4NywzMiw3MSw3OCwxMywxLDMyLDUyLDMyLDg4LDMyLDcyLDEwOCwzMiw4NywxMDYsNjUs
OCwxMDgsMTA2LDMyLDQ1LDMyLDg3LDY1LDgsMTA4LDEwNiw0MywzLDAsMzIsNDYsMzIsODcsNjUs
OCwxMDgsMTA2LDQzLDMsMCwxNjIsMzIsODEsMTYyLDU3LDMsMCwzMiw1MiwzMiw4NywzMiw3Miwx
MDgsMzIsODgsMTA2LDY1LDgsMTA4LDEwNiwzMiw0NSwzMiw4Nyw2NSw4LDEwOCwxMDYsNDMsMyww
LDMyLDQ2LDMyLDg3LDY1LDgsMTA4LDEwNiw0MywzLDAsMTYyLDMyLDgxLDE2Miw1NywzLDAsMzIs
ODcsNjUsMSwxMDYsMzMsODcsMTIsMCwxMSwxMSwzMiw0OSwzMiw4OCw2NSw4LDEwOCwxMDYsMzIs
NDEsNjUsMTcsNjUsOCwxMDgsMTA2LDQzLDMsMCw1NywzLDAsMzIsNTAsMzIsODgsNjUsOCwxMDgs
MTA2LDMyLDQxLDY1LDE3LDY1LDgsMTA4LDEwNiw0MywzLDAsNTcsMywwLDExLDMyLDI2LDY1LDMs
NzAsNCw2NCwzMiw4OCw2NSwxLDEwNiwzMyw4OCwzMiwxNywzMiwxMiwzMiw2NiwxMDYsNjUsOCwx
MDgsMTA2LDQzLDMsMCwzMywxMDksMzIsODAsMzIsMTA5LDE1Myw2OCw0NSw2NywyOCwyMzUsMjI2
LDU0LDI2LDYzLDE2NSwxNjMsMzMsMTA4LDY1LDAsMzMsODcsMiw2NCwzLDY0LDMyLDg3LDMyLDcx
LDc4LDEzLDEsMzIsNTIsMzIsODgsMzIsNzIsMTA4LDMyLDg3LDEwNiw2NSw4LDEwOCwxMDYsMzIs
NDgsMzIsODcsNjUsOCwxMDgsMTA2LDQzLDMsMCwzMiwxMDgsMTYyLDU3LDMsMCwzMiw1MiwzMiw4
NywzMiw3MiwxMDgsMzIsODgsMTA2LDY1LDgsMTA4LDEwNiwzMiw0OCwzMiw4Nyw2NSw4LDEwOCwx
MDYsNDMsMywwLDMyLDEwOCwxNjIsNTcsMywwLDMyLDg3LDY1LDEsMTA2LDMzLDg3LDEyLDAsMTEs
MTEsMzIsNDksMzIsODgsNjUsOCwxMDgsMTA2LDMyLDEwOSwzMiwxMDgsMTYyLDU3LDMsMCwzMiw1
MCwzMiw4OCw2NSw4LDEwOCwxMDYsMzIsMTA5LDMyLDEwOCwxNjIsNTcsMywwLDExLDMyLDcyLDMy
LDUyLDMyLDQ5LDMyLDUxLDMyLDU3LDE2LDIxLDMyLDU3LDY1LDAsNjUsOCwxMDgsMTA2LDQzLDMs
MCwzMywxMDcsMzIsMTA3LDY4LDAsMCwwLDAsMCwwLDAsMCw5OCw0LDY0LDMyLDQyLDMyLDY2LDY1
LDgsMTA4LDEwNiw2OCwwLDAsMCwwLDAsNTYsMTQzLDY0LDE1NCw1NywzLDAsMzIsNDMsMzIsNjYs
NjUsOCwxMDgsMTA2LDY4LDAsMCwwLDAsMCw1NiwxNDMsNjQsMTU0LDU3LDMsMCw1LDMyLDQyLDMy
LDY2LDY1LDgsMTA4LDEwNiw2OCwwLDAsMCwwLDAsMCwwLDAsNTcsMywwLDMyLDQzLDMyLDY2LDY1
LDgsMTA4LDEwNiwzMiw3NSw1NywzLDAsMzIsMjcsMzMsMTEwLDMyLDI2LDY1LDIsNzAsNCw2NCwz
MiwxMDksMzMsMTEwLDExLDY1LDAsMzMsODYsMiw2NCwzLDY0LDMyLDg2LDMyLDcyLDc4LDEzLDEs
MzIsNDMsMzIsNjYsNjUsOCwxMDgsMTA2LDMyLDQzLDMyLDY2LDY1LDgsMTA4LDEwNiw0MywzLDAs
MzIsNTEsMzIsODYsNjUsOCwxMDgsMTA2LDQzLDMsMCwzMiw1MCwzMiw4Niw2NSw4LDEwOCwxMDYs
NDMsMywwLDE2MiwxNjEsNTcsMywwLDMyLDg2LDMyLDcxLDcyLDQsNjQsMzIsMjYsNjUsMCw3MCw0
LDY0LDMyLDQyLDMyLDY2LDY1LDgsMTA4LDEwNiwzMiw0MiwzMiw2Niw2NSw4LDEwOCwxMDYsNDMs
MywwLDMyLDUxLDMyLDg2LDY1LDgsMTA4LDEwNiw0MywzLDAsMzIsNDcsMzIsODYsNjUsOCwxMDgs
MTA2LDQzLDMsMCwzMiwxMTAsMTYxLDE2MiwxNjAsNTcsMywwLDUsMzIsMjYsNjUsMiw3MCw0LDY0
LDMyLDQyLDMyLDY2LDY1LDgsMTA4LDEwNiwzMiw0MiwzMiw2Niw2NSw4LDEwOCwxMDYsNDMsMyww
LDMyLDUxLDMyLDg2LDY1LDgsMTA4LDEwNiw0MywzLDAsMzIsNDcsMzIsODYsNjUsOCwxMDgsMTA2
LDQzLDMsMCwzMiw0OCwzMiw4Niw2NSw4LDEwOCwxMDYsNDMsMywwLDE2MSwxNjIsMTYwLDU3LDMs
MCw1LDMyLDQyLDMyLDY2LDY1LDgsMTA4LDEwNiwzMiw0MiwzMiw2Niw2NSw4LDEwOCwxMDYsNDMs
MywwLDMyLDUxLDMyLDg2LDY1LDgsMTA4LDEwNiw0MywzLDAsMzIsNDcsMzIsODYsNjUsOCwxMDgs
MTA2LDQzLDMsMCwxNjIsMTYwLDU3LDMsMCwxMSwxMSwxMSwzMiw4Niw2NSwxLDEwNiwzMyw4Niwx
MiwwLDExLDExLDMyLDI2LDY1LDAsNzAsMzIsMjYsNjUsMiw3MCwxMTQsNCw2NCwzMiw0MiwzMiw2
Niw2NSw4LDEwOCwxMDYsMzIsNDIsMzIsNjYsNjUsOCwxMDgsMTA2LDQzLDMsMCwzMiwxMTAsMTYw
LDU3LDMsMCwxMSwxMSwxMSwzMiw2NSw2NSwxLDEwNiwzMyw2NSwxMiwwLDExLDExLDExLDE1Nyw1
LDMsNiwxMjcsNSwxMjQsNSwxMjcsNjUsMiwzMiwxNSwxMDgsNjUsMSwxMDYsMzMsNDEsNjUsMiwz
MiwxNiwxMDgsNjUsMSwxMDYsMzMsNDIsNjgsMCwwLDAsMCwwLDAsMCwwLDY4LDAsMCwwLDAsMCww
LDAsMCw2OCwwLDAsMCwwLDAsMCwwLDAsNjgsMCwwLDAsMCwwLDAsMCwwLDY4LDAsMCwwLDAsMCww
LDAsMCw2OCwwLDAsMCwwLDAsMCwwLDAsMzIsMCwzMiwxLDMyLDIsMzIsMywzMiw0LDMyLDUsMzIs
NywzMiwxOSwxNiwxNiwzMiwyNyw2NSwxLDY1LDgsMTA4LDEwNiwzMiwxOSw2NSwwLDY1LDgsMTA4
LDEwNiw0MywzLDAsNTcsMywwLDY1LDAsMzMsMzksNjUsMCwzMiwxNSwxMDcsMzMsMjgsMiw2NCwz
LDY0LDMyLDI4LDMyLDE1LDY1LDEsMTA2LDc4LDEzLDEsMzIsMjgsMTgzLDMyLDEyLDE2MiwzMywz
NCwzMiwxNSwzMiwyOCwxMDYsMzMsMzEsNjUsMCwzMiwxNiwxMDcsMzMsMjksMiw2NCwzLDY0LDMy
LDI5LDMyLDE2LDY1LDEsMTA2LDc4LDEzLDEsMzIsMjksMTgzLDMyLDEzLDE2MiwzMywzNSwzMiwx
NiwzMiwyOSwxMDYsMzMsMzIsNjUsMCwzMiwxNywxMDcsMzMsMzAsMiw2NCwzLDY0LDMyLDMwLDMy
LDE3LDY1LDEsMTA2LDc4LDEzLDEsMzIsMzAsMTgzLDMyLDE0LDE2MiwzMywzNiwzMiwxNywzMiwz
MCwxMDYsMzMsMzMsNjgsMCwwLDAsMCwwLDAsMCwwLDY4LDAsMCwwLDAsMCwwLDAsMCw2OCwwLDAs
MCwwLDAsMCwwLDAsMzIsMzQsMzIsMzUsMzIsMzYsMzIsMCwzMiwxLDMyLDIsMzIsMywzMiw0LDMy
LDUsMzIsNywzMiwxOSwxNiwxNiwzMiwxOSw2NSwxLDY1LDgsMTA4LDEwNiw0MywzLDAsMzMsMzgs
MzIsMTgsMzIsMzMsMzIsNDIsMTA4LDMyLDQxLDEwOCwzMiwzMiwzMiw0MSwxMDgsMTA2LDMyLDMx
LDEwNiw2NSw4LDEwOCwxMDYsMzIsMzgsNTcsMywwLDY4LDAsMCwwLDAsMCwwLDAsMCw2OCwwLDAs
MCwwLDAsMCwwLDAsNjgsMCwwLDAsMCwwLDAsMCwwLDMyLDM0LDMyLDM1LDMyLDM2LDMyLDYsMzIs
NywxNiwxMiwzMywzNywzMiwzNywzMiw4LDEwMSw0LDY0LDMyLDIwLDMyLDM5LDY1LDgsMTA4LDEw
Niw2OCwwLDAsMCwwLDAsMCwwLDAsMzIsMzgsNjgsMTg3LDE4OSwyMTUsMjE3LDIyMywxMjQsMjE5
LDYxLDMyLDM3LDE2MiwxNjEsMTYxLDU3LDMsMCwzMiwyMSwzMiwzOSw2NSw4LDEwOCwxMDYsMzIs
MzMsMzIsNDIsMTA4LDMyLDQxLDEwOCwzMiwzMiwzMiw0MSwxMDgsMTA2LDMyLDMxLDEwNiw2NSwx
LDEwNiwxODMsNTcsMywwLDMyLDM5LDY1LDEsMTA2LDMzLDM5LDExLDMyLDMwLDY1LDEsMTA2LDMz
LDMwLDEyLDAsMTEsMTEsMzIsMjksNjUsMSwxMDYsMzMsMjksMTIsMCwxMSwxMSwzMiwyOCw2NSwx
LDEwNiwzMywyOCwxMiwwLDExLDExLDMyLDM5LDY1LDEsNzQsNCw2NCw2NSwwLDMyLDM5LDMyLDIw
LDMyLDIxLDMyLDIxLDY1LDEsMzIsMjUsMzIsMjYsMTYsMTMsMTEsNjUsMCwzMyw0MywyLDY0LDMs
NjQsMzIsNDMsMzIsMzksNzgsMTMsMSwzMiwyMSwzMiw0Myw2NSw4LDEwOCwxMDYsNDMsMywwLDY4
LDAsMCwwLDAsMCwwLDIyNCw2MywxNjAsMTcwLDY1LDEsMTA3LDMzLDQwLDMyLDQwLDMyLDQyLDMy
LDQxLDEwOCwxMDksMzMsMzMsMzIsNDAsMzIsMzMsMzIsNDIsMTA4LDMyLDQxLDEwOCwxMDcsMzIs
NDEsMTA5LDMzLDMyLDMyLDQwLDMyLDMzLDMyLDQyLDEwOCwzMiw0MSwxMDgsMTA3LDMyLDMyLDMy
LDQxLDEwOCwxMDcsMzMsMzEsMzIsMjIsMzIsNDMsNjUsNCwxMDgsMTA2LDMyLDMxLDY1LDEsMTA2
LDU0LDIsMCwzMiwyMywzMiw0Myw2NSw0LDEwOCwxMDYsMzIsMzIsNjUsMSwxMDYsNTQsMiwwLDMy
LDI0LDMyLDQzLDY1LDQsMTA4LDEwNiwzMiwzMyw2NSwxLDEwNiw1NCwyLDAsMzIsNDMsNjUsMSwx
MDYsMzMsNDMsMTIsMCwxMSwxMSwzMiwyNyw2NSwwLDY1LDgsMTA4LDEwNiwzMiwzOSwxODMsNTcs
MywwLDExLDE1NSw1LDIsMTEsMTI3LDEsMTI0LDY4LDAsMCwwLDAsMCwxOTIsODgsNjQsMTU0LDMz
LDQwLDMyLDQsMzIsNSwxMDgsMzMsMzUsNjUsMCwzMywyOSwzMiwyMSw2NSwwLDc0LDQsNjQsNjUs
MCwzMywzMSwyLDY0LDMsNjQsMzIsMzEsNjUsOCw3OCwxMywxLDMyLDI3LDMyLDMxLDY1LDQsMTA4
LDEwNiw2NSwwLDU0LDIsMCwzMiwzMSw2NSwxLDEwNiwzMywzMSwxMiwwLDExLDExLDExLDY1LDEs
MzMsMzAsMiw2NCwzLDY0LDMyLDMwLDMyLDEzLDc4LDEzLDEsMzIsMjksMzIsMjAsNzgsNCw2NCwz
MiwxMywzMywzMCw1LDMyLDAsMzIsMTQsMzIsMzAsNjUsNCwxMDgsMTA2LDQwLDIsMCwzMiwxNywx
MDcsNjUsMSwxMDcsMTA2LDMzLDMxLDMyLDEsMzIsMTUsMzIsMzAsNjUsNCwxMDgsMTA2LDQwLDIs
MCwzMiwxOCwxMDcsNjUsMSwxMDcsMTA2LDMzLDMyLDMyLDIsMzIsMTYsMzIsMzAsNjUsNCwxMDgs
MTA2LDQwLDIsMCwzMiwxOSwxMDcsNjUsMSwxMDcsMTA2LDMzLDMzLDMyLDMxLDY1LDAsNzgsMzIs
MzIsNjUsMCw3OCwxMTMsMzIsMzMsNjUsMCw3OCwxMTMsMzIsMzEsMzIsNCw3MiwxMTMsMzIsMzIs
MzIsNSw3MiwxMTMsMzIsMzMsMzIsNiw3MiwxMTMsNCw2NCwzMiwzMSwzMiwzMiwzMiw0LDEwOCwx
MDYsMzIsMzMsMzIsMzUsMTA4LDEwNiwzMywzNCwzMiwzLDMyLDM0LDY1LDgsMTA4LDEwNiw0Mywz
LDAsMzIsNDAsMTAwLDQsNjQsMzIsMjEsNjUsMCw3NCw0LDY0LDMyLDAsMzIsMzEsMTA3LDMzLDM2
LDMyLDEsMzIsMzIsMTA3LDMzLDM3LDMyLDIsMzIsMzMsMTA3LDMzLDM4LDMyLDM4LDY1LDAsNzQs
NCw2NCw2NSwzLDMzLDM5LDMyLDM2LDY1LDAsNzYsMzIsMzcsNjUsMCw3NCwxMTMsNCw2NCw2NSww
LDMzLDM5LDExLDMyLDM2LDY1LDAsNzQsMzIsMzcsNjUsMCw3OCwxMTMsNCw2NCw2NSwxLDMzLDM5
LDExLDMyLDM2LDY1LDAsNzIsMzIsMzcsNjUsMCw3NiwxMTMsNCw2NCw2NSwyLDMzLDM5LDExLDUs
NjUsNywzMywzOSwzMiwzNiw2NSwwLDc2LDMyLDM3LDY1LDAsNzQsMTEzLDQsNjQsNjUsNCwzMywz
OSwxMSwzMiwzNiw2NSwwLDc0LDMyLDM3LDY1LDAsNzgsMTEzLDQsNjQsNjUsNSwzMywzOSwxMSwz
MiwzNiw2NSwwLDcyLDMyLDM3LDY1LDAsNzYsMTEzLDQsNjQsNjUsNiwzMywzOSwxMSwxMSwzMiwy
NywzMiwzOSw2NSw0LDEwOCwxMDYsNDAsMiwwLDMyLDIxLDcyLDQsNjQsMzIsMjcsMzIsMzksNjUs
NCwxMDgsMTA2LDMyLDI3LDMyLDM5LDY1LDQsMTA4LDEwNiw0MCwyLDAsNjUsMSwxMDYsNTQsMiww
LDMyLDIyLDMyLDI5LDY1LDQsMTA4LDEwNiwzMiwzMCw1NCwyLDAsMzIsMjMsMzIsMjksNjUsOCwx
MDgsMTA2LDMyLDcsMzIsMzEsMTgzLDMyLDEwLDE2MiwxNjAsNTcsMywwLDMyLDI0LDMyLDI5LDY1
LDgsMTA4LDEwNiwzMiw4LDMyLDMyLDE4MywzMiwxMSwxNjIsMTYwLDU3LDMsMCwzMiwyNSwzMiwy
OSw2NSw4LDEwOCwxMDYsMzIsOSwzMiwzMywxODMsMzIsMTIsMTYyLDE2MCw1NywzLDAsMzIsMjYs
MzIsMjksNjUsOCwxMDgsMTA2LDMyLDMsMzIsMzQsNjUsOCwxMDgsMTA2LDQzLDMsMCw1NywzLDAs
MzIsMjksNjUsMSwxMDYsMzMsMjksMTEsNSwzMiwyMiwzMiwyOSw2NSw0LDEwOCwxMDYsMzIsMzAs
NTQsMiwwLDMyLDIzLDMyLDI5LDY1LDgsMTA4LDEwNiwzMiw3LDMyLDMxLDE4MywzMiwxMCwxNjIs
MTYwLDU3LDMsMCwzMiwyNCwzMiwyOSw2NSw4LDEwOCwxMDYsMzIsOCwzMiwzMiwxODMsMzIsMTEs
MTYyLDE2MCw1NywzLDAsMzIsMjUsMzIsMjksNjUsOCwxMDgsMTA2LDMyLDksMzIsMzMsMTgzLDMy
LDEyLDE2MiwxNjAsNTcsMywwLDMyLDI2LDMyLDI5LDY1LDgsMTA4LDEwNiwzMiwzLDMyLDM0LDY1
LDgsMTA4LDEwNiw0MywzLDAsNTcsMywwLDMyLDI5LDY1LDEsMTA2LDMzLDI5LDExLDExLDExLDEx
LDMyLDMwLDY1LDEsMTA2LDMzLDMwLDEyLDAsMTEsMTEsMzIsMjgsNjUsMCw2NSw4LDEwOCwxMDYs
MzIsMjksMTgzLDU3LDMsMCwxMSwxOTcsMTgsNSwxMywxMjcsNywxMjQsOCwxMjcsNywxMjQsMSwx
MjcsNjUsMiwzMiwyMiwxMDgsNjUsMSwxMDYsMzMsNzMsNjUsMiwzMiwyMywxMDgsNjUsMSwxMDYs
MzMsNzQsNjUsMiwzMiwyNCwxMDgsNjUsMSwxMDYsMzMsNzUsMzIsMzcsMzIsMzgsMTA4LDMzLDc2
LDMyLDgsMzIsMTYsMTA2LDMzLDUwLDMyLDYsMzMsODUsMzIsODUsNjUsMCw3MCw0LDY0LDMyLDUw
LDMzLDUxLDExLDMyLDg1LDY1LDEsNzAsNCw2NCwzMiw1MCw2NSwxLDEwNiwzMyw1MSwxMSwzMiw4
NSw2NSwyLDcwLDQsNjQsMzIsNTAsMzMsNTEsMTEsMzIsODUsNjUsMyw3MCw0LDY0LDMyLDUwLDY1
LDIsMTA2LDMzLDUxLDExLDMyLDg1LDY1LDQsNzAsNCw2NCwzMiw1MCw2NSwxLDEwNiwzMyw1MSwx
MSwzMiw4NSw2NSwzLDc4LDQsNjQsMzIsMCwzMiwxLDMyLDM3LDEwOCwxMDYsMzIsMiwzMiw3Niwx
MDgsMTA2LDMzLDU0LDMyLDQwLDMyLDU0LDY1LDgsMTA4LDEwNiw0MywzLDAsNjgsMCwwLDAsMCww
LDAsMjQsNjQsMTU0LDEwMSwzMiw0MCwzMiw1NCw2NSw4LDEwOCwxMDYsNDMsMywwLDY4LDAsMCww
LDAsMCwwLDI0LDY0LDEwMiwxMTQsNCw2NCw2NSwwLDMzLDg1LDMyLDUwLDMzLDUxLDExLDExLDY1
LDAsMzMsNTUsNjUsMCwzMyw1MywyLDY0LDMsNjQsMzIsNTMsMzIsNTAsNzgsMTMsMSwzMiw1Mywz
Miw4LDcyLDQsNjQsMzIsOSwzMiw1Myw2NSw4LDEwOCwxMDYsNDMsMywwLDY4LDAsMCwwLDAsMCww
LDIyNCw2MywxNjAsMTcwLDMzLDU2LDMyLDExLDMyLDU2LDY1LDgsMTA4LDEwNiw0MywzLDAsMzMs
NjMsMzIsMTIsMzIsNTYsNjUsOCwxMDgsMTA2LDQzLDMsMCwzMyw2NCwzMiwxMywzMiw1Niw2NSw4
LDEwOCwxMDYsNDMsMywwLDMzLDY1LDMyLDQ2LDMyLDUzLDY1LDgsMTA4LDEwNiwzMiwxNCwzMiw1
Niw2NSw4LDEwOCwxMDYsNDMsMywwLDU3LDMsMCwzMiw0NywzMiw1Myw2NSw4LDEwOCwxMDYsMzIs
MTUsMzIsNTYsNjUsOCwxMDgsMTA2LDQzLDMsMCw1NywzLDAsMzIsODUsNjUsMiw3MCw0LDY0LDMy
LDQ2LDMyLDUzLDY1LDgsMTA4LDEwNiwzMiw0NiwzMiw1Myw2NSw4LDEwOCwxMDYsNDMsMywwLDMy
LDQ3LDMyLDUzLDY1LDgsMTA4LDEwNiw0MywzLDAsMTYxLDU3LDMsMCwxMSw1LDMyLDUzLDMyLDgs
MTA3LDMzLDU2LDMyLDE4LDMyLDU2LDY1LDgsMTA4LDEwNiw0MywzLDAsMzMsNjMsMzIsMTksMzIs
NTYsNjUsOCwxMDgsMTA2LDQzLDMsMCwzMyw2NCwzMiwyMCwzMiw1Niw2NSw4LDEwOCwxMDYsNDMs
MywwLDMzLDY1LDMyLDQ2LDMyLDUzLDY1LDgsMTA4LDEwNiwzMiwyMSwzMiw1Niw2NSw4LDEwOCwx
MDYsNDMsMywwLDU3LDMsMCwzMiwxNywzMiw1Niw2NSw0LDEwOCwxMDYsNDAsMiwwLDMzLDU0LDMy
LDAsMzIsMjYsMzIsNTQsNjUsNCwxMDgsMTA2LDQwLDIsMCwzMiwyMiwxMDcsNjUsMSwxMDcsMTA2
LDMzLDU3LDMyLDEsMzIsMjcsMzIsNTQsNjUsNCwxMDgsMTA2LDQwLDIsMCwzMiwyMywxMDcsNjUs
MSwxMDcsMTA2LDMzLDU4LDMyLDIsMzIsMjgsMzIsNTQsNjUsNCwxMDgsMTA2LDQwLDIsMCwzMiwy
NCwxMDcsNjUsMSwxMDcsMTA2LDMzLDU5LDMyLDU3LDMyLDU4LDMyLDM3LDEwOCwxMDYsMzIsNTks
MzIsNzYsMTA4LDEwNiwzMyw1NiwzMiw0NywzMiw1Myw2NSw4LDEwOCwxMDYsMzIsNDAsMzIsNTYs
NjUsOCwxMDgsMTA2LDQzLDMsMCw1NywzLDAsMzIsODUsNjUsMiw3MCw0LDY0LDMyLDQ2LDMyLDUz
LDY1LDgsMTA4LDEwNiwzMiw0NiwzMiw1Myw2NSw4LDEwOCwxMDYsNDMsMywwLDMyLDQ3LDMyLDUz
LDY1LDgsMTA4LDEwNiw0MywzLDAsMTYxLDU3LDMsMCwxMSwxMSw2NSwwLDMzLDUyLDIsNjQsMyw2
NCwzMiw1MiwzMiw1Myw2NSwxLDEwNiw3OCwxMywxLDMyLDUyLDMyLDgsNzIsNCw2NCwzMiw5LDMy
LDUyLDY1LDgsMTA4LDEwNiw0MywzLDAsNjgsMCwwLDAsMCwwLDAsMjI0LDYzLDE2MCwxNzAsMzMs
NTYsMzIsMTEsMzIsNTYsNjUsOCwxMDgsMTA2LDQzLDMsMCwzMyw2NiwzMiwxMiwzMiw1Niw2NSw4
LDEwOCwxMDYsNDMsMywwLDMzLDY3LDMyLDEzLDMyLDU2LDY1LDgsMTA4LDEwNiw0MywzLDAsMzMs
NjgsNSwzMiw1MiwzMiw4LDEwNywzMyw1NiwzMiwxOCwzMiw1Niw2NSw4LDEwOCwxMDYsNDMsMyww
LDMzLDY2LDMyLDE5LDMyLDU2LDY1LDgsMTA4LDEwNiw0MywzLDAsMzMsNjcsMzIsMjAsMzIsNTYs
NjUsOCwxMDgsMTA2LDQzLDMsMCwzMyw2OCwzMiwxNywzMiw1Niw2NSw0LDEwOCwxMDYsNDAsMiww
LDMzLDU0LDMyLDAsMzIsMjYsMzIsNTQsNjUsNCwxMDgsMTA2LDQwLDIsMCwzMiwyMiwxMDcsNjUs
MSwxMDcsMTA2LDMzLDYwLDMyLDEsMzIsMjcsMzIsNTQsNjUsNCwxMDgsMTA2LDQwLDIsMCwzMiwy
MywxMDcsNjUsMSwxMDcsMTA2LDMzLDYxLDMyLDIsMzIsMjgsMzIsNTQsNjUsNCwxMDgsMTA2LDQw
LDIsMCwzMiwyNCwxMDcsNjUsMSwxMDcsMTA2LDMzLDYyLDExLDMyLDUzLDMyLDgsNzIsMzIsNTIs
MzIsOCw3MiwxMTQsNCw2NCwzMiw2MywzMiw2NCwzMiw2NSwzMiw2NiwzMiw2NywzMiw2OCwzMiwy
OSwzMiwzMCwzMiwzMSwzMiwzMiwzMiwzMywzMiwzNCwzMiwzNSwzMiw0OCwxNiwxNiwzMiw0Miwz
Miw1NSw2NSw4LDEwOCwxMDYsMzIsNDgsNjUsMSw2NSw4LDEwOCwxMDYsNDMsMywwLDU3LDMsMCw1
LDMyLDIyLDMyLDU3LDMyLDYwLDEwNywxMDYsMzMsNzAsMzIsMjMsMzIsNTgsMzIsNjEsMTA3LDEw
NiwzMyw3MSwzMiwyNCwzMiw1OSwzMiw2MiwxMDcsMTA2LDMzLDcyLDMyLDcwLDY1LDAsNzIsMzIs
NzAsMzIsNzMsNzgsMTE0LDMyLDcxLDY1LDAsNzIsMTE0LDMyLDcxLDMyLDc0LDc4LDExNCwzMiw3
Miw2NSwwLDcyLDExNCwzMiw3MiwzMiw3NSw3OCwxMTQsNCw2NCwzMiw2MywzMiw2NCwzMiw2NSwz
Miw2NiwzMiw2NywzMiw2OCwzMiwyOSwzMiwzMCwzMiwzMSwzMiwzMiwzMiwzMywzMiwzNCwzMiwz
NSwzMiw0OCwxNiwxNiwzMiw0MiwzMiw1NSw2NSw4LDEwOCwxMDYsMzIsNDgsNjUsMSw2NSw4LDEw
OCwxMDYsNDMsMywwLDU3LDMsMCw1LDMyLDQyLDMyLDU1LDY1LDgsMTA4LDEwNiwzMiwyNSwzMiw3
MiwzMiw3NCwxMDgsMzIsNzMsMTA4LDMyLDcxLDMyLDczLDEwOCwxMDYsMzIsNzAsMTA2LDY1LDgs
MTA4LDEwNiw0MywzLDAsNTcsMywwLDExLDExLDMyLDU1LDY1LDEsMTA2LDMzLDU1LDMyLDUyLDY1
LDEsMTA2LDMzLDUyLDEyLDAsMTEsMTEsMzIsNTMsMzIsOCw3Miw0LDY0LDMyLDMsMzIsNCwzMiw1
LDMyLDYzLDMyLDY0LDMyLDY1LDMyLDI5LDMyLDMwLDMyLDMxLDMyLDMyLDMyLDMzLDMyLDM0LDMy
LDM1LDMyLDQ4LDE2LDE2LDMyLDQzLDMyLDUzLDY1LDgsMTA4LDEwNiwzMiw0OCw2NSwxLDY1LDgs
MTA4LDEwNiw0MywzLDAsNTcsMywwLDUsMzIsMjIsMzIsMCwzMiw1NywxMDcsMTA2LDMzLDcwLDMy
LDIzLDMyLDEsMzIsNTgsMTA3LDEwNiwzMyw3MSwzMiwyNCwzMiwyLDMyLDU5LDEwNywxMDYsMzMs
NzIsMzIsNzAsNjUsMCw3MiwzMiw3MCwzMiw3Myw3OCwxMTQsMzIsNzEsNjUsMCw3MiwxMTQsMzIs
NzEsMzIsNzQsNzgsMTE0LDMyLDcyLDY1LDAsNzIsMTE0LDMyLDcyLDMyLDc1LDc4LDExNCw0LDY0
LDMyLDMsMzIsNCwzMiw1LDMyLDYzLDMyLDY0LDMyLDY1LDMyLDI5LDMyLDMwLDMyLDMxLDMyLDMy
LDMyLDMzLDMyLDM0LDMyLDM1LDMyLDQ4LDE2LDE2LDMyLDQzLDMyLDUzLDY1LDgsMTA4LDEwNiwz
Miw0OCw2NSwxLDY1LDgsMTA4LDEwNiw0MywzLDAsNTcsMywwLDUsMzIsNDMsMzIsNTMsNjUsOCwx
MDgsMTA2LDMyLDI1LDMyLDcyLDMyLDc0LDEwOCwzMiw3MywxMDgsMzIsNzEsMzIsNzMsMTA4LDEw
NiwzMiw3MCwxMDYsNjUsOCwxMDgsMTA2LDQzLDMsMCw1NywzLDAsMTEsMTEsMzIsNDQsMzIsNTMs
NjUsOCwxMDgsMTA2LDMyLDQzLDMyLDUzLDY1LDgsMTA4LDEwNiw0MywzLDAsNTcsMywwLDMyLDUz
LDY1LDEsMTA2LDMzLDUzLDEyLDAsMTEsMTEsMzIsODUsNjUsMSw3MCwzMiw4NSw2NSwzLDcwLDEx
NCw0LDY0LDY1LDAsMzMsNTIsMiw2NCwzLDY0LDMyLDUyLDMyLDUwLDc4LDEzLDEsMzIsNTUsNjUs
MSwxMDYsMzMsNTUsMzIsNDIsMzIsNTUsNjUsOCwxMDgsMTA2LDY4LDAsMCwwLDAsMCwwLDI0MCw2
Myw1NywzLDAsMzIsNTIsNjUsMSwxMDYsMzMsNTIsMTIsMCwxMSwxMSwzMiw1NSw2NSwxLDEwNiwz
Myw1NSwzMiw0MiwzMiw1NSw2NSw4LDEwOCwxMDYsNjgsMCwwLDAsMCwwLDAsMCwwLDU3LDMsMCwz
Miw0MywzMiw1MCw2NSw4LDEwOCwxMDYsNjgsMCwwLDAsMCwwLDAsMjQwLDYzLDU3LDMsMCwzMiw0
NCwzMiw1MCw2NSw4LDEwOCwxMDYsNjgsMCwwLDAsMCwwLDAsMjQwLDYzLDU3LDMsMCwxMSwzMiw4
NSw2NSwzLDcwLDQsNjQsNjgsMCwwLDAsMCwxMjYsMTMyLDQ2LDY1LDMzLDgxLDY4LDAsMCwwLDAs
MTI2LDEzMiw0Niw2NSwxNTQsMzMsODIsNjUsMCwzMyw1MiwyLDY0LDMsNjQsMzIsNTIsMzIsNTAs
NzgsMTMsMSwzMiw1NSw2NSwxLDEwNiwzMyw1NSwzMiw0MiwzMiw1NSw2NSw4LDEwOCwxMDYsMzIs
NDcsMzIsNTIsNjUsOCwxMDgsMTA2LDQzLDMsMCw1NywzLDAsMzIsNDIsMzIsNTUsNjUsOCwxMDgs
MTA2LDQzLDMsMCwzMiw4MSw5OSw0LDY0LDMyLDQyLDMyLDU1LDY1LDgsMTA4LDEwNiw0MywzLDAs
MzMsODEsMTEsMzIsNDIsMzIsNTUsNjUsOCwxMDgsMTA2LDQzLDMsMCwzMiw4MiwxMDAsNCw2NCwz
Miw0MiwzMiw1NSw2NSw4LDEwOCwxMDYsNDMsMywwLDMzLDgyLDExLDMyLDUyLDY1LDEsMTA2LDMz
LDUyLDEyLDAsMTEsMTEsMzIsNTUsNjUsMSwxMDYsMzMsNTUsMzIsNDIsMzIsNTUsNjUsOCwxMDgs
MTA2LDY4LDAsMCwwLDAsMCwwLDAsMCw1NywzLDAsMzIsNTUsNjUsMSwxMDYsMzMsNTUsMzIsNDIs
MzIsNTUsNjUsOCwxMDgsMTA2LDY4LDAsMCwwLDAsMCwwLDAsMCw1NywzLDAsMzIsMCwzMiwxLDMy
LDM3LDEwOCwxMDYsMzIsMiwzMiw3NiwxMDgsMTA2LDMzLDU0LDMyLDQzLDMyLDUwLDY1LDEsMTA2
LDY1LDgsMTA4LDEwNiwzMiw0MCwzMiw1NCw2NSw4LDEwOCwxMDYsNDMsMywwLDU3LDMsMCwzMiw0
NCwzMiw1MCw2NSwxLDEwNiw2NSw4LDEwOCwxMDYsMzIsNDMsMzIsNTAsNjUsMSwxMDYsNjUsOCwx
MDgsMTA2LDQzLDMsMCw1NywzLDAsMzIsODIsMzIsODEsMTYxLDY4LDE4NywxODksMjE1LDIxNywy
MjMsMTI0LDIxOSw2MSw5OSw0LDY0LDMyLDUxLDY1LDEsMTA3LDMzLDUxLDExLDExLDMyLDg1LDY1
LDQsNzAsNCw2NCw2OCw4MCwyMzksMjI2LDIxNCwyMjgsMjYsNzUsNjgsMzMsODMsNjgsODAsMjM5
LDIyNiwyMTQsMjI4LDI2LDc1LDY4LDE1NCwzMyw4NCw2NSwwLDMzLDUyLDIsNjQsMyw2NCwzMiw1
MiwzMiw1MCw3OCwxMywxLDMyLDU1LDY1LDEsMTA2LDMzLDU1LDMyLDQyLDMyLDU1LDY1LDgsMTA4
LDEwNiwzMiw0MSwzMiw0MywzMiw1Miw2NSw4LDEwOCwxMDYsNDMsMywwLDE2Miw1NywzLDAsMzIs
NDIsMzIsNTUsNjUsOCwxMDgsMTA2LDQzLDMsMCwzMiw4Myw5OSw0LDY0LDMyLDQyLDMyLDU1LDY1
LDgsMTA4LDEwNiw0MywzLDAsMzMsODMsMTEsMzIsNDIsMzIsNTUsNjUsOCwxMDgsMTA2LDQzLDMs
MCwzMiw4NCwxMDAsNCw2NCwzMiw0MiwzMiw1NSw2NSw4LDEwOCwxMDYsNDMsMywwLDMzLDg0LDEx
LDMyLDUyLDY1LDEsMTA2LDMzLDUyLDEyLDAsMTEsMTEsMzIsNTUsNjUsMSwxMDYsMzMsNTUsMzIs
NDIsMzIsNTUsNjUsOCwxMDgsMTA2LDY4LDAsMCwwLDAsMCwwLDI0MCw2Myw1NywzLDAsMzIsNDMs
MzIsNTAsNjUsOCwxMDgsMTA2LDMyLDQxLDU3LDMsMCwzMiw0NCwzMiw1MCw2NSw4LDEwOCwxMDYs
MzIsNDEsNTcsMywwLDExLDMyLDUxLDY1LDEsNzAsMzIsODUsNjUsMyw3MSwxMTMsNCw2NCwzMiw0
NSw2NSwwLDY1LDgsMTA4LDEwNiwzMiw0Myw2NSwwLDY1LDgsMTA4LDEwNiw0MywzLDAsMzIsNDIs
NjUsMCw2NSw4LDEwOCwxMDYsNDMsMywwLDE2Myw1NywzLDAsNjUsMCwzMyw3Nyw1LDMyLDUxLDMy
LDQyLDMyLDQzLDMyLDQ1LDMyLDQ4LDE2LDIwLDMyLDQ4LDY1LDAsNjUsOCwxMDgsMTA2LDQzLDMs
MCwxNzAsMzMsNzcsMTEsMzIsNzcsNjUsMCw3MSw0LDY0LDMyLDQ5LDY1LDAsNjUsOCwxMDgsMTA2
LDMyLDcsNTcsMywwLDMyLDQ5LDY1LDEsNjUsOCwxMDgsMTA2LDY4LDAsMCwwLDAsMCwwLDI0MCw2
Myw1NywzLDAsMTUsMTEsNjgsMCwwLDAsMCwwLDAsMCwwLDMzLDc4LDMyLDM2LDMzLDc5LDY4LDAs
MCwwLDAsMCwwLDAsMCwzMyw4MCw2NSwwLDMzLDUyLDIsNjQsMyw2NCwzMiw1MiwzMiw1MCw3OCwx
MywxLDMyLDc4LDMyLDQ1LDMyLDUyLDY1LDgsMTA4LDEwNiw0MywzLDAsMzIsNDYsMzIsNTIsNjUs
OCwxMDgsMTA2LDQzLDMsMCwxNjIsMTYwLDMzLDc4LDMyLDc5LDMyLDQ1LDMyLDUyLDY1LDgsMTA4
LDEwNiw0MywzLDAsMzIsNDQsMzIsNTIsNjUsOCwxMDgsMTA2LDQzLDMsMCwxNjIsMTYxLDMzLDc5
LDMyLDgwLDMyLDQ1LDMyLDUyLDY1LDgsMTA4LDEwNiw0MywzLDAsMTYwLDMzLDgwLDMyLDUyLDY1
LDEsMTA2LDMzLDUyLDEyLDAsMTEsMTEsMzIsODUsNjUsMSw3MCw0LDY0LDMyLDc5LDMyLDQ1LDMy
LDUwLDY1LDgsMTA4LDEwNiw0MywzLDAsMTYxLDMzLDc5LDExLDMyLDg1LDY1LDIsNzAsNCw2NCwz
Miw3OCwzMiw3LDE2MCwzMyw3OCwxMSwzMiw4NSw2NSw0LDcwLDQsNjQsMzIsMCwzMiwxLDMyLDM3
LDEwOCwxMDYsMzIsMiwzMiw3NiwxMDgsMTA2LDMzLDU0LDMyLDc4LDMyLDQ1LDMyLDUwLDY1LDgs
MTA4LDEwNiw0MywzLDAsMzIsNDAsMzIsNTQsNjUsOCwxMDgsMTA2LDQzLDMsMCwxNjIsMTYwLDMz
LDc4LDMyLDc5LDMyLDQ1LDMyLDUwLDY1LDgsMTA4LDEwNiw0MywzLDAsMzIsNDQsMzIsNTAsNjUs
OCwxMDgsMTA2LDQzLDMsMCwxNjIsMTYxLDMzLDc5LDExLDMyLDc5LDY4LDAsMCwwLDAsMCwwLDAs
MCw5OSw0LDY0LDY4LDAsMCwwLDAsMCwwLDAsMCwzMyw3OSwxMSwzMiw3OSwxNTksMzMsNzksMzIs
NDksNjUsMCw2NSw4LDEwOCwxMDYsMzIsNzgsNTcsMywwLDMyLDQ5LDY1LDEsNjUsOCwxMDgsMTA2
LDMyLDc5LDU3LDMsMCwxMSwxMjksMTMsNyw4LDEyNyw3LDEyNCwzLDEyNyw1LDEyNCwzLDEyNyw2
LDEyNCwxLDEyNyw2OCwwLDAsMCwwLDAsMTkyLDg4LDY0LDE1NCwzMyw4NSw2OCwxODcsMTg5LDIx
NSwyMTcsMjIzLDEyNCwyMTksNjEsMzMsODYsNjgsNDUsNjcsMjgsMjM1LDIyNiw1NCwyNiw2Mywz
Myw4NywzMiwwLDMyLDEsMTA4LDMyLDIsMTA4LDMzLDczLDMyLDAsMzIsMSwxMDgsMzMsNzQsNjUs
MCwzMyw3NSwyLDY0LDMsNjQsMzIsNzUsMzIsNzMsNzgsMTMsMSwzMiw1MywzMiw3NSw2NSw4LDEw
OCwxMDYsMzIsNTIsMTYsNSw1NywzLDAsMzIsNTQsMzIsNzUsNjUsOCwxMDgsMTA2LDMyLDc1LDE4
Myw1NywzLDAsMzIsNzUsNjUsMSwxMDYsMzMsNzUsMTIsMCwxMSwxMSw2NSwwLDMyLDczLDMyLDUz
LDMyLDU0LDMyLDU0LDY1LDEsMzIsNzAsMzIsNzEsMTYsMTMsNjUsMCwzMyw3NSwyLDY0LDMsNjQs
MzIsNzUsMzIsNzMsNzgsMTMsMSwzMiw1MywzMiw3NSw2NSw4LDEwOCwxMDYsMzIsODUsNTcsMyww
LDMyLDc1LDY1LDEsMTA2LDMzLDc1LDEyLDAsMTEsMTEsNjUsMCwzMyw3NiwyLDY0LDMsNjQsMzIs
NzYsMzIsOSw3OCwxMywxLDMyLDAsMzIsMywzMiw2LDMyLDEwLDMyLDc2LDY1LDgsMTA4LDEwNiw0
MywzLDAsMzIsNjgsMTYsMTAsMzIsNjgsNjUsMCw2NSw0LDEwOCwxMDYsNDAsMiwwLDMzLDc3LDMy
LDEsMzIsNCwzMiw3LDMyLDExLDMyLDc2LDY1LDgsMTA4LDEwNiw0MywzLDAsMzIsNjgsMTYsMTAs
MzIsNjgsNjUsMCw2NSw0LDEwOCwxMDYsNDAsMiwwLDMzLDc4LDMyLDIsMzIsNSwzMiw4LDMyLDEy
LDMyLDc2LDY1LDgsMTA4LDEwNiw0MywzLDAsMzIsNjgsMTYsMTAsMzIsNjgsNjUsMCw2NSw0LDEw
OCwxMDYsNDAsMiwwLDMzLDc5LDMyLDc3LDMyLDc4LDMyLDAsMTA4LDEwNiwzMiw3OSwzMiw3NCwx
MDgsMTA2LDMzLDc1LDMyLDMsMzIsNzcsMTgzLDMyLDYsMTYyLDE2MCwzMyw4MSwzMiw0LDMyLDc4
LDE4MywzMiw3LDE2MiwxNjAsMzMsODIsMzIsNSwzMiw3OSwxODMsMzIsOCwxNjIsMTYwLDMzLDgz
LDMyLDgxLDMyLDEwLDMyLDc2LDY1LDgsMTA4LDEwNiw0MywzLDAsMTYxLDE1MywzMiw4MiwzMiwx
MSwzMiw3Niw2NSw4LDEwOCwxMDYsNDMsMywwLDE2MSwxNTMsMTYwLDMyLDgzLDMyLDEyLDMyLDc2
LDY1LDgsMTA4LDEwNiw0MywzLDAsMTYxLDE1MywxNjAsMzMsODQsMzIsODQsMzIsODcsMTAxLDQs
NjQsMzIsNTMsMzIsNzUsNjUsOCwxMDgsMTA2LDY4LDAsMCwwLDAsMCwwLDM2LDY0LDMyLDg1LDE2
Miw1NywzLDAsMTEsMzIsNzYsNjUsMSwxMDYsMzMsNzYsMTIsMCwxMSwxMSw2NSwwLDMzLDc2LDIs
NjQsMyw2NCwzMiw3NiwzMiw5LDc4LDEzLDEsMzIsMCwzMiwzLDMyLDYsMzIsMTAsMzIsNzYsNjUs
OCwxMDgsMTA2LDQzLDMsMCwzMiw2OCwxNiwxMCwzMiw2OCw2NSwwLDY1LDQsMTA4LDEwNiw0MCwy
LDAsMzMsNzcsMzIsMSwzMiw0LDMyLDcsMzIsMTEsMzIsNzYsNjUsOCwxMDgsMTA2LDQzLDMsMCwz
Miw2OCwxNiwxMCwzMiw2OCw2NSwwLDY1LDQsMTA4LDEwNiw0MCwyLDAsMzMsNzgsMzIsMiwzMiw1
LDMyLDgsMzIsMTIsMzIsNzYsNjUsOCwxMDgsMTA2LDQzLDMsMCwzMiw2OCwxNiwxMCwzMiw2OCw2
NSwwLDY1LDQsMTA4LDEwNiw0MCwyLDAsMzMsNzksMzIsNzcsMzIsNzgsMzIsMCwxMDgsMTA2LDMy
LDc5LDMyLDc0LDEwOCwxMDYsMzMsNzUsMzIsMywzMiw3NywxODMsMzIsNiwxNjIsMTYwLDMzLDgx
LDMyLDQsMzIsNzgsMTgzLDMyLDcsMTYyLDE2MCwzMyw4MiwzMiw1LDMyLDc5LDE4MywzMiw4LDE2
MiwxNjAsMzMsODMsMzIsODEsMzIsMTAsMzIsNzYsNjUsOCwxMDgsMTA2LDQzLDMsMCwxNjEsMTUz
LDMyLDgyLDMyLDExLDMyLDc2LDY1LDgsMTA4LDEwNiw0MywzLDAsMTYxLDE1MywxNjAsMzIsODMs
MzIsMTIsMzIsNzYsNjUsOCwxMDgsMTA2LDQzLDMsMCwxNjEsMTUzLDE2MCwzMyw4NCwzMiw4NCwz
Miw4NywxMDEsNCw2NCwzMiw1MywzMiw3NSw2NSw4LDEwOCwxMDYsMzIsMTMsMzIsNzYsNjUsOCwx
MDgsMTA2LDQzLDMsMCw1NywzLDAsMTEsMzIsNzYsNjUsMSwxMDYsMzMsNzYsMTIsMCwxMSwxMSwz
Miw0Miw2NSwwLDY1LDgsMTA4LDEwNiw0MywzLDAsMTcwLDMzLDk2LDMyLDQyLDY1LDEsNjUsOCwx
MDgsMTA2LDQzLDMsMCwxNzAsMzMsOTcsMzIsNDIsNjUsMiw2NSw4LDEwOCwxMDYsNDMsMywwLDE3
MCwzMyw5OCwzMiw0Miw2NSwzLDY1LDgsMTA4LDEwNiw0MywzLDAsMzMsOTksMzIsNDIsNjUsNCw2
NSw4LDEwOCwxMDYsNDMsMywwLDMzLDEwMCwzMiw0Miw2NSw1LDY1LDgsMTA4LDEwNiw0MywzLDAs
MzMsMTAxLDMyLDQyLDY1LDYsNjUsOCwxMDgsMTA2LDQzLDMsMCwzMywxMDIsMzIsNDIsNjUsNyw2
NSw4LDEwOCwxMDYsNDMsMywwLDMzLDEwMywzMiw0Miw2NSw4LDY1LDgsMTA4LDEwNiw0MywzLDAs
MzMsMTA0LDY1LDAsMzMsMTA1LDIsNjQsMyw2NCwzMiwxMDUsMzIsNzMsNzgsMTMsMSwzMiw1NCwz
MiwxMDUsNjUsOCwxMDgsMTA2LDQzLDMsMCw2OCwwLDAsMCwwLDAsMCwyMjQsNjMsMTYwLDE3MCwz
Myw4MCwzMiw1MywzMiw4MCw2NSw4LDEwOCwxMDYsNDMsMywwLDMyLDg1LDMyLDg2LDE2MCwxMDEs
MzIsNTMsMzIsODAsNjUsOCwxMDgsMTA2LDQzLDMsMCw2OCwwLDAsMCwwLDAsMCwwLDY0LDMyLDg1
LDE2MiwxMDIsMTEzLDQsNjQsMzIsODAsMzIsNzQsMTA5LDMzLDc5LDMyLDgwLDMyLDc5LDMyLDc0
LDEwOCwxMDcsMzIsMCwxMDksMzMsNzgsMzIsODAsMzIsNzksMzIsNzQsMTA4LDEwNywzMiw3OCwz
MiwwLDEwOCwxMDcsMzMsNzcsMzIsMywzMiw3NywxODMsMzIsNiwxNjIsMTYwLDMzLDgxLDMyLDQs
MzIsNzgsMTgzLDMyLDcsMTYyLDE2MCwzMyw4MiwzMiw1LDMyLDc5LDE4MywzMiw4LDE2MiwxNjAs
MzMsODMsMzIsODEsMzIsODIsMzIsODMsMzIsMzUsMzIsMzYsMzIsMzQsMzIsMzcsMzIsMzgsMzIs
MzksMzIsNDAsMzIsMjUsMzIsOSwzMiwxMCwzMiwxMSwzMiwxMiwzMiw3MiwzMiw1NSwzMiw0MSwz
Miw5NiwzMiw5OSwzMiwxMDIsMzIsOTcsMzIsMTAwLDMyLDEwMywzMiw5OCwzMiwxMDEsMzIsMTA0
LDMyLDY3LDMyLDY4LDMyLDY5LDMyLDcwLDMyLDcxLDE2LDE5LDMyLDY3LDY1LDAsNjUsOCwxMDgs
MTA2LDQzLDMsMCwxNzAsMzMsODgsMzIsODgsMzIsMTcsNzgsNCw2NCwzMiw4OCwzMiwxOCw3NCw0
LDY0LDMyLDE4LDMzLDg4LDExLDMyLDc3LDMyLDc4LDMyLDc5LDMyLDUzLDMyLDAsMzIsMSwzMiwy
LDMyLDMsMzIsNCwzMiw1LDMyLDYsMzIsNywzMiw4LDMyLDQ2LDMyLDQ4LDMyLDQ5LDMyLDUwLDMy
LDQzLDMyLDQ0LDMyLDQ1LDMyLDI2LDMyLDI1LDMyLDU2LDMyLDU3LDMyLDU4LDMyLDU5LDMyLDYw
LDMyLDY5LDMyLDY3LDE2LDI1LDMyLDY3LDY1LDAsNjUsOCwxMDgsMTA2LDQzLDMsMCwxNzAsMzMs
ODksMzIsMjcsNjUsMiw3MCw0LDY0LDMyLDE1LDMyLDgwLDY1LDgsMTA4LDEwNiw0MywzLDAsMzMs
OTEsNSw2OCwwLDAsMCwwLDAsMCwwLDAsMzMsOTEsMTEsMzIsODgsMzIsODksMTA2LDY1LDEsNzIs
NCw2NCwzMiw5MSwzMyw5Miw2OCwwLDAsMCwwLDAsMCwyNDAsNjMsMzMsOTMsNSwzMiwyNywzMyw5
MCwzMiwyNyw2NSwxLDcwLDMyLDg4LDMyLDg5LDEwNiw2NSw0LDcyLDExMyw0LDY0LDY1LDAsMzMs
OTAsMTEsMzIsNzcsMzIsNzgsMzIsNzksMzIsODEsMzIsODIsMzIsODMsMzIsOTAsMzIsOTEsMzIs
ODgsMzIsNTUsMzIsOSwzMiwxMCwzMiwxMSwzMiwxMiwzMiwxMywzMiwxNCwzMiw4OSwzMiw1Niwz
Miw1NywzMiw1OCwzMiw1OSwzMiw2MCwzMiw0MywzMiw0NCwzMiw0NSwzMiw0NywzMiw0OCwzMiw0
OSwzMiw1MCwzMiwyOCwzMiwyOSwzMiwzMCwzMiwzMSwzMiwzMiwzMiwzMywzMiwzNCwzMiw1MSwz
MiwwLDMyLDEsMzIsMiwzMiwxNSwzMiwxNiwzMiw2MSwzMiw2MiwzMiw2MywzMiw2NCwzMiw2NSwz
Miw2NiwzMiw2NywzMiw2NywxNiwyNiwzMiw2Nyw2NSwwLDY1LDgsMTA4LDEwNiw0MywzLDAsMzMs
OTIsMzIsNjcsNjUsMSw2NSw4LDEwOCwxMDYsNDMsMywwLDMzLDkzLDExLDMyLDUyLDE2LDUsMzMs
OTQsMzIsOTQsMzIsNjUsMzIsNjgsMTYsNiwzMiw2NSw2NSwwLDY1LDgsMTA4LDEwNiw0MywzLDAs
MzMsOTUsMzIsNTMsMzIsODAsNjUsOCwxMDgsMTA2LDMyLDk1LDMyLDkzLDE2MiwzMiw5MiwxNjAs
NTcsMywwLDExLDExLDMyLDEwNSw2NSwxLDEwNiwzMywxMDUsMTIsMCwxMSwxMSw2NSwwLDMzLDc2
LDIsNjQsMyw2NCwzMiw3NiwzMiw5LDc4LDEzLDEsMzIsMCwzMiwzLDMyLDYsMzIsMTAsMzIsNzYs
NjUsOCwxMDgsMTA2LDQzLDMsMCwzMiw2OCwxNiwxMCwzMiw2OCw2NSwwLDY1LDQsMTA4LDEwNiw0
MCwyLDAsMzMsNzcsMzIsMSwzMiw0LDMyLDcsMzIsMTEsMzIsNzYsNjUsOCwxMDgsMTA2LDQzLDMs
MCwzMiw2OCwxNiwxMCwzMiw2OCw2NSwwLDY1LDQsMTA4LDEwNiw0MCwyLDAsMzMsNzgsMzIsMiwz
Miw1LDMyLDgsMzIsMTIsMzIsNzYsNjUsOCwxMDgsMTA2LDQzLDMsMCwzMiw2OCwxNiwxMCwzMiw2
OCw2NSwwLDY1LDQsMTA4LDEwNiw0MCwyLDAsMzMsNzksMzIsMywzMiw3NywxODMsMzIsNiwxNjIs
MTYwLDMzLDgxLDMyLDQsMzIsNzgsMTgzLDMyLDcsMTYyLDE2MCwzMyw4MiwzMiw1LDMyLDc5LDE4
MywzMiw4LDE2MiwxNjAsMzMsODMsMzIsNzcsMzIsNzgsMzIsMCwxMDgsMTA2LDMyLDc5LDMyLDc0
LDEwOCwxMDYsMzMsNzUsMzIsODEsMzIsMTAsMzIsNzYsNjUsOCwxMDgsMTA2LDQzLDMsMCwxNjEs
MTUzLDMyLDgyLDMyLDExLDMyLDc2LDY1LDgsMTA4LDEwNiw0MywzLDAsMTYxLDE1MywxNjAsMzIs
ODMsMzIsMTIsMzIsNzYsNjUsOCwxMDgsMTA2LDQzLDMsMCwxNjEsMTUzLDE2MCwzMyw4NCwzMiw4
NCwzMiw4NywxMDEsNCw2NCwzMiw1MywzMiw3NSw2NSw4LDEwOCwxMDYsMzIsMTMsMzIsNzYsNjUs
OCwxMDgsMTA2LDQzLDMsMCw1NywzLDAsMTEsMzIsNzYsNjUsMSwxMDYsMzMsNzYsMTIsMCwxMSwx
MSwxMV0pO1xuXG5jb25zdCBfbWF0aCA9IHtcbiAgc2luOiBNYXRoLnNpbiwgY29zOiBNYXRoLmNv
cywgbG46IE1hdGgubG9nLFxuICBleHA6IE1hdGguZXhwLCBwb3c6IE1hdGgucG93LCBhdGFuMjog
TWF0aC5hdGFuMixcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBpbnN0YW50aWF0ZShpbXBvcnRzID0g
e30pIHtcbiAgY29uc3QgaW1wb3J0T2JqID0geyBtYXRoOiBfbWF0aCwgaG9zdDoge30gfTtcbiAg
bGV0IG1lbSA9IG51bGw7XG4gIGZvciAoY29uc3QgW2ssIHZdIG9mIE9iamVjdC5lbnRyaWVzKGlt
cG9ydHMpKSB7XG4gICAgaWYgKGsgPT09ICdtZW1vcnknIHx8IGsgPT09ICdfX21lbW9yeScpIHtc
biAgICAgIG1lbSA9IHY7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdiA9PT0gJ2Z1bmN0aW9uJykg
e1xuICAgICAgaW1wb3J0T2JqLmhvc3Rba10gPSB2O1xuICAgIH0gZWxzZSBpZiAodiAmJiB0eXBl
b2YgdiA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGZvciAoY29uc3QgW2syLCBmbl0gb2YgT2JqZWN0
LmVudHJpZXModikpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykgaW1w
b3J0T2JqLmhvc3RbayArICcuJyArIGsyXSA9IGZuO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBp
ZiAoIW1lbSkgbWVtID0gbmV3IFdlYkFzc2VtYmx5Lk1lbW9yeSh7IGluaXRpYWw6IDEgfSk7XG4g
IGltcG9ydE9iai5lbnYgPSB7IG1lbW9yeTogbWVtIH07XG4gIGNvbnN0IG1vZCA9IG5ldyBXZWJB
c3NlbWJseS5Nb2R1bGUoX2J5dGVzKTtcbiAgY29uc3QgaW5zdCA9IG5ldyBXZWJBc3NlbWJseS5J
bnN0YW5jZShtb2QsIGltcG9ydE9iaik7XG4gIGNvbnN0IGV4cG9ydHMgPSB7fTtcbiAgZm9yIChj
b25zdCBba2V5LCB2YWxdIG9mIE9iamVjdC5lbnRyaWVzKGluc3QuZXhwb3J0cykpIHtcbiAgICBp
ZiAoIWtleS5pbmNsdWRlcygnLicpKSB7IGV4cG9ydHNba2V5XSA9IHZhbDsgY29udGludWU7IH1c
biAgICBjb25zdCBwYXJ0cyA9IGtleS5zcGxpdCgnLicpO1xuICAgIGxldCBvYmogPSBleHBvcnRz
O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAg
ICBpZiAoIW9ialtwYXJ0c1tpXV0gfHwgdHlwZW9mIG9ialtwYXJ0c1tpXV0gIT09ICdvYmplY3Qn
KSBvYmpbcGFydHNbaV1dID0ge307XG4gICAgICBvYmogPSBvYmpbcGFydHNbaV1dO1xuICAgIH1c
biAgICBvYmpbcGFydHNbcGFydHMubGVuZ3RoIC0gMV1dID0gdmFsO1xuICB9XG4gIHJldHVybiBl
eHBvcnRzO1xufVxuXG4vLyDilIDilIAgTWVtb3J5IGhlbHBlcnMg4pSA4pSAXG4vLyBCdW1wIGFs
bG9jYXRvciBhbmQgdHlwZWQgcmVhZC93cml0ZSBmb3IgV2FzbSBsaW5lYXIgbWVtb3J5LlxuLy8g
Q2FsbGVyIG1hbmFnZXMgb2Zmc2V0IHZpYSBzdGF0ZSA9IHsgb2ZmOiAwIH0uXG5cbmV4cG9ydCBm
dW5jdGlvbiBhbGxvYyhzdGF0ZSwgbmY2NCA9IDAsIG5pMzIgPSAwKSB7XG4gIGNvbnN0IG8gPSBz
dGF0ZS5vZmY7XG4gIHN0YXRlLm9mZiArPSBuZjY0ICogOCArIG5pMzIgKiA0O1xuICBzdGF0ZS5v
ZmYgPSAoc3RhdGUub2ZmICsgNykgJiB+NzsgIC8vIGFsaWduIHRvIDggYnl0ZXMgKGY2NCBib3Vu
ZGFyeSlcbiAgcmV0dXJuIG87XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB3cml0ZUY2NChtZW0sIG9m
ZiwgdmFscykge1xuICBjb25zdCBmID0gbmV3IEZsb2F0NjRBcnJheShtZW0uYnVmZmVyKTtcbiAg
Zm9yIChsZXQgaSA9IDA7IGkgPCB2YWxzLmxlbmd0aDsgaSsrKSBmW29mZiAvIDggKyBpXSA9IHZh
bHNbaV07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB3cml0ZUkzMihtZW0sIG9mZiwgdmFscykge1xu
ICBjb25zdCB2ID0gbmV3IEludDMyQXJyYXkobWVtLmJ1ZmZlcik7XG4gIGZvciAobGV0IGkgPSAw
OyBpIDwgdmFscy5sZW5ndGg7IGkrKykgdltvZmYgLyA0ICsgaV0gPSB2YWxzW2ldO1xufVxuXG4v
LyByZWFkKiByZXR1cm4gY29waWVzICguc2xpY2UpLCBzYWZlIGFjcm9zcyBtZW1vcnkuZ3Jvd1xu
ZXhwb3J0IGZ1bmN0aW9uIHJlYWRGNjQobWVtLCBvZmYsIG4pIHtcbiAgcmV0dXJuIG5ldyBGbG9h
dDY0QXJyYXkobWVtLmJ1ZmZlci5zbGljZShvZmYsIG9mZiArIG4gKiA4KSk7XG59XG5cbmV4cG9y
dCBmdW5jdGlvbiByZWFkSTMyKG1lbSwgb2ZmLCBuKSB7XG4gIHJldHVybiBuZXcgSW50MzJBcnJh
eShtZW0uYnVmZmVyLnNsaWNlKG9mZiwgb2ZmICsgbiAqIDQpKTtcbn1cblxuLy8gR3JvdyBtZW1v
cnkgaWYgYWxsb2NhdG9yIG9mZnNldCBleGNlZWRzIGN1cnJlbnQgc2l6ZSAoNjRLQiBwYWdlcylc
bmV4cG9ydCBmdW5jdGlvbiBncm93TWVtb3J5KG1lbSwgb2ZmKSB7XG4gIGNvbnN0IG5lZWRlZCA9
IE1hdGguY2VpbChvZmYgLyA2NTUzNik7XG4gIGNvbnN0IGN1cnJlbnQgPSBtZW0uYnVmZmVyLmJ5
dGVMZW5ndGggLyA2NTUzNjtcbiAgaWYgKGN1cnJlbnQgPCBuZWVkZWQpIG1lbS5ncm93KG5lZWRl
ZCAtIGN1cnJlbnQgKyAxKTtcbn1cblxuLy8gZ3NsaWIgaGlnaC1sZXZlbCBBUEkg4oCUIGFwcGVu
ZGVkIHRvIGJpbmFyeSBkaXN0IGJ5IGJ1aWxkLmpzLlxuLy8gUnVudGltZSBoZWxwZXJzIChhbGxv
Yywgd3JpdGVGNjQsIHdyaXRlSTMyLCByZWFkRjY0LCByZWFkSTMyLCBncm93TWVtb3J5KVxuLy8g
YW5kIGluc3RhbnRpYXRlKCkgYXJlIGluIG1vZHVsZSBzY29wZSBmcm9tIHRoZSBiaW5hcnkgZGlz
dC5cbi8vXG4vLyBDb25maWcgc2hhcGVzOlxuLy8gICBrYjJkKHsgZGF0YSwgZ3JpZCwgdmFyaW9n
cmFtLCBzZWFyY2gsIGRpc2NyZXRpemF0aW9uPywga3R5cGU/LCBza21lYW4/IH0pXG4vLyAgIGt0
M2QoeyBkYXRhLCBncmlkLCB2YXJpb2dyYW0sIHNlYXJjaCwgZGlzY3JldGl6YXRpb24/LCBrdHlw
ZT8sIHNrbWVhbj8gfSlcbi8vICAgc2dzaW0oeyBncmlkLCB2YXJpb2dyYW0sIHNlYXJjaCwgZGF0
YT8gfSkg4oaSIHsgcnVuKHNlZWQpLCBkaXNwb3NlKCkgfVxuLy9cbi8vIFNlZSBleHQvZ3NsaWIv
UkVBRE1FLm1kIGZvciByb3V0aW5lIGRvY3MsIENMQVVERS5tZCBmb3IgYXJjaGl0ZWN0dXJlLlxu
XG4vLyB2YXJpb2dyYW0gbW9kZWwgbmFtZXMg4oaSIEdTTElCIGludGVnZXIgY29kZXMgKGNvdmEz
IGNvbnZlbnRpb24pXG5jb25zdCBfVkFSSU9fVFlQRVMgPSB7XG4gIHNwaGVyaWNhbDogMSwgZXhw
b25lbnRpYWw6IDIsIGdhdXNzaWFuOiAzLCBwb3dlcjogNCwgaG9sZTogNSxcbiAgc3BoOiAxLCBl
eHA6IDIsIGdhdTogMywgcG93OiA0LFxuICAxOiAxLCAyOiAyLCAzOiAzLCA0OiA0LCA1OiA1LFxu
fTtcblxuLy8gRmlsbCBpbiBncmlkIGRlZmF1bHRzLiBHU0xJQiBjb252ZW50aW9uOiB4bW4gPSB4
c2l6LzIgKGNlbGwtY2VudGVyZWQpLlxuZnVuY3Rpb24gX3Jlc29sdmVHcmlkKGcsIGlzM2QpIHtc
biAgY29uc3QgbnggPSBnLm54LCBueSA9IGcubnksIG56ID0gaXMzZCA/IChnLm56IHx8IDEpIDog
MTtcbiAgY29uc3QgeHNpeiA9IGcueHNpeiB8fCAxLCB5c2l6ID0gZy55c2l6IHx8IDEsIHpzaXog
PSBpczNkID8gKGcuenNpeiB8fCAxKSA6IDE7XG4gIGNvbnN0IHhtbiA9IGcueG1uICE9IG51bGwg
PyBnLnhtbiA6IHhzaXogLyAyO1xuICBjb25zdCB5bW4gPSBnLnltbiAhPSBudWxsID8gZy55bW4g
OiB5c2l6IC8gMjtcbiAgY29uc3Qgem1uID0gaXMzZCA/IChnLnptbiAhPSBudWxsID8gZy56bW4g
OiB6c2l6IC8gMikgOiB6c2l6IC8gMjtcbiAgcmV0dXJuIHsgbngsIG55LCBueiwgeG1uLCB5bW4s
IHptbiwgeHNpeiwgeXNpeiwgenNpeiwgbnh5ejogbnggKiBueSAqIG56IH07XG59XG5cbmZ1bmN0
aW9uIF9wYXJzZVZhcmlvKHYpIHtcbiAgY29uc3QgYzAgPSB2Lm51Z2dldCB8fCAwO1xuICBjb25z
dCBzdHJ1Y3RzID0gdi5zdHJ1Y3R1cmVzIHx8IFtdO1xuICBjb25zdCBuc3QgPSBzdHJ1Y3RzLmxl
bmd0aDtcbiAgY29uc3QgaXRzID0gW10sIGNjcyA9IFtdLCByYW5nZXMgPSBbXTtcbiAgY29uc3Qg
YW5ncyA9IFtdLCBhbmcycyA9IFtdLCBhbmczcyA9IFtdO1xuICBjb25zdCByYW5nZU1pbm9ycyA9
IFtdLCByYW5nZVZlcnRzID0gW107XG4gIGZvciAoY29uc3QgcyBvZiBzdHJ1Y3RzKSB7XG4gICAg
Y29uc3QgaXQgPSBfVkFSSU9fVFlQRVNbcy50eXBlXTtcbiAgICBpZiAoaXQgPT0gbnVsbCkgdGhy
b3cgbmV3IEVycm9yKGB1bmtub3duIHZhcmlvZ3JhbSB0eXBlOiAke3MudHlwZX1gKTtcbiAgICBp
dHMucHVzaChpdCk7XG4gICAgY2NzLnB1c2gocy5jb250cmlidXRpb24pO1xuICAgIHJhbmdlcy5w
dXNoKHMucmFuZ2UpO1xuICAgIGFuZ3MucHVzaChzLmFuZ2xlIHx8IDApO1xuICAgIGFuZzJzLnB1
c2gocy5hbmdsZTIgfHwgMCk7XG4gICAgYW5nM3MucHVzaChzLmFuZ2xlMyB8fCAwKTtcbiAgICBy
YW5nZU1pbm9ycy5wdXNoKHMucmFuZ2VNaW5vciAhPSBudWxsID8gcy5yYW5nZU1pbm9yIDogcy5y
YW5nZSk7XG4gICAgcmFuZ2VWZXJ0cy5wdXNoKHMucmFuZ2VWZXJ0ICE9IG51bGwgPyBzLnJhbmdl
VmVydCA6IHMucmFuZ2UpO1xuICB9XG4gIHJldHVybiB7IG5zdCwgYzAsIGl0cywgY2NzLCByYW5n
ZXMsIGFuZ3MsIGFuZzJzLCBhbmczcywgcmFuZ2VNaW5vcnMsIHJhbmdlVmVydHMgfTtcbn1cblxu
Ly8gMkQgb3JkaW5hcnkvc2ltcGxlIGtyaWdpbmcuIFJldHVybnMgeyBlc3QsIHZhciB9IGFzIEZs
b2F0NjRBcnJheXMuXG5leHBvcnQgZnVuY3Rpb24ga2IyZChvcHRzKSB7XG4gIGNvbnN0IGRhdGEg
PSBvcHRzLmRhdGE7XG4gIGNvbnN0IG5kID0gZGF0YS5sZW5ndGg7XG4gIGNvbnN0IGcgPSBfcmVz
b2x2ZUdyaWQob3B0cy5ncmlkLCBmYWxzZSk7XG4gIGNvbnN0IHYgPSBfcGFyc2VWYXJpbyhvcHRz
LnZhcmlvZ3JhbSk7XG4gIGNvbnN0IHNlYXJjaCA9IG9wdHMuc2VhcmNoO1xuICBjb25zdCBORE1B
WCA9IHNlYXJjaC5uZG1heCB8fCBNYXRoLm1pbihuZCwgMjApO1xuICBjb25zdCBORE1JTiA9IHNl
YXJjaC5uZG1pbiB8fCAxO1xuICBjb25zdCBSQURJVVMgPSBzZWFyY2gucmFkaXVzO1xuICBjb25z
dCBkaXNjID0gb3B0cy5kaXNjcmV0aXphdGlvbiB8fCB7fTtcbiAgY29uc3QgTlhESVMgPSBkaXNj
Lm54IHx8IDEsIE5ZRElTID0gZGlzYy5ueSB8fCAxO1xuICBjb25zdCBrdHlwZSA9IG9wdHMua3R5
cGUgPT09IFwiU0tcIiA/IDAgOiAxO1xuICBjb25zdCBza21lYW4gPSBvcHRzLnNrbWVhbiB8fCAw
O1xuXG4gIGNvbnN0IG1lbSA9IG5ldyBXZWJBc3NlbWJseS5NZW1vcnkoeyBpbml0aWFsOiA0IH0p
O1xuICBjb25zdCBsaWIgPSBpbnN0YW50aWF0ZSh7IG1lbW9yeTogbWVtIH0pO1xuICBjb25zdCBz
dCA9IHsgb2ZmOiAwIH07XG5cbiAgLy8gZGF0YSBhcnJheXNcbiAgY29uc3QgcFggPSBhbGxvYyhz
dCwgbmQpLCBwWSA9IGFsbG9jKHN0LCBuZCksIHBWUiA9IGFsbG9jKHN0LCBuZCk7XG4gIC8vIHZh
cmlvZ3JhbVxuICBjb25zdCBwSVQgPSBhbGxvYyhzdCwgMCwgdi5uc3QgKyA0KSwgcENDID0gYWxs
b2Moc3QsIHYubnN0ICsgNCksIHBBQSA9IGFsbG9jKHN0LCB2Lm5zdCArIDQpO1xuICAvLyBvdXRw
dXRcbiAgY29uc3QgcEVTVCA9IGFsbG9jKHN0LCBnLm54eXopLCBwRVNUViA9IGFsbG9jKHN0LCBn
Lm54eXopO1xuICAvLyByb3RhdGlvbiAoOSBmNjQgcGVyIHN0cnVjdHVyZSlcbiAgY29uc3QgcFJP
VCA9IGFsbG9jKHN0LCA5ICogdi5uc3QpO1xuICAvLyBzY3JhdGNoXG4gIGNvbnN0IHBYQSA9IGFs
bG9jKHN0LCBORE1BWCArIDEpLCBwWUEgPSBhbGxvYyhzdCwgTkRNQVggKyAxKTtcbiAgY29uc3Qg
cFZSQSA9IGFsbG9jKHN0LCBORE1BWCArIDEpLCBwRElTVCA9IGFsbG9jKHN0LCBORE1BWCArIDEp
LCBwTlVNUyA9IGFsbG9jKHN0LCBORE1BWCArIDEpO1xuICBjb25zdCBORVEgPSBORE1BWCArIDE7
XG4gIGNvbnN0IHBSID0gYWxsb2Moc3QsIE5FUSksIHBSUiA9IGFsbG9jKHN0LCBORVEpLCBwUyA9
IGFsbG9jKHN0LCBORVEpO1xuICBjb25zdCBwQSA9IGFsbG9jKHN0LCBORVEgKiAoTkVRICsgMSkg
LyAyKTtcbiAgY29uc3QgcFhEQiA9IGFsbG9jKHN0LCBOWERJUyAqIE5ZRElTKSwgcFlEQiA9IGFs
bG9jKHN0LCBOWERJUyAqIE5ZRElTKTtcbiAgY29uc3QgcENPVlJFUyA9IGFsbG9jKHN0LCAyKSwg
cEtTT0xSRVMgPSBhbGxvYyhzdCwgMSk7XG5cbiAgZ3Jvd01lbW9yeShtZW0sIHN0Lm9mZik7XG5c
biAgLy8gd3JpdGUgZGF0YVxuICB3cml0ZUY2NChtZW0sIHBYLCBkYXRhLm1hcChkID0+IGRbMF0p
KTtcbiAgd3JpdGVGNjQobWVtLCBwWSwgZGF0YS5tYXAoZCA9PiBkWzFdKSk7XG4gIHdyaXRlRjY0
KG1lbSwgcFZSLCBkYXRhLm1hcChkID0+IGRbMl0pKTtcblxuICAvLyB2YXJpb2dyYW0gcGFyYW1z
XG4gIHdyaXRlSTMyKG1lbSwgcElULCB2Lml0cyk7XG4gIHdyaXRlRjY0KG1lbSwgcENDLCB2LmNj
cyk7XG4gIHdyaXRlRjY0KG1lbSwgcEFBLCB2LnJhbmdlcyk7XG5cbiAgLy8gcm90YXRpb24gbWF0
cmljZXNcbiAgZm9yIChsZXQgaXMgPSAwOyBpcyA8IHYubnN0OyBpcysrKSB7XG4gICAgY29uc3Qg
YW5pcyA9IHYucmFuZ2VNaW5vcnNbaXNdIC8gdi5yYW5nZXNbaXNdO1xuICAgIGxpYi5nc2xpYi5z
ZXRyb3Qodi5hbmdzW2lzXSwgMCwgMCwgYW5pcywgMS4wLCBpcywgcFJPVCk7XG4gIH1cblxuICBs
aWIuZ3NsaWIua2IyZChcbiAgICBnLm54LCBnLm55LCBnLnhtbiwgZy55bW4sIGcueHNpeiwgZy55
c2l6LFxuICAgIE5YRElTLCBOWURJUyxcbiAgICBuZCwgcFgsIHBZLCBwVlIsXG4gICAgTkRNSU4s
IE5ETUFYLCBSQURJVVMsXG4gICAga3R5cGUsIHNrbWVhbixcbiAgICB2Lm5zdCwgdi5jMCxcbiAg
ICBwSVQsIHBDQywgcEFBLFxuICAgIDAsIHBST1QsXG4gICAgcEVTVCwgcEVTVFYsXG4gICAgcFhB
LCBwWUEsIHBWUkEsIHBESVNULCBwTlVNUyxcbiAgICBwUiwgcFJSLCBwUywgcEEsXG4gICAgcFhE
QiwgcFlEQiwgcENPVlJFUywgcEtTT0xSRVNcbiAgKTtcblxuICByZXR1cm4ge1xuICAgIGVzdDog
cmVhZEY2NChtZW0sIHBFU1QsIGcubnh5eiksXG4gICAgdmFyOiByZWFkRjY0KG1lbSwgcEVTVFYs
IGcubnh5eiksXG4gIH07XG59XG5cbi8vIDNEIGtyaWdpbmcgKFNLL09LLCBzdXBlciBibG9jayBz
ZWFyY2gpLiBSZXR1cm5zIHsgZXN0LCB2YXIgfSBhcyBGbG9hdDY0QXJyYXlzLlxuZXhwb3J0IGZ1
bmN0aW9uIGt0M2Qob3B0cykge1xuICBjb25zdCBkYXRhID0gb3B0cy5kYXRhO1xuICBjb25zdCBu
ZCA9IGRhdGEubGVuZ3RoO1xuICBjb25zdCBnID0gX3Jlc29sdmVHcmlkKG9wdHMuZ3JpZCwgdHJ1
ZSk7XG4gIGNvbnN0IHYgPSBfcGFyc2VWYXJpbyhvcHRzLnZhcmlvZ3JhbSk7XG4gIGNvbnN0IHNl
YXJjaCA9IG9wdHMuc2VhcmNoO1xuICBjb25zdCBORE1BWCA9IHNlYXJjaC5uZG1heCB8fCBNYXRo
Lm1pbihuZCwgMjApO1xuICBjb25zdCBORE1JTiA9IHNlYXJjaC5uZG1pbiB8fCAxO1xuICBjb25z
dCBSQURJVVMgPSBzZWFyY2gucmFkaXVzO1xuICBjb25zdCBzYW5nMSA9IHNlYXJjaC5hbmdsZSB8
fCAwLCBzYW5nMiA9IHNlYXJjaC5hbmdsZTIgfHwgMCwgc2FuZzMgPSBzZWFyY2guYW5nbGUzIHx8
IDA7XG4gIGNvbnN0IHNSYWRNaW4gPSBzZWFyY2gucmFkaXVzTWlub3IgIT0gbnVsbCA/IHNlYXJj
aC5yYWRpdXNNaW5vciA6IFJBRElVUztcbiAgY29uc3Qgc1JhZFZlcnQgPSBzZWFyY2gucmFkaXVz
VmVydCAhPSBudWxsID8gc2VhcmNoLnJhZGl1c1ZlcnQgOiBSQURJVVM7XG4gIGNvbnN0IHNhbmlz
MSA9IHNSYWRNaW4gLyBSQURJVVMsIHNhbmlzMiA9IHNSYWRWZXJ0IC8gUkFESVVTO1xuICBjb25z
dCBkaXNjID0gb3B0cy5kaXNjcmV0aXphdGlvbiB8fCB7fTtcbiAgY29uc3QgTlhESVMgPSBkaXNj
Lm54IHx8IDEsIE5ZRElTID0gZGlzYy5ueSB8fCAxLCBOWkRJUyA9IGRpc2MubnogfHwgMTtcbiAg
Y29uc3Qga3R5cGUgPSBvcHRzLmt0eXBlID09PSBcIlNLXCIgPyAwIDogMTtcbiAgY29uc3Qgc2tt
ZWFuID0gb3B0cy5za21lYW4gfHwgMDtcbiAgY29uc3QgTURUX01BWCA9IDEwO1xuICBjb25zdCBO
RVFfTUFYID0gTkRNQVggKyBNRFRfTUFYO1xuXG4gIGNvbnN0IG1lbSA9IG5ldyBXZWJBc3NlbWJs
eS5NZW1vcnkoeyBpbml0aWFsOiA2NCB9KTtcbiAgY29uc3QgbGliID0gaW5zdGFudGlhdGUoeyBt
ZW1vcnk6IG1lbSB9KTtcbiAgY29uc3Qgc3QgPSB7IG9mZjogNjU1MzYgfTtcblxuICAvLyBkYXRh
XG4gIGNvbnN0IHBYID0gYWxsb2Moc3QsIG5kICsgMjApLCBwWSA9IGFsbG9jKHN0LCBuZCArIDIw
KSwgcFogPSBhbGxvYyhzdCwgbmQgKyAyMCk7XG4gIGNvbnN0IHBWUiA9IGFsbG9jKHN0LCBuZCAr
IGcubnh5eiArIDIwKSwgcFZFID0gYWxsb2Moc3QsIG5kICsgZy5ueHl6ICsgMjApO1xuICAvLyB2
YXJpb2dyYW1cbiAgY29uc3QgcElUID0gYWxsb2Moc3QsIDAsIHYubnN0ICsgNCksIHBDQyA9IGFs
bG9jKHN0LCB2Lm5zdCArIDQpLCBwQUEgPSBhbGxvYyhzdCwgdi5uc3QgKyA0KTtcbiAgLy8gcm90
YXRpb246IG5zdCArIDEgKHNlYXJjaClcbiAgY29uc3QgcFJPVCA9IGFsbG9jKHN0LCA5ICogKHYu
bnN0ICsgMSkpO1xuICAvLyBkcmlmdFxuICBjb25zdCBwSURSSUYgPSBhbGxvYyhzdCwgMCwgOSk7
XG4gIC8vIHN1cGVyIGJsb2NrXG4gIGNvbnN0IG1heHNieCA9IGcubnggPiAxID8gTWF0aC5taW4o
TWF0aC5mbG9vcihnLm54IC8gMiksIDUwKSA6IDE7XG4gIGNvbnN0IG1heHNieSA9IGcubnkgPiAx
ID8gTWF0aC5taW4oTWF0aC5mbG9vcihnLm55IC8gMiksIDUwKSA6IDE7XG4gIGNvbnN0IG1heHNi
eiA9IGcubnogPiAxID8gTWF0aC5taW4oTWF0aC5mbG9vcihnLm56IC8gMiksIDUwKSA6IDE7XG4g
IGNvbnN0IE1BWFNCID0gbWF4c2J4ICogbWF4c2J5ICogbWF4c2J6O1xuICBjb25zdCBwTklTQiA9
IGFsbG9jKHN0LCAwLCBNQVhTQiArIDEwKSwgcFNVUE9VVCA9IGFsbG9jKHN0LCAyMCk7XG4gIGNv
bnN0IFNCVE9TUl9TSVpFID0gOCAqIE1BWFNCO1xuICBjb25zdCBwSVhTQiA9IGFsbG9jKHN0LCAw
LCBTQlRPU1JfU0laRSksIHBJWVNCID0gYWxsb2Moc3QsIDAsIFNCVE9TUl9TSVpFKSwgcElaU0Ig
PSBhbGxvYyhzdCwgMCwgU0JUT1NSX1NJWkUpO1xuICAvLyBvdXRwdXRcbiAgY29uc3QgcEVTVCA9
IGFsbG9jKHN0LCBnLm54eXopLCBwRVNUViA9IGFsbG9jKHN0LCBnLm54eXopO1xuICAvLyBzY3Jh
dGNoXG4gIGNvbnN0IHBYQSA9IGFsbG9jKHN0LCBORE1BWCksIHBZQSA9IGFsbG9jKHN0LCBORE1B
WCksIHBaQSA9IGFsbG9jKHN0LCBORE1BWCk7XG4gIGNvbnN0IHBWUkEgPSBhbGxvYyhzdCwgTkRN
QVgpLCBwVkVBID0gYWxsb2Moc3QsIE5ETUFYKTtcbiAgY29uc3QgcFIgPSBhbGxvYyhzdCwgTkVR
X01BWCksIHBSUiA9IGFsbG9jKHN0LCBORVFfTUFYKSwgcFMgPSBhbGxvYyhzdCwgTkVRX01BWCk7
XG4gIGNvbnN0IHBLQSA9IGFsbG9jKHN0LCBORVFfTUFYICogTkVRX01BWCk7XG4gIGNvbnN0IG5k
aXNjID0gTlhESVMgKiBOWURJUyAqIE5aRElTO1xuICBjb25zdCBwWERCID0gYWxsb2Moc3QsIE1h
dGgubWF4KG5kaXNjLCAyNykpLCBwWURCID0gYWxsb2Moc3QsIE1hdGgubWF4KG5kaXNjLCAyNykp
LCBwWkRCID0gYWxsb2Moc3QsIE1hdGgubWF4KG5kaXNjLCAyNykpO1xuICBjb25zdCBwQ0xPU0Ug
PSBhbGxvYyhzdCwgTkRNQVgpO1xuICBjb25zdCBwQ09WUkVTID0gYWxsb2Moc3QsIDIpO1xuICBj
b25zdCBwSU5PQ1QgPSBhbGxvYyhzdCwgMCwgOCk7XG4gIGNvbnN0IHBHRVRJRFggPSBhbGxvYyhz
dCwgMCwgMik7XG4gIGNvbnN0IHBUTVAgPSBhbGxvYyhzdCwgbmQgKyAyMCk7XG4gIGNvbnN0IHBJ
WEFSUiA9IGFsbG9jKHN0LCAwLCBuZCArIDIwKSwgcElEWDIgPSBhbGxvYyhzdCwgMCwgMik7XG4g
IGNvbnN0IHBMVCA9IGFsbG9jKHN0LCAwLCA2NCksIHBVVCA9IGFsbG9jKHN0LCAwLCA2NCk7XG4g
IGNvbnN0IHBOU0JCVUYgPSBhbGxvYyhzdCwgMCwgMSk7XG5cbiAgZ3Jvd01lbW9yeShtZW0sIHN0
Lm9mZik7XG5cbiAgLy8gd3JpdGUgZGF0YVxuICB3cml0ZUY2NChtZW0sIHBYLCBkYXRhLm1hcChk
ID0+IGRbMF0pKTtcbiAgd3JpdGVGNjQobWVtLCBwWSwgZGF0YS5tYXAoZCA9PiBkWzFdKSk7XG4g
IHdyaXRlRjY0KG1lbSwgcFosIGRhdGEubWFwKGQgPT4gZFsyXSkpO1xuICB3cml0ZUY2NChtZW0s
IHBWUiwgZGF0YS5tYXAoZCA9PiBkWzNdKSk7XG4gIHdyaXRlRjY0KG1lbSwgcFZFLCBuZXcgQXJy
YXkobmQpLmZpbGwoMS4wKSk7XG5cbiAgLy8gdmFyaW9ncmFtXG4gIHdyaXRlSTMyKG1lbSwgcElU
LCB2Lml0cyk7XG4gIHdyaXRlRjY0KG1lbSwgcENDLCB2LmNjcyk7XG4gIHdyaXRlRjY0KG1lbSwg
cEFBLCB2LnJhbmdlcyk7XG4gIHdyaXRlSTMyKG1lbSwgcElEUklGLCBbMCwgMCwgMCwgMCwgMCwg
MCwgMCwgMCwgMF0pO1xuXG4gIC8vIHJvdGF0aW9uIG1hdHJpY2VzIOKAlCBvbmUgcGVyIHZhcmlv
Z3JhbSBzdHJ1Y3R1cmVcbiAgZm9yIChsZXQgaXMgPSAwOyBpcyA8IHYubnN0OyBpcysrKSB7XG4g
ICAgY29uc3QgYW5pczEgPSB2LnJhbmdlTWlub3JzW2lzXSAvIHYucmFuZ2VzW2lzXTtcbiAgICBj
b25zdCBhbmlzMiA9IHYucmFuZ2VWZXJ0c1tpc10gLyB2LnJhbmdlc1tpc107XG4gICAgbGliLmdz
bGliLnNldHJvdCh2LmFuZ3NbaXNdLCB2LmFuZzJzW2lzXSwgdi5hbmczc1tpc10sIGFuaXMxLCBh
bmlzMiwgaXMsIHBST1QpO1xuICB9XG4gIC8vIHNlYXJjaCByb3RhdGlvbiBhdCBzbG90IG5zdFxu
ICBsaWIuZ3NsaWIuc2V0cm90KHNhbmcxLCBzYW5nMiwgc2FuZzMsIHNhbmlzMSwgc2FuaXMyLCB2
Lm5zdCwgcFJPVCk7XG5cbiAgLy8gc3VwZXIgYmxvY2sgc2VhcmNoXG4gIGxpYi5nc2xpYi5zZXRz
dXByKFxuICAgIGcubngsIGcueG1uLCBnLnhzaXosIGcubnksIGcueW1uLCBnLnlzaXosIGcubnos
IGcuem1uLCBnLnpzaXosXG4gICAgbmQsIHBYLCBwWSwgcFosIHBWUiwgcFRNUCxcbiAgICBwTklT
QiwgcElEWDIsIHBJWEFSUiwgcExULCBwVVQsXG4gICAgbWF4c2J4LCBtYXhzYnksIG1heHNieiwg
cFNVUE9VVFxuICApO1xuXG4gIC8vIFZFIG5lZWRzIHNhbWUgcmVvcmRlciBhcyBzZXRzdXByIGRp
ZCB0byBYLFksWixWUlxuICB3cml0ZUY2NChtZW0sIHBWRSwgbmV3IEFycmF5KG5kKS5maWxsKDEu
MCkpO1xuXG4gIGNvbnN0IHN1cG91dCA9IHJlYWRGNjQobWVtLCBwU1VQT1VULCA5KTtcbiAgbGli
LmdzbGliLnBpY2tzdXAoXG4gICAgc3Vwb3V0WzBdLCBzdXBvdXRbNl0sXG4gICAgc3Vwb3V0WzFd
LCBzdXBvdXRbN10sXG4gICAgc3Vwb3V0WzJdLCBzdXBvdXRbOF0sXG4gICAgdi5uc3QsIHBST1Qs
XG4gICAgUkFESVVTICogUkFESVVTLFxuICAgIHBOU0JCVUYsXG4gICAgcElYU0IsIHBJWVNCLCBw
SVpTQlxuICApO1xuICBjb25zdCBuc2J0b3NyID0gcmVhZEkzMihtZW0sIHBOU0JCVUYsIDEpWzBd
O1xuXG4gIC8vIGluaXQgb3V0cHV0IHRvIFVORVNUXG4gIGNvbnN0IHVuZXN0ID0gbmV3IEFycmF5
KGcubnh5eikuZmlsbCgtOTk5LjApO1xuICB3cml0ZUY2NChtZW0sIHBFU1QsIHVuZXN0KTtcbiAg
d3JpdGVGNjQobWVtLCBwRVNUViwgdW5lc3QpO1xuXG4gIGxpYi5nc2xpYi5rdDNkKFxuICAgIGcu
bngsIGcubnksIGcubnosIGcueG1uLCBnLnltbiwgZy56bW4sIGcueHNpeiwgZy55c2l6LCBnLnpz
aXosXG4gICAgTlhESVMsIE5ZRElTLCBOWkRJUyxcbiAgICBuZCwgcFgsIHBZLCBwWiwgcFZSLCBw
VkUsXG4gICAgTkRNSU4sIE5ETUFYLCBSQURJVVMsXG4gICAgc2FuZzEsIHNhbmcyLCBzYW5nMywg
c2FuaXMxLCBzYW5pczIsXG4gICAga3R5cGUsIHNrbWVhbixcbiAgICBwSURSSUYsXG4gICAgdi5u
c3QsIHYuYzAsIHBJVCwgcENDLCBwQUEsXG4gICAgMCwgcFJPVCxcbiAgICBuc2J0b3NyLCBwSVhT
QiwgcElZU0IsIHBJWlNCLCBwTklTQixcbiAgICBwU1VQT1VULFxuICAgIHBFU1QsIHBFU1RWLFxu
ICAgIHBYQSwgcFlBLCBwWkEsIHBWUkEsIHBWRUEsXG4gICAgcFIsIHBSUiwgcFMsIHBLQSxcbiAg
ICBwWERCLCBwWURCLCBwWkRCLFxuICAgIHBDTE9TRSwgcENPVlJFUyxcbiAgICBwSU5PQ1QsIHBH
RVRJRFgsXG4gICAgcExULCBwVVRcbiAgKTtcblxuICByZXR1cm4ge1xuICAgIGVzdDogcmVhZEY2
NChtZW0sIHBFU1QsIGcubnh5eiksXG4gICAgdmFyOiByZWFkRjY0KG1lbSwgcEVTVFYsIGcubnh5
eiksXG4gIH07XG59XG5cbi8vIFNlcXVlbnRpYWwgR2F1c3NpYW4gc2ltdWxhdGlvbi4gUmV0dXJu
cyB7IHJ1bihzZWVkKSDihpIgRmxvYXQ2NEFycmF5LCBkaXNwb3NlKCkgfS5cbi8vIFNldHVwIChz
dXBlciBibG9ja3MsIGNvdmFyaWFuY2UgdGFibGUpIHJ1bnMgb25jZTsgcnVuKCkgaXMgY2hlYXAg
cGVyIHJlYWxpemF0aW9uLlxuZXhwb3J0IGZ1bmN0aW9uIHNnc2ltKG9wdHMpIHtcbiAgY29uc3Qg
ZyA9IF9yZXNvbHZlR3JpZChvcHRzLmdyaWQsIHRydWUpO1xuICBjb25zdCB2ID0gX3BhcnNlVmFy
aW8ob3B0cy52YXJpb2dyYW0pO1xuICBjb25zdCBzZWFyY2ggPSBvcHRzLnNlYXJjaDtcbiAgY29u
c3QgTkRNQVggPSBzZWFyY2gubmRtYXggfHwgMTA7XG4gIGNvbnN0IE5ETUlOID0gc2VhcmNoLm5k
bWluIHx8IDA7XG4gIGNvbnN0IE5PRE1BWCA9IHNlYXJjaC5ub2RtYXggfHwgMTI7XG4gIGNvbnN0
IFJBRElVUyA9IHNlYXJjaC5yYWRpdXM7XG4gIGNvbnN0IHNhbmcxID0gc2VhcmNoLmFuZ2xlIHx8
IDAsIHNhbmcyID0gc2VhcmNoLmFuZ2xlMiB8fCAwLCBzYW5nMyA9IHNlYXJjaC5hbmdsZTMgfHwg
MDtcbiAgY29uc3Qgc1JhZE1pbiA9IHNlYXJjaC5yYWRpdXNNaW5vciAhPSBudWxsID8gc2VhcmNo
LnJhZGl1c01pbm9yIDogUkFESVVTO1xuICBjb25zdCBzUmFkVmVydCA9IHNlYXJjaC5yYWRpdXNW
ZXJ0ICE9IG51bGwgPyBzZWFyY2gucmFkaXVzVmVydCA6IFJBRElVUztcbiAgY29uc3Qgc2FuaXMx
ID0gc1JhZE1pbiAvIFJBRElVUywgc2FuaXMyID0gc1JhZFZlcnQgLyBSQURJVVM7XG5cbiAgLy8g
Y292YXJpYW5jZSB0YWJsZSBkaW1lbnNpb25zXG4gIGNvbnN0IE5DVFggPSBNYXRoLm1pbihNYXRo
Lm1heChNYXRoLmNlaWwoUkFESVVTIC8gKGcueHNpeiB8fCAxKSksIDEpLCBNYXRoLmZsb29yKChn
Lm54IC0gMSkgLyAyKSk7XG4gIGNvbnN0IE5DVFkgPSBNYXRoLm1pbihNYXRoLm1heChNYXRoLmNl
aWwoUkFESVVTIC8gKGcueXNpeiB8fCAxKSksIDEpLCBNYXRoLmZsb29yKChnLm55IC0gMSkgLyAy
KSk7XG4gIGNvbnN0IE5DVFogPSBnLm56IDw9IDEgPyAwIDogTWF0aC5taW4oTWF0aC5tYXgoTWF0
aC5jZWlsKFJBRElVUyAvIChnLnpzaXogfHwgMSkpLCAxKSwgTWF0aC5mbG9vcigoZy5ueiAtIDEp
IC8gMikpO1xuXG4gIGNvbnN0IGRhdGEgPSBvcHRzLmRhdGEgfHwgW107XG4gIGNvbnN0IG5kID0g
ZGF0YS5sZW5ndGg7XG5cbiAgY29uc3QgTkVRX01BWCA9IE5ETUFYICsgTk9ETUFYICsgMjtcbiAg
Y29uc3QgTUFYQ1RYID0gMiAqIE5DVFggKyAxO1xuICBjb25zdCBNQVhDVFkgPSAyICogTkNUWSAr
IDE7XG4gIGNvbnN0IE1BWENUWiA9IE5DVFogPT09IDAgPyAxIDogMiAqIE5DVFogKyAxO1xuICBj
b25zdCBDT1ZUQUJfU0laRSA9IE1BWENUWCAqIE1BWENUWSAqIE1BWENUWjtcbiAgY29uc3QgTUFY
X0xPT0tVID0gQ09WVEFCX1NJWkU7XG4gIGNvbnN0IE5TQl9NQVggPSBnLm54eXogKyAxMDtcbiAg
Y29uc3QgbmRBbGxvYyA9IE1hdGgubWF4KG5kLCAyMCk7XG5cbiAgbGV0IG1lbSA9IG5ldyBXZWJB
c3NlbWJseS5NZW1vcnkoeyBpbml0aWFsOiA2NCB9KTtcbiAgY29uc3QgbGliID0gaW5zdGFudGlh
dGUoeyBtZW1vcnk6IG1lbSB9KTtcbiAgY29uc3Qgc3QgPSB7IG9mZjogNjU1MzYgfTtcblxuICAv
LyBkYXRhIGFycmF5c1xuICBjb25zdCBwWCA9IGFsbG9jKHN0LCBuZEFsbG9jKSwgcFkgPSBhbGxv
YyhzdCwgbmRBbGxvYyksIHBaID0gYWxsb2Moc3QsIG5kQWxsb2MpO1xuICBjb25zdCBwVlIgPSBh
bGxvYyhzdCwgbmRBbGxvYyksIHBTRUMgPSBhbGxvYyhzdCwgbmRBbGxvYyksIHBMVk0gPSBhbGxv
YyhzdCwgZy5ueHl6KTtcbiAgLy8gdmFyaW9ncmFtXG4gIGNvbnN0IHBJVCA9IGFsbG9jKHN0LCAw
LCB2Lm5zdCArIDQpLCBwQ0MgPSBhbGxvYyhzdCwgdi5uc3QgKyA0KSwgcEFBID0gYWxsb2Moc3Qs
IHYubnN0ICsgNCk7XG4gIGNvbnN0IHBST1QgPSBhbGxvYyhzdCwgOSAqICh2Lm5zdCArIDEpKTtc
biAgLy8gc3VwZXIgYmxvY2tcbiAgY29uc3QgcE5JU0IgPSBhbGxvYyhzdCwgMCwgTlNCX01BWCks
IHBTVVBPVVQgPSBhbGxvYyhzdCwgMjApO1xuICBjb25zdCBwSVhTQiA9IGFsbG9jKHN0LCAwLCBO
U0JfTUFYKSwgcElZU0IgPSBhbGxvYyhzdCwgMCwgTlNCX01BWCksIHBJWlNCID0gYWxsb2Moc3Qs
IDAsIE5TQl9NQVgpO1xuICAvLyBjb3ZhcmlhbmNlIHRhYmxlXG4gIGNvbnN0IHBDT1ZUQUIgPSBh
bGxvYyhzdCwgQ09WVEFCX1NJWkUpO1xuICBjb25zdCBwSVhOT0RFID0gYWxsb2Moc3QsIDAsIE1B
WF9MT09LVSksIHBJWU5PREUgPSBhbGxvYyhzdCwgMCwgTUFYX0xPT0tVKSwgcElaTk9ERSA9IGFs
bG9jKHN0LCAwLCBNQVhfTE9PS1UpO1xuICAvLyBSTkdcbiAgY29uc3QgcElYViA9IGFsbG9jKHN0
LCAwLCAxMyk7XG4gIC8vIHNpbXVsYXRpb25cbiAgY29uc3QgcFNJTSA9IGFsbG9jKHN0LCBnLm54
eXopLCBwT1JERVIgPSBhbGxvYyhzdCwgZy5ueHl6KSwgcENMT1NFID0gYWxsb2Moc3QsIE5ETUFY
KTtcbiAgY29uc3QgcElDTk9ERSA9IGFsbG9jKHN0LCAwLCBOT0RNQVgpO1xuICBjb25zdCBwQ05P
REVYID0gYWxsb2Moc3QsIE5PRE1BWCksIHBDTk9ERVkgPSBhbGxvYyhzdCwgTk9ETUFYKSwgcENO
T0RFWiA9IGFsbG9jKHN0LCBOT0RNQVgpLCBwQ05PREVWID0gYWxsb2Moc3QsIE5PRE1BWCk7XG4g
IC8vIGtyaWdpbmcgc2NyYXRjaFxuICBjb25zdCBwQSA9IGFsbG9jKHN0LCBORVFfTUFYICogKE5F
UV9NQVggKyAxKSAvIDIpO1xuICBjb25zdCBwUiA9IGFsbG9jKHN0LCBORVFfTUFYKSwgcFJSID0g
YWxsb2Moc3QsIE5FUV9NQVgpLCBwUyA9IGFsbG9jKHN0LCBORVFfTUFYKTtcbiAgY29uc3QgcFZS
QSA9IGFsbG9jKHN0LCBORVFfTUFYKSwgcFZSRUEgPSBhbGxvYyhzdCwgTkVRX01BWCk7XG4gIGNv
bnN0IHBDT1ZSRVMgPSBhbGxvYyhzdCwgMiksIHBHRVRJRFggPSBhbGxvYyhzdCwgMCwgMiksIHBJ
Tk9DVCA9IGFsbG9jKHN0LCAwLCA4KTtcbiAgY29uc3QgcExUID0gYWxsb2Moc3QsIDAsIDY0KSwg
cFVUID0gYWxsb2Moc3QsIDAsIDY0KTtcbiAgY29uc3QgcFRNUCA9IGFsbG9jKHN0LCBNQVhfTE9P
S1UpO1xuICBjb25zdCBwQ1RfVE1QID0gYWxsb2Moc3QsIE1BWF9MT09LVSksIHBDVF9PUkRFUiA9
IGFsbG9jKHN0LCBNQVhfTE9PS1UpLCBwQ1RfUkVTVUxUID0gYWxsb2Moc3QsIDIpO1xuICBjb25z
dCBwU1VfSURYMiA9IGFsbG9jKHN0LCAwLCAyKSwgcFNVX0lYQVJSID0gYWxsb2Moc3QsIDAsIDIw
KSwgcE5TQkJVRiA9IGFsbG9jKHN0LCAwLCAxKTtcbiAgY29uc3QgcFRtcFggPSBhbGxvYyhzdCwg
bmRBbGxvYyksIHBUbXBZID0gYWxsb2Moc3QsIG5kQWxsb2MpLCBwVG1wWiA9IGFsbG9jKHN0LCBu
ZEFsbG9jKSwgcFRtcFZSID0gYWxsb2Moc3QsIG5kQWxsb2MpO1xuXG4gIGdyb3dNZW1vcnkobWVt
LCBzdC5vZmYpO1xuXG4gIC8vIHplcm8gTFZNXG4gIHdyaXRlRjY0KG1lbSwgcExWTSwgbmV3IEFy
cmF5KGcubnh5eikuZmlsbCgwLjApKTtcblxuICAvLyBjb25kaXRpb25pbmcgZGF0YVxuICBpZiAo
bmQgPiAwKSB7XG4gICAgd3JpdGVGNjQobWVtLCBwWCwgZGF0YS5tYXAoZCA9PiBkWzBdKSk7XG4g
ICAgd3JpdGVGNjQobWVtLCBwWSwgZGF0YS5tYXAoZCA9PiBkWzFdKSk7XG4gICAgd3JpdGVGNjQo
bWVtLCBwWiwgZGF0YS5tYXAoZCA9PiBkWzJdKSk7XG4gICAgd3JpdGVGNjQobWVtLCBwVlIsIGRh
dGEubWFwKGQgPT4gZFszXSkpO1xuICB9XG5cbiAgLy8gdmFyaW9ncmFtXG4gIHdyaXRlSTMyKG1l
bSwgcElULCB2Lml0cyk7XG4gIHdyaXRlRjY0KG1lbSwgcENDLCB2LmNjcyk7XG4gIHdyaXRlRjY0
KG1lbSwgcEFBLCB2LnJhbmdlcyk7XG5cbiAgLy8gcm90YXRpb24gbWF0cmljZXNcbiAgZm9yIChs
ZXQgaXMgPSAwOyBpcyA8IHYubnN0OyBpcysrKSB7XG4gICAgY29uc3QgYW5pczEgPSB2LnJhbmdl
TWlub3JzW2lzXSAvIHYucmFuZ2VzW2lzXTtcbiAgICBjb25zdCBhbmlzMiA9IHYucmFuZ2VWZXJ0
c1tpc10gLyB2LnJhbmdlc1tpc107XG4gICAgbGliLmdzbGliLnNldHJvdCh2LmFuZ3NbaXNdLCB2
LmFuZzJzW2lzXSwgdi5hbmczc1tpc10sIGFuaXMxLCBhbmlzMiwgaXMsIHBST1QpO1xuICB9XG4g
IC8vIHNlYXJjaCByb3RhdGlvblxuICBsaWIuZ3NsaWIuc2V0cm90KHNhbmcxLCBzYW5nMiwgc2Fu
ZzMsIHNhbmlzMSwgc2FuaXMyLCB2Lm5zdCwgcFJPVCk7XG5cbiAgLy8gc3VwZXIgYmxvY2sgc2Vh
cmNoXG4gIGxpYi5nc2xpYi5zZXRzdXByKFxuICAgIGcubngsIGcueG1uLCBnLnhzaXosIGcubnks
IGcueW1uLCBnLnlzaXosIGcubnosIGcuem1uLCBnLnpzaXosXG4gICAgbmQsIHBUbXBYLCBwVG1w
WSwgcFRtcFosIHBUbXBWUiwgcFRNUCxcbiAgICBwTklTQiwgcFNVX0lEWDIsIHBTVV9JWEFSUiwg
cExULCBwVVQsIGcubngsIGcubnksIGcubnosIHBTVVBPVVRcbiAgKTtcblxuICBjb25zdCBzdXBv
dXQgPSByZWFkRjY0KG1lbSwgcFNVUE9VVCwgOSk7XG4gIGxpYi5nc2xpYi5waWNrc3VwKFxuICAg
IHN1cG91dFswXSwgc3Vwb3V0WzZdLCBzdXBvdXRbMV0sIHN1cG91dFs3XSwgc3Vwb3V0WzJdLCBz
dXBvdXRbOF0sXG4gICAgMSwgcFJPVCwgUkFESVVTICogUkFESVVTLCBwTlNCQlVGLCBwSVhTQiwg
cElZU0IsIHBJWlNCXG4gICk7XG4gIGNvbnN0IG5zYnRvc3IgPSByZWFkSTMyKG1lbSwgcE5TQkJV
RiwgMSlbMF07XG5cbiAgLy8gY292YXJpYW5jZSB0YWJsZVxuICBsaWIuZ3NsaWIuY3RhYmxlKFxu
ICAgIHYubnN0LCB2LmMwLCBwSVQsIHBDQywgcEFBLCAwLCAxLCBwUk9ULCBSQURJVVMgKiBSQURJ
VVMsXG4gICAgZy5ueCwgZy5ueSwgZy5ueiwgZy54c2l6LCBnLnlzaXosIGcuenNpeiwgTkNUWCwg
TkNUWSwgTkNUWixcbiAgICBwQ09WVEFCLCBwQ09WUkVTLCBwQ1RfVE1QLCBwQ1RfT1JERVIsIHBJ
WE5PREUsIHBJWU5PREUsIHBJWk5PREUsIHBMVCwgcFVULCBwQ1RfUkVTVUxUXG4gICk7XG5cbiAg
Y29uc3QgY3RyZXMgPSByZWFkRjY0KG1lbSwgcENUX1JFU1VMVCwgMik7XG4gIGNvbnN0IG5sb29r
dSA9IGN0cmVzWzBdLCBjYmIgPSBjdHJlc1sxXTtcblxuICByZXR1cm4ge1xuICAgIHJ1bihzZWVk
KSB7XG4gICAgICBjb25zdCBpMzIgPSBuZXcgSW50MzJBcnJheShtZW0uYnVmZmVyKTtcbiAgICAg
IGkzMltwSVhWIC8gNF0gPSBzZWVkICYgMHgzRkZGRkZGRjtcbiAgICAgIGZvciAobGV0IGsgPSAx
OyBrIDwgMTM7IGsrKykgaTMyW3BJWFYgLyA0ICsga10gPSAwO1xuXG4gICAgICBsaWIuZ3NsaWIu
c2dzaW0oXG4gICAgICAgIGcubngsIGcubnksIGcubnosIGcueG1uLCBnLnltbiwgZy56bW4sIGcu
eHNpeiwgZy55c2l6LCBnLnpzaXosXG4gICAgICAgIG5kLCBwWCwgcFksIHBaLCBwVlIsIHBTRUMs
IHBMVk0sIDAuMCxcbiAgICAgICAgTkRNSU4sIE5ETUFYLCBSQURJVVMsXG4gICAgICAgIHNhbmcx
LCBzYW5nMiwgc2FuZzMsIHNhbmlzMSwgc2FuaXMyLFxuICAgICAgICAwLCBOT0RNQVgsIDAsXG4g
ICAgICAgIHYubnN0LCB2LmMwLCBwSVQsIHBDQywgcEFBLFxuICAgICAgICAwLCBwUk9ULCBSQURJ
VVMgKiBSQURJVVMsIDEsXG4gICAgICAgIG5zYnRvc3IsIHBJWFNCLCBwSVlTQiwgcElaU0IsIHBO
SVNCLCBwU1VQT1VULFxuICAgICAgICBOQ1RYLCBOQ1RZLCBOQ1RaLCBubG9va3UsIHBDT1ZUQUIs
IHBJWE5PREUsIHBJWU5PREUsIHBJWk5PREUsIGNiYixcbiAgICAgICAgcElYViwgcFNJTSwgcE9S
REVSLCBwQ0xPU0UsIHBJQ05PREUsXG4gICAgICAgIHBDTk9ERVgsIHBDTk9ERVksIHBDTk9ERVos
IHBDTk9ERVYsXG4gICAgICAgIHBBLCBwUiwgcFJSLCBwUywgcFZSQSwgcFZSRUEsXG4gICAgICAg
IHBDT1ZSRVMsIHBHRVRJRFgsIHBJTk9DVCwgcExULCBwVVQsIHBUTVBcbiAgICAgICk7XG5cbiAg
ICAgIHJldHVybiBuZXcgRmxvYXQ2NEFycmF5KG1lbS5idWZmZXIuc2xpY2UocFNJTSwgcFNJTSAr
IGcubnh5eiAqIDgpKTtcbiAgICB9LFxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICBtZW0gPSBudWxs
O1xuICAgIH0sXG4gIH07XG59XG4iLCJjZWxsSWQiOm51bGx9fQ==
AUDITABLE-MODULES-->
<!-- notebook settings: JSON {theme, fontSize, width, ...} -->
<!--AUDITABLE-SETTINGS
{"theme":"dark","fontSize":13,"width":"860"}
AUDITABLE-SETTINGS-->

<script>
// -- state.js --

// ═══════════════════════════════════════════════════
// AUDITABLE — reactive notebook runtime
// Geoscientific Chaos Union, 2025
// ═══════════════════════════════════════════════════

const $ = s => document.querySelector(s);
const $$ = s => [...document.querySelectorAll(s)];

// ── STATE ──
const S = {
  cells: [],        // { id, type, code, el, defines, uses, output, error }
  scope: {},        // shared variable scope
  cellId: 0,        // unique cell ID counter
  editTimer: null,  // debounce timer for autorun
  autorun: true,    // reactive mode flag
  selectedId: null, // currently selected cell
  pendingD: false,  // for "dd" double-tap delete
  pendingDTimer: null,
  clipboard: null,  // copied cell data
  trash: [],        // undo stack for deleted cells
  findActive: false,
  findQuery: '',
  findCase: false,
  findRegex: false,
  findMatches: [],   // { cellId, index, length }
  findCurrent: -1,
  initialized: false, // set after loadFromEmbed/init completes
};

const JS_KEYWORDS = new Set([
  'const','let','var','function','return','if','else','for','while','do',
  'switch','case','break','continue','new','this','class','extends','import',
  'export','default','from','of','in','typeof','instanceof','void','delete',
  'throw','try','catch','finally','async','await','yield','true','false',
  'null','undefined','NaN','Infinity'
]);

const JS_BUILTINS = new Set([
  'Math','Array','Object','String','Number','Float64Array','Float32Array',
  'Int32Array','Uint8Array','Map','Set','Promise','console','JSON',
  'ui','std','load','install','print',
  'workshop','notebook','md','html','css'
]);


// -- stdlib.js --

// ── STDLIB ──
// Bundled standard library for notebook work.
// Module-level — no per-cell state needed.

// ── Provider Registry ──

const _providers = { file: null, download: null };

function registerProvider(name, fn) {
  if (name in _providers) _providers[name] = fn;
}

// ── Data ──

function csv(text, opts = {}) {
  const sep = opts.separator || ',';
  const typed = !!opts.typed;
  const lines = [];
  let i = 0;
  const len = text.length;

  while (i < len) {
    const row = [];
    while (i < len) {
      if (text[i] === '"') {
        // quoted field
        i++;
        let field = '';
        while (i < len) {
          if (text[i] === '"') {
            if (text[i + 1] === '"') { field += '"'; i += 2; }
            else { i++; break; }
          } else { field += text[i]; i++; }
        }
        row.push(field);
        if (text[i] === sep) i++;
        else if (text[i] === '\r') { i++; if (text[i] === '\n') i++; break; }
        else if (text[i] === '\n') { i++; break; }
        else if (i >= len) break;
      } else {
        // unquoted field
        let field = '';
        while (i < len && text[i] !== sep && text[i] !== '\n' && text[i] !== '\r') {
          field += text[i]; i++;
        }
        row.push(field);
        if (text[i] === sep) i++;
        else if (text[i] === '\r') { i++; if (text[i] === '\n') i++; break; }
        else if (text[i] === '\n') { i++; break; }
        else break;
      }
    }
    if (row.length > 0 && !(row.length === 1 && row[0] === '')) lines.push(row);
  }

  if (lines.length < 2) return [];
  const headers = lines[0];
  const result = [];
  for (let r = 1; r < lines.length; r++) {
    const obj = {};
    for (let c = 0; c < headers.length; c++) {
      let val = lines[r][c] !== undefined ? lines[r][c] : '';
      if (typed) {
        const num = Number(val);
        if (val !== '' && !isNaN(num)) val = num;
        else if (val === 'true') val = true;
        else if (val === 'false') val = false;
        else if (val === '') val = null;
      }
      obj[headers[c]] = val;
    }
    result.push(obj);
  }
  return result;
}

async function fetchJSON(url) {
  const resp = await fetch(url);
  if (!resp.ok) throw new Error(`fetchJSON: ${resp.status} ${resp.statusText}`);
  return resp.json();
}

// ── Math / Stats ──

function _acc(arr, fn) {
  return fn ? arr.map(fn) : arr;
}

function sum(arr, fn) {
  const vals = _acc(arr, fn);
  let s = 0;
  for (let i = 0; i < vals.length; i++) s += vals[i];
  return s;
}

function mean(arr, fn) {
  if (!arr.length) return NaN;
  return sum(arr, fn) / arr.length;
}

function median(arr, fn) {
  const vals = _acc(arr, fn).slice().sort((a, b) => a - b);
  const n = vals.length;
  if (n === 0) return NaN;
  if (n % 2 === 1) return vals[(n - 1) / 2];
  return (vals[n / 2 - 1] + vals[n / 2]) / 2;
}

function extent(arr, fn) {
  const vals = _acc(arr, fn);
  let lo = Infinity, hi = -Infinity;
  for (let i = 0; i < vals.length; i++) {
    if (vals[i] < lo) lo = vals[i];
    if (vals[i] > hi) hi = vals[i];
  }
  return [lo, hi];
}

function bin(arr, n = 10, fn) {
  const vals = _acc(arr, fn);
  const [lo, hi] = extent(vals);
  const range = hi - lo || 1;
  const step = range / n;
  const bins = [];
  for (let i = 0; i < n; i++) {
    bins.push({ x0: lo + i * step, x1: lo + (i + 1) * step, values: [] });
  }
  for (const v of vals) {
    let idx = Math.floor((v - lo) / step);
    if (idx >= n) idx = n - 1;
    if (idx < 0) idx = 0;
    bins[idx].values.push(v);
  }
  return bins;
}

function linspace(start, stop, n) {
  if (n < 2) return n === 1 ? [start] : [];
  const result = new Array(n);
  const step = (stop - start) / (n - 1);
  for (let i = 0; i < n; i++) result[i] = start + i * step;
  result[n - 1] = stop; // exact endpoint
  return result;
}

// ── Array ──

function unique(arr, fn) {
  if (!fn) return [...new Set(arr)];
  const seen = new Set();
  const result = [];
  for (const item of arr) {
    const key = fn(item);
    if (!seen.has(key)) { seen.add(key); result.push(item); }
  }
  return result;
}

function zip(...arrays) {
  const len = Math.min(...arrays.map(a => a.length));
  const result = new Array(len);
  for (let i = 0; i < len; i++) {
    result[i] = arrays.map(a => a[i]);
  }
  return result;
}

function cross(...arrays) {
  if (arrays.length === 0) return [[]];
  const [first, ...rest] = arrays;
  const sub = cross(...rest);
  const result = [];
  for (const item of first) {
    for (const tail of sub) {
      result.push([item, ...tail]);
    }
  }
  return result;
}

// ── DOM / IO ──

async function file(accept) {
  if (_providers.file) return _providers.file(accept);
  return new Promise((resolve, reject) => {
    const input = document.createElement('input');
    input.type = 'file';
    if (accept) input.accept = accept;
    input.onchange = async () => {
      const f = input.files[0];
      if (!f) { reject(new Error('no file selected')); return; }
      const text = await f.text();
      resolve({ name: f.name, text, size: f.size });
    };
    input.click();
  });
}

function download(data, filename, mimeType) {
  if (_providers.download) return _providers.download(data, filename, mimeType);
  const str = typeof data === 'string' ? data : JSON.stringify(data, null, 2);
  const mime = mimeType || (typeof data === 'string' ? 'text/plain' : 'application/json');
  const blob = new Blob([str], { type: mime });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename || 'download';
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  setTimeout(() => URL.revokeObjectURL(url), 1000);
}

function el(tag, attrs, ...children) {
  const elem = document.createElement(tag);
  if (attrs && typeof attrs === 'object' && !(attrs instanceof Node)) {
    for (const [k, v] of Object.entries(attrs)) {
      if (k === 'style' && typeof v === 'object') {
        Object.assign(elem.style, v);
      } else if (k.startsWith('on') && typeof v === 'function') {
        elem.addEventListener(k.slice(2), v);
      } else {
        elem.setAttribute(k, v);
      }
    }
  } else if (attrs != null) {
    // attrs is actually a child
    children.unshift(attrs);
  }
  for (const child of children) {
    if (child instanceof Node) elem.appendChild(child);
    else if (child != null) elem.appendChild(document.createTextNode(String(child)));
  }
  return elem;
}

async function copy(text) {
  await navigator.clipboard.writeText(text);
}

function fmt(number, opts = {}) {
  const { decimals, prefix, suffix } = opts;
  let s = decimals != null ? number.toFixed(decimals)
    : new Intl.NumberFormat(undefined, { maximumFractionDigits: 6 }).format(number);
  if (prefix) s = prefix + s;
  if (suffix) s = s + suffix;
  return s;
}

// ── Source inclusion with dependency resolution ──

function include(libs, ...names) {
  // accept single library or array of libraries
  const list = Array.isArray(libs) && libs[0] && libs[0].sources ? libs : [libs];
  // merge all libraries into unified sources + deps
  const sources = {}, deps = {};
  for (const lib of list) {
    if (!lib || !lib.sources || !lib.deps)
      throw new Error('include: expected library with sources and deps');
    Object.assign(sources, lib.sources);
    Object.assign(deps, lib.deps);
  }
  const needed = new Set();
  function walk(name) {
    if (needed.has(name)) return;
    if (!sources[name]) throw new Error(`include: unknown routine '${name}'`);
    needed.add(name);
    for (const dep of deps[name] || []) walk(dep);
  }
  names.forEach(walk);
  // topological sort: deps before dependents
  const sorted = [];
  const visited = new Set();
  function visit(name) {
    if (visited.has(name)) return;
    visited.add(name);
    for (const dep of deps[name] || []) visit(dep);
    sorted.push(name);
  }
  needed.forEach(visit);
  return sorted.map(n => sources[n]).join('\n\n');
}

// ── Export ──

const std = {
  csv, fetchJSON,
  sum, mean, median, extent, bin, linspace,
  unique, zip, cross,
  file, download, el, copy, fmt,
  include,
};

// -- python.js --

// ── @python COMPAT HELPERS ──
// Python-familiar functions for users transitioning from Python.
// Each has a .help property showing the idiomatic JS equivalent.

function range(a, b, step) {
  let start, stop, s;
  if (b === undefined) { start = 0; stop = a; s = 1; }
  else { start = a; stop = b; s = step || 1; }
  const result = [];
  if (s > 0) { for (let i = start; i < stop; i += s) result.push(i); }
  else if (s < 0) { for (let i = start; i > stop; i += s) result.push(i); }
  return result;
}
range.help = 'JS: Array.from({length: n}, (_, i) => start + i * step)';

function enumerate(arr) {
  return arr.map((v, i) => [i, v]);
}
enumerate.help = 'JS: arr.map((v, i) => [i, v]) or arr.entries()';

function len(x) {
  if (x == null) throw new TypeError('len() of unsized object');
  if (x.size !== undefined) return x.size;
  return x.length;
}
len.help = 'JS: x.length or x.size';

function sorted(arr, key, reverse) {
  const copy = [...arr];
  if (key) copy.sort((a, b) => {
    const ka = key(a), kb = key(b);
    return ka < kb ? -1 : ka > kb ? 1 : 0;
  });
  else copy.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
  if (reverse) copy.reverse();
  return copy;
}
sorted.help = 'JS: arr.toSorted((a, b) => ...)';

function reversed(arr) {
  return [...arr].reverse();
}
reversed.help = 'JS: arr.toReversed()';

function isinstance(obj, cls) {
  return obj instanceof cls;
}
isinstance.help = 'JS: obj instanceof cls';

function type(x) {
  if (x === null) return 'null';
  if (Array.isArray(x)) return 'array';
  return typeof x;
}
type.help = 'JS: typeof x';

const python = {
  range, enumerate, len, sorted, reversed,
  isinstance, type,
};

function zenOfPython() {
  return [
    'The Zen of Python, by Tim Peters',
    '',
    'Beautiful is better than ugly.',
    'Explicit is better than implicit.',
    'Simple is better than complex.',
    'Complex is better than complicated.',
    'Flat is better than nested.',
    'Sparse is better than dense.',
    'Readability counts.',
    "Special cases aren't special enough to break the rules.",
    'Although practicality beats purity.',
    'Errors should never pass silently.',
    'Unless explicitly silenced.',
    'In the face of ambiguity, refuse the temptation to guess.',
    'There should be one-- and preferably only one --obvious way to do it.',
    "Although that way may not be obvious at first unless you're Dutch.",
    'Now is better than never.',
    'Although never is often better than *right* now.',
    "If the implementation is hard to explain, it's a bad idea.",
    'If the implementation is easy to explain, it may be a good idea.',
    "Namespaces are one honking great idea -- let's do more of those!",
  ].join('\n');
}

// -- syntax.js --

// ── SYNTAX HIGHLIGHTING ──

const CSS_NAMED_COLORS = new Set([
  'black','silver','gray','white','maroon','red','purple','fuchsia',
  'green','lime','olive','yellow','navy','blue','teal','aqua','orange'
]);

// detect curried tagged template: scan back through tokens for lang({...})`
function detectCurriedTag(tokens) {
  // last non-whitespace token must be )
  let j = tokens.length - 1;
  while (j >= 0 && tokens[j].type === '') j--;
  if (j < 0 || tokens[j].text !== ')') return null;
  // scan back to matching (
  let depth = 1;
  j--;
  while (j >= 0 && depth > 0) {
    if (tokens[j].text === ')') depth++;
    else if (tokens[j].text === '(') depth--;
    j--;
  }
  // token before ( should be the language name
  while (j >= 0 && tokens[j].type === '') j--;
  if (j < 0) return null;
  const name = tokens[j].text;
  if (window._taggedLanguages && window._taggedLanguages[name]) {
    return window._taggedLanguages[name];
  }
  return null;
}

// tokenize a tagged template literal starting at the opening backtick
function tokenizeTaggedTemplate(code, i, len, lang, tokens) {
  tokens.push({ type: 'punc', text: '`' });
  i++; // skip opening backtick
  let strBuf = '';
  while (i < len && code[i] !== '`') {
    if (code[i] === '\\') {
      strBuf += code[i] + (i + 1 < len ? code[i + 1] : '');
      i += 2;
      continue;
    }
    if (code[i] === '$' && i + 1 < len && code[i + 1] === '{') {
      if (strBuf) {
        tokens.push(...lang.tokenize(strBuf));
        strBuf = '';
      }
      tokens.push({ type: 'punc', text: '${' });
      i += 2;
      let depth = 1;
      let exprStart = i;
      while (i < len && depth > 0) {
        if (code[i] === '{') depth++;
        else if (code[i] === '}') { depth--; if (depth === 0) break; }
        else if (code[i] === '`') {
          i++;
          while (i < len && code[i] !== '`') {
            if (code[i] === '\\') i++;
            i++;
          }
        } else if (code[i] === '"' || code[i] === "'") {
          const q = code[i]; i++;
          while (i < len && code[i] !== q) {
            if (code[i] === '\\') i++;
            i++;
          }
        }
        i++;
      }
      const expr = code.slice(exprStart, i);
      if (expr) tokens.push(...tokenize(expr));
      if (i < len && code[i] === '}') {
        tokens.push({ type: 'punc', text: '}' });
        i++;
      }
      continue;
    }
    strBuf += code[i];
    i++;
  }
  if (strBuf) tokens.push(...lang.tokenize(strBuf));
  if (i < len && code[i] === '`') {
    tokens.push({ type: 'punc', text: '`' });
    i++;
  }
  return i;
}

function tokenize(code) {
  const tokens = [];
  let i = 0;
  const len = code.length;

  while (i < len) {
    // line comment
    if (code[i] === '/' && code[i+1] === '/') {
      const start = i;
      while (i < len && code[i] !== '\n') i++;
      tokens.push({ type: 'cmt', text: code.slice(start, i) });
      continue;
    }
    // block comment
    if (code[i] === '/' && code[i+1] === '*') {
      const start = i;
      i += 2;
      while (i < len && !(code[i-1] === '*' && code[i] === '/')) i++;
      if (i < len) i++;
      tokens.push({ type: 'cmt', text: code.slice(start, i) });
      continue;
    }
    // strings
    if (code[i] === '"' || code[i] === "'" || code[i] === '`') {
      // curried tagged template: lang({...})`...` — detect before treating as plain string
      if (code[i] === '`' && typeof window !== 'undefined' && window._taggedLanguages) {
        const lang = detectCurriedTag(tokens);
        if (lang) {
          i = tokenizeTaggedTemplate(code, i, len, lang, tokens);
          continue;
        }
      }
      const q = code[i];
      const start = i;
      i++;
      while (i < len && code[i] !== q) {
        if (code[i] === '\\') i++;
        i++;
      }
      if (i < len) i++;
      tokens.push({ type: 'str', text: code.slice(start, i) });
      continue;
    }
    // numbers
    if (/\d/.test(code[i]) || (code[i] === '.' && i+1 < len && /\d/.test(code[i+1]))) {
      const start = i;
      if (code[i] === '0' && (code[i+1] === 'x' || code[i+1] === 'X')) {
        i += 2;
        while (i < len && /[0-9a-fA-F_]/.test(code[i])) i++;
      } else {
        while (i < len && /[0-9._eE+-]/.test(code[i])) i++;
      }
      tokens.push({ type: 'num', text: code.slice(start, i) });
      continue;
    }
    // identifiers / keywords
    if (/[a-zA-Z_$]/.test(code[i])) {
      const start = i;
      while (i < len && /\w/.test(code[i])) i++;
      const word = code.slice(start, i);

      // tagged template literal — delegate to registered language tokenizer
      if (i < len && code[i] === '`' && typeof window !== 'undefined'
          && window._taggedLanguages && window._taggedLanguages[word]) {
        tokens.push({ type: 'fn', text: word });
        i = tokenizeTaggedTemplate(code, i, len, window._taggedLanguages[word], tokens);
        continue;
      }

      if (JS_KEYWORDS.has(word)) {
        tokens.push({ type: 'kw', text: word });
      } else if (JS_BUILTINS.has(word)) {
        tokens.push({ type: 'const', text: word });
      } else if (i < len && code[i] === '(') {
        tokens.push({ type: 'fn', text: word });
      } else {
        tokens.push({ type: 'id', text: word });
      }
      continue;
    }
    // operators
    if ('=+-*/<>!&|^~%?:'.includes(code[i])) {
      tokens.push({ type: 'op', text: code[i] });
      i++;
      continue;
    }
    // punctuation
    if ('(){}[];,.'.includes(code[i])) {
      tokens.push({ type: 'punc', text: code[i] });
      i++;
      continue;
    }
    // whitespace / other — pass through
    tokens.push({ type: '', text: code[i] });
    i++;
  }

  return tokens;
}

function highlightCode(ta, hl) {
  const code = ta.value;
  if (!code) { hl.innerHTML = '\n'; return; }

  const tokens = tokenize(code);
  let html = '';
  for (const t of tokens) {
    const escaped = t.text
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;');
    if (t.type && t.type !== 'id') {
      html += `<span class="hl-${t.type}">${escaped}</span>`;
    } else {
      html += escaped;
    }
  }
  // trailing newline so highlight layer matches textarea height
  hl.innerHTML = html + '\n';
}

// ── CSS SYNTAX HIGHLIGHTING ──

function tokenizeCss(code) {
  const tokens = [];
  let i = 0;
  const len = code.length;
  let ctx = 'sel'; // 'sel' | 'prop' | 'val'
  let depth = 0;

  while (i < len) {
    // block comment
    if (code[i] === '/' && code[i+1] === '*') {
      const start = i;
      i += 2;
      while (i < len && !(code[i-1] === '*' && code[i] === '/')) i++;
      if (i < len) i++;
      tokens.push({ type: 'cmt', text: code.slice(start, i) });
      continue;
    }
    // strings
    if (code[i] === '"' || code[i] === "'") {
      const q = code[i];
      const start = i;
      i++;
      while (i < len && code[i] !== q) {
        if (code[i] === '\\') i++;
        i++;
      }
      if (i < len) i++;
      tokens.push({ type: 'str', text: code.slice(start, i) });
      continue;
    }
    // punctuation with context transitions
    if (code[i] === '{') {
      tokens.push({ type: 'punc', text: '{' });
      depth++;
      ctx = 'prop';
      i++;
      continue;
    }
    if (code[i] === '}') {
      tokens.push({ type: 'punc', text: '}' });
      depth--;
      ctx = depth > 0 ? 'prop' : 'sel';
      i++;
      continue;
    }
    if (code[i] === ':' && ctx === 'prop') {
      tokens.push({ type: 'punc', text: ':' });
      ctx = 'val';
      i++;
      continue;
    }
    if (code[i] === ';') {
      tokens.push({ type: 'punc', text: ';' });
      ctx = 'prop';
      i++;
      continue;
    }
    if ('(),'.includes(code[i])) {
      tokens.push({ type: 'punc', text: code[i] });
      i++;
      continue;
    }
    // @-rules
    if (code[i] === '@') {
      const start = i;
      i++;
      while (i < len && /[a-zA-Z-]/.test(code[i])) i++;
      tokens.push({ type: 'atrule', text: code.slice(start, i) });
      continue;
    }
    // !important
    if (code[i] === '!' && ctx === 'val') {
      const start = i;
      i++;
      while (i < len && /[a-zA-Z]/.test(code[i])) i++;
      tokens.push({ type: 'important', text: code.slice(start, i) });
      continue;
    }
    // # — hex color in val, ID selector in sel
    if (code[i] === '#') {
      if (ctx === 'val') {
        const start = i;
        i++;
        while (i < len && /[0-9a-fA-F]/.test(code[i])) i++;
        tokens.push({ type: 'color', text: code.slice(start, i) });
      } else {
        // ID selector
        const start = i;
        i++;
        while (i < len && /[\w-]/.test(code[i])) i++;
        tokens.push({ type: 'sel', text: code.slice(start, i) });
      }
      continue;
    }
    // : in selector context = pseudo-class
    if (code[i] === ':' && ctx === 'sel') {
      const start = i;
      i++;
      if (i < len && code[i] === ':') i++; // ::
      while (i < len && /[a-zA-Z-]/.test(code[i])) i++;
      // handle pseudo with parens like :nth-child(...)
      if (i < len && code[i] === '(') {
        i++;
        let pdepth = 1;
        while (i < len && pdepth > 0) {
          if (code[i] === '(') pdepth++;
          else if (code[i] === ')') pdepth--;
          if (pdepth > 0) i++;
        }
        if (i < len) i++;
      }
      tokens.push({ type: 'sel', text: code.slice(start, i) });
      continue;
    }
    // . in selector context = class selector
    if (code[i] === '.' && ctx === 'sel') {
      const start = i;
      i++;
      while (i < len && /[\w-]/.test(code[i])) i++;
      tokens.push({ type: 'sel', text: code.slice(start, i) });
      continue;
    }
    // numbers (with units)
    if (ctx === 'val' && (/\d/.test(code[i]) || (code[i] === '.' && i+1 < len && /\d/.test(code[i+1])))) {
      const start = i;
      while (i < len && /[0-9.]/.test(code[i])) i++;
      // units
      while (i < len && /[a-zA-Z%]/.test(code[i])) i++;
      tokens.push({ type: 'num', text: code.slice(start, i) });
      continue;
    }
    // identifiers
    if (/[a-zA-Z_-]/.test(code[i])) {
      const start = i;
      while (i < len && /[\w-]/.test(code[i])) i++;
      const word = code.slice(start, i);
      // function call
      if (i < len && code[i] === '(') {
        tokens.push({ type: 'fn', text: word });
        continue;
      }
      if (ctx === 'val' && CSS_NAMED_COLORS.has(word.toLowerCase())) {
        tokens.push({ type: 'color', text: word });
      } else if (ctx === 'prop') {
        tokens.push({ type: 'prop', text: word });
      } else if (ctx === 'sel') {
        tokens.push({ type: 'sel', text: word });
      } else {
        tokens.push({ type: '', text: word });
      }
      continue;
    }
    // whitespace / other
    tokens.push({ type: '', text: code[i] });
    i++;
  }

  return tokens;
}

function resolveToHex(colorStr) {
  const d = document.createElement('div');
  d.style.color = colorStr;
  document.body.appendChild(d);
  const rgb = getComputedStyle(d).color;
  d.remove();
  const m = rgb.match(/(\d+)/g);
  if (!m || m.length < 3) return colorStr;
  return '#' + m.slice(0, 3).map(n => parseInt(n).toString(16).padStart(2, '0')).join('');
}

let _colorPicker = null;
let _pickerTarget = null; // { ta, offset, len }

function ensureColorPicker() {
  if (_colorPicker) return _colorPicker;
  _colorPicker = document.createElement('input');
  _colorPicker.type = 'color';
  _colorPicker.style.cssText = 'position:absolute;visibility:hidden;width:0;height:0;';
  document.body.appendChild(_colorPicker);
  _colorPicker.addEventListener('input', () => {
    if (!_pickerTarget) return;
    const { ta, offset, len } = _pickerTarget;
    const newColor = _colorPicker.value;
    ta.focus();
    ta.selectionStart = offset;
    ta.selectionEnd = offset + len;
    document.execCommand('insertText', false, newColor);
    ta.dispatchEvent(new Event('input'));
    // update offset for new length
    _pickerTarget.len = newColor.length;
  });
  return _colorPicker;
}

function highlightCss(ta, hl) {
  const code = ta.value;
  if (!code) { hl.innerHTML = '\n'; return; }

  const tokens = tokenizeCss(code);
  let html = '';
  let offset = 0;
  for (const t of tokens) {
    const escaped = t.text
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;');
    if (t.type === 'color') {
      const hex = resolveToHex(t.text);
      html += `<span class="hl-color"><span class="hl-swatch" style="background:${hex}" data-offset="${offset}" data-len="${t.text.length}"></span>${escaped}</span>`;
    } else if (t.type && t.type !== 'id') {
      html += `<span class="hl-${t.type}">${escaped}</span>`;
    } else {
      html += escaped;
    }
    offset += t.text.length;
  }
  hl.innerHTML = html + '\n';

  // wire swatch clicks (only add once per highlight layer)
  if (!hl._swatchWired) {
    hl._swatchWired = true;
    hl.addEventListener('click', (e) => {
      const swatch = e.target.closest('.hl-swatch');
      if (!swatch) return;
      const off = parseInt(swatch.dataset.offset);
      const len = parseInt(swatch.dataset.len);
      const picker = ensureColorPicker();
      _pickerTarget = { ta, offset: off, len };
      const hex = resolveToHex(ta.value.slice(off, off + len));
      picker.value = hex;
      picker.click();
    });
  }
}

// ── HTML SYNTAX HIGHLIGHTING ──

function tokenizeHtml(code) {
  const tokens = [];
  let i = 0;
  const len = code.length;

  while (i < len) {
    // template expression ${...}
    if (code[i] === '$' && i + 1 < len && code[i + 1] === '{') {
      const start = i;
      i += 2;
      let depth = 1;
      while (i < len && depth > 0) {
        if (code[i] === '{') depth++;
        else if (code[i] === '}') depth--;
        if (depth > 0) i++;
      }
      if (i < len) i++;
      tokens.push({ type: 'expr', text: code.slice(start, i) });
      continue;
    }
    // comment <!-- ... -->
    if (code[i] === '<' && code[i + 1] === '!' && code[i + 2] === '-' && code[i + 3] === '-') {
      const start = i;
      i += 4;
      while (i < len) {
        if (code[i] === '-' && code[i + 1] === '-' && code[i + 2] === '>') { i += 3; break; }
        i++;
      }
      tokens.push({ type: 'cmt', text: code.slice(start, i) });
      continue;
    }
    // tag
    if (code[i] === '<') {
      tokens.push({ type: 'tag', text: '<' });
      i++;
      // closing slash
      if (i < len && code[i] === '/') { tokens.push({ type: 'tag', text: '/' }); i++; }
      // tag name
      const ns = i;
      while (i < len && /[a-zA-Z0-9-]/.test(code[i])) i++;
      if (i > ns) tokens.push({ type: 'tag', text: code.slice(ns, i) });
      // attributes until >
      while (i < len && code[i] !== '>') {
        // template expression inside tag
        if (code[i] === '$' && i + 1 < len && code[i + 1] === '{') {
          const start = i;
          i += 2;
          let depth = 1;
          while (i < len && depth > 0) {
            if (code[i] === '{') depth++;
            else if (code[i] === '}') depth--;
            if (depth > 0) i++;
          }
          if (i < len) i++;
          tokens.push({ type: 'expr', text: code.slice(start, i) });
          continue;
        }
        if (/\s/.test(code[i])) { tokens.push({ type: '', text: code[i] }); i++; continue; }
        if (code[i] === '/') { tokens.push({ type: 'tag', text: '/' }); i++; continue; }
        if (code[i] === '=') { tokens.push({ type: 'punc', text: '=' }); i++; continue; }
        // quoted attribute value
        if (code[i] === '"' || code[i] === "'") {
          const q = code[i];
          const start = i;
          i++;
          while (i < len && code[i] !== q) { if (code[i] === '\\') i++; i++; }
          if (i < len) i++;
          tokens.push({ type: 'str', text: code.slice(start, i) });
          continue;
        }
        // attribute name or unquoted value
        const as = i;
        while (i < len && !/[\s=>/"']/.test(code[i])) i++;
        if (i > as) {
          let j = i;
          while (j < len && /\s/.test(code[j])) j++;
          tokens.push({ type: (j < len && code[j] === '=') ? 'attr' : 'attr', text: code.slice(as, i) });
        }
      }
      if (i < len && code[i] === '>') { tokens.push({ type: 'tag', text: '>' }); i++; }
      continue;
    }
    // plain text
    tokens.push({ type: '', text: code[i] });
    i++;
  }

  return tokens;
}

function highlightHtml(ta, hl) {
  const code = ta.value;
  if (!code) { hl.innerHTML = '\n'; return; }

  const tokens = tokenizeHtml(code);
  let html = '';
  for (const t of tokens) {
    const escaped = t.text
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;');
    if (t.type) {
      html += `<span class="hl-${t.type}">${escaped}</span>`;
    } else {
      html += escaped;
    }
  }
  hl.innerHTML = html + '\n';
}

// -- dag.js --

// ── REACTIVE DAG ──

// ── directive helpers ──

function hasDirective(code, name) {
  return new RegExp(String.raw`^\s*\/\/\s*%${name}\b`, 'm').test(code);
}

function getDirective(code, name) {
  const m = code.match(new RegExp(String.raw`^\s*\/\/\s*%${name}\s+(.+)`, 'm'));
  return m ? m[1].trim() : null;
}

const isManual    = code => hasDirective(code, 'manual');
const isHidden    = code => hasDirective(code, 'hide');
const isNorun     = code => hasDirective(code, 'norun');
const isCollapsed = code => hasDirective(code, 'collapsed');
const parseCellName    = code => getDirective(code, 'cellName');
const parseOutputId    = code => { const v = getDirective(code, 'outputId'); return v ? v.split(/\s+/)[0] : null; };
const parseOutputClass = code => getDirective(code, 'outputClass');

// ── code analysis ──

function stripCommentsAndStrings(code) {
  // single-pass: strings take precedence over comments (// inside "..." is not a comment)
  let out = '', i = 0;
  while (i < code.length) {
    // single-quoted string
    if (code[i] === "'") {
      out += '""';
      i++;
      while (i < code.length && code[i] !== "'") { if (code[i] === '\\') i++; i++; }
      i++; // skip closing quote
      continue;
    }
    // double-quoted string
    if (code[i] === '"') {
      out += '""';
      i++;
      while (i < code.length && code[i] !== '"') { if (code[i] === '\\') i++; i++; }
      i++; // skip closing quote
      continue;
    }
    // template literal: replace string parts with spaces but keep ${expr} content
    if (code[i] === '`') {
      i++;
      while (i < code.length && code[i] !== '`') {
        if (code[i] === '\\') { i += 2; continue; }
        if (code[i] === '$' && code[i + 1] === '{') {
          i += 2;
          let depth = 1;
          out += ' ';
          while (i < code.length && depth > 0) {
            if (code[i] === '{') depth++;
            else if (code[i] === '}') { depth--; if (depth === 0) break; }
            out += code[i];
            i++;
          }
          out += ' ';
          i++; // skip closing }
          continue;
        }
        i++;
      }
      i++; // skip closing backtick
      continue;
    }
    // line comment
    if (code[i] === '/' && code[i + 1] === '/') {
      while (i < code.length && code[i] !== '\n') i++;
      continue;
    }
    // block comment
    if (code[i] === '/' && code[i + 1] === '*') {
      i += 2;
      while (i < code.length && !(code[i - 1] === '*' && code[i] === '/')) i++;
      i++;
      continue;
    }
    out += code[i];
    i++;
  }
  return out;
}

function parseNames(code) {
  // extract ONLY top-level variable definitions (brace depth 0)
  const defines = new Set();

  const stripped = stripCommentsAndStrings(code);

  let depth = 0;
  let parenDepth = 0;
  let i = 0;
  while (i < stripped.length) {
    const ch = stripped[i];
    if (ch === '{') { depth++; i++; continue; }
    if (ch === '}') { depth--; i++; continue; }
    if (ch === '(') { parenDepth++; i++; continue; }
    if (ch === ')') { parenDepth--; i++; continue; }

    if (depth === 0 && parenDepth === 0) {
      // check for const/let/var
      const rest = stripped.slice(i);
      const dm = rest.match(/^(?:const|let|var)\s+(\w+)/);
      if (dm) {
        defines.add(dm[1]);
        // scan forward for comma-separated declarations: const W = 80, H = 60
        // skip initializer expressions tracking depth, grab identifiers after commas
        let j = dm[0].length;
        let d = 0, pd = 0, bd = 0;
        while (j < rest.length) {
          const ch = rest[j];
          if (ch === '{') d++;
          else if (ch === '}') d--;
          else if (ch === '(') pd++;
          else if (ch === ')') pd--;
          else if (ch === '[') bd++;
          else if (ch === ']') bd--;
          else if (ch === ';' || ch === '\n') {
            if (d === 0 && pd === 0 && bd === 0) break;
          }
          else if (ch === ',' && d === 0 && pd === 0 && bd === 0) {
            // next identifier after comma
            const after = rest.slice(j + 1).match(/^\s*(\w+)/);
            if (after) defines.add(after[1]);
          }
          j++;
        }
        i += j;
        continue;
      }
      // destructuring: const { a, b } = ... or const [ a, b ] = ...
      const destruct = rest.match(/^(?:const|let|var)\s*[\{\[]/);
      if (destruct) {
        // find the closing } or ] then extract identifiers
        const opener = rest[destruct[0].length - 1];
        const closer = opener === '{' ? '}' : ']';
        const closeIdx = rest.indexOf(closer, destruct[0].length);
        if (closeIdx > 0) {
          const inner = rest.slice(destruct[0].length, closeIdx);
          // split on commas, take last word of each part (handles renaming)
          inner.split(',').forEach(part => {
            const parts = part.trim().split(/\s*:\s*/);
            const name = (parts.length > 1 ? parts[1] : parts[0]).trim().match(/^\w+/);
            if (name) defines.add(name[0]);
          });
          i += closeIdx + 1;
          continue;
        }
      }
      // check for function declarations
      const fm = rest.match(/^function\s+(\w+)/);
      if (fm) {
        defines.add(fm[1]);
        i += fm[0].length;
        continue;
      }
    }
    i++;
  }

  return { defines };
}

function findUses(code, allDefined, selfDefined) {
  // find identifiers that reference other cells' definitions
  const uses = new Set();
  const stripped = stripCommentsAndStrings(code);
  if (!selfDefined) selfDefined = parseNames(code).defines;

  const idRe = /\b([a-zA-Z_$]\w*)\b/g;
  let m;
  while ((m = idRe.exec(stripped))) {
    if (allDefined.has(m[1]) && !selfDefined.has(m[1])) {
      uses.add(m[1]);
    }
  }
  return uses;
}

function findHtmlUses(code, allDefined) {
  const uses = new Set();
  const re = /\$\{([^}]+)\}/g;
  let m;
  while ((m = re.exec(code))) {
    const expr = m[1];
    const idRe = /\b([a-zA-Z_$]\w*)\b/g;
    let im;
    while ((im = idRe.exec(expr))) {
      if (allDefined.has(im[1])) uses.add(im[1]);
    }
  }
  return uses;
}

function buildDAG() {
  // collect all defined names globally (only re-parse changed cells)
  const allDefined = new Map(); // name -> cell id
  for (const c of S.cells) {
    if (c.type !== 'code') continue;
    if (c.code !== c._parsedCode) {
      const { defines } = parseNames(c.code);
      c.defines = defines;
      c._parsedCode = c.code;
    }
    for (const name of c.defines) {
      allDefined.set(name, c.id);
    }
  }

  // find uses for each cell (invalidate if code changed or global names changed)
  const definedNames = new Set(allDefined.keys());
  const definedKey = [...definedNames].sort().join(',');
  for (const c of S.cells) {
    if (c.type === 'code') {
      if (c.code !== c._usesCode || c._definedKey !== definedKey) {
        c.uses = findUses(c.code, definedNames, c.defines);
        c._usesCode = c.code;
        c._definedKey = definedKey;
      }
    } else if (c.type === 'html') {
      if (c.code !== c._usesCode || c._definedKey !== definedKey) {
        c.uses = findHtmlUses(c.code, definedNames);
        c._usesCode = c.code;
        c._definedKey = definedKey;
      }
    }
  }

  return allDefined;
}

function topoSort(dirtyIds) {
  // BFS from dirty cells to find all downstream dependents
  const dependents = new Map(); // varName -> Set<cellId>
  for (const c of S.cells) {
    if (!c.uses) continue;
    for (const name of c.uses) {
      if (!dependents.has(name)) dependents.set(name, new Set());
      dependents.get(name).add(c.id);
    }
  }

  const needsRun = new Set(dirtyIds);
  const queue = [...dirtyIds];
  while (queue.length) {
    const id = queue.shift();
    const cell = S.cells.find(c => c.id === id);
    if (!cell || !cell.defines) continue;
    for (const name of cell.defines) {
      const deps = dependents.get(name);
      if (!deps) continue;
      for (const depId of deps) {
        if (!needsRun.has(depId)) {
          needsRun.add(depId);
          queue.push(depId);
        }
      }
    }
  }

  // return in document order
  return S.cells.filter(c => needsRun.has(c.id)).map(c => c.id);
}

// -- exec.js --

// ── EXECUTION ENGINE ──
//
// Scope model: each cell runs inside an AsyncFunction where upstream variables
// are passed as parameters. This is pass-by-value for primitives — reassigning
// a variable in cell A (e.g. `grid = next`) does NOT propagate to cell B.
// Mutable state that needs to survive across callbacks belongs in %manual cells
// using DOM elements, objects, or closures.
//
// Cell builtins (display, canvas, slider, load, install, installBinary, etc.)
// are injected as additional parameters — listed in _injected, not in scope.
// They are NOT propagated to downstream cells.

// ── BINARY HELPERS ──

function uint8ToBase64(bytes) {
  let bin = '';
  for (let i = 0; i < bytes.length; i++) bin += String.fromCharCode(bytes[i]);
  return btoa(bin);
}

async function decodeBinary(entry) {
  const type = entry.type || 'application/octet-stream';
  const bytes = Uint8Array.from(atob(entry.source), c => c.charCodeAt(0));
  if (entry.compressed) {
    const ds = new DecompressionStream('gzip');
    const stream = new Blob([bytes]).stream().pipeThrough(ds);
    const decompressed = new Uint8Array(await new Response(stream).arrayBuffer());
    return URL.createObjectURL(new Blob([decompressed], { type }));
  }
  return URL.createObjectURL(new Blob([bytes], { type }));
}

// ── TAGGED CONTENT ──

class TaggedContent {
  constructor(type, content) { this.type = type; this.content = content; }
  toString() { return this.content; }
}

function taggedTemplate(type) {
  return (strings, ...values) => {
    let result = strings[0];
    for (let i = 0; i < values.length; i++) result += String(values[i]) + strings[i + 1];
    return new TaggedContent(type, result);
  };
}

// ── EXECUTION ──

function renderHtmlCell(cell) {
  const viewEl = cell.el.querySelector('.cell-html-view');
  const outputEl = cell.el.querySelector('.cell-output');
  if (!viewEl) return;
  if (outputEl) { outputEl.textContent = ''; outputEl.className = 'cell-output'; }

  // use only variables this cell references for stable function signatures
  const scopeKeys = cell.uses ? [...cell.uses].sort() : [];
  const scopeVals = scopeKeys.map(k => S.scope[k]);

  // cache compiled template functions per expression
  if (!cell._tplCache) cell._tplCache = {};
  const scopeSig = scopeKeys.join(',');
  if (cell._tplScopeSig !== scopeSig) {
    cell._tplCache = {};  // scope signature changed, invalidate all
    cell._tplScopeSig = scopeSig;
  }

  let rendered = cell.code.replace(/\$\{([^}]+)\}/g, (match, expr) => {
    try {
      let fn = cell._tplCache[expr];
      if (!fn) {
        fn = new Function(...scopeKeys, '"use strict"; return (' + expr + ')');
        cell._tplCache[expr] = fn;
      }
      const val = fn(...scopeVals);
      return val === undefined ? '' : String(val);
    } catch (e) {
      return '[Error: ' + e.message + ']';
    }
  });

  viewEl.innerHTML = rendered;
  cell.el.classList.remove('stale', 'error');
  cell.el.classList.add('fresh');
  setTimeout(() => cell.el.classList.remove('fresh'), 800);
}

async function execCell(cell) {
  // fire invalidation promise from previous run (cleanup resources)
  if (cell._invalidate) { cell._invalidate(); cell._invalidate = null; }

  const outputEl = cell.el.querySelector('.cell-output');
  const widgetEl = cell.el.querySelector('.cell-widgets');

  // preserve canvases before clearing output
  const prevCanvases = [...outputEl.querySelectorAll('canvas')];
  outputEl.textContent = '';
  outputEl.className = 'cell-output';
  const outClass = parseOutputClass(cell.code);
  if (outClass) outputEl.classList.add(...outClass.split(/\s+/));
  const outId = parseOutputId(cell.code);
  outputEl.id = outId || '';
  cell.el.classList.toggle('present-hidden', isHidden(cell.code));
  cell.error = null;

  // create invalidation promise for this run
  let invalidationResolve;
  const invalidation = new Promise(r => { invalidationResolve = r; });
  cell._invalidate = invalidationResolve;

  // track which widgets are used this run
  const usedWidgets = new Set();
  let canvasIdx = 0;

  // build display function for this cell
  const display = (...args) => {
    for (const arg of args) {
      if (arg instanceof Element) {
        outputEl.appendChild(arg);
      } else if (typeof arg === 'object' && arg !== null) {
        const pre = document.createElement('span');
        try { pre.textContent = JSON.stringify(arg, null, 2); }
        catch { pre.textContent = String(arg); }
        outputEl.appendChild(pre);
        outputEl.appendChild(document.createTextNode('\n'));
      } else {
        outputEl.appendChild(document.createTextNode(String(arg) + '\n'));
      }
    }
  };

  // canvas helper — reuses existing canvas if dimensions match
  const canvas = (w = 400, h = 300) => {
    const prev = prevCanvases[canvasIdx++];
    if (prev && prev.width === w && prev.height === h) {
      outputEl.appendChild(prev);
      return prev;
    }
    const c = document.createElement('canvas');
    c.width = w; c.height = h;
    c.style.background = '#000';
    outputEl.appendChild(c);
    return c;
  };

  // table helper
  const table = (data, columns) => {
    if (!data || !data.length) return;
    const cols = columns || Object.keys(data[0]);

    // detect numeric columns by scanning first 10 rows
    const isNumCol = {};
    for (const c of cols) {
      let allNum = true;
      const scanRows = data.slice(0, 10);
      for (const row of scanRows) {
        const v = row[c];
        if (v !== null && v !== undefined && typeof v !== 'number') { allNum = false; break; }
      }
      isNumCol[c] = allNum;
    }

    const t = document.createElement('table');
    const thead = document.createElement('thead');
    const hr = document.createElement('tr');
    for (const c of cols) {
      const th = document.createElement('th');
      th.textContent = c;
      th.style.textAlign = isNumCol[c] ? 'right' : 'left';
      hr.appendChild(th);
    }
    thead.appendChild(hr);
    t.appendChild(thead);
    const tbody = document.createElement('tbody');
    for (const row of data) {
      const tr = document.createElement('tr');
      for (const c of cols) {
        const td = document.createElement('td');
        const v = row[c];
        td.textContent = typeof v === 'number' ? (Number.isInteger(v) ? v : v.toFixed(4)) : String(v ?? '');
        td.style.textAlign = isNumCol[c] ? 'right' : 'left';
        tr.appendChild(td);
      }
      tbody.appendChild(tr);
    }
    t.appendChild(tbody);
    outputEl.appendChild(t);
  };

  // input widget helpers — persist state and DOM across re-runs
  if (!cell._inputs) cell._inputs = {};
  if (!cell._callbacks) cell._callbacks = {};

  const mkInput = (label, type, defaultVal, opts = {}) => {
    const key = label;
    const prev = cell._inputs[key];
    let val = prev !== undefined ? prev : defaultVal;
    usedWidgets.add(key);
    cell._callbacks[key] = { onInput: opts.onInput, onChange: opts.onChange };

    // check if widget DOM already exists
    const existing = widgetEl.querySelector(`[data-widget-key="${CSS.escape(key)}"]`);
    if (existing) {
      // update id/class in case they changed on re-run
      existing.id = opts.id || '';
      existing.className = 'cell-widget' + (opts.class ? ' ' + opts.class : '');
      // just return current value, DOM stays — callbacks already updated above
      cell._inputs[key] = type === 'slider' ? parseFloat(val)
                         : type === 'checkbox' ? !!val
                         : val;
      return cell._inputs[key];
    }

    // create new widget
    const wrap = document.createElement('div');
    wrap.dataset.widgetKey = key;
    wrap.className = 'cell-widget' + (opts.class ? ' ' + opts.class : '');
    if (opts.id) wrap.id = opts.id;

    const lbl = document.createElement('span');
    lbl.textContent = label;
    lbl.className = 'cell-widget-label';
    wrap.appendChild(lbl);

    let input;
    if (type === 'slider') {
      input = document.createElement('input');
      input.type = 'range';
      input.min = opts.min ?? 0;
      input.max = opts.max ?? 100;
      input.step = opts.step ?? 1;
      input.value = val;
      const valSpan = document.createElement('span');
      valSpan.textContent = val;
      valSpan.className = 'cell-widget-val';
      input.oninput = () => {
        const n = parseFloat(input.value);
        cell._inputs[key] = n;
        valSpan.textContent = n;
        const cb = cell._callbacks[key];
        if (cb.onInput) { cb.onInput(n); }
        else if (!cb.onChange) { clearTimeout(cell._inputTimer); cell._inputTimer = setTimeout(() => runDAG([cell.id], true), 80); }
      };
      input.onchange = () => { const cb = cell._callbacks[key]; if (cb.onChange) cb.onChange(parseFloat(input.value)); };
      wrap.appendChild(input);
      wrap.appendChild(valSpan);
    } else if (type === 'dropdown') {
      input = document.createElement('select');
      for (const o of (opts.options || [])) {
        const opt = document.createElement('option');
        opt.value = o;
        opt.textContent = o;
        if (o === val) opt.selected = true;
        input.appendChild(opt);
      }
      input.onchange = () => {
        cell._inputs[key] = input.value;
        const cb = cell._callbacks[key];
        if (cb.onInput || cb.onChange) {
          if (cb.onInput) cb.onInput(input.value);
          if (cb.onChange) cb.onChange(input.value);
        } else { runDAG([cell.id], true); }
      };
      wrap.appendChild(input);
    } else if (type === 'checkbox') {
      input = document.createElement('input');
      input.type = 'checkbox';
      input.checked = !!val;
      input.onchange = () => {
        cell._inputs[key] = input.checked;
        const cb = cell._callbacks[key];
        if (cb.onInput || cb.onChange) {
          if (cb.onInput) cb.onInput(input.checked);
          if (cb.onChange) cb.onChange(input.checked);
        } else { runDAG([cell.id], true); }
      };
      wrap.appendChild(input);
    } else if (type === 'text') {
      input = document.createElement('input');
      input.type = 'text';
      input.value = val;
      input.oninput = () => {
        cell._inputs[key] = input.value;
        const cb = cell._callbacks[key];
        if (cb.onInput) { cb.onInput(input.value); }
        else if (!cb.onChange) { clearTimeout(cell._inputTimer); cell._inputTimer = setTimeout(() => runDAG([cell.id], true), 300); }
      };
      input.onchange = () => { const cb = cell._callbacks[key]; if (cb.onChange) cb.onChange(input.value); };
      wrap.appendChild(input);
    }

    widgetEl.appendChild(wrap);
    cell._inputs[key] = type === 'slider' ? parseFloat(val)
                       : type === 'checkbox' ? !!val
                       : val;
    return cell._inputs[key];
  };

  const slider = (label, defaultVal = 50, opts = {}) => mkInput(label, 'slider', defaultVal, opts);
  const dropdown = (label, options, defaultVal, opts = {}) => mkInput(label, 'dropdown', defaultVal || options[0], { ...opts, options });
  const checkbox = (label, defaultVal = false, opts = {}) => mkInput(label, 'checkbox', defaultVal, opts);
  const textInput = (label, defaultVal = '', opts = {}) => mkInput(label, 'text', defaultVal, opts);

  // execute with scoped parameters (only what this cell uses, for stable V8 JIT)
  // filter out injected names — they're per-cell params, not scope-propagated
  const _injected = ['ui', 'std', 'load', 'install', 'installBinary', 'invalidation', 'print', 'md', 'html', 'css', 'workshop', 'notebook'];
  const scopeKeys = cell.uses ? [...cell.uses].filter(k => !_injected.includes(k)).sort() : [];
  const defNames = cell.defines ? [...cell.defines].sort().join(', ') : '';

  // import cache — shared across all cells
  if (!window._importCache) window._importCache = {};
  if (!window._installedModules) window._installedModules = {}; // url -> { source, cellId }

  const load = async (url) => {
    // virtual modules
    if (url === '@std') return std;
    if (url === '@python') return python;
    if (url === '@python/this') { display(zenOfPython()); return python; }

    // @atra/<name> — atra library binary distributions
    // if pre-installed (via /// module: directive or install()), the existing
    // _installedModules[url] check below handles it. this fallback covers
    // development mode where the file is available at a relative path.
    if (url.startsWith('@atra/')) {
      if (!window._importCache[url] && !window._installedModules[url]) {
        const name = url.slice(6);
        const mod = await import('./ext/atra/lib/' + name + '.js');
        window._importCache[url] = mod;
        return mod;
      }
      // fall through to normal _importCache / _installedModules handling below
    }

    if (window._importCache[url]) return window._importCache[url];

    // binary assets — return blob URL
    if (window._installedModules[url]?.binary) {
      const blobUrl = await decodeBinary(window._installedModules[url]);
      window._importCache[url] = blobUrl;
      return blobUrl;
    }

    const langsBefore = window._taggedLanguages ? Object.keys(window._taggedLanguages).length : 0;

    let mod;
    // check installed (offline) modules first
    if (window._installedModules[url]) {
      const entry = window._installedModules[url];
      let src = typeof entry === 'string' ? entry : entry.source;
      // resolve root-relative paths for legacy saved modules
      try { src = resolveModulePaths(src, url); } catch {}
      const blob = new Blob([src], { type: 'application/javascript' });
      const blobUrl = URL.createObjectURL(blob);
      mod = await import(blobUrl);
    } else {
      mod = await import(url);
    }
    window._importCache[url] = mod;

    // if the module registered new tagged languages, re-highlight all code cells
    const langsAfter = window._taggedLanguages ? Object.keys(window._taggedLanguages).length : 0;
    if (langsAfter > langsBefore) {
      for (const c of S.cells) {
        if (c.type !== 'code') continue;
        const ta = c.el.querySelector('textarea');
        const hl = c.el.querySelector('.highlight-layer');
        if (ta && hl) highlightCode(ta, hl);
      }
    }

    return mod;
  };

  // resolve root-relative paths in module source so blob URLs work
  const resolveModulePaths = (source, responseUrl) => {
    const origin = new URL(responseUrl).origin;
    return source.replace(/(from\s+["'])(\/[^"']+)(["'])/g, '$1' + origin + '$2$3')
                 .replace(/(import\s*\(["'])(\/[^"']+)(["']\))/g, '$1' + origin + '$2$3')
                 .replace(/(export\s+\*\s+from\s+["'])(\/[^"']+)(["'])/g, '$1' + origin + '$2$3')
                 .replace(/(export\s*\{[^}]*\}\s*from\s+["'])(\/[^"']+)(["'])/g, '$1' + origin + '$2$3');
  };

  const install = async (url) => {
    // @atra/<name> — resolve to CDN URL, store under virtual key
    if (url.startsWith('@atra/')) {
      const name = url.slice(6);
      const realUrl = __AUDITABLE_PAGES_URL__ + '/ext/atra/lib/' + name + '.js';
      const resp = await fetch(realUrl);
      if (!resp.ok) throw new Error(`Failed to fetch ${realUrl}: ${resp.status}`);
      const source = await resp.text();
      window._installedModules[url] = { source, cellId: cell.id };
      const blob = new Blob([source], { type: 'application/javascript' });
      const blobUrl = URL.createObjectURL(blob);
      const mod = await import(blobUrl);
      window._importCache[url] = mod;
      display(`installed ${url} (${(source.length / 1024).toFixed(1)} KB)`);
      return mod;
    }
    // normalize: add ?bundle for esm.sh if not present
    let bundleUrl = url;
    if (bundleUrl.includes('esm.sh') && !bundleUrl.includes('?bundle') && !bundleUrl.includes('&bundle')) {
      bundleUrl += (bundleUrl.includes('?') ? '&' : '?') + 'bundle';
    }
    // fetch source
    const resp = await fetch(bundleUrl);
    if (!resp.ok) throw new Error(`Failed to fetch ${bundleUrl}: ${resp.status}`);
    let source = await resp.text();
    // resolve root-relative paths to absolute so blob URLs work
    source = resolveModulePaths(source, resp.url);
    // store under original url with cell reference
    window._installedModules[url] = { source, cellId: cell.id };
    // also load it into cache
    const blob = new Blob([source], { type: 'application/javascript' });
    const blobUrl = URL.createObjectURL(blob);
    const mod = await import(blobUrl);
    window._importCache[url] = mod;
    display(`installed ${url} (${(source.length / 1024).toFixed(1)} KB)`);
    return mod;
  };

  const installBinary = async (url, opts = {}) => {
    const compress = opts.compress !== false;
    // if already installed, decode and return blob URL
    if (window._installedModules[url]?.binary) {
      return decodeBinary(window._installedModules[url]);
    }
    const resp = await fetch(url);
    if (!resp.ok) throw new Error(`Failed to fetch ${url}: ${resp.status}`);
    const contentType = resp.headers.get('content-type')?.split(';')[0] || 'application/octet-stream';
    const buf = await resp.arrayBuffer();
    const raw = new Uint8Array(buf);
    let stored, isCompressed = false;
    if (compress) {
      const cs = new CompressionStream('gzip');
      const stream = new Blob([raw]).stream().pipeThrough(cs);
      const compressed = new Uint8Array(await new Response(stream).arrayBuffer());
      stored = uint8ToBase64(compressed);
      isCompressed = true;
    } else {
      stored = uint8ToBase64(raw);
    }
    window._installedModules[url] = { source: stored, cellId: cell.id, binary: true, compressed: isCompressed, type: contentType };
    const ratio = isCompressed ? ` \u2192 ${(stored.length / 1024).toFixed(1)} KB compressed` : '';
    display(`installed binary ${url} (${(buf.byteLength / 1024).toFixed(1)} KB${ratio})`);
    return URL.createObjectURL(new Blob([raw], { type: contentType }));
  };

  // ui object — constructed per-cell (closes over cell context)
  const ui = { display, print: display, canvas, table, slider, dropdown, checkbox, textInput };

  // tagged template builtins
  const md = taggedTemplate('md');
  const html = taggedTemplate('html');
  const css = taggedTemplate('css');

  // workshop builtin — slide-out side panel with navigable pages
  const workshop = (pages, opts) => {
    const key = '__workshop__';
    usedWidgets.add(key);
    const useOverlay = !!(opts && opts.overlay);

    // persist page index across re-runs
    if (cell._inputs[key] === undefined) cell._inputs[key] = 0;
    let currentPage = cell._inputs[key];

    // get or create panel DOM
    let panel = document.getElementById('workshopPanel');
    let overlay = document.getElementById('workshopOverlay');
    if (!panel) {
      overlay = document.createElement('div');
      overlay.id = 'workshopOverlay';
      overlay.className = 'workshop-overlay';
      overlay.onclick = () => toggleWorkshop(false);
      document.body.appendChild(overlay);

      panel = document.createElement('div');
      panel.id = 'workshopPanel';
      panel.className = 'workshop-panel';
      document.body.appendChild(panel);
    }

    // side tab attached to the panel edge
    let toggleBtn = document.getElementById('workshopToggle');
    if (!toggleBtn) {
      toggleBtn = document.createElement('button');
      toggleBtn.id = 'workshopToggle';
      toggleBtn.className = 'workshop-tab';
      toggleBtn.title = 'toggle workshop panel';
      toggleBtn.textContent = 'workshop';
      document.body.appendChild(toggleBtn);
      toggleBtn.onclick = () => toggleWorkshop();
    }

    function toggleWorkshop(show) {
      const isOpen = panel.classList.contains('open');
      const shouldOpen = show !== undefined ? show : !isOpen;
      panel.classList.toggle('open', shouldOpen);
      if (useOverlay) overlay.classList.toggle('visible', shouldOpen);
    }

    function renderPage(idx) {
      idx = Math.max(0, Math.min(idx, pages.length - 1));
      currentPage = idx;
      cell._inputs[key] = idx;
      const page = pages[idx];

      panel.innerHTML = '';

      // header with close button
      const header = document.createElement('div');
      header.className = 'workshop-header';
      const title = document.createElement('span');
      title.className = 'workshop-title';
      title.textContent = page.title || `Page ${idx + 1}`;
      header.appendChild(title);
      const closeBtn = document.createElement('button');
      closeBtn.className = 'workshop-close';
      closeBtn.textContent = '\u00d7';
      closeBtn.onclick = () => toggleWorkshop(false);
      header.appendChild(closeBtn);
      panel.appendChild(header);

      // content
      const body = document.createElement('div');
      body.className = 'workshop-body';
      if (page.content instanceof Element) {
        body.appendChild(page.content);
      } else if (page.content instanceof TaggedContent) {
        if (page.content.type === 'md') {
          body.innerHTML = renderMd(page.content.content);
        } else if (page.content.type === 'css') {
          const pre = document.createElement('pre');
          pre.textContent = page.content.content;
          body.appendChild(pre);
        } else {
          body.innerHTML = page.content.content;
        }
      } else {
        body.textContent = String(page.content ?? '');
      }
      panel.appendChild(body);

      // progress pips
      const pips = document.createElement('div');
      pips.className = 'workshop-pips';
      for (let i = 0; i < pages.length; i++) {
        const pip = document.createElement('span');
        pip.className = 'workshop-pip' + (i === idx ? ' active' : '') + (i < idx ? ' done' : '');
        pip.onclick = () => navigate(i);
        pips.appendChild(pip);
      }
      panel.appendChild(pips);

      // nav buttons
      const nav = document.createElement('div');
      nav.className = 'workshop-nav';
      if (idx > 0) {
        const prev = document.createElement('button');
        prev.textContent = '\u2190 prev';
        prev.onclick = () => navigate(idx - 1);
        nav.appendChild(prev);
      }
      const spacer = document.createElement('span');
      spacer.style.flex = '1';
      nav.appendChild(spacer);
      const counter = document.createElement('span');
      counter.className = 'workshop-counter';
      counter.textContent = `${idx + 1} / ${pages.length}`;
      nav.appendChild(counter);
      if (idx < pages.length - 1) {
        const next = document.createElement('button');
        next.className = 'workshop-next';
        next.textContent = 'next \u2192';
        if (page.canAdvance && !page.canAdvance()) {
          next.disabled = true;
          next.title = 'complete the task to continue';
        }
        next.onclick = () => navigate(idx + 1);
        nav.appendChild(next);
      }
      panel.appendChild(nav);

      // fire onEnter
      if (page.onEnter) page.onEnter();
    }

    function navigate(idx) {
      const prevPage = pages[currentPage];
      if (prevPage?.onLeave) prevPage.onLeave();
      renderPage(idx);
    }

    // store re-check function for canAdvance gating
    cell._workshopRecheck = () => {
      const page = pages[currentPage];
      if (!page?.canAdvance) return;
      const nextBtn = panel.querySelector('.workshop-next');
      if (nextBtn) {
        nextBtn.disabled = !page.canAdvance();
      }
    };

    renderPage(currentPage);

    // auto-open on first creation
    if (!panel.classList.contains('open') && !cell._workshopShown) {
      toggleWorkshop(true);
      cell._workshopShown = true;
    }

    // store cleanup so deleteCell can tear down workshop DOM
    cell._workshopCleanup = () => {
      panel.remove();
      overlay.remove();
      toggleBtn.remove();
      cell._workshopRecheck = null;
    };
    // on re-run, just clear the recheck — DOM is reused by ID
    invalidation.then(() => {
      cell._workshopRecheck = null;
    });

    return { goto: navigate, toggle: toggleWorkshop, recheck: cell._workshopRecheck };
  };

  // notebook API — programmatic notebook control
  const notebook = {
    get cells() { return S.cells.map(c => ({ id: c.id, type: c.type, code: c.code })); },
    get scope() { return { ...S.scope }; },
    addCell: (type, code, afterId) => addCell(type, code, afterId),
    scrollTo: (id) => {
      const c = S.cells.find(c => c.id === id);
      if (c?.el) c.el.scrollIntoView({ behavior: 'smooth', block: 'center' });
    },
    focus: (id) => {
      const c = S.cells.find(c => c.id === id);
      if (c?.el) {
        c.el.scrollIntoView({ behavior: 'smooth', block: 'center' });
        const ta = c.el.querySelector('textarea');
        if (ta) ta.focus();
      }
    },
    collapse: (id) => {
      const c = S.cells.find(c => c.id === id);
      if (c?.el) c.el.classList.add('collapsed');
    },
    expand: (id) => {
      const c = S.cells.find(c => c.id === id);
      if (c?.el) c.el.classList.remove('collapsed');
    },
    run: (ids) => runDAG(Array.isArray(ids) ? ids : [ids], true),
  };

  // function caching — reuse compiled function if code/uses/defines unchanged
  const cacheKey = scopeKeys.join(',') + '|' + defNames + '|' + cell.code;

  try {
    let fn;
    if (cell._cacheKey === cacheKey && cell._cachedFn) {
      fn = cell._cachedFn;
    } else {
      const AsyncFunction = Object.getPrototypeOf(async function(){}).constructor;
      const cellName = parseCellName(cell.code);
      const slug = cellName ? '-' + cellName.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/(^-|-$)/g, '') : '';
      fn = new AsyncFunction(
        ...scopeKeys,
        'ui', 'std', 'load', 'install', 'installBinary', 'invalidation', 'print',
        'md', 'html', 'css', 'workshop', 'notebook',
        `"use strict";\n${cell.code}\n\n` +
        `return { ${defNames} };\n` +
        `//# sourceURL=auditable://cell-${cell.id}${slug}.js`
      );
      cell._cachedFn = fn;
      cell._cacheKey = cacheKey;
    }

    const scopeVals = scopeKeys.map(k => S.scope[k]);
    const result = await fn(...scopeVals, ui, std, load, install, installBinary, invalidation, display,
      md, html, css, workshop, notebook);

    // update scope with defined variables
    if (result && typeof result === 'object') {
      cell._lastResult = result;
      for (const [k, v] of Object.entries(result)) {
        if (v !== undefined) S.scope[k] = v;
      }
    }

    cell.el.classList.remove('stale', 'error');
    cell.el.classList.add('fresh');
    setTimeout(() => cell.el.classList.remove('fresh'), 800);

    // remove widgets no longer referenced by code
    for (const w of widgetEl.querySelectorAll('[data-widget-key]')) {
      if (!usedWidgets.has(w.dataset.widgetKey)) {
        delete cell._inputs[w.dataset.widgetKey];
        delete cell._callbacks[w.dataset.widgetKey];
        w.remove();
      }
    }

  } catch (e) {
    cell.error = e.message;
    outputEl.textContent = e.message;
    outputEl.className = 'cell-output error';
    cell.el.classList.remove('stale', 'fresh');
    cell.el.classList.add('error');
  }
}

async function runDAG(dirtyIds, force = false) {
  buildDAG();
  const isAutorun = S.autorun && !force;

  // determine which cells need execution via topo sort
  const runSet = new Set(topoSort(dirtyIds));

  if (window._dagStart) window._dagStart();

  // rebuild scope in document order, only executing cells in runSet
  S.scope = {};
  const poisoned = new Set(); // variable names defined by errored cells
  for (let i = 0; i < S.cells.length; i++) {
    const cell = S.cells[i];

    if (cell.type === 'html') {
      if (runSet.has(cell.id)) {
        // check if any used variable is poisoned
        if (cell.uses && [...cell.uses].some(n => poisoned.has(n))) {
          cell.el.classList.remove('fresh');
          cell.el.classList.add('stale');
        } else {
          renderHtmlCell(cell);
        }
      }
      continue;
    }
    if (cell.type !== 'code') continue;

    // skip norun cells (unless explicitly triggered)
    if (isNorun(cell.code) && !dirtyIds.includes(cell.id)) {
      if (cell._lastResult) {
        for (const [k, v] of Object.entries(cell._lastResult)) {
          if (v !== undefined) S.scope[k] = v;
        }
      }
      continue;
    }

    // skip manual cells unless force or explicitly triggered
    if (!force && isManual(cell.code) && !dirtyIds.includes(cell.id)) {
      if (cell._lastResult) {
        for (const [k, v] of Object.entries(cell._lastResult)) {
          if (v !== undefined) S.scope[k] = v;
        }
      }
      cell.el.classList.add('stale');
      continue;
    }

    // not in run set — restore cached results, skip execution
    if (!runSet.has(cell.id)) {
      if (cell._lastResult) {
        for (const [k, v] of Object.entries(cell._lastResult)) {
          if (v !== undefined) S.scope[k] = v;
        }
      }
      continue;
    }

    // error isolation: if any upstream dependency is poisoned, skip this cell
    if (cell.uses && cell.uses.size > 0) {
      let blocked = false;
      for (const name of cell.uses) {
        if (poisoned.has(name)) { blocked = true; break; }
      }
      if (blocked) {
        const outputEl = cell.el.querySelector('.cell-output');
        if (outputEl && !cell.error) {
          outputEl.textContent = 'blocked by upstream error';
          outputEl.className = 'cell-output error';
        }
        cell.el.classList.remove('stale', 'fresh');
        cell.el.classList.add('error');
        // poison our own defines so downstream also blocks
        if (cell.defines) for (const name of cell.defines) poisoned.add(name);
        continue;
      }
    }

    // value-equality gating: if this cell is a downstream dependent (not directly
    // dirty) and all its input values are unchanged, skip re-execution entirely
    if (!dirtyIds.includes(cell.id) && cell._lastResult && cell.uses && cell.uses.size > 0) {
      let inputsChanged = false;
      for (const name of cell.uses) {
        if (S.scope[name] !== cell._prevInputs?.[name]) { inputsChanged = true; break; }
      }
      if (!inputsChanged) {
        // inputs identical — restore previous results, skip execution
        for (const [k, v] of Object.entries(cell._lastResult)) {
          if (v !== undefined) S.scope[k] = v;
        }
        continue;
      }
    }

    if (window._beforeExec) window._beforeExec(cell);
    await execCell(cell);

    // if the cell errored, poison its defines
    if (cell.error) {
      if (cell.defines) for (const name of cell.defines) poisoned.add(name);
    }

    // snapshot input values for future equality checks
    if (cell.uses) {
      cell._prevInputs = {};
      for (const name of cell.uses) cell._prevInputs[name] = S.scope[name];
    }

    if (window._afterExec && !isAutorun) {
      const jump = window._afterExec(cell, i);
      if (jump >= 0) { i = jump - 1; continue; }
    }
  }

  updateStatus();

  // recheck workshop canAdvance gates after scope changes
  for (const c of S.cells) {
    if (c._workshopRecheck) c._workshopRecheck();
  }
}

async function runAll() {
  const ids = S.cells.filter(c => c.type === 'code' || c.type === 'html').map(c => c.id);
  if (ids.length === 0) return;
  await runDAG(ids, true);
  setMsg('ran all cells', 'ok');
}

// late import to avoid circular dependency at module load time

// -- markdown.js --

// ── MARKDOWN RENDERING (minimal) ──

function renderMd(src) {
  let html = src
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;');

  // headings
  html = html.replace(/^### (.+)$/gm, '<h3>$1</h3>');
  html = html.replace(/^## (.+)$/gm, '<h2>$1</h2>');
  html = html.replace(/^# (.+)$/gm, '<h1>$1</h1>');

  // bold/italic
  html = html.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
  html = html.replace(/\*(.+?)\*/g, '<em>$1</em>');

  // inline code
  html = html.replace(/`(.+?)`/g, '<code>$1</code>');

  // links
  html = html.replace(/\[(.+?)\]\((.+?)\)/g, '<a href="$2">$1</a>');

  // tables — detect pipe-delimited blocks before paragraph wrapping
  html = html.replace(
    /((?:^\|.+\|[ \t]*$\n?)+)/gm,
    (block) => {
      const rows = block.trim().split('\n').map(r =>
        r.trim().replace(/^\|/, '').replace(/\|$/, '').split('|').map(c => c.trim())
      );
      if (rows.length < 2) return block;
      // check for separator row (--- or :--- etc)
      const sep = rows[1];
      if (!sep.every(c => /^:?-{1,}:?$/.test(c))) return block;
      const hdr = rows[0];
      const body = rows.slice(2);
      let t = '<table><thead><tr>' +
        hdr.map(c => `<th>${c}</th>`).join('') +
        '</tr></thead><tbody>';
      for (const row of body) {
        t += '<tr>' + row.map(c => `<td>${c}</td>`).join('') + '</tr>';
      }
      t += '</tbody></table>';
      return t;
    }
  );

  // paragraphs
  html = html.replace(/\n\n/g, '</p><p>');
  if (!html.startsWith('<h') && !html.startsWith('<p') && !html.startsWith('<table')) html = '<p>' + html + '</p>';

  return html;
}

// -- cell-dom.js --

// ── CELL DOM ──

function cssSummary(code) {
  if (!code || !code.trim()) return '';
  const rules = (code.match(/[^{}]+\{/g) || []).length;
  const lines = code.split('\n').length;
  return `${rules} rule${rules !== 1 ? 's' : ''} \u00b7 ${lines} line${lines !== 1 ? 's' : ''}`;
}

function cellHeaderHTML(type, id) {
  return `<div class="cell-header">
    <span class="cell-type">${type}</span>
    <button class="cell-btn cell-convert" onclick="toggleTypePicker(${id})" title="convert type">\u21c4</button>
    <div class="cell-type-picker" data-cell-id="${id}">
      <button onclick="convertCell(${id},'code')">code</button>
      <button onclick="convertCell(${id},'md')">md</button>
      <button onclick="convertCell(${id},'css')">css</button>
      <button onclick="convertCell(${id},'html')">html</button>
    </div>
    <button class="cell-btn cell-insert" onclick="showInsertPicker(${id},'before')" title="insert above">+\u2191</button>
    <button class="cell-btn cell-insert" onclick="showInsertPicker(${id},'after')" title="insert below">+\u2193</button>
    <button class="cell-btn" onclick="moveCell(${id},-1)" title="move up">\u2191</button>
    <button class="cell-btn" onclick="moveCell(${id},1)" title="move down">\u2193</button>
    <button class="cell-btn del" onclick="deleteCellWithUndo(${id})" title="delete">\u00d7</button>
  </div>`;
}

function createCellEl(type, id) {
  const div = document.createElement('div');
  div.className = 'cell';
  div.dataset.id = id;
  div.dataset.type = type;

  if (type === 'code') {
    div.innerHTML = `
      ${cellHeaderHTML('code', id)}
      <div class="cell-code">
        <div class="editor-wrap">
          <div class="line-numbers" aria-hidden="true">1</div>
          <textarea rows="3" spellcheck="false" wrap="off" placeholder="// code"></textarea>
          <div class="highlight-layer" aria-hidden="true"></div>
        </div>
      </div>
      <div class="cell-widgets"></div>
      <div class="cell-output"></div>
    `;

    const ta = div.querySelector('textarea');
    const hl = div.querySelector('.highlight-layer');
    div.querySelector('.cell-type').addEventListener('click', () => div.classList.toggle('collapsed'));
    const ln = div.querySelector('.line-numbers');
    ta.addEventListener('input', () => { highlightCode(ta, hl); onCodeEdit(id); });
    ta.addEventListener('scroll', () => { hl.scrollTop = ta.scrollTop; hl.scrollLeft = ta.scrollLeft; ln.scrollTop = ta.scrollTop; });
    attachAutocomplete(ta, id);
    ta.addEventListener('keydown', handleTab);
    ta.addEventListener('input', autoResize);
  } else if (type === 'css') {
    div.innerHTML = `
      ${cellHeaderHTML('css', id)}
      <div class="cell-css-view"></div>
      <div class="cell-css-edit" style="display:none">
        <div class="editor-wrap">
          <div class="line-numbers" aria-hidden="true">1</div>
          <textarea rows="3" spellcheck="false" wrap="off" placeholder="/* css */"></textarea>
          <div class="highlight-layer" aria-hidden="true"></div>
        </div>
      </div>
    `;

    const cssView = div.querySelector('.cell-css-view');
    const cssEditWrap = div.querySelector('.cell-css-edit');
    const ta = div.querySelector('textarea');
    const hl = div.querySelector('.highlight-layer');
    div.querySelector('.cell-type').addEventListener('click', () => div.classList.toggle('collapsed'));

    cssView.addEventListener('click', () => {
      cssEditWrap.style.display = '';
      cssView.style.display = 'none';
      ta.focus();
      autoResize({ target: ta });
    });

    ta.addEventListener('blur', () => {
      if (S.findActive) return;
      const cell = S.cells.find(c => c.id === id);
      if (cell) {
        cell.code = ta.value;
        cssView.textContent = cssSummary(ta.value);
      }
      cssEditWrap.style.display = 'none';
      cssView.style.display = '';
    });

    const ln = div.querySelector('.line-numbers');
    ta.addEventListener('input', () => { highlightCss(ta, hl); onCssEdit(id); });
    ta.addEventListener('scroll', () => { hl.scrollTop = ta.scrollTop; hl.scrollLeft = ta.scrollLeft; ln.scrollTop = ta.scrollTop; });
    ta.addEventListener('input', autoResize);
    ta.addEventListener('keydown', handleTab);
  } else if (type === 'html') {
    div.innerHTML = `
      ${cellHeaderHTML('html', id)}
      <div class="cell-html-view"></div>
      <div class="cell-html-edit" style="display:none">
        <div class="editor-wrap">
          <div class="line-numbers" aria-hidden="true">1</div>
          <textarea rows="2" spellcheck="false" wrap="off" placeholder="<html template>"></textarea>
          <div class="highlight-layer" aria-hidden="true"></div>
        </div>
      </div>
      <div class="cell-output"></div>
    `;

    const view = div.querySelector('.cell-html-view');
    const editWrap = div.querySelector('.cell-html-edit');
    const ta = div.querySelector('.cell-html-edit textarea');
    const hl = div.querySelector('.highlight-layer');
    div.querySelector('.cell-type').addEventListener('click', () => div.classList.toggle('collapsed'));

    view.addEventListener('click', () => {
      editWrap.style.display = '';
      view.style.display = 'none';
      ta.focus();
      autoResize({ target: ta });
    });

    ta.addEventListener('blur', () => {
      if (S.findActive) return;
      const cell = S.cells.find(c => c.id === id);
      if (cell) {
        cell.code = ta.value;
        renderHtmlCell(cell);
      }
      editWrap.style.display = 'none';
      view.style.display = '';
    });

    const ln = div.querySelector('.line-numbers');
    ta.addEventListener('input', () => { highlightHtml(ta, hl); onHtmlEdit(id); });
    ta.addEventListener('scroll', () => { hl.scrollTop = ta.scrollTop; hl.scrollLeft = ta.scrollLeft; ln.scrollTop = ta.scrollTop; });
    ta.addEventListener('input', autoResize);
    ta.addEventListener('keydown', handleTab);
  } else {
    div.innerHTML = `
      ${cellHeaderHTML('md', id)}
      <div class="cell-md-view"></div>
      <div class="cell-md-edit" style="display:none">
        <textarea rows="2" spellcheck="false" placeholder="markdown"></textarea>
      </div>
    `;

    const view = div.querySelector('.cell-md-view');
    const editWrap = div.querySelector('.cell-md-edit');
    const ta = div.querySelector('.cell-md-edit textarea');
    div.querySelector('.cell-type').addEventListener('click', () => div.classList.toggle('collapsed'));

    view.addEventListener('click', () => {
      editWrap.style.display = '';
      view.style.display = 'none';
      ta.focus();
      autoResize({ target: ta });
    });

    ta.addEventListener('blur', () => {
      if (S.findActive) return;
      const cell = S.cells.find(c => c.id === id);
      if (cell) {
        cell.code = ta.value;
        view.innerHTML = renderMd(ta.value);
      }
      editWrap.style.display = 'none';
      view.style.display = '';
    });

    ta.addEventListener('input', autoResize);
    ta.addEventListener('keydown', handleTab);
  }

  return div;
}

// undoable text replacement — uses execCommand so the browser records it in the undo stack
function replaceRange(ta, from, to, text) {
  ta.focus();
  ta.selectionStart = from;
  ta.selectionEnd = to;
  document.execCommand('insertText', false, text);
}

function handleTab(e) {
  const ta = e.target;
  const start = ta.selectionStart;
  const end = ta.selectionEnd;

  if (e.key === 'Tab') {
    e.preventDefault();

    if (start === end) {
      // no selection — insert 2 spaces
      replaceRange(ta, start, end, '  ');
    } else {
      // selection — indent/unindent lines
      const val = ta.value;
      const lineStart = val.lastIndexOf('\n', start - 1) + 1;
      const lineEnd = val.indexOf('\n', end);
      const blockEnd = lineEnd === -1 ? val.length : lineEnd;
      const block = val.slice(lineStart, blockEnd);
      let newBlock;
      if (e.shiftKey) {
        newBlock = block.replace(/^  /gm, '');
      } else {
        newBlock = block.replace(/^/gm, '  ');
      }
      replaceRange(ta, lineStart, blockEnd, newBlock);
      ta.selectionStart = lineStart;
      ta.selectionEnd = lineStart + newBlock.length;
    }
    ta.dispatchEvent(new Event('input'));
    return;
  }

  // Enter — auto-indent
  if (e.key === 'Enter') {
    e.preventDefault();
    const val = ta.value;
    const before = val.slice(0, start);
    const after = val.slice(end);

    // find current line's leading whitespace
    const lineStart = before.lastIndexOf('\n') + 1;
    const line = before.slice(lineStart);
    const indent = line.match(/^(\s*)/)[1];

    // check if the character before cursor is an opener
    const charBefore = before.trimEnd().slice(-1);
    const extra = '{(['.includes(charBefore) ? '  ' : '';

    // check if the character after cursor is a matching closer
    const charAfter = after.trimStart()[0];
    const pairs = { '{': '}', '(': ')', '[': ']' };
    const needClose = extra && charAfter === pairs[charBefore];

    if (needClose) {
      // cursor between brackets: add indented line + closing line
      const insert = '\n' + indent + extra + '\n' + indent;
      replaceRange(ta, start, end, insert);
      ta.selectionStart = ta.selectionEnd = start + 1 + indent.length + extra.length;
    } else {
      const insert = '\n' + indent + extra;
      replaceRange(ta, start, end, insert);
    }
    ta.dispatchEvent(new Event('input'));
    return;
  }

  // Ctrl+X / Ctrl+C with no selection — whole-line cut/copy
  if ((e.key === 'x' || e.key === 'c') && (e.ctrlKey || e.metaKey) && !e.shiftKey && !e.altKey && start === end) {
    e.preventDefault();
    const val = ta.value;
    const lineStart = val.lastIndexOf('\n', start - 1) + 1;
    let lineEnd = val.indexOf('\n', start);
    if (lineEnd === -1) lineEnd = val.length;
    else lineEnd++; // include the newline

    const lineText = val.slice(lineStart, lineEnd);
    navigator.clipboard.writeText(lineText);

    if (e.key === 'x') {
      replaceRange(ta, lineStart, lineEnd, '');
      ta.dispatchEvent(new Event('input'));
    }
    return;
  }
}

function toggleComment(ta) {
  const val = ta.value;
  const start = ta.selectionStart;
  const end = ta.selectionEnd;

  // find affected line range
  const lineStart = val.lastIndexOf('\n', start - 1) + 1;
  let lineEnd = val.indexOf('\n', end);
  if (lineEnd === -1) lineEnd = val.length;

  const block = val.slice(lineStart, lineEnd);
  const lines = block.split('\n');

  // check if all lines are commented
  const allCommented = lines.every(l => /^\s*\/\//.test(l) || l.trim() === '');

  let newLines;
  if (allCommented) {
    // uncomment: remove first // (and one trailing space if present)
    newLines = lines.map(l => l.replace(/^(\s*)\/\/ ?/, '$1'));
  } else {
    // comment: add // at the minimum indent level
    const indents = lines.filter(l => l.trim()).map(l => l.match(/^(\s*)/)[1].length);
    const minIndent = indents.length ? Math.min(...indents) : 0;
    newLines = lines.map(l => {
      if (l.trim() === '') return l;
      return l.slice(0, minIndent) + '// ' + l.slice(minIndent);
    });
  }

  const newBlock = newLines.join('\n');
  replaceRange(ta, lineStart, lineEnd, newBlock);
  ta.selectionStart = lineStart;
  ta.selectionEnd = lineStart + newBlock.length;
  ta.dispatchEvent(new Event('input'));
}

function updateLineNumbers(ta) {
  const wrap = ta.closest('.editor-wrap');
  if (!wrap) return;
  const gutter = wrap.querySelector('.line-numbers');
  if (!gutter) return;
  const count = ta.value.split('\n').length;
  const lines = [];
  for (let i = 1; i <= count; i++) lines.push(i);
  gutter.textContent = lines.join('\n');
}

function autoResize(e) {
  const ta = e.target || e;
  ta.style.height = 'auto';
  ta.style.height = ta.scrollHeight + 'px';
  // sync highlight layer if present
  const hl = ta.parentElement && ta.parentElement.querySelector('.highlight-layer');
  if (hl) { hl.style.height = ta.style.height; }
  updateLineNumbers(ta);
}

// -- cell-ops.js --

// ── CELL OPERATIONS ──

function addCell(type, code = '', afterId = null, beforeId = null) {
  const id = S.cellId++;
  const cell = {
    id, type, code,
    defines: new Set(),
    uses: new Set(),
    error: null,
    el: createCellEl(type, id)
  };

  const nb = $('#notebook');
  if (beforeId !== null) {
    const idx = S.cells.findIndex(c => c.id === beforeId);
    if (idx >= 0) {
      S.cells.splice(idx, 0, cell);
      S.cells[idx + 1].el.before(cell.el);
    } else {
      S.cells.push(cell);
      nb.appendChild(cell.el);
    }
  } else if (afterId !== null) {
    const idx = S.cells.findIndex(c => c.id === afterId);
    if (idx >= 0) {
      S.cells.splice(idx + 1, 0, cell);
      if (idx < S.cells.length - 2) {
        S.cells[idx + 2].el.before(cell.el);
      } else {
        nb.appendChild(cell.el);
      }
    } else {
      S.cells.push(cell);
      nb.appendChild(cell.el);
    }
  } else {
    S.cells.push(cell);
    nb.appendChild(cell.el);
  }

  // set code
  const ta = cell.el.querySelector('textarea');
  if (code) {
    ta.value = code;
    autoResize({ target: ta });
    if (type === 'code') {
      const hl = cell.el.querySelector('.highlight-layer');
      if (hl) highlightCode(ta, hl);
      if (isManual(code)) cell.el.classList.add('manual');
    }
    if (type === 'md') {
      cell.el.querySelector('.cell-md-view').innerHTML = renderMd(code);
    }
  }

  // CSS cell: create <style> element in <head>
  if (type === 'css') {
    const hl = cell.el.querySelector('.highlight-layer');
    if (hl && code) highlightCss(ta, hl);
    const cssView = cell.el.querySelector('.cell-css-view');
    if (cssView && code) cssView.textContent = cssSummary(code);
    const styleEl = document.createElement('style');
    styleEl.dataset.cellId = id;
    styleEl.textContent = code;
    document.head.appendChild(styleEl);
    cell._styleEl = styleEl;
  }

  // HTML cell: render template
  if (type === 'html' && code) {
    renderHtmlCell(cell);
  }

  if (S.initialized) ta.focus();
  updateStatus();
  notifyDirty();
  return cell;
}

function deleteCell(id) {
  const idx = S.cells.findIndex(c => c.id === id);
  if (idx < 0) return;
  // fire invalidation so cell resources (timers, etc.) clean up
  if (S.cells[idx]._invalidate) { S.cells[idx]._invalidate(); S.cells[idx]._invalidate = null; }
  // tear down workshop DOM if this cell had one
  if (S.cells[idx]._workshopCleanup) { S.cells[idx]._workshopCleanup(); S.cells[idx]._workshopCleanup = null; }
  if (S.cells[idx]._styleEl) {
    S.cells[idx]._styleEl.remove();
    S.cells[idx]._styleEl = null;
  }
  S.cells[idx].el.remove();
  S.cells.splice(idx, 1);
  // re-run to clean scope
  if (S.cells.some(c => c.type === 'code' || c.type === 'html')) runAll();
  updateStatus();
  notifyDirty();
}

function convertCell(id, newType) {
  const cell = S.cells.find(c => c.id === id);
  if (!cell || cell.type === newType) return;

  const code = cell.code;

  // cleanup old type
  if (cell._styleEl) {
    cell._styleEl.remove();
    cell._styleEl = null;
  }

  // create new cell element
  const newEl = createCellEl(newType, id);
  cell.el.replaceWith(newEl);
  cell.el = newEl;
  cell.type = newType;

  // set code
  const ta = newEl.querySelector('textarea');
  ta.value = code;
  cell.code = code;
  autoResize({ target: ta });

  if (newType === 'code') {
    const hl = newEl.querySelector('.highlight-layer');
    if (hl) highlightCode(ta, hl);
  }
  if (newType === 'md') {
    newEl.querySelector('.cell-md-view').innerHTML = renderMd(code);
  }
  if (newType === 'css') {
    const hl = newEl.querySelector('.highlight-layer');
    if (hl) highlightCss(ta, hl);
    const cssView = newEl.querySelector('.cell-css-view');
    if (cssView && code) cssView.textContent = cssSummary(code);
    const styleEl = document.createElement('style');
    styleEl.dataset.cellId = id;
    styleEl.textContent = code;
    document.head.appendChild(styleEl);
    cell._styleEl = styleEl;
  }
  if (newType === 'html') {
    renderHtmlCell(cell);
  }

  selectCell(id);
  updateStatus();
  notifyDirty();
  if (S.cells.some(c => c.type === 'code' || c.type === 'html')) runAll();
}

function moveCell(id, dir) {
  const idx = S.cells.findIndex(c => c.id === id);
  const newIdx = idx + dir;
  if (newIdx < 0 || newIdx >= S.cells.length) return;

  const [cell] = S.cells.splice(idx, 1);
  S.cells.splice(newIdx, 0, cell);

  // re-order DOM
  const nb = $('#notebook');
  nb.innerHTML = '';
  for (const c of S.cells) nb.appendChild(c.el);

  // re-order CSS <style> elements in <head> to match cell order
  for (const c of S.cells) {
    if (c._styleEl) document.head.appendChild(c._styleEl);
  }

  notifyDirty();
  if (S.cells.some(c => c.type === 'code' || c.type === 'html')) runAll();
}

// -- editor.js --

// ── EDITING ──

function notifyDirty() {
  if (S.initialized && window.__AF_BRIDGE__) window.parent.postMessage({ type: 'af:dirty' }, '*');
}

function toggleAutorun() {
  S.autorun = !S.autorun;
  const btn = $('#autorunBtn');
  const btnMobile = document.getElementById('autorunBtnMobile');
  const cls = S.autorun ? 'autorun-on' : 'autorun-off';
  const text = S.autorun ? '\u25b6' : '\u2016';
  btn.textContent = text;
  btn.title = S.autorun ? 'reactive mode \u2014 cells auto-run on edit' : 'manual mode \u2014 only Run All or Ctrl+Enter';
  btn.className = cls;
  if (btnMobile) {
    btnMobile.textContent = text;
    btnMobile.className = cls;
  }
  const sel = $('#setExecMode');
  if (sel) sel.value = S.autorun ? 'reactive' : 'manual';
  setMsg(S.autorun ? 'autorun on' : 'autorun off', 'ok');
}

function onCssEdit(id) {
  const cell = S.cells.find(c => c.id === id);
  if (!cell) return;
  cell.code = cell.el.querySelector('textarea').value;
  if (cell._styleEl) cell._styleEl.textContent = cell.code;
  notifyDirty();
}

function onHtmlEdit(id) {
  const cell = S.cells.find(c => c.id === id);
  if (!cell) return;
  cell.code = cell.el.querySelector('textarea').value;
  cell.el.classList.add('stale');
  notifyDirty();

  if (S.autorun) {
    clearTimeout(S.editTimer);
    S.editTimer = setTimeout(() => runDAG([id], false), 400);
  }
}

function onCodeEdit(id) {
  const cell = S.cells.find(c => c.id === id);
  if (!cell) return;
  const ta = cell.el.querySelector('textarea');
  cell.code = ta.value;

  // update manual state
  if (isManual(cell.code)) {
    cell.el.classList.add('manual');
  } else {
    cell.el.classList.remove('manual');
  }

  cell.el.classList.add('stale');
  notifyDirty();

  if (S.autorun) {
    clearTimeout(S.editTimer);
    S.editTimer = setTimeout(() => runDAG([id], false), 400);
  }
}

// -- settings.js --

// ── SETTINGS ──

// Safe localStorage access — blob URL iframes have opaque origins where localStorage throws
function lsGet(key) { try { return localStorage.getItem(key); } catch { return null; } }
function lsSet(key, val) { try { localStorage.setItem(key, val); } catch {} }
function lsRemove(key) { try { localStorage.removeItem(key); } catch {} }

function toggleSettings() {
  const overlay = $('#settingsOverlay');
  const panel = $('#settingsPanel');
  const open = !overlay.classList.contains('visible');
  overlay.classList.toggle('visible');
  panel.style.display = open ? 'block' : 'none';
  if (open) refreshModuleList();
}

function applyTheme(theme) {
  if (theme === 'light') {
    document.documentElement.classList.add('light');
  } else {
    document.documentElement.classList.remove('light');
  }
  $('#setTheme').value = theme;
}

function applyFontSize(size) {
  size = parseInt(size);
  document.documentElement.style.setProperty('--editor-font-size', size + 'px');
  $('#setFontSize').value = size;
  $('#setFontSizeVal').textContent = size;
}

function applyWidth(w) {
  const nb = $('#notebook');
  nb.style.maxWidth = w;
  $('#setWidth').value = w;
}

function applyLineNumbers(show) {
  const on = show === true || show === 'true' || show === 'on';
  document.documentElement.classList.toggle('hide-line-numbers', !on);
  const el = $('#setLineNumbers');
  if (el) el.value = on ? 'on' : 'off';
}

function applyHeader(mode) {
  const root = document.documentElement;
  root.classList.remove('header-always', 'header-hover', 'header-compact');
  if (mode === 'always') root.classList.add('header-always');
  else if (mode === 'hover') root.classList.add('header-hover');
  else if (mode === 'compact') root.classList.add('header-compact');
  // 'auto' = no class, CSS media queries handle it
  $('#setHeader').value = mode;
}

// ── EXECUTION MODE ──

const __AUDITABLE_DEFAULT_EXEC_MODE__ = 'reactive';
const __AUDITABLE_DEFAULT_RUN_ON_LOAD__ = 'yes';

let _runOnLoad = 'yes';
let _showToggle = 'yes';

function applyExecMode(mode) {
  S.autorun = (mode === 'reactive');
  const btn = $('#autorunBtn');
  const btnMobile = document.getElementById('autorunBtnMobile');
  const cls = S.autorun ? 'autorun-on' : 'autorun-off';
  const text = S.autorun ? '\u25b6' : '\u2016';
  if (btn) { btn.textContent = text; btn.className = cls; btn.title = S.autorun ? 'reactive mode \u2014 cells auto-run on edit' : 'manual mode \u2014 only Run All or Ctrl+Enter'; }
  if (btnMobile) { btnMobile.textContent = text; btnMobile.className = cls; }
  const sel = $('#setExecMode');
  if (sel) sel.value = mode;
}

function applyRunOnLoad(val) {
  _runOnLoad = val;
  const sel = $('#setRunOnLoad');
  if (sel) sel.value = val;
}

function applyShowToggle(val) {
  _showToggle = val;
  document.documentElement.classList.toggle('hide-run-toggle', val === 'no');
  const sel = $('#setShowToggle');
  if (sel) sel.value = val;
}

function applyGlobalExecMode(val) {
  if (val) lsSet('auditable-exec-mode', val);
  else lsRemove('auditable-exec-mode');
}

function applyGlobalRunOnLoad(val) {
  if (val) lsSet('auditable-run-on-load', val);
  else lsRemove('auditable-run-on-load');
}

function resolveExecMode() {
  return lsGet('auditable-exec-mode')
    || $('#setExecMode')?.value
    || __AUDITABLE_DEFAULT_EXEC_MODE__;
}

function resolveRunOnLoad() {
  return lsGet('auditable-run-on-load')
    || _runOnLoad
    || __AUDITABLE_DEFAULT_RUN_ON_LOAD__;
}

function getSettings() {
  const s = {
    theme: document.documentElement.classList.contains('light') ? 'light' : 'dark',
    fontSize: parseInt($('#setFontSize').value),
    width: $('#setWidth').value,
    header: $('#setHeader').value,
    lineNumbers: document.documentElement.classList.contains('hide-line-numbers') ? 'off' : 'on',
    execMode: S.autorun ? 'reactive' : 'manual',
    runOnLoad: _runOnLoad,
    showToggle: _showToggle,
  };
  if (window._sizeCompare) s.sizeCompare = true;
  if (window._sizeCompareRef === 'content') s.sizeCompareRef = 'content';
  return s;
}

function applySettings(s) {
  if (!s) return;
  if (s.theme) applyTheme(s.theme);
  if (s.fontSize) applyFontSize(s.fontSize);
  if (s.width) applyWidth(s.width);
  if (s.header) applyHeader(s.header);
  if (s.lineNumbers) applyLineNumbers(s.lineNumbers);
  if (s.execMode) applyExecMode(s.execMode);
  if (s.runOnLoad) applyRunOnLoad(s.runOnLoad);
  if (s.showToggle) applyShowToggle(s.showToggle);
  // optional: size-compare.js (typeof guards for --lean builds without it)
  if (s.sizeCompare !== undefined && typeof applySizeCompare === 'function') applySizeCompare(s.sizeCompare);
  if (s.sizeCompareRef !== undefined && typeof applySizeCompareRef === 'function') applySizeCompareRef(s.sizeCompareRef);
}

function togglePresent() {
  document.body.classList.toggle('presenting');
}

// ── ABOUT ──

const __AUDITABLE_VERSION__ = '0.3.0';
const __AUDITABLE_RELEASE__ = 'dev';
const __AUDITABLE_BUILD_DATE__ = '2026-02-26';
const __AUDITABLE_BASE_SIZE__ = 254544;

(function() {
  const ver = $('#aboutVersion');
  const build = $('#aboutBuild');
  const rt = $('#aboutRuntime');
  if (ver) ver.textContent = 'auditable v' + __AUDITABLE_VERSION__;
  if (build) build.textContent = (__AUDITABLE_RELEASE__ !== 'dev' ? __AUDITABLE_RELEASE__ + ' \u00b7 ' : '') + 'built ' + __AUDITABLE_BUILD_DATE__;
  if (rt && __AUDITABLE_BASE_SIZE__ > 0) rt.textContent = 'runtime ' + (__AUDITABLE_BASE_SIZE__ / 1024).toFixed(1) + ' KB';
})();

// ── EXECUTION SETTINGS INIT ──

(function() {
  const gm = lsGet('auditable-exec-mode') || '';
  const gr = lsGet('auditable-run-on-load') || '';
  const selGm = $('#setGlobalExecMode');
  const selGr = $('#setGlobalRunOnLoad');
  if (selGm) selGm.value = gm;
  if (selGr) selGr.value = gr;
})();

// ── MODULE MANAGEMENT ──

function formatSize(bytes) {
  return (bytes / 1024).toFixed(1) + ' KB';
}

function renderEntryRow(url, entry) {
  const src = typeof entry === 'string' ? entry : entry.source;
  const cellId = typeof entry === 'string' ? null : entry.cellId;
  const isBinary = typeof entry === 'object' && entry.binary;
  const size = src ? src.length : 0;
  const displaySize = isBinary ? Math.floor(size * 3 / 4) : size;

  const row = document.createElement('div');
  row.className = 'module-row';

  const urlSpan = document.createElement('span');
  urlSpan.className = 'module-url';
  urlSpan.textContent = url;
  urlSpan.title = url;
  row.appendChild(urlSpan);

  const info = document.createElement('span');
  info.className = 'module-info';
  info.textContent = (cellId != null ? 'cell ' + cellId + '  ' : '')
    + (isBinary && entry.compressed ? 'gzipped  ' : '')
    + formatSize(displaySize);
  row.appendChild(info);

  const btn = document.createElement('button');
  btn.className = 'module-remove';
  btn.textContent = '\u00d7';
  btn.title = isBinary ? 'remove binary' : 'remove module';
  btn.onclick = () => removeModule(url);
  row.appendChild(btn);

  return { row, size };
}

function renderSection(list, urls, mods, emptyText) {
  list.innerHTML = '';
  if (urls.length === 0) {
    const empty = document.createElement('div');
    empty.className = 'module-empty';
    empty.textContent = emptyText;
    list.appendChild(empty);
    return 0;
  }
  let totalSize = 0;
  for (const url of urls) {
    const { row, size } = renderEntryRow(url, mods[url]);
    list.appendChild(row);
    totalSize += size;
  }
  const total = document.createElement('div');
  total.className = 'module-total';
  total.textContent = 'total  ' + formatSize(totalSize);
  list.appendChild(total);
  return totalSize;
}

function refreshModuleList() {
  const modList = $('#moduleList');
  const binList = $('#binaryList');
  if (!modList) return;

  const mods = window._installedModules || {};
  const modUrls = [];
  const binUrls = [];
  for (const url of Object.keys(mods)) {
    const entry = mods[url];
    if (typeof entry === 'object' && entry.binary) binUrls.push(url);
    else modUrls.push(url);
  }

  renderSection(modList, modUrls, mods, 'no modules installed');
  if (binList) renderSection(binList, binUrls, mods, 'no binaries installed');
}

function removeModule(url) {
  const entry = window._installedModules?.[url];
  const cellId = entry && typeof entry === 'object' ? entry.cellId : null;
  const kind = entry?.binary ? 'binary' : 'module';
  if (window._installedModules) delete window._installedModules[url];
  if (window._importCache) delete window._importCache[url];
  refreshModuleList();
  updateStatus();
  if (cellId != null) {
    setMsg(`removed ${kind} \u2014 cell ${cellId} will re-install it on next run`, 'warn');
  }
}

// -- update.js --

// ── UPDATE PANEL ──

function toggleUpdate() {
  const overlay = $('#updateOverlay');
  const panel = $('#updatePanel');
  const open = !overlay.classList.contains('visible');
  overlay.classList.toggle('visible');
  panel.style.display = open ? 'block' : 'none';
}

// ── SELF-UPDATE SYSTEM ──

const __AUDITABLE_PUBLIC_KEY__ = '';
const __AUDITABLE_REPO__ = 'endarthur/auditable';
const __AUDITABLE_PAGES_URL__ = 'https://endarthur.github.io/auditable';

// ── SIGNATURE EXTRACTION ──

function extractSignature(html) {
  const m = html.match(/<!--AUDITABLE-SIGNATURE\n([\s\S]*?)\nAUDITABLE-SIGNATURE-->/);
  if (!m) return null;
  try { return JSON.parse(m[1]); } catch { return null; }
}

// ── RUNTIME EXTRACTION ──

function extractRuntime(html) {
  const style = html.match(/<style>([\s\S]*?)<\/style>/);
  const script = html.match(/<script>([\s\S]*?)<\/script>/);
  if (!style || !script) return null;
  return { style: style[1], script: script[1] };
}

// ── DATA EXTRACTION ──

function extractData(html) {
  const data = html.match(/<!--AUDITABLE-DATA\n([\s\S]*?)\nAUDITABLE-DATA-->/);
  const settings = html.match(/<!--AUDITABLE-SETTINGS\n([\s\S]*?)\nAUDITABLE-SETTINGS-->/);
  const modules = html.match(/<!--AUDITABLE-MODULES\n([\s\S]*?)\nAUDITABLE-MODULES-->/);
  const title = html.match(/<title>([^<]*)<\/title>/);
  return {
    data: data ? data[0] : null,
    settings: settings ? settings[0] : null,
    modules: modules ? modules[0] : null,
    title: title ? title[1].replace(/^Auditable\s*\u2014\s*/, '') : 'untitled',
  };
}

// ── SIGNED CONTENT CONSTRUCTION ──

function buildSignedContent(style, script) {
  return 'AUDITABLE-SIGNED-CONTENT\n'
    + style + '\n'
    + 'AUDITABLE-STYLE-SCRIPT-BOUNDARY\n'
    + script;
}

// ── SIGNATURE VERIFICATION (Web Crypto) ──

async function verifySignature(html) {
  const sig = extractSignature(html);
  if (!sig) return { status: 'unsigned' };

  const pubKeyB64 = __AUDITABLE_PUBLIC_KEY__;
  if (!pubKeyB64) return { status: 'no-key', sig };

  // Check if the signature's public key matches ours
  if (sig.pub !== pubKeyB64) return { status: 'wrong-key', sig };

  const runtime = extractRuntime(html);
  if (!runtime) return { status: 'error', message: 'could not extract runtime' };

  const content = buildSignedContent(runtime.style, runtime.script);

  try {
    const pubBytes = Uint8Array.from(atob(pubKeyB64), c => c.charCodeAt(0));
    const key = await crypto.subtle.importKey(
      'raw', pubBytes, { name: 'Ed25519' }, false, ['verify']
    );
    const sigBytes = Uint8Array.from(atob(sig.sig), c => c.charCodeAt(0));
    const msgBytes = new TextEncoder().encode(content);
    const valid = await crypto.subtle.verify('Ed25519', key, sigBytes, msgBytes);
    return { status: valid ? 'valid' : 'invalid', sig };
  } catch (e) {
    if (e.name === 'NotSupportedError') {
      return { status: 'unsupported', message: 'browser does not support Ed25519 verification' };
    }
    return { status: 'error', message: e.message };
  }
}

// ── REASSEMBLE ──

function reassemble(newHtml, oldData) {
  let html = newHtml;

  // Remove any existing data/settings/modules comments (and their description comments) from the new template
  html = html.replace(/(?:<!-- [^\n]*-->\n)?<!--AUDITABLE-DATA\n[\s\S]*?\nAUDITABLE-DATA-->\n?/g, '');
  html = html.replace(/(?:<!-- [^\n]*-->\n)?<!--AUDITABLE-SETTINGS\n[\s\S]*?\nAUDITABLE-SETTINGS-->\n?/g, '');
  html = html.replace(/(?:<!-- [^\n]*-->\n)?<!--AUDITABLE-MODULES\n[\s\S]*?\nAUDITABLE-MODULES-->\n?/g, '');

  // Build data block to inject
  const parts = [];
  if (oldData.data) parts.push(oldData.data);
  if (oldData.modules) parts.push(oldData.modules);
  if (oldData.settings) parts.push(oldData.settings);
  const dataBlock = parts.length ? '\n' + parts.join('\n') + '\n' : '';

  // Inject before the signature comment or before <script>
  const sigIdx = html.indexOf('<!--AUDITABLE-SIGNATURE');
  const scriptIdx = html.indexOf('<script>');
  const insertIdx = sigIdx >= 0 ? sigIdx : scriptIdx;
  if (insertIdx >= 0) {
    html = html.slice(0, insertIdx) + dataBlock + html.slice(insertIdx);
  }

  // Update title
  if (oldData.title && oldData.title !== 'untitled') {
    html = html.replace(/<title>[^<]*<\/title>/, '<title>Auditable \u2014 ' + escHtml(oldData.title) + '</title>');
    // Also update the docTitle input value
    html = html.replace(/(<input[^>]*id="docTitle"[^>]*value=")[^"]*"/, '$1' + escHtml(oldData.title) + '"');
  }

  return html;
}

function escHtml(s) {
  return s.replace(/&/g, '&amp;').replace(/"/g, '&quot;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
}

// ── VERSION COMPARISON ──

function compareVersions(a, b) {
  // compare semver strings like "0.1.0" vs "0.2.0"
  const pa = a.replace(/^v/, '').split('.').map(Number);
  const pb = b.replace(/^v/, '').split('.').map(Number);
  for (let i = 0; i < Math.max(pa.length, pb.length); i++) {
    const na = pa[i] || 0, nb = pb[i] || 0;
    if (na < nb) return -1;
    if (na > nb) return 1;
  }
  return 0;
}

// ── TOOLBAR BADGES ──

function setBadge(id, label, cls) {
  const container = $('#toolbarBadges');
  if (!container) return;
  let el = container.querySelector('[data-badge="' + id + '"]');
  if (!label) {
    if (el) el.remove();
    return;
  }
  if (!el) {
    el = document.createElement('span');
    el.className = 'toolbar-badge toolbar-badge-' + id;
    el.setAttribute('data-badge', id);
    container.appendChild(el);
  }
  el.textContent = label;
  if (cls) el.className = 'toolbar-badge ' + cls;
}

// ── UPDATE STATUS UI ──

function setUpdateStatus(html, cls) {
  const el = $('#updateStatus');
  if (el) {
    el.innerHTML = html;
    el.className = 'update-status' + (cls ? ' update-' + cls : '');
  }
}

// ── CHECK FOR UPDATE (GitHub API) ──

async function checkForUpdate() {
  const btn = $('#updateCheckBtn');
  if (btn) btn.disabled = true;
  setUpdateStatus('checking...', '');

  try {
    // Fetch version.json from GitHub Pages (CORS-friendly)
    const vResp = await fetch(__AUDITABLE_PAGES_URL__ + '/version.json');
    if (!vResp.ok) throw new Error('version check failed: ' + vResp.status);
    const vData = await vResp.json();
    const remoteVersion = vData.version || '';
    const currentRelease = $('#updateRelease')?.textContent || 'dev';

    if (currentRelease === 'dev') {
      // Dev builds always offer the latest release
    } else if (compareVersions(currentRelease, remoteVersion) >= 0) {
      setUpdateStatus('up to date (' + currentRelease + ')', 'ok');
      if (btn) btn.disabled = false;
      return;
    }

    const notes = vData.notes || '';
    const notesHtml = notes
      ? '<div class="update-notes">' + renderMd(notes) + '</div>'
      : '';

    setUpdateStatus(
      '<strong>' + remoteVersion + '</strong> available'
      + notesHtml
      + '<button id="updateApplyBtn" onclick="applyOnlineUpdate()">update</button>',
      'available'
    );

    window._updateVersion = remoteVersion;
  } catch (e) {
    setUpdateStatus('error: ' + escHtml(e.message), 'err');
  }
  if (btn) btn.disabled = false;
}

// ── APPLY ONLINE UPDATE ──

async function applyOnlineUpdate() {
  setUpdateStatus('downloading...', '');

  try {
    // Download signed build from GitHub Pages (CORS-friendly)
    const resp = await fetch(__AUDITABLE_PAGES_URL__ + '/auditable.html');
    if (!resp.ok) throw new Error('download failed: ' + resp.status);
    const newHtml = await resp.text();
    await applyUpdate(newHtml, window._updateVersion);
  } catch (e) {
    setUpdateStatus('error: ' + escHtml(e.message), 'err');
  }
}

// ── APPLY UPDATE (verify + reassemble + download) ──

async function applyUpdate(newHtml, version) {
  setUpdateStatus('verifying signature...', '');

  const result = await verifySignature(newHtml);

  if (result.status === 'invalid') {
    setUpdateStatus('signature verification FAILED \u2014 update rejected', 'err');
    return;
  }

  const warnMessages = {
    'unsigned': 'this file is not signed',
    'no-key': 'no public key configured \u2014 cannot verify signature',
    'wrong-key': 'signed with an unknown key',
  };
  if (warnMessages[result.status]) {
    setUpdateStatus(
      'warning: ' + warnMessages[result.status]
      + '<div class="update-confirm">'
      + '<button onclick="proceedUpdate()">proceed anyway</button>'
      + '<button onclick="cancelUpdate()">cancel</button>'
      + '</div>',
      'warn'
    );
    window._pendingUpdateHtml = newHtml;
    window._pendingUpdateVersion = version;
    return;
  }

  if (result.status === 'unsupported') {
    setUpdateStatus(
      result.message
      + '<div class="update-confirm">'
      + '<button onclick="proceedUpdate()">proceed without verification</button>'
      + '<button onclick="cancelUpdate()">cancel</button>'
      + '</div>',
      'warn'
    );
    window._pendingUpdateHtml = newHtml;
    window._pendingUpdateVersion = version;
    return;
  }

  if (result.status === 'error') {
    setUpdateStatus('verification error: ' + escHtml(result.message), 'err');
    return;
  }

  // Valid signature — proceed
  finishUpdate(newHtml, version);
}

function proceedUpdate() {
  if (window._pendingUpdateHtml) {
    finishUpdate(window._pendingUpdateHtml, window._pendingUpdateVersion);
    delete window._pendingUpdateHtml;
    delete window._pendingUpdateVersion;
  }
}

function cancelUpdate() {
  delete window._pendingUpdateHtml;
  delete window._pendingUpdateVersion;
  setUpdateStatus('update cancelled', '');
}

function finishUpdate(newHtml, version) {
  setUpdateStatus('reassembling...', '');

  // Extract current document as HTML to get data comments
  const currentHtml = document.documentElement.outerHTML;
  // But the data comments are in the body innerHTML at load time; grab from live source
  const bodyHtml = document.body.innerHTML;
  const fullHtml = '<!DOCTYPE html>\n<html>' + document.head.outerHTML + '<body>' + bodyHtml + '</body></html>';

  const oldData = extractData(fullHtml);
  // Override title from live doc
  const titleInput = $('#docTitle');
  if (titleInput) oldData.title = titleInput.value || 'untitled';

  // Build fresh data comments from live state (more reliable than regex from DOM)
  if (S.cells.length) {
    const cellData = S.cells.map(c => ({
      type: c.type,
      code: c.code,
      collapsed: c.el?.classList.contains('collapsed') || undefined
    }));
    oldData.data = '<!-- cell data: JSON array of {type, code, collapsed?} -->\n<!--AUDITABLE-DATA\n' + JSON.stringify(cellData) + '\nAUDITABLE-DATA-->';
  }
  if (window._installedModules && Object.keys(window._installedModules).length) {
    oldData.modules = '<!-- installed modules: base64-encoded JSON mapping URLs to {source, cellId} -->\n<!--AUDITABLE-MODULES\n' + encodeModules(window._installedModules) + '\nAUDITABLE-MODULES-->';
  }
  oldData.settings = '<!-- notebook settings: JSON {theme, fontSize, width, ...} -->\n<!--AUDITABLE-SETTINGS\n' + JSON.stringify(getSettings()) + '\nAUDITABLE-SETTINGS-->';

  const result = reassemble(newHtml, oldData);

  // Offer as download
  const title = (titleInput ? titleInput.value : 'untitled') || 'untitled';
  const blob = new Blob([result], { type: 'text/html' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = title.replace(/[^a-zA-Z0-9_-]/g, '_') + '.html';
  a.click();
  URL.revokeObjectURL(url);

  const vLabel = version ? ' to ' + version : '';
  setUpdateStatus('updated' + vLabel + ' \u2014 saved as ' + a.download, 'ok');
  setMsg('updated' + vLabel, 'ok');
}

// ── UPDATE FROM FILE ──

function updateFromFile() {
  const input = document.createElement('input');
  input.type = 'file';
  input.accept = '.html';
  input.onchange = async () => {
    const file = input.files[0];
    if (!file) return;
    setUpdateStatus('reading file...', '');
    const text = await file.text();

    // Try to extract version from the file
    const vMatch = text.match(/__AUDITABLE_VERSION__\s*=\s*'([^']+)'/);
    const version = vMatch ? 'v' + vMatch[1] : null;

    await applyUpdate(text, version);
  };
  input.click();
}

// ── VERIFY CURRENT DOCUMENT ──

async function verifySelf() {
  const el = $('#updateSigStatus');
  if (!el) return;

  // Reconstruct from live DOM
  const styleEl = document.querySelector('style');
  const scriptEl = document.querySelector('script');
  if (!styleEl || !scriptEl) {
    el.textContent = 'error: no style/script';
    el.className = 'update-sig update-err';
    return;
  }

  const raw = document.body.innerHTML;
  const sigMatch = raw.match(/<!--AUDITABLE-SIGNATURE\n([\s\S]*?)\nAUDITABLE-SIGNATURE-->/);
  if (!sigMatch) {
    el.textContent = 'unsigned';
    el.className = 'update-sig update-warn';
    return;
  }

  let sig;
  try { sig = JSON.parse(sigMatch[1]); } catch {
    el.textContent = 'invalid signature format';
    el.className = 'update-sig update-err';
    return;
  }

  const pubKeyB64 = __AUDITABLE_PUBLIC_KEY__;
  if (!pubKeyB64) {
    el.textContent = 'no public key configured';
    el.className = 'update-sig update-warn';
    return;
  }

  if (sig.pub !== pubKeyB64) {
    el.textContent = 'signed with unknown key';
    el.className = 'update-sig update-warn';
    return;
  }

  const content = buildSignedContent(styleEl.textContent, scriptEl.textContent);

  try {
    const pubBytes = Uint8Array.from(atob(pubKeyB64), c => c.charCodeAt(0));
    const key = await crypto.subtle.importKey(
      'raw', pubBytes, { name: 'Ed25519' }, false, ['verify']
    );
    const sigBytes = Uint8Array.from(atob(sig.sig), c => c.charCodeAt(0));
    const msgBytes = new TextEncoder().encode(content);
    const valid = await crypto.subtle.verify('Ed25519', key, sigBytes, msgBytes);
    if (valid) {
      el.textContent = 'signed \u2713';
      el.className = 'update-sig update-ok';
      setBadge('signed', 'signed', 'toolbar-badge toolbar-badge-signed');
    } else {
      el.textContent = 'signature invalid';
      el.className = 'update-sig update-err';
    }
  } catch (e) {
    if (e.name === 'NotSupportedError') {
      el.textContent = 'Ed25519 not supported';
      el.className = 'update-sig update-warn';
    } else {
      el.textContent = 'error: ' + e.message;
      el.className = 'update-sig update-err';
    }
  }
}

// ── INIT ──
(function() {
  const ver = $('#updateCurrentVer');
  if (ver) ver.textContent = 'v' + __AUDITABLE_VERSION__;
  const rel = $('#updateRelease');
  if (rel) {
    rel.textContent = __AUDITABLE_RELEASE__;
    if (__AUDITABLE_RELEASE__ === 'dev') rel.className = 'update-sig update-warn';
  }
  // Show public key status
  const keyEl = $('#updatePubKey');
  if (keyEl) {
    if (__AUDITABLE_PUBLIC_KEY__) {
      keyEl.textContent = __AUDITABLE_PUBLIC_KEY__.slice(0, 8) + '...';
      keyEl.className = 'update-sig update-key-truncated';
      keyEl.onclick = () => {
        if (keyEl.classList.contains('update-key-expanded')) {
          keyEl.textContent = __AUDITABLE_PUBLIC_KEY__.slice(0, 8) + '...';
          keyEl.classList.remove('update-key-expanded');
          keyEl.classList.add('update-key-truncated');
        } else {
          keyEl.textContent = __AUDITABLE_PUBLIC_KEY__;
          keyEl.classList.remove('update-key-truncated');
          keyEl.classList.add('update-key-expanded');
        }
      };
    } else {
      keyEl.textContent = 'not configured';
      keyEl.className = 'update-sig update-warn';
    }
  }
  // Run self-verification on load
  verifySelf();
})();

// -- save.js --

// ── MODULES ENCODING ──
// base64-encode modules JSON to avoid HTML comment / String.replace issues
// (source code can contain --, $', etc.)

function encodeModules(obj) {
  const b64 = btoa(unescape(encodeURIComponent(JSON.stringify(obj))));
  return b64.replace(/.{1,76}/g, '$&\n').trimEnd();
}

function decodeModules(raw) {
  const b64 = raw.replace(/\s/g, '');
  // detect legacy format: starts with { means raw JSON (not base64)
  if (b64.startsWith('{') || b64.startsWith('%7B')) return JSON.parse(raw);
  return JSON.parse(decodeURIComponent(escape(atob(b64))));
}

// ── SAVE / LOAD ──

// save mode: 'normal' or 'packed'
let _saveMode = 'normal';

function getSaveMode() { return _saveMode; }

function toggleSaveTray() {
  const tray = $('#saveTray');
  if (tray) tray.classList.toggle('open');
}

function setSaveMode(mode) {
  _saveMode = mode;
  // update UI
  const label = $('#saveLabel');
  if (label) label.textContent = mode === 'packed' ? 'pack' : 'save';
  const tray = $('#saveTray');
  if (tray) tray.classList.remove('open');
  // update mobile buttons
  const mobSave = $('#mobileSaveBtn');
  const mobPack = $('#mobilePackBtn');
  if (mobSave) mobSave.classList.toggle('active-mode', mode === 'normal');
  if (mobPack) mobPack.classList.toggle('active-mode', mode === 'packed');
}

function buildNotebookHtml() {
  // serialize current state back to a self-contained HTML file
  const title = $('#docTitle').value || 'untitled';

  // collect cells as data
  const cellData = S.cells.map(c => ({
    type: c.type,
    code: c.code,
    collapsed: c.el.classList.contains('collapsed') || undefined
  }));

  // get the runtime and styles from current document
  const styleEl = document.querySelector('style');
  const styles = styleEl.textContent;

  // get the script
  const scriptEl = document.querySelector('script');
  const script = scriptEl.textContent;

  // read static elements from live DOM
  const helpHTML = $('#helpOverlay').outerHTML;
  const settingsOvHTML = $('#settingsOverlay').outerHTML;
  const settingsPanHTML = $('#settingsPanel').outerHTML.replace(/display:\s*block;?/, '');
  const updateOvHTML = $('#updateOverlay').outerHTML.replace(/\bvisible\b/, '').replace(/class="\s*"/, 'class=""');
  const updatePanEl = $('#updatePanel').cloneNode(true);
  updatePanEl.style.display = '';
  // reset update status and dynamic text
  const uStatus = updatePanEl.querySelector('#updateStatus');
  if (uStatus) { uStatus.innerHTML = ''; uStatus.className = 'update-status'; }
  const updatePanHTML = updatePanEl.outerHTML.replace(/display:\s*block;?/, '');
  const statusbarHTML = document.querySelector('.statusbar').outerHTML;

  // read toolbar from live DOM and patch the title value
  const toolbarEl = document.querySelector('.toolbar').cloneNode(true);
  toolbarEl.querySelector('#docTitle').value = title;
  toolbarEl.querySelector('#toolbarStatus').textContent = '';
  // reset autorun button state to match saved mode
  const autoBtn = toolbarEl.querySelector('#autorunBtn');
  const savedMode = S.autorun ? 'reactive' : 'manual';
  if (autoBtn) {
    autoBtn.className = savedMode === 'reactive' ? 'autorun-on' : 'autorun-off';
    autoBtn.textContent = savedMode === 'reactive' ? '\u25b6' : '\u2016';
  }
  // close overflow and save tray if open
  const overflow = toolbarEl.querySelector('.toolbar-overflow');
  if (overflow) overflow.classList.remove('open');
  const saveTray = toolbarEl.querySelector('#saveTray');
  if (saveTray) saveTray.classList.remove('open');
  // reset save label to default
  const saveLabel = toolbarEl.querySelector('#saveLabel');
  if (saveLabel) saveLabel.textContent = 'save';
  // clear badges (they get set dynamically on load)
  const badges = toolbarEl.querySelector('.toolbar-badges');
  if (badges) badges.innerHTML = '';
  const toolbarHTML = toolbarEl.outerHTML;

  // capture find bar and reset to default state
  const findBarEl = $('#findBar').cloneNode(true);
  findBarEl.style.display = '';
  findBarEl.classList.remove('show-replace');
  findBarEl.querySelector('#findInput').value = '';
  findBarEl.querySelector('#replaceInput').value = '';
  findBarEl.querySelector('#findCount').textContent = '';
  findBarEl.querySelector('#findCaseBtn').classList.remove('active');
  findBarEl.querySelector('#findRegexBtn').classList.remove('active');
  const findBarHTML = findBarEl.outerHTML;

  // build output HTML
  return `<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Auditable \u2014 ${esc(title)}</title>
<style>\n${styles}\n</style>
</head>
<body>

${helpHTML}

${settingsOvHTML}
${settingsPanHTML}

${updateOvHTML}
${updatePanHTML}

${toolbarHTML}

${findBarHTML}

<button class="present-exit" onclick="togglePresent()">\u2715 exit</button>

<div class="notebook" id="notebook">
</div>

${statusbarHTML}

${'<!-- cell data: JSON array of {type, code, collapsed?} -->\n<!--AUDITABLE-DATA\n' + JSON.stringify(cellData) + '\nAUDITABLE-DATA-->'}
${Object.keys(window._installedModules || {}).length ? '<!-- installed modules: base64-encoded JSON mapping URLs to {source, cellId} -->\n<!--AUDITABLE-MODULES\n' + encodeModules(window._installedModules) + '\nAUDITABLE-MODULES-->' : ''}
${'<!-- notebook settings: JSON {theme, fontSize, width, ...} -->\n<!--AUDITABLE-SETTINGS\n' + JSON.stringify(getSettings()) + '\nAUDITABLE-SETTINGS-->'}

<script>\n${script}\n<\/script>
</body>
</html>`;
}

function downloadHtml(html, title) {
  const blob = new Blob([html], { type: 'text/html' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = title.replace(/[^a-zA-Z0-9_-]/g, '_') + '.html';
  a.click();
  URL.revokeObjectURL(url);
  return a.download;
}

function saveNotebook() {
  if (_saveMode === 'packed') {
    savePackedNotebook();
    return;
  }
  const title = $('#docTitle').value || 'untitled';
  const html = buildNotebookHtml();

  // AF bridge: send serialized HTML to parent shell instead of downloading
  if (window.__AF_BRIDGE__) {
    window.parent.postMessage({ type: 'af:serialized', payload: { html } }, '*');
    setMsg('saved', 'ok');
    return;
  }

  const fn = downloadHtml(html, title);
  setMsg('saved ' + fn, 'ok');
}

async function savePackedNotebook() {
  const title = $('#docTitle').value || 'untitled';
  const html = buildNotebookHtml();

  try {
    // compress via CompressionStream
    const blob = new Blob([html]);
    const cs = new CompressionStream('gzip');
    const stream = blob.stream().pipeThrough(cs);
    const compressed = await new Response(stream).arrayBuffer();
    const b64 = btoa(String.fromCharCode(...new Uint8Array(compressed)));
    const b64Lines = b64.replace(/.{1,76}/g, '$&\n');

    const loader = `<!DOCTYPE html>
<!-- packed auditable notebook -->
<!-- the full notebook is gzip-compressed and base64-encoded in the <pre> block below. -->
<!-- on load, the script decodes and decompresses it, then replaces the page contents. -->
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Auditable \u2014 ${esc(title)}</title>
  <style>
    html { background: #1a1a1a }
    body { color: #999; font: 14px/1.5 monospace; display: flex; justify-content: center; align-items: center; height: 100vh; margin: 0 }
    #_d { display: none }
  </style>
</head>
<body>
<div id="_l">unpacking\u2026</div>

<!-- base64-encoded gzip payload (76-char lines) -->
<pre id="_d">
${b64Lines}</pre>

<script>
(async () => {
  // 1. read base64 from the hidden <pre>, strip whitespace from line wrapping
  var b64 = document.getElementById('_d').textContent.replace(/\\s/g, '');

  // 2. decode base64 to binary
  var bytes = Uint8Array.from(atob(b64), c => c.charCodeAt(0));

  // 3. decompress gzip via DecompressionStream
  var stream = new Response(new Blob([bytes])).body.pipeThrough(new DecompressionStream('gzip'));
  var html = await new Response(stream).text();

  // 4. mark as packed (so the notebook knows it was loaded from a packed save)
  html = html.replace('<head>', '<head><meta name="auditable-packed">');

  // 5. replace the current page with the full notebook
  document.open();
  document.write(html);
  document.close();
})().catch(function(e) {
  document.getElementById('_l').textContent = 'error: ' + e.message;
});
<\/script>
</body>
</html>`;


    const fn = downloadHtml(loader, title);
    const kb = (loader.length / 1024).toFixed(0);
    setMsg('packed ' + fn + ' (' + kb + ' KB)', 'ok');
  } catch (e) {
    setMsg('pack failed: ' + e.message, 'err');
  }
}

function esc(s) {
  return s.replace(/"/g, '&quot;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
}

function exportAsTxt() {
  const title = $('#docTitle').value || 'untitled';
  const html = buildNotebookHtml();

  // extract notebook data from HTML
  const dataMatch = html.match(/<!--AUDITABLE-DATA\n([\s\S]*?)\nAUDITABLE-DATA-->/);
  let cells = [];
  if (dataMatch) {
    try { cells = JSON.parse(dataMatch[1]); } catch {}
  }

  const setMatch = html.match(/<!--AUDITABLE-SETTINGS\n([\s\S]*?)\nAUDITABLE-SETTINGS-->/);
  let settings = {};
  if (setMatch) {
    try { settings = JSON.parse(setMatch[1]); } catch {}
  }

  // extract module URLs (without sources — standalone export just records URLs)
  const modMatch = html.match(/<!--AUDITABLE-MODULES\n([\s\S]*?)\nAUDITABLE-MODULES-->/);
  let moduleUrls = [];
  if (modMatch) {
    try {
      const decoded = decodeModules(modMatch[1]);
      moduleUrls = Object.keys(decoded);
    } catch {}
  }

  // build /// formatted text
  const lines = ['/// auditable'];
  if (title && title !== 'untitled') {
    lines.push('/// title: ' + title);
  }
  const defaultSettings = { theme: 'dark', fontSize: 13, width: '860' };
  if (JSON.stringify(settings) !== JSON.stringify(defaultSettings)) {
    lines.push('/// settings: ' + JSON.stringify(settings));
  }
  for (const url of moduleUrls) {
    lines.push('/// module: ' + url);
  }
  for (const cell of cells) {
    lines.push('');
    const flags = cell.collapsed ? ' collapsed' : '';
    lines.push('/// ' + cell.type + flags);
    lines.push(cell.code || '');
  }
  const txt = lines.join('\n') + '\n';

  // download
  if (window.__AF_BRIDGE__) {
    window.parent.postMessage({ type: 'af:download', payload: { data: txt, filename: title.replace(/[^a-zA-Z0-9_-]/g, '_') + '.txt', mime: 'text/plain' } }, '*');
  } else {
    const blob = new Blob([txt], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = title.replace(/[^a-zA-Z0-9_-]/g, '_') + '.txt';
    a.click();
    URL.revokeObjectURL(url);
  }
  setMsg('exported .txt', 'ok');
}

function loadFromEmbed() {
  // look for embedded cell data in HTML comments
  const raw = document.body.innerHTML;

  // restore installed modules first (before cells run)
  const modMatch = raw.match(/<!--AUDITABLE-MODULES\n([\s\S]*?)\nAUDITABLE-MODULES-->/);
  if (modMatch) {
    try {
      window._installedModules = decodeModules(modMatch[1]);
    } catch (e) {
      console.error('Failed to parse installed modules:', e);
    }
  }

  // restore settings
  const setMatch = raw.match(/<!--AUDITABLE-SETTINGS\n([\s\S]*?)\nAUDITABLE-SETTINGS-->/);
  if (setMatch) {
    try {
      applySettings(JSON.parse(setMatch[1]));
    } catch (e) {
      console.error('Failed to parse settings:', e);
    }
  }

  // apply execution mode priority chain (localStorage > notebook > build default)
  const effectiveMode = resolveExecMode();
  const effectiveRun = resolveRunOnLoad();
  if (effectiveMode === 'manual') {
    S.autorun = false;
    const btn = document.getElementById('autorunBtn');
    const btnMobile = document.getElementById('autorunBtnMobile');
    if (btn) { btn.className = 'autorun-off'; btn.textContent = '\u2016'; btn.title = 'manual mode \u2014 only Run All or Ctrl+Enter'; }
    if (btnMobile) { btnMobile.className = 'autorun-off'; btnMobile.textContent = '\u2016'; }
    const sel = document.getElementById('setExecMode');
    if (sel) sel.value = 'manual';
  }

  const match = raw.match(/<!--AUDITABLE-DATA\n([\s\S]*?)\nAUDITABLE-DATA-->/);
  if (match) {
    try {
      const data = JSON.parse(match[1]);
      for (const c of data) {
        const cell = addCell(c.type, c.code);
        if (c.collapsed || isCollapsed(c.code)) cell.el.classList.add('collapsed');
      }
      // run after load (gated on resolved runOnLoad)
      if (effectiveRun === 'yes' && S.cells.some(c => c.type === 'code')) {
        setTimeout(runAll, 50);
      }
      return true;
    } catch (e) {
      console.error('Failed to parse embedded data:', e);
    }
  }
  return false;
}

// -- ui.js --

// ── STATUS ──

function estimateContentSize() {
  let modules = 0;
  for (const v of Object.values(window._installedModules || {})) {
    modules += typeof v === 'string' ? v.length : (v.source?.length || 0);
  }
  const cells = JSON.stringify(S.cells.map(c => ({ type: c.type, code: c.code }))).length;
  return modules + cells;
}

function estimateFileSize() {
  const style = document.querySelector('style')?.textContent.length || 0;
  const script = document.querySelector('script')?.textContent.length || 0;
  return style + script + estimateContentSize() + 2000; // ~2KB HTML boilerplate
}

function updateStatus() {
  const counts = { code: 0, md: 0, css: 0, html: 0 };
  for (const c of S.cells) if (counts[c.type] !== undefined) counts[c.type]++;
  const parts = [];
  for (const [t, n] of Object.entries(counts)) if (n > 0) parts.push(`${n} ${t}`);
  const statusText = parts.join(' \u00b7 ') || '0 cells';
  const totalBytes = estimateFileSize();
  const contentBytes = estimateContentSize();
  const useContent = window._sizeCompareRef === 'content';
  const displayBytes = useContent ? contentBytes : totalBytes;
  const sizeKB = displayBytes >= 1024 ? Math.round(displayBytes / 1024) : 1;
  const sizeText = '~' + sizeKB + ' KB' + (useContent ? ' content' : '');
  $('#statusCells').textContent = statusText;
  const compare = typeof sizeCompare === 'function' ? sizeCompare(displayBytes) : '';
  const sizeEl = document.getElementById('statusSize');
  if (sizeEl) sizeEl.textContent = (compare ? sizeText + ' \u00b7 ' + compare : sizeText) + ' \u00b7 ';
  // mirror to toolbar for mobile
  const toolbarStatus = document.getElementById('toolbarStatus');
  if (toolbarStatus) toolbarStatus.textContent = (compare || sizeText) + ' \u00b7 ' + statusText;
  updateInsertBars();
}

function updateInsertBars() {
  const nb = $('#notebook');
  // remove existing insert bars
  nb.querySelectorAll('.insert-bar').forEach(b => b.remove());

  // add one before first cell and between each pair
  for (let i = 0; i <= S.cells.length; i++) {
    const bar = document.createElement('div');
    bar.className = 'insert-bar';
    const afterId = i > 0 ? S.cells[i - 1].id : null;
    bar.innerHTML = `<div class="insert-btns">
      <button onclick="insertAt(${afterId},'code')">+ code</button>
      <button onclick="insertAt(${afterId},'md')">+ md</button>
      <button onclick="insertAt(${afterId},'css')">+ css</button>
      <button onclick="insertAt(${afterId},'html')">+ html</button>
    </div>`;
    if (i < S.cells.length) {
      S.cells[i].el.before(bar);
    } else {
      nb.appendChild(bar);
    }
  }
}

function insertAt(afterId, type) {
  let cell;
  if (afterId === null && S.cells.length > 0) {
    // insert before first cell
    cell = addCellWithUndo(type, '', null, S.cells[0].id);
  } else {
    cell = addCellWithUndo(type, '', afterId);
  }
  selectCell(cell.id);
  editCell(cell.id);
}

function setMsg(msg, cls = '') {
  const el = $('#statusMsg');
  el.textContent = msg;
  el.className = 'status-msg' + (cls ? ' ' + cls : '');
  if (cls) setTimeout(() => { el.textContent = ''; el.className = 'status-msg'; }, 3000);
}

// -- find.js --

// ── FIND / REPLACE ──

function openFind(showReplace) {
  const bar = $('#findBar');
  bar.style.display = 'flex';
  S.findActive = true;
  if (showReplace) bar.classList.add('show-replace');
  else bar.classList.remove('show-replace');
  const inp = $('#findInput');
  // pre-fill from textarea selection
  const active = document.activeElement;
  if (active && active.tagName === 'TEXTAREA') {
    const sel = active.value.substring(active.selectionStart, active.selectionEnd);
    if (sel && sel.indexOf('\n') === -1) inp.value = sel;
  }
  inp.focus();
  inp.select();
  if (inp.value) findComputeMatches();
}

function closeFind() {
  const bar = $('#findBar');
  bar.style.display = '';
  bar.classList.remove('show-replace');
  S.findActive = false;
  S.findQuery = '';
  S.findMatches = [];
  S.findCurrent = -1;
  $('#findCount').textContent = '';
  // remove all overlays
  document.querySelectorAll('.search-overlay').forEach(el => el.remove());
  document.querySelectorAll('.md-search-wrap').forEach(wrap => {
    const ta = wrap.querySelector('textarea');
    if (ta) wrap.parentNode.insertBefore(ta, wrap);
    wrap.remove();
  });
}

function escapeRegex(s) {
  return s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

function findComputeMatches() {
  const query = $('#findInput').value;
  S.findQuery = query;
  S.findMatches = [];
  if (!query) {
    S.findCurrent = -1;
    findUpdateCount();
    document.querySelectorAll('.search-overlay').forEach(el => el.remove());
    document.querySelectorAll('.md-search-wrap').forEach(wrap => {
      const ta = wrap.querySelector('textarea');
      if (ta) wrap.parentNode.insertBefore(ta, wrap);
      wrap.remove();
    });
    return;
  }
  const flags = S.findCase ? 'g' : 'gi';
  const pattern = S.findRegex ? query : escapeRegex(query);
  let re;
  try { re = new RegExp(pattern, flags); }
  catch (e) {
    S.findCurrent = -1;
    $('#findCount').textContent = 'bad regex';
    return;
  }

  for (const cell of S.cells) {
    let m;
    re.lastIndex = 0;
    while ((m = re.exec(cell.code)) !== null) {
      S.findMatches.push({ cellId: cell.id, index: m.index, length: m[0].length });
      if (m[0].length === 0) re.lastIndex++;  // prevent infinite loop on zero-length match
    }
  }
  // keep findCurrent in range
  if (S.findMatches.length === 0) S.findCurrent = -1;
  else if (S.findCurrent < 0 || S.findCurrent >= S.findMatches.length) S.findCurrent = 0;
  findUpdateOverlays();
  findUpdateCount();
}

function findNext() {
  if (!S.findMatches.length) return;
  S.findCurrent = (S.findCurrent + 1) % S.findMatches.length;
  findUpdateOverlays();
  findUpdateCount();
  findScrollToMatch();
}

function findPrev() {
  if (!S.findMatches.length) return;
  S.findCurrent = (S.findCurrent - 1 + S.findMatches.length) % S.findMatches.length;
  findUpdateOverlays();
  findUpdateCount();
  findScrollToMatch();
}

function findReplace() {
  if (S.findCurrent < 0 || S.findCurrent >= S.findMatches.length) return;
  const match = S.findMatches[S.findCurrent];
  const cell = S.cells.find(c => c.id === match.cellId);
  if (!cell) return;
  const replaceVal = $('#replaceInput').value;
  if (S.findRegex) {
    const flags = S.findCase ? '' : 'i';
    try {
      const re = new RegExp(S.findQuery, flags);
      const matched = cell.code.substring(match.index, match.index + match.length);
      const replaced = matched.replace(re, replaceVal);
      cell.code = cell.code.substring(0, match.index) + replaced + cell.code.substring(match.index + match.length);
    } catch (e) { return; }
  } else {
    cell.code = cell.code.substring(0, match.index) + replaceVal + cell.code.substring(match.index + match.length);
  }
  // update textarea
  const ta = cell.el.querySelector('textarea');
  if (ta) {
    ta.value = cell.code;
    ta.dispatchEvent(new Event('input'));
  }
  findComputeMatches();
}

function findReplaceAll() {
  const query = S.findQuery;
  if (!query) return;
  const replaceVal = $('#replaceInput').value;
  const flags = S.findCase ? 'g' : 'gi';
  const pattern = S.findRegex ? query : escapeRegex(query);
  let re;
  try { re = new RegExp(pattern, flags); }
  catch (e) { return; }
  let count = 0;
  for (const cell of S.cells) {
    const before = cell.code;
    if (S.findRegex) {
      cell.code = cell.code.replace(re, (...args) => { count++; return replaceVal.replace(/\$(\d+)/g, (_, n) => args[+n] != null ? args[+n] : ''); });
    } else {
      cell.code = cell.code.replace(re, () => { count++; return replaceVal; });
    }
    if (cell.code !== before) {
      const ta = cell.el.querySelector('textarea');
      if (ta) {
        ta.value = cell.code;
        ta.dispatchEvent(new Event('input'));
      }
    }
  }
  findComputeMatches();
}

function findUpdateOverlays() {
  // remove existing overlays
  document.querySelectorAll('.search-overlay').forEach(el => el.remove());
  // unwrap md-search-wraps
  document.querySelectorAll('.md-search-wrap').forEach(wrap => {
    const ta = wrap.querySelector('textarea');
    if (ta) wrap.parentNode.insertBefore(ta, wrap);
    wrap.remove();
  });

  if (!S.findQuery || !S.findMatches.length) return;

  // group matches by cellId
  const byCell = {};
  S.findMatches.forEach((m, i) => {
    if (!byCell[m.cellId]) byCell[m.cellId] = [];
    byCell[m.cellId].push({ ...m, globalIdx: i });
  });

  for (const cellId of Object.keys(byCell)) {
    const cell = S.cells.find(c => c.id === parseInt(cellId));
    if (!cell) continue;
    const matches = byCell[cellId];
    const code = cell.code;

    // build overlay content
    let html = '';
    let pos = 0;
    for (const m of matches) {
      // text before match
      html += escHtml(code.substring(pos, m.index));
      const cls = m.globalIdx === S.findCurrent ? 'search-match search-match-current' : 'search-match';
      html += `<mark class="${cls}">${escHtml(code.substring(m.index, m.index + m.length))}</mark>`;
      pos = m.index + m.length;
    }
    html += escHtml(code.substring(pos));

    const overlay = document.createElement('div');

    if (cell.type === 'md') {
      // markdown cells: wrap textarea in md-search-wrap
      overlay.className = 'search-overlay search-overlay-md';
      overlay.innerHTML = html;
      const editWrap = cell.el.querySelector('.cell-md-edit');
      const ta = editWrap.querySelector('textarea');
      let wrap = editWrap.querySelector('.md-search-wrap');
      if (!wrap) {
        wrap = document.createElement('div');
        wrap.className = 'md-search-wrap';
        ta.parentNode.insertBefore(wrap, ta);
        wrap.appendChild(ta);
      }
      wrap.appendChild(overlay);
      wireScrollSync(ta, overlay);
    } else {
      // code, css, html cells: insert in editor-wrap
      overlay.className = 'search-overlay';
      overlay.innerHTML = html;
      let editorWrap;
      if (cell.type === 'code') editorWrap = cell.el.querySelector('.cell-code .editor-wrap');
      else if (cell.type === 'css') editorWrap = cell.el.querySelector('.cell-css-edit .editor-wrap');
      else if (cell.type === 'html') editorWrap = cell.el.querySelector('.cell-html-edit .editor-wrap');
      if (editorWrap) {
        editorWrap.appendChild(overlay);
        const ta = editorWrap.querySelector('textarea');
        if (ta) wireScrollSync(ta, overlay);
      }
    }
  }
}

function wireScrollSync(ta, overlay) {
  if (ta._searchScrollWired) return;
  ta._searchScrollWired = true;
  ta.addEventListener('scroll', () => {
    const ov = ta.closest('.editor-wrap, .md-search-wrap');
    if (!ov) return;
    const so = ov.querySelector('.search-overlay');
    if (so) {
      so.scrollTop = ta.scrollTop;
      so.scrollLeft = ta.scrollLeft;
    }
  });
}

function findUpdateCount() {
  const el = $('#findCount');
  if (!S.findQuery) { el.textContent = ''; return; }
  if (S.findMatches.length === 0) { el.textContent = 'no results'; return; }
  el.textContent = `${S.findCurrent + 1}/${S.findMatches.length}`;
}

function findScrollToMatch() {
  if (S.findCurrent < 0) return;
  const match = S.findMatches[S.findCurrent];
  if (!match) return;
  const cell = S.cells.find(c => c.id === match.cellId);
  if (!cell) return;

  // open editor for non-code cells if needed
  if (cell.type === 'css') {
    const editWrap = cell.el.querySelector('.cell-css-edit');
    const view = cell.el.querySelector('.cell-css-view');
    if (editWrap.style.display === 'none') {
      const ta = editWrap.querySelector('textarea');
      editWrap.style.display = '';
      view.style.display = 'none';
      ta.value = cell.code;
      autoResize({ target: ta });
    }
  } else if (cell.type === 'html') {
    const editWrap = cell.el.querySelector('.cell-html-edit');
    const view = cell.el.querySelector('.cell-html-view');
    if (editWrap.style.display === 'none') {
      const ta = editWrap.querySelector('textarea');
      editWrap.style.display = '';
      view.style.display = 'none';
      ta.value = cell.code;
      autoResize({ target: ta });
    }
  } else if (cell.type === 'md') {
    const editWrap = cell.el.querySelector('.cell-md-edit');
    const view = cell.el.querySelector('.cell-md-view');
    if (editWrap.style.display === 'none') {
      const ta = editWrap.querySelector('textarea');
      editWrap.style.display = '';
      view.style.display = 'none';
      ta.value = cell.code;
      autoResize({ target: ta });
    }
  }

  // uncollapse if collapsed
  cell.el.classList.remove('collapsed');

  // scroll cell into view
  cell.el.scrollIntoView({ block: 'nearest', behavior: 'smooth' });

  // scroll textarea to match line
  const ta = cell.type === 'md'
    ? cell.el.querySelector('.cell-md-edit textarea')
    : cell.type === 'css'
    ? cell.el.querySelector('.cell-css-edit textarea')
    : cell.type === 'html'
    ? cell.el.querySelector('.cell-html-edit textarea')
    : cell.el.querySelector('textarea');
  if (ta) {
    const textBefore = cell.code.substring(0, match.index);
    const lineNum = textBefore.split('\n').length - 1;
    const lineHeight = parseFloat(getComputedStyle(ta).lineHeight) || 20;
    ta.scrollTop = Math.max(0, lineNum * lineHeight - ta.clientHeight / 2);
  }
}

function escHtml(s) {
  return s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
}

// ── EVENT WIRING ──
(function () {
  const findInput = $('#findInput');
  const replaceInput = $('#replaceInput');
  if (!findInput) return;

  findInput.addEventListener('input', () => findComputeMatches());

  findInput.addEventListener('keydown', (e) => {
    if (e.key === 'Enter' && e.shiftKey) { e.preventDefault(); findPrev(); }
    else if (e.key === 'Enter') { e.preventDefault(); findNext(); }
    else if (e.key === 'Escape') { e.preventDefault(); closeFind(); }
  });

  if (replaceInput) {
    replaceInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') { e.preventDefault(); findReplace(); }
      else if (e.key === 'Escape') { e.preventDefault(); closeFind(); }
    });
  }

  const nextBtn = $('#findNextBtn');
  const prevBtn = $('#findPrevBtn');
  const replBtn = $('#findReplaceBtn');
  const replAllBtn = $('#findReplaceAllBtn');
  const caseBtn = $('#findCaseBtn');
  const regexBtn = $('#findRegexBtn');
  const closeBtn = $('#findCloseBtn');

  if (nextBtn) nextBtn.addEventListener('click', findNext);
  if (prevBtn) prevBtn.addEventListener('click', findPrev);
  if (replBtn) replBtn.addEventListener('click', findReplace);
  if (replAllBtn) replAllBtn.addEventListener('click', findReplaceAll);
  if (closeBtn) closeBtn.addEventListener('click', closeFind);
  if (caseBtn) caseBtn.addEventListener('click', () => {
    S.findCase = !S.findCase;
    caseBtn.classList.toggle('active', S.findCase);
    findComputeMatches();
  });
  if (regexBtn) regexBtn.addEventListener('click', () => {
    S.findRegex = !S.findRegex;
    regexBtn.classList.toggle('active', S.findRegex);
    findComputeMatches();
  });

  // live recompute on edit — delegation
  let recomputeTimer = null;
  document.getElementById('notebook').addEventListener('input', (e) => {
    if (!S.findActive) return;
    if (e.target.tagName !== 'TEXTAREA') return;
    clearTimeout(recomputeTimer);
    recomputeTimer = setTimeout(findComputeMatches, 150);
  });
})();

// -- complete.js --

// ── AUTOCOMPLETE ENGINE ──

// well-known property lists for dot completion on builtins
const KNOWN_PROPS = {
  Math: ['abs','acos','asin','atan','atan2','ceil','cos','exp','floor','hypot',
         'log','log2','log10','max','min','pow','random','round','sign','sin',
         'sqrt','tan','trunc','PI','E','LN2','LN10'],
  Array: ['from','isArray','of'],
  Object: ['keys','values','entries','assign','freeze','create','defineProperty','fromEntries','hasOwn'],
  JSON: ['parse','stringify'],
  console: ['log','warn','error','info','table','time','timeEnd','clear'],
  Promise: ['all','allSettled','any','race','resolve','reject'],
  Number: ['isFinite','isInteger','isNaN','parseFloat','parseInt','MAX_SAFE_INTEGER','MIN_SAFE_INTEGER','EPSILON'],
  String: ['fromCharCode','fromCodePoint','raw'],
  ui: ['display','print','canvas','table','slider','dropdown','checkbox','textInput'],
  std: ['csv','fetchJSON','sum','mean','median','extent','bin','linspace',
        'unique','zip','cross','file','download','el','copy','fmt'],
};

// common prototype methods by type
const PROTO_PROPS = {
  array: ['push','pop','shift','unshift','splice','slice','concat','join','reverse',
          'sort','map','filter','reduce','reduceRight','find','findIndex','indexOf',
          'includes','every','some','flat','flatMap','fill','forEach','at','length'],
  string: ['charAt','charCodeAt','codePointAt','concat','endsWith','includes',
           'indexOf','lastIndexOf','match','matchAll','padEnd','padStart','repeat',
           'replace','replaceAll','search','slice','split','startsWith','substring',
           'toLowerCase','toUpperCase','trim','trimEnd','trimStart','at','length'],
  number: ['toFixed','toPrecision','toString','valueOf'],
};

// ── BUILTIN HELP (injected by build.js from src/builtins.json) ──

const BUILTIN_HELP = {
  "ui.display": {
    "sig": "ui.display(...values)",
    "desc": "output values to cell"
  },
  "ui.canvas": {
    "sig": "ui.canvas(w?, h?)",
    "desc": "create/reuse canvas (default 400\u00d7300)"
  },
  "ui.table": {
    "sig": "ui.table(data, columns?)",
    "desc": "render array of objects as table"
  },
  "ui.slider": {
    "sig": "ui.slider(label, default?, {min,max,step,onInput,onChange}?)",
    "desc": "range input \u2014 reactive, or callback via onInput/onChange"
  },
  "ui.dropdown": {
    "sig": "ui.dropdown(label, options, default?, {onInput,onChange}?)",
    "desc": "select menu \u2014 reactive, or callback via onInput/onChange"
  },
  "ui.checkbox": {
    "sig": "ui.checkbox(label, default?, {onInput,onChange}?)",
    "desc": "toggle \u2014 reactive, or callback via onInput/onChange"
  },
  "ui.textInput": {
    "sig": "ui.textInput(label, default?, {onInput,onChange}?)",
    "desc": "text field \u2014 reactive, or callback via onInput/onChange"
  },
  "std.csv": {
    "sig": "std.csv(text, {separator?, typed?}?)",
    "desc": "parse CSV text to array of objects"
  },
  "std.fetchJSON": {
    "sig": "std.fetchJSON(url)",
    "desc": "fetch URL and parse JSON"
  },
  "std.sum": {
    "sig": "std.sum(arr, fn?)",
    "desc": "sum array values"
  },
  "std.mean": {
    "sig": "std.mean(arr, fn?)",
    "desc": "arithmetic mean"
  },
  "std.median": {
    "sig": "std.median(arr, fn?)",
    "desc": "median value"
  },
  "std.extent": {
    "sig": "std.extent(arr, fn?)",
    "desc": "returns [min, max]"
  },
  "std.bin": {
    "sig": "std.bin(arr, n?, fn?)",
    "desc": "histogram bins (default 10)"
  },
  "std.linspace": {
    "sig": "std.linspace(start, stop, n)",
    "desc": "evenly-spaced numbers"
  },
  "std.unique": {
    "sig": "std.unique(arr, fn?)",
    "desc": "unique values with optional key fn"
  },
  "std.zip": {
    "sig": "std.zip(...arrays)",
    "desc": "zip arrays together"
  },
  "std.cross": {
    "sig": "std.cross(...arrays)",
    "desc": "cartesian product"
  },
  "std.file": {
    "sig": "std.file(accept?)",
    "desc": "open file picker"
  },
  "std.download": {
    "sig": "std.download(data, filename, mimeType?)",
    "desc": "download data as file"
  },
  "std.el": {
    "sig": "std.el(tag, attrs?, ...children)",
    "desc": "create DOM element"
  },
  "std.copy": {
    "sig": "std.copy(text)",
    "desc": "copy text to clipboard"
  },
  "std.fmt": {
    "sig": "std.fmt(number, {decimals?, prefix?, suffix?}?)",
    "desc": "format number to string"
  },
  "print": {
    "sig": "print(...values)",
    "desc": "output values to cell (alias for ui.display)"
  },
  "load": {
    "sig": "load(url)",
    "desc": "import ES module (cached). @std, @python supported."
  },
  "install": {
    "sig": "install(url)",
    "desc": "fetch & embed module for offline"
  },
  "invalidation": {
    "sig": "invalidation",
    "desc": "promise \u2014 resolves when cell re-runs"
  },
  "atra": {
    "sig": "atra`...` or atra({imports})`...`",
    "desc": "compile Fortran/Pascal to Wasm (load ext/atra/index.js)"
  }
};

// ── FUZZY MATCHING ──

// returns { score, indices } or null if no match
// indices = positions in `text` that matched characters from `query`
function fuzzyMatch(query, text) {
  const qLen = query.length;
  const tLen = text.length;
  if (qLen === 0) return { score: 0, indices: [] };
  if (qLen > tLen) return null;

  const qLower = query.toLowerCase();
  const tLower = text.toLowerCase();

  // fast check: all query chars exist in text in order
  let qi = 0;
  for (let ti = 0; ti < tLen && qi < qLen; ti++) {
    if (qLower[qi] === tLower[ti]) qi++;
  }
  if (qi < qLen) return null;

  // find best match using a greedy approach that prefers word boundaries
  // word boundaries: start of string, after _ or $, camelCase transitions
  const indices = [];
  qi = 0;

  // first pass: try to match at word boundaries
  const boundaryIndices = [];
  let bqi = 0;
  for (let ti = 0; ti < tLen && bqi < qLen; ti++) {
    if (qLower[bqi] !== tLower[ti]) continue;
    const isBoundary = ti === 0
      || text[ti - 1] === '_' || text[ti - 1] === '$'
      || (text[ti] >= 'A' && text[ti] <= 'Z' && (ti === 0 || text[ti - 1] < 'A' || text[ti - 1] > 'Z'));
    if (isBoundary) {
      boundaryIndices.push(ti);
      bqi++;
    }
  }

  if (bqi === qLen) {
    // all chars matched at boundaries — use those indices
    indices.push(...boundaryIndices);
  } else {
    // fallback: greedy left-to-right match, prefer consecutive runs
    qi = 0;
    for (let ti = 0; ti < tLen && qi < qLen; ti++) {
      if (qLower[qi] === tLower[ti]) {
        indices.push(ti);
        qi++;
      }
    }
  }

  // score the match
  let score = 0;

  // bonus for matching at start of string
  if (indices[0] === 0) score += 10;

  // bonus for consecutive characters
  for (let i = 1; i < indices.length; i++) {
    if (indices[i] === indices[i - 1] + 1) score += 5;
  }

  // bonus for word boundary matches
  for (const idx of indices) {
    if (idx === 0) { score += 3; continue; }
    const prev = text[idx - 1];
    if (prev === '_' || prev === '$') { score += 3; continue; }
    if (text[idx] >= 'A' && text[idx] <= 'Z' && (prev < 'A' || prev > 'Z')) score += 3;
  }

  // bonus for exact case match
  for (let i = 0; i < indices.length; i++) {
    if (query[i] === text[indices[i]]) score += 1;
  }

  // penalty for spread-out matches (large gaps between indices)
  const span = indices[indices.length - 1] - indices[0];
  score -= span * 0.5;

  // slight penalty for longer names (prefer shorter completions)
  score -= tLen * 0.1;

  return { score, indices };
}

// determine cursor context: is it inside a string or comment?
function cursorContext(code, cursor) {
  let i = 0;
  while (i < cursor) {
    const ch = code[i];
    // single-line comment
    if (ch === '/' && code[i + 1] === '/') {
      const nl = code.indexOf('\n', i);
      if (nl === -1 || nl >= cursor) return 'comment';
      i = nl + 1;
      continue;
    }
    // block comment
    if (ch === '/' && code[i + 1] === '*') {
      const end = code.indexOf('*/', i + 2);
      if (end === -1 || end + 2 > cursor) return 'comment';
      i = end + 2;
      continue;
    }
    // single-quoted string
    if (ch === "'") {
      i++;
      while (i < code.length) {
        if (code[i] === '\\') { i += 2; continue; }
        if (code[i] === "'") { i++; break; }
        if (i >= cursor) return 'string';
        i++;
      }
      continue;
    }
    // double-quoted string
    if (ch === '"') {
      i++;
      while (i < code.length) {
        if (code[i] === '\\') { i += 2; continue; }
        if (code[i] === '"') { i++; break; }
        if (i >= cursor) return 'string';
        i++;
      }
      continue;
    }
    // template literal (possibly tagged)
    if (ch === '`') {
      // look back for a tag name: identifier immediately before the backtick,
      // or curried form: identifier(...) before the backtick
      let tagName = null;
      if (i > 0 && typeof window !== 'undefined' && window._taggedLanguages) {
        let te = i;
        let ts = te;
        // direct form: ident`
        while (ts > 0 && /\w/.test(code[ts - 1])) ts--;
        if (ts < te) {
          const candidate = code.slice(ts, te);
          if (window._taggedLanguages[candidate]) tagName = candidate;
        }
        // curried form: ident(...)`
        if (!tagName && code[i - 1] === ')') {
          let p = i - 2, depth = 1;
          while (p >= 0 && depth > 0) {
            if (code[p] === ')') depth++;
            else if (code[p] === '(') depth--;
            p--;
          }
          // p now points one before the (
          let ne = p + 1;
          let ns = ne;
          while (ns > 0 && /\w/.test(code[ns - 1])) ns--;
          if (ns < ne) {
            const candidate = code.slice(ns, ne);
            if (window._taggedLanguages[candidate]) tagName = candidate;
          }
        }
      }

      i++;
      let depth = 0;
      while (i < code.length) {
        if (code[i] === '\\') { i += 2; continue; }
        if (code[i] === '$' && code[i + 1] === '{') {
          depth++;
          i += 2;
          // inside ${...} — this is code context
          let braces = 1;
          while (i < code.length && braces > 0) {
            if (code[i] === '{') braces++;
            else if (code[i] === '}') { braces--; if (braces === 0) break; }
            if (i >= cursor) return 'code'; // inside template expression = code
            i++;
          }
          if (i >= cursor) return 'code';
          i++; // skip closing }
          continue;
        }
        if (code[i] === '`') { i++; break; }
        if (i >= cursor) return tagName ? { type: 'tagged', lang: tagName } : 'string';
        i++;
      }
      continue;
    }
    i++;
  }
  return 'code';
}

// extract the word being typed at cursor position
function extractPrefix(code, cursor) {
  let end = cursor;
  let start = cursor;
  while (start > 0 && /[a-zA-Z0-9_$]/.test(code[start - 1])) start--;
  return { prefix: code.slice(start, end), start };
}

// detect dot access: returns the expression before the dot, or null
function detectDot(code, cursor) {
  // cursor is right after a dot or after dot + partial word
  const before = code.slice(0, cursor);
  // match patterns like "identifier." or "identifier.par" at end
  const m = before.match(/([a-zA-Z_$][\w$]*)\.\s*([a-zA-Z_$][\w$]*)?$/);
  if (m) return { obj: m[1], prefix: m[2] || '' };
  return null;
}

function getPropsForValue(val) {
  if (val == null) return [];
  const props = new Set();
  // own properties
  const own = Object.getOwnPropertyNames(val);
  for (const p of own) {
    if (/^[a-zA-Z_$]/.test(p)) props.add(p);
  }
  // prototype chain (1 level)
  const proto = Object.getPrototypeOf(val);
  if (proto && proto !== Object.prototype) {
    try {
      const pNames = Object.getOwnPropertyNames(proto);
      for (const p of pNames) {
        if (p !== 'constructor' && /^[a-zA-Z_$]/.test(p)) props.add(p);
      }
    } catch {}
  }
  return [...props];
}

function getCompletions(code, cursor, cellId) {
  const ctx = cursorContext(code, cursor);

  // tagged template literal — delegate to extension completions
  if (ctx && typeof ctx === 'object' && ctx.type === 'tagged') {
    const lang = typeof window !== 'undefined' && window._taggedLanguages
      && window._taggedLanguages[ctx.lang];
    if (lang && lang.completions) {
      const { prefix, start } = extractPrefix(code, cursor);
      if (!prefix) return { prefix: '', items: [] };
      const extItems = lang.completions(prefix);
      // score and annotate items
      const items = [];
      for (const it of extItems) {
        const m = fuzzyMatch(prefix, it.text);
        if (m) items.push({ text: it.text, kind: it.kind || 'var', score: m.score, indices: m.indices });
      }
      items.sort((a, b) => b.score - a.score || a.text.localeCompare(b.text));
      return { prefix, items: items.slice(0, 30) };
    }
    return { prefix: '', items: [] };
  }

  if (ctx !== 'code') return { prefix: '', items: [] };

  // check for dot completion
  const dot = detectDot(code, cursor);
  if (dot) {
    const items = [];
    const prefix = dot.prefix;
    let propList = [];

    // check known builtins
    if (KNOWN_PROPS[dot.obj]) {
      propList = KNOWN_PROPS[dot.obj];
    } else if (dot.obj in S.scope) {
      // live value inspection
      const val = S.scope[dot.obj];
      if (val != null) {
        propList = getPropsForValue(val);
        // also add type-based suggestions
        if (Array.isArray(val)) propList = [...new Set([...propList, ...PROTO_PROPS.array])];
        else if (typeof val === 'string') propList = [...new Set([...propList, ...PROTO_PROPS.string])];
        else if (typeof val === 'number') propList = [...new Set([...propList, ...PROTO_PROPS.number])];
      }
    }

    for (const p of propList) {
      if (!prefix) {
        items.push({ text: p, kind: 'prop', score: 0, indices: [] });
        continue;
      }
      const m = fuzzyMatch(prefix, p);
      if (m) items.push({ text: p, kind: 'prop', score: m.score, indices: m.indices });
    }

    items.sort((a, b) => b.score - a.score || a.text.localeCompare(b.text));
    return { prefix, items: items.slice(0, 30) };
  }

  // word prefix completion
  const { prefix, start } = extractPrefix(code, cursor);
  if (!prefix) return { prefix: '', items: [] };

  const items = [];
  const seen = new Set();

  // collect candidates from all sources with their kind
  const candidates = [];

  // 1. scope variables
  for (const name of Object.keys(S.scope)) {
    if (!seen.has(name)) { seen.add(name); candidates.push({ text: name, kind: 'var' }); }
  }

  // 2. own cell defines
  const cell = S.cells.find(c => c.id === cellId);
  if (cell && cell.defines) {
    for (const name of cell.defines) {
      if (!seen.has(name)) { seen.add(name); candidates.push({ text: name, kind: 'def' }); }
    }
  }

  // 3. builtin functions (with help detail)
  for (const name of Object.keys(BUILTIN_HELP)) {
    if (!seen.has(name)) {
      seen.add(name);
      const h = BUILTIN_HELP[name];
      candidates.push({ text: name, kind: 'fn', detail: h.sig });
    }
  }

  // 4. JS builtins
  for (const name of JS_BUILTINS) {
    if (!seen.has(name)) { seen.add(name); candidates.push({ text: name, kind: 'const' }); }
  }

  // 5. JS keywords (min 2 chars to avoid noise)
  if (prefix.length >= 2) {
    for (const name of JS_KEYWORDS) {
      if (!seen.has(name)) { seen.add(name); candidates.push({ text: name, kind: 'kw' }); }
    }
  }

  // fuzzy match all candidates
  for (const c of candidates) {
    if (c.text === prefix) continue; // skip exact match (already typed)
    const m = fuzzyMatch(prefix, c.text);
    if (m) {
      const item = { text: c.text, kind: c.kind, score: m.score, indices: m.indices };
      if (c.detail) item.detail = c.detail;
      items.push(item);
    }
  }

  // sort by score descending, then alphabetical
  items.sort((a, b) => b.score - a.score || a.text.localeCompare(b.text));

  return { prefix, items: items.slice(0, 30) };
}

// ── TEXTAREA ADAPTER ──

const KIND_LABELS = { var: 'v', fn: 'f', kw: 'k', const: 'c', prop: 'p', def: 'd' };

let activeMenu = null;
let activeState = null;
let activeSigHint = null;

function dismissAutocomplete() {
  if (activeMenu) {
    activeMenu.remove();
    activeMenu = null;
    activeState = null;
  }
}

function dismissSigHint() {
  if (activeSigHint) {
    activeSigHint.remove();
    activeSigHint = null;
  }
}

// detect if cursor is inside a function call's arguments for a known builtin
function detectCallContext(code, cursor) {
  // scan backwards from cursor to find an unmatched (
  let depth = 0;
  let i = cursor - 1;
  while (i >= 0) {
    const ch = code[i];
    if (ch === ')') depth++;
    else if (ch === '(') {
      if (depth === 0) {
        // found the opening paren — extract the function name before it (including dot for ui.slider etc.)
        let end = i;
        let start = end - 1;
        while (start >= 0 && /[a-zA-Z0-9_$.]/.test(code[start])) start--;
        start++;
        const fnName = code.slice(start, end);
        if (BUILTIN_HELP[fnName]) {
          // figure out which parameter we're on by counting commas at depth 0
          let paramIdx = 0;
          let d = 0;
          for (let j = i + 1; j < cursor; j++) {
            if (code[j] === '(' || code[j] === '[' || code[j] === '{') d++;
            else if (code[j] === ')' || code[j] === ']' || code[j] === '}') d--;
            else if (code[j] === ',' && d === 0) paramIdx++;
          }
          return { fnName, parenPos: i, paramIdx };
        }
        return null;
      }
      depth--;
    }
    i--;
  }
  return null;
}

function showSigHint(ta) {
  const code = ta.value;
  const cursor = ta.selectionStart;
  if (ta.selectionStart !== ta.selectionEnd) { dismissSigHint(); return; }

  const ctx = cursorContext(code, cursor);
  if (ctx !== 'code') { dismissSigHint(); return; }

  const call = detectCallContext(code, cursor);
  if (!call) { dismissSigHint(); return; }

  const wrap = ta.closest('.editor-wrap');
  if (!wrap) { dismissSigHint(); return; }

  const help = BUILTIN_HELP[call.fnName];
  const pos = measureCursorPos(ta, call.parenPos);

  if (!activeSigHint) {
    activeSigHint = document.createElement('div');
    activeSigHint.className = 'ac-sig-hint';
    wrap.appendChild(activeSigHint);
  } else if (activeSigHint.parentElement !== wrap) {
    activeSigHint.remove();
    wrap.appendChild(activeSigHint);
  }

  // highlight current parameter in the signature
  const sigHtml = highlightParam(help.sig, call.paramIdx);
  activeSigHint.innerHTML = `<span class="ac-sig-fn">${sigHtml}</span><span class="ac-sig-desc">${esc(help.desc)}</span>`;

  const cs = getComputedStyle(ta);
  const padLeft = parseFloat(cs.paddingLeft) || 0;
  const padTop = parseFloat(cs.paddingTop) || 0;
  const lineHeight = parseFloat(cs.lineHeight) || parseFloat(cs.fontSize) * 1.5;

  const left = pos.x + padLeft - ta.scrollLeft;

  // place above the current line; pos.y is bottom of the line
  // so subtract lineHeight (to get top of line) then the hint's own height
  activeSigHint.style.left = left + 'px';
  activeSigHint.style.top = '0px'; // render off-screen first to measure
  activeSigHint.style.visibility = 'hidden';
  const hintH = activeSigHint.offsetHeight || lineHeight;
  activeSigHint.style.visibility = '';

  let top = pos.y + padTop - ta.scrollTop - lineHeight - hintH;

  // if it would go above the editor, show below the current line instead
  const wrapRect = wrap.getBoundingClientRect();
  const taRect = ta.getBoundingClientRect();
  const absTop = taRect.top + top;
  if (absTop < wrapRect.top) {
    top = pos.y + padTop - ta.scrollTop;
  }

  activeSigHint.style.top = top + 'px';
}

function highlightParam(sig, paramIdx) {
  // find the params inside parens
  const openParen = sig.indexOf('(');
  if (openParen === -1) return esc(sig);
  const closeParen = sig.lastIndexOf(')');
  if (closeParen === -1) return esc(sig);

  const before = sig.slice(0, openParen + 1);
  const params = sig.slice(openParen + 1, closeParen);
  const after = sig.slice(closeParen);

  // split on commas (respecting nested braces)
  const parts = [];
  let depth = 0;
  let start = 0;
  for (let i = 0; i < params.length; i++) {
    if (params[i] === '{' || params[i] === '(' || params[i] === '[') depth++;
    else if (params[i] === '}' || params[i] === ')' || params[i] === ']') depth--;
    else if (params[i] === ',' && depth === 0) {
      parts.push(params.slice(start, i));
      start = i + 1;
    }
  }
  parts.push(params.slice(start));

  let html = esc(before);
  for (let i = 0; i < parts.length; i++) {
    if (i > 0) html += esc(',');
    if (i === paramIdx) {
      html += '<span class="ac-sig-active">' + esc(parts[i]) + '</span>';
    } else {
      html += esc(parts[i]);
    }
  }
  html += esc(after);
  return html;
}

function measureCursorPos(ta, cursor) {
  const text = ta.value.substring(0, cursor);
  const lines = text.split('\n');
  const lineNum = lines.length - 1;
  const colText = lines[lineNum];

  // measure column offset using a hidden span
  let measurer = ta._acMeasurer;
  if (!measurer) {
    measurer = document.createElement('span');
    measurer.style.cssText = 'position:absolute;visibility:hidden;white-space:pre;pointer-events:none;';
    document.body.appendChild(measurer);
    ta._acMeasurer = measurer;
  }
  const cs = getComputedStyle(ta);
  measurer.style.font = cs.font;
  measurer.style.fontSize = cs.fontSize;
  measurer.style.fontFamily = cs.fontFamily;
  measurer.style.letterSpacing = cs.letterSpacing;
  measurer.style.tabSize = cs.tabSize;
  measurer.textContent = colText;

  const lineHeight = parseFloat(cs.lineHeight) || parseFloat(cs.fontSize) * 1.5;
  const x = measurer.offsetWidth;
  const y = (lineNum + 1) * lineHeight;

  return { x, y, lineHeight };
}

function highlightMatches(text, indices) {
  if (!indices || !indices.length) return esc(text);
  const set = new Set(indices);
  let html = '';
  let inMatch = false;
  for (let i = 0; i < text.length; i++) {
    if (set.has(i)) {
      if (!inMatch) { html += '<span class="ac-match">'; inMatch = true; }
      html += esc(text[i]);
    } else {
      if (inMatch) { html += '</span>'; inMatch = false; }
      html += esc(text[i]);
    }
  }
  if (inMatch) html += '</span>';
  return html;
}

function renderMenu(items, prefix, selectedIdx) {
  let html = '';
  const max = Math.min(items.length, 30);
  for (let i = 0; i < max; i++) {
    const it = items[i];
    const cls = i === selectedIdx ? 'ac-item active' : 'ac-item';
    const kindCls = 'ac-kind ac-kind-' + it.kind;
    const label = KIND_LABELS[it.kind] || '?';
    const textHtml = highlightMatches(it.text, it.indices);
    const detailHtml = it.detail ? `<span class="ac-detail">${esc(it.detail)}</span>` : '';
    html += `<div class="${cls}" data-index="${i}"><span class="${kindCls}">${label}</span><span class="ac-text">${textHtml}</span>${detailHtml}</div>`;
  }
  return html;
}

function esc(s) {
  return s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
}

function showMenu(ta, cellId) {
  const code = ta.value;
  const cursor = ta.selectionStart;
  if (ta.selectionStart !== ta.selectionEnd) { dismissAutocomplete(); return; }

  const result = getCompletions(code, cursor, cellId);
  if (!result.items.length) { dismissAutocomplete(); return; }

  const wrap = ta.closest('.editor-wrap');
  if (!wrap) { dismissAutocomplete(); return; }

  const pos = measureCursorPos(ta, cursor);

  if (!activeMenu) {
    activeMenu = document.createElement('div');
    activeMenu.className = 'ac-menu';
    wrap.appendChild(activeMenu);
  } else if (activeMenu.parentElement !== wrap) {
    activeMenu.remove();
    wrap.appendChild(activeMenu);
  }

  activeState = {
    items: result.items,
    prefix: result.prefix,
    selected: 0,
    ta,
    cellId,
    cursorStart: cursor - result.prefix.length
  };

  activeMenu.innerHTML = renderMenu(result.items, result.prefix, 0);

  // position: account for padding and scroll
  const cs = getComputedStyle(ta);
  const padLeft = parseFloat(cs.paddingLeft) || 0;
  const padTop = parseFloat(cs.paddingTop) || 0;

  const left = pos.x + padLeft - ta.scrollLeft;
  const top = pos.y + padTop - ta.scrollTop;

  activeMenu.style.left = left + 'px';
  activeMenu.style.top = top + 'px';

  // flip above if it would overflow viewport
  const menuRect = activeMenu.getBoundingClientRect();
  if (menuRect.bottom > window.innerHeight - 20) {
    activeMenu.style.top = (top - pos.lineHeight - activeMenu.offsetHeight) + 'px';
  }

  // mouse interaction
  activeMenu.onmousedown = (e) => {
    e.preventDefault(); // don't blur textarea
    const item = e.target.closest('.ac-item');
    if (item) {
      activeState.selected = parseInt(item.dataset.index);
      acceptCompletion();
    }
  };
}

function updateSelection(idx) {
  if (!activeMenu || !activeState) return;
  activeState.selected = idx;
  const items = activeMenu.querySelectorAll('.ac-item');
  items.forEach((el, i) => el.classList.toggle('active', i === idx));
  // scroll into view
  if (items[idx]) items[idx].scrollIntoView({ block: 'nearest' });
}

function acceptCompletion() {
  if (!activeState) return;
  const { items, selected, ta, prefix, cursorStart } = activeState;
  const item = items[selected];
  if (!item) return;

  ta.focus();
  ta.selectionStart = cursorStart;
  ta.selectionEnd = cursorStart + prefix.length;
  document.execCommand('insertText', false, item.text);

  dismissAutocomplete();
  ta.dispatchEvent(new Event('input'));
}

function attachAutocomplete(textarea, cellId) {
  // keydown handler — must be added BEFORE handleTab so stopImmediatePropagation works
  textarea.addEventListener('keydown', (e) => {
    // Ctrl+Shift+Space — manual signature hint trigger
    if (e.key === ' ' && (e.ctrlKey || e.metaKey) && e.shiftKey) {
      e.preventDefault();
      e.stopImmediatePropagation();
      dismissAutocomplete();
      showSigHint(textarea);
      return;
    }

    if (!activeMenu || !activeState) return;

    if (e.key === 'ArrowDown') {
      e.preventDefault();
      e.stopImmediatePropagation();
      const next = (activeState.selected + 1) % activeState.items.length;
      updateSelection(next);
      return;
    }
    if (e.key === 'ArrowUp') {
      e.preventDefault();
      e.stopImmediatePropagation();
      const prev = (activeState.selected - 1 + activeState.items.length) % activeState.items.length;
      updateSelection(prev);
      return;
    }
    if (e.key === 'Tab' || e.key === 'Enter') {
      e.preventDefault();
      e.stopImmediatePropagation();
      acceptCompletion();
      return;
    }
    if (e.key === 'Escape') {
      e.preventDefault();
      e.stopImmediatePropagation();
      dismissAutocomplete();
      dismissSigHint();
      return;
    }
  });

  // input handler — show/update completions + signature hints
  textarea.addEventListener('input', () => {
    // use a microtask so the value is settled
    Promise.resolve().then(() => {
      showMenu(textarea, cellId);
      // show sig hint only when autocomplete menu is not visible
      if (!activeMenu) showSigHint(textarea);
      else dismissSigHint();
    });
  });

  // dismiss on blur
  textarea.addEventListener('blur', () => {
    // delay so mousedown on menu can fire first
    setTimeout(() => { dismissAutocomplete(); dismissSigHint(); }, 150);
  });

  // dismiss on scroll (position goes stale)
  textarea.addEventListener('scroll', () => {
    dismissAutocomplete();
    dismissSigHint();
  });
}

// -- keyboard.js --

// ── KEYBOARD / SELECTION ──

function addCellWithUndo(type, code, afterId, beforeId) {
  const cell = addCell(type, code, afterId, beforeId);
  S.trash.push({ action: 'add', id: cell.id });
  return cell;
}

function deleteCellWithUndo(id) {
  const idx = S.cells.findIndex(c => c.id === id);
  if (idx < 0) return;
  const cell = S.cells[idx];
  const afterId = idx > 0 ? S.cells[idx - 1].id : null;
  const beforeId = afterId === null && idx < S.cells.length - 1 ? S.cells[idx + 1].id : null;
  S.trash.push({ action: 'delete', type: cell.type, code: cell.code, afterId, beforeId, collapsed: !!cell.el.classList.contains('collapsed') });
  deleteCell(id);
  setMsg('deleted cell (z to undo)', 'ok');
}

function undo() {
  if (!S.trash.length) { setMsg('nothing to undo', ''); return; }
  const entry = S.trash.pop();

  if (entry.action === 'add') {
    // undo add = delete the cell (without pushing to undo stack)
    deleteCell(entry.id);
    setMsg('undid add', 'ok');
  } else {
    // undo delete = restore the cell
    const { type, code, afterId, beforeId, collapsed } = entry;
    const validAfter = afterId !== null && S.cells.find(c => c.id === afterId) ? afterId : null;
    const validBefore = beforeId !== null && S.cells.find(c => c.id === beforeId) ? beforeId : null;
    const newCell = addCell(type, code, validAfter, validBefore);
    if (collapsed) newCell.el.classList.add('collapsed');
    selectCell(newCell.id);
    if ((type === 'code' || type === 'html') && S.cells.some(c => c.type === 'code' || c.type === 'html')) runAll();
    setMsg('restored cell', 'ok');
  }
}

function selectCell(id, scroll) {
  // deselect previous
  $$('.cell.selected').forEach(el => el.classList.remove('selected'));
  S.selectedId = id;
  if (id === null) return;
  const cell = S.cells.find(c => c.id === id);
  if (cell) {
    cell.el.classList.add('selected');
    if (scroll) cell.el.scrollIntoView({ block: 'nearest' });
  }
}

function getEditingCell() {
  const active = document.activeElement;
  if (active && active.tagName === 'TEXTAREA') {
    const cellEl = active.closest('.cell');
    if (cellEl) {
      const id = parseInt(cellEl.dataset.id);
      return S.cells.find(c => c.id === id) || null;
    }
  }
  return null;
}

function editCell(id) {
  const cell = S.cells.find(c => c.id === id);
  if (!cell) return;
  selectCell(id);

  if (cell.type === 'md') {
    // open md editor
    const view = cell.el.querySelector('.cell-md-view');
    const editWrap = cell.el.querySelector('.cell-md-edit');
    const ta = cell.el.querySelector('.cell-md-edit textarea');
    editWrap.style.display = '';
    view.style.display = 'none';
    ta.value = cell.code;
    ta.focus();
    autoResize({ target: ta });
  } else if (cell.type === 'css') {
    // open css editor
    const view = cell.el.querySelector('.cell-css-view');
    const editWrap = cell.el.querySelector('.cell-css-edit');
    const ta = cell.el.querySelector('.cell-css-edit textarea');
    editWrap.style.display = '';
    view.style.display = 'none';
    ta.value = cell.code;
    ta.focus();
    autoResize({ target: ta });
  } else if (cell.type === 'html') {
    // open html editor
    const view = cell.el.querySelector('.cell-html-view');
    const editWrap = cell.el.querySelector('.cell-html-edit');
    const ta = cell.el.querySelector('.cell-html-edit textarea');
    editWrap.style.display = '';
    view.style.display = 'none';
    ta.value = cell.code;
    ta.focus();
    autoResize({ target: ta });
  } else {
    cell.el.querySelector('textarea').focus();
  }
}

function exitEdit() {
  const active = document.activeElement;
  if (active && active.tagName === 'TEXTAREA') {
    active.blur();
  }
}

function runSelected() {
  if (S.selectedId === null && S.cells.length) selectCell(S.cells[0].id);
  const cell = S.cells.find(c => c.id === S.selectedId);
  if (!cell) return;
  if (cell.type === 'code') {
    cell.code = cell.el.querySelector('.cell-code textarea').value;
    runDAG([cell.id]);
  } else if (cell.type === 'html') {
    renderHtmlCell(cell);
  }
}

// ── MOBILE TRAY TOGGLES ──

function closeAllTrays() {
  document.querySelectorAll('.action-add-tray.open, .action-more-tray.open, .cell-type-picker.open, .cell-insert-picker.open').forEach(el => el.classList.remove('open'));
}

function toggleToolbarMenu() {
  const menu = document.querySelector('.toolbar-overflow');
  if (!menu) return;
  menu.classList.toggle('open');
}

function toggleAddTray() {
  const tray = document.querySelector('.action-add-tray');
  if (!tray) return;
  const wasOpen = tray.classList.contains('open');
  closeAllTrays();
  if (!wasOpen) tray.classList.add('open');
}

function toggleMoreTray() {
  const tray = document.querySelector('.action-more-tray');
  if (!tray) return;
  const wasOpen = tray.classList.contains('open');
  closeAllTrays();
  if (!wasOpen) tray.classList.add('open');
}

function showInsertPicker(id, dir) {
  closeAllTrays();
  const cell = S.cells.find(c => c.id === id);
  if (!cell) return;
  document.querySelectorAll('.cell-insert-picker').forEach(el => el.remove());
  const picker = document.createElement('div');
  picker.className = 'cell-insert-picker open';
  let afterId;
  if (dir === 'after') {
    afterId = id;
  } else {
    const idx = S.cells.findIndex(c => c.id === id);
    afterId = idx > 0 ? S.cells[idx - 1].id : null;
  }
  picker.innerHTML = ['code', 'md', 'css', 'html'].map(t =>
    `<button onclick="insertAt(${afterId !== null ? afterId : 'null'},'${t}');this.closest('.cell-insert-picker').remove()">${t}</button>`
  ).join('');
  const header = cell.el.querySelector('.cell-header');
  header.style.position = 'relative';
  picker.style.top = '100%';
  picker.style.left = dir === 'before' ? '0' : 'auto';
  picker.style.right = dir === 'after' ? '0' : 'auto';
  header.appendChild(picker);
}

function toggleTypePicker(id) {
  closeAllTrays();
  const picker = document.querySelector(`.cell-type-picker[data-cell-id="${id}"]`);
  if (picker) picker.classList.toggle('open');
}

function collapseAll() {
  S.cells.forEach(c => c.el.classList.add('collapsed'));
  setMsg('collapsed all', 'ok');
}

function expandAll() {
  S.cells.forEach(c => c.el.classList.remove('collapsed'));
  setMsg('expanded all', 'ok');
}

function newNotebook() {
  if (!confirm('Clear all cells?')) return;
  while (S.cells.length) {
    const cell = S.cells[0];
    if (cell._styleEl) { cell._styleEl.remove(); cell._styleEl = null; }
    cell.el.remove();
    S.cells.shift();
  }
  S.scope = {};
  S.selectedId = null;
  S.clipboard = null;
  S.trash = [];
  $('#docTitle').value = 'untitled';
  updateStatus();
  setMsg('new notebook', 'ok');
}

function runSelectedCell() { runSelectedAndAdvance(); }

function runSelectedAndAdvance() {
  runSelected();
  if (S.selectedId === null) return;
  // respect goto target if set
  const gotoIdx = window._lastGotoTarget;
  if (gotoIdx != null && gotoIdx >= 0 && gotoIdx < S.cells.length) {
    editCell(S.cells[gotoIdx].id);
  } else {
    const idx = S.cells.findIndex(c => c.id === S.selectedId);
    if (idx < S.cells.length - 1) {
      editCell(S.cells[idx + 1].id);
    } else {
      const newCell = addCellWithUndo('code', '', S.selectedId);
      selectCell(newCell.id);
    }
  }
}

function navigateCell(dir) {
  if (!S.cells.length) return;
  if (S.selectedId === null) {
    selectCell(S.cells[0].id, true);
    return;
  }
  const idx = S.cells.findIndex(c => c.id === S.selectedId);
  const newIdx = idx + dir;
  if (newIdx >= 0 && newIdx < S.cells.length) {
    selectCell(S.cells[newIdx].id, true);
  }
}

document.addEventListener('keydown', (e) => {
  // find bar shortcuts (must be before edit/command branches)
  if ((e.key === 'f') && (e.ctrlKey || e.metaKey) && !e.altKey) {
    e.preventDefault(); openFind(false); return;
  }
  if ((e.key === 'h') && (e.ctrlKey || e.metaKey) && !e.altKey) {
    e.preventDefault(); openFind(true); return;
  }
  if (e.key === 'Escape' && S.findActive) {
    e.preventDefault(); closeFind(); return;
  }

  const editing = getEditingCell();

  if (editing) {
    // ── EDIT MODE ──
    if (e.key === '/' && (e.ctrlKey || e.metaKey)) {
      e.preventDefault();
      toggleComment(document.activeElement);
      return;
    }
    if (e.key === 'Escape') {
      e.preventDefault();
      exitEdit();
      selectCell(editing.id);
      return;
    }
    if (e.key === 'Enter' && e.ctrlKey) {
      e.preventDefault();
      editing.code = editing.el.querySelector('textarea').value;
      if (editing.type === 'code') runDAG([editing.id], true);
      return;
    }
    if (e.key === 'Enter' && e.shiftKey) {
      e.preventDefault();
      editing.code = editing.el.querySelector('textarea').value;
      if (editing.type === 'code') runDAG([editing.id], true);
      // advance — respect goto target if set
      const gotoIdx = window._lastGotoTarget;
      if (gotoIdx != null && gotoIdx >= 0 && gotoIdx < S.cells.length) {
        editCell(S.cells[gotoIdx].id);
      } else {
        const idx = S.cells.findIndex(c => c.id === editing.id);
        if (idx < S.cells.length - 1) {
          editCell(S.cells[idx + 1].id);
        } else {
          const newCell = addCellWithUndo('code', '', editing.id);
          selectCell(newCell.id);
          editCell(newCell.id);
        }
      }
      return;
    }
  } else {
    // ── COMMAND MODE ──
    // ignore if typing in any input field (title, find bar, etc.)
    if (document.activeElement && (document.activeElement.tagName === 'INPUT' || document.activeElement.id === 'docTitle')) return;

    // let browser shortcuts through (Ctrl+J downloads, etc.)
    if (e.ctrlKey || e.metaKey || e.altKey) return;

    if (e.key === 'ArrowUp' || e.key === 'k') {
      e.preventDefault();
      navigateCell(-1);
      return;
    }
    if (e.key === 'ArrowDown' || e.key === 'j') {
      e.preventDefault();
      navigateCell(1);
      return;
    }
    if (e.key === 'Enter') {
      e.preventDefault();
      if (S.selectedId !== null) editCell(S.selectedId);
      return;
    }
    if (e.key === 'a') {
      e.preventDefault();
      const newCell = addCellWithUndo('code', '', null, S.selectedId);
      selectCell(newCell.id);
      editCell(newCell.id);
      return;
    }
    if (e.key === 'b') {
      e.preventDefault();
      const newCell = addCellWithUndo('code', '', S.selectedId);
      selectCell(newCell.id);
      editCell(newCell.id);
      return;
    }
    if (e.key === 'd') {
      e.preventDefault();
      if (S.pendingD) {
        // dd — delete
        clearTimeout(S.pendingDTimer);
        S.pendingD = false;
        if (S.selectedId !== null) {
          const idx = S.cells.findIndex(c => c.id === S.selectedId);
          const nextId = idx < S.cells.length - 1 ? S.cells[idx + 1].id
                       : idx > 0 ? S.cells[idx - 1].id : null;
          deleteCellWithUndo(S.selectedId);
          if (nextId !== null) selectCell(nextId);
        }
      } else {
        S.pendingD = true;
        S.pendingDTimer = setTimeout(() => { S.pendingD = false; }, 600);
      }
      return;
    }
    if (e.key !== 'd' && S.pendingD) { S.pendingD = false; clearTimeout(S.pendingDTimer); }
    if (e.key === 'z') {
      e.preventDefault();
      undo();
      return;
    }
    if (e.key === 'c' && S.selectedId !== null) {
      e.preventDefault();
      const cell = S.cells.find(c => c.id === S.selectedId);
      if (cell) S.clipboard = { type: cell.type, code: cell.code };
      setMsg('copied cell', 'ok');
      return;
    }
    if (e.key === 'v' && S.clipboard) {
      e.preventDefault();
      const newCell = addCellWithUndo(S.clipboard.type, S.clipboard.code, S.selectedId);
      selectCell(newCell.id);
      if (S.clipboard.type === 'code' && S.cells.some(c => c.type === 'code')) runAll();
      return;
    }
    if (e.key === 'x' && S.selectedId !== null) {
      // cut = copy + delete
      e.preventDefault();
      const cell = S.cells.find(c => c.id === S.selectedId);
      if (cell) S.clipboard = { type: cell.type, code: cell.code };
      const idx = S.cells.findIndex(c => c.id === S.selectedId);
      const nextId = idx < S.cells.length - 1 ? S.cells[idx + 1].id
                   : idx > 0 ? S.cells[idx - 1].id : null;
      deleteCellWithUndo(S.selectedId);
      if (nextId !== null) selectCell(nextId);
      setMsg('cut cell', 'ok');
      return;
    }
    if (e.key === 'h' && S.selectedId !== null) {
      e.preventDefault();
      const cell = S.cells.find(c => c.id === S.selectedId);
      if (cell) cell.el.classList.toggle('collapsed');
      return;
    }
    if (e.key === 'l') {
      e.preventDefault();
      const on = getSettings().lineNumbers === 'on';
      applyLineNumbers(!on);
      setMsg(on ? 'line numbers off' : 'line numbers on', 'ok');
      return;
    }
    if (e.key === 'p') {
      e.preventDefault();
      togglePresent();
      return;
    }
    if (e.key === 'm' && S.selectedId !== null) {
      e.preventDefault();
      convertCell(S.selectedId, 'md');
      return;
    }
    if (e.key === 'y' && S.selectedId !== null) {
      e.preventDefault();
      convertCell(S.selectedId, 'code');
      return;
    }
    if (e.key === 's' && S.selectedId !== null) {
      e.preventDefault();
      convertCell(S.selectedId, 'css');
      return;
    }
    if (e.key === 't' && S.selectedId !== null) {
      e.preventDefault();
      convertCell(S.selectedId, 'html');
      return;
    }
  }

  // global: F1 help overlay
  if (e.key === 'F1') {
    e.preventDefault();
    $('#helpOverlay').classList.toggle('visible');
    return;
  }

  // close presentation mode on Escape
  if (e.key === 'Escape' && document.body.classList.contains('presenting')) {
    togglePresent();
    e.stopImmediatePropagation();
    return;
  }

  // close settings on Escape if visible
  if (e.key === 'Escape' && $('#settingsOverlay').classList.contains('visible')) {
    toggleSettings();
    e.stopImmediatePropagation();
    return;
  }

  // close help on Escape if visible
  if (e.key === 'Escape' && $('#helpOverlay').classList.contains('visible')) {
    $('#helpOverlay').classList.remove('visible');
    e.stopImmediatePropagation();
    return;
  }

  // global: Ctrl+S / Cmd+S
  if (e.key === 's' && (e.ctrlKey || e.metaKey)) {
    e.preventDefault();
    saveNotebook();
  }
});

// click to dismiss help
$('#helpOverlay').addEventListener('click', (e) => {
  if (e.target === $('#helpOverlay')) $('#helpOverlay').classList.remove('visible');
});

// click to select + close trays
document.addEventListener('click', (e) => {
  // close action trays if clicking outside their wrapper (wrapper = parent div with tray + button)
  const addTray = document.querySelector('.action-add-tray');
  const moreTray = document.querySelector('.action-more-tray');
  if (addTray && addTray.classList.contains('open') && !addTray.parentElement.contains(e.target)) {
    addTray.classList.remove('open');
  }
  if (moreTray && moreTray.classList.contains('open') && !moreTray.parentElement.contains(e.target)) {
    moreTray.classList.remove('open');
  }
  // close cell type pickers if clicking outside
  if (!e.target.closest('.cell-type-picker') && !e.target.closest('.cell-type')) {
    document.querySelectorAll('.cell-type-picker.open').forEach(el => el.classList.remove('open'));
  }
  // close cell insert pickers if clicking outside
  if (!e.target.closest('.cell-insert-picker')) {
    document.querySelectorAll('.cell-insert-picker').forEach(el => el.remove());
  }
  // close toolbar overflow menu if clicking outside
  const tbOverflow = document.querySelector('.toolbar-overflow');
  if (tbOverflow && tbOverflow.classList.contains('open') && !tbOverflow.contains(e.target)) {
    tbOverflow.classList.remove('open');
  }
  // close save tray if clicking outside
  const saveTray = document.getElementById('saveTray');
  if (saveTray && saveTray.classList.contains('open') && !saveTray.parentElement.contains(e.target)) {
    saveTray.classList.remove('open');
  }

  const cellEl = e.target.closest('.cell');
  if (cellEl) {
    const id = parseInt(cellEl.dataset.id);
    selectCell(id);
  }
});

// late import to avoid circular dependency at module load time

// -- goto.js --

// ── GOTO ── @optional

function parseGoto(code) {
  const m = code.match(/^\s*\/\/\s*%goto\b\s*(.*)/m);
  if (!m) return null;
  return m[1].trim() || '';
}

const MAX_VISITS = 1000;
let visits = {};

window._dagStart = function() {
  visits = {};
  window._lastGotoTarget = null;
};

window._beforeExec = function(cell) {
  const target = parseGoto(cell.code);
  if (target !== null) {
    S.scope.__goto = target;
    cell.defines.add('__goto');
  } else {
    delete S.scope.__goto;
  }
};

window._afterExec = function(cell, index) {
  const gotoTarget = S.scope.__goto;
  delete S.scope.__goto;
  window._lastGotoTarget = null;

  if (!gotoTarget) return -1;

  // resolve by cellName
  const targetIdx = S.cells.findIndex(c => parseCellName(c.code) === gotoTarget);
  if (targetIdx < 0) {
    const out = cell.el.querySelector('.cell-output');
    if (out) {
      out.appendChild(document.createTextNode('\ngoto: cell \u201c' + gotoTarget + '\u201d not found'));
      out.classList.add('error');
    }
    return -1;
  }

  // loop protection
  const key = index + ':' + targetIdx;
  visits[key] = (visits[key] || 0) + 1;
  if (visits[key] > MAX_VISITS) {
    const out = cell.el.querySelector('.cell-output');
    if (out) {
      out.appendChild(document.createTextNode('\ngoto: loop limit reached (' + MAX_VISITS + ' iterations)'));
      out.classList.add('error');
    }
    return -1;
  }

  window._lastGotoTarget = targetIdx;
  return targetIdx;
};

// -- size-compare.js --

// ── SIZE COMPARISON ── @optional

const SIZE_MEDIA = [
  [4096, 'an Atari 2600 cartridge'],
  [49152, 'a ZX Spectrum tape'],
  [73728, 'Apollo AGC rope memory'],
  [81920, 'an 8\u2033 floppy (SS/SD)'],
  [262144, 'an NES cartridge'],
  [368640, 'a 5.25\u2033 floppy (DS/DD)'],
  [737280, 'a 3.5\u2033 floppy (DS/DD)'],
  [1228800, 'a 5.25\u2033 floppy (DS/HD)'],
  [1474560, 'a 3.5\u2033 floppy (DS/HD)'],
];

function sizeCompare(bytes) {
  if (!window._sizeCompare) return '';
  for (const [size, name] of SIZE_MEDIA) {
    if (bytes <= size) return 'fits on ' + name;
  }
  const n = Math.ceil(bytes / 1474560);
  return n + '\u00d7 3.5\u2033 floppies';
}

function applySizeCompare(val) {
  const on = val === true || val === 'true' || val === 'on';
  window._sizeCompare = on;
  const el = $('#setSizeCompare');
  if (el) el.value = on ? 'on' : 'off';
  updateStatus();
}

function applySizeCompareRef(val) {
  window._sizeCompareRef = val === 'content' ? 'content' : 'total';
  const el = $('#setSizeCompareRef');
  if (el) el.value = window._sizeCompareRef;
  updateStatus();
}

// inject settings rows before modules section
(function() {
  const panel = $('#settingsPanel');
  if (!panel) return;
  const headings = panel.querySelectorAll('h2');
  const modulesH2 = headings[headings.length - 1];
  if (!modulesH2) return;

  const h2 = document.createElement('h2');
  h2.textContent = 'status bar';
  modulesH2.before(h2);

  const refRow = document.createElement('div');
  refRow.className = 'settings-row';
  refRow.innerHTML = '<label>size reference</label>' +
    '<select id="setSizeCompareRef" onchange="applySizeCompareRef(this.value)">' +
    '<option value="total" selected>total file</option>' +
    '<option value="content">content only</option></select>';
  modulesH2.before(refRow);

  const row = document.createElement('div');
  row.className = 'settings-row';
  row.innerHTML = '<label>size comparison</label>' +
    '<select id="setSizeCompare" onchange="applySizeCompare(this.value)">' +
    '<option value="off">off</option><option value="on" selected>on</option></select>';
  modulesH2.before(row);

  window._sizeCompare = true;
  window._sizeCompareRef = 'total';
})();

// -- globals.js --

// ── GLOBAL BINDINGS ──
// This module wires exported functions to window.* for use by onclick/onchange
// handlers in template HTML and dynamically generated markup.
// Modules stay pure (no side effects, no window assignments).











// state
window.$ = $;
window.S = S;

// editor
window.toggleAutorun = toggleAutorun;

// settings
window.toggleSettings = toggleSettings;
window.togglePresent = togglePresent;
window.applyTheme = applyTheme;
window.applyFontSize = applyFontSize;
window.applyWidth = applyWidth;
window.applyLineNumbers = applyLineNumbers;
window.applyHeader = applyHeader;
window.applyExecMode = applyExecMode;
window.applyRunOnLoad = applyRunOnLoad;
window.applyShowToggle = applyShowToggle;
window.applyGlobalExecMode = applyGlobalExecMode;
window.applyGlobalRunOnLoad = applyGlobalRunOnLoad;

// update
window.toggleUpdate = toggleUpdate;
window.checkForUpdate = checkForUpdate;
window.applyOnlineUpdate = applyOnlineUpdate;
window.proceedUpdate = proceedUpdate;
window.cancelUpdate = cancelUpdate;
window.updateFromFile = updateFromFile;

// save
window.saveNotebook = saveNotebook;
window.savePackedNotebook = savePackedNotebook;
window.setSaveMode = setSaveMode;
window.toggleSaveTray = toggleSaveTray;
window.exportAsTxt = exportAsTxt;

// exec
window.runAll = runAll;

// ui
window.insertAt = insertAt;

// find
window.openFind = openFind;
window.closeFind = closeFind;

// stdlib
window.__auditable_registerProvider = registerProvider;

// keyboard / toolbar
window.addCellWithUndo = addCellWithUndo;
window.deleteCellWithUndo = deleteCellWithUndo;
window.runSelectedCell = runSelectedCell;
window.toggleToolbarMenu = toggleToolbarMenu;
window.toggleAddTray = toggleAddTray;
window.toggleMoreTray = toggleMoreTray;
window.showInsertPicker = showInsertPicker;
window.toggleTypePicker = toggleTypePicker;
window.collapseAll = collapseAll;
window.expandAll = expandAll;
window.newNotebook = newNotebook;

// -- init.js --

// ── INIT ──

(function init() {
  // detect packed format (meta tag injected by loader)
  const packedMeta = document.querySelector('meta[name="auditable-packed"]');
  if (packedMeta) {
    packedMeta.remove();
    setBadge('packed', 'packed', 'toolbar-badge toolbar-badge-packed');
    setSaveMode('packed');
  }

  if (!loadFromEmbed()) {
    addCell('md', '');
    addCell('code', '');
  }
  S.initialized = true;
})();

// ── AF BRIDGE ──
// When running inside AF shell (iframe), establish postMessage communication.
// No-op when running standalone (window.parent === window).
//
// Message protocol (notebook ↔ AF shell):
//   af:ready          → sent on init with { title }
//   af:serialize      ← received to trigger saveNotebook()
//   af:saved          ← received after save (shows "saved" status)
//   af:setTitle       ← received to update docTitle input
//   af:resize         ← received when iframe becomes visible (recalc textareas)
//   af:titleChanged   → sent when user edits the title
//   af:fileRequest    → sent to request file picker { id, accept }
//   af:fileResult     ← received with picked file { id, file }
//   af:download       → sent to request download { data, filename, mimeType }
//   af:dirty          → sent when notebook has unsaved changes

(function afBridge() {
  if (window.parent === window) return;
  window.__AF_BRIDGE__ = true;

  // register AF-specific providers for file/download
  registerProvider('file', (accept) => {
    return new Promise((resolve) => {
      const id = 'af_file_' + Date.now();
      function handler(e) {
        if (e.data?.type === 'af:fileResult' && e.data.payload?.id === id) {
          window.removeEventListener('message', handler);
          resolve(e.data.payload.file);
        }
      }
      window.addEventListener('message', handler);
      window.parent.postMessage({ type: 'af:fileRequest', payload: { id, accept } }, '*');
    });
  });

  registerProvider('download', (data, filename, mimeType) => {
    const str = typeof data === 'string' ? data : JSON.stringify(data, null, 2);
    const mime = mimeType || (typeof data === 'string' ? 'text/plain' : 'application/json');
    window.parent.postMessage({
      type: 'af:download',
      payload: { data: str, filename, mimeType: mime }
    }, '*');
  });

  const title = document.getElementById('docTitle')?.value || 'untitled';
  window.parent.postMessage({ type: 'af:ready', payload: { title } }, '*');

  window.addEventListener('message', (e) => {
    const msg = e.data;
    if (!msg?.type) return;
    if (msg.type === 'af:serialize') saveNotebook();
    else if (msg.type === 'af:saved') setMsg('saved', 'ok');
    else if (msg.type === 'af:setTitle') {
      const input = document.getElementById('docTitle');
      if (input && msg.payload?.title) input.value = msg.payload.title;
    } else if (msg.type === 'af:resize') {
      // recalculate textarea heights after becoming visible
      document.querySelectorAll('textarea').forEach(ta => {
        ta.style.height = 'auto';
        ta.style.height = ta.scrollHeight + 'px';
        const hl = ta.parentElement?.querySelector('.highlight-layer');
        if (hl) hl.style.height = ta.style.height;
      });
    }
  });

  document.getElementById('docTitle')?.addEventListener('input', () => {
    window.parent.postMessage({
      type: 'af:titleChanged',
      payload: { title: document.getElementById('docTitle').value }
    }, '*');
  });
})();
</script>
</body>
<!-- good luck out there -->
</html>
