<!DOCTYPE html>
<!-- auditable — a reactive computational notebook in a single HTML file -->
<!-- https://github.com/endarthur/auditable — MIT license -->
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Auditable — atra — Wasm kernels</title>
<style>
:root {
  --bg: #0a0a0a;
  --bg1: #111;
  --bg2: #1a1a1a;
  --border: #222;
  --border-hi: #333;
  --fg: #aaa;
  --fg-dim: #555;
  --fg-bright: #ccc;
  --accent: #c89b3c;
  --accent-dim: #8a6c2a;
  --err: #a33;
  --ok: #3a7;
  --mono: 'Courier New', Courier, monospace;
  --editor-font-size: 13px;
}

* { margin: 0; padding: 0; box-sizing: border-box; }

/* scrollbar */
::-webkit-scrollbar { width: 6px; height: 6px; }
::-webkit-scrollbar-track { background: var(--bg); }
::-webkit-scrollbar-thumb { background: var(--border-hi); border-radius: 0; }
::-webkit-scrollbar-thumb:hover { background: var(--fg-dim); }
textarea::-webkit-scrollbar-thumb { background: var(--border); }
@supports (scrollbar-color: auto) {
  * { scrollbar-color: var(--border-hi) var(--bg); scrollbar-width: thin; }
}

html, body {
  background: var(--bg);
  color: var(--fg);
  font-family: var(--mono);
  font-size: 13px;
  line-height: 1.5;
  min-height: 100vh;
}

/* ── TOOLBAR ── */
.toolbar {
  position: sticky;
  top: 0;
  z-index: 100;
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 6px 12px;
  background: var(--bg);
  border-bottom: 1px solid var(--border);
}

.toolbar-title {
  font-size: 11px;
  letter-spacing: 3px;
  text-transform: uppercase;
  color: var(--accent);
  opacity: 0.8;
  user-select: none;
}

.toolbar-sep {
  width: 1px;
  height: 16px;
  background: var(--border);
  margin: 0 4px;
}

.toolbar-filename {
  font-size: 12px;
  color: var(--fg-dim);
  flex: 1;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.toolbar-filename input {
  background: none;
  border: none;
  border-bottom: 1px solid transparent;
  color: var(--fg);
  font-family: var(--mono);
  font-size: 12px;
  outline: none;
  width: 200px;
}
.toolbar-filename input:focus {
  border-bottom-color: var(--accent-dim);
}

button {
  background: var(--bg2);
  border: 1px solid var(--border);
  color: var(--fg-dim);
  font-family: var(--mono);
  font-size: 10px;
  letter-spacing: 1px;
  text-transform: uppercase;
  padding: 4px 10px;
  cursor: pointer;
  transition: border-color 0.15s, color 0.15s;
}
button:hover {
  border-color: var(--border-hi);
  color: var(--fg);
}
button.accent {
  border-color: var(--accent-dim);
  color: var(--accent);
}
button.accent:hover {
  border-color: var(--accent);
}

/* ── TOOLBAR BADGES ── */
.toolbar-badges {
  display: inline-flex;
  gap: 4px;
  margin-left: 6px;
  align-items: center;
}
.toolbar-badge {
  font-size: 9px;
  letter-spacing: 0.5px;
  padding: 1px 4px;
  border-radius: 2px;
  user-select: none;
  opacity: 0.85;
}
.toolbar-badge-signed {
  color: var(--ok);
  border: 1px solid color-mix(in srgb, var(--ok) 40%, transparent);
}
.toolbar-badge-packed {
  color: var(--fg-dim);
  border: 1px solid var(--border);
}

/* ── SPLIT SAVE BUTTON ── */
.save-split {
  display: inline-flex;
  position: relative;
}
.save-split button:first-child {
  border-right: none;
  border-radius: 3px 0 0 3px;
}
.save-caret {
  border-radius: 0 3px 3px 0 !important;
  padding: 4px 4px !important;
  font-size: 10px;
}
.save-tray {
  display: none;
  position: absolute;
  right: 0;
  top: 100%;
  margin-top: 4px;
  background: var(--bg);
  border: 1px solid var(--border);
  z-index: 100;
  min-width: 120px;
}
.save-tray.open { display: flex; flex-direction: column; }
.save-tray button {
  border: none;
  border-bottom: 1px solid var(--border);
  text-align: left;
  padding: 6px 10px;
  white-space: nowrap;
  font-size: 12px;
}
.save-tray button:last-child { border-bottom: none; }
.save-tray button:hover { background: var(--bg-hi); }

/* ── TRANSPORT CONTROLS ── */
.transport {
  display: inline-flex;
  border: 1px solid var(--border);
}
.transport button {
  border: none;
  border-right: 1px solid var(--border);
  padding: 4px 8px;
}
.transport button:last-child { border-right: none; }
.transport button.autorun-on {
  background: #33aa77;
  color: #111;
}
.transport button.autorun-off {
  background: #dd4444;
  color: #111;
}

.toolbar-right {
  margin-left: auto;
  display: flex;
  align-items: center;
  gap: 8px;
}

/* ── TOOLBAR OVERFLOW MENU ── */
.toolbar-overflow {
  position: relative;
  display: inline-block;
}
.toolbar-overflow-tray {
  display: none;
  position: absolute;
  top: 100%;
  right: 0;
  background: var(--bg1);
  border: 1px solid var(--border);
  z-index: 200;
  flex-direction: column;
  min-width: 140px;
}
.toolbar-overflow-tray button {
  border: none;
  border-bottom: 1px solid var(--border);
  text-align: left;
  padding: 8px 12px;
  background: var(--bg1);
  white-space: nowrap;
}
.toolbar-overflow-tray button:last-child { border-bottom: none; }
.toolbar-overflow-tray button:hover { background: var(--bg2); color: var(--fg-bright); }
.toolbar-overflow.open .toolbar-overflow-tray { display: flex; }

/* ── BOTTOM ACTION BAR ── */
.action-bar { display: none; }

/* ── ACTION BAR TRAYS ── */
.action-add-tray,
.action-more-tray {
  display: none;
  position: absolute;
  bottom: 100%;
  background: var(--bg1);
  border: 1px solid var(--border);
  flex-direction: column;
  z-index: 200;
}
.action-add-tray { left: 0; min-width: 120px; }
.action-more-tray { right: 0; min-width: 120px; }
.action-add-tray.open,
.action-more-tray.open { display: flex; }
.action-add-tray button,
.action-more-tray button {
  min-height: 48px;
  border: none;
  border-bottom: 1px solid var(--border);
  text-align: left;
  padding: 8px 16px;
  background: var(--bg1);
  color: var(--fg);
  font-family: var(--mono);
  font-size: 12px;
  letter-spacing: 1px;
  text-transform: uppercase;
}
.action-add-tray button:last-child,
.action-more-tray button:last-child { border-bottom: none; }
.action-add-tray button:hover,
.action-more-tray button:hover { background: var(--bg2); color: var(--fg-bright); }
.action-more-tray button.active-mode { color: var(--accent); }

/* ── CELL INSERT / CONVERT BUTTONS (touch only) ── */
.cell-insert { display: none; }
.cell-convert { display: none; }

/* ── CELL TYPE PICKER ── */
.cell-type-picker {
  display: none;
  gap: 2px;
  padding: 2px 8px 4px;
}
.cell-type-picker.open { display: flex; }
.cell-type-picker button {
  font-size: 9px;
  padding: 2px 8px;
  background: var(--bg2);
  border: 1px solid var(--border);
  color: var(--fg-dim);
  font-family: var(--mono);
  letter-spacing: 1px;
  text-transform: uppercase;
}
.cell-type-picker button:hover {
  border-color: var(--accent-dim);
  color: var(--accent);
}

/* ── CELL INSERT PICKER ── */
.cell-insert-picker {
  display: none;
  gap: 2px;
  position: absolute;
  background: var(--bg1);
  border: 1px solid var(--border);
  padding: 4px;
  z-index: 200;
}
.cell-insert-picker.open { display: flex; }
.cell-insert-picker button {
  font-size: 9px;
  padding: 4px 8px;
  background: var(--bg2);
  border: 1px solid var(--border);
  color: var(--fg-dim);
  font-family: var(--mono);
  letter-spacing: 1px;
  text-transform: uppercase;
  min-height: 36px;
}
.cell-insert-picker button:hover {
  border-color: var(--accent-dim);
  color: var(--accent);
}

/* ── TOOLBAR STATUS (mobile cell count) ── */
.toolbar-status { display: none; }

/* ── NOTEBOOK ── */
.notebook {
  max-width: 860px;
  margin: 0 auto;
  padding: 16px 12px 120px;
}

/* ── CELL ── */
.cell {
  position: relative;
  margin: 6px 0;
  border-left: 2px solid transparent;
  transition: border-color 0.15s;
}
.cell:hover {
  border-left-color: var(--border-hi);
}
.cell.selected {
  border-left-color: var(--accent);
}
.cell.selected .cell-header {
  opacity: 1;
}
.cell.manual .cell-type::after {
  content: ' \00b7 manual';
  color: var(--accent-dim);
}
.cell.stale {
  border-left-color: var(--accent-dim);
}
.cell.error {
  border-left-color: var(--err);
}
.cell.fresh {
  border-left-color: var(--ok);
  transition: border-color 0.5s;
}

/* cell header — type label + controls */
.cell-header {
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 2px 8px;
  opacity: 0;
  transition: opacity 0.15s;
  user-select: none;
}
.cell:hover .cell-header,
.cell:focus-within .cell-header {
  opacity: 1;
}

.cell.collapsed .cell-code,
.cell.collapsed .cell-md-edit,
.cell.collapsed .cell-css-edit,
.cell.collapsed .cell-html-edit {
  display: none !important;
}
.cell.collapsed .cell-type::before {
  content: '\25b8 ';
}
.cell:not(.collapsed) .cell-type::before {
  content: '\25be ';
}
.cell-type {
  cursor: pointer;
  user-select: none;
  font-size: 9px;
  letter-spacing: 2px;
  text-transform: uppercase;
  color: var(--fg-dim);
}
.cell[data-type="code"] .cell-type { color: #7aabcf; }
.cell[data-type="css"]  .cell-type { color: #d4955a; }
.cell[data-type="html"] .cell-type { color: #6dbfb8; }
.cell[data-type="md"]   .cell-type { color: var(--fg-dim); }

.cell-btn {
  background: none;
  border: none;
  color: var(--fg-dim);
  font-family: var(--mono);
  font-size: 10px;
  padding: 0 4px;
  cursor: pointer;
}
.cell-btn:hover { color: var(--fg); }
.cell-btn.del:hover { color: var(--err); }

/* ── CODE CELL ── */
.cell-code {
  position: relative;
}

.editor-wrap {
  --gutter: 36px;
  position: relative;
  overflow: hidden;
}

.line-numbers {
  position: absolute;
  top: 0; left: 0; bottom: 0;
  width: var(--gutter);
  padding: 8px 4px 8px 0;
  font-family: var(--mono);
  font-size: var(--editor-font-size);
  line-height: 1.5;
  text-align: right;
  color: var(--fg-dim);
  background: var(--bg1);
  border-right: 1px solid var(--border);
  border-top: 1px solid var(--border);
  border-bottom: 1px solid var(--border);
  border-left: 1px solid var(--border);
  overflow: hidden;
  z-index: 3;
  pointer-events: none;
  white-space: pre;
  box-sizing: border-box;
}

:root.hide-line-numbers .line-numbers { display: none; }
:root.hide-line-numbers .editor-wrap { --gutter: 0px; }

.cell-code textarea {
  display: block;
  width: 100%;
  background: transparent;
  border: 1px solid var(--border);
  color: var(--fg-bright);
  caret-color: var(--fg-bright);
  font-family: var(--mono);
  font-size: var(--editor-font-size);
  line-height: 1.5;
  padding: 8px 10px 8px calc(var(--gutter) + 10px);
  resize: vertical;
  min-height: 38px;
  outline: none;
  tab-size: 2;
  white-space: pre;
  overflow-x: auto;
  position: relative;
  z-index: 2;
  -webkit-text-fill-color: transparent;
}
.cell-code textarea::selection {
  -webkit-text-fill-color: var(--fg-bright);
  background: rgba(200,155,60,0.25);
}
.cell-code textarea:focus + .highlight-layer {
  border-color: var(--border-hi);
}
.cell-code textarea:focus ~ .line-numbers {
  border-color: var(--border-hi);
}

.highlight-layer {
  position: absolute;
  top: 0; left: 0; right: 0; bottom: 0;
  background: var(--bg1);
  border: 1px solid var(--border);
  padding: 8px 10px 8px calc(var(--gutter) + 10px);
  font-family: var(--mono);
  font-size: var(--editor-font-size);
  line-height: 1.5;
  tab-size: 2;
  white-space: pre;
  overflow: hidden;
  z-index: 1;
  pointer-events: none;
  color: var(--fg-bright);
}

/* syntax tokens */
.hl-kw { color: #7a9ec7; }
.hl-str { color: var(--accent); }
.hl-num { color: #8cb878; }
.hl-cmt { color: #555; font-style: italic; }
.hl-fn { color: #c4a6d0; }
.hl-const { color: #d09870; }
.hl-op { color: #888; }
.hl-punc { color: #666; }

/* CSS syntax tokens */
.hl-atrule { color: #7aabcf; }
.hl-prop { color: #7aabcf; }
.hl-sel { color: #d4955a; }
.hl-color { color: var(--accent); }
.hl-important { color: #d4555a; font-weight: bold; }

/* HTML syntax tokens */
.hl-tag { color: #6dbfb8; }
.hl-attr { color: #7aabcf; }
.hl-expr { color: var(--accent); }

.hl-swatch {
  display: inline-block;
  width: 10px;
  height: 10px;
  border: 1px solid var(--border-hi);
  vertical-align: middle;
  margin-right: 2px;
  cursor: pointer;
  pointer-events: auto;
}

.cell-output {
  padding: 4px 10px;
  min-height: 0;
  font-size: 12px;
  color: var(--fg);
  white-space: pre-wrap;
  word-break: break-all;
}
.cell-output:empty {
  display: none;
}
.cell-output.error {
  color: var(--err);
}

.cell-output canvas {
  max-width: 100%;
  display: block;
  margin: 4px 0;
}

.cell-output table {
  border-collapse: collapse;
  font-size: 11px;
  margin: 4px 0;
}
.cell-output table th,
.cell-output table td {
  border: 1px solid var(--border);
  padding: 2px 8px;
}
.cell-output table th {
  color: var(--accent);
  font-weight: normal;
  text-transform: uppercase;
  font-size: 9px;
  letter-spacing: 1px;
}

/* ── CSS CELL ── */
.cell-css-view {
  padding: 6px 10px;
  color: var(--fg-dim);
  cursor: text;
  min-height: 24px;
  font-size: 11px;
  font-style: italic;
}
.cell-css-view:empty::before {
  content: '(empty stylesheet)';
}

.cell-css-edit textarea {
  display: block;
  width: 100%;
  background: transparent;
  border: 1px solid var(--border);
  color: var(--fg-bright);
  caret-color: var(--fg-bright);
  font-family: var(--mono);
  font-size: var(--editor-font-size);
  line-height: 1.5;
  padding: 8px 10px 8px calc(var(--gutter) + 10px);
  resize: vertical;
  min-height: 38px;
  outline: none;
  tab-size: 2;
  white-space: pre;
  overflow-x: auto;
  position: relative;
  z-index: 2;
  -webkit-text-fill-color: transparent;
}
.cell-css-edit textarea::selection {
  -webkit-text-fill-color: var(--fg-bright);
  background: rgba(200,155,60,0.25);
}
.cell-css-edit textarea:focus + .highlight-layer {
  border-color: var(--border-hi);
}
.cell-css-edit textarea:focus ~ .line-numbers {
  border-color: var(--border-hi);
}

/* ── HTML CELL ── */
.cell-html-view {
  padding: 6px 10px;
  color: var(--fg);
  cursor: text;
  min-height: 24px;
}
.cell-html-view:empty::before {
  content: '(empty html template)';
  color: var(--fg-dim);
  font-style: italic;
  font-size: 11px;
}
.cell-html-edit textarea {
  display: block;
  width: 100%;
  background: transparent;
  border: 1px solid var(--border);
  color: var(--fg-bright);
  caret-color: var(--fg-bright);
  font-family: var(--mono);
  font-size: var(--editor-font-size);
  line-height: 1.5;
  padding: 8px 10px 8px calc(var(--gutter) + 10px);
  resize: vertical;
  min-height: 38px;
  outline: none;
  tab-size: 2;
  white-space: pre;
  overflow-x: auto;
  position: relative;
  z-index: 2;
  -webkit-text-fill-color: transparent;
}
.cell-html-edit textarea::selection {
  -webkit-text-fill-color: var(--fg-bright);
  background: rgba(200,155,60,0.25);
}
.cell-html-edit textarea:focus + .highlight-layer {
  border-color: var(--border-hi);
}
.cell-html-edit textarea:focus ~ .line-numbers {
  border-color: var(--border-hi);
}

/* ── MARKDOWN CELL ── */
.cell-md-view {
  padding: 6px 10px;
  color: var(--fg);
  cursor: text;
  min-height: 24px;
}
.cell-md-view:empty::before {
  content: '(empty markdown cell)';
  color: var(--fg-dim);
  font-style: italic;
  font-size: 11px;
}
.cell-md-view h1, .cell-md-view h2, .cell-md-view h3 {
  color: var(--fg-bright);
  font-weight: normal;
  margin: 4px 0;
}
.cell-md-view h1 { font-size: 18px; letter-spacing: 2px; }
.cell-md-view h2 { font-size: 15px; letter-spacing: 1px; color: var(--accent); }
.cell-md-view h3 { font-size: 13px; }
.cell-md-view p { margin: 4px 0; }
.cell-md-view code {
  background: var(--bg2);
  padding: 1px 4px;
  font-size: 12px;
}
.cell-md-view strong { color: var(--fg-bright); }
.cell-md-view em { font-style: italic; }
.cell-md-view a { color: var(--accent); }

.cell-md-edit textarea {
  display: block;
  width: 100%;
  background: var(--bg1);
  border: 1px solid var(--border);
  color: var(--fg-bright);
  font-family: var(--mono);
  font-size: var(--editor-font-size);
  line-height: 1.5;
  padding: 8px 10px;
  resize: vertical;
  min-height: 38px;
  outline: none;
}

/* ── PRESENTATION MODE ── */
body.presenting .toolbar { display: none; }
body.presenting .cell-header { display: none; }
body.presenting .cell-code { display: none; }
body.presenting .cell-md-edit { display: none !important; }
body.presenting .cell-css-edit { display: none; }
body.presenting .cell-css-view { display: none; }
body.presenting .cell-html-edit { display: none !important; }
body.presenting .cell { border-left: none; margin: 0; }
body.presenting .cell:hover { border-left: none; }
body.presenting .insert-bar { display: none; }
body.presenting .notebook { max-width: 900px; padding-top: 40px; }
body.presenting .statusbar { display: none; }
body.presenting .present-hidden { display: none; }
body.presenting .present-exit {
  display: block;
  position: fixed;
  top: 12px;
  right: 12px;
  z-index: 200;
}
.present-exit { display: none; }

/* ── INSERT BAR (between cells) ── */
.insert-bar {
  height: 16px;
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  margin: -6px 0;
}
.insert-bar::before {
  content: '';
  position: absolute;
  left: 20px;
  right: 20px;
  top: 50%;
  height: 1px;
  background: var(--border);
  opacity: 0;
  transition: opacity 0.15s;
}
.insert-bar:hover::before { opacity: 1; }
.insert-bar .insert-btns {
  display: flex;
  gap: 4px;
  opacity: 0;
  transition: opacity 0.15s;
  position: relative;
  z-index: 10;
}
.insert-bar:hover .insert-btns { opacity: 1; }
.insert-bar .insert-btns button {
  font-size: 9px;
  padding: 1px 8px;
  background: var(--bg);
  border: 1px solid var(--border);
  color: var(--fg-dim);
}
.insert-bar .insert-btns button:hover {
  border-color: var(--accent-dim);
  color: var(--accent);
}

/* ── ADD CELL BAR ── */
.add-bar {
  display: flex;
  justify-content: center;
  gap: 8px;
  padding: 6px 0;
  opacity: 0;
  transition: opacity 0.15s;
}
.notebook:hover .add-bar,
.add-bar.visible {
  opacity: 0.5;
}
.add-bar:hover {
  opacity: 1 !important;
}

/* ── WIDGET CLASSES ── */
.cell-widget {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 2px 0;
  font-size: 12px;
  color: var(--fg-dim);
}
.cell-widget-label {
  min-width: 80px;
  font-size: 10px;
  letter-spacing: 1px;
  text-transform: uppercase;
  color: var(--fg-dim);
}
.cell-widget input[type="range"] {
  flex: 1;
  accent-color: var(--accent);
  max-width: 200px;
}
.cell-widget select {
  background: var(--bg2);
  border: 1px solid var(--border);
  color: var(--fg-bright);
  font-family: var(--mono);
  font-size: 12px;
  padding: 2px 4px;
}
.cell-widget input[type="checkbox"] {
  accent-color: var(--accent);
}
.cell-widget input[type="text"] {
  background: var(--bg2);
  border: 1px solid var(--border);
  color: var(--fg-bright);
  font-family: var(--mono);
  font-size: 12px;
  padding: 2px 6px;
  flex: 1;
  max-width: 200px;
}
.cell-widget-val {
  min-width: 40px;
  text-align: right;
  color: var(--fg-bright);
  font-size: 12px;
}

/* ── STATUS BAR ── */
.statusbar {
  position: fixed;
  bottom: 0;
  left: 0;
  right: 0;
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 4px 12px;
  background: var(--bg);
  border-top: 1px solid var(--border);
  font-size: 10px;
  color: var(--fg-dim);
  letter-spacing: 1px;
  z-index: 100;
}
.statusbar .status-size { color: var(--fg-dim); }
.statusbar .status-cells { color: var(--fg-dim); }
.statusbar .status-msg { flex: 1; text-align: right; }
.statusbar .status-msg.ok { color: var(--ok); }
.statusbar .status-msg.warn { color: var(--accent); }
.statusbar .status-msg.err { color: var(--err); }
.statusbar .status-attr { margin-left: auto; display: flex; align-items: center; gap: 6px; }
.statusbar .status-attr a {
  color: var(--fg-dim);
  text-decoration: none;
  transition: color 0.2s;
}
.statusbar .status-attr a:hover { color: var(--accent); }
.statusbar .status-attr svg { vertical-align: middle; }

/* ── EMPTY STATE ── */
.empty-state {
  text-align: center;
  padding: 80px 20px;
  color: var(--fg-dim);
}
.empty-state .logo {
  font-size: 11px;
  letter-spacing: 4px;
  text-transform: uppercase;
  color: var(--accent);
  margin-bottom: 16px;
}
.empty-state .tagline {
  font-size: 11px;
  margin-bottom: 24px;
}

.help-overlay {
  display: none;
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.85);
  z-index: 1000;
  overflow-y: auto;
  padding: 40px;
}
.help-overlay.visible { display: flex; justify-content: center; }
.help-content {
  position: relative;
  max-width: 600px;
  width: 100%;
  color: var(--fg);
  font-family: var(--mono);
  font-size: 13px;
  line-height: 1.8;
}
.help-content h2 {
  color: var(--accent);
  font-size: 14px;
  letter-spacing: 2px;
  text-transform: uppercase;
  margin: 24px 0 8px 0;
  border-bottom: 1px solid var(--border);
  padding-bottom: 4px;
}
.help-content h2:first-child { margin-top: 0; }
.help-row {
  display: flex;
  justify-content: space-between;
  padding: 2px 0;
}
.help-key {
  background: var(--bg2);
  border: 1px solid var(--border);
  border-radius: 3px;
  padding: 0 6px;
  font-size: 11px;
  color: var(--fg-bright);
  min-width: 80px;
  text-align: center;
  display: inline-block;
}
.help-desc { color: var(--fg); }
.help-close {
  color: var(--accent-dim);
  font-size: 11px;
  text-align: center;
  margin-top: 24px;
  letter-spacing: 1px;
}
.help-close-btn {
  position: absolute;
  top: 0;
  right: 0;
  background: none;
  border: 1px solid var(--border);
  color: var(--fg-dim);
  font-size: 20px;
  width: 44px;
  height: 44px;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 0;
  cursor: pointer;
  text-transform: none;
  letter-spacing: 0;
}
.help-close-btn:hover {
  border-color: var(--err);
  color: var(--err);
}

/* ── SETTINGS PANEL ── */
.settings-overlay {
  display: none;
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.5);
  z-index: 1000;
}
.settings-overlay.visible { display: block; }
.settings-panel {
  display: none;
  position: fixed;
  top: 0;
  right: 0;
  bottom: 0;
  width: 280px;
  max-width: 90vw;
  background: var(--bg1);
  border-left: 1px solid var(--border);
  padding: 20px;
  overflow-y: auto;
  z-index: 1001;
  font-family: var(--mono);
  font-size: 12px;
  color: var(--fg);
}
.settings-close {
  position: absolute;
  top: 12px;
  right: 12px;
  background: none;
  border: 1px solid var(--border);
  color: var(--fg-dim);
  font-size: 18px;
  width: 32px;
  height: 32px;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 0;
  cursor: pointer;
  text-transform: none;
  letter-spacing: 0;
}
.settings-close:hover {
  border-color: var(--err);
  color: var(--err);
}

.settings-panel h2 {
  color: var(--accent);
  font-size: 11px;
  letter-spacing: 2px;
  text-transform: uppercase;
  margin: 20px 0 10px 0;
}
.settings-panel h2:first-child { margin-top: 0; }
.settings-row {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 6px 0;
}
.settings-row label { color: var(--fg-dim); font-size: 11px; }
.settings-row select,
.settings-row input[type="range"] {
  background: var(--bg2);
  border: 1px solid var(--border);
  color: var(--fg-bright);
  font-family: var(--mono);
  font-size: 11px;
  padding: 2px 4px;
}
.settings-row input[type="range"] {
  accent-color: var(--accent);
  width: 100px;
}
.settings-val {
  min-width: 30px;
  text-align: right;
  color: var(--fg-bright);
  font-size: 11px;
}

/* ── SETTINGS DESCRIPTIONS ── */
.settings-desc {
  color: var(--fg-dim);
  font-size: 10px;
  line-height: 1.5;
  padding: 4px 0 8px;
}
.settings-desc strong {
  color: var(--fg);
}

/* ── HIDE RUN TOGGLE ── */
html.hide-run-toggle #autorunBtn,
html.hide-run-toggle #autorunBtnMobile { display: none; }

/* ── MODULE LIST (settings panel) ── */
.module-row {
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 4px 0;
  font-size: 11px;
}
.module-url {
  flex: 1;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  color: var(--fg);
}
.module-info {
  color: var(--fg-dim);
  white-space: nowrap;
  font-size: 10px;
}
.module-remove {
  background: none;
  border: none;
  color: var(--fg-dim);
  font-size: 14px;
  padding: 0 2px;
  cursor: pointer;
  line-height: 1;
  text-transform: none;
  letter-spacing: 0;
}
.module-remove:hover { color: var(--err); }
.module-total {
  padding: 4px 0;
  font-size: 10px;
  color: var(--fg-dim);
  border-top: 1px solid var(--border);
  text-align: right;
}
.module-empty {
  color: var(--fg-dim);
  font-size: 11px;
  font-style: italic;
  padding: 4px 0;
}
/* ── UPDATE PANEL ── */
.update-overlay {
  display: none;
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.5);
  z-index: 1000;
}
.update-overlay.visible { display: block; }
.update-panel {
  display: none;
  position: fixed;
  top: 0;
  right: 0;
  bottom: 0;
  width: 280px;
  max-width: 90vw;
  background: var(--bg1);
  border-left: 1px solid var(--border);
  padding: 20px;
  overflow-y: auto;
  z-index: 1001;
  font-family: var(--mono);
  font-size: 12px;
  color: var(--fg);
}
.update-panel h2 {
  color: var(--accent);
  font-size: 11px;
  letter-spacing: 2px;
  text-transform: uppercase;
  margin: 0 0 12px 0;
}
.update-panel .settings-row {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 6px 0;
}
.update-panel .settings-row label { color: var(--fg-dim); font-size: 11px; }
.update-actions {
  display: flex;
  flex-direction: column;
  gap: 6px;
  padding: 8px 0;
}
.update-actions button {
  width: 100%;
  padding: 8px 10px;
}
.update-status {
  font-size: 11px;
  padding: 8px 0;
  line-height: 1.5;
}
.update-status strong { color: var(--fg-bright); }
.update-status button {
  display: block;
  width: 100%;
  margin-top: 8px;
  padding: 8px 10px;
  border-color: var(--accent-dim);
  color: var(--accent);
}
.update-status button:hover {
  border-color: var(--accent);
}
.update-ok { color: var(--ok); }
.update-err { color: var(--err); }
.update-warn { color: var(--accent); }
.update-available { color: var(--fg); }
.update-notes {
  color: var(--fg-dim);
  font-size: 11px;
  padding: 6px 0;
  max-height: 120px;
  overflow-y: auto;
  line-height: 1.4;
}
.update-notes p { margin: 0 0 4px; }
.update-notes ul { margin: 2px 0; padding-left: 16px; }
.update-notes li { margin: 1px 0; }
.update-notes h1, .update-notes h2, .update-notes h3 { font-size: 11px; margin: 4px 0 2px; color: var(--fg); }
.update-confirm {
  display: flex;
  gap: 8px;
  padding: 6px 0;
}
.update-confirm button { width: auto; }
.update-sig {
  font-size: 11px;
}
.update-key-truncated {
  cursor: pointer;
}
.update-key-truncated:hover {
  color: var(--accent);
}
.update-key-expanded {
  word-break: break-all;
  user-select: all;
  cursor: pointer;
  color: var(--fg-bright);
}
/* ── UPDATE BUTTON IN OVERFLOW TRAY ── */
.toolbar-update-btn {
  color: var(--accent) !important;
}

.settings-about {
  margin-top: 24px;
  padding-top: 12px;
  border-top: 1px solid var(--border);
  font-size: 11px;
  color: var(--fg-dim);
  display: flex;
  flex-direction: column;
  gap: 2px;
}
.settings-about a {
  color: var(--accent);
  text-decoration: none;
}
.settings-about a:hover { text-decoration: underline; }

/* ── FIND BAR ── */
.find-bar {
  display: none;
  flex-direction: column;
  position: sticky;
  top: 33px;
  z-index: 99;
  float: right;
  max-width: 400px;
  width: 100%;
  background: var(--bg1);
  border: 1px solid var(--border);
  border-top: none;
  padding: 6px 8px;
  gap: 4px;
}
.find-row {
  display: flex;
  align-items: center;
  gap: 4px;
}
.find-replace-row {
  display: none;
  align-items: center;
  gap: 4px;
}
.find-bar.show-replace .find-replace-row { display: flex; }
.find-bar input[type="text"] {
  flex: 1;
  background: var(--bg2);
  border: 1px solid var(--border);
  color: var(--fg-bright);
  font-family: var(--mono);
  font-size: 12px;
  padding: 4px 8px;
  outline: none;
  min-width: 0;
}
.find-bar input[type="text"]:focus {
  border-color: var(--border-hi);
}
.find-count {
  font-size: 10px;
  color: var(--fg-dim);
  white-space: nowrap;
  min-width: 50px;
  text-align: center;
  letter-spacing: 1px;
}
.find-bar button {
  padding: 3px 8px;
  font-size: 10px;
  min-width: 28px;
}
.find-bar button.active {
  color: var(--accent);
  border-color: var(--accent-dim);
}
body.presenting .find-bar { display: none !important; }

/* ── SEARCH OVERLAY ── */
.search-overlay {
  position: absolute;
  top: 0; left: 0; right: 0; bottom: 0;
  padding: 8px 10px 8px calc(var(--gutter) + 10px);
  font-family: var(--mono);
  font-size: var(--editor-font-size);
  line-height: 1.5;
  tab-size: 2;
  white-space: pre;
  overflow: hidden;
  z-index: 1;
  pointer-events: none;
  color: transparent;
  border: 1px solid transparent;
}
.search-overlay-md {
  padding: 8px 10px;
}
.md-search-wrap {
  position: relative;
}
.search-match {
  background: rgba(200,155,60,0.25);
  color: transparent;
}
.search-match-current {
  background: rgba(200,155,60,0.5);
  outline: 1px solid var(--accent);
}

/* ── AUTOCOMPLETE MENU ── */
.ac-menu {
  position: absolute;
  z-index: 10;
  background: #1e1e1e;
  border: 1px solid #444;
  border-radius: 3px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.4);
  max-height: 200px;
  overflow-y: auto;
  font-family: var(--mono);
  font-size: var(--editor-font-size);
  min-width: 120px;
}
.ac-item {
  padding: 2px 8px;
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 6px;
  white-space: nowrap;
}
.ac-item.active,
.ac-item:hover {
  background: rgba(200,155,60,0.2);
}
.ac-kind {
  width: 16px;
  height: 16px;
  border-radius: 2px;
  font-size: 10px;
  text-align: center;
  line-height: 16px;
  flex-shrink: 0;
}
.ac-kind-var, .ac-kind-def { color: #5ca7e4; }
.ac-kind-fn { color: #c89b3c; }
.ac-kind-kw { color: #cc7832; }
.ac-kind-const { color: #9876aa; }
.ac-kind-prop { color: #6a8759; }
.ac-text { color: var(--fg-bright); }
.ac-detail {
  margin-left: auto;
  padding-left: 12px;
  color: var(--fg-dim);
  font-size: 11px;
}
.ac-match { font-weight: bold; }
.ac-sig-hint {
  position: absolute;
  z-index: 10;
  background: #1e1e1e;
  border: 1px solid #444;
  border-radius: 3px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.4);
  padding: 3px 8px;
  font-family: var(--mono);
  font-size: var(--editor-font-size);
  white-space: nowrap;
  display: flex;
  gap: 10px;
  align-items: baseline;
}
.ac-sig-fn { color: var(--fg-bright); }
.ac-sig-active { color: var(--accent); font-weight: bold; text-decoration: underline; }
.ac-sig-desc { color: var(--fg-dim); font-size: 11px; }
:root.light .ac-sig-hint {
  background: #eae8e3;
  border-color: #b0ab9f;
  box-shadow: 0 2px 8px rgba(0,0,0,0.15);
}
:root.light .ac-menu {
  background: #eae8e3;
  border-color: #b0ab9f;
  box-shadow: 0 2px 8px rgba(0,0,0,0.15);
}
:root.light .ac-item.active,
:root.light .ac-item:hover {
  background: rgba(153,107,31,0.15);
}

/* ── WORKSHOP PANEL ── */
.workshop-overlay {
  display: none;
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.3);
  z-index: 900;
}
.workshop-overlay.visible { display: block; }
.workshop-panel {
  position: fixed;
  top: 0;
  right: -380px;
  bottom: 0;
  width: 360px;
  max-width: 90vw;
  background: var(--bg1);
  border-left: 1px solid var(--border);
  z-index: 901;
  display: flex;
  flex-direction: column;
  font-family: var(--mono);
  font-size: 13px;
  color: var(--fg);
  transition: right 0.25s ease;
  overflow: hidden;
}
.workshop-panel.open { right: 0; }
.workshop-tab {
  position: fixed;
  right: 0;
  top: 50%;
  transform: translateY(-50%) rotate(180deg);
  writing-mode: vertical-rl;
  background: var(--bg1);
  border: 1px solid var(--border);
  border-right: none;
  color: var(--accent);
  font-family: var(--mono);
  font-size: 10px;
  letter-spacing: 2px;
  text-transform: uppercase;
  padding: 10px 5px;
  cursor: pointer;
  z-index: 902;
  transition: right 0.25s ease;
}
.workshop-tab:hover { background: var(--bg2); }
.workshop-panel.open ~ .workshop-tab { right: min(360px, 90vw); }
.workshop-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 16px 16px 12px;
  border-bottom: 1px solid var(--border);
}
.workshop-title {
  color: var(--accent);
  font-size: 11px;
  letter-spacing: 2px;
  text-transform: uppercase;
}
.workshop-close {
  background: none;
  border: 1px solid var(--border);
  color: var(--fg-dim);
  font-size: 18px;
  width: 28px; height: 28px;
  display: flex; align-items: center; justify-content: center;
  padding: 0; cursor: pointer;
  text-transform: none;
  letter-spacing: 0;
}
.workshop-close:hover { border-color: var(--err); color: var(--err); }
.workshop-body {
  flex: 1;
  overflow-y: auto;
  padding: 16px;
  line-height: 1.6;
}
.workshop-body h1, .workshop-body h2, .workshop-body h3 {
  color: var(--fg-bright);
  margin: 1em 0 0.5em;
}
.workshop-body h1:first-child, .workshop-body h2:first-child, .workshop-body h3:first-child {
  margin-top: 0;
}
.workshop-body code {
  background: var(--bg2);
  padding: 1px 4px;
  font-size: 0.9em;
}
.workshop-body strong { color: var(--accent); }
.workshop-pips {
  display: flex;
  justify-content: center;
  gap: 6px;
  padding: 8px 16px;
}
.workshop-pip {
  width: 8px; height: 8px;
  border-radius: 50%;
  background: var(--border);
  cursor: pointer;
}
.workshop-pip.done { background: var(--fg-dim); }
.workshop-pip.active { background: var(--accent); }
.workshop-nav {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 12px 16px;
  border-top: 1px solid var(--border);
}
.workshop-nav button {
  background: var(--bg2);
  border: 1px solid var(--border);
  color: var(--fg);
  font-family: var(--mono);
  font-size: 11px;
  padding: 4px 12px;
  cursor: pointer;
}
.workshop-nav button:hover { border-color: var(--accent); color: var(--accent); }
.workshop-nav button:disabled { opacity: 0.3; cursor: default; }
.workshop-nav button:disabled:hover { border-color: var(--border); color: var(--fg); }
.workshop-counter { color: var(--fg-dim); font-size: 11px; }

/* ── LIGHT THEME ── */
:root.light {
  --bg: #f5f4f0;
  --bg1: #eae8e3;
  --bg2: #dedad3;
  --border: #ccc8bf;
  --border-hi: #b0ab9f;
  --fg: #444;
  --fg-dim: #888;
  --fg-bright: #222;
  --accent: #996b1f;
  --accent-dim: #b8924a;
  --err: #c33;
  --ok: #287;
}
:root.light .cell[data-type="code"] .cell-type { color: #4a7a9e; }
:root.light .cell[data-type="css"]  .cell-type { color: #a56e33; }
:root.light .cell[data-type="html"] .cell-type { color: #3d8a83; }
:root.light ::-webkit-scrollbar-track { background: var(--bg); }
:root.light ::-webkit-scrollbar-thumb { background: var(--border-hi); }

/* ── TOUCH / HEADER MODES ── */
@media (hover: none) {
  .insert-bar { display: none; }
  .cell.selected .cell-insert { display: inline; }
  .cell.selected .cell-convert { display: inline; }
  .cell.selected .cell-header {
    gap: 2px;
  }
  .cell.selected .cell-btn {
    min-height: 36px;
    min-width: 36px;
    font-size: 14px;
    display: inline-flex;
    align-items: center;
    justify-content: center;
  }
}

/* compact header: ellipsis indicator, full controls on select */
@media (hover: none) {
  :root:not(.header-always):not(.header-hover) .cell-header > * { display: none; }
  :root:not(.header-always):not(.header-hover) .cell-header {
    opacity: 1;
    justify-content: center;
    padding: 1px 8px;
  }
  :root:not(.header-always):not(.header-hover) .cell-header::before {
    content: '\22ef';
    color: var(--fg-dim);
    font-size: 12px;
    opacity: 0.4;
  }
  :root:not(.header-always):not(.header-hover) .cell.selected .cell-header > * { display: inline; }
  :root:not(.header-always):not(.header-hover) .cell.selected .cell-header::before { display: none; }
  :root:not(.header-always):not(.header-hover) .cell.selected .cell-header {
    justify-content: flex-start;
    padding: 2px 8px;
  }
}

/* header-always: full header visible on all devices */
:root.header-always .cell-header { opacity: 0.6; }
:root.header-always .cell:hover .cell-header,
:root.header-always .cell.selected .cell-header { opacity: 1; }

/* header-compact: forced compact mode on all devices */
:root.header-compact .cell-header > * { display: none; }
:root.header-compact .cell-header {
  opacity: 1 !important;
  justify-content: center;
  padding: 1px 8px;
}
:root.header-compact .cell-header::before {
  content: '\22ef';
  color: var(--fg-dim);
  font-size: 12px;
  opacity: 0.4;
}
:root.header-compact .cell.selected .cell-header > * { display: inline; }
:root.header-compact .cell.selected .cell-header::before { display: none; }
:root.header-compact .cell.selected .cell-header {
  justify-content: flex-start;
  padding: 2px 8px;
}

/* ── RESPONSIVE ── */
@media (max-width: 640px) {
  /* slim top toolbar: filename + cell count only */
  .toolbar {
    flex-wrap: nowrap;
    gap: 4px;
    padding: 6px 8px;
  }
  .toolbar-title { display: none; }
  .toolbar-sep { display: none; }
  .toolbar .toolbar-add, .toolbar .toolbar-secondary { display: none; }
  .transport { display: none; }
  .toolbar-right { display: none; }
  .toolbar-filename { flex: 1; }
  .toolbar-filename input { width: 100%; }
  .toolbar-status {
    display: inline;
    font-size: 10px;
    color: var(--fg-dim);
    white-space: nowrap;
    letter-spacing: 1px;
  }

  /* bottom action bar replaces statusbar */
  .statusbar {
    display: block;
    padding: 0;
    height: 48px;
  }
  .statusbar .status-size,
  .statusbar .status-cells,
  .statusbar .status-msg,
  .statusbar .status-attr { display: none; }
  .action-bar {
    display: grid;
    grid-template-columns: repeat(5, 1fr);
    height: 48px;
  }
  /* wrapper divs for tray positioning must fill their grid cell */
  .action-bar > div {
    position: relative;
    display: flex;
  }
  .action-bar > div > button {
    flex: 1;
  }
  /* style only the 5 action buttons, not tray buttons */
  .action-bar > button,
  .action-bar > div > button {
    min-height: 48px;
    border: none;
    border-right: 1px solid var(--border);
    background: var(--bg);
    font-family: var(--mono);
    font-size: 16px;
    color: var(--fg);
    padding: 0;
    letter-spacing: 0;
    text-transform: none;
  }
  .action-bar > :last-child > button,
  .action-bar > button:last-child { border-right: none; }
  .action-bar > button:active,
  .action-bar > div > button:active { background: var(--bg2); }
  .action-bar > button.autorun-on,
  .action-bar > div > button.autorun-on {
    background: #33aa77;
    color: #111;
  }
  .action-bar > button.autorun-off,
  .action-bar > div > button.autorun-off {
    background: #dd4444;
    color: #111;
  }

  .find-bar { max-width: 100%; float: none; }
  .notebook { padding: 8px 6px 100px; }
  .cell-header { padding: 2px 4px; }
  .settings-close { width: 44px; height: 44px; font-size: 22px; }
  .settings-row { padding: 10px 0; }
  .settings-row select { min-height: 44px; font-size: 14px; padding: 4px 8px; }
  .settings-row input[type="range"] { height: 44px; }
  .help-overlay { padding: 20px 12px; }
  .settings-panel { width: 260px; }
}

</style>
</head>
<body>

<div class="help-overlay" id="helpOverlay">
<div class="help-content">
<button class="help-close-btn" onclick="$('#helpOverlay').classList.remove('visible')">&#x00d7;</button>
<h2>command mode</h2>
<div class="help-row"><span class="help-key">&#x2191; / k</span><span class="help-desc">select cell above</span></div>
<div class="help-row"><span class="help-key">&#x2193; / j</span><span class="help-desc">select cell below</span></div>
<div class="help-row"><span class="help-key">Enter</span><span class="help-desc">edit selected cell</span></div>
<div class="help-row"><span class="help-key">a</span><span class="help-desc">insert cell above</span></div>
<div class="help-row"><span class="help-key">b</span><span class="help-desc">insert cell below</span></div>
<div class="help-row"><span class="help-key">d d</span><span class="help-desc">delete cell</span></div>
<div class="help-row"><span class="help-key">z</span><span class="help-desc">undo delete</span></div>
<div class="help-row"><span class="help-key">c</span><span class="help-desc">copy cell</span></div>
<div class="help-row"><span class="help-key">v</span><span class="help-desc">paste cell below</span></div>
<div class="help-row"><span class="help-key">x</span><span class="help-desc">cut cell</span></div>
<div class="help-row"><span class="help-key">m</span><span class="help-desc">convert to markdown</span></div>
<div class="help-row"><span class="help-key">y</span><span class="help-desc">convert to code</span></div>
<div class="help-row"><span class="help-key">s</span><span class="help-desc">convert to css</span></div>
<div class="help-row"><span class="help-key">t</span><span class="help-desc">convert to html template</span></div>
<div class="help-row"><span class="help-key">h</span><span class="help-desc">collapse / expand cell</span></div>
<div class="help-row"><span class="help-key">l</span><span class="help-desc">toggle line numbers</span></div>
<div class="help-row"><span class="help-key">p</span><span class="help-desc">presentation mode</span></div>

<h2>edit mode</h2>
<div class="help-row"><span class="help-key">Esc</span><span class="help-desc">exit to command mode</span></div>
<div class="help-row"><span class="help-key">Ctrl+Enter</span><span class="help-desc">run cell</span></div>
<div class="help-row"><span class="help-key">Shift+Enter</span><span class="help-desc">run cell + advance</span></div>
<div class="help-row"><span class="help-key">Ctrl+/</span><span class="help-desc">toggle comment</span></div>
<div class="help-row"><span class="help-key">Tab</span><span class="help-desc">indent</span></div>
<div class="help-row"><span class="help-key">Shift+Tab</span><span class="help-desc">unindent</span></div>

<h2>global</h2>
<div class="help-row"><span class="help-key">F1</span><span class="help-desc">toggle this help</span></div>
<div class="help-row"><span class="help-key">Ctrl+S</span><span class="help-desc">save notebook</span></div>
<div class="help-row"><span class="help-key">Ctrl+F</span><span class="help-desc">find in notebook</span></div>
<div class="help-row"><span class="help-key">Ctrl+H</span><span class="help-desc">find and replace</span></div>

<h2>toolbar</h2>
<div class="help-row"><span class="help-key">&#x23f5; step</span><span class="help-desc">run selected cell</span></div>
<div class="help-row"><span class="help-key">&#x25b6;/&#x2016;</span><span class="help-desc">toggle reactive mode (autorun)</span></div>
<div class="help-row"><span class="help-key">&#x25b6;&#x25b6; run all</span><span class="help-desc">run all cells</span></div>

<h2>builtins</h2>
<div class="help-row"><span class="help-key">display()</span><span class="help-desc">show text, objects, or DOM elements</span></div>
<div class="help-row"><span class="help-key">canvas(w,h)</span><span class="help-desc">create a canvas element</span></div>
<div class="help-row"><span class="help-key">table(data)</span><span class="help-desc">render array of objects as table</span></div>
<div class="help-row"><span class="help-key">slider()</span><span class="help-desc">reactive range input</span></div>
<div class="help-row"><span class="help-key">dropdown()</span><span class="help-desc">reactive select input</span></div>
<div class="help-row"><span class="help-key">checkbox()</span><span class="help-desc">reactive boolean input</span></div>
<div class="help-row"><span class="help-key">textInput()</span><span class="help-desc">reactive text input</span></div>
<div class="help-row"><span class="help-key">load(url)</span><span class="help-desc">import ESM module (cached)</span></div>
<div class="help-row"><span class="help-key">install(url)</span><span class="help-desc">import + embed in HTML on save</span></div>
<div class="help-row"><span class="help-key">installBinary(url)</span><span class="help-desc">fetch binary asset + embed gzipped</span></div>
<div class="help-row"><span class="help-key">invalidation</span><span class="help-desc">promise that resolves before cell re-runs</span></div>
<div class="help-row"><span class="help-key">md``</span><span class="help-desc">markdown tagged template</span></div>
<div class="help-row"><span class="help-key">html``</span><span class="help-desc">HTML tagged template</span></div>
<div class="help-row"><span class="help-key">css``</span><span class="help-desc">CSS tagged template</span></div>
<div class="help-row"><span class="help-key">workshop(pages)</span><span class="help-desc">interactive side panel with pages</span></div>
<div class="help-row"><span class="help-key">notebook</span><span class="help-desc">API for cells, scope, scrollTo, focus</span></div>

<h2>directives</h2>
<div class="help-row"><span class="help-key">// %manual</span><span class="help-desc">skip cell on reactive updates</span></div>
<div class="help-row"><span class="help-key">// %norun</span><span class="help-desc">skip cell on Run All</span></div>
<div class="help-row"><span class="help-key">// %hide</span><span class="help-desc">hide cell in present mode</span></div>
<div class="help-row"><span class="help-key">// %cellName &lt;label&gt;</span><span class="help-desc">name cell in DevTools</span></div>
<div class="help-row"><span class="help-key">// %outputId &lt;id&gt;</span><span class="help-desc">set id on output div</span></div>
<div class="help-row"><span class="help-key">// %outputClass &lt;cls&gt;</span><span class="help-desc">add classes to output div</span></div>
<div class="help-row"><span class="help-key">// %goto &lt;label&gt;</span><span class="help-desc">jump to named cell after execution</span></div>
<div class="help-row"><span class="help-key">// %collapsed</span><span class="help-desc">start cell collapsed</span></div>

<div class="help-close">press F1 or Esc to close</div>
</div>
</div>

<div class="settings-overlay" id="settingsOverlay" onclick="if(event.target===this)toggleSettings()"></div>
<div class="settings-panel" id="settingsPanel">
  <button class="settings-close" onclick="toggleSettings()">&#x00d7;</button>
  <h2>theme</h2>
  <div class="settings-row">
    <label>color scheme</label>
    <select id="setTheme" onchange="applyTheme(this.value)">
      <option value="dark">dark</option>
      <option value="light">light</option>
    </select>
  </div>

  <h2>editor</h2>
  <div class="settings-row">
    <label>font size</label>
    <input type="range" id="setFontSize" min="10" max="20" value="13" oninput="applyFontSize(this.value)">
    <span class="settings-val" id="setFontSizeVal">13</span>
  </div>
  <div class="settings-row">
    <label>line numbers</label>
    <select id="setLineNumbers" onchange="applyLineNumbers(this.value)">
      <option value="on" selected>on</option>
      <option value="off">off</option>
    </select>
  </div>

  <h2>notebook</h2>
  <div class="settings-row">
    <label>max width</label>
    <select id="setWidth" onchange="applyWidth(this.value)">
      <option value="720">narrow</option>
      <option value="860" selected>default</option>
      <option value="1100">wide</option>
      <option value="100%">full</option>
    </select>
  </div>
  <div class="settings-row">
    <label>cell header</label>
    <select id="setHeader" onchange="applyHeader(this.value)">
      <option value="auto" selected>auto</option>
      <option value="always">always visible</option>
      <option value="compact">compact</option>
      <option value="hover">hover only</option>
    </select>
  </div>

  <h2>execution</h2>
  <div class="settings-row">
    <label>mode</label>
    <select id="setExecMode" onchange="applyExecMode(this.value)">
      <option value="reactive">reactive</option>
      <option value="manual">manual</option>
    </select>
  </div>
  <div class="settings-row">
    <label>run on load</label>
    <select id="setRunOnLoad" onchange="applyRunOnLoad(this.value)">
      <option value="yes">yes</option>
      <option value="no">no</option>
    </select>
  </div>
  <div class="settings-row">
    <label>show run toggle</label>
    <select id="setShowToggle" onchange="applyShowToggle(this.value)">
      <option value="yes">yes</option>
      <option value="no">no</option>
    </select>
  </div>
  <div class="settings-desc">
    <strong>reactive</strong>: cells auto-run on edit, changes propagate.<br>
    <strong>manual</strong>: only Ctrl+Enter, Shift+Enter, or Run All.
  </div>
  <div class="settings-row">
    <label>global override</label>
    <select id="setGlobalExecMode" onchange="applyGlobalExecMode(this.value)">
      <option value="">(notebook default)</option>
      <option value="reactive">always reactive</option>
      <option value="manual">always manual</option>
    </select>
  </div>
  <div class="settings-row">
    <label>global run on load</label>
    <select id="setGlobalRunOnLoad" onchange="applyGlobalRunOnLoad(this.value)">
      <option value="">(notebook default)</option>
      <option value="yes">always run</option>
      <option value="no">never run</option>
    </select>
  </div>

  <h2>modules</h2>
  <div id="moduleList"></div>
  <h2>binaries</h2>
  <div id="binaryList"></div>

  <div class="settings-about">
    <span id="aboutVersion"></span>
    <span id="aboutBuild"></span>
    <span id="aboutRuntime"></span>
    <a href="https://github.com/endarthur/auditable" target="_blank">github.com/endarthur/auditable</a>
  </div>
</div>

<div class="update-overlay" id="updateOverlay" onclick="if(event.target===this)toggleUpdate()"></div>
<div class="update-panel" id="updatePanel">
  <button class="settings-close" onclick="toggleUpdate()">&#x00d7;</button>
  <h2>update</h2>
  <div class="settings-row">
    <label>version</label>
    <span id="updateCurrentVer">v0.0.0</span>
  </div>
  <div class="settings-row">
    <label>release</label>
    <span id="updateRelease">dev</span>
  </div>
  <div class="settings-row">
    <label>signature</label>
    <span id="updateSigStatus" class="update-sig">checking...</span>
  </div>
  <div class="settings-row">
    <label>public key</label>
    <span id="updatePubKey" class="update-sig">-</span>
  </div>
  <div id="updateStatus" class="update-status"></div>
  <div class="update-actions">
    <button id="updateCheckBtn" onclick="checkForUpdate()">check for updates</button>
    <button onclick="updateFromFile()">update from file</button>
  </div>
</div>

<div class="toolbar">
  <span class="toolbar-title">auditable</span>
  <span class="toolbar-badges" id="toolbarBadges"></span>
  <span class="toolbar-sep"></span>
  <span class="toolbar-filename">
    <input type="text" id="docTitle" value="atra — Wasm kernels" spellcheck="false">
  </span>
  <span class="toolbar-status" id="toolbarStatus"></span>
  <button class="toolbar-add" onclick="addCellWithUndo('code','',S.selectedId)">+ code</button>
  <button class="toolbar-add" onclick="addCellWithUndo('md','',S.selectedId)">+ md</button>
  <button class="toolbar-secondary" onclick="addCellWithUndo('css','',S.selectedId)">+ css</button>
  <button class="toolbar-secondary" onclick="addCellWithUndo('html','',S.selectedId)">+ html</button>
  <span class="toolbar-sep"></span>
  <span class="transport">
    <button onclick="runSelectedCell()" title="run cell + advance (Shift+Enter)">&#x23f5;</button>
    <button id="autorunBtn" class="autorun-on" onclick="toggleAutorun()" title="reactive mode &#x2014; cells auto-run on edit">&#x25b6;</button>
    <button onclick="runAll()" title="run all cells">&#x25b6;&#x25b6;</button>
  </span>
  <span class="toolbar-right">
    <span class="save-split">
      <button class="accent" onclick="saveNotebook()"><span id="saveLabel">save</span></button><button class="accent save-caret" onclick="toggleSaveTray()">&#x25be;</button>
      <div class="save-tray" id="saveTray">
        <button onclick="setSaveMode('normal');saveNotebook()">save</button>
        <button onclick="setSaveMode('packed');saveNotebook()">save packed</button>
        <button onclick="exportAsTxt();toggleSaveTray()">export .txt</button>
      </div>
    </span>
    <div class="toolbar-overflow">
      <button onclick="toggleToolbarMenu()" title="more">&#x22ef;</button>
      <div class="toolbar-overflow-tray">
        <button onclick="newNotebook();toggleToolbarMenu()">new</button>
        <button onclick="collapseAll();toggleToolbarMenu()">collapse all</button>
        <button onclick="expandAll();toggleToolbarMenu()">expand all</button>
        <button onclick="$('#helpOverlay').classList.toggle('visible');toggleToolbarMenu()">help (F1)</button>
        <button onclick="toggleSettings();toggleToolbarMenu()">settings</button>
        <button class="toolbar-update-btn" onclick="toggleUpdate();toggleToolbarMenu()">update</button>
        <button onclick="togglePresent();toggleToolbarMenu()">present</button>
        <button onclick="openFind(false);toggleToolbarMenu()">find (Ctrl+F)</button>
      </div>
    </div>
  </span>
</div>

<div class="find-bar" id="findBar">
  <div class="find-row">
    <input type="text" id="findInput" placeholder="find" spellcheck="false" autocomplete="off">
    <span class="find-count" id="findCount"></span>
    <button id="findRegexBtn" title="use regex">.*</button>
    <button id="findCaseBtn" title="match case">Aa</button>
    <button id="findPrevBtn" title="previous (Shift+Enter)">&#x2191;</button>
    <button id="findNextBtn" title="next (Enter)">&#x2193;</button>
    <button id="findCloseBtn" title="close (Esc)">&#x00d7;</button>
  </div>
  <div class="find-replace-row" id="findReplaceRow">
    <input type="text" id="replaceInput" placeholder="replace" spellcheck="false" autocomplete="off">
    <button id="findReplaceBtn">replace</button>
    <button id="findReplaceAllBtn">all</button>
  </div>
</div>

<button class="present-exit" onclick="togglePresent()">&#x2715; exit</button>

<div class="notebook" id="notebook">
  <!-- cells go here -->
</div>

<div class="statusbar">
  <span class="status-size" id="statusSize"></span>
  <span class="status-cells" id="statusCells">0 cells</span>
  <span class="status-msg" id="statusMsg"></span>
  <span class="status-attr">
    <a href="https://endarthur.github.io" target="_blank">endarthur</a>
    <span>&middot;</span>
    <a href="https://gentropic.org" target="_blank">geoscientific chaos union</a>
    <span>&middot;</span>
    <a href="https://github.com/endarthur/auditable" target="_blank" title="source on GitHub"><svg width="14" height="14" viewBox="0 0 16 16" fill="currentColor"><path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"/></svg></a>
  </span>
  <div class="action-bar">
    <div>
      <div class="action-add-tray">
        <button onclick="insertAt(S.selectedId,'code');toggleAddTray()">+ code</button>
        <button onclick="insertAt(S.selectedId,'md');toggleAddTray()">+ md</button>
        <button onclick="insertAt(S.selectedId,'css');toggleAddTray()">+ css</button>
        <button onclick="insertAt(S.selectedId,'html');toggleAddTray()">+ html</button>
      </div>
      <button class="action-add" onclick="toggleAddTray()">+</button>
    </div>
    <button onclick="runSelectedCell()" title="run cell + advance">&#x23f5;</button>
    <button id="autorunBtnMobile" class="autorun-on" onclick="toggleAutorun()" title="autorun">&#x25b6;</button>
    <button onclick="runAll()" title="run all">&#x25b6;&#x25b6;</button>
    <div>
      <div class="action-more-tray">
        <button onclick="newNotebook();toggleMoreTray()">new</button>
        <button id="mobileSaveBtn" class="active-mode" onclick="setSaveMode('normal');saveNotebook();toggleMoreTray()">save</button>
        <button id="mobilePackBtn" onclick="setSaveMode('packed');saveNotebook();toggleMoreTray()">save packed</button>
        <button onclick="collapseAll();toggleMoreTray()">collapse all</button>
        <button onclick="expandAll();toggleMoreTray()">expand all</button>
        <button onclick="$('#helpOverlay').classList.toggle('visible');toggleMoreTray()">help</button>
        <button onclick="toggleSettings();toggleMoreTray()">settings</button>
        <button class="toolbar-update-btn" onclick="toggleUpdate();toggleMoreTray()">update</button>
        <button onclick="togglePresent();toggleMoreTray()">present</button>
        <button onclick="openFind(false);toggleMoreTray()">find</button>
      </div>
      <button class="action-more" onclick="toggleMoreTray()">&#x22ef;</button>
    </div>
  </div>
</div>


<!-- cell data: JSON array of {type, code, collapsed?} -->
<!--AUDITABLE-DATA
[{"type":"md","code":"# atra — WebAssembly numerical kernels\n\n[atra](ext/atra/SPEC.md) is a Fortran/Pascal hybrid that compiles to WebAssembly bytecode via tagged template literals. no toolchain, no build step — one JS file turns formulas into bytecode.\n\nthis notebook computes a **spherical variogram model** and uses it to evaluate an **IDW-like weighted interpolation** over a grid, with the heavy loop running entirely in Wasm."},{"type":"code","code":"const { atra } = await load(\"./ext/atra/index.js\");"},{"type":"code","code":"// spherical variogram model + grid evaluator\n// compiled to WebAssembly — all loops run as native Wasm\n\nconst range0 = ui.slider(\"range\", 60, {min:10, max:200, step:1});\nconst sill0 = ui.slider(\"sill\", 1.0, {min:0.1, max:3.0, step:0.1});\nconst nugget0 = ui.slider(\"nugget\", 0.1, {min:0.0, max:1.0, step:0.05});\nconst nPts = ui.slider(\"samples\", 30, {min:5, max:100, step:1});\nconst gridN = ui.slider(\"grid\", 120, {min:40, max:250, step:10});"},{"type":"code","code":"// compile atra kernels to Wasm\nconst mem = new WebAssembly.Memory({ initial: 4 }); // 256 KB\n\nconst wasm = atra({ memory: mem })`\n  const PI: f64 = 3.141592653589793\n\n  ! spherical variogram model: γ(h) = c0 + c1 * (1.5h/a - 0.5(h/a)^3)\n  function spherical(h, a, c1, c0: f64): f64\n  begin\n    if (h <= 0.0) then\n      spherical := 0.0\n    else if (h >= a) then\n      spherical := c0 + c1\n    else\n      spherical := c0 + c1 * (1.5 * h / a - 0.5 * (h / a) ** 3)\n    end if\n  end\n\n  ! weighted interpolation over a grid using variogram-based weights\n  ! samples: [x0, y0, v0, x1, y1, v1, ...] (f64 triples)\n  ! grid: row-major f64 output, gridN * gridN entries\n  subroutine eval_grid(\n    samples: array f64; nSamples: i32;\n    grid: array f64; gridN: i32;\n    a, c1, c0: f64\n  )\n  var\n    ix, iy, k: i32\n    gx, gy, dx, dy, dist, gamma, w, wsum, vsum: f64\n  begin\n    for iy := 0, gridN\n      for ix := 0, gridN\n        gx := f64(ix) / f64(gridN)\n        gy := f64(iy) / f64(gridN)\n        wsum := 0.0\n        vsum := 0.0\n        for k := 0, nSamples\n          dx := gx - samples[k * 3]\n          dy := gy - samples[k * 3 + 1]\n          dist := sqrt(dx * dx + dy * dy)\n          if (dist < 1e-10) then\n            wsum := 1.0\n            vsum := samples[k * 3 + 2]\n            break\n          end if\n          gamma := spherical(dist, a, c1, c0)\n          if (gamma > 0.0) then\n            w := 1.0 / gamma\n          else\n            w := 1e10\n          end if\n          wsum += w\n          vsum += w * samples[k * 3 + 2]\n        end for\n        grid[iy * gridN + ix] := vsum / wsum\n      end for\n    end for\n  end\n`;"},{"type":"code","code":"// generate seeded samples + run Wasm kernel\nfunction mulberry32(a) {\n  return function() {\n    a |= 0; a = a + 0x6D2B79F5 | 0;\n    let t = Math.imul(a ^ a >>> 15, 1 | a);\n    t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;\n    return ((t ^ t >>> 14) >>> 0) / 4294967296;\n  };\n}\nconst rng = mulberry32(42);\n\n// pack samples into Wasm memory as f64 triples\nconst buf = new Float64Array(mem.buffer);\nconst samplesPtr = 0;\nfor (let i = 0; i < nPts; i++) {\n  const x = rng(), y = rng();\n  const trend = 0.5 * Math.sin(x * 4.0) * Math.cos(y * 3.0) + 0.5;\n  buf[i * 3 + 0] = x;\n  buf[i * 3 + 1] = y;\n  buf[i * 3 + 2] = 0.3 * rng() + 0.7 * trend;\n}\n\nconst gridPtr = nPts * 3 * 8; // after sample data\n\nconst t0 = performance.now();\nwasm.eval_grid(samplesPtr, nPts, gridPtr, gridN, range0 / 200, sill0, nugget0);\nconst elapsed = (performance.now() - t0).toFixed(2);\n\n// read grid back\nconst grid = new Float64Array(mem.buffer, gridPtr, gridN * gridN);"},{"type":"code","code":"// render\nconst size = Math.min(500, window.innerWidth - 80);\nconst c = ui.canvas(size, size);\nconst ctx = c.getContext(\"2d\");\n\nfunction viridis(t) {\n  t = Math.max(0, Math.min(1, t));\n  const r = Math.round(255 * Math.max(0, Math.min(1,\n    0.267 + t * (0.004 + t * (5.294 + t * (-14.05 + t * 8.5))))));\n  const g = Math.round(255 * Math.max(0, Math.min(1,\n    0.004 + t * (1.384 + t * (0.098 + t * (-2.74 + t * 2.23))))));\n  const b = Math.round(255 * Math.max(0, Math.min(1,\n    0.329 + t * (1.44 + t * (-5.11 + t * (6.87 + t * -3.57))))));\n  return `rgb(${r},${g},${b})`;\n}\n\nlet vmin = Infinity, vmax = -Infinity;\nfor (let i = 0; i < grid.length; i++) {\n  if (grid[i] < vmin) vmin = grid[i];\n  if (grid[i] > vmax) vmax = grid[i];\n}\nconst vrange = vmax - vmin || 1;\n\nconst cellW = size / gridN;\nfor (let iy = 0; iy < gridN; iy++) {\n  for (let ix = 0; ix < gridN; ix++) {\n    const t = (grid[iy * gridN + ix] - vmin) / vrange;\n    ctx.fillStyle = viridis(t);\n    ctx.fillRect(ix * cellW, iy * cellW, cellW + 0.5, cellW + 0.5);\n  }\n}\n\n// overlay sample points\nfor (let i = 0; i < nPts; i++) {\n  const x = buf[i * 3] * size, y = buf[i * 3 + 1] * size;\n  ctx.beginPath();\n  ctx.arc(x, y, 4, 0, Math.PI * 2);\n  ctx.fillStyle = \"#fff\";\n  ctx.fill();\n  ctx.lineWidth = 1.5;\n  ctx.strokeStyle = \"#000\";\n  ctx.stroke();\n}\n\nui.display(`${gridN}\\u00d7${gridN} grid \\u00b7 ${nPts} samples \\u00b7 Wasm kernel: ${elapsed} ms`);"},{"type":"code","code":"// variogram curve plot\nconst cvs = ui.canvas(500, 200);\nconst cx = cvs.getContext(\"2d\");\nconst w = 500, h = 200, pad = 40;\n\ncx.fillStyle = \"#181818\";\ncx.fillRect(0, 0, w, h);\n\n// axes\ncx.strokeStyle = \"#555\";\ncx.lineWidth = 1;\ncx.beginPath();\ncx.moveTo(pad, h - pad); cx.lineTo(w - 10, h - pad);\ncx.moveTo(pad, h - pad); cx.lineTo(pad, 10);\ncx.stroke();\n\ncx.fillStyle = \"#999\";\ncx.font = \"11px monospace\";\ncx.fillText(\"h\", w - 20, h - pad + 4);\ncx.fillText(\"\\u03b3(h)\", pad - 4, 14);\n\n// plot spherical model curve\nconst maxH = 1.2;\nconst maxG = nugget0 + sill0 * 1.15;\ncx.strokeStyle = \"#c89b3c\";\ncx.lineWidth = 2;\ncx.beginPath();\nfor (let i = 0; i <= 200; i++) {\n  const hv = (i / 200) * maxH;\n  const gv = wasm.spherical(hv, range0 / 200, sill0, nugget0);\n  const px = pad + (hv / maxH) * (w - pad - 10);\n  const py = (h - pad) - (gv / maxG) * (h - pad - 20);\n  if (i === 0) cx.moveTo(px, py); else cx.lineTo(px, py);\n}\ncx.stroke();\n\n// tick labels\ncx.fillStyle = \"#888\";\nfor (let i = 0; i <= 4; i++) {\n  const hv = (i / 4) * maxH;\n  const px = pad + (hv / maxH) * (w - pad - 10);\n  cx.fillText(hv.toFixed(2), px - 12, h - pad + 14);\n}\nfor (let i = 0; i <= 3; i++) {\n  const gv = (i / 3) * maxG;\n  const py = (h - pad) - (gv / maxG) * (h - pad - 20);\n  cx.fillText(gv.toFixed(2), 2, py + 4);\n}"},{"type":"md","code":"**how it works:** the `atra` tagged template compiles a spherical variogram model and a grid evaluator to WebAssembly bytecode — no toolchain, just `atra\\`...\\``. sample data is packed into Wasm linear memory as `f64` triples, and the nested loop runs as native Wasm instructions. the resulting grid is rendered with a viridis colormap."}]
AUDITABLE-DATA-->
<!-- installed modules: base64-encoded JSON mapping URLs to {source, cellId} -->
<!--AUDITABLE-MODULES
eyIuL2V4dC9hdHJhL2luZGV4LmpzIjp7InNvdXJjZSI6Ii8vIEBhdWRpdGFibGUvYXRyYSDigJQg
QXJpdGhtZXRpYyBUUkFuc3BpbGVyXG4vLyBGb3J0cmFuL1Bhc2NhbCBoeWJyaWQg4oaSIFdlYkFz
c2VtYmx5IGJ5dGVjb2RlLiBTaW5nbGUtZmlsZSBjb21waWxlci5cblxuLy8g4pWQ4pWQ4pWQ4pWQ
4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ
4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ
4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ
4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQXG4vLyAxLiBISUdITElH
SFQgVE9LRU5JWkVSICsgQ09NUExFVElPTlMgKGZvciBhdWRpdGFibGUgc3ludGF4IGhpZ2hsaWdo
dGluZylcbi8vIOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKV
kOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKV
kOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKV
kOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKV
kOKVkOKVkFxuXG5jb25zdCBBVFJBX0tFWVdPUkRTID0gbmV3IFNldChbXG4gICdmdW5jdGlvbics
J3N1YnJvdXRpbmUnLCdiZWdpbicsJ2VuZCcsJ3ZhcicsJ2NvbnN0JywnaWYnLCd0aGVuJywnZWxz
ZScsXG4gICdmb3InLCd3aGlsZScsJ2RvJywnYnJlYWsnLCdhbmQnLCdvcicsJ25vdCcsJ21vZCcs
J2ltcG9ydCcsJ2V4cG9ydCcsXG4gICdjYWxsJywnYXJyYXknLCd0cnVlJywnZmFsc2UnLCdmcm9t
Jyxcbl0pO1xuXG5jb25zdCBBVFJBX1RZUEVTID0gbmV3IFNldChbJ2kzMicsJ2k2NCcsJ2YzMics
J2Y2NCddKTtcblxuY29uc3QgQVRSQV9CVUlMVElOUyA9IG5ldyBTZXQoW1xuICAnc2luJywnY29z
Jywnc3FydCcsJ2FicycsJ2Zsb29yJywnY2VpbCcsJ2xuJywnZXhwJywncG93JyxcbiAgJ21pbics
J21heCcsJ3RydW5jJywnbmVhcmVzdCcsJ2NvcHlzaWduJywnc2VsZWN0JyxcbiAgJ2NseicsJ2N0
eicsJ3BvcGNudCcsJ3JvdGwnLCdyb3RyJywnbWVtb3J5X3NpemUnLCdtZW1vcnlfZ3JvdycsXG5d
KTtcblxuZnVuY3Rpb24gdG9rZW5pemVBdHJhKGNvZGUpIHtcbiAgY29uc3QgdG9rZW5zID0gW107
XG4gIGxldCBpID0gMDtcbiAgY29uc3QgbGVuID0gY29kZS5sZW5ndGg7XG5cbiAgd2hpbGUgKGkg
PCBsZW4pIHtcbiAgICAvLyBsaW5lIGNvbW1lbnQ6ICEgdG8gZW5kIG9mIGxpbmVcbiAgICBpZiAo
Y29kZVtpXSA9PT0gJyEnKSB7XG4gICAgICBjb25zdCBzdGFydCA9IGk7XG4gICAgICB3aGlsZSAo
aSA8IGxlbiAmJiBjb2RlW2ldICE9PSAnXFxuJykgaSsrO1xuICAgICAgdG9rZW5zLnB1c2goeyB0
eXBlOiAnY210JywgdGV4dDogY29kZS5zbGljZShzdGFydCwgaSkgfSk7XG4gICAgICBjb250aW51
ZTtcbiAgICB9XG4gICAgLy8gbnVtYmVycyAod2l0aCBvcHRpb25hbCB0eXBlIHN1ZmZpeCBfZjMy
LCBfZjY0LCBfaTMyLCBfaTY0KVxuICAgIGlmICgvXFxkLy50ZXN0KGNvZGVbaV0pIHx8IChjb2Rl
W2ldID09PSAnLicgJiYgaSArIDEgPCBsZW4gJiYgL1xcZC8udGVzdChjb2RlW2kgKyAxXSkpKSB7
XG4gICAgICBjb25zdCBzdGFydCA9IGk7XG4gICAgICB3aGlsZSAoaSA8IGxlbiAmJiAvWzAtOS5d
Ly50ZXN0KGNvZGVbaV0pKSBpKys7XG4gICAgICBpZiAoaSA8IGxlbiAmJiAvW2VFXS8udGVzdChj
b2RlW2ldKSkge1xuICAgICAgICBpKys7XG4gICAgICAgIGlmIChpIDwgbGVuICYmIC9bKy1dLy50
ZXN0KGNvZGVbaV0pKSBpKys7XG4gICAgICAgIHdoaWxlIChpIDwgbGVuICYmIC9cXGQvLnRlc3Qo
Y29kZVtpXSkpIGkrKztcbiAgICAgIH1cbiAgICAgIC8vIHR5cGUgc3VmZml4OiBfZjMyLCBfZjY0
LCBfaTMyLCBfaTY0XG4gICAgICBpZiAoY29kZVtpXSA9PT0gJ18nICYmIGkgKyAzIDw9IGxlbiAm
JiAvXltmaV0vLnRlc3QoY29kZVtpICsgMV0pKSB7XG4gICAgICAgIGNvbnN0IHN1ZiA9IGNvZGUu
c2xpY2UoaSArIDEsIGkgKyA0KTtcbiAgICAgICAgaWYgKEFUUkFfVFlQRVMuaGFzKHN1ZikpIGkg
Kz0gNDtcbiAgICAgIH1cbiAgICAgIHRva2Vucy5wdXNoKHsgdHlwZTogJ251bScsIHRleHQ6IGNv
ZGUuc2xpY2Uoc3RhcnQsIGkpIH0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIC8vIGlk
ZW50aWZpZXJzIC8ga2V5d29yZHNcbiAgICBpZiAoL1thLXpBLVpfXS8udGVzdChjb2RlW2ldKSkg
e1xuICAgICAgY29uc3Qgc3RhcnQgPSBpO1xuICAgICAgd2hpbGUgKGkgPCBsZW4gJiYgL1tcXHcu
XS8udGVzdChjb2RlW2ldKSkgaSsrO1xuICAgICAgY29uc3Qgd29yZCA9IGNvZGUuc2xpY2Uoc3Rh
cnQsIGkpO1xuICAgICAgY29uc3QgbG93ZXIgPSB3b3JkLnRvTG93ZXJDYXNlKCk7XG4gICAgICBp
ZiAoQVRSQV9LRVlXT1JEUy5oYXMobG93ZXIpKSB7XG4gICAgICAgIHRva2Vucy5wdXNoKHsgdHlw
ZTogJ2t3JywgdGV4dDogd29yZCB9KTtcbiAgICAgIH0gZWxzZSBpZiAoQVRSQV9UWVBFUy5oYXMo
bG93ZXIpKSB7XG4gICAgICAgIC8vIHR5cGUgbmFtZXMgYXMgYnVpbHRpbnMgd2hlbiBmb2xsb3dl
ZCBieSAoXG4gICAgICAgIGlmIChpIDwgbGVuICYmIGNvZGVbaV0gPT09ICcoJykge1xuICAgICAg
ICAgIHRva2Vucy5wdXNoKHsgdHlwZTogJ2ZuJywgdGV4dDogd29yZCB9KTtcbiAgICAgICAgfSBl
bHNlIHtcbiAgICAgICAgICB0b2tlbnMucHVzaCh7IHR5cGU6ICdjb25zdCcsIHRleHQ6IHdvcmQg
fSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoQVRSQV9CVUlMVElOUy5oYXMobG93ZXIp
IHx8IGxvd2VyLnN0YXJ0c1dpdGgoJ3dhc20uJykpIHtcbiAgICAgICAgdG9rZW5zLnB1c2goeyB0
eXBlOiAnZm4nLCB0ZXh0OiB3b3JkIH0pO1xuICAgICAgfSBlbHNlIGlmIChpIDwgbGVuICYmIGNv
ZGVbaV0gPT09ICcoJykge1xuICAgICAgICB0b2tlbnMucHVzaCh7IHR5cGU6ICdmbicsIHRleHQ6
IHdvcmQgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0b2tlbnMucHVzaCh7IHR5cGU6ICdp
ZCcsIHRleHQ6IHdvcmQgfSk7XG4gICAgICB9XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAg
Ly8gbXVsdGktY2hhciBvcGVyYXRvcnNcbiAgICBpZiAoaSArIDEgPCBsZW4pIHtcbiAgICAgIGNv
bnN0IHR3byA9IGNvZGVbaV0gKyBjb2RlW2kgKyAxXTtcbiAgICAgIGlmICh0d28gPT09ICcqKicg
fHwgdHdvID09PSAnOj0nIHx8IHR3byA9PT0gJys9JyB8fCB0d28gPT09ICctPScgfHxcbiAgICAg
ICAgICB0d28gPT09ICcqPScgfHwgdHdvID09PSAnLz0nIHx8IHR3byA9PT0gJz09JyB8fCB0d28g
PT09ICc8PScgfHxcbiAgICAgICAgICB0d28gPT09ICc+PScgfHwgdHdvID09PSAnPDwnIHx8IHR3
byA9PT0gJz4+Jykge1xuICAgICAgICB0b2tlbnMucHVzaCh7IHR5cGU6ICdvcCcsIHRleHQ6IHR3
byB9KTtcbiAgICAgICAgaSArPSAyO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAg
IC8vIC89IGlzIG5vdC1lcXVhbCAobXVzdCBjaGVjayBpdCdzIG5vdCAvPXNvbWV0aGluZyBhcyBk
aXZpZGUtYXNzaWduIOKAlCBidXQgaW4gYXRyYSAvPSBpcyBub3QtZXF1YWwpXG4gICAgICBpZiAo
Y29kZVtpXSA9PT0gJy8nICYmIGNvZGVbaSArIDFdID09PSAnPScpIHtcbiAgICAgICAgdG9rZW5z
LnB1c2goeyB0eXBlOiAnb3AnLCB0ZXh0OiAnLz0nIH0pO1xuICAgICAgICBpICs9IDI7XG4gICAg
ICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBzaW5nbGUtY2hhciBvcGVyYXRv
cnNcbiAgICBpZiAoJystKi88Pj0mfF5+Jy5pbmNsdWRlcyhjb2RlW2ldKSkge1xuICAgICAgdG9r
ZW5zLnB1c2goeyB0eXBlOiAnb3AnLCB0ZXh0OiBjb2RlW2ldIH0pO1xuICAgICAgaSsrO1xuICAg
ICAgY29udGludWU7XG4gICAgfVxuICAgIC8vIHB1bmN0dWF0aW9uXG4gICAgaWYgKCcoKVtdOyw6
Jy5pbmNsdWRlcyhjb2RlW2ldKSkge1xuICAgICAgdG9rZW5zLnB1c2goeyB0eXBlOiAncHVuYycs
IHRleHQ6IGNvZGVbaV0gfSk7XG4gICAgICBpKys7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4g
ICAgLy8gd2hpdGVzcGFjZSAvIG90aGVyXG4gICAgdG9rZW5zLnB1c2goeyB0eXBlOiAnJywgdGV4
dDogY29kZVtpXSB9KTtcbiAgICBpKys7XG4gIH1cbiAgcmV0dXJuIHRva2Vucztcbn1cblxuZnVu
Y3Rpb24gYXRyYUNvbXBsZXRpb25zKCkge1xuICBjb25zdCBpdGVtcyA9IFtdO1xuICBmb3IgKGNv
bnN0IHcgb2YgQVRSQV9LRVlXT1JEUykgaXRlbXMucHVzaCh7IHRleHQ6IHcsIGtpbmQ6ICdrdycg
fSk7XG4gIGZvciAoY29uc3QgdyBvZiBBVFJBX1RZUEVTKSAgICBpdGVtcy5wdXNoKHsgdGV4dDog
dywga2luZDogJ2NvbnN0JyB9KTtcbiAgZm9yIChjb25zdCB3IG9mIEFUUkFfQlVJTFRJTlMpIGl0
ZW1zLnB1c2goeyB0ZXh0OiB3LCBraW5kOiAnZm4nIH0pO1xuICByZXR1cm4gaXRlbXM7XG59XG5c
bi8vIOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKV
kOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKV
kOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKV
kOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKV
kFxuLy8gMi4gQ09NUElMRVIgVE9LRU5JWkVSXG4vLyDilZDilZDilZDilZDilZDilZDilZDilZDi
lZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDi
lZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDi
lZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDi
lZDilZDilZDilZDilZDilZDilZDilZDilZDilZBcblxuY29uc3QgVE9LID0ge1xuICBOVU06ICdu
dW0nLCBJRDogJ2lkJywgS1c6ICdrdycsIE9QOiAnb3AnLCBQVU5DOiAncHVuYycsIEVPRjogJ2Vv
ZicsXG59O1xuXG5mdW5jdGlvbiBsZXgoc291cmNlKSB7XG4gIGNvbnN0IHRva2VucyA9IFtdO1xu
ICBsZXQgaSA9IDAsIGxpbmUgPSAxLCBjb2wgPSAxO1xuICBjb25zdCBsZW4gPSBzb3VyY2UubGVu
Z3RoO1xuXG4gIGZ1bmN0aW9uIGFkdigpIHsgaWYgKHNvdXJjZVtpXSA9PT0gJ1xcbicpIHsgbGlu
ZSsrOyBjb2wgPSAxOyB9IGVsc2UgeyBjb2wrKzsgfSBpKys7IH1cbiAgZnVuY3Rpb24gcGVlaygp
IHsgcmV0dXJuIGkgPCBsZW4gPyBzb3VyY2VbaV0gOiAnJzsgfVxuICBmdW5jdGlvbiBwZWVrMigp
IHsgcmV0dXJuIGkgKyAxIDwgbGVuID8gc291cmNlW2ldICsgc291cmNlW2kgKyAxXSA6IHNvdXJj
ZVtpXSB8fCAnJzsgfVxuXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgLy8gc2tpcCB3aGl0ZXNw
YWNlIGFuZCBzZW1pY29sb25zXG4gICAgaWYgKCcgXFx0XFxyXFxuOycuaW5jbHVkZXMoc291cmNl
W2ldKSkgeyBhZHYoKTsgY29udGludWU7IH1cbiAgICAvLyBjb21tZW50XG4gICAgaWYgKHNvdXJj
ZVtpXSA9PT0gJyEnKSB7XG4gICAgICB3aGlsZSAoaSA8IGxlbiAmJiBzb3VyY2VbaV0gIT09ICdc
XG4nKSBhZHYoKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCB0bCA9IGxpbmUs
IHRjID0gY29sO1xuICAgIC8vIG51bWJlclxuICAgIGlmICgvXFxkLy50ZXN0KHNvdXJjZVtpXSkg
fHwgKHNvdXJjZVtpXSA9PT0gJy4nICYmIGkgKyAxIDwgbGVuICYmIC9cXGQvLnRlc3Qoc291cmNl
W2kgKyAxXSkpKSB7XG4gICAgICBjb25zdCBzdGFydCA9IGk7XG4gICAgICBsZXQgaXNGbG9hdCA9
IGZhbHNlO1xuICAgICAgd2hpbGUgKGkgPCBsZW4gJiYgL1xcZC8udGVzdChzb3VyY2VbaV0pKSBh
ZHYoKTtcbiAgICAgIGlmIChwZWVrKCkgPT09ICcuJyAmJiAvXFxkLy50ZXN0KHNvdXJjZVtpICsg
MV0gfHwgJycpKSB7IGlzRmxvYXQgPSB0cnVlOyBhZHYoKTsgd2hpbGUgKGkgPCBsZW4gJiYgL1xc
ZC8udGVzdChzb3VyY2VbaV0pKSBhZHYoKTsgfVxuICAgICAgaWYgKC9bZUVdLy50ZXN0KHBlZWso
KSkpIHsgaXNGbG9hdCA9IHRydWU7IGFkdigpOyBpZiAoL1srLV0vLnRlc3QocGVlaygpKSkgYWR2
KCk7IHdoaWxlIChpIDwgbGVuICYmIC9cXGQvLnRlc3Qoc291cmNlW2ldKSkgYWR2KCk7IH1cbiAg
ICAgIGxldCB0eXBlU3VmZml4ID0gbnVsbDtcbiAgICAgIGlmIChwZWVrKCkgPT09ICdfJykge1xu
ICAgICAgICBjb25zdCBzID0gc291cmNlLnNsaWNlKGkgKyAxLCBpICsgNCk7XG4gICAgICAgIGlm
IChBVFJBX1RZUEVTLmhhcyhzKSkgeyB0eXBlU3VmZml4ID0gczsgYWR2KCk7IGFkdigpOyBhZHYo
KTsgYWR2KCk7IH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IHJhdyA9IHNvdXJjZS5zbGljZShzdGFy
dCwgaSk7XG4gICAgICB0b2tlbnMucHVzaCh7IHR5cGU6IFRPSy5OVU0sIHZhbHVlOiByYXcsIGlz
RmxvYXQsIHR5cGVTdWZmaXgsIGxpbmU6IHRsLCBjb2w6IHRjIH0pO1xuICAgICAgY29udGludWU7
XG4gICAgfVxuICAgIC8vIGlkZW50aWZpZXIgKGluY2x1ZGluZyB3YXNtLnh4eClcbiAgICBpZiAo
L1thLXpBLVpfXS8udGVzdChzb3VyY2VbaV0pKSB7XG4gICAgICBjb25zdCBzdGFydCA9IGk7XG4g
ICAgICB3aGlsZSAoaSA8IGxlbiAmJiAvXFx3Ly50ZXN0KHNvdXJjZVtpXSkpIGFkdigpO1xuICAg
ICAgLy8gaGFuZGxlIHdhc20ueHh4XG4gICAgICBpZiAoc291cmNlLnNsaWNlKHN0YXJ0LCBpKSA9
PT0gJ3dhc20nICYmIHBlZWsoKSA9PT0gJy4nKSB7XG4gICAgICAgIGFkdigpOyAvLyBza2lwIC5c
biAgICAgICAgd2hpbGUgKGkgPCBsZW4gJiYgL1tcXHddLy50ZXN0KHNvdXJjZVtpXSkpIGFkdigp
O1xuICAgICAgfVxuICAgICAgbGV0IHZhbCA9IHNvdXJjZS5zbGljZShzdGFydCwgaSk7XG4gICAg
ICAvLyBpbnRlcnBvbGF0aW9uIG1hcmtlcnM6IF9fSU5URVJQX05fX1xuICAgICAgaWYgKC9eX19J
TlRFUlBfXFxkK19fJC8udGVzdCh2YWwpKSB7XG4gICAgICAgIHRva2Vucy5wdXNoKHsgdHlwZTog
VE9LLklELCB2YWx1ZTogdmFsLCBpbnRlcnA6IHRydWUsIGxpbmU6IHRsLCBjb2w6IHRjIH0pO1xu
ICAgICAgfSBlbHNlIGlmIChBVFJBX0tFWVdPUkRTLmhhcyh2YWwpIHx8IEFUUkFfVFlQRVMuaGFz
KHZhbCkpIHtcbiAgICAgICAgdG9rZW5zLnB1c2goeyB0eXBlOiBUT0suS1csIHZhbHVlOiB2YWws
IGxpbmU6IHRsLCBjb2w6IHRjIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdG9rZW5zLnB1
c2goeyB0eXBlOiBUT0suSUQsIHZhbHVlOiB2YWwsIGxpbmU6IHRsLCBjb2w6IHRjIH0pO1xuICAg
ICAgfVxuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIC8vIG11bHRpLWNoYXIgb3BlcmF0b3Jz
XG4gICAgY29uc3QgdHcgPSBwZWVrMigpO1xuICAgIGlmICh0dyA9PT0gJyoqJyB8fCB0dyA9PT0g
Jzo9JyB8fCB0dyA9PT0gJys9JyB8fCB0dyA9PT0gJy09JyB8fCB0dyA9PT0gJyo9JyB8fFxuICAg
ICAgICB0dyA9PT0gJz09JyB8fCB0dyA9PT0gJzw9JyB8fCB0dyA9PT0gJz49JyB8fCB0dyA9PT0g
Jzw8JyB8fCB0dyA9PT0gJz4+Jykge1xuICAgICAgdG9rZW5zLnB1c2goeyB0eXBlOiBUT0suT1As
IHZhbHVlOiB0dywgbGluZTogdGwsIGNvbDogdGMgfSk7XG4gICAgICBhZHYoKTsgYWR2KCk7XG4g
ICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgLy8gLz0g4oCUIHRoaXMgaXMgbm90LWVxdWFsIGlu
IGF0cmFcbiAgICBpZiAoc291cmNlW2ldID09PSAnLycgJiYgc291cmNlW2kgKyAxXSA9PT0gJz0n
KSB7XG4gICAgICB0b2tlbnMucHVzaCh7IHR5cGU6IFRPSy5PUCwgdmFsdWU6ICcvPScsIGxpbmU6
IHRsLCBjb2w6IHRjIH0pO1xuICAgICAgYWR2KCk7IGFkdigpO1xuICAgICAgY29udGludWU7XG4g
ICAgfVxuICAgIC8vIHNpbmdsZS1jaGFyIG9wZXJhdG9yc1xuICAgIGlmICgnKy0qLzw+PSZ8Xn4n
LmluY2x1ZGVzKHNvdXJjZVtpXSkpIHtcbiAgICAgIHRva2Vucy5wdXNoKHsgdHlwZTogVE9LLk9Q
LCB2YWx1ZTogc291cmNlW2ldLCBsaW5lOiB0bCwgY29sOiB0YyB9KTtcbiAgICAgIGFkdigpO1xu
ICAgICAgY29udGludWU7XG4gICAgfVxuICAgIC8vIHB1bmN0dWF0aW9uXG4gICAgaWYgKCcoKVtd
Oyw6Jy5pbmNsdWRlcyhzb3VyY2VbaV0pKSB7XG4gICAgICB0b2tlbnMucHVzaCh7IHR5cGU6IFRP
Sy5QVU5DLCB2YWx1ZTogc291cmNlW2ldLCBsaW5lOiB0bCwgY29sOiB0YyB9KTtcbiAgICAgIGFk
digpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIC8vIHNraXAgdW5rbm93blxuICAgIGFk
digpO1xuICB9XG4gIHRva2Vucy5wdXNoKHsgdHlwZTogVE9LLkVPRiwgdmFsdWU6ICcnLCBsaW5l
LCBjb2wgfSk7XG4gIHJldHVybiB0b2tlbnM7XG59XG5cbi8vIOKVkOKVkOKVkOKVkOKVkOKVkOKV
kOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKV
kOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKV
kOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKV
kOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkFxuLy8gMy4gUEFSU0VSXG4vLyDilZDi
lZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDi
lZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDi
lZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDi
lZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZBcblxuZnVu
Y3Rpb24gcGFyc2UodG9rZW5zKSB7XG4gIGxldCBwb3MgPSAwO1xuICBmdW5jdGlvbiBjdXIoKSB7
IHJldHVybiB0b2tlbnNbcG9zXTsgfVxuICBmdW5jdGlvbiBhdCh0eXBlLCB2YWx1ZSkgeyBjb25z
dCB0ID0gY3VyKCk7IHJldHVybiB0LnR5cGUgPT09IHR5cGUgJiYgKHZhbHVlID09PSB1bmRlZmlu
ZWQgfHwgdC52YWx1ZSA9PT0gdmFsdWUpOyB9XG4gIGZ1bmN0aW9uIGVhdCh0eXBlLCB2YWx1ZSkg
e1xuICAgIGNvbnN0IHQgPSBjdXIoKTtcbiAgICBpZiAodC50eXBlICE9PSB0eXBlIHx8ICh2YWx1
ZSAhPT0gdW5kZWZpbmVkICYmIHQudmFsdWUgIT09IHZhbHVlKSlcbiAgICAgIHRocm93IG5ldyBT
eW50YXhFcnJvcihgRXhwZWN0ZWQgJHt2YWx1ZSB8fCB0eXBlfSBidXQgZ290IFwiJHt0LnZhbHVl
fVwiIGF0ICR7dC5saW5lfToke3QuY29sfWApO1xuICAgIHBvcysrO1xuICAgIHJldHVybiB0O1xu
ICB9XG4gIGZ1bmN0aW9uIG1heWJlKHR5cGUsIHZhbHVlKSB7IGlmIChhdCh0eXBlLCB2YWx1ZSkp
IHsgcG9zKys7IHJldHVybiB0cnVlOyB9IHJldHVybiBmYWxzZTsgfVxuXG4gIGZ1bmN0aW9uIHBh
cnNlUHJvZ3JhbSgpIHtcbiAgICBjb25zdCBib2R5ID0gW107XG4gICAgd2hpbGUgKCFhdChUT0su
RU9GKSkge1xuICAgICAgaWYgKGF0KFRPSy5LVywgJ2NvbnN0JykgJiYgIWlzTG9jYWxDb250ZXh0
KCkpIGJvZHkucHVzaChwYXJzZUdsb2JhbENvbnN0KCkpO1xuICAgICAgZWxzZSBpZiAoYXQoVE9L
LktXLCAndmFyJykgJiYgIWlzTG9jYWxDb250ZXh0KCkpIGJvZHkucHVzaChwYXJzZUdsb2JhbFZh
cigpKTtcbiAgICAgIGVsc2UgaWYgKGF0KFRPSy5LVywgJ2Z1bmN0aW9uJykpIGJvZHkucHVzaChw
YXJzZUZ1bmN0aW9uKCkpO1xuICAgICAgZWxzZSBpZiAoYXQoVE9LLktXLCAnc3Vicm91dGluZScp
KSBib2R5LnB1c2gocGFyc2VTdWJyb3V0aW5lKCkpO1xuICAgICAgZWxzZSBpZiAoYXQoVE9LLktX
LCAnaW1wb3J0JykpIGJvZHkucHVzaChwYXJzZUltcG9ydCgpKTtcbiAgICAgIGVsc2UgaWYgKGF0
KFRPSy5LVywgJ2V4cG9ydCcpKSB7IHBvcysrOyBib2R5LnB1c2gocGFyc2VGdW5jdGlvbih0cnVl
KSk7IH1cbiAgICAgIGVsc2UgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIFwiJHtj
dXIoKS52YWx1ZX1cIiBhdCAke2N1cigpLmxpbmV9OiR7Y3VyKCkuY29sfWApO1xuICAgIH1cbiAg
ICByZXR1cm4geyB0eXBlOiAnUHJvZ3JhbScsIGJvZHkgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlz
TG9jYWxDb250ZXh0KCkgeyByZXR1cm4gZmFsc2U7IH0gLy8gZ2xvYmFscyBvbmx5IGF0IHRvcCBs
ZXZlbFxuXG4gIGZ1bmN0aW9uIHBhcnNlR2xvYmFsQ29uc3QoKSB7XG4gICAgZWF0KFRPSy5LVywg
J2NvbnN0Jyk7XG4gICAgY29uc3QgbmFtZSA9IGVhdChUT0suSUQpLnZhbHVlO1xuICAgIGVhdChU
T0suUFVOQywgJzonKTtcbiAgICBjb25zdCB2dHlwZSA9IGVhdChUT0suS1cpLnZhbHVlO1xuICAg
IGVhdChUT0suT1AsICc9Jyk7XG4gICAgY29uc3QgaW5pdCA9IHBhcnNlRXhwcigwKTtcbiAgICBy
ZXR1cm4geyB0eXBlOiAnQ29uc3REZWNsJywgbmFtZSwgdnR5cGUsIGluaXQgfTtcbiAgfVxuXG4g
IGZ1bmN0aW9uIHBhcnNlR2xvYmFsVmFyKCkge1xuICAgIGVhdChUT0suS1csICd2YXInKTtcbiAg
ICBjb25zdCBuYW1lID0gZWF0KFRPSy5JRCkudmFsdWU7XG4gICAgZWF0KFRPSy5QVU5DLCAnOicp
O1xuICAgIGNvbnN0IHZ0eXBlID0gZWF0KFRPSy5LVykudmFsdWU7XG4gICAgbGV0IGluaXQgPSBu
dWxsO1xuICAgIGlmIChtYXliZShUT0suT1AsICc9JykpIGluaXQgPSBwYXJzZUV4cHIoMCk7XG4g
ICAgcmV0dXJuIHsgdHlwZTogJ1ZhckRlY2wnLCBuYW1lLCB2dHlwZSwgaW5pdCB9O1xuICB9XG5c
biAgZnVuY3Rpb24gcGFyc2VJbXBvcnQoKSB7XG4gICAgZWF0KFRPSy5LVywgJ2ltcG9ydCcpO1xu
ICAgIC8vIGltcG9ydCBmdW5jdGlvbiBuYW1lKHBhcmFtcyk6IHJldFR5cGUgZnJvbSAnbW9kdWxl
J1xuICAgIC8vIGltcG9ydCBuYW1lID0gJHtpbnRlcnB9XG4gICAgLy8gaW1wb3J0IG5hbWUocGFy
YW1zKTogcmV0VHlwZSA9ICR7aW50ZXJwfVxuICAgIGlmIChhdChUT0suS1csICdmdW5jdGlvbicp
KSB7XG4gICAgICBwb3MrKztcbiAgICB9XG4gICAgY29uc3QgbmFtZSA9IGVhdChUT0suSUQpLnZh
bHVlO1xuICAgIGxldCBwYXJhbXMgPSBbXSwgcmV0VHlwZSA9IG51bGwsIG1vZHVsZU5hbWUgPSAn
aG9zdCcsIGludGVycElkeCA9IG51bGw7XG4gICAgaWYgKGF0KFRPSy5QVU5DLCAnKCcpKSB7XG4g
ICAgICBwYXJhbXMgPSBwYXJzZVBhcmFtTGlzdCgpO1xuICAgIH1cbiAgICBpZiAobWF5YmUoVE9L
LlBVTkMsICc6JykpIHtcbiAgICAgIHJldFR5cGUgPSBlYXQoVE9LLktXKS52YWx1ZTtcbiAgICB9
XG4gICAgaWYgKG1heWJlKFRPSy5PUCwgJz0nKSkge1xuICAgICAgLy8gaW50ZXJwb2xhdGlvbiBt
YXJrZXJcbiAgICAgIGNvbnN0IHQgPSBlYXQoVE9LLklEKTtcbiAgICAgIGludGVycElkeCA9IHQu
dmFsdWU7XG4gICAgfSBlbHNlIGlmIChtYXliZShUT0suS1csICdmcm9tJykpIHtcbiAgICAgIC8v
ICdtb2R1bGUnIOKAlCB3ZSBqdXN0IHJlYWQgdGhlIGlkZW50aWZpZXIgYXMgYSBzdHJpbmctbGlr
ZSB0aGluZ1xuICAgICAgbW9kdWxlTmFtZSA9IGVhdChUT0suSUQpLnZhbHVlO1xuICAgIH1cbiAg
ICByZXR1cm4geyB0eXBlOiAnSW1wb3J0RGVjbCcsIG5hbWUsIHBhcmFtcywgcmV0VHlwZSwgbW9k
dWxlTmFtZSwgaW50ZXJwSWR4IH07XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUZ1bmN0aW9uKGV4
cG9ydGVkID0gZmFsc2UpIHtcbiAgICBlYXQoVE9LLktXLCAnZnVuY3Rpb24nKTtcbiAgICBjb25z
dCBuYW1lID0gZWF0KFRPSy5JRCkudmFsdWU7XG4gICAgZWF0KFRPSy5QVU5DLCAnKCcpO1xuICAg
IGNvbnN0IHBhcmFtcyA9IGF0KFRPSy5QVU5DLCAnKScpID8gW10gOiBwYXJzZVBhcmFtRW50cmll
cygpO1xuICAgIGVhdChUT0suUFVOQywgJyknKTtcbiAgICBlYXQoVE9LLlBVTkMsICc6Jyk7XG4g
ICAgY29uc3QgcmV0VHlwZSA9IGVhdChUT0suS1cpLnZhbHVlO1xuICAgIGNvbnN0IGxvY2FscyA9
IFtdO1xuICAgIGlmIChhdChUT0suS1csICd2YXInKSkge1xuICAgICAgcG9zKys7XG4gICAgICB3
aGlsZSAoIWF0KFRPSy5LVywgJ2JlZ2luJykpIHtcbiAgICAgICAgY29uc3QgbG5hbWVzID0gW2Vh
dChUT0suSUQpLnZhbHVlXTtcbiAgICAgICAgd2hpbGUgKG1heWJlKFRPSy5QVU5DLCAnLCcpKSBs
bmFtZXMucHVzaChlYXQoVE9LLklEKS52YWx1ZSk7XG4gICAgICAgIGVhdChUT0suUFVOQywgJzon
KTtcbiAgICAgICAgY29uc3QgbHQgPSBlYXQoVE9LLktXKS52YWx1ZTtcbiAgICAgICAgZm9yIChj
b25zdCBsbiBvZiBsbmFtZXMpIGxvY2Fscy5wdXNoKHsgdHlwZTogJ0xvY2FsJywgbmFtZTogbG4s
IHZ0eXBlOiBsdCB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWF0KFRPSy5LVywgJ2JlZ2luJyk7
XG4gICAgY29uc3QgYm9keSA9IHBhcnNlU3RhdGVtZW50cygnZW5kJyk7XG4gICAgZWF0KFRPSy5L
VywgJ2VuZCcpO1xuICAgIHJldHVybiB7IHR5cGU6ICdGdW5jdGlvbicsIG5hbWUsIHBhcmFtcywg
cmV0VHlwZSwgbG9jYWxzLCBib2R5LCBleHBvcnRlZCB9O1xuICB9XG5cbiAgZnVuY3Rpb24gcGFy
c2VTdWJyb3V0aW5lKCkge1xuICAgIGVhdChUT0suS1csICdzdWJyb3V0aW5lJyk7XG4gICAgY29u
c3QgbmFtZSA9IGVhdChUT0suSUQpLnZhbHVlO1xuICAgIGVhdChUT0suUFVOQywgJygnKTtcbiAg
ICBjb25zdCBwYXJhbXMgPSBhdChUT0suUFVOQywgJyknKSA/IFtdIDogcGFyc2VQYXJhbUVudHJp
ZXMoKTtcbiAgICBlYXQoVE9LLlBVTkMsICcpJyk7XG4gICAgY29uc3QgbG9jYWxzID0gW107XG4g
ICAgaWYgKGF0KFRPSy5LVywgJ3ZhcicpKSB7XG4gICAgICBwb3MrKztcbiAgICAgIHdoaWxlICgh
YXQoVE9LLktXLCAnYmVnaW4nKSkge1xuICAgICAgICBjb25zdCBsbmFtZXMgPSBbZWF0KFRPSy5J
RCkudmFsdWVdO1xuICAgICAgICB3aGlsZSAobWF5YmUoVE9LLlBVTkMsICcsJykpIGxuYW1lcy5w
dXNoKGVhdChUT0suSUQpLnZhbHVlKTtcbiAgICAgICAgZWF0KFRPSy5QVU5DLCAnOicpO1xuICAg
ICAgICBjb25zdCBsdCA9IGVhdChUT0suS1cpLnZhbHVlO1xuICAgICAgICBmb3IgKGNvbnN0IGxu
IG9mIGxuYW1lcykgbG9jYWxzLnB1c2goeyB0eXBlOiAnTG9jYWwnLCBuYW1lOiBsbiwgdnR5cGU6
IGx0IH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBlYXQoVE9LLktXLCAnYmVnaW4nKTtcbiAgICBj
b25zdCBib2R5ID0gcGFyc2VTdGF0ZW1lbnRzKCdlbmQnKTtcbiAgICBlYXQoVE9LLktXLCAnZW5k
Jyk7XG4gICAgcmV0dXJuIHsgdHlwZTogJ1N1YnJvdXRpbmUnLCBuYW1lLCBwYXJhbXMsIGxvY2Fs
cywgYm9keSB9O1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VQYXJhbUVudHJpZXMoKSB7XG4gICAg
Y29uc3QgcGFyYW1zID0gW107XG4gICAgd2hpbGUgKGN1cigpLnR5cGUgPT09IFRPSy5JRCkge1xu
ICAgICAgLy8gQ29sbGVjdCBjb21tYS1zZXBhcmF0ZWQgbmFtZXMgdGhhdCBzaGFyZSBhIHR5cGVc
biAgICAgIGNvbnN0IG5hbWVzID0gW2VhdChUT0suSUQpLnZhbHVlXTtcbiAgICAgIHdoaWxlIChh
dChUT0suUFVOQywgJywnKSAmJiB0b2tlbnNbcG9zICsgMV0gJiYgdG9rZW5zW3BvcyArIDFdLnR5
cGUgPT09IFRPSy5JRCAmJlxuICAgICAgICAgICAgIHRva2Vuc1twb3MgKyAyXSAmJiAodG9rZW5z
W3BvcyArIDJdLnZhbHVlID09PSAnLCcgfHwgdG9rZW5zW3BvcyArIDJdLnZhbHVlID09PSAnOicp
KSB7XG4gICAgICAgIHBvcysrOyAvLyBza2lwICxcbiAgICAgICAgbmFtZXMucHVzaChlYXQoVE9L
LklEKS52YWx1ZSk7XG4gICAgICB9XG4gICAgICBlYXQoVE9LLlBVTkMsICc6Jyk7XG4gICAgICBs
ZXQgaXNBcnJheSA9IGZhbHNlLCBhcnJheURpbXMgPSBudWxsO1xuICAgICAgaWYgKGF0KFRPSy5L
VywgJ2FycmF5JykpIHtcbiAgICAgICAgcG9zKys7XG4gICAgICAgIGlzQXJyYXkgPSB0cnVlO1xu
ICAgICAgICBpZiAoYXQoVE9LLlBVTkMsICcoJykpIHtcbiAgICAgICAgICBwb3MrKztcbiAgICAg
ICAgICBhcnJheURpbXMgPSBbXTtcbiAgICAgICAgICBhcnJheURpbXMucHVzaChwYXJzZUV4cHIo
MCkpO1xuICAgICAgICAgIHdoaWxlIChtYXliZShUT0suUFVOQywgJywnKSkgYXJyYXlEaW1zLnB1
c2gocGFyc2VFeHByKDApKTtcbiAgICAgICAgICBlYXQoVE9LLlBVTkMsICcpJyk7XG4gICAgICAg
IH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IHZ0eXBlID0gZWF0KFRPSy5LVykudmFsdWU7XG4gICAg
ICBmb3IgKGNvbnN0IG4gb2YgbmFtZXMpIHBhcmFtcy5wdXNoKHsgdHlwZTogJ1BhcmFtJywgbmFt
ZTogbiwgdnR5cGUsIGlzQXJyYXksIGFycmF5RGltcyB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHBh
cmFtcztcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlUGFyYW1MaXN0KCkge1xuICAgIC8vIHNpbXBs
aWZpZWQgcGFyYW0gbGlzdCBmb3IgaW1wb3J0czogbmFtZTogdHlwZSwgLi4uXG4gICAgZWF0KFRP
Sy5QVU5DLCAnKCcpO1xuICAgIGNvbnN0IHBhcmFtcyA9IFtdO1xuICAgIHdoaWxlIChjdXIoKS50
eXBlID09PSBUT0suSUQpIHtcbiAgICAgIGNvbnN0IG5hbWVzID0gW2VhdChUT0suSUQpLnZhbHVl
XTtcbiAgICAgIHdoaWxlIChhdChUT0suUFVOQywgJywnKSAmJiB0b2tlbnNbcG9zICsgMV0gJiYg
dG9rZW5zW3BvcyArIDFdLnR5cGUgPT09IFRPSy5JRCAmJlxuICAgICAgICAgICAgIHRva2Vuc1tw
b3MgKyAyXSAmJiAodG9rZW5zW3BvcyArIDJdLnZhbHVlID09PSAnLCcgfHwgdG9rZW5zW3BvcyAr
IDJdLnZhbHVlID09PSAnOicpKSB7XG4gICAgICAgIHBvcysrO1xuICAgICAgICBuYW1lcy5wdXNo
KGVhdChUT0suSUQpLnZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGVhdChUT0suUFVOQywgJzonKTtc
biAgICAgIGNvbnN0IHZ0eXBlID0gZWF0KFRPSy5LVykudmFsdWU7XG4gICAgICBmb3IgKGNvbnN0
IG4gb2YgbmFtZXMpIHBhcmFtcy5wdXNoKHsgdHlwZTogJ1BhcmFtJywgbmFtZTogbiwgdnR5cGUs
IGlzQXJyYXk6IGZhbHNlLCBhcnJheURpbXM6IG51bGwgfSk7XG4gICAgfVxuICAgIGVhdChUT0su
UFVOQywgJyknKTtcbiAgICByZXR1cm4gcGFyYW1zO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VT
dGF0ZW1lbnRzKGVuZEt3KSB7XG4gICAgY29uc3Qgc3RtdHMgPSBbXTtcbiAgICB3aGlsZSAoIWF0
KFRPSy5LVywgZW5kS3cpICYmICFhdChUT0suRU9GKSkge1xuICAgICAgLy8gYWxzbyBzdG9wIGF0
ICdlbHNlJyBmb3IgaWYgYmxvY2tzXG4gICAgICBpZiAoZW5kS3cgPT09ICdlbmQnICYmIChhdChU
T0suS1csICdlbHNlJykpKSBicmVhaztcbiAgICAgIHN0bXRzLnB1c2gocGFyc2VTdGF0ZW1lbnQo
KSk7XG4gICAgfVxuICAgIHJldHVybiBzdG10cztcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlU3Rh
dGVtZW50KCkge1xuICAgIGlmIChhdChUT0suS1csICdpZicpKSByZXR1cm4gcGFyc2VJZigpO1xu
ICAgIGlmIChhdChUT0suS1csICdmb3InKSkgcmV0dXJuIHBhcnNlRm9yKCk7XG4gICAgaWYgKGF0
KFRPSy5LVywgJ3doaWxlJykpIHJldHVybiBwYXJzZVdoaWxlKCk7XG4gICAgaWYgKGF0KFRPSy5L
VywgJ2RvJykpIHJldHVybiBwYXJzZURvV2hpbGUoKTtcbiAgICBpZiAoYXQoVE9LLktXLCAnYnJl
YWsnKSkgeyBwb3MrKzsgcmV0dXJuIHsgdHlwZTogJ0JyZWFrJyB9OyB9XG4gICAgaWYgKGF0KFRP
Sy5LVywgJ2NhbGwnKSkgeyBwb3MrKzsgY29uc3QgbmFtZSA9IGVhdChUT0suSUQpLnZhbHVlOyBl
YXQoVE9LLlBVTkMsICcoJyk7IGNvbnN0IGFyZ3MgPSBwYXJzZUFyZ3MoKTsgZWF0KFRPSy5QVU5D
LCAnKScpOyByZXR1cm4geyB0eXBlOiAnQ2FsbCcsIG5hbWUsIGFyZ3MgfTsgfVxuXG4gICAgLy8g
YXNzaWdubWVudCBvciBleHByZXNzaW9uIHN0YXRlbWVudFxuICAgIC8vIGxvb2sgYWhlYWQ6IGlk
IDo9IC8gaWRbLi4uXSA6PSAvIGlkICs9IGV0Yy5cbiAgICBpZiAoY3VyKCkudHlwZSA9PT0gVE9L
LklEKSB7XG4gICAgICBjb25zdCBuYW1lID0gY3VyKCkudmFsdWU7XG4gICAgICAvLyBjaGVjayBm
b3IgYXJyYXkgc3RvcmU6IGlkW1xuICAgICAgaWYgKHRva2Vuc1twb3MgKyAxXSAmJiB0b2tlbnNb
cG9zICsgMV0udmFsdWUgPT09ICdbJykge1xuICAgICAgICBwb3MrKztcbiAgICAgICAgZWF0KFRP
Sy5QVU5DLCAnWycpO1xuICAgICAgICBjb25zdCBpbmRpY2VzID0gW3BhcnNlRXhwcigwKV07XG4g
ICAgICAgIHdoaWxlIChtYXliZShUT0suUFVOQywgJywnKSkgaW5kaWNlcy5wdXNoKHBhcnNlRXhw
cigwKSk7XG4gICAgICAgIGVhdChUT0suUFVOQywgJ10nKTtcbiAgICAgICAgaWYgKGF0KFRPSy5P
UCwgJzo9JykpIHtcbiAgICAgICAgICBwb3MrKztcbiAgICAgICAgICBjb25zdCB2YWx1ZSA9IHBh
cnNlRXhwcigwKTtcbiAgICAgICAgICByZXR1cm4geyB0eXBlOiAnQXJyYXlTdG9yZScsIG5hbWUs
IGluZGljZXMsIHZhbHVlIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gY29tcG91bmQgYXNzaWdu
bWVudCBvbiBhcnJheVxuICAgICAgICBjb25zdCBjb3AgPSBjdXIoKS52YWx1ZTtcbiAgICAgICAg
aWYgKGNvcCA9PT0gJys9JyB8fCBjb3AgPT09ICctPScgfHwgY29wID09PSAnKj0nIHx8IGNvcCA9
PT0gJy89Jykge1xuICAgICAgICAgIC8vIE5vdGU6IC89IGlzIGFtYmlndW91cyDigJQgYXMgYSBz
dGF0ZW1lbnQgc3RhcnQgYWZ0ZXIgYXJyYXkgYWNjZXNzLCBpdCdzIGNvbXBvdW5kIGFzc2lnblxu
ICAgICAgICAgIHBvcysrO1xuICAgICAgICAgIGNvbnN0IHJocyA9IHBhcnNlRXhwcigwKTtcbiAg
ICAgICAgICBjb25zdCBvcCA9IGNvcFswXTsgLy8gKywgLSwgKiwgL1xuICAgICAgICAgIHJldHVy
biB7IHR5cGU6ICdBcnJheVN0b3JlJywgbmFtZSwgaW5kaWNlcywgdmFsdWU6IHtcbiAgICAgICAg
ICAgIHR5cGU6ICdCaW5PcCcsIG9wLCBsZWZ0OiB7IHR5cGU6ICdBcnJheUFjY2VzcycsIG5hbWUs
IGluZGljZXMgfSwgcmlnaHQ6IHJoc1xuICAgICAgICAgIH19O1xuICAgICAgICB9XG4gICAgICAg
IHRocm93IG5ldyBTeW50YXhFcnJvcihgRXhwZWN0ZWQgOj0gb3IgY29tcG91bmQgYXNzaWdubWVu
dCBhZnRlciBhcnJheSBhY2Nlc3MgYXQgJHtjdXIoKS5saW5lfToke2N1cigpLmNvbH1gKTtcbiAg
ICAgIH1cbiAgICAgIGlmICh0b2tlbnNbcG9zICsgMV0gJiYgdG9rZW5zW3BvcyArIDFdLnZhbHVl
ID09PSAnOj0nKSB7XG4gICAgICAgIHBvcysrOyBwb3MrKztcbiAgICAgICAgY29uc3QgdmFsdWUg
PSBwYXJzZUV4cHIoMCk7XG4gICAgICAgIHJldHVybiB7IHR5cGU6ICdBc3NpZ24nLCBuYW1lLCB2
YWx1ZSB9O1xuICAgICAgfVxuICAgICAgLy8gY29tcG91bmQgYXNzaWdubWVudDogKz0sIC09LCAq
PVxuICAgICAgaWYgKHRva2Vuc1twb3MgKyAxXSAmJiAodG9rZW5zW3BvcyArIDFdLnZhbHVlID09
PSAnKz0nIHx8IHRva2Vuc1twb3MgKyAxXS52YWx1ZSA9PT0gJy09JyB8fCB0b2tlbnNbcG9zICsg
MV0udmFsdWUgPT09ICcqPScpKSB7XG4gICAgICAgIGNvbnN0IGNvcCA9IHRva2Vuc1twb3MgKyAx
XS52YWx1ZTtcbiAgICAgICAgY29uc3Qgb3AgPSBjb3BbMF07XG4gICAgICAgIHBvcysrOyBwb3Mr
KztcbiAgICAgICAgY29uc3QgcmhzID0gcGFyc2VFeHByKDApO1xuICAgICAgICByZXR1cm4geyB0
eXBlOiAnQXNzaWduJywgbmFtZSwgdmFsdWU6IHsgdHlwZTogJ0Jpbk9wJywgb3AsIGxlZnQ6IHsg
dHlwZTogJ0lkZW50JywgbmFtZSB9LCByaWdodDogcmhzIH0gfTtcbiAgICAgIH1cbiAgICAgIC8v
IC89IGNvbXBvdW5kIGFzc2lnbm1lbnQgKG9ubHkgd2hlbiBub3QgaW4gZXhwcmVzc2lvbiBjb250
ZXh0IOKAlCBzdGF0ZW1lbnQgbGV2ZWwpXG4gICAgICAvLyBEaXNhbWJpZ3VhdGlvbjogYXQgc3Rh
dGVtZW50IGxldmVsLCBpZCAvPSBleHByIGlzIGNvbXBvdW5kIGRpdmlkZS1hc3NpZ25cbiAgICAg
IC8vIEJ1dCAvPSBpcyBhbHNvIG5vdC1lcXVhbCBvcGVyYXRvci4gQXQgc3RhdGVtZW50IGxldmVs
OiBpZCAvPSBleHByIOKGkiBkaXZpZGUtYXNzaWduLlxuICAgICAgaWYgKHRva2Vuc1twb3MgKyAx
XSAmJiB0b2tlbnNbcG9zICsgMV0udmFsdWUgPT09ICcvPScpIHtcbiAgICAgICAgLy8gbG9vayBm
dXJ0aGVyOiBpZiB0aGlzIGlzIGEgc3RhbmRhbG9uZSBzdGF0ZW1lbnQgKGlkIC89IGV4cHIpLCB0
cmVhdCBhcyBjb21wb3VuZCBhc3NpZ25cbiAgICAgICAgY29uc3Qgb3AgPSAnLyc7XG4gICAgICAg
IHBvcysrOyBwb3MrKztcbiAgICAgICAgY29uc3QgcmhzID0gcGFyc2VFeHByKDApO1xuICAgICAg
ICByZXR1cm4geyB0eXBlOiAnQXNzaWduJywgbmFtZSwgdmFsdWU6IHsgdHlwZTogJ0Jpbk9wJywg
b3AsIGxlZnQ6IHsgdHlwZTogJ0lkZW50JywgbmFtZSB9LCByaWdodDogcmhzIH0gfTtcbiAgICAg
IH1cbiAgICB9XG5cbiAgICAvLyBleHByZXNzaW9uIHN0YXRlbWVudCAoZS5nLiwgYmFyZSBmdW5j
dGlvbiBjYWxsKVxuICAgIGNvbnN0IGV4cHIgPSBwYXJzZUV4cHIoMCk7XG4gICAgaWYgKGV4cHIu
dHlwZSA9PT0gJ0Z1bmNDYWxsJykgcmV0dXJuIHsgdHlwZTogJ0NhbGwnLCBuYW1lOiBleHByLm5h
bWUsIGFyZ3M6IGV4cHIuYXJncyB9O1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVW5leHBl
Y3RlZCBleHByZXNzaW9uIHN0YXRlbWVudCBhdCAke2N1cigpLmxpbmV9OiR7Y3VyKCkuY29sfWAp
O1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VJZihpc0Vsc2VJZikge1xuICAgIGVhdChUT0suS1cs
ICdpZicpO1xuICAgIGVhdChUT0suUFVOQywgJygnKTtcbiAgICBjb25zdCBjb25kID0gcGFyc2VF
eHByKDApO1xuICAgIGVhdChUT0suUFVOQywgJyknKTtcbiAgICBlYXQoVE9LLktXLCAndGhlbicp
O1xuICAgIGNvbnN0IGJvZHkgPSBbXTtcbiAgICB3aGlsZSAoIWF0KFRPSy5LVywgJ2Vsc2UnKSAm
JiAhYXQoVE9LLktXLCAnZW5kJykgJiYgIWF0KFRPSy5FT0YpKSB7XG4gICAgICBib2R5LnB1c2go
cGFyc2VTdGF0ZW1lbnQoKSk7XG4gICAgfVxuICAgIGxldCBlbHNlQm9keSA9IG51bGw7XG4gICAg
aWYgKG1heWJlKFRPSy5LVywgJ2Vsc2UnKSkge1xuICAgICAgaWYgKGF0KFRPSy5LVywgJ2lmJykp
IHtcbiAgICAgICAgLy8gZWxzZSBpZiBjaGFpbjogaW5uZXIgcGFyc2VJZiBoYW5kbGVzIGV2ZXJ5
dGhpbmcgaW5jbHVkaW5nIGVuZCBpZlxuICAgICAgICBlbHNlQm9keSA9IFtwYXJzZUlmKHRydWUp
XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsc2VCb2R5ID0gW107XG4gICAgICAgIHdoaWxl
ICghYXQoVE9LLktXLCAnZW5kJykgJiYgIWF0KFRPSy5FT0YpKSB7XG4gICAgICAgICAgZWxzZUJv
ZHkucHVzaChwYXJzZVN0YXRlbWVudCgpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAg
ICAvLyBPbmx5IGNvbnN1bWUgJ2VuZCBpZicgYXQgdGhlIG91dGVybW9zdCBpZiAobm90IGluIGVs
c2UtaWYgY2hhaW4pXG4gICAgaWYgKCFpc0Vsc2VJZiAmJiBhdChUT0suS1csICdlbmQnKSkge1xu
ICAgICAgcG9zKys7XG4gICAgICBtYXliZShUT0suS1csICdpZicpO1xuICAgIH1cbiAgICByZXR1
cm4geyB0eXBlOiAnSWYnLCBjb25kLCBib2R5LCBlbHNlQm9keSB9O1xuICB9XG5cbiAgZnVuY3Rp
b24gcGFyc2VGb3IoKSB7XG4gICAgZWF0KFRPSy5LVywgJ2ZvcicpO1xuICAgIGNvbnN0IHZhck5h
bWUgPSBlYXQoVE9LLklEKS52YWx1ZTtcbiAgICBlYXQoVE9LLk9QLCAnOj0nKTtcbiAgICBjb25z
dCBzdGFydCA9IHBhcnNlRXhwcigwKTtcbiAgICBlYXQoVE9LLlBVTkMsICcsJyk7XG4gICAgY29u
c3QgZW5kID0gcGFyc2VFeHByKDApO1xuICAgIGxldCBzdGVwID0gbnVsbDtcbiAgICBpZiAobWF5
YmUoVE9LLlBVTkMsICcsJykpIHN0ZXAgPSBwYXJzZUV4cHIoMCk7XG4gICAgY29uc3QgYm9keSA9
IFtdO1xuICAgIHdoaWxlICghYXQoVE9LLktXLCAnZW5kJykgJiYgIWF0KFRPSy5FT0YpKSBib2R5
LnB1c2gocGFyc2VTdGF0ZW1lbnQoKSk7XG4gICAgZWF0KFRPSy5LVywgJ2VuZCcpO1xuICAgIGVh
dChUT0suS1csICdmb3InKTtcbiAgICByZXR1cm4geyB0eXBlOiAnRm9yJywgdmFyTmFtZSwgc3Rh
cnQsIGVuZCwgc3RlcCwgYm9keSB9O1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VXaGlsZSgpIHtc
biAgICBlYXQoVE9LLktXLCAnd2hpbGUnKTtcbiAgICBlYXQoVE9LLlBVTkMsICcoJyk7XG4gICAg
Y29uc3QgY29uZCA9IHBhcnNlRXhwcigwKTtcbiAgICBlYXQoVE9LLlBVTkMsICcpJyk7XG4gICAg
Y29uc3QgYm9keSA9IFtdO1xuICAgIHdoaWxlICghYXQoVE9LLktXLCAnZW5kJykgJiYgIWF0KFRP
Sy5FT0YpKSBib2R5LnB1c2gocGFyc2VTdGF0ZW1lbnQoKSk7XG4gICAgZWF0KFRPSy5LVywgJ2Vu
ZCcpO1xuICAgIGVhdChUT0suS1csICd3aGlsZScpO1xuICAgIHJldHVybiB7IHR5cGU6ICdXaGls
ZScsIGNvbmQsIGJvZHkgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlRG9XaGlsZSgpIHtcbiAg
ICBlYXQoVE9LLktXLCAnZG8nKTtcbiAgICBjb25zdCBib2R5ID0gW107XG4gICAgd2hpbGUgKCFh
dChUT0suS1csICd3aGlsZScpICYmICFhdChUT0suRU9GKSkgYm9keS5wdXNoKHBhcnNlU3RhdGVt
ZW50KCkpO1xuICAgIGVhdChUT0suS1csICd3aGlsZScpO1xuICAgIGVhdChUT0suUFVOQywgJygn
KTtcbiAgICBjb25zdCBjb25kID0gcGFyc2VFeHByKDApO1xuICAgIGVhdChUT0suUFVOQywgJykn
KTtcbiAgICByZXR1cm4geyB0eXBlOiAnRG9XaGlsZScsIGNvbmQsIGJvZHkgfTtcbiAgfVxuXG4g
IGZ1bmN0aW9uIHBhcnNlQXJncygpIHtcbiAgICBjb25zdCBhcmdzID0gW107XG4gICAgaWYgKCFh
dChUT0suUFVOQywgJyknKSkge1xuICAgICAgYXJncy5wdXNoKHBhcnNlRXhwcigwKSk7XG4gICAg
ICB3aGlsZSAobWF5YmUoVE9LLlBVTkMsICcsJykpIGFyZ3MucHVzaChwYXJzZUV4cHIoMCkpO1xu
ICAgIH1cbiAgICByZXR1cm4gYXJncztcbiAgfVxuXG4gIC8vIOKUgOKUgCBQcmF0dCBleHByZXNz
aW9uIHBhcnNlciDilIDilIBcblxuICAvLyBCaW5kaW5nIHBvd2VycyAoaGlnaGVyID0gdGlnaHRl
cilcbiAgZnVuY3Rpb24gbGJwKHRvaykge1xuICAgIGlmICh0b2sudHlwZSA9PT0gVE9LLktXKSB7
XG4gICAgICBpZiAodG9rLnZhbHVlID09PSAnb3InKSByZXR1cm4gMjtcbiAgICAgIGlmICh0b2su
dmFsdWUgPT09ICdhbmQnKSByZXR1cm4gNDtcbiAgICAgIGlmICh0b2sudmFsdWUgPT09ICdtb2Qn
KSByZXR1cm4gMTg7XG4gICAgfVxuICAgIGlmICh0b2sudHlwZSA9PT0gVE9LLk9QKSB7XG4gICAg
ICBjb25zdCB2ID0gdG9rLnZhbHVlO1xuICAgICAgaWYgKHYgPT09ICc9PScgfHwgdiA9PT0gJy89
JyB8fCB2ID09PSAnPCcgfHwgdiA9PT0gJz4nIHx8IHYgPT09ICc8PScgfHwgdiA9PT0gJz49Jykg
cmV0dXJuIDY7XG4gICAgICBpZiAodiA9PT0gJ3wnKSByZXR1cm4gODtcbiAgICAgIGlmICh2ID09
PSAnXicpIHJldHVybiAxMDtcbiAgICAgIGlmICh2ID09PSAnJicpIHJldHVybiAxMjtcbiAgICAg
IGlmICh2ID09PSAnPDwnIHx8IHYgPT09ICc+PicpIHJldHVybiAxNDtcbiAgICAgIGlmICh2ID09
PSAnKycgfHwgdiA9PT0gJy0nKSByZXR1cm4gMTY7XG4gICAgICBpZiAodiA9PT0gJyonIHx8IHYg
PT09ICcvJykgcmV0dXJuIDE4O1xuICAgICAgaWYgKHYgPT09ICcqKicpIHJldHVybiAyMjsgLy8g
cmlnaHQtYXNzb2MgaGFuZGxlZCBieSB1c2luZyByYnAgPSAyMiAtIDFcbiAgICB9XG4gICAgcmV0
dXJuIDA7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUV4cHIobWluQnApIHtcbiAgICBsZXQgbGVm
dCA9IHBhcnNlUHJlZml4KCk7XG5cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgY29uc3QgdCA9
IGN1cigpO1xuICAgICAgY29uc3QgYnAgPSBsYnAodCk7XG4gICAgICBpZiAoYnAgPT09IDAgfHwg
YnAgPCBtaW5CcCkgYnJlYWs7XG5cbiAgICAgIC8vIGlmLWV4cHJlc3Npb24gKHRlcm5hcnkpOiBp
ZiAoY29uZCkgdGhlbiBhIGVsc2UgYlxuICAgICAgLy8gTm90IGhhbmRsZWQgaGVyZSDigJQgaXQn
cyBhIHByZWZpeCBmb3JtXG4gICAgICBpZiAodC50eXBlID09PSBUT0suS1cgJiYgdC52YWx1ZSA9
PT0gJ29yJykgeyBwb3MrKzsgbGVmdCA9IHsgdHlwZTogJ0Jpbk9wJywgb3A6ICdvcicsIGxlZnQs
IHJpZ2h0OiBwYXJzZUV4cHIoYnAgKyAxKSB9OyBjb250aW51ZTsgfVxuICAgICAgaWYgKHQudHlw
ZSA9PT0gVE9LLktXICYmIHQudmFsdWUgPT09ICdhbmQnKSB7IHBvcysrOyBsZWZ0ID0geyB0eXBl
OiAnQmluT3AnLCBvcDogJ2FuZCcsIGxlZnQsIHJpZ2h0OiBwYXJzZUV4cHIoYnAgKyAxKSB9OyBj
b250aW51ZTsgfVxuICAgICAgaWYgKHQudHlwZSA9PT0gVE9LLktXICYmIHQudmFsdWUgPT09ICdt
b2QnKSB7IHBvcysrOyBsZWZ0ID0geyB0eXBlOiAnQmluT3AnLCBvcDogJ21vZCcsIGxlZnQsIHJp
Z2h0OiBwYXJzZUV4cHIoYnAgKyAxKSB9OyBjb250aW51ZTsgfVxuXG4gICAgICBpZiAodC50eXBl
ID09PSBUT0suT1ApIHtcbiAgICAgICAgaWYgKHQudmFsdWUgPT09ICcqKicpIHtcbiAgICAgICAg
ICBwb3MrKztcbiAgICAgICAgICAvLyByaWdodC1hc3NvY2lhdGl2ZTogdXNlIGJwIGluc3RlYWQg
b2YgYnArMVxuICAgICAgICAgIGxlZnQgPSB7IHR5cGU6ICdCaW5PcCcsIG9wOiAnKionLCBsZWZ0
LCByaWdodDogcGFyc2VFeHByKGJwKSB9O1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9
XG4gICAgICAgIHBvcysrO1xuICAgICAgICBsZWZ0ID0geyB0eXBlOiAnQmluT3AnLCBvcDogdC52
YWx1ZSwgbGVmdCwgcmlnaHQ6IHBhcnNlRXhwcihicCArIDEpIH07XG4gICAgICAgIGNvbnRpbnVl
O1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBsZWZ0O1xuICB9XG5c
biAgZnVuY3Rpb24gcGFyc2VQcmVmaXgoKSB7XG4gICAgY29uc3QgdCA9IGN1cigpO1xuXG4gICAg
Ly8gcGFyZW50aGVzaXplZCBleHByZXNzaW9uXG4gICAgaWYgKHQudHlwZSA9PT0gVE9LLlBVTkMg
JiYgdC52YWx1ZSA9PT0gJygnKSB7XG4gICAgICBwb3MrKztcbiAgICAgIGNvbnN0IGV4cHIgPSBw
YXJzZUV4cHIoMCk7XG4gICAgICBlYXQoVE9LLlBVTkMsICcpJyk7XG4gICAgICByZXR1cm4gZXhw
cjtcbiAgICB9XG5cbiAgICAvLyBpZi1leHByZXNzaW9uICh0ZXJuYXJ5KTogaWYgKGNvbmQpIHRo
ZW4gYSBlbHNlIGJcbiAgICBpZiAodC50eXBlID09PSBUT0suS1cgJiYgdC52YWx1ZSA9PT0gJ2lm
Jykge1xuICAgICAgcG9zKys7XG4gICAgICBlYXQoVE9LLlBVTkMsICcoJyk7XG4gICAgICBjb25z
dCBjb25kID0gcGFyc2VFeHByKDApO1xuICAgICAgZWF0KFRPSy5QVU5DLCAnKScpO1xuICAgICAg
ZWF0KFRPSy5LVywgJ3RoZW4nKTtcbiAgICAgIGNvbnN0IHRoZW5FeHByID0gcGFyc2VFeHByKDAp
O1xuICAgICAgZWF0KFRPSy5LVywgJ2Vsc2UnKTtcbiAgICAgIGNvbnN0IGVsc2VFeHByID0gcGFy
c2VFeHByKDApO1xuICAgICAgcmV0dXJuIHsgdHlwZTogJ0lmRXhwcicsIGNvbmQsIHRoZW5FeHBy
LCBlbHNlRXhwciB9O1xuICAgIH1cblxuICAgIC8vIHVuYXJ5IG1pbnVzXG4gICAgaWYgKHQudHlw
ZSA9PT0gVE9LLk9QICYmIHQudmFsdWUgPT09ICctJykge1xuICAgICAgcG9zKys7XG4gICAgICBy
ZXR1cm4geyB0eXBlOiAnVW5hcnlPcCcsIG9wOiAnLScsIG9wZXJhbmQ6IHBhcnNlRXhwcigyMSkg
fTtcbiAgICB9XG4gICAgLy8gbm90XG4gICAgaWYgKHQudHlwZSA9PT0gVE9LLktXICYmIHQudmFs
dWUgPT09ICdub3QnKSB7XG4gICAgICBwb3MrKztcbiAgICAgIHJldHVybiB7IHR5cGU6ICdVbmFy
eU9wJywgb3A6ICdub3QnLCBvcGVyYW5kOiBwYXJzZUV4cHIoMjEpIH07XG4gICAgfVxuICAgIC8v
IGJpdHdpc2Ugbm90XG4gICAgaWYgKHQudHlwZSA9PT0gVE9LLk9QICYmIHQudmFsdWUgPT09ICd+
Jykge1xuICAgICAgcG9zKys7XG4gICAgICByZXR1cm4geyB0eXBlOiAnVW5hcnlPcCcsIG9wOiAn
ficsIG9wZXJhbmQ6IHBhcnNlRXhwcigyMSkgfTtcbiAgICB9XG4gICAgLy8gbnVtYmVyIGxpdGVy
YWxcbiAgICBpZiAodC50eXBlID09PSBUT0suTlVNKSB7XG4gICAgICBwb3MrKztcbiAgICAgIHJl
dHVybiB7IHR5cGU6ICdOdW1iZXJMaXQnLCB2YWx1ZTogdC52YWx1ZSwgaXNGbG9hdDogdC5pc0Zs
b2F0LCB0eXBlU3VmZml4OiB0LnR5cGVTdWZmaXggfTtcbiAgICB9XG4gICAgLy8gdHJ1ZS9mYWxz
ZVxuICAgIGlmICh0LnR5cGUgPT09IFRPSy5LVyAmJiAodC52YWx1ZSA9PT0gJ3RydWUnIHx8IHQu
dmFsdWUgPT09ICdmYWxzZScpKSB7XG4gICAgICBwb3MrKztcbiAgICAgIHJldHVybiB7IHR5cGU6
ICdOdW1iZXJMaXQnLCB2YWx1ZTogdC52YWx1ZSA9PT0gJ3RydWUnID8gJzEnIDogJzAnLCBpc0Zs
b2F0OiBmYWxzZSwgdHlwZVN1ZmZpeDogJ2kzMicgfTtcbiAgICB9XG4gICAgLy8gaWRlbnRpZmll
ciDigJQgbWF5IGJlIGZ1bmN0aW9uIGNhbGwsIGFycmF5IGFjY2Vzcywgb3IgcGxhaW4gdmFyaWFi
bGVcbiAgICBpZiAodC50eXBlID09PSBUT0suSUQpIHtcbiAgICAgIHBvcysrO1xuICAgICAgY29u
c3QgbmFtZSA9IHQudmFsdWU7XG4gICAgICAvLyBmdW5jdGlvbiBjYWxsOiBuYW1lKC4uLilcbiAg
ICAgIGlmIChhdChUT0suUFVOQywgJygnKSkge1xuICAgICAgICBwb3MrKztcbiAgICAgICAgY29u
c3QgYXJncyA9IHBhcnNlQXJncygpO1xuICAgICAgICBlYXQoVE9LLlBVTkMsICcpJyk7XG4gICAg
ICAgIHJldHVybiB7IHR5cGU6ICdGdW5jQ2FsbCcsIG5hbWUsIGFyZ3MgfTtcbiAgICAgIH1cbiAg
ICAgIC8vIGFycmF5IGFjY2VzczogbmFtZVsuLi5dXG4gICAgICBpZiAoYXQoVE9LLlBVTkMsICdb
JykpIHtcbiAgICAgICAgcG9zKys7XG4gICAgICAgIGNvbnN0IGluZGljZXMgPSBbcGFyc2VFeHBy
KDApXTtcbiAgICAgICAgd2hpbGUgKG1heWJlKFRPSy5QVU5DLCAnLCcpKSBpbmRpY2VzLnB1c2go
cGFyc2VFeHByKDApKTtcbiAgICAgICAgZWF0KFRPSy5QVU5DLCAnXScpO1xuICAgICAgICByZXR1
cm4geyB0eXBlOiAnQXJyYXlBY2Nlc3MnLCBuYW1lLCBpbmRpY2VzIH07XG4gICAgICB9XG4gICAg
ICByZXR1cm4geyB0eXBlOiAnSWRlbnQnLCBuYW1lIH07XG4gICAgfVxuICAgIC8vIHR5cGUgY29u
dmVyc2lvbjogaTMyKC4uLiksIGY2NCguLi4pICDigJQgdHlwZXMgYXJlIGtleXdvcmRzXG4gICAg
aWYgKHQudHlwZSA9PT0gVE9LLktXICYmIEFUUkFfVFlQRVMuaGFzKHQudmFsdWUpICYmIHRva2Vu
c1twb3MgKyAxXSAmJiB0b2tlbnNbcG9zICsgMV0udmFsdWUgPT09ICcoJykge1xuICAgICAgcG9z
Kys7IC8vIHNraXAgdHlwZSBrZXl3b3JkXG4gICAgICBwb3MrKzsgLy8gc2tpcCAoXG4gICAgICBj
b25zdCBhcmcgPSBwYXJzZUV4cHIoMCk7XG4gICAgICBlYXQoVE9LLlBVTkMsICcpJyk7XG4gICAg
ICByZXR1cm4geyB0eXBlOiAnRnVuY0NhbGwnLCBuYW1lOiB0LnZhbHVlLCBhcmdzOiBbYXJnXSB9
O1xuICAgIH1cbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFVuZXhwZWN0ZWQgdG9rZW4gXCIk
e3QudmFsdWV9XCIgYXQgJHt0LmxpbmV9OiR7dC5jb2x9YCk7XG4gIH1cblxuICByZXR1cm4gcGFy
c2VQcm9ncmFtKCk7XG59XG5cbi8vIOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKV
kOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKV
kOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKV
kOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKV
kOKVkOKVkOKVkOKVkOKVkOKVkFxuLy8gNC4gQ09ERSBHRU5FUkFUT1Ig4oCUIGVtaXRzIFdhc20g
YmluYXJ5XG4vLyDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDi
lZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDi
lZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDi
lZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDi
lZDilZDilZBcblxuLy8gV2FzbSBvcGNvZGVzXG5jb25zdCBPUF9VTlJFQUNIQUJMRSA9IDB4MDAs
IE9QX05PUCA9IDB4MDEsIE9QX0JMT0NLID0gMHgwMiwgT1BfTE9PUCA9IDB4MDMsXG4gIE9QX0lG
ID0gMHgwNCwgT1BfRUxTRSA9IDB4MDUsIE9QX0VORCA9IDB4MGIsIE9QX0JSID0gMHgwYywgT1Bf
QlJfSUYgPSAweDBkLFxuICBPUF9SRVRVUk4gPSAweDBmLCBPUF9DQUxMID0gMHgxMCwgT1BfU0VM
RUNUID0gMHgxYixcbiAgT1BfTE9DQUxfR0VUID0gMHgyMCwgT1BfTE9DQUxfU0VUID0gMHgyMSwg
T1BfTE9DQUxfVEVFID0gMHgyMixcbiAgT1BfR0xPQkFMX0dFVCA9IDB4MjMsIE9QX0dMT0JBTF9T
RVQgPSAweDI0LFxuICBPUF9JMzJfTE9BRCA9IDB4MjgsIE9QX0k2NF9MT0FEID0gMHgyOSwgT1Bf
RjMyX0xPQUQgPSAweDJhLCBPUF9GNjRfTE9BRCA9IDB4MmIsXG4gIE9QX0kzMl9TVE9SRSA9IDB4
MzYsIE9QX0k2NF9TVE9SRSA9IDB4MzcsIE9QX0YzMl9TVE9SRSA9IDB4MzgsIE9QX0Y2NF9TVE9S
RSA9IDB4MzksXG4gIE9QX01FTU9SWV9TSVpFID0gMHgzZiwgT1BfTUVNT1JZX0dST1cgPSAweDQw
LFxuICBPUF9JMzJfQ09OU1QgPSAweDQxLCBPUF9JNjRfQ09OU1QgPSAweDQyLCBPUF9GMzJfQ09O
U1QgPSAweDQzLCBPUF9GNjRfQ09OU1QgPSAweDQ0LFxuICBPUF9JMzJfRVFaID0gMHg0NSwgT1Bf
STMyX0VRID0gMHg0NiwgT1BfSTMyX05FID0gMHg0NyxcbiAgT1BfSTMyX0xUX1MgPSAweDQ4LCBP
UF9JMzJfTFRfVSA9IDB4NDksIE9QX0kzMl9HVF9TID0gMHg0YSwgT1BfSTMyX0dUX1UgPSAweDRi
LFxuICBPUF9JMzJfTEVfUyA9IDB4NGMsIE9QX0kzMl9MRV9VID0gMHg0ZCwgT1BfSTMyX0dFX1Mg
PSAweDRlLCBPUF9JMzJfR0VfVSA9IDB4NGYsXG4gIE9QX0k2NF9FUVogPSAweDUwLCBPUF9JNjRf
RVEgPSAweDUxLCBPUF9JNjRfTkUgPSAweDUyLFxuICBPUF9JNjRfTFRfUyA9IDB4NTMsIE9QX0k2
NF9MVF9VID0gMHg1NCwgT1BfSTY0X0dUX1MgPSAweDU1LCBPUF9JNjRfR1RfVSA9IDB4NTYsXG4g
IE9QX0k2NF9MRV9TID0gMHg1NywgT1BfSTY0X0xFX1UgPSAweDU4LCBPUF9JNjRfR0VfUyA9IDB4
NTksIE9QX0k2NF9HRV9VID0gMHg1YSxcbiAgT1BfRjMyX0VRID0gMHg1YiwgT1BfRjMyX05FID0g
MHg1YywgT1BfRjMyX0xUID0gMHg1ZCwgT1BfRjMyX0dUID0gMHg1ZSwgT1BfRjMyX0xFID0gMHg1
ZiwgT1BfRjMyX0dFID0gMHg2MCxcbiAgT1BfRjY0X0VRID0gMHg2MSwgT1BfRjY0X05FID0gMHg2
MiwgT1BfRjY0X0xUID0gMHg2MywgT1BfRjY0X0dUID0gMHg2NCwgT1BfRjY0X0xFID0gMHg2NSwg
T1BfRjY0X0dFID0gMHg2NixcbiAgT1BfSTMyX0NMWiA9IDB4NjcsIE9QX0kzMl9DVFogPSAweDY4
LCBPUF9JMzJfUE9QQ05UID0gMHg2OSxcbiAgT1BfSTMyX0FERCA9IDB4NmEsIE9QX0kzMl9TVUIg
PSAweDZiLCBPUF9JMzJfTVVMID0gMHg2YyxcbiAgT1BfSTMyX0RJVl9TID0gMHg2ZCwgT1BfSTMy
X0RJVl9VID0gMHg2ZSwgT1BfSTMyX1JFTV9TID0gMHg2ZiwgT1BfSTMyX1JFTV9VID0gMHg3MCxc
biAgT1BfSTMyX0FORCA9IDB4NzEsIE9QX0kzMl9PUiA9IDB4NzIsIE9QX0kzMl9YT1IgPSAweDcz
LFxuICBPUF9JMzJfU0hMID0gMHg3NCwgT1BfSTMyX1NIUl9TID0gMHg3NSwgT1BfSTMyX1NIUl9V
ID0gMHg3NixcbiAgT1BfSTMyX1JPVEwgPSAweDc3LCBPUF9JMzJfUk9UUiA9IDB4NzgsXG4gIE9Q
X0k2NF9DTFogPSAweDc5LCBPUF9JNjRfQ1RaID0gMHg3YSwgT1BfSTY0X1BPUENOVCA9IDB4N2Is
XG4gIE9QX0k2NF9BREQgPSAweDdjLCBPUF9JNjRfU1VCID0gMHg3ZCwgT1BfSTY0X01VTCA9IDB4
N2UsXG4gIE9QX0k2NF9ESVZfUyA9IDB4N2YsIE9QX0k2NF9ESVZfVSA9IDB4ODAsIE9QX0k2NF9S
RU1fUyA9IDB4ODEsIE9QX0k2NF9SRU1fVSA9IDB4ODIsXG4gIE9QX0k2NF9BTkQgPSAweDgzLCBP
UF9JNjRfT1IgPSAweDg0LCBPUF9JNjRfWE9SID0gMHg4NSxcbiAgT1BfSTY0X1NITCA9IDB4ODYs
IE9QX0k2NF9TSFJfUyA9IDB4ODcsIE9QX0k2NF9TSFJfVSA9IDB4ODgsXG4gIE9QX0k2NF9ST1RM
ID0gMHg4OSwgT1BfSTY0X1JPVFIgPSAweDhhLFxuICBPUF9GMzJfQUJTID0gMHg4YiwgT1BfRjMy
X05FRyA9IDB4OGMsIE9QX0YzMl9DRUlMID0gMHg4ZCwgT1BfRjMyX0ZMT09SID0gMHg4ZSxcbiAg
T1BfRjMyX1RSVU5DID0gMHg4ZiwgT1BfRjMyX05FQVJFU1QgPSAweDkwLCBPUF9GMzJfU1FSVCA9
IDB4OTEsXG4gIE9QX0YzMl9BREQgPSAweDkyLCBPUF9GMzJfU1VCID0gMHg5MywgT1BfRjMyX01V
TCA9IDB4OTQsIE9QX0YzMl9ESVYgPSAweDk1LFxuICBPUF9GMzJfTUlOID0gMHg5NiwgT1BfRjMy
X01BWCA9IDB4OTcsIE9QX0YzMl9DT1BZU0lHTiA9IDB4OTgsXG4gIE9QX0Y2NF9BQlMgPSAweDk5
LCBPUF9GNjRfTkVHID0gMHg5YSwgT1BfRjY0X0NFSUwgPSAweDliLCBPUF9GNjRfRkxPT1IgPSAw
eDljLFxuICBPUF9GNjRfVFJVTkMgPSAweDlkLCBPUF9GNjRfTkVBUkVTVCA9IDB4OWUsIE9QX0Y2
NF9TUVJUID0gMHg5ZixcbiAgT1BfRjY0X0FERCA9IDB4YTAsIE9QX0Y2NF9TVUIgPSAweGExLCBP
UF9GNjRfTVVMID0gMHhhMiwgT1BfRjY0X0RJViA9IDB4YTMsXG4gIE9QX0Y2NF9NSU4gPSAweGE0
LCBPUF9GNjRfTUFYID0gMHhhNSwgT1BfRjY0X0NPUFlTSUdOID0gMHhhNixcbiAgT1BfSTMyX1dS
QVBfSTY0ID0gMHhhNyxcbiAgT1BfSTMyX1RSVU5DX0YzMl9TID0gMHhhOCwgT1BfSTMyX1RSVU5D
X0Y2NF9TID0gMHhhYSxcbiAgT1BfSTY0X0VYVEVORF9JMzJfUyA9IDB4YWMsIE9QX0k2NF9FWFRF
TkRfSTMyX1UgPSAweGFkLFxuICBPUF9JNjRfVFJVTkNfRjMyX1MgPSAweGFlLCBPUF9JNjRfVFJV
TkNfRjY0X1MgPSAweGIwLFxuICBPUF9GMzJfQ09OVkVSVF9JMzJfUyA9IDB4YjIsIE9QX0YzMl9D
T05WRVJUX0k2NF9TID0gMHhiNCxcbiAgT1BfRjMyX0RFTU9URV9GNjQgPSAweGI2LFxuICBPUF9G
NjRfQ09OVkVSVF9JMzJfUyA9IDB4YjcsIE9QX0Y2NF9DT05WRVJUX0k2NF9TID0gMHhiOSxcbiAg
T1BfRjY0X1BST01PVEVfRjMyID0gMHhiYixcbiAgT1BfSTMyX1JFSU5URVJQUkVUX0YzMiA9IDB4
YmMsIE9QX0k2NF9SRUlOVEVSUFJFVF9GNjQgPSAweGJkLFxuICBPUF9GMzJfUkVJTlRFUlBSRVRf
STMyID0gMHhiZSwgT1BfRjY0X1JFSU5URVJQUkVUX0k2NCA9IDB4YmYsXG4gIE9QX0kzMl9FWFRF
TkQ4X1MgPSAweGMwLCBPUF9JMzJfRVhURU5EMTZfUyA9IDB4YzEsXG4gIE9QX0k2NF9FWFRFTkQ4
X1MgPSAweGMyLCBPUF9JNjRfRVhURU5EMTZfUyA9IDB4YzMsIE9QX0k2NF9FWFRFTkQzMl9TID0g
MHhjNDtcblxuLy8gV2FzbSBGQyBwcmVmaXggb3Bjb2RlcyAoMHhGQyBwcmVmaXgpXG5jb25zdCBP
UF9GQ19QUkVGSVggPSAweGZjO1xuY29uc3QgT1BfSTMyX1RSVU5DX1NBVF9GMzJfUyA9IDAsIE9Q
X0kzMl9UUlVOQ19TQVRfRjMyX1UgPSAxLFxuICBPUF9JMzJfVFJVTkNfU0FUX0Y2NF9TID0gMiwg
T1BfSTMyX1RSVU5DX1NBVF9GNjRfVSA9IDMsXG4gIE9QX0k2NF9UUlVOQ19TQVRfRjMyX1MgPSA0
LCBPUF9JNjRfVFJVTkNfU0FUX0YzMl9VID0gNSxcbiAgT1BfSTY0X1RSVU5DX1NBVF9GNjRfUyA9
IDYsIE9QX0k2NF9UUlVOQ19TQVRfRjY0X1UgPSA3O1xuXG4vLyBXYXNtIHR5cGUgY29kZXNcbmNv
bnN0IFdBU01fSTMyID0gMHg3ZiwgV0FTTV9JNjQgPSAweDdlLCBXQVNNX0YzMiA9IDB4N2QsIFdB
U01fRjY0ID0gMHg3YztcbmNvbnN0IFdBU01fVk9JRCA9IDB4NDA7XG5cbmZ1bmN0aW9uIHdhc21U
eXBlKHQpIHtcbiAgaWYgKHQgPT09ICdpMzInKSByZXR1cm4gV0FTTV9JMzI7XG4gIGlmICh0ID09
PSAnaTY0JykgcmV0dXJuIFdBU01fSTY0O1xuICBpZiAodCA9PT0gJ2YzMicpIHJldHVybiBXQVNN
X0YzMjtcbiAgaWYgKHQgPT09ICdmNjQnKSByZXR1cm4gV0FTTV9GNjQ7XG4gIHRocm93IG5ldyBF
cnJvcignVW5rbm93biB0eXBlOiAnICsgdCk7XG59XG5cbmZ1bmN0aW9uIHR5cGVTaXplKHQpIHtc
biAgaWYgKHQgPT09ICdpMzInIHx8IHQgPT09ICdmMzInKSByZXR1cm4gNDtcbiAgaWYgKHQgPT09
ICdpNjQnIHx8IHQgPT09ICdmNjQnKSByZXR1cm4gODtcbiAgdGhyb3cgbmV3IEVycm9yKCdVbmtu
b3duIHR5cGU6ICcgKyB0KTtcbn1cblxuZnVuY3Rpb24gaXNGbG9hdCh0KSB7IHJldHVybiB0ID09
PSAnZjMyJyB8fCB0ID09PSAnZjY0JzsgfVxuZnVuY3Rpb24gaXNJbnQodCkgeyByZXR1cm4gdCA9
PT0gJ2kzMicgfHwgdCA9PT0gJ2k2NCc7IH1cblxuLy8g4pSA4pSAIEJ5dGVXcml0ZXIg4pSA4pSA
XG5cbmNsYXNzIEJ5dGVXcml0ZXIge1xuICBjb25zdHJ1Y3RvcigpIHsgdGhpcy5idWYgPSBbXTsg
fVxuICBieXRlKGIpIHsgdGhpcy5idWYucHVzaChiICYgMHhmZik7IH1cbiAgYnl0ZXMoYXJyKSB7
IGZvciAoY29uc3QgYiBvZiBhcnIpIHRoaXMuYnl0ZShiKTsgfVxuICB1MzIodikgeyAvLyBMRUIx
MjggdW5zaWduZWRcbiAgICBkbyB7IGxldCBiID0gdiAmIDB4N2Y7IHYgPj4+PSA3OyBpZiAodikg
YiB8PSAweDgwOyB0aGlzLmJ5dGUoYik7IH0gd2hpbGUgKHYpO1xuICB9XG4gIHMzMih2KSB7IC8v
IExFQjEyOCBzaWduZWRcbiAgICBsZXQgbW9yZSA9IHRydWU7XG4gICAgd2hpbGUgKG1vcmUpIHtc
biAgICAgIGxldCBiID0gdiAmIDB4N2Y7IHYgPj49IDc7XG4gICAgICBpZiAoKHYgPT09IDAgJiYg
IShiICYgMHg0MCkpIHx8ICh2ID09PSAtMSAmJiAoYiAmIDB4NDApKSkgbW9yZSA9IGZhbHNlOyBl
bHNlIGIgfD0gMHg4MDtcbiAgICAgIHRoaXMuYnl0ZShiKTtcbiAgICB9XG4gIH1cbiAgczY0KHYp
IHsgLy8gTEVCMTI4IHNpZ25lZCBmb3IgaTY0IChCaWdJbnQpXG4gICAgdiA9IEJpZ0ludCh2KTtc
biAgICBsZXQgbW9yZSA9IHRydWU7XG4gICAgd2hpbGUgKG1vcmUpIHtcbiAgICAgIGxldCBiID0g
TnVtYmVyKHYgJiAweDdmbik7IHYgPj49IDduO1xuICAgICAgaWYgKCh2ID09PSAwbiAmJiAhKGIg
JiAweDQwKSkgfHwgKHYgPT09IC0xbiAmJiAoYiAmIDB4NDApKSkgbW9yZSA9IGZhbHNlOyBlbHNl
IGIgfD0gMHg4MDtcbiAgICAgIHRoaXMuYnl0ZShiKTtcbiAgICB9XG4gIH1cbiAgZjMyKHYpIHsg
Y29uc3QgYnVmID0gbmV3IEFycmF5QnVmZmVyKDQpOyBuZXcgRGF0YVZpZXcoYnVmKS5zZXRGbG9h
dDMyKDAsIHYsIHRydWUpOyB0aGlzLmJ5dGVzKG5ldyBVaW50OEFycmF5KGJ1ZikpOyB9XG4gIGY2
NCh2KSB7IGNvbnN0IGJ1ZiA9IG5ldyBBcnJheUJ1ZmZlcig4KTsgbmV3IERhdGFWaWV3KGJ1Ziku
c2V0RmxvYXQ2NCgwLCB2LCB0cnVlKTsgdGhpcy5ieXRlcyhuZXcgVWludDhBcnJheShidWYpKTsg
fVxuICBzdHIocykgeyBjb25zdCBlbmMgPSBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUocyk7IHRo
aXMudTMyKGVuYy5sZW5ndGgpOyB0aGlzLmJ5dGVzKGVuYyk7IH1cbiAgc2VjdGlvbihpZCwgY29u
dGVudEZuKSB7XG4gICAgY29uc3QgaW5uZXIgPSBuZXcgQnl0ZVdyaXRlcigpO1xuICAgIGNvbnRl
bnRGbihpbm5lcik7XG4gICAgdGhpcy5ieXRlKGlkKTtcbiAgICB0aGlzLnUzMihpbm5lci5idWYu
bGVuZ3RoKTtcbiAgICB0aGlzLmJ5dGVzKGlubmVyLmJ1Zik7XG4gIH1cbiAgdG9VaW50OEFycmF5
KCkgeyByZXR1cm4gbmV3IFVpbnQ4QXJyYXkodGhpcy5idWYpOyB9XG59XG5cbmZ1bmN0aW9uIGNv
ZGVnZW4oYXN0LCBpbnRlcnBWYWx1ZXMsIHVzZXJJbXBvcnRzKSB7XG4gIGNvbnN0IHcgPSBuZXcg
Qnl0ZVdyaXRlcigpO1xuXG4gIC8vIOKUgOKUgCBDb2xsZWN0IGluZm8g4pSA4pSAXG4gIGNvbnN0
IGdsb2JhbHMgPSBbXTsgICAgLy8geyBuYW1lLCB2dHlwZSwgbXV0YWJsZSwgaW5pdCB9XG4gIGNv
bnN0IGZ1bmN0aW9ucyA9IFtdOyAgLy8gQVNUIG5vZGVzXG4gIGNvbnN0IGltcG9ydHMgPSBbXTsg
ICAgLy8geyBuYW1lLCBtb2R1bGVOYW1lLCBwYXJhbXMsIHJldFR5cGUsIGludGVycElkeCB9XG4g
IGNvbnN0IGxvY2FsRnVuY05hbWVzID0gbmV3IFNldCgpO1xuXG4gIGZvciAoY29uc3Qgbm9kZSBv
ZiBhc3QuYm9keSkge1xuICAgIGlmIChub2RlLnR5cGUgPT09ICdDb25zdERlY2wnKSBnbG9iYWxz
LnB1c2goeyBuYW1lOiBub2RlLm5hbWUsIHZ0eXBlOiBub2RlLnZ0eXBlLCBtdXRhYmxlOiBmYWxz
ZSwgaW5pdDogbm9kZS5pbml0IH0pO1xuICAgIGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gJ1ZhckRl
Y2wnKSBnbG9iYWxzLnB1c2goeyBuYW1lOiBub2RlLm5hbWUsIHZ0eXBlOiBub2RlLnZ0eXBlLCBt
dXRhYmxlOiB0cnVlLCBpbml0OiBub2RlLmluaXQgfSk7XG4gICAgZWxzZSBpZiAobm9kZS50eXBl
ID09PSAnRnVuY3Rpb24nIHx8IG5vZGUudHlwZSA9PT0gJ1N1YnJvdXRpbmUnKSB7IGZ1bmN0aW9u
cy5wdXNoKG5vZGUpOyBsb2NhbEZ1bmNOYW1lcy5hZGQobm9kZS5uYW1lKTsgfVxuICAgIGVsc2Ug
aWYgKG5vZGUudHlwZSA9PT0gJ0ltcG9ydERlY2wnKSBpbXBvcnRzLnB1c2gobm9kZSk7XG4gIH1c
blxuICAvLyBNYXRoIGJ1aWx0aW5zIHRoYXQgbmVlZCBpbXBvcnRpbmdcbiAgY29uc3QgTUFUSF9C
VUlMVElOUyA9IHsgc2luOiAxLCBjb3M6IDEsIGxuOiAxLCBleHA6IDEsIHBvdzogMiwgYXRhbjI6
IDIgfTtcbiAgLy8gTmF0aXZlIGJ1aWx0aW5zIChubyBpbXBvcnQgbmVlZGVkKSDigJQgcmVzb2x2
ZWQgcGVyLXR5cGUgaW4gZW1pdEZ1bmNDYWxsXG4gIGNvbnN0IE5BVElWRV9CVUlMVElOUyA9IG5l
dyBTZXQoW1xuICAgICdzcXJ0JywnYWJzJywnZmxvb3InLCdjZWlsJywndHJ1bmMnLCduZWFyZXN0
JywnY29weXNpZ24nLFxuICAgICdtaW4nLCdtYXgnLCdzZWxlY3QnLFxuICAgICdjbHonLCdjdHon
LCdwb3BjbnQnLCdyb3RsJywncm90cicsXG4gICAgJ21lbW9yeV9zaXplJywnbWVtb3J5X2dyb3cn
LFxuICAgICdpMzInLCdpNjQnLCdmMzInLCdmNjQnLCAvLyB0eXBlIGNvbnZlcnNpb25zXG4gIF0p
O1xuXG4gIC8vIFNjYW4gYWxsIGZ1bmN0aW9uIGJvZGllcyBmb3IgdW5yZXNvbHZlZCBjYWxsc1xu
ICBjb25zdCB1c2VkQ2FsbHMgPSBuZXcgU2V0KCk7XG4gIGZ1bmN0aW9uIHNjYW5DYWxscyhzdG10
cykge1xuICAgIGZvciAoY29uc3QgcyBvZiBzdG10cykge1xuICAgICAgaWYgKHMudHlwZSA9PT0g
J0NhbGwnIHx8IHMudHlwZSA9PT0gJ0Z1bmNDYWxsJykgdXNlZENhbGxzLmFkZChzLm5hbWUpO1xu
ICAgICAgaWYgKHMudHlwZSA9PT0gJ0lmJykgeyBzY2FuQ2FsbHMocy5ib2R5KTsgaWYgKHMuZWxz
ZUJvZHkpIHNjYW5DYWxscyhzLmVsc2VCb2R5KTsgfVxuICAgICAgaWYgKHMudHlwZSA9PT0gJ0Zv
cicgfHwgcy50eXBlID09PSAnV2hpbGUnIHx8IHMudHlwZSA9PT0gJ0RvV2hpbGUnKSBzY2FuQ2Fs
bHMocy5ib2R5KTtcbiAgICAgIC8vIHNjYW4gZXhwcmVzc2lvbnNcbiAgICAgIHNjYW5FeHByQ2Fs
bHMocyk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHNjYW5FeHByQ2FsbHMobm9kZSkge1xuICAg
IGlmICghbm9kZSB8fCB0eXBlb2Ygbm9kZSAhPT0gJ29iamVjdCcpIHJldHVybjtcbiAgICBpZiAo
bm9kZS50eXBlID09PSAnRnVuY0NhbGwnKSB1c2VkQ2FsbHMuYWRkKG5vZGUubmFtZSk7XG4gICAg
Ly8gKiogb3BlcmF0b3IgbWF5IG5lZWQgcG93IGltcG9ydCAoZm9yIG5vbi1zcXJ0LCBub24tc21h
bGwtaW50IGV4cG9uZW50cylcbiAgICBpZiAobm9kZS50eXBlID09PSAnQmluT3AnICYmIG5vZGUu
b3AgPT09ICcqKicpIHVzZWRDYWxscy5hZGQoJ3BvdycpO1xuICAgIGZvciAoY29uc3QgayBvZiBP
YmplY3Qua2V5cyhub2RlKSkge1xuICAgICAgY29uc3QgdiA9IG5vZGVba107XG4gICAgICBpZiAo
QXJyYXkuaXNBcnJheSh2KSkgdi5mb3JFYWNoKHNjYW5FeHByQ2FsbHMpO1xuICAgICAgZWxzZSBp
ZiAodiAmJiB0eXBlb2YgdiA9PT0gJ29iamVjdCcgJiYgdi50eXBlKSBzY2FuRXhwckNhbGxzKHYp
O1xuICAgIH1cbiAgfVxuICBmb3IgKGNvbnN0IGZuIG9mIGZ1bmN0aW9ucykgc2NhbkNhbGxzKGZu
LmJvZHkpO1xuXG4gIC8vIEF1dG8taW1wb3J0IG1hdGggYnVpbHRpbnMgdGhhdCBhcmUgYWN0dWFs
bHkgdXNlZFxuICBjb25zdCBtYXRoSW1wb3J0cyA9IFtdO1xuICBmb3IgKGNvbnN0IG5hbWUgb2Yg
dXNlZENhbGxzKSB7XG4gICAgaWYgKE1BVEhfQlVJTFRJTlNbbmFtZV0gIT09IHVuZGVmaW5lZCAm
JiAhbG9jYWxGdW5jTmFtZXMuaGFzKG5hbWUpICYmICFpbXBvcnRzLmZpbmQoaW0gPT4gaW0ubmFt
ZSA9PT0gbmFtZSkpIHtcbiAgICAgIGNvbnN0IG5QYXJhbXMgPSBNQVRIX0JVSUxUSU5TW25hbWVd
O1xuICAgICAgY29uc3QgcGFyYW1zID0gW107XG4gICAgICBmb3IgKGxldCBrID0gMDsgayA8IG5Q
YXJhbXM7IGsrKykgcGFyYW1zLnB1c2goeyB0eXBlOiAnUGFyYW0nLCBuYW1lOiAneCcgKyBrLCB2
dHlwZTogJ2Y2NCcsIGlzQXJyYXk6IGZhbHNlLCBhcnJheURpbXM6IG51bGwgfSk7XG4gICAgICBt
YXRoSW1wb3J0cy5wdXNoKHsgbmFtZSwgbW9kdWxlTmFtZTogJ21hdGgnLCBwYXJhbXMsIHJldFR5
cGU6ICdmNjQnLCBpbnRlcnBJZHg6IG51bGwgfSk7XG4gICAgfVxuICB9XG5cbiAgLy8gQXV0by1p
bXBvcnQgZnJvbSB1c2VySW1wb3J0cyBvciBnbG9iYWxUaGlzXG4gIGNvbnN0IGhvc3RJbXBvcnRz
ID0gW107XG4gIGZvciAoY29uc3QgbmFtZSBvZiB1c2VkQ2FsbHMpIHtcbiAgICBpZiAobG9jYWxG
dW5jTmFtZXMuaGFzKG5hbWUpIHx8IE5BVElWRV9CVUlMVElOUy5oYXMobmFtZSkgfHwgbmFtZS5z
dGFydHNXaXRoKCd3YXNtLicpIHx8XG4gICAgICAgIE1BVEhfQlVJTFRJTlNbbmFtZV0gIT09IHVu
ZGVmaW5lZCB8fCBpbXBvcnRzLmZpbmQoaW0gPT4gaW0ubmFtZSA9PT0gbmFtZSkpIGNvbnRpbnVl
O1xuICAgIC8vIGNoZWNrIHVzZXJJbXBvcnRzIHRoZW4gZ2xvYmFsVGhpc1xuICAgIGxldCBmbiA9
IHVzZXJJbXBvcnRzICYmIHVzZXJJbXBvcnRzW25hbWVdO1xuICAgIGlmICghZm4gJiYgdHlwZW9m
IGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnKSBmbiA9IGdsb2JhbFRoaXNbbmFtZV07XG4gICAg
aWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29uc3QgblBhcmFtcyA9IGZu
Lmxlbmd0aDtcbiAgICAgIGNvbnN0IHBhcmFtcyA9IFtdO1xuICAgICAgZm9yIChsZXQgayA9IDA7
IGsgPCBuUGFyYW1zOyBrKyspIHBhcmFtcy5wdXNoKHsgdHlwZTogJ1BhcmFtJywgbmFtZTogJ3gn
ICsgaywgdnR5cGU6ICdmNjQnLCBpc0FycmF5OiBmYWxzZSwgYXJyYXlEaW1zOiBudWxsIH0pO1xu
ICAgICAgaG9zdEltcG9ydHMucHVzaCh7IG5hbWUsIG1vZHVsZU5hbWU6ICdob3N0JywgcGFyYW1z
LCByZXRUeXBlOiAnZjY0JywgaW50ZXJwSWR4OiBudWxsLCBqc0ZuOiBmbiB9KTtcbiAgICB9XG4g
IH1cblxuICBjb25zdCBhbGxJbXBvcnRzID0gWy4uLm1hdGhJbXBvcnRzLCAuLi5pbXBvcnRzLCAu
Li5ob3N0SW1wb3J0c107XG5cbiAgLy8gQnVpbGQgZnVuY3Rpb24gaW5kZXggdGFibGU6IGltcG9y
dHMgZmlyc3QsIHRoZW4gbG9jYWwgZnVuY3Rpb25zXG4gIGNvbnN0IGZ1bmNJbmRleCA9IHt9O1xu
ICBsZXQgaWR4ID0gMDtcbiAgZm9yIChjb25zdCBpbSBvZiBhbGxJbXBvcnRzKSB7IGZ1bmNJbmRl
eFtpbS5uYW1lXSA9IGlkeCsrOyB9XG4gIGZvciAoY29uc3QgZm4gb2YgZnVuY3Rpb25zKSB7IGZ1
bmNJbmRleFtmbi5uYW1lXSA9IGlkeCsrOyB9XG5cbiAgLy8gR2xvYmFsIGluZGV4IHRhYmxlXG4g
IGNvbnN0IGdsb2JhbEluZGV4ID0ge307XG4gIGZvciAobGV0IGdpID0gMDsgZ2kgPCBnbG9iYWxz
Lmxlbmd0aDsgZ2krKykgZ2xvYmFsSW5kZXhbZ2xvYmFsc1tnaV0ubmFtZV0gPSBnaTtcblxuICAv
LyDilIDilIAgQnVpbGQgdHlwZSBzaWduYXR1cmVzIOKUgOKUgFxuICBmdW5jdGlvbiBwYXJhbVdh
c21UeXBlKHApIHsgcmV0dXJuIHAuaXNBcnJheSA/ICdpMzInIDogcC52dHlwZTsgfVxuICBmdW5j
dGlvbiBzaWdLZXkocGFyYW1zLCByZXRUeXBlKSB7XG4gICAgcmV0dXJuIHBhcmFtcy5tYXAocCA9
PiBwYXJhbVdhc21UeXBlKHApKS5qb2luKCcsJykgKyAnOicgKyAocmV0VHlwZSB8fCAnJyk7XG4g
IH1cbiAgY29uc3Qgc2lnTWFwID0gbmV3IE1hcCgpO1xuICBjb25zdCBzaWdMaXN0ID0gW107IC8v
IFt7cGFyYW1zLCByZXRUeXBlfV1cbiAgZnVuY3Rpb24gZ2V0T3JBZGRTaWcocGFyYW1zLCByZXRU
eXBlKSB7XG4gICAgY29uc3Qga2V5ID0gc2lnS2V5KHBhcmFtcywgcmV0VHlwZSk7XG4gICAgaWYg
KHNpZ01hcC5oYXMoa2V5KSkgcmV0dXJuIHNpZ01hcC5nZXQoa2V5KTtcbiAgICBjb25zdCBpZCA9
IHNpZ0xpc3QubGVuZ3RoO1xuICAgIHNpZ0xpc3QucHVzaCh7IHBhcmFtcywgcmV0VHlwZSB9KTtc
biAgICBzaWdNYXAuc2V0KGtleSwgaWQpO1xuICAgIHJldHVybiBpZDtcbiAgfVxuXG4gIC8vIFJl
Z2lzdGVyIGFsbCBzaWduYXR1cmVzXG4gIGNvbnN0IGltcG9ydFNpZ0lkcyA9IGFsbEltcG9ydHMu
bWFwKGltID0+IGdldE9yQWRkU2lnKGltLnBhcmFtcywgaW0ucmV0VHlwZSkpO1xuICBjb25zdCBm
dW5jU2lnSWRzID0gZnVuY3Rpb25zLm1hcChmbiA9PiB7XG4gICAgY29uc3QgcmV0VHlwZSA9IGZu
LnR5cGUgPT09ICdTdWJyb3V0aW5lJyA/IG51bGwgOiBmbi5yZXRUeXBlO1xuICAgIHJldHVybiBn
ZXRPckFkZFNpZyhmbi5wYXJhbXMsIHJldFR5cGUpO1xuICB9KTtcblxuICAvLyDilIDilIAgRGV0
ZXJtaW5lIG1lbW9yeSDilIDilIBcbiAgY29uc3QgaGFzTWVtb3J5ID0gZnVuY3Rpb25zLnNvbWUo
Zm4gPT4gZm4ucGFyYW1zLnNvbWUocCA9PiBwLmlzQXJyYXkpKTtcbiAgY29uc3QgaW1wb3J0TWVt
b3J5ID0gdXNlckltcG9ydHMgJiYgdXNlckltcG9ydHMuX19tZW1vcnk7XG5cbiAgLy8g4pSA4pSA
IEVtaXQgV2FzbSBiaW5hcnkg4pSA4pSAXG4gIC8vIE1hZ2ljICsgdmVyc2lvblxuICB3LmJ5dGVz
KFsweDAwLCAweDYxLCAweDczLCAweDZkXSk7IC8vIFxcMGFzbVxuICB3LmJ5dGVzKFsweDAxLCAw
eDAwLCAweDAwLCAweDAwXSk7IC8vIHZlcnNpb24gMVxuXG4gIC8vIFR5cGUgc2VjdGlvbiAoMSlc
biAgdy5zZWN0aW9uKDEsIHMgPT4ge1xuICAgIHMudTMyKHNpZ0xpc3QubGVuZ3RoKTtcbiAgICBm
b3IgKGNvbnN0IHNpZyBvZiBzaWdMaXN0KSB7XG4gICAgICBzLmJ5dGUoMHg2MCk7IC8vIGZ1bmMg
dHlwZVxuICAgICAgcy51MzIoc2lnLnBhcmFtcy5sZW5ndGgpO1xuICAgICAgZm9yIChjb25zdCBw
IG9mIHNpZy5wYXJhbXMpIHMuYnl0ZSh3YXNtVHlwZShwYXJhbVdhc21UeXBlKHApKSk7XG4gICAg
ICBpZiAoc2lnLnJldFR5cGUpIHsgcy51MzIoMSk7IHMuYnl0ZSh3YXNtVHlwZShzaWcucmV0VHlw
ZSkpOyB9XG4gICAgICBlbHNlIHMudTMyKDApO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gSW1wb3J0
IHNlY3Rpb24gKDIpXG4gIGlmIChhbGxJbXBvcnRzLmxlbmd0aCA+IDAgfHwgaW1wb3J0TWVtb3J5
KSB7XG4gICAgdy5zZWN0aW9uKDIsIHMgPT4ge1xuICAgICAgcy51MzIoYWxsSW1wb3J0cy5sZW5n
dGggKyAoaW1wb3J0TWVtb3J5ID8gMSA6IDApKTtcbiAgICAgIGZvciAobGV0IGlpID0gMDsgaWkg
PCBhbGxJbXBvcnRzLmxlbmd0aDsgaWkrKykge1xuICAgICAgICBjb25zdCBpbSA9IGFsbEltcG9y
dHNbaWldO1xuICAgICAgICBzLnN0cihpbS5tb2R1bGVOYW1lKTtcbiAgICAgICAgcy5zdHIoaW0u
bmFtZSk7XG4gICAgICAgIHMuYnl0ZSgweDAwKTsgLy8gZnVuYyBpbXBvcnRcbiAgICAgICAgcy51
MzIoaW1wb3J0U2lnSWRzW2lpXSk7XG4gICAgICB9XG4gICAgICBpZiAoaW1wb3J0TWVtb3J5KSB7
XG4gICAgICAgIHMuc3RyKCdlbnYnKTtcbiAgICAgICAgcy5zdHIoJ21lbW9yeScpO1xuICAgICAg
ICBzLmJ5dGUoMHgwMik7IC8vIG1lbW9yeSBpbXBvcnRcbiAgICAgICAgcy5ieXRlKDB4MDApOyAv
LyBubyBtYXhcbiAgICAgICAgcy51MzIoMSk7IC8vIGluaXRpYWwgMSBwYWdlXG4gICAgICB9XG4g
ICAgfSk7XG4gIH1cblxuICAvLyBGdW5jdGlvbiBzZWN0aW9uICgzKVxuICB3LnNlY3Rpb24oMywg
cyA9PiB7XG4gICAgcy51MzIoZnVuY3Rpb25zLmxlbmd0aCk7XG4gICAgZm9yIChjb25zdCBzaWdJ
ZCBvZiBmdW5jU2lnSWRzKSBzLnUzMihzaWdJZCk7XG4gIH0pO1xuXG4gIC8vIE1lbW9yeSBzZWN0
aW9uICg1KSDigJQgb25seSBpZiBhcnJheXMgdXNlZCBhbmQgbm8gaW1wb3J0ZWQgbWVtb3J5XG4g
IGlmIChoYXNNZW1vcnkgJiYgIWltcG9ydE1lbW9yeSkge1xuICAgIHcuc2VjdGlvbig1LCBzID0+
IHtcbiAgICAgIHMudTMyKDEpO1xuICAgICAgcy5ieXRlKDB4MDApOyAvLyBubyBtYXhcbiAgICAg
IHMudTMyKDEpOyAvLyBpbml0aWFsOiAxIHBhZ2UgKDY0S0IpXG4gICAgfSk7XG4gIH1cblxuICAv
LyBHbG9iYWwgc2VjdGlvbiAoNilcbiAgaWYgKGdsb2JhbHMubGVuZ3RoID4gMCkge1xuICAgIHcu
c2VjdGlvbig2LCBzID0+IHtcbiAgICAgIHMudTMyKGdsb2JhbHMubGVuZ3RoKTtcbiAgICAgIGZv
ciAoY29uc3QgZyBvZiBnbG9iYWxzKSB7XG4gICAgICAgIHMuYnl0ZSh3YXNtVHlwZShnLnZ0eXBl
KSk7XG4gICAgICAgIHMuYnl0ZShnLm11dGFibGUgPyAweDAxIDogMHgwMCk7XG4gICAgICAgIC8v
IGluaXQgZXhwcmVzc2lvblxuICAgICAgICBlbWl0Q29uc3RFeHByKHMsIGcuaW5pdCwgZy52dHlw
ZSk7XG4gICAgICAgIHMuYnl0ZShPUF9FTkQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAg
Ly8gRXhwb3J0IHNlY3Rpb24gKDcpXG4gIHcuc2VjdGlvbig3LCBzID0+IHtcbiAgICBjb25zdCBl
eHBvcnRzID0gZnVuY3Rpb25zLm1hcCgoZm4sIGkpID0+ICh7IG5hbWU6IGZuLm5hbWUsIGlkeDog
YWxsSW1wb3J0cy5sZW5ndGggKyBpIH0pKTtcbiAgICBjb25zdCBtZW1FeHBvcnQgPSAoaGFzTWVt
b3J5ICYmICFpbXBvcnRNZW1vcnkpID8gMSA6IDA7XG4gICAgcy51MzIoZXhwb3J0cy5sZW5ndGgg
KyBtZW1FeHBvcnQpO1xuICAgIGZvciAoY29uc3QgZSBvZiBleHBvcnRzKSB7XG4gICAgICBzLnN0
cihlLm5hbWUpO1xuICAgICAgcy5ieXRlKDB4MDApOyAvLyBmdW5jIGV4cG9ydFxuICAgICAgcy51
MzIoZS5pZHgpO1xuICAgIH1cbiAgICBpZiAobWVtRXhwb3J0KSB7XG4gICAgICBzLnN0cignbWVt
b3J5Jyk7XG4gICAgICBzLmJ5dGUoMHgwMik7IC8vIG1lbW9yeSBleHBvcnRcbiAgICAgIHMudTMy
KDApO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gQ29kZSBzZWN0aW9uICgxMClcbiAgdy5zZWN0aW9u
KDEwLCBzID0+IHtcbiAgICBzLnUzMihmdW5jdGlvbnMubGVuZ3RoKTtcbiAgICBmb3IgKGNvbnN0
IGZuIG9mIGZ1bmN0aW9ucykge1xuICAgICAgY29uc3QgYm9keVdyaXRlciA9IG5ldyBCeXRlV3Jp
dGVyKCk7XG4gICAgICBlbWl0RnVuY3Rpb25Cb2R5KGJvZHlXcml0ZXIsIGZuKTtcbiAgICAgIHMu
dTMyKGJvZHlXcml0ZXIuYnVmLmxlbmd0aCk7XG4gICAgICBzLmJ5dGVzKGJvZHlXcml0ZXIuYnVm
KTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiB3LnRvVWludDhBcnJheSgpO1xuXG4gIC8vIOKU
gOKUgCBIZWxwZXI6IGVtaXQgY29uc3RhbnQgaW5pdCBleHByZXNzaW9uIOKUgOKUgFxuICBmdW5j
dGlvbiBlbWl0Q29uc3RFeHByKHMsIG5vZGUsIHZ0eXBlKSB7XG4gICAgaWYgKCFub2RlKSB7XG4g
ICAgICAvLyBkZWZhdWx0IHplcm9cbiAgICAgIGlmICh2dHlwZSA9PT0gJ2kzMicpIHsgcy5ieXRl
KE9QX0kzMl9DT05TVCk7IHMuczMyKDApOyB9XG4gICAgICBlbHNlIGlmICh2dHlwZSA9PT0gJ2k2
NCcpIHsgcy5ieXRlKE9QX0k2NF9DT05TVCk7IHMuczY0KDBuKTsgfVxuICAgICAgZWxzZSBpZiAo
dnR5cGUgPT09ICdmMzInKSB7IHMuYnl0ZShPUF9GMzJfQ09OU1QpOyBzLmYzMigwKTsgfVxuICAg
ICAgZWxzZSBpZiAodnR5cGUgPT09ICdmNjQnKSB7IHMuYnl0ZShPUF9GNjRfQ09OU1QpOyBzLmY2
NCgwKTsgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAobm9kZS50eXBlID09PSAnTnVt
YmVyTGl0Jykge1xuICAgICAgY29uc3QgdmFsID0gcGFyc2VOdW1lcmljVmFsdWUobm9kZSwgdnR5
cGUpO1xuICAgICAgZW1pdFR5cGVkQ29uc3QocywgdnR5cGUsIHZhbCk7XG4gICAgICByZXR1cm47
XG4gICAgfVxuICAgIGlmIChub2RlLnR5cGUgPT09ICdVbmFyeU9wJyAmJiBub2RlLm9wID09PSAn
LScgJiYgbm9kZS5vcGVyYW5kLnR5cGUgPT09ICdOdW1iZXJMaXQnKSB7XG4gICAgICBjb25zdCB2
YWwgPSAtcGFyc2VOdW1lcmljVmFsdWUobm9kZS5vcGVyYW5kLCB2dHlwZSk7XG4gICAgICBlbWl0
VHlwZWRDb25zdChzLCB2dHlwZSwgdmFsKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhy
b3cgbmV3IEVycm9yKCdHbG9iYWwgaW5pdCBtdXN0IGJlIGEgY29uc3RhbnQgZXhwcmVzc2lvbicp
O1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VOdW1lcmljVmFsdWUobm9kZSwgZGVmYXVsdFR5cGUp
IHtcbiAgICBjb25zdCByYXcgPSBub2RlLnZhbHVlO1xuICAgIGlmIChyYXcuaW5jbHVkZXMoJy4n
KSB8fCByYXcuaW5jbHVkZXMoJ2UnKSB8fCByYXcuaW5jbHVkZXMoJ0UnKSB8fCBub2RlLmlzRmxv
YXQpIHJldHVybiBwYXJzZUZsb2F0KHJhdyk7XG4gICAgcmV0dXJuIHBhcnNlSW50KHJhdywgMTAp
O1xuICB9XG5cbiAgZnVuY3Rpb24gZW1pdFR5cGVkQ29uc3QocywgdnR5cGUsIHZhbCkge1xuICAg
IGlmICh2dHlwZSA9PT0gJ2kzMicpIHsgcy5ieXRlKE9QX0kzMl9DT05TVCk7IHMuczMyKHZhbCB8
IDApOyB9XG4gICAgZWxzZSBpZiAodnR5cGUgPT09ICdpNjQnKSB7IHMuYnl0ZShPUF9JNjRfQ09O
U1QpOyBzLnM2NChCaWdJbnQodmFsKSk7IH1cbiAgICBlbHNlIGlmICh2dHlwZSA9PT0gJ2YzMicp
IHsgcy5ieXRlKE9QX0YzMl9DT05TVCk7IHMuZjMyKHZhbCk7IH1cbiAgICBlbHNlIGlmICh2dHlw
ZSA9PT0gJ2Y2NCcpIHsgcy5ieXRlKE9QX0Y2NF9DT05TVCk7IHMuZjY0KHZhbCk7IH1cbiAgfVxu
XG4gIC8vIOKUgOKUgCBFbWl0IGZ1bmN0aW9uIGJvZHkg4pSA4pSAXG4gIGZ1bmN0aW9uIGVtaXRG
dW5jdGlvbkJvZHkoYncsIGZuKSB7XG4gICAgY29uc3QgaXNGdW5jID0gZm4udHlwZSA9PT0gJ0Z1
bmN0aW9uJztcbiAgICBjb25zdCByZXRUeXBlID0gaXNGdW5jID8gZm4ucmV0VHlwZSA6IG51bGw7
XG5cbiAgICAvLyBCdWlsZCBsb2NhbCBtYXA6IHBhcmFtcyArIGxvY2FscyArIHJldHVybiB2YXJc
biAgICBjb25zdCBsb2NhbE1hcCA9IHt9OyAvLyBuYW1lIOKGkiB7IGlkeCwgdnR5cGUgfVxuICAg
IGxldCBsb2NhbElkeCA9IDA7XG4gICAgZm9yIChjb25zdCBwIG9mIGZuLnBhcmFtcykge1xuICAg
ICAgbG9jYWxNYXBbcC5uYW1lXSA9IHtcbiAgICAgICAgaWR4OiBsb2NhbElkeCsrLFxuICAgICAg
ICB2dHlwZTogcC5pc0FycmF5ID8gJ2kzMicgOiBwLnZ0eXBlLCAvLyBXYXNtIHR5cGU6IGFycmF5
cyBhcmUgaTMyIHBvaW50ZXJzXG4gICAgICAgIGlzQXJyYXk6IHAuaXNBcnJheSxcbiAgICAgICAg
YXJyYXlEaW1zOiBwLmFycmF5RGltcyxcbiAgICAgICAgZWxlbVR5cGU6IHAuaXNBcnJheSA/IHAu
dnR5cGUgOiBudWxsICAvLyBlbGVtZW50IHR5cGUgZm9yIGxvYWQvc3RvcmVcbiAgICAgIH07XG4g
ICAgfVxuICAgIC8vIEFkZGl0aW9uYWwgbG9jYWxzIGRlY2xhcmVkXG4gICAgY29uc3QgZGVjbGFy
ZWRMb2NhbHMgPSBbLi4uZm4ubG9jYWxzXTtcbiAgICBpZiAoaXNGdW5jKSB7XG4gICAgICAvLyBo
aWRkZW4gcmV0dXJuIGxvY2FsICh1c2VzIGZ1bmN0aW9uIG5hbWUpXG4gICAgICBkZWNsYXJlZExv
Y2Fscy5wdXNoKHsgbmFtZTogJyRfcmV0dXJuJywgdnR5cGU6IHJldFR5cGUgfSk7XG4gICAgfVxu
ICAgIGZvciAoY29uc3QgbG9jIG9mIGRlY2xhcmVkTG9jYWxzKSB7XG4gICAgICBsb2NhbE1hcFts
b2MubmFtZV0gPSB7IGlkeDogbG9jYWxJZHgrKywgdnR5cGU6IGxvYy52dHlwZSB9O1xuICAgIH1c
blxuICAgIC8vIEVtaXQgbG9jYWwgZGVjbGFyYXRpb25zIChvbmx5IHRoZSBub24tcGFyYW0gb25l
cylcbiAgICBjb25zdCBsb2NhbFR5cGVzID0gZGVjbGFyZWRMb2NhbHMubWFwKGwgPT4gbC52dHlw
ZSk7XG4gICAgLy8gQ29tcHJlc3M6IHJ1bnMgb2Ygc2FtZSB0eXBlXG4gICAgY29uc3QgbG9jYWxS
dW5zID0gW107XG4gICAgZm9yIChjb25zdCBsdCBvZiBsb2NhbFR5cGVzKSB7XG4gICAgICBpZiAo
bG9jYWxSdW5zLmxlbmd0aCA+IDAgJiYgbG9jYWxSdW5zW2xvY2FsUnVucy5sZW5ndGggLSAxXS50
eXBlID09PSBsdCkgbG9jYWxSdW5zW2xvY2FsUnVucy5sZW5ndGggLSAxXS5jb3VudCsrO1xuICAg
ICAgZWxzZSBsb2NhbFJ1bnMucHVzaCh7IGNvdW50OiAxLCB0eXBlOiBsdCB9KTtcbiAgICB9XG4g
ICAgYncudTMyKGxvY2FsUnVucy5sZW5ndGgpO1xuICAgIGZvciAoY29uc3QgcnVuIG9mIGxvY2Fs
UnVucykge1xuICAgICAgYncudTMyKHJ1bi5jb3VudCk7XG4gICAgICBidy5ieXRlKHdhc21UeXBl
KHJ1bi50eXBlKSk7XG4gICAgfVxuXG4gICAgLy8gRW1pdCBib2R5IHN0YXRlbWVudHNcbiAgICBs
ZXQgZGVwdGggPSAwOyAvLyBjdXJyZW50IGJsb2NrIG5lc3RpbmcgZGVwdGhcbiAgICBjb25zdCBi
cmVha1RhcmdldHMgPSBbXTsgLy8gc3RhY2sgb2Yge2RlcHRofSBmb3IgZWFjaCBlbmNsb3Npbmcg
bG9vcCdzIGJyZWFrIGJsb2NrXG5cbiAgICBmdW5jdGlvbiBlbWl0U3RtdHMoc3RtdHMpIHsgZm9y
IChjb25zdCBzIG9mIHN0bXRzKSBlbWl0U3RtdChzKTsgfVxuXG4gICAgZnVuY3Rpb24gZW1pdFN0
bXQoc3RtdCkge1xuICAgICAgc3dpdGNoIChzdG10LnR5cGUpIHtcbiAgICAgICAgY2FzZSAnQXNz
aWduJzoge1xuICAgICAgICAgIGNvbnN0IHRhcmdldCA9IHN0bXQubmFtZTtcbiAgICAgICAgICAv
LyBBc3NpZ25tZW50IHRvIGZ1bmN0aW9uIG5hbWUgPSBzZXQgcmV0dXJuIHZhcmlhYmxlXG4gICAg
ICAgICAgaWYgKGlzRnVuYyAmJiB0YXJnZXQgPT09IGZuLm5hbWUpIHtcbiAgICAgICAgICAgIGVt
aXRFeHByKHN0bXQudmFsdWUsIHJldFR5cGUpO1xuICAgICAgICAgICAgYncuYnl0ZShPUF9MT0NB
TF9TRVQpO1xuICAgICAgICAgICAgYncudTMyKGxvY2FsTWFwWyckX3JldHVybiddLmlkeCk7XG4g
ICAgICAgICAgfSBlbHNlIGlmIChsb2NhbE1hcFt0YXJnZXRdKSB7XG4gICAgICAgICAgICBlbWl0
RXhwcihzdG10LnZhbHVlLCBsb2NhbE1hcFt0YXJnZXRdLnZ0eXBlKTtcbiAgICAgICAgICAgIGJ3
LmJ5dGUoT1BfTE9DQUxfU0VUKTtcbiAgICAgICAgICAgIGJ3LnUzMihsb2NhbE1hcFt0YXJnZXRd
LmlkeCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChnbG9iYWxJbmRleFt0YXJnZXRdICE9PSB1bmRl
ZmluZWQpIHtcbiAgICAgICAgICAgIGVtaXRFeHByKHN0bXQudmFsdWUsIGdsb2JhbHNbZ2xvYmFs
SW5kZXhbdGFyZ2V0XV0udnR5cGUpO1xuICAgICAgICAgICAgYncuYnl0ZShPUF9HTE9CQUxfU0VU
KTtcbiAgICAgICAgICAgIGJ3LnUzMihnbG9iYWxJbmRleFt0YXJnZXRdKTtcbiAgICAgICAgICB9
IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmRlZmluZWQgdmFyaWFibGU6
ICR7dGFyZ2V0fWApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxu
ICAgICAgICBjYXNlICdBcnJheVN0b3JlJzoge1xuICAgICAgICAgIGNvbnN0IGluZm8gPSBsb2Nh
bE1hcFtzdG10Lm5hbWVdO1xuICAgICAgICAgIGlmICghaW5mbykgdGhyb3cgbmV3IEVycm9yKGBV
bmRlZmluZWQgYXJyYXk6ICR7c3RtdC5uYW1lfWApO1xuICAgICAgICAgIGNvbnN0IGVsZW1UeXBl
ID0gaW5mby5lbGVtVHlwZSB8fCBpbmZvLnZ0eXBlO1xuICAgICAgICAgIC8vIGNvbXB1dGUgYWRk
cmVzc1xuICAgICAgICAgIGVtaXRBcnJheUFkZHIoc3RtdC5uYW1lLCBzdG10LmluZGljZXMsIGlu
Zm8sIGVsZW1UeXBlKTtcbiAgICAgICAgICAvLyBjb21wdXRlIHZhbHVlXG4gICAgICAgICAgZW1p
dEV4cHIoc3RtdC52YWx1ZSwgZWxlbVR5cGUpO1xuICAgICAgICAgIC8vIHN0b3JlXG4gICAgICAg
ICAgZW1pdFN0b3JlKGVsZW1UeXBlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAg
ICAgICBjYXNlICdJZic6IHtcbiAgICAgICAgICBlbWl0RXhwcihzdG10LmNvbmQsICdpMzInKTtc
biAgICAgICAgICBidy5ieXRlKE9QX0lGKTtcbiAgICAgICAgICBidy5ieXRlKFdBU01fVk9JRCk7
XG4gICAgICAgICAgZGVwdGgrKztcbiAgICAgICAgICBlbWl0U3RtdHMoc3RtdC5ib2R5KTtcbiAg
ICAgICAgICBpZiAoc3RtdC5lbHNlQm9keSkge1xuICAgICAgICAgICAgYncuYnl0ZShPUF9FTFNF
KTtcbiAgICAgICAgICAgIGVtaXRTdG10cyhzdG10LmVsc2VCb2R5KTtcbiAgICAgICAgICB9XG4g
ICAgICAgICAgZGVwdGgtLTtcbiAgICAgICAgICBidy5ieXRlKE9QX0VORCk7XG4gICAgICAgICAg
YnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnRm9yJzoge1xuICAgICAgICAgIGNvbnN0
IHZJbmZvID0gbG9jYWxNYXBbc3RtdC52YXJOYW1lXTtcbiAgICAgICAgICBpZiAoIXZJbmZvKSB0
aHJvdyBuZXcgRXJyb3IoYFVuZGVmaW5lZCBsb29wIHZhcmlhYmxlOiAke3N0bXQudmFyTmFtZX1g
KTtcbiAgICAgICAgICBjb25zdCB2dCA9IHZJbmZvLnZ0eXBlO1xuICAgICAgICAgIGVtaXRFeHBy
KHN0bXQuc3RhcnQsIHZ0KTtcbiAgICAgICAgICBidy5ieXRlKE9QX0xPQ0FMX1NFVCk7XG4gICAg
ICAgICAgYncudTMyKHZJbmZvLmlkeCk7XG5cbiAgICAgICAgICBjb25zdCBoYXNTdGVwID0gc3Rt
dC5zdGVwICE9PSBudWxsO1xuXG4gICAgICAgICAgYncuYnl0ZShPUF9CTE9DSyk7IGJ3LmJ5dGUo
V0FTTV9WT0lEKTsgZGVwdGgrKztcbiAgICAgICAgICBjb25zdCBicmVha0RlcHRoID0gZGVwdGg7
IC8vIGJyZWFrIHRhcmdldCA9IHRoaXMgYmxvY2tcbiAgICAgICAgICBidy5ieXRlKE9QX0xPT1Ap
OyBidy5ieXRlKFdBU01fVk9JRCk7IGRlcHRoKys7XG4gICAgICAgICAgYnJlYWtUYXJnZXRzLnB1
c2goYnJlYWtEZXB0aCk7XG5cbiAgICAgICAgICAvLyBjb25kaXRpb24gY2hlY2s6IGJyX2lmIHRv
IGJyZWFrIGJsb2NrXG4gICAgICAgICAgYncuYnl0ZShPUF9MT0NBTF9HRVQpOyBidy51MzIodklu
Zm8uaWR4KTtcbiAgICAgICAgICBlbWl0RXhwcihzdG10LmVuZCwgdnQpO1xuICAgICAgICAgIGlm
ICghaGFzU3RlcCkge1xuICAgICAgICAgICAgZW1pdENtcCgnPj0nLCB2dCk7XG4gICAgICAgICAg
fSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHN0ZXBJc05lZ0xpdCA9IHN0bXQuc3RlcC50eXBl
ID09PSAnVW5hcnlPcCcgJiYgc3RtdC5zdGVwLm9wID09PSAnLScgJiYgc3RtdC5zdGVwLm9wZXJh
bmQudHlwZSA9PT0gJ051bWJlckxpdCc7XG4gICAgICAgICAgICBjb25zdCBzdGVwSXNOZWdDb25z
dCA9IHN0ZXBJc05lZ0xpdCB8fCAoc3RtdC5zdGVwLnR5cGUgPT09ICdOdW1iZXJMaXQnICYmIHBh
cnNlRmxvYXQoc3RtdC5zdGVwLnZhbHVlKSA8IDApO1xuICAgICAgICAgICAgZW1pdENtcChzdGVw
SXNOZWdDb25zdCA/ICc8PScgOiAnPj0nLCB2dCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJ3
LmJ5dGUoT1BfQlJfSUYpOyBidy51MzIoZGVwdGggLSBicmVha0RlcHRoKTtcblxuICAgICAgICAg
IGVtaXRTdG10cyhzdG10LmJvZHkpO1xuXG4gICAgICAgICAgLy8gaW5jcmVtZW50XG4gICAgICAg
ICAgYncuYnl0ZShPUF9MT0NBTF9HRVQpOyBidy51MzIodkluZm8uaWR4KTtcbiAgICAgICAgICBp
ZiAoaGFzU3RlcCkgeyBlbWl0RXhwcihzdG10LnN0ZXAsIHZ0KTsgfSBlbHNlIHsgZW1pdFR5cGVk
Q29uc3QoYncsIHZ0LCAxKTsgfVxuICAgICAgICAgIGVtaXRBZGQodnQpO1xuICAgICAgICAgIGJ3
LmJ5dGUoT1BfTE9DQUxfU0VUKTsgYncudTMyKHZJbmZvLmlkeCk7XG5cbiAgICAgICAgICBidy5i
eXRlKE9QX0JSKTsgYncudTMyKDApOyAvLyBjb250aW51ZSB0byBsb29wXG4gICAgICAgICAgZGVw
dGgtLTsgYncuYnl0ZShPUF9FTkQpOyAvLyBlbmQgbG9vcFxuICAgICAgICAgIGJyZWFrVGFyZ2V0
cy5wb3AoKTtcbiAgICAgICAgICBkZXB0aC0tOyBidy5ieXRlKE9QX0VORCk7IC8vIGVuZCBibG9j
a1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ1doaWxlJzoge1xu
ICAgICAgICAgIGJ3LmJ5dGUoT1BfQkxPQ0spOyBidy5ieXRlKFdBU01fVk9JRCk7IGRlcHRoKys7
XG4gICAgICAgICAgY29uc3QgYnJlYWtEZXB0aCA9IGRlcHRoO1xuICAgICAgICAgIGJ3LmJ5dGUo
T1BfTE9PUCk7IGJ3LmJ5dGUoV0FTTV9WT0lEKTsgZGVwdGgrKztcbiAgICAgICAgICBicmVha1Rh
cmdldHMucHVzaChicmVha0RlcHRoKTtcblxuICAgICAgICAgIGVtaXRFeHByKHN0bXQuY29uZCwg
J2kzMicpO1xuICAgICAgICAgIGJ3LmJ5dGUoT1BfSTMyX0VRWik7XG4gICAgICAgICAgYncuYnl0
ZShPUF9CUl9JRik7IGJ3LnUzMihkZXB0aCAtIGJyZWFrRGVwdGgpO1xuXG4gICAgICAgICAgZW1p
dFN0bXRzKHN0bXQuYm9keSk7XG5cbiAgICAgICAgICBidy5ieXRlKE9QX0JSKTsgYncudTMyKDAp
OyAvLyBjb250aW51ZSBsb29wXG4gICAgICAgICAgZGVwdGgtLTsgYncuYnl0ZShPUF9FTkQpOyAv
LyBlbmQgbG9vcFxuICAgICAgICAgIGJyZWFrVGFyZ2V0cy5wb3AoKTtcbiAgICAgICAgICBkZXB0
aC0tOyBidy5ieXRlKE9QX0VORCk7IC8vIGVuZCBibG9ja1xuICAgICAgICAgIGJyZWFrO1xuICAg
ICAgICB9XG4gICAgICAgIGNhc2UgJ0RvV2hpbGUnOiB7XG4gICAgICAgICAgYncuYnl0ZShPUF9C
TE9DSyk7IGJ3LmJ5dGUoV0FTTV9WT0lEKTsgZGVwdGgrKztcbiAgICAgICAgICBjb25zdCBicmVh
a0RlcHRoID0gZGVwdGg7XG4gICAgICAgICAgYncuYnl0ZShPUF9MT09QKTsgYncuYnl0ZShXQVNN
X1ZPSUQpOyBkZXB0aCsrO1xuICAgICAgICAgIGJyZWFrVGFyZ2V0cy5wdXNoKGJyZWFrRGVwdGgp
O1xuXG4gICAgICAgICAgZW1pdFN0bXRzKHN0bXQuYm9keSk7XG5cbiAgICAgICAgICBlbWl0RXhw
cihzdG10LmNvbmQsICdpMzInKTtcbiAgICAgICAgICBidy5ieXRlKE9QX0JSX0lGKTsgYncudTMy
KDApOyAvLyBjb250aW51ZSBpZiB0cnVlXG5cbiAgICAgICAgICBkZXB0aC0tOyBidy5ieXRlKE9Q
X0VORCk7IC8vIGVuZCBsb29wXG4gICAgICAgICAgYnJlYWtUYXJnZXRzLnBvcCgpO1xuICAgICAg
ICAgIGRlcHRoLS07IGJ3LmJ5dGUoT1BfRU5EKTsgLy8gZW5kIGJsb2NrXG4gICAgICAgICAgYnJl
YWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnQnJlYWsnOiB7XG4gICAgICAgICAgaWYgKGJy
ZWFrVGFyZ2V0cy5sZW5ndGggPT09IDApIHRocm93IG5ldyBFcnJvcignYnJlYWsgb3V0c2lkZSBs
b29wJyk7XG4gICAgICAgICAgY29uc3QgdGFyZ2V0RGVwdGggPSBicmVha1RhcmdldHNbYnJlYWtU
YXJnZXRzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgIGJ3LmJ5dGUoT1BfQlIpO1xuICAgICAgICAg
IGJ3LnUzMihkZXB0aCAtIHRhcmdldERlcHRoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAg
fVxuICAgICAgICBjYXNlICdDYWxsJzoge1xuICAgICAgICAgIC8vIHN1YnJvdXRpbmUgY2FsbCBv
ciBmdW5jdGlvbiBjYWxsIChyZXN1bHQgZGlzY2FyZGVkKVxuICAgICAgICAgIGNvbnN0IGZJZHgg
PSBmdW5jSW5kZXhbc3RtdC5uYW1lXTtcbiAgICAgICAgICBpZiAoZklkeCA9PT0gdW5kZWZpbmVk
KSB0aHJvdyBuZXcgRXJyb3IoYFVuZGVmaW5lZCBmdW5jdGlvbjogJHtzdG10Lm5hbWV9YCk7XG4g
ICAgICAgICAgZm9yIChsZXQgYWkgPSAwOyBhaSA8IHN0bXQuYXJncy5sZW5ndGg7IGFpKyspIHtc
biAgICAgICAgICAgIC8vIGluZmVyIHBhcmFtIHR5cGUgZnJvbSBkZWNsYXJhdGlvblxuICAgICAg
ICAgICAgY29uc3QgcGFyYW1UeXBlID0gZ2V0UGFyYW1UeXBlKHN0bXQubmFtZSwgYWkpO1xuICAg
ICAgICAgICAgZW1pdEV4cHIoc3RtdC5hcmdzW2FpXSwgcGFyYW1UeXBlKTtcbiAgICAgICAgICB9
XG4gICAgICAgICAgYncuYnl0ZShPUF9DQUxMKTtcbiAgICAgICAgICBidy51MzIoZklkeCk7XG4g
ICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0
aHJvdyBuZXcgRXJyb3IoYFVua25vd24gc3RhdGVtZW50IHR5cGU6ICR7c3RtdC50eXBlfWApO1xu
ICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFBhcmFtVHlwZShmdW5jTmFtZSwgcGFy
YW1JZHgpIHtcbiAgICAgIC8vIGNoZWNrIGxvY2FsIGZ1bmN0aW9uc1xuICAgICAgY29uc3QgZm4g
PSBmdW5jdGlvbnMuZmluZChmID0+IGYubmFtZSA9PT0gZnVuY05hbWUpO1xuICAgICAgaWYgKGZu
ICYmIGZuLnBhcmFtc1twYXJhbUlkeF0pIHJldHVybiBmbi5wYXJhbXNbcGFyYW1JZHhdLmlzQXJy
YXkgPyAnaTMyJyA6IGZuLnBhcmFtc1twYXJhbUlkeF0udnR5cGU7XG4gICAgICAvLyBjaGVjayBp
bXBvcnRzXG4gICAgICBjb25zdCBpbSA9IGFsbEltcG9ydHMuZmluZChpID0+IGkubmFtZSA9PT0g
ZnVuY05hbWUpO1xuICAgICAgaWYgKGltICYmIGltLnBhcmFtc1twYXJhbUlkeF0pIHJldHVybiBp
bS5wYXJhbXNbcGFyYW1JZHhdLnZ0eXBlO1xuICAgICAgcmV0dXJuICdmNjQnOyAvLyBkZWZhdWx0
XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVzb2x2ZVR5cGUobmFtZSkge1xuICAgICAgaWYgKGxv
Y2FsTWFwW25hbWVdKSByZXR1cm4gbG9jYWxNYXBbbmFtZV0udnR5cGU7XG4gICAgICBpZiAoZ2xv
YmFsSW5kZXhbbmFtZV0gIT09IHVuZGVmaW5lZCkgcmV0dXJuIGdsb2JhbHNbZ2xvYmFsSW5kZXhb
bmFtZV1dLnZ0eXBlO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24g
aW5mZXJFeHByVHlwZShleHByKSB7XG4gICAgICBzd2l0Y2ggKGV4cHIudHlwZSkge1xuICAgICAg
ICBjYXNlICdOdW1iZXJMaXQnOiB7XG4gICAgICAgICAgaWYgKGV4cHIudHlwZVN1ZmZpeCkgcmV0
dXJuIGV4cHIudHlwZVN1ZmZpeDtcbiAgICAgICAgICBpZiAoZXhwci5pc0Zsb2F0IHx8IGV4cHIu
dmFsdWUuaW5jbHVkZXMoJy4nKSB8fCBleHByLnZhbHVlLmluY2x1ZGVzKCdlJykgfHwgZXhwci52
YWx1ZS5pbmNsdWRlcygnRScpKSByZXR1cm4gJ2Y2NCc7XG4gICAgICAgICAgcmV0dXJuICdpMzIn
O1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ0lkZW50JzogcmV0dXJuIHJlc29sdmVUeXBlKGV4
cHIubmFtZSkgfHwgJ2Y2NCc7XG4gICAgICAgIGNhc2UgJ0Jpbk9wJzogcmV0dXJuIGluZmVyRXhw
clR5cGUoZXhwci5sZWZ0KTtcbiAgICAgICAgY2FzZSAnVW5hcnlPcCc6IHJldHVybiBpbmZlckV4
cHJUeXBlKGV4cHIub3BlcmFuZCk7XG4gICAgICAgIGNhc2UgJ0Z1bmNDYWxsJzoge1xuICAgICAg
ICAgIC8vIHR5cGUgY29udmVyc2lvbnNcbiAgICAgICAgICBpZiAoQVRSQV9UWVBFUy5oYXMoZXhw
ci5uYW1lKSkgcmV0dXJuIGV4cHIubmFtZTtcbiAgICAgICAgICAvLyBrbm93biByZXR1cm4gdHlw
ZXNcbiAgICAgICAgICBjb25zdCBmbiA9IGZ1bmN0aW9ucy5maW5kKGYgPT4gZi5uYW1lID09PSBl
eHByLm5hbWUpO1xuICAgICAgICAgIGlmIChmbiAmJiBmbi5yZXRUeXBlKSByZXR1cm4gZm4ucmV0
VHlwZTtcbiAgICAgICAgICByZXR1cm4gJ2Y2NCc7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAn
QXJyYXlBY2Nlc3MnOiB7XG4gICAgICAgICAgY29uc3QgaW5mbyA9IGxvY2FsTWFwW2V4cHIubmFt
ZV07XG4gICAgICAgICAgcmV0dXJuIGluZm8gPyAoaW5mby5lbGVtVHlwZSB8fCBpbmZvLnZ0eXBl
KSA6ICdmNjQnO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ0lmRXhwcic6IHJldHVybiBpbmZl
ckV4cHJUeXBlKGV4cHIudGhlbkV4cHIpO1xuICAgICAgICBkZWZhdWx0OiByZXR1cm4gJ2Y2NCc7
XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZW1pdEV4cHIoZXhwciwgZXhwZWN0ZWRU
eXBlKSB7XG4gICAgICBjb25zdCBhY3R1YWxUeXBlID0gZXhwZWN0ZWRUeXBlIHx8IGluZmVyRXhw
clR5cGUoZXhwcik7XG5cbiAgICAgIHN3aXRjaCAoZXhwci50eXBlKSB7XG4gICAgICAgIGNhc2Ug
J051bWJlckxpdCc6IHtcbiAgICAgICAgICBjb25zdCB0ID0gZXhwZWN0ZWRUeXBlIHx8IGluZmVy
RXhwclR5cGUoZXhwcik7XG4gICAgICAgICAgY29uc3QgcmF3ID0gZXhwci52YWx1ZTtcbiAgICAg
ICAgICBpZiAodCA9PT0gJ2kzMicpIHsgYncuYnl0ZShPUF9JMzJfQ09OU1QpOyBidy5zMzIocGFy
c2VJbnQocmF3LCAxMCkgfCAwKTsgfVxuICAgICAgICAgIGVsc2UgaWYgKHQgPT09ICdpNjQnKSB7
IGJ3LmJ5dGUoT1BfSTY0X0NPTlNUKTsgYncuczY0KEJpZ0ludChwYXJzZUludChyYXcsIDEwKSkp
OyB9XG4gICAgICAgICAgZWxzZSBpZiAodCA9PT0gJ2YzMicpIHsgYncuYnl0ZShPUF9GMzJfQ09O
U1QpOyBidy5mMzIocGFyc2VGbG9hdChyYXcpKTsgfVxuICAgICAgICAgIGVsc2UgeyBidy5ieXRl
KE9QX0Y2NF9DT05TVCk7IGJ3LmY2NChwYXJzZUZsb2F0KHJhdykpOyB9XG4gICAgICAgICAgYnJl
YWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnSWRlbnQnOiB7XG4gICAgICAgICAgY29uc3Qg
bmFtZSA9IGV4cHIubmFtZTtcbiAgICAgICAgICBpZiAobG9jYWxNYXBbbmFtZV0pIHsgYncuYnl0
ZShPUF9MT0NBTF9HRVQpOyBidy51MzIobG9jYWxNYXBbbmFtZV0uaWR4KTsgfVxuICAgICAgICAg
IGVsc2UgaWYgKGdsb2JhbEluZGV4W25hbWVdICE9PSB1bmRlZmluZWQpIHsgYncuYnl0ZShPUF9H
TE9CQUxfR0VUKTsgYncudTMyKGdsb2JhbEluZGV4W25hbWVdKTsgfVxuICAgICAgICAgIGVsc2Ug
dGhyb3cgbmV3IEVycm9yKGBVbmRlZmluZWQgdmFyaWFibGU6ICR7bmFtZX1gKTtcbiAgICAgICAg
ICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdCaW5PcCc6IHtcbiAgICAgICAgICBj
b25zdCB0ID0gZXhwZWN0ZWRUeXBlIHx8IGluZmVyRXhwclR5cGUoZXhwcik7XG4gICAgICAgICAg
ZW1pdEJpbk9wKGV4cHIsIHQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAg
IGNhc2UgJ1VuYXJ5T3AnOiB7XG4gICAgICAgICAgY29uc3QgdCA9IGV4cGVjdGVkVHlwZSB8fCBp
bmZlckV4cHJUeXBlKGV4cHIpO1xuICAgICAgICAgIGlmIChleHByLm9wID09PSAnLScpIHtcbiAg
ICAgICAgICAgIGlmICh0ID09PSAnZjY0JykgeyBlbWl0RXhwcihleHByLm9wZXJhbmQsIHQpOyBi
dy5ieXRlKE9QX0Y2NF9ORUcpOyB9XG4gICAgICAgICAgICBlbHNlIGlmICh0ID09PSAnZjMyJykg
eyBlbWl0RXhwcihleHByLm9wZXJhbmQsIHQpOyBidy5ieXRlKE9QX0YzMl9ORUcpOyB9XG4gICAg
ICAgICAgICBlbHNlIGlmICh0ID09PSAnaTMyJykgeyBidy5ieXRlKE9QX0kzMl9DT05TVCk7IGJ3
LnMzMigwKTsgZW1pdEV4cHIoZXhwci5vcGVyYW5kLCB0KTsgYncuYnl0ZShPUF9JMzJfU1VCKTsg
fVxuICAgICAgICAgICAgZWxzZSBpZiAodCA9PT0gJ2k2NCcpIHsgYncuYnl0ZShPUF9JNjRfQ09O
U1QpOyBidy5zNjQoMG4pOyBlbWl0RXhwcihleHByLm9wZXJhbmQsIHQpOyBidy5ieXRlKE9QX0k2
NF9TVUIpOyB9XG4gICAgICAgICAgfSBlbHNlIGlmIChleHByLm9wID09PSAnbm90Jykge1xuICAg
ICAgICAgICAgZW1pdEV4cHIoZXhwci5vcGVyYW5kLCAnaTMyJyk7XG4gICAgICAgICAgICBidy5i
eXRlKE9QX0kzMl9FUVopO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZXhwci5vcCA9PT0gJ34nKSB7
XG4gICAgICAgICAgICBlbWl0RXhwcihleHByLm9wZXJhbmQsIHQpO1xuICAgICAgICAgICAgaWYg
KHQgPT09ICdpMzInKSB7IGJ3LmJ5dGUoT1BfSTMyX0NPTlNUKTsgYncuczMyKC0xKTsgYncuYnl0
ZShPUF9JMzJfWE9SKTsgfVxuICAgICAgICAgICAgZWxzZSBpZiAodCA9PT0gJ2k2NCcpIHsgYncu
Ynl0ZShPUF9JNjRfQ09OU1QpOyBidy5zNjQoLTFuKTsgYncuYnl0ZShPUF9JNjRfWE9SKTsgfVxu
ICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbWl0RXhwcihleHByLm9wZXJhbmQsIHQp
O1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNl
ICdGdW5jQ2FsbCc6IHtcbiAgICAgICAgICBlbWl0RnVuY0NhbGwoZXhwciwgZXhwZWN0ZWRUeXBl
KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdBcnJheUFjY2Vz
cyc6IHtcbiAgICAgICAgICBjb25zdCBpbmZvID0gbG9jYWxNYXBbZXhwci5uYW1lXTtcbiAgICAg
ICAgICBpZiAoIWluZm8pIHRocm93IG5ldyBFcnJvcihgVW5kZWZpbmVkIGFycmF5OiAke2V4cHIu
bmFtZX1gKTtcbiAgICAgICAgICBjb25zdCBlbGVtVHlwZSA9IGluZm8uZWxlbVR5cGUgfHwgaW5m
by52dHlwZTtcbiAgICAgICAgICBlbWl0QXJyYXlBZGRyKGV4cHIubmFtZSwgZXhwci5pbmRpY2Vz
LCBpbmZvLCBlbGVtVHlwZSk7XG4gICAgICAgICAgZW1pdExvYWQoZWxlbVR5cGUpO1xuICAgICAg
ICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ0lmRXhwcic6IHtcbiAgICAgICAg
ICBjb25zdCB0ID0gZXhwZWN0ZWRUeXBlIHx8IGluZmVyRXhwclR5cGUoZXhwci50aGVuRXhwcik7
XG4gICAgICAgICAgZW1pdEV4cHIoZXhwci5jb25kLCAnaTMyJyk7XG4gICAgICAgICAgYncuYnl0
ZShPUF9JRik7XG4gICAgICAgICAgYncuYnl0ZSh3YXNtVHlwZSh0KSk7XG4gICAgICAgICAgZW1p
dEV4cHIoZXhwci50aGVuRXhwciwgdCk7XG4gICAgICAgICAgYncuYnl0ZShPUF9FTFNFKTtcbiAg
ICAgICAgICBlbWl0RXhwcihleHByLmVsc2VFeHByLCB0KTtcbiAgICAgICAgICBidy5ieXRlKE9Q
X0VORCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAg
ICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gZXhwcmVzc2lvbiB0eXBlOiAke2V4cHIu
dHlwZX1gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlbWl0QmluT3AoZXhwciwg
dCkge1xuICAgICAgY29uc3Qgb3AgPSBleHByLm9wO1xuXG4gICAgICAvLyBFeHBvbmVudGlhdGlv
blxuICAgICAgaWYgKG9wID09PSAnKionKSB7XG4gICAgICAgIGVtaXRQb3coZXhwciwgdCk7XG4g
ICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gQ29tcGFyaXNvbiBvcGVyYXRvcnMg
cmV0dXJuIGkzMlxuICAgICAgaWYgKG9wID09PSAnPT0nIHx8IG9wID09PSAnLz0nIHx8IG9wID09
PSAnPCcgfHwgb3AgPT09ICc+JyB8fCBvcCA9PT0gJzw9JyB8fCBvcCA9PT0gJz49Jykge1xuICAg
ICAgICBjb25zdCBvcGVyYW5kVHlwZSA9IGluZmVyRXhwclR5cGUoZXhwci5sZWZ0KTtcbiAgICAg
ICAgZW1pdEV4cHIoZXhwci5sZWZ0LCBvcGVyYW5kVHlwZSk7XG4gICAgICAgIGVtaXRFeHByKGV4
cHIucmlnaHQsIG9wZXJhbmRUeXBlKTtcbiAgICAgICAgZW1pdENtcChvcCwgb3BlcmFuZFR5cGUp
O1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIExvZ2ljYWw6IGFuZCwgb3Jc
biAgICAgIGlmIChvcCA9PT0gJ2FuZCcpIHtcbiAgICAgICAgZW1pdEV4cHIoZXhwci5sZWZ0LCAn
aTMyJyk7XG4gICAgICAgIGVtaXRFeHByKGV4cHIucmlnaHQsICdpMzInKTtcbiAgICAgICAgYncu
Ynl0ZShPUF9JMzJfQU5EKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKG9w
ID09PSAnb3InKSB7XG4gICAgICAgIGVtaXRFeHByKGV4cHIubGVmdCwgJ2kzMicpO1xuICAgICAg
ICBlbWl0RXhwcihleHByLnJpZ2h0LCAnaTMyJyk7XG4gICAgICAgIGJ3LmJ5dGUoT1BfSTMyX09S
KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBlbWl0RXhwcihleHByLmxlZnQs
IHQpO1xuICAgICAgZW1pdEV4cHIoZXhwci5yaWdodCwgdCk7XG5cbiAgICAgIGlmIChvcCA9PT0g
JysnKSBlbWl0QWRkKHQpO1xuICAgICAgZWxzZSBpZiAob3AgPT09ICctJykgZW1pdFN1Yih0KTtc
biAgICAgIGVsc2UgaWYgKG9wID09PSAnKicpIGVtaXRNdWwodCk7XG4gICAgICBlbHNlIGlmIChv
cCA9PT0gJy8nKSBlbWl0RGl2KHQpO1xuICAgICAgZWxzZSBpZiAob3AgPT09ICdtb2QnKSB7XG4g
ICAgICAgIGlmICh0ID09PSAnaTMyJykgYncuYnl0ZShPUF9JMzJfUkVNX1MpO1xuICAgICAgICBl
bHNlIGlmICh0ID09PSAnaTY0JykgYncuYnl0ZShPUF9JNjRfUkVNX1MpO1xuICAgICAgICBlbHNl
IHRocm93IG5ldyBFcnJvcignbW9kIHJlcXVpcmVzIGludGVnZXIgdHlwZScpO1xuICAgICAgfVxu
ICAgICAgZWxzZSBpZiAob3AgPT09ICcmJykgeyBpZiAodCA9PT0gJ2kzMicpIGJ3LmJ5dGUoT1Bf
STMyX0FORCk7IGVsc2UgYncuYnl0ZShPUF9JNjRfQU5EKTsgfVxuICAgICAgZWxzZSBpZiAob3Ag
PT09ICd8JykgeyBpZiAodCA9PT0gJ2kzMicpIGJ3LmJ5dGUoT1BfSTMyX09SKTsgZWxzZSBidy5i
eXRlKE9QX0k2NF9PUik7IH1cbiAgICAgIGVsc2UgaWYgKG9wID09PSAnXicpIHsgaWYgKHQgPT09
ICdpMzInKSBidy5ieXRlKE9QX0kzMl9YT1IpOyBlbHNlIGJ3LmJ5dGUoT1BfSTY0X1hPUik7IH1c
biAgICAgIGVsc2UgaWYgKG9wID09PSAnPDwnKSB7IGlmICh0ID09PSAnaTMyJykgYncuYnl0ZShP
UF9JMzJfU0hMKTsgZWxzZSBidy5ieXRlKE9QX0k2NF9TSEwpOyB9XG4gICAgICBlbHNlIGlmIChv
cCA9PT0gJz4+JykgeyBpZiAodCA9PT0gJ2kzMicpIGJ3LmJ5dGUoT1BfSTMyX1NIUl9TKTsgZWxz
ZSBidy5ieXRlKE9QX0k2NF9TSFJfUyk7IH1cbiAgICAgIGVsc2UgdGhyb3cgbmV3IEVycm9yKGBV
bmtub3duIG9wZXJhdG9yOiAke29wfWApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVtaXRQb3co
ZXhwciwgdCkge1xuICAgICAgLy8gKiowLjUg4oaSIHNxcnRcbiAgICAgIGlmIChleHByLnJpZ2h0
LnR5cGUgPT09ICdOdW1iZXJMaXQnICYmIChleHByLnJpZ2h0LnZhbHVlID09PSAnMC41JyB8fCBl
eHByLnJpZ2h0LnZhbHVlID09PSAnLjUnKSkge1xuICAgICAgICBlbWl0RXhwcihleHByLmxlZnQs
IHQpO1xuICAgICAgICBpZiAodCA9PT0gJ2Y2NCcpIGJ3LmJ5dGUoT1BfRjY0X1NRUlQpO1xuICAg
ICAgICBlbHNlIGlmICh0ID09PSAnZjMyJykgYncuYnl0ZShPUF9GMzJfU1FSVCk7XG4gICAgICAg
IHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIEdlbmVyYWw6IGNhbGwgcG93IGltcG9ydCAod29y
a3MgZm9yIGFsbCBjYXNlcyBpbmNsdWRpbmcgKioyLCAqKjMpXG4gICAgICBlbWl0RXhwcihleHBy
LmxlZnQsICdmNjQnKTtcbiAgICAgIGVtaXRFeHByKGV4cHIucmlnaHQsICdmNjQnKTtcbiAgICAg
IGJ3LmJ5dGUoT1BfQ0FMTCk7XG4gICAgICBidy51MzIoZnVuY0luZGV4Wydwb3cnXSk7XG4gICAg
ICAvLyBDb252ZXJ0IHJlc3VsdCBiYWNrIGlmIG5lZWRlZFxuICAgICAgaWYgKHQgPT09ICdmMzIn
KSBidy5ieXRlKE9QX0YzMl9ERU1PVEVfRjY0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlbWl0
RnVuY0NhbGwoZXhwciwgZXhwZWN0ZWRUeXBlKSB7XG4gICAgICBjb25zdCBuYW1lID0gZXhwci5u
YW1lO1xuXG4gICAgICAvLyBUeXBlIGNvbnZlcnNpb25zOiBpMzIoeCksIGY2NCh4KSwgZXRjLlxu
ICAgICAgaWYgKEFUUkFfVFlQRVMuaGFzKG5hbWUpKSB7XG4gICAgICAgIGNvbnN0IGZyb21UeXBl
ID0gaW5mZXJFeHByVHlwZShleHByLmFyZ3NbMF0pO1xuICAgICAgICBjb25zdCB0b1R5cGUgPSBu
YW1lO1xuICAgICAgICBlbWl0RXhwcihleHByLmFyZ3NbMF0sIGZyb21UeXBlKTtcbiAgICAgICAg
ZW1pdENvbnZlcnNpb24oZnJvbVR5cGUsIHRvVHlwZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAg
IH1cblxuICAgICAgLy8gTmF0aXZlIGJ1aWx0aW5zXG4gICAgICBpZiAobmFtZSA9PT0gJ3NxcnQn
KSB7IGVtaXRFeHByKGV4cHIuYXJnc1swXSwgZXhwZWN0ZWRUeXBlKTsgaWYgKGV4cGVjdGVkVHlw
ZSA9PT0gJ2YzMicpIGJ3LmJ5dGUoT1BfRjMyX1NRUlQpOyBlbHNlIGJ3LmJ5dGUoT1BfRjY0X1NR
UlQpOyByZXR1cm47IH1cbiAgICAgIGlmIChuYW1lID09PSAnYWJzJykgeyBlbWl0RXhwcihleHBy
LmFyZ3NbMF0sIGV4cGVjdGVkVHlwZSk7IGlmIChleHBlY3RlZFR5cGUgPT09ICdmMzInKSBidy5i
eXRlKE9QX0YzMl9BQlMpOyBlbHNlIGJ3LmJ5dGUoT1BfRjY0X0FCUyk7IHJldHVybjsgfVxuICAg
ICAgaWYgKG5hbWUgPT09ICdmbG9vcicpIHsgZW1pdEV4cHIoZXhwci5hcmdzWzBdLCBleHBlY3Rl
ZFR5cGUpOyBpZiAoZXhwZWN0ZWRUeXBlID09PSAnZjMyJykgYncuYnl0ZShPUF9GMzJfRkxPT1Ip
OyBlbHNlIGJ3LmJ5dGUoT1BfRjY0X0ZMT09SKTsgcmV0dXJuOyB9XG4gICAgICBpZiAobmFtZSA9
PT0gJ2NlaWwnKSB7IGVtaXRFeHByKGV4cHIuYXJnc1swXSwgZXhwZWN0ZWRUeXBlKTsgaWYgKGV4
cGVjdGVkVHlwZSA9PT0gJ2YzMicpIGJ3LmJ5dGUoT1BfRjMyX0NFSUwpOyBlbHNlIGJ3LmJ5dGUo
T1BfRjY0X0NFSUwpOyByZXR1cm47IH1cbiAgICAgIGlmIChuYW1lID09PSAndHJ1bmMnKSB7IGVt
aXRFeHByKGV4cHIuYXJnc1swXSwgZXhwZWN0ZWRUeXBlKTsgaWYgKGV4cGVjdGVkVHlwZSA9PT0g
J2YzMicpIGJ3LmJ5dGUoT1BfRjMyX1RSVU5DKTsgZWxzZSBidy5ieXRlKE9QX0Y2NF9UUlVOQyk7
IHJldHVybjsgfVxuICAgICAgaWYgKG5hbWUgPT09ICduZWFyZXN0JykgeyBlbWl0RXhwcihleHBy
LmFyZ3NbMF0sIGV4cGVjdGVkVHlwZSk7IGlmIChleHBlY3RlZFR5cGUgPT09ICdmMzInKSBidy5i
eXRlKE9QX0YzMl9ORUFSRVNUKTsgZWxzZSBidy5ieXRlKE9QX0Y2NF9ORUFSRVNUKTsgcmV0dXJu
OyB9XG4gICAgICBpZiAobmFtZSA9PT0gJ21pbicpIHsgZW1pdEV4cHIoZXhwci5hcmdzWzBdLCBl
eHBlY3RlZFR5cGUpOyBlbWl0RXhwcihleHByLmFyZ3NbMV0sIGV4cGVjdGVkVHlwZSk7IGlmIChl
eHBlY3RlZFR5cGUgPT09ICdmMzInKSBidy5ieXRlKE9QX0YzMl9NSU4pOyBlbHNlIGJ3LmJ5dGUo
T1BfRjY0X01JTik7IHJldHVybjsgfVxuICAgICAgaWYgKG5hbWUgPT09ICdtYXgnKSB7IGVtaXRF
eHByKGV4cHIuYXJnc1swXSwgZXhwZWN0ZWRUeXBlKTsgZW1pdEV4cHIoZXhwci5hcmdzWzFdLCBl
eHBlY3RlZFR5cGUpOyBpZiAoZXhwZWN0ZWRUeXBlID09PSAnZjMyJykgYncuYnl0ZShPUF9GMzJf
TUFYKTsgZWxzZSBidy5ieXRlKE9QX0Y2NF9NQVgpOyByZXR1cm47IH1cbiAgICAgIGlmIChuYW1l
ID09PSAnY29weXNpZ24nKSB7IGVtaXRFeHByKGV4cHIuYXJnc1swXSwgZXhwZWN0ZWRUeXBlKTsg
ZW1pdEV4cHIoZXhwci5hcmdzWzFdLCBleHBlY3RlZFR5cGUpOyBpZiAoZXhwZWN0ZWRUeXBlID09
PSAnZjMyJykgYncuYnl0ZShPUF9GMzJfQ09QWVNJR04pOyBlbHNlIGJ3LmJ5dGUoT1BfRjY0X0NP
UFlTSUdOKTsgcmV0dXJuOyB9XG4gICAgICBpZiAobmFtZSA9PT0gJ3NlbGVjdCcpIHtcbiAgICAg
ICAgLy8gc2VsZWN0KGEsIGIsIGNvbmQpIOKAlCBXYXNtIHNlbGVjdCBwaWNrcyBhIGlmIGNvbmQh
PTAsIGIgb3RoZXJ3aXNlXG4gICAgICAgIGNvbnN0IHQgPSBleHBlY3RlZFR5cGUgfHwgaW5mZXJF
eHByVHlwZShleHByLmFyZ3NbMF0pO1xuICAgICAgICBlbWl0RXhwcihleHByLmFyZ3NbMF0sIHQp
O1xuICAgICAgICBlbWl0RXhwcihleHByLmFyZ3NbMV0sIHQpO1xuICAgICAgICBlbWl0RXhwcihl
eHByLmFyZ3NbMl0sICdpMzInKTtcbiAgICAgICAgYncuYnl0ZShPUF9TRUxFQ1QpO1xuICAgICAg
ICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAobmFtZSA9PT0gJ2NseicpIHsgZW1pdEV4cHIo
ZXhwci5hcmdzWzBdLCBleHBlY3RlZFR5cGUpOyBpZiAoZXhwZWN0ZWRUeXBlID09PSAnaTY0Jykg
YncuYnl0ZShPUF9JNjRfQ0xaKTsgZWxzZSBidy5ieXRlKE9QX0kzMl9DTFopOyByZXR1cm47IH1c
biAgICAgIGlmIChuYW1lID09PSAnY3R6JykgeyBlbWl0RXhwcihleHByLmFyZ3NbMF0sIGV4cGVj
dGVkVHlwZSk7IGlmIChleHBlY3RlZFR5cGUgPT09ICdpNjQnKSBidy5ieXRlKE9QX0k2NF9DVFop
OyBlbHNlIGJ3LmJ5dGUoT1BfSTMyX0NUWik7IHJldHVybjsgfVxuICAgICAgaWYgKG5hbWUgPT09
ICdwb3BjbnQnKSB7IGVtaXRFeHByKGV4cHIuYXJnc1swXSwgZXhwZWN0ZWRUeXBlKTsgaWYgKGV4
cGVjdGVkVHlwZSA9PT0gJ2k2NCcpIGJ3LmJ5dGUoT1BfSTY0X1BPUENOVCk7IGVsc2UgYncuYnl0
ZShPUF9JMzJfUE9QQ05UKTsgcmV0dXJuOyB9XG4gICAgICBpZiAobmFtZSA9PT0gJ3JvdGwnKSB7
IGVtaXRFeHByKGV4cHIuYXJnc1swXSwgZXhwZWN0ZWRUeXBlKTsgZW1pdEV4cHIoZXhwci5hcmdz
WzFdLCBleHBlY3RlZFR5cGUpOyBpZiAoZXhwZWN0ZWRUeXBlID09PSAnaTY0JykgYncuYnl0ZShP
UF9JNjRfUk9UTCk7IGVsc2UgYncuYnl0ZShPUF9JMzJfUk9UTCk7IHJldHVybjsgfVxuICAgICAg
aWYgKG5hbWUgPT09ICdyb3RyJykgeyBlbWl0RXhwcihleHByLmFyZ3NbMF0sIGV4cGVjdGVkVHlw
ZSk7IGVtaXRFeHByKGV4cHIuYXJnc1sxXSwgZXhwZWN0ZWRUeXBlKTsgaWYgKGV4cGVjdGVkVHlw
ZSA9PT0gJ2k2NCcpIGJ3LmJ5dGUoT1BfSTY0X1JPVFIpOyBlbHNlIGJ3LmJ5dGUoT1BfSTMyX1JP
VFIpOyByZXR1cm47IH1cbiAgICAgIGlmIChuYW1lID09PSAnbWVtb3J5X3NpemUnKSB7IGJ3LmJ5
dGUoT1BfTUVNT1JZX1NJWkUpOyBidy51MzIoMCk7IHJldHVybjsgfVxuICAgICAgaWYgKG5hbWUg
PT09ICdtZW1vcnlfZ3JvdycpIHsgZW1pdEV4cHIoZXhwci5hcmdzWzBdLCAnaTMyJyk7IGJ3LmJ5
dGUoT1BfTUVNT1JZX0dST1cpOyBidy51MzIoMCk7IHJldHVybjsgfVxuXG4gICAgICAvLyB3YXNt
LiogZXNjYXBlIGhhdGNoXG4gICAgICBpZiAobmFtZS5zdGFydHNXaXRoKCd3YXNtLicpKSB7XG4g
ICAgICAgIGVtaXRXYXNtQnVpbHRpbihuYW1lLnNsaWNlKDUpLCBleHByLCBleHBlY3RlZFR5cGUp
O1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFJlZ3VsYXIgZnVuY3Rpb24g
Y2FsbFxuICAgICAgY29uc3QgZklkeCA9IGZ1bmNJbmRleFtuYW1lXTtcbiAgICAgIGlmIChmSWR4
ID09PSB1bmRlZmluZWQpIHRocm93IG5ldyBFcnJvcihgVW5kZWZpbmVkIGZ1bmN0aW9uOiAke25h
bWV9YCk7XG4gICAgICBmb3IgKGxldCBhaSA9IDA7IGFpIDwgZXhwci5hcmdzLmxlbmd0aDsgYWkr
Kykge1xuICAgICAgICBjb25zdCBwYXJhbVR5cGUgPSBnZXRQYXJhbVR5cGUobmFtZSwgYWkpO1xu
ICAgICAgICBlbWl0RXhwcihleHByLmFyZ3NbYWldLCBwYXJhbVR5cGUpO1xuICAgICAgfVxuICAg
ICAgYncuYnl0ZShPUF9DQUxMKTtcbiAgICAgIGJ3LnUzMihmSWR4KTtcbiAgICB9XG5cbiAgICBm
dW5jdGlvbiBlbWl0V2FzbUJ1aWx0aW4ob3AsIGV4cHIsIGV4cGVjdGVkVHlwZSkge1xuICAgICAg
Y29uc3QgdCA9IGV4cGVjdGVkVHlwZSB8fCAnaTMyJztcbiAgICAgIGlmIChvcCA9PT0gJ2Rpdl91
JykgeyBlbWl0RXhwcihleHByLmFyZ3NbMF0sIHQpOyBlbWl0RXhwcihleHByLmFyZ3NbMV0sIHQp
OyBidy5ieXRlKHQgPT09ICdpNjQnID8gT1BfSTY0X0RJVl9VIDogT1BfSTMyX0RJVl9VKTsgcmV0
dXJuOyB9XG4gICAgICBpZiAob3AgPT09ICdyZW1fdScpIHsgZW1pdEV4cHIoZXhwci5hcmdzWzBd
LCB0KTsgZW1pdEV4cHIoZXhwci5hcmdzWzFdLCB0KTsgYncuYnl0ZSh0ID09PSAnaTY0JyA/IE9Q
X0k2NF9SRU1fVSA6IE9QX0kzMl9SRU1fVSk7IHJldHVybjsgfVxuICAgICAgaWYgKG9wID09PSAn
c2hyX3UnKSB7IGVtaXRFeHByKGV4cHIuYXJnc1swXSwgdCk7IGVtaXRFeHByKGV4cHIuYXJnc1sx
XSwgdCk7IGJ3LmJ5dGUodCA9PT0gJ2k2NCcgPyBPUF9JNjRfU0hSX1UgOiBPUF9JMzJfU0hSX1Up
OyByZXR1cm47IH1cbiAgICAgIGlmIChvcCA9PT0gJ2x0X3UnKSB7IGVtaXRFeHByKGV4cHIuYXJn
c1swXSwgdCk7IGVtaXRFeHByKGV4cHIuYXJnc1sxXSwgdCk7IGJ3LmJ5dGUodCA9PT0gJ2k2NCcg
PyBPUF9JNjRfTFRfVSA6IE9QX0kzMl9MVF9VKTsgcmV0dXJuOyB9XG4gICAgICBpZiAob3AgPT09
ICdndF91JykgeyBlbWl0RXhwcihleHByLmFyZ3NbMF0sIHQpOyBlbWl0RXhwcihleHByLmFyZ3Nb
MV0sIHQpOyBidy5ieXRlKHQgPT09ICdpNjQnID8gT1BfSTY0X0dUX1UgOiBPUF9JMzJfR1RfVSk7
IHJldHVybjsgfVxuICAgICAgaWYgKG9wID09PSAnbGVfdScpIHsgZW1pdEV4cHIoZXhwci5hcmdz
WzBdLCB0KTsgZW1pdEV4cHIoZXhwci5hcmdzWzFdLCB0KTsgYncuYnl0ZSh0ID09PSAnaTY0JyA/
IE9QX0k2NF9MRV9VIDogT1BfSTMyX0xFX1UpOyByZXR1cm47IH1cbiAgICAgIGlmIChvcCA9PT0g
J2dlX3UnKSB7IGVtaXRFeHByKGV4cHIuYXJnc1swXSwgdCk7IGVtaXRFeHByKGV4cHIuYXJnc1sx
XSwgdCk7IGJ3LmJ5dGUodCA9PT0gJ2k2NCcgPyBPUF9JNjRfR0VfVSA6IE9QX0kzMl9HRV9VKTsg
cmV0dXJuOyB9XG4gICAgICBpZiAob3AgPT09ICdyZWludGVycHJldF9mNjQnKSB7IGVtaXRFeHBy
KGV4cHIuYXJnc1swXSwgJ2Y2NCcpOyBidy5ieXRlKE9QX0k2NF9SRUlOVEVSUFJFVF9GNjQpOyBy
ZXR1cm47IH1cbiAgICAgIGlmIChvcCA9PT0gJ3JlaW50ZXJwcmV0X2YzMicpIHsgZW1pdEV4cHIo
ZXhwci5hcmdzWzBdLCAnZjMyJyk7IGJ3LmJ5dGUoT1BfSTMyX1JFSU5URVJQUkVUX0YzMik7IHJl
dHVybjsgfVxuICAgICAgaWYgKG9wID09PSAncmVpbnRlcnByZXRfaTY0JykgeyBlbWl0RXhwcihl
eHByLmFyZ3NbMF0sICdpNjQnKTsgYncuYnl0ZShPUF9GNjRfUkVJTlRFUlBSRVRfSTY0KTsgcmV0
dXJuOyB9XG4gICAgICBpZiAob3AgPT09ICdyZWludGVycHJldF9pMzInKSB7IGVtaXRFeHByKGV4
cHIuYXJnc1swXSwgJ2kzMicpOyBidy5ieXRlKE9QX0YzMl9SRUlOVEVSUFJFVF9JMzIpOyByZXR1
cm47IH1cbiAgICAgIGlmIChvcCA9PT0gJ2V4dGVuZDhfcycpIHsgZW1pdEV4cHIoZXhwci5hcmdz
WzBdLCB0KTsgYncuYnl0ZSh0ID09PSAnaTY0JyA/IE9QX0k2NF9FWFRFTkQ4X1MgOiBPUF9JMzJf
RVhURU5EOF9TKTsgcmV0dXJuOyB9XG4gICAgICBpZiAob3AgPT09ICdleHRlbmQxNl9zJykgeyBl
bWl0RXhwcihleHByLmFyZ3NbMF0sIHQpOyBidy5ieXRlKHQgPT09ICdpNjQnID8gT1BfSTY0X0VY
VEVORDE2X1MgOiBPUF9JMzJfRVhURU5EMTZfUyk7IHJldHVybjsgfVxuICAgICAgaWYgKG9wID09
PSAndHJ1bmNfc2F0X3MnKSB7XG4gICAgICAgIGNvbnN0IGZyb21UeXBlID0gaW5mZXJFeHByVHlw
ZShleHByLmFyZ3NbMF0pO1xuICAgICAgICBlbWl0RXhwcihleHByLmFyZ3NbMF0sIGZyb21UeXBl
KTtcbiAgICAgICAgYncuYnl0ZShPUF9GQ19QUkVGSVgpO1xuICAgICAgICBpZiAodCA9PT0gJ2kz
MicgJiYgZnJvbVR5cGUgPT09ICdmMzInKSBidy51MzIoT1BfSTMyX1RSVU5DX1NBVF9GMzJfUyk7
XG4gICAgICAgIGVsc2UgaWYgKHQgPT09ICdpMzInICYmIGZyb21UeXBlID09PSAnZjY0JykgYncu
dTMyKE9QX0kzMl9UUlVOQ19TQVRfRjY0X1MpO1xuICAgICAgICBlbHNlIGlmICh0ID09PSAnaTY0
JyAmJiBmcm9tVHlwZSA9PT0gJ2YzMicpIGJ3LnUzMihPUF9JNjRfVFJVTkNfU0FUX0YzMl9TKTtc
biAgICAgICAgZWxzZSBpZiAodCA9PT0gJ2k2NCcgJiYgZnJvbVR5cGUgPT09ICdmNjQnKSBidy51
MzIoT1BfSTY0X1RSVU5DX1NBVF9GNjRfUyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAg
ICAgIGlmIChvcCA9PT0gJ3RydW5jX3NhdF91Jykge1xuICAgICAgICBjb25zdCBmcm9tVHlwZSA9
IGluZmVyRXhwclR5cGUoZXhwci5hcmdzWzBdKTtcbiAgICAgICAgZW1pdEV4cHIoZXhwci5hcmdz
WzBdLCBmcm9tVHlwZSk7XG4gICAgICAgIGJ3LmJ5dGUoT1BfRkNfUFJFRklYKTtcbiAgICAgICAg
aWYgKHQgPT09ICdpMzInICYmIGZyb21UeXBlID09PSAnZjMyJykgYncudTMyKE9QX0kzMl9UUlVO
Q19TQVRfRjMyX1UpO1xuICAgICAgICBlbHNlIGlmICh0ID09PSAnaTMyJyAmJiBmcm9tVHlwZSA9
PT0gJ2Y2NCcpIGJ3LnUzMihPUF9JMzJfVFJVTkNfU0FUX0Y2NF9VKTtcbiAgICAgICAgZWxzZSBp
ZiAodCA9PT0gJ2k2NCcgJiYgZnJvbVR5cGUgPT09ICdmMzInKSBidy51MzIoT1BfSTY0X1RSVU5D
X1NBVF9GMzJfVSk7XG4gICAgICAgIGVsc2UgaWYgKHQgPT09ICdpNjQnICYmIGZyb21UeXBlID09
PSAnZjY0JykgYncudTMyKE9QX0k2NF9UUlVOQ19TQVRfRjY0X1UpO1xuICAgICAgICByZXR1cm47
XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gd2FzbSBidWlsdGluOiB3
YXNtLiR7b3B9YCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZW1pdENvbnZlcnNpb24oZnJvbSwg
dG8pIHtcbiAgICAgIGlmIChmcm9tID09PSB0bykgcmV0dXJuO1xuICAgICAgaWYgKGZyb20gPT09
ICdpMzInICYmIHRvID09PSAnZjY0JykgYncuYnl0ZShPUF9GNjRfQ09OVkVSVF9JMzJfUyk7XG4g
ICAgICBlbHNlIGlmIChmcm9tID09PSAnaTMyJyAmJiB0byA9PT0gJ2YzMicpIGJ3LmJ5dGUoT1Bf
RjMyX0NPTlZFUlRfSTMyX1MpO1xuICAgICAgZWxzZSBpZiAoZnJvbSA9PT0gJ2kzMicgJiYgdG8g
PT09ICdpNjQnKSBidy5ieXRlKE9QX0k2NF9FWFRFTkRfSTMyX1MpO1xuICAgICAgZWxzZSBpZiAo
ZnJvbSA9PT0gJ2k2NCcgJiYgdG8gPT09ICdpMzInKSBidy5ieXRlKE9QX0kzMl9XUkFQX0k2NCk7
XG4gICAgICBlbHNlIGlmIChmcm9tID09PSAnaTY0JyAmJiB0byA9PT0gJ2Y2NCcpIGJ3LmJ5dGUo
T1BfRjY0X0NPTlZFUlRfSTY0X1MpO1xuICAgICAgZWxzZSBpZiAoZnJvbSA9PT0gJ2k2NCcgJiYg
dG8gPT09ICdmMzInKSBidy5ieXRlKE9QX0YzMl9DT05WRVJUX0k2NF9TKTtcbiAgICAgIGVsc2Ug
aWYgKGZyb20gPT09ICdmNjQnICYmIHRvID09PSAnaTMyJykgYncuYnl0ZShPUF9JMzJfVFJVTkNf
RjY0X1MpO1xuICAgICAgZWxzZSBpZiAoZnJvbSA9PT0gJ2Y2NCcgJiYgdG8gPT09ICdpNjQnKSBi
dy5ieXRlKE9QX0k2NF9UUlVOQ19GNjRfUyk7XG4gICAgICBlbHNlIGlmIChmcm9tID09PSAnZjY0
JyAmJiB0byA9PT0gJ2YzMicpIGJ3LmJ5dGUoT1BfRjMyX0RFTU9URV9GNjQpO1xuICAgICAgZWxz
ZSBpZiAoZnJvbSA9PT0gJ2YzMicgJiYgdG8gPT09ICdmNjQnKSBidy5ieXRlKE9QX0Y2NF9QUk9N
T1RFX0YzMik7XG4gICAgICBlbHNlIGlmIChmcm9tID09PSAnZjMyJyAmJiB0byA9PT0gJ2kzMicp
IGJ3LmJ5dGUoT1BfSTMyX1RSVU5DX0YzMl9TKTtcbiAgICAgIGVsc2UgaWYgKGZyb20gPT09ICdm
MzInICYmIHRvID09PSAnaTY0JykgYncuYnl0ZShPUF9JNjRfVFJVTkNfRjMyX1MpO1xuICAgICAg
ZWxzZSB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBjb252ZXJ0ICR7ZnJvbX0gdG8gJHt0b31gKTtc
biAgICB9XG5cbiAgICBmdW5jdGlvbiBlbWl0QXJyYXlBZGRyKG5hbWUsIGluZGljZXMsIGluZm8s
IGVsZW1UeXBlKSB7XG4gICAgICAvLyBCYXNlIHBvaW50ZXJcbiAgICAgIGJ3LmJ5dGUoT1BfTE9D
QUxfR0VUKTtcbiAgICAgIGJ3LnUzMihpbmZvLmlkeCk7XG5cbiAgICAgIGNvbnN0IHN6ID0gdHlw
ZVNpemUoZWxlbVR5cGUpO1xuXG4gICAgICBpZiAoaW5kaWNlcy5sZW5ndGggPT09IDEpIHtcbiAg
ICAgICAgLy8gMUQ6IGJhc2UgKyBpICogc2l6ZW9mXG4gICAgICAgIGVtaXRFeHByKGluZGljZXNb
MF0sICdpMzInKTtcbiAgICAgICAgYncuYnl0ZShPUF9JMzJfQ09OU1QpOyBidy5zMzIoc3opO1xu
ICAgICAgICBidy5ieXRlKE9QX0kzMl9NVUwpO1xuICAgICAgICBidy5ieXRlKE9QX0kzMl9BREQp
O1xuICAgICAgfSBlbHNlIGlmIChpbmRpY2VzLmxlbmd0aCA9PT0gMyAmJiAhaW5mby5hcnJheURp
bXMpIHtcbiAgICAgICAgLy8gMkQgd2l0aCBleHBsaWNpdCBzdHJpZGU6IGFbaSwgc3RyaWRlLCBq
XSDihpIgYmFzZSArIChpKnN0cmlkZSArIGopICogc2l6ZW9mXG4gICAgICAgIGVtaXRFeHByKGlu
ZGljZXNbMF0sICdpMzInKTtcbiAgICAgICAgZW1pdEV4cHIoaW5kaWNlc1sxXSwgJ2kzMicpO1xu
ICAgICAgICBidy5ieXRlKE9QX0kzMl9NVUwpO1xuICAgICAgICBlbWl0RXhwcihpbmRpY2VzWzJd
LCAnaTMyJyk7XG4gICAgICAgIGJ3LmJ5dGUoT1BfSTMyX0FERCk7XG4gICAgICAgIGJ3LmJ5dGUo
T1BfSTMyX0NPTlNUKTsgYncuczMyKHN6KTtcbiAgICAgICAgYncuYnl0ZShPUF9JMzJfTVVMKTtc
biAgICAgICAgYncuYnl0ZShPUF9JMzJfQUREKTtcbiAgICAgIH0gZWxzZSBpZiAoaW5kaWNlcy5s
ZW5ndGggPT09IDIgJiYgaW5mby5hcnJheURpbXMgJiYgaW5mby5hcnJheURpbXMubGVuZ3RoID09
PSAyKSB7XG4gICAgICAgIC8vIDJEIHdpdGggZGVjbGFyZWQgZGltczogYVtpLCBqXSDihpIgYmFz
ZSArIChpKmRpbTEgKyBqKSAqIHNpemVvZlxuICAgICAgICBlbWl0RXhwcihpbmRpY2VzWzBdLCAn
aTMyJyk7XG4gICAgICAgIGVtaXRFeHByKGluZm8uYXJyYXlEaW1zWzFdLCAnaTMyJyk7XG4gICAg
ICAgIGJ3LmJ5dGUoT1BfSTMyX01VTCk7XG4gICAgICAgIGVtaXRFeHByKGluZGljZXNbMV0sICdp
MzInKTtcbiAgICAgICAgYncuYnl0ZShPUF9JMzJfQUREKTtcbiAgICAgICAgYncuYnl0ZShPUF9J
MzJfQ09OU1QpOyBidy5zMzIoc3opO1xuICAgICAgICBidy5ieXRlKE9QX0kzMl9NVUwpO1xuICAg
ICAgICBidy5ieXRlKE9QX0kzMl9BREQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cg
bmV3IEVycm9yKGBVbnN1cHBvcnRlZCBhcnJheSBpbmRleCBwYXR0ZXJuIGZvciAke25hbWV9YCk7
XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZW1pdExvYWQodCkge1xuICAgICAgaWYg
KHQgPT09ICdpMzInKSB7IGJ3LmJ5dGUoT1BfSTMyX0xPQUQpOyBidy51MzIoMik7IGJ3LnUzMigw
KTsgfSAvLyBhbGlnbj00XG4gICAgICBlbHNlIGlmICh0ID09PSAnaTY0JykgeyBidy5ieXRlKE9Q
X0k2NF9MT0FEKTsgYncudTMyKDMpOyBidy51MzIoMCk7IH1cbiAgICAgIGVsc2UgaWYgKHQgPT09
ICdmMzInKSB7IGJ3LmJ5dGUoT1BfRjMyX0xPQUQpOyBidy51MzIoMik7IGJ3LnUzMigwKTsgfVxu
ICAgICAgZWxzZSBpZiAodCA9PT0gJ2Y2NCcpIHsgYncuYnl0ZShPUF9GNjRfTE9BRCk7IGJ3LnUz
MigzKTsgYncudTMyKDApOyB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZW1pdFN0b3JlKHQpIHtc
biAgICAgIGlmICh0ID09PSAnaTMyJykgeyBidy5ieXRlKE9QX0kzMl9TVE9SRSk7IGJ3LnUzMigy
KTsgYncudTMyKDApOyB9XG4gICAgICBlbHNlIGlmICh0ID09PSAnaTY0JykgeyBidy5ieXRlKE9Q
X0k2NF9TVE9SRSk7IGJ3LnUzMigzKTsgYncudTMyKDApOyB9XG4gICAgICBlbHNlIGlmICh0ID09
PSAnZjMyJykgeyBidy5ieXRlKE9QX0YzMl9TVE9SRSk7IGJ3LnUzMigyKTsgYncudTMyKDApOyB9
XG4gICAgICBlbHNlIGlmICh0ID09PSAnZjY0JykgeyBidy5ieXRlKE9QX0Y2NF9TVE9SRSk7IGJ3
LnUzMigzKTsgYncudTMyKDApOyB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZW1pdENtcChvcCwg
dCkge1xuICAgICAgaWYgKHQgPT09ICdmNjQnKSB7XG4gICAgICAgIGlmIChvcCA9PT0gJz09Jykg
YncuYnl0ZShPUF9GNjRfRVEpO1xuICAgICAgICBlbHNlIGlmIChvcCA9PT0gJy89JykgYncuYnl0
ZShPUF9GNjRfTkUpO1xuICAgICAgICBlbHNlIGlmIChvcCA9PT0gJzwnKSBidy5ieXRlKE9QX0Y2
NF9MVCk7XG4gICAgICAgIGVsc2UgaWYgKG9wID09PSAnPicpIGJ3LmJ5dGUoT1BfRjY0X0dUKTtc
biAgICAgICAgZWxzZSBpZiAob3AgPT09ICc8PScpIGJ3LmJ5dGUoT1BfRjY0X0xFKTtcbiAgICAg
ICAgZWxzZSBpZiAob3AgPT09ICc+PScpIGJ3LmJ5dGUoT1BfRjY0X0dFKTtcbiAgICAgIH0gZWxz
ZSBpZiAodCA9PT0gJ2YzMicpIHtcbiAgICAgICAgaWYgKG9wID09PSAnPT0nKSBidy5ieXRlKE9Q
X0YzMl9FUSk7XG4gICAgICAgIGVsc2UgaWYgKG9wID09PSAnLz0nKSBidy5ieXRlKE9QX0YzMl9O
RSk7XG4gICAgICAgIGVsc2UgaWYgKG9wID09PSAnPCcpIGJ3LmJ5dGUoT1BfRjMyX0xUKTtcbiAg
ICAgICAgZWxzZSBpZiAob3AgPT09ICc+JykgYncuYnl0ZShPUF9GMzJfR1QpO1xuICAgICAgICBl
bHNlIGlmIChvcCA9PT0gJzw9JykgYncuYnl0ZShPUF9GMzJfTEUpO1xuICAgICAgICBlbHNlIGlm
IChvcCA9PT0gJz49JykgYncuYnl0ZShPUF9GMzJfR0UpO1xuICAgICAgfSBlbHNlIGlmICh0ID09
PSAnaTMyJykge1xuICAgICAgICBpZiAob3AgPT09ICc9PScpIGJ3LmJ5dGUoT1BfSTMyX0VRKTtc
biAgICAgICAgZWxzZSBpZiAob3AgPT09ICcvPScpIGJ3LmJ5dGUoT1BfSTMyX05FKTtcbiAgICAg
ICAgZWxzZSBpZiAob3AgPT09ICc8JykgYncuYnl0ZShPUF9JMzJfTFRfUyk7XG4gICAgICAgIGVs
c2UgaWYgKG9wID09PSAnPicpIGJ3LmJ5dGUoT1BfSTMyX0dUX1MpO1xuICAgICAgICBlbHNlIGlm
IChvcCA9PT0gJzw9JykgYncuYnl0ZShPUF9JMzJfTEVfUyk7XG4gICAgICAgIGVsc2UgaWYgKG9w
ID09PSAnPj0nKSBidy5ieXRlKE9QX0kzMl9HRV9TKTtcbiAgICAgIH0gZWxzZSBpZiAodCA9PT0g
J2k2NCcpIHtcbiAgICAgICAgaWYgKG9wID09PSAnPT0nKSBidy5ieXRlKE9QX0k2NF9FUSk7XG4g
ICAgICAgIGVsc2UgaWYgKG9wID09PSAnLz0nKSBidy5ieXRlKE9QX0k2NF9ORSk7XG4gICAgICAg
IGVsc2UgaWYgKG9wID09PSAnPCcpIGJ3LmJ5dGUoT1BfSTY0X0xUX1MpO1xuICAgICAgICBlbHNl
IGlmIChvcCA9PT0gJz4nKSBidy5ieXRlKE9QX0k2NF9HVF9TKTtcbiAgICAgICAgZWxzZSBpZiAo
b3AgPT09ICc8PScpIGJ3LmJ5dGUoT1BfSTY0X0xFX1MpO1xuICAgICAgICBlbHNlIGlmIChvcCA9
PT0gJz49JykgYncuYnl0ZShPUF9JNjRfR0VfUyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVu
Y3Rpb24gZW1pdEFkZCh0KSB7XG4gICAgICBpZiAodCA9PT0gJ2Y2NCcpIGJ3LmJ5dGUoT1BfRjY0
X0FERCk7XG4gICAgICBlbHNlIGlmICh0ID09PSAnZjMyJykgYncuYnl0ZShPUF9GMzJfQUREKTtc
biAgICAgIGVsc2UgaWYgKHQgPT09ICdpMzInKSBidy5ieXRlKE9QX0kzMl9BREQpO1xuICAgICAg
ZWxzZSBpZiAodCA9PT0gJ2k2NCcpIGJ3LmJ5dGUoT1BfSTY0X0FERCk7XG4gICAgfVxuXG4gICAg
ZnVuY3Rpb24gZW1pdFN1Yih0KSB7XG4gICAgICBpZiAodCA9PT0gJ2Y2NCcpIGJ3LmJ5dGUoT1Bf
RjY0X1NVQik7XG4gICAgICBlbHNlIGlmICh0ID09PSAnZjMyJykgYncuYnl0ZShPUF9GMzJfU1VC
KTtcbiAgICAgIGVsc2UgaWYgKHQgPT09ICdpMzInKSBidy5ieXRlKE9QX0kzMl9TVUIpO1xuICAg
ICAgZWxzZSBpZiAodCA9PT0gJ2k2NCcpIGJ3LmJ5dGUoT1BfSTY0X1NVQik7XG4gICAgfVxuXG4g
ICAgZnVuY3Rpb24gZW1pdE11bCh0KSB7XG4gICAgICBpZiAodCA9PT0gJ2Y2NCcpIGJ3LmJ5dGUo
T1BfRjY0X01VTCk7XG4gICAgICBlbHNlIGlmICh0ID09PSAnZjMyJykgYncuYnl0ZShPUF9GMzJf
TVVMKTtcbiAgICAgIGVsc2UgaWYgKHQgPT09ICdpMzInKSBidy5ieXRlKE9QX0kzMl9NVUwpO1xu
ICAgICAgZWxzZSBpZiAodCA9PT0gJ2k2NCcpIGJ3LmJ5dGUoT1BfSTY0X01VTCk7XG4gICAgfVxu
XG4gICAgZnVuY3Rpb24gZW1pdERpdih0KSB7XG4gICAgICBpZiAodCA9PT0gJ2Y2NCcpIGJ3LmJ5
dGUoT1BfRjY0X0RJVik7XG4gICAgICBlbHNlIGlmICh0ID09PSAnZjMyJykgYncuYnl0ZShPUF9G
MzJfRElWKTtcbiAgICAgIGVsc2UgaWYgKHQgPT09ICdpMzInKSBidy5ieXRlKE9QX0kzMl9ESVZf
Uyk7XG4gICAgICBlbHNlIGlmICh0ID09PSAnaTY0JykgYncuYnl0ZShPUF9JNjRfRElWX1MpO1xu
ICAgIH1cblxuICAgIC8vIOKUgOKUgCBFbWl0IGZ1bmN0aW9uIGJvZHkgc3RhdGVtZW50cyDilIDi
lIBcbiAgICBlbWl0U3RtdHMoZm4uYm9keSk7XG5cbiAgICAvLyDilIDilIAgRW5kIG9mIGZ1bmN0
aW9uIGJvZHk6IHJldHVybiB2YWx1ZSDilIDilIBcbiAgICBpZiAoaXNGdW5jKSB7XG4gICAgICBi
dy5ieXRlKE9QX0xPQ0FMX0dFVCk7XG4gICAgICBidy51MzIobG9jYWxNYXBbJyRfcmV0dXJuJ10u
aWR4KTtcbiAgICB9XG4gICAgYncuYnl0ZShPUF9FTkQpO1xuICB9XG59XG5cbi8vIOKVkOKVkOKV
kOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKV
kOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKV
kOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKV
kOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkFxuLy8gNS4gVEFH
R0VEIFRFTVBMQVRFIEdMVUUgKyBTRUxGLVJFR0lTVFJBVElPTlxuLy8g4pWQ4pWQ4pWQ4pWQ4pWQ
4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ
4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ
4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ
4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQXG5cbmZ1bmN0aW9uIGNvbXBp
bGVTb3VyY2Uoc291cmNlLCBpbnRlcnBWYWx1ZXMsIHVzZXJJbXBvcnRzKSB7XG4gIGNvbnN0IHRv
a2VucyA9IGxleChzb3VyY2UpO1xuICBjb25zdCBhc3QgPSBwYXJzZSh0b2tlbnMpO1xuICByZXR1
cm4gY29kZWdlbihhc3QsIGludGVycFZhbHVlcywgdXNlckltcG9ydHMpO1xufVxuXG5mdW5jdGlv
biBpbnN0YW50aWF0ZShieXRlcywgdXNlckltcG9ydHMsIGludGVycFZhbHVlcykge1xuICBjb25z
dCBpbXBvcnRPYmogPSB7IG1hdGg6IHt9IH07XG5cbiAgLy8gTWF0aCBidWlsdGluc1xuICBpbXBv
cnRPYmoubWF0aC5zaW4gPSBNYXRoLnNpbjtcbiAgaW1wb3J0T2JqLm1hdGguY29zID0gTWF0aC5j
b3M7XG4gIGltcG9ydE9iai5tYXRoLmxuID0gTWF0aC5sb2c7XG4gIGltcG9ydE9iai5tYXRoLmV4
cCA9IE1hdGguZXhwO1xuICBpbXBvcnRPYmoubWF0aC5wb3cgPSBNYXRoLnBvdztcbiAgaW1wb3J0
T2JqLm1hdGguYXRhbjIgPSBNYXRoLmF0YW4yO1xuXG4gIC8vIEhvc3QgaW1wb3J0cyAoZnJvbSB1
c2VySW1wb3J0cyBvciBnbG9iYWxUaGlzKVxuICBpbXBvcnRPYmouaG9zdCA9IHt9O1xuICBpZiAo
dXNlckltcG9ydHMpIHtcbiAgICBmb3IgKGNvbnN0IFtrLCB2XSBvZiBPYmplY3QuZW50cmllcyh1
c2VySW1wb3J0cykpIHtcbiAgICAgIGlmIChrID09PSAnX19tZW1vcnknIHx8IGsgPT09ICdtZW1v
cnknKSBjb250aW51ZTtcbiAgICAgIGlmICh0eXBlb2YgdiA9PT0gJ2Z1bmN0aW9uJykgaW1wb3J0
T2JqLmhvc3Rba10gPSB2O1xuICAgIH1cbiAgfVxuXG4gIC8vIEludGVycG9sYXRlZCBpbXBvcnRz
XG4gIGlmIChpbnRlcnBWYWx1ZXMpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGludGVycFZh
bHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgdiA9IGludGVycFZhbHVlc1tpXTtcbiAg
ICAgIGlmICh0eXBlb2YgdiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBpbXBvcnRPYmouaG9z
dFsnX19JTlRFUlBfJyArIGkgKyAnX18nXSA9IHY7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAg
Ly8gTWVtb3J5XG4gIGlmICh1c2VySW1wb3J0cyAmJiB1c2VySW1wb3J0cy5fX21lbW9yeSkge1xu
ICAgIGlmICghaW1wb3J0T2JqLmVudikgaW1wb3J0T2JqLmVudiA9IHt9O1xuICAgIGltcG9ydE9i
ai5lbnYubWVtb3J5ID0gdXNlckltcG9ydHMuX19tZW1vcnk7XG4gIH1cblxuICBjb25zdCBtb2Qg
PSBuZXcgV2ViQXNzZW1ibHkuTW9kdWxlKGJ5dGVzKTtcbiAgY29uc3QgaW5zdGFuY2UgPSBuZXcg
V2ViQXNzZW1ibHkuSW5zdGFuY2UobW9kLCBpbXBvcnRPYmopO1xuICByZXR1cm4gaW5zdGFuY2U7
XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhdHJhKHN0cmluZ3NPck9wdHMsIC4uLnZhbHVlcykge1xu
ICAvLyBDdXJyaWVkIGZvcm06IGF0cmEoe2ltcG9ydHN9KWAuLi5gXG4gIGlmIChzdHJpbmdzT3JP
cHRzICYmICFBcnJheS5pc0FycmF5KHN0cmluZ3NPck9wdHMpICYmIHR5cGVvZiBzdHJpbmdzT3JP
cHRzID09PSAnb2JqZWN0JyAmJiAhc3RyaW5nc09yT3B0cy5yYXcpIHtcbiAgICBjb25zdCBvcHRz
ID0gc3RyaW5nc09yT3B0cztcbiAgICByZXR1cm4gZnVuY3Rpb24oc3RyaW5ncywgLi4udmFscykg
e1xuICAgICAgcmV0dXJuIGNvbXBpbGVBbmRJbnN0YW50aWF0ZShzdHJpbmdzLCB2YWxzLCBvcHRz
KTtcbiAgICB9O1xuICB9XG4gIC8vIERpcmVjdCBmb3JtOiBhdHJhYC4uLmBcbiAgcmV0dXJuIGNv
bXBpbGVBbmRJbnN0YW50aWF0ZShzdHJpbmdzT3JPcHRzLCB2YWx1ZXMsIG51bGwpO1xufVxuXG5m
dW5jdGlvbiBjb21waWxlQW5kSW5zdGFudGlhdGUoc3RyaW5ncywgdmFsdWVzLCB1c2VySW1wb3J0
cykge1xuICAvLyBOb3JtYWxpemU6IHVzZXIgcGFzc2VzIHsgbWVtb3J5IH0gYnV0IGludGVybmFs
IGNvZGUgdXNlcyBfX21lbW9yeVxuICBpZiAodXNlckltcG9ydHMgJiYgdXNlckltcG9ydHMubWVt
b3J5ICYmICF1c2VySW1wb3J0cy5fX21lbW9yeSkge1xuICAgIHVzZXJJbXBvcnRzID0gT2JqZWN0
LmFzc2lnbih7fSwgdXNlckltcG9ydHMsIHsgX19tZW1vcnk6IHVzZXJJbXBvcnRzLm1lbW9yeSB9
KTtcbiAgfVxuICAvLyBKb2luIHRlbXBsYXRlIHN0cmluZ3Mgd2l0aCBpbnRlcnBvbGF0aW9uIG1h
cmtlcnNcbiAgbGV0IHNvdXJjZSA9IHN0cmluZ3NbMF07XG4gIGZvciAobGV0IGkgPSAwOyBpIDwg
dmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gRm9yIG51bWVyaWMgdmFsdWVzLCBpbmxpbmUg
dGhlbSBkaXJlY3RseVxuICAgIGlmICh0eXBlb2YgdmFsdWVzW2ldID09PSAnbnVtYmVyJykge1xu
ICAgICAgc291cmNlICs9IFN0cmluZyh2YWx1ZXNbaV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBz
b3VyY2UgKz0gJ19fSU5URVJQXycgKyBpICsgJ19fJztcbiAgICB9XG4gICAgc291cmNlICs9IHN0
cmluZ3NbaSArIDFdO1xuICB9XG5cbiAgY29uc3QgYnl0ZXMgPSBjb21waWxlU291cmNlKHNvdXJj
ZSwgdmFsdWVzLCB1c2VySW1wb3J0cyk7XG4gIGNvbnN0IGluc3RhbmNlID0gaW5zdGFudGlhdGUo
Ynl0ZXMsIHVzZXJJbXBvcnRzLCB2YWx1ZXMpO1xuICByZXR1cm4gaW5zdGFuY2UuZXhwb3J0cztc
bn1cblxuLy8gRGlyZWN0IGNvbXBpbGVyIGFjY2Vzc1xuYXRyYS5jb21waWxlID0gZnVuY3Rpb24o
c291cmNlKSB7XG4gIHJldHVybiBjb21waWxlU291cmNlKHNvdXJjZSwgbnVsbCwgbnVsbCk7XG59
O1xuXG5hdHJhLnBhcnNlID0gZnVuY3Rpb24oc291cmNlKSB7XG4gIGNvbnN0IHRva2VucyA9IGxl
eChzb3VyY2UpO1xuICByZXR1cm4gcGFyc2UodG9rZW5zKTtcbn07XG5cbmF0cmEuZHVtcCA9IGZ1
bmN0aW9uKHNvdXJjZSkge1xuICBjb25zdCBieXRlcyA9IGNvbXBpbGVTb3VyY2Uoc291cmNlLCBu
dWxsLCBudWxsKTtcbiAgcmV0dXJuIEFycmF5LmZyb20oYnl0ZXMpLm1hcChiID0+IGIudG9TdHJp
bmcoMTYpLnBhZFN0YXJ0KDIsICcwJykpLmpvaW4oJyAnKTtcbn07XG5cbi8vIOKUgOKUgCBTZWxm
LXJlZ2lzdHJhdGlvbiDilIDilIBcblxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQn
KSB7XG4gIGlmICghd2luZG93Ll90YWdnZWRMYW5ndWFnZXMpIHdpbmRvdy5fdGFnZ2VkTGFuZ3Vh
Z2VzID0ge307XG4gIHdpbmRvdy5fdGFnZ2VkTGFuZ3VhZ2VzLmF0cmEgPSB7IHRva2VuaXplOiB0
b2tlbml6ZUF0cmEsIGNvbXBsZXRpb25zOiBhdHJhQ29tcGxldGlvbnMgfTtcbn1cblxuLy8gQXR0
YWNoIGludGVybmFscyBmb3IgdGVzdGluZyAvIGFkdmFuY2VkIHVzZVxuYXRyYS5fbGV4ID0gbGV4
O1xuYXRyYS5fcGFyc2UgPSBwYXJzZTtcbmF0cmEuX3Rva2VuaXplID0gdG9rZW5pemVBdHJhO1xu
IiwiY2VsbElkIjpudWxsfX0=
AUDITABLE-MODULES-->
<!-- notebook settings: JSON {theme, fontSize, width, ...} -->
<!--AUDITABLE-SETTINGS
{"theme":"dark","fontSize":13,"width":"860"}
AUDITABLE-SETTINGS-->

<script>
// -- state.js --

// ═══════════════════════════════════════════════════
// AUDITABLE — reactive notebook runtime
// Geoscientific Chaos Union, 2025
// ═══════════════════════════════════════════════════

const $ = s => document.querySelector(s);
const $$ = s => [...document.querySelectorAll(s)];

// ── STATE ──
const S = {
  cells: [],        // { id, type, code, el, defines, uses, output, error }
  scope: {},        // shared variable scope
  cellId: 0,        // unique cell ID counter
  editTimer: null,  // debounce timer for autorun
  autorun: true,    // reactive mode flag
  selectedId: null, // currently selected cell
  pendingD: false,  // for "dd" double-tap delete
  pendingDTimer: null,
  clipboard: null,  // copied cell data
  trash: [],        // undo stack for deleted cells
  findActive: false,
  findQuery: '',
  findCase: false,
  findRegex: false,
  findMatches: [],   // { cellId, index, length }
  findCurrent: -1,
  initialized: false, // set after loadFromEmbed/init completes
};

const JS_KEYWORDS = new Set([
  'const','let','var','function','return','if','else','for','while','do',
  'switch','case','break','continue','new','this','class','extends','import',
  'export','default','from','of','in','typeof','instanceof','void','delete',
  'throw','try','catch','finally','async','await','yield','true','false',
  'null','undefined','NaN','Infinity'
]);

const JS_BUILTINS = new Set([
  'Math','Array','Object','String','Number','Float64Array','Float32Array',
  'Int32Array','Uint8Array','Map','Set','Promise','console','JSON',
  'ui','std','load','install','print',
  'workshop','notebook','md','html','css'
]);


// -- stdlib.js --

// ── STDLIB ──
// Bundled standard library for notebook work.
// Module-level — no per-cell state needed.

// ── Provider Registry ──

const _providers = { file: null, download: null };

function registerProvider(name, fn) {
  if (name in _providers) _providers[name] = fn;
}

// ── Data ──

function csv(text, opts = {}) {
  const sep = opts.separator || ',';
  const typed = !!opts.typed;
  const lines = [];
  let i = 0;
  const len = text.length;

  while (i < len) {
    const row = [];
    while (i < len) {
      if (text[i] === '"') {
        // quoted field
        i++;
        let field = '';
        while (i < len) {
          if (text[i] === '"') {
            if (text[i + 1] === '"') { field += '"'; i += 2; }
            else { i++; break; }
          } else { field += text[i]; i++; }
        }
        row.push(field);
        if (text[i] === sep) i++;
        else if (text[i] === '\r') { i++; if (text[i] === '\n') i++; break; }
        else if (text[i] === '\n') { i++; break; }
        else if (i >= len) break;
      } else {
        // unquoted field
        let field = '';
        while (i < len && text[i] !== sep && text[i] !== '\n' && text[i] !== '\r') {
          field += text[i]; i++;
        }
        row.push(field);
        if (text[i] === sep) i++;
        else if (text[i] === '\r') { i++; if (text[i] === '\n') i++; break; }
        else if (text[i] === '\n') { i++; break; }
        else break;
      }
    }
    if (row.length > 0 && !(row.length === 1 && row[0] === '')) lines.push(row);
  }

  if (lines.length < 2) return [];
  const headers = lines[0];
  const result = [];
  for (let r = 1; r < lines.length; r++) {
    const obj = {};
    for (let c = 0; c < headers.length; c++) {
      let val = lines[r][c] !== undefined ? lines[r][c] : '';
      if (typed) {
        const num = Number(val);
        if (val !== '' && !isNaN(num)) val = num;
        else if (val === 'true') val = true;
        else if (val === 'false') val = false;
        else if (val === '') val = null;
      }
      obj[headers[c]] = val;
    }
    result.push(obj);
  }
  return result;
}

async function fetchJSON(url) {
  const resp = await fetch(url);
  if (!resp.ok) throw new Error(`fetchJSON: ${resp.status} ${resp.statusText}`);
  return resp.json();
}

// ── Math / Stats ──

function _acc(arr, fn) {
  return fn ? arr.map(fn) : arr;
}

function sum(arr, fn) {
  const vals = _acc(arr, fn);
  let s = 0;
  for (let i = 0; i < vals.length; i++) s += vals[i];
  return s;
}

function mean(arr, fn) {
  if (!arr.length) return NaN;
  return sum(arr, fn) / arr.length;
}

function median(arr, fn) {
  const vals = _acc(arr, fn).slice().sort((a, b) => a - b);
  const n = vals.length;
  if (n === 0) return NaN;
  if (n % 2 === 1) return vals[(n - 1) / 2];
  return (vals[n / 2 - 1] + vals[n / 2]) / 2;
}

function extent(arr, fn) {
  const vals = _acc(arr, fn);
  let lo = Infinity, hi = -Infinity;
  for (let i = 0; i < vals.length; i++) {
    if (vals[i] < lo) lo = vals[i];
    if (vals[i] > hi) hi = vals[i];
  }
  return [lo, hi];
}

function bin(arr, n = 10, fn) {
  const vals = _acc(arr, fn);
  const [lo, hi] = extent(vals);
  const range = hi - lo || 1;
  const step = range / n;
  const bins = [];
  for (let i = 0; i < n; i++) {
    bins.push({ x0: lo + i * step, x1: lo + (i + 1) * step, values: [] });
  }
  for (const v of vals) {
    let idx = Math.floor((v - lo) / step);
    if (idx >= n) idx = n - 1;
    if (idx < 0) idx = 0;
    bins[idx].values.push(v);
  }
  return bins;
}

function linspace(start, stop, n) {
  if (n < 2) return n === 1 ? [start] : [];
  const result = new Array(n);
  const step = (stop - start) / (n - 1);
  for (let i = 0; i < n; i++) result[i] = start + i * step;
  result[n - 1] = stop; // exact endpoint
  return result;
}

// ── Array ──

function unique(arr, fn) {
  if (!fn) return [...new Set(arr)];
  const seen = new Set();
  const result = [];
  for (const item of arr) {
    const key = fn(item);
    if (!seen.has(key)) { seen.add(key); result.push(item); }
  }
  return result;
}

function zip(...arrays) {
  const len = Math.min(...arrays.map(a => a.length));
  const result = new Array(len);
  for (let i = 0; i < len; i++) {
    result[i] = arrays.map(a => a[i]);
  }
  return result;
}

function cross(...arrays) {
  if (arrays.length === 0) return [[]];
  const [first, ...rest] = arrays;
  const sub = cross(...rest);
  const result = [];
  for (const item of first) {
    for (const tail of sub) {
      result.push([item, ...tail]);
    }
  }
  return result;
}

// ── DOM / IO ──

async function file(accept) {
  if (_providers.file) return _providers.file(accept);
  return new Promise((resolve, reject) => {
    const input = document.createElement('input');
    input.type = 'file';
    if (accept) input.accept = accept;
    input.onchange = async () => {
      const f = input.files[0];
      if (!f) { reject(new Error('no file selected')); return; }
      const text = await f.text();
      resolve({ name: f.name, text, size: f.size });
    };
    input.click();
  });
}

function download(data, filename, mimeType) {
  if (_providers.download) return _providers.download(data, filename, mimeType);
  const str = typeof data === 'string' ? data : JSON.stringify(data, null, 2);
  const mime = mimeType || (typeof data === 'string' ? 'text/plain' : 'application/json');
  const blob = new Blob([str], { type: mime });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename || 'download';
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  setTimeout(() => URL.revokeObjectURL(url), 1000);
}

function el(tag, attrs, ...children) {
  const elem = document.createElement(tag);
  if (attrs && typeof attrs === 'object' && !(attrs instanceof Node)) {
    for (const [k, v] of Object.entries(attrs)) {
      if (k === 'style' && typeof v === 'object') {
        Object.assign(elem.style, v);
      } else if (k.startsWith('on') && typeof v === 'function') {
        elem.addEventListener(k.slice(2), v);
      } else {
        elem.setAttribute(k, v);
      }
    }
  } else if (attrs != null) {
    // attrs is actually a child
    children.unshift(attrs);
  }
  for (const child of children) {
    if (child instanceof Node) elem.appendChild(child);
    else if (child != null) elem.appendChild(document.createTextNode(String(child)));
  }
  return elem;
}

async function copy(text) {
  await navigator.clipboard.writeText(text);
}

function fmt(number, opts = {}) {
  const { decimals, prefix, suffix } = opts;
  let s = decimals != null ? number.toFixed(decimals)
    : new Intl.NumberFormat(undefined, { maximumFractionDigits: 6 }).format(number);
  if (prefix) s = prefix + s;
  if (suffix) s = s + suffix;
  return s;
}

// ── Export ──

const std = {
  csv, fetchJSON,
  sum, mean, median, extent, bin, linspace,
  unique, zip, cross,
  file, download, el, copy, fmt,
};

// -- python.js --

// ── @python COMPAT HELPERS ──
// Python-familiar functions for users transitioning from Python.
// Each has a .help property showing the idiomatic JS equivalent.

function range(a, b, step) {
  let start, stop, s;
  if (b === undefined) { start = 0; stop = a; s = 1; }
  else { start = a; stop = b; s = step || 1; }
  const result = [];
  if (s > 0) { for (let i = start; i < stop; i += s) result.push(i); }
  else if (s < 0) { for (let i = start; i > stop; i += s) result.push(i); }
  return result;
}
range.help = 'JS: Array.from({length: n}, (_, i) => start + i * step)';

function enumerate(arr) {
  return arr.map((v, i) => [i, v]);
}
enumerate.help = 'JS: arr.map((v, i) => [i, v]) or arr.entries()';

function len(x) {
  if (x == null) throw new TypeError('len() of unsized object');
  if (x.size !== undefined) return x.size;
  return x.length;
}
len.help = 'JS: x.length or x.size';

function sorted(arr, key, reverse) {
  const copy = [...arr];
  if (key) copy.sort((a, b) => {
    const ka = key(a), kb = key(b);
    return ka < kb ? -1 : ka > kb ? 1 : 0;
  });
  else copy.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
  if (reverse) copy.reverse();
  return copy;
}
sorted.help = 'JS: arr.toSorted((a, b) => ...)';

function reversed(arr) {
  return [...arr].reverse();
}
reversed.help = 'JS: arr.toReversed()';

function isinstance(obj, cls) {
  return obj instanceof cls;
}
isinstance.help = 'JS: obj instanceof cls';

function type(x) {
  if (x === null) return 'null';
  if (Array.isArray(x)) return 'array';
  return typeof x;
}
type.help = 'JS: typeof x';

const python = {
  range, enumerate, len, sorted, reversed,
  isinstance, type,
};

function zenOfPython() {
  return [
    'The Zen of Python, by Tim Peters',
    '',
    'Beautiful is better than ugly.',
    'Explicit is better than implicit.',
    'Simple is better than complex.',
    'Complex is better than complicated.',
    'Flat is better than nested.',
    'Sparse is better than dense.',
    'Readability counts.',
    "Special cases aren't special enough to break the rules.",
    'Although practicality beats purity.',
    'Errors should never pass silently.',
    'Unless explicitly silenced.',
    'In the face of ambiguity, refuse the temptation to guess.',
    'There should be one-- and preferably only one --obvious way to do it.',
    "Although that way may not be obvious at first unless you're Dutch.",
    'Now is better than never.',
    'Although never is often better than *right* now.',
    "If the implementation is hard to explain, it's a bad idea.",
    'If the implementation is easy to explain, it may be a good idea.',
    "Namespaces are one honking great idea -- let's do more of those!",
  ].join('\n');
}

// -- syntax.js --

// ── SYNTAX HIGHLIGHTING ──

const CSS_NAMED_COLORS = new Set([
  'black','silver','gray','white','maroon','red','purple','fuchsia',
  'green','lime','olive','yellow','navy','blue','teal','aqua','orange'
]);

// detect curried tagged template: scan back through tokens for lang({...})`
function detectCurriedTag(tokens) {
  // last non-whitespace token must be )
  let j = tokens.length - 1;
  while (j >= 0 && tokens[j].type === '') j--;
  if (j < 0 || tokens[j].text !== ')') return null;
  // scan back to matching (
  let depth = 1;
  j--;
  while (j >= 0 && depth > 0) {
    if (tokens[j].text === ')') depth++;
    else if (tokens[j].text === '(') depth--;
    j--;
  }
  // token before ( should be the language name
  while (j >= 0 && tokens[j].type === '') j--;
  if (j < 0) return null;
  const name = tokens[j].text;
  if (window._taggedLanguages && window._taggedLanguages[name]) {
    return window._taggedLanguages[name];
  }
  return null;
}

// tokenize a tagged template literal starting at the opening backtick
function tokenizeTaggedTemplate(code, i, len, lang, tokens) {
  tokens.push({ type: 'punc', text: '`' });
  i++; // skip opening backtick
  let strBuf = '';
  while (i < len && code[i] !== '`') {
    if (code[i] === '\\') {
      strBuf += code[i] + (i + 1 < len ? code[i + 1] : '');
      i += 2;
      continue;
    }
    if (code[i] === '$' && i + 1 < len && code[i + 1] === '{') {
      if (strBuf) {
        tokens.push(...lang.tokenize(strBuf));
        strBuf = '';
      }
      tokens.push({ type: 'punc', text: '${' });
      i += 2;
      let depth = 1;
      let exprStart = i;
      while (i < len && depth > 0) {
        if (code[i] === '{') depth++;
        else if (code[i] === '}') { depth--; if (depth === 0) break; }
        else if (code[i] === '`') {
          i++;
          while (i < len && code[i] !== '`') {
            if (code[i] === '\\') i++;
            i++;
          }
        } else if (code[i] === '"' || code[i] === "'") {
          const q = code[i]; i++;
          while (i < len && code[i] !== q) {
            if (code[i] === '\\') i++;
            i++;
          }
        }
        i++;
      }
      const expr = code.slice(exprStart, i);
      if (expr) tokens.push(...tokenize(expr));
      if (i < len && code[i] === '}') {
        tokens.push({ type: 'punc', text: '}' });
        i++;
      }
      continue;
    }
    strBuf += code[i];
    i++;
  }
  if (strBuf) tokens.push(...lang.tokenize(strBuf));
  if (i < len && code[i] === '`') {
    tokens.push({ type: 'punc', text: '`' });
    i++;
  }
  return i;
}

function tokenize(code) {
  const tokens = [];
  let i = 0;
  const len = code.length;

  while (i < len) {
    // line comment
    if (code[i] === '/' && code[i+1] === '/') {
      const start = i;
      while (i < len && code[i] !== '\n') i++;
      tokens.push({ type: 'cmt', text: code.slice(start, i) });
      continue;
    }
    // block comment
    if (code[i] === '/' && code[i+1] === '*') {
      const start = i;
      i += 2;
      while (i < len && !(code[i-1] === '*' && code[i] === '/')) i++;
      if (i < len) i++;
      tokens.push({ type: 'cmt', text: code.slice(start, i) });
      continue;
    }
    // strings
    if (code[i] === '"' || code[i] === "'" || code[i] === '`') {
      // curried tagged template: lang({...})`...` — detect before treating as plain string
      if (code[i] === '`' && typeof window !== 'undefined' && window._taggedLanguages) {
        const lang = detectCurriedTag(tokens);
        if (lang) {
          i = tokenizeTaggedTemplate(code, i, len, lang, tokens);
          continue;
        }
      }
      const q = code[i];
      const start = i;
      i++;
      while (i < len && code[i] !== q) {
        if (code[i] === '\\') i++;
        i++;
      }
      if (i < len) i++;
      tokens.push({ type: 'str', text: code.slice(start, i) });
      continue;
    }
    // numbers
    if (/\d/.test(code[i]) || (code[i] === '.' && i+1 < len && /\d/.test(code[i+1]))) {
      const start = i;
      if (code[i] === '0' && (code[i+1] === 'x' || code[i+1] === 'X')) {
        i += 2;
        while (i < len && /[0-9a-fA-F_]/.test(code[i])) i++;
      } else {
        while (i < len && /[0-9._eE+-]/.test(code[i])) i++;
      }
      tokens.push({ type: 'num', text: code.slice(start, i) });
      continue;
    }
    // identifiers / keywords
    if (/[a-zA-Z_$]/.test(code[i])) {
      const start = i;
      while (i < len && /\w/.test(code[i])) i++;
      const word = code.slice(start, i);

      // tagged template literal — delegate to registered language tokenizer
      if (i < len && code[i] === '`' && typeof window !== 'undefined'
          && window._taggedLanguages && window._taggedLanguages[word]) {
        tokens.push({ type: 'fn', text: word });
        i = tokenizeTaggedTemplate(code, i, len, window._taggedLanguages[word], tokens);
        continue;
      }

      if (JS_KEYWORDS.has(word)) {
        tokens.push({ type: 'kw', text: word });
      } else if (JS_BUILTINS.has(word)) {
        tokens.push({ type: 'const', text: word });
      } else if (i < len && code[i] === '(') {
        tokens.push({ type: 'fn', text: word });
      } else {
        tokens.push({ type: 'id', text: word });
      }
      continue;
    }
    // operators
    if ('=+-*/<>!&|^~%?:'.includes(code[i])) {
      tokens.push({ type: 'op', text: code[i] });
      i++;
      continue;
    }
    // punctuation
    if ('(){}[];,.'.includes(code[i])) {
      tokens.push({ type: 'punc', text: code[i] });
      i++;
      continue;
    }
    // whitespace / other — pass through
    tokens.push({ type: '', text: code[i] });
    i++;
  }

  return tokens;
}

function highlightCode(ta, hl) {
  const code = ta.value;
  if (!code) { hl.innerHTML = '\n'; return; }

  const tokens = tokenize(code);
  let html = '';
  for (const t of tokens) {
    const escaped = t.text
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;');
    if (t.type && t.type !== 'id') {
      html += `<span class="hl-${t.type}">${escaped}</span>`;
    } else {
      html += escaped;
    }
  }
  // trailing newline so highlight layer matches textarea height
  hl.innerHTML = html + '\n';
}

// ── CSS SYNTAX HIGHLIGHTING ──

function tokenizeCss(code) {
  const tokens = [];
  let i = 0;
  const len = code.length;
  let ctx = 'sel'; // 'sel' | 'prop' | 'val'
  let depth = 0;

  while (i < len) {
    // block comment
    if (code[i] === '/' && code[i+1] === '*') {
      const start = i;
      i += 2;
      while (i < len && !(code[i-1] === '*' && code[i] === '/')) i++;
      if (i < len) i++;
      tokens.push({ type: 'cmt', text: code.slice(start, i) });
      continue;
    }
    // strings
    if (code[i] === '"' || code[i] === "'") {
      const q = code[i];
      const start = i;
      i++;
      while (i < len && code[i] !== q) {
        if (code[i] === '\\') i++;
        i++;
      }
      if (i < len) i++;
      tokens.push({ type: 'str', text: code.slice(start, i) });
      continue;
    }
    // punctuation with context transitions
    if (code[i] === '{') {
      tokens.push({ type: 'punc', text: '{' });
      depth++;
      ctx = 'prop';
      i++;
      continue;
    }
    if (code[i] === '}') {
      tokens.push({ type: 'punc', text: '}' });
      depth--;
      ctx = depth > 0 ? 'prop' : 'sel';
      i++;
      continue;
    }
    if (code[i] === ':' && ctx === 'prop') {
      tokens.push({ type: 'punc', text: ':' });
      ctx = 'val';
      i++;
      continue;
    }
    if (code[i] === ';') {
      tokens.push({ type: 'punc', text: ';' });
      ctx = 'prop';
      i++;
      continue;
    }
    if ('(),'.includes(code[i])) {
      tokens.push({ type: 'punc', text: code[i] });
      i++;
      continue;
    }
    // @-rules
    if (code[i] === '@') {
      const start = i;
      i++;
      while (i < len && /[a-zA-Z-]/.test(code[i])) i++;
      tokens.push({ type: 'atrule', text: code.slice(start, i) });
      continue;
    }
    // !important
    if (code[i] === '!' && ctx === 'val') {
      const start = i;
      i++;
      while (i < len && /[a-zA-Z]/.test(code[i])) i++;
      tokens.push({ type: 'important', text: code.slice(start, i) });
      continue;
    }
    // # — hex color in val, ID selector in sel
    if (code[i] === '#') {
      if (ctx === 'val') {
        const start = i;
        i++;
        while (i < len && /[0-9a-fA-F]/.test(code[i])) i++;
        tokens.push({ type: 'color', text: code.slice(start, i) });
      } else {
        // ID selector
        const start = i;
        i++;
        while (i < len && /[\w-]/.test(code[i])) i++;
        tokens.push({ type: 'sel', text: code.slice(start, i) });
      }
      continue;
    }
    // : in selector context = pseudo-class
    if (code[i] === ':' && ctx === 'sel') {
      const start = i;
      i++;
      if (i < len && code[i] === ':') i++; // ::
      while (i < len && /[a-zA-Z-]/.test(code[i])) i++;
      // handle pseudo with parens like :nth-child(...)
      if (i < len && code[i] === '(') {
        i++;
        let pdepth = 1;
        while (i < len && pdepth > 0) {
          if (code[i] === '(') pdepth++;
          else if (code[i] === ')') pdepth--;
          if (pdepth > 0) i++;
        }
        if (i < len) i++;
      }
      tokens.push({ type: 'sel', text: code.slice(start, i) });
      continue;
    }
    // . in selector context = class selector
    if (code[i] === '.' && ctx === 'sel') {
      const start = i;
      i++;
      while (i < len && /[\w-]/.test(code[i])) i++;
      tokens.push({ type: 'sel', text: code.slice(start, i) });
      continue;
    }
    // numbers (with units)
    if (ctx === 'val' && (/\d/.test(code[i]) || (code[i] === '.' && i+1 < len && /\d/.test(code[i+1])))) {
      const start = i;
      while (i < len && /[0-9.]/.test(code[i])) i++;
      // units
      while (i < len && /[a-zA-Z%]/.test(code[i])) i++;
      tokens.push({ type: 'num', text: code.slice(start, i) });
      continue;
    }
    // identifiers
    if (/[a-zA-Z_-]/.test(code[i])) {
      const start = i;
      while (i < len && /[\w-]/.test(code[i])) i++;
      const word = code.slice(start, i);
      // function call
      if (i < len && code[i] === '(') {
        tokens.push({ type: 'fn', text: word });
        continue;
      }
      if (ctx === 'val' && CSS_NAMED_COLORS.has(word.toLowerCase())) {
        tokens.push({ type: 'color', text: word });
      } else if (ctx === 'prop') {
        tokens.push({ type: 'prop', text: word });
      } else if (ctx === 'sel') {
        tokens.push({ type: 'sel', text: word });
      } else {
        tokens.push({ type: '', text: word });
      }
      continue;
    }
    // whitespace / other
    tokens.push({ type: '', text: code[i] });
    i++;
  }

  return tokens;
}

function resolveToHex(colorStr) {
  const d = document.createElement('div');
  d.style.color = colorStr;
  document.body.appendChild(d);
  const rgb = getComputedStyle(d).color;
  d.remove();
  const m = rgb.match(/(\d+)/g);
  if (!m || m.length < 3) return colorStr;
  return '#' + m.slice(0, 3).map(n => parseInt(n).toString(16).padStart(2, '0')).join('');
}

let _colorPicker = null;
let _pickerTarget = null; // { ta, offset, len }

function ensureColorPicker() {
  if (_colorPicker) return _colorPicker;
  _colorPicker = document.createElement('input');
  _colorPicker.type = 'color';
  _colorPicker.style.cssText = 'position:absolute;visibility:hidden;width:0;height:0;';
  document.body.appendChild(_colorPicker);
  _colorPicker.addEventListener('input', () => {
    if (!_pickerTarget) return;
    const { ta, offset, len } = _pickerTarget;
    const newColor = _colorPicker.value;
    ta.focus();
    ta.selectionStart = offset;
    ta.selectionEnd = offset + len;
    document.execCommand('insertText', false, newColor);
    ta.dispatchEvent(new Event('input'));
    // update offset for new length
    _pickerTarget.len = newColor.length;
  });
  return _colorPicker;
}

function highlightCss(ta, hl) {
  const code = ta.value;
  if (!code) { hl.innerHTML = '\n'; return; }

  const tokens = tokenizeCss(code);
  let html = '';
  let offset = 0;
  for (const t of tokens) {
    const escaped = t.text
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;');
    if (t.type === 'color') {
      const hex = resolveToHex(t.text);
      html += `<span class="hl-color"><span class="hl-swatch" style="background:${hex}" data-offset="${offset}" data-len="${t.text.length}"></span>${escaped}</span>`;
    } else if (t.type && t.type !== 'id') {
      html += `<span class="hl-${t.type}">${escaped}</span>`;
    } else {
      html += escaped;
    }
    offset += t.text.length;
  }
  hl.innerHTML = html + '\n';

  // wire swatch clicks (only add once per highlight layer)
  if (!hl._swatchWired) {
    hl._swatchWired = true;
    hl.addEventListener('click', (e) => {
      const swatch = e.target.closest('.hl-swatch');
      if (!swatch) return;
      const off = parseInt(swatch.dataset.offset);
      const len = parseInt(swatch.dataset.len);
      const picker = ensureColorPicker();
      _pickerTarget = { ta, offset: off, len };
      const hex = resolveToHex(ta.value.slice(off, off + len));
      picker.value = hex;
      picker.click();
    });
  }
}

// ── HTML SYNTAX HIGHLIGHTING ──

function tokenizeHtml(code) {
  const tokens = [];
  let i = 0;
  const len = code.length;

  while (i < len) {
    // template expression ${...}
    if (code[i] === '$' && i + 1 < len && code[i + 1] === '{') {
      const start = i;
      i += 2;
      let depth = 1;
      while (i < len && depth > 0) {
        if (code[i] === '{') depth++;
        else if (code[i] === '}') depth--;
        if (depth > 0) i++;
      }
      if (i < len) i++;
      tokens.push({ type: 'expr', text: code.slice(start, i) });
      continue;
    }
    // comment <!-- ... -->
    if (code[i] === '<' && code[i + 1] === '!' && code[i + 2] === '-' && code[i + 3] === '-') {
      const start = i;
      i += 4;
      while (i < len) {
        if (code[i] === '-' && code[i + 1] === '-' && code[i + 2] === '>') { i += 3; break; }
        i++;
      }
      tokens.push({ type: 'cmt', text: code.slice(start, i) });
      continue;
    }
    // tag
    if (code[i] === '<') {
      tokens.push({ type: 'tag', text: '<' });
      i++;
      // closing slash
      if (i < len && code[i] === '/') { tokens.push({ type: 'tag', text: '/' }); i++; }
      // tag name
      const ns = i;
      while (i < len && /[a-zA-Z0-9-]/.test(code[i])) i++;
      if (i > ns) tokens.push({ type: 'tag', text: code.slice(ns, i) });
      // attributes until >
      while (i < len && code[i] !== '>') {
        // template expression inside tag
        if (code[i] === '$' && i + 1 < len && code[i + 1] === '{') {
          const start = i;
          i += 2;
          let depth = 1;
          while (i < len && depth > 0) {
            if (code[i] === '{') depth++;
            else if (code[i] === '}') depth--;
            if (depth > 0) i++;
          }
          if (i < len) i++;
          tokens.push({ type: 'expr', text: code.slice(start, i) });
          continue;
        }
        if (/\s/.test(code[i])) { tokens.push({ type: '', text: code[i] }); i++; continue; }
        if (code[i] === '/') { tokens.push({ type: 'tag', text: '/' }); i++; continue; }
        if (code[i] === '=') { tokens.push({ type: 'punc', text: '=' }); i++; continue; }
        // quoted attribute value
        if (code[i] === '"' || code[i] === "'") {
          const q = code[i];
          const start = i;
          i++;
          while (i < len && code[i] !== q) { if (code[i] === '\\') i++; i++; }
          if (i < len) i++;
          tokens.push({ type: 'str', text: code.slice(start, i) });
          continue;
        }
        // attribute name or unquoted value
        const as = i;
        while (i < len && !/[\s=>/"']/.test(code[i])) i++;
        if (i > as) {
          let j = i;
          while (j < len && /\s/.test(code[j])) j++;
          tokens.push({ type: (j < len && code[j] === '=') ? 'attr' : 'attr', text: code.slice(as, i) });
        }
      }
      if (i < len && code[i] === '>') { tokens.push({ type: 'tag', text: '>' }); i++; }
      continue;
    }
    // plain text
    tokens.push({ type: '', text: code[i] });
    i++;
  }

  return tokens;
}

function highlightHtml(ta, hl) {
  const code = ta.value;
  if (!code) { hl.innerHTML = '\n'; return; }

  const tokens = tokenizeHtml(code);
  let html = '';
  for (const t of tokens) {
    const escaped = t.text
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;');
    if (t.type) {
      html += `<span class="hl-${t.type}">${escaped}</span>`;
    } else {
      html += escaped;
    }
  }
  hl.innerHTML = html + '\n';
}

// -- dag.js --

// ── REACTIVE DAG ──

// ── directive helpers ──

function hasDirective(code, name) {
  return new RegExp(String.raw`^\s*\/\/\s*%${name}\b`, 'm').test(code);
}

function getDirective(code, name) {
  const m = code.match(new RegExp(String.raw`^\s*\/\/\s*%${name}\s+(.+)`, 'm'));
  return m ? m[1].trim() : null;
}

const isManual    = code => hasDirective(code, 'manual');
const isHidden    = code => hasDirective(code, 'hide');
const isNorun     = code => hasDirective(code, 'norun');
const isCollapsed = code => hasDirective(code, 'collapsed');
const parseCellName    = code => getDirective(code, 'cellName');
const parseOutputId    = code => { const v = getDirective(code, 'outputId'); return v ? v.split(/\s+/)[0] : null; };
const parseOutputClass = code => getDirective(code, 'outputClass');

// ── code analysis ──

function stripCommentsAndStrings(code) {
  // single-pass: strings take precedence over comments (// inside "..." is not a comment)
  let out = '', i = 0;
  while (i < code.length) {
    // single-quoted string
    if (code[i] === "'") {
      out += '""';
      i++;
      while (i < code.length && code[i] !== "'") { if (code[i] === '\\') i++; i++; }
      i++; // skip closing quote
      continue;
    }
    // double-quoted string
    if (code[i] === '"') {
      out += '""';
      i++;
      while (i < code.length && code[i] !== '"') { if (code[i] === '\\') i++; i++; }
      i++; // skip closing quote
      continue;
    }
    // template literal: replace string parts with spaces but keep ${expr} content
    if (code[i] === '`') {
      i++;
      while (i < code.length && code[i] !== '`') {
        if (code[i] === '\\') { i += 2; continue; }
        if (code[i] === '$' && code[i + 1] === '{') {
          i += 2;
          let depth = 1;
          out += ' ';
          while (i < code.length && depth > 0) {
            if (code[i] === '{') depth++;
            else if (code[i] === '}') { depth--; if (depth === 0) break; }
            out += code[i];
            i++;
          }
          out += ' ';
          i++; // skip closing }
          continue;
        }
        i++;
      }
      i++; // skip closing backtick
      continue;
    }
    // line comment
    if (code[i] === '/' && code[i + 1] === '/') {
      while (i < code.length && code[i] !== '\n') i++;
      continue;
    }
    // block comment
    if (code[i] === '/' && code[i + 1] === '*') {
      i += 2;
      while (i < code.length && !(code[i - 1] === '*' && code[i] === '/')) i++;
      i++;
      continue;
    }
    out += code[i];
    i++;
  }
  return out;
}

function parseNames(code) {
  // extract ONLY top-level variable definitions (brace depth 0)
  const defines = new Set();

  const stripped = stripCommentsAndStrings(code);

  let depth = 0;
  let parenDepth = 0;
  let i = 0;
  while (i < stripped.length) {
    const ch = stripped[i];
    if (ch === '{') { depth++; i++; continue; }
    if (ch === '}') { depth--; i++; continue; }
    if (ch === '(') { parenDepth++; i++; continue; }
    if (ch === ')') { parenDepth--; i++; continue; }

    if (depth === 0 && parenDepth === 0) {
      // check for const/let/var
      const rest = stripped.slice(i);
      const dm = rest.match(/^(?:const|let|var)\s+(\w+)/);
      if (dm) {
        defines.add(dm[1]);
        // scan forward for comma-separated declarations: const W = 80, H = 60
        // skip initializer expressions tracking depth, grab identifiers after commas
        let j = dm[0].length;
        let d = 0, pd = 0, bd = 0;
        while (j < rest.length) {
          const ch = rest[j];
          if (ch === '{') d++;
          else if (ch === '}') d--;
          else if (ch === '(') pd++;
          else if (ch === ')') pd--;
          else if (ch === '[') bd++;
          else if (ch === ']') bd--;
          else if (ch === ';' || ch === '\n') {
            if (d === 0 && pd === 0 && bd === 0) break;
          }
          else if (ch === ',' && d === 0 && pd === 0 && bd === 0) {
            // next identifier after comma
            const after = rest.slice(j + 1).match(/^\s*(\w+)/);
            if (after) defines.add(after[1]);
          }
          j++;
        }
        i += j;
        continue;
      }
      // destructuring: const { a, b } = ... or const [ a, b ] = ...
      const destruct = rest.match(/^(?:const|let|var)\s*[\{\[]/);
      if (destruct) {
        // find the closing } or ] then extract identifiers
        const opener = rest[destruct[0].length - 1];
        const closer = opener === '{' ? '}' : ']';
        const closeIdx = rest.indexOf(closer, destruct[0].length);
        if (closeIdx > 0) {
          const inner = rest.slice(destruct[0].length, closeIdx);
          // split on commas, take last word of each part (handles renaming)
          inner.split(',').forEach(part => {
            const parts = part.trim().split(/\s*:\s*/);
            const name = (parts.length > 1 ? parts[1] : parts[0]).trim().match(/^\w+/);
            if (name) defines.add(name[0]);
          });
          i += closeIdx + 1;
          continue;
        }
      }
      // check for function declarations
      const fm = rest.match(/^function\s+(\w+)/);
      if (fm) {
        defines.add(fm[1]);
        i += fm[0].length;
        continue;
      }
    }
    i++;
  }

  return { defines };
}

function findUses(code, allDefined, selfDefined) {
  // find identifiers that reference other cells' definitions
  const uses = new Set();
  const stripped = stripCommentsAndStrings(code);
  if (!selfDefined) selfDefined = parseNames(code).defines;

  const idRe = /\b([a-zA-Z_$]\w*)\b/g;
  let m;
  while ((m = idRe.exec(stripped))) {
    if (allDefined.has(m[1]) && !selfDefined.has(m[1])) {
      uses.add(m[1]);
    }
  }
  return uses;
}

function findHtmlUses(code, allDefined) {
  const uses = new Set();
  const re = /\$\{([^}]+)\}/g;
  let m;
  while ((m = re.exec(code))) {
    const expr = m[1];
    const idRe = /\b([a-zA-Z_$]\w*)\b/g;
    let im;
    while ((im = idRe.exec(expr))) {
      if (allDefined.has(im[1])) uses.add(im[1]);
    }
  }
  return uses;
}

function buildDAG() {
  // collect all defined names globally (only re-parse changed cells)
  const allDefined = new Map(); // name -> cell id
  for (const c of S.cells) {
    if (c.type !== 'code') continue;
    if (c.code !== c._parsedCode) {
      const { defines } = parseNames(c.code);
      c.defines = defines;
      c._parsedCode = c.code;
    }
    for (const name of c.defines) {
      allDefined.set(name, c.id);
    }
  }

  // find uses for each cell (invalidate if code changed or global names changed)
  const definedNames = new Set(allDefined.keys());
  const definedKey = [...definedNames].sort().join(',');
  for (const c of S.cells) {
    if (c.type === 'code') {
      if (c.code !== c._usesCode || c._definedKey !== definedKey) {
        c.uses = findUses(c.code, definedNames, c.defines);
        c._usesCode = c.code;
        c._definedKey = definedKey;
      }
    } else if (c.type === 'html') {
      if (c.code !== c._usesCode || c._definedKey !== definedKey) {
        c.uses = findHtmlUses(c.code, definedNames);
        c._usesCode = c.code;
        c._definedKey = definedKey;
      }
    }
  }

  return allDefined;
}

function topoSort(dirtyIds) {
  // BFS from dirty cells to find all downstream dependents
  const dependents = new Map(); // varName -> Set<cellId>
  for (const c of S.cells) {
    if (!c.uses) continue;
    for (const name of c.uses) {
      if (!dependents.has(name)) dependents.set(name, new Set());
      dependents.get(name).add(c.id);
    }
  }

  const needsRun = new Set(dirtyIds);
  const queue = [...dirtyIds];
  while (queue.length) {
    const id = queue.shift();
    const cell = S.cells.find(c => c.id === id);
    if (!cell || !cell.defines) continue;
    for (const name of cell.defines) {
      const deps = dependents.get(name);
      if (!deps) continue;
      for (const depId of deps) {
        if (!needsRun.has(depId)) {
          needsRun.add(depId);
          queue.push(depId);
        }
      }
    }
  }

  // return in document order
  return S.cells.filter(c => needsRun.has(c.id)).map(c => c.id);
}

// -- exec.js --

// ── EXECUTION ENGINE ──
//
// Scope model: each cell runs inside an AsyncFunction where upstream variables
// are passed as parameters. This is pass-by-value for primitives — reassigning
// a variable in cell A (e.g. `grid = next`) does NOT propagate to cell B.
// Mutable state that needs to survive across callbacks belongs in %manual cells
// using DOM elements, objects, or closures.
//
// Cell builtins (display, canvas, slider, load, install, installBinary, etc.)
// are injected as additional parameters — listed in _injected, not in scope.
// They are NOT propagated to downstream cells.

// ── BINARY HELPERS ──

function uint8ToBase64(bytes) {
  let bin = '';
  for (let i = 0; i < bytes.length; i++) bin += String.fromCharCode(bytes[i]);
  return btoa(bin);
}

async function decodeBinary(entry) {
  const type = entry.type || 'application/octet-stream';
  const bytes = Uint8Array.from(atob(entry.source), c => c.charCodeAt(0));
  if (entry.compressed) {
    const ds = new DecompressionStream('gzip');
    const stream = new Blob([bytes]).stream().pipeThrough(ds);
    const decompressed = new Uint8Array(await new Response(stream).arrayBuffer());
    return URL.createObjectURL(new Blob([decompressed], { type }));
  }
  return URL.createObjectURL(new Blob([bytes], { type }));
}

// ── TAGGED CONTENT ──

class TaggedContent {
  constructor(type, content) { this.type = type; this.content = content; }
  toString() { return this.content; }
}

function taggedTemplate(type) {
  return (strings, ...values) => {
    let result = strings[0];
    for (let i = 0; i < values.length; i++) result += String(values[i]) + strings[i + 1];
    return new TaggedContent(type, result);
  };
}

// ── EXECUTION ──

function renderHtmlCell(cell) {
  const viewEl = cell.el.querySelector('.cell-html-view');
  const outputEl = cell.el.querySelector('.cell-output');
  if (!viewEl) return;
  if (outputEl) { outputEl.textContent = ''; outputEl.className = 'cell-output'; }

  // use only variables this cell references for stable function signatures
  const scopeKeys = cell.uses ? [...cell.uses].sort() : [];
  const scopeVals = scopeKeys.map(k => S.scope[k]);

  // cache compiled template functions per expression
  if (!cell._tplCache) cell._tplCache = {};
  const scopeSig = scopeKeys.join(',');
  if (cell._tplScopeSig !== scopeSig) {
    cell._tplCache = {};  // scope signature changed, invalidate all
    cell._tplScopeSig = scopeSig;
  }

  let rendered = cell.code.replace(/\$\{([^}]+)\}/g, (match, expr) => {
    try {
      let fn = cell._tplCache[expr];
      if (!fn) {
        fn = new Function(...scopeKeys, '"use strict"; return (' + expr + ')');
        cell._tplCache[expr] = fn;
      }
      const val = fn(...scopeVals);
      return val === undefined ? '' : String(val);
    } catch (e) {
      return '[Error: ' + e.message + ']';
    }
  });

  viewEl.innerHTML = rendered;
  cell.el.classList.remove('stale', 'error');
  cell.el.classList.add('fresh');
  setTimeout(() => cell.el.classList.remove('fresh'), 800);
}

async function execCell(cell) {
  // fire invalidation promise from previous run (cleanup resources)
  if (cell._invalidate) { cell._invalidate(); cell._invalidate = null; }

  const outputEl = cell.el.querySelector('.cell-output');
  const widgetEl = cell.el.querySelector('.cell-widgets');

  // preserve canvases before clearing output
  const prevCanvases = [...outputEl.querySelectorAll('canvas')];
  outputEl.textContent = '';
  outputEl.className = 'cell-output';
  const outClass = parseOutputClass(cell.code);
  if (outClass) outputEl.classList.add(...outClass.split(/\s+/));
  const outId = parseOutputId(cell.code);
  outputEl.id = outId || '';
  cell.el.classList.toggle('present-hidden', isHidden(cell.code));
  cell.error = null;

  // create invalidation promise for this run
  let invalidationResolve;
  const invalidation = new Promise(r => { invalidationResolve = r; });
  cell._invalidate = invalidationResolve;

  // track which widgets are used this run
  const usedWidgets = new Set();
  let canvasIdx = 0;

  // build display function for this cell
  const display = (...args) => {
    for (const arg of args) {
      if (arg instanceof Element) {
        outputEl.appendChild(arg);
      } else if (typeof arg === 'object' && arg !== null) {
        const pre = document.createElement('span');
        try { pre.textContent = JSON.stringify(arg, null, 2); }
        catch { pre.textContent = String(arg); }
        outputEl.appendChild(pre);
        outputEl.appendChild(document.createTextNode('\n'));
      } else {
        outputEl.appendChild(document.createTextNode(String(arg) + '\n'));
      }
    }
  };

  // canvas helper — reuses existing canvas if dimensions match
  const canvas = (w = 400, h = 300) => {
    const prev = prevCanvases[canvasIdx++];
    if (prev && prev.width === w && prev.height === h) {
      outputEl.appendChild(prev);
      return prev;
    }
    const c = document.createElement('canvas');
    c.width = w; c.height = h;
    c.style.background = '#000';
    outputEl.appendChild(c);
    return c;
  };

  // table helper
  const table = (data, columns) => {
    if (!data || !data.length) return;
    const cols = columns || Object.keys(data[0]);

    // detect numeric columns by scanning first 10 rows
    const isNumCol = {};
    for (const c of cols) {
      let allNum = true;
      const scanRows = data.slice(0, 10);
      for (const row of scanRows) {
        const v = row[c];
        if (v !== null && v !== undefined && typeof v !== 'number') { allNum = false; break; }
      }
      isNumCol[c] = allNum;
    }

    const t = document.createElement('table');
    const thead = document.createElement('thead');
    const hr = document.createElement('tr');
    for (const c of cols) {
      const th = document.createElement('th');
      th.textContent = c;
      th.style.textAlign = isNumCol[c] ? 'right' : 'left';
      hr.appendChild(th);
    }
    thead.appendChild(hr);
    t.appendChild(thead);
    const tbody = document.createElement('tbody');
    for (const row of data) {
      const tr = document.createElement('tr');
      for (const c of cols) {
        const td = document.createElement('td');
        const v = row[c];
        td.textContent = typeof v === 'number' ? (Number.isInteger(v) ? v : v.toFixed(4)) : String(v ?? '');
        td.style.textAlign = isNumCol[c] ? 'right' : 'left';
        tr.appendChild(td);
      }
      tbody.appendChild(tr);
    }
    t.appendChild(tbody);
    outputEl.appendChild(t);
  };

  // input widget helpers — persist state and DOM across re-runs
  if (!cell._inputs) cell._inputs = {};
  if (!cell._callbacks) cell._callbacks = {};

  const mkInput = (label, type, defaultVal, opts = {}) => {
    const key = label;
    const prev = cell._inputs[key];
    let val = prev !== undefined ? prev : defaultVal;
    usedWidgets.add(key);
    cell._callbacks[key] = { onInput: opts.onInput, onChange: opts.onChange };

    // check if widget DOM already exists
    const existing = widgetEl.querySelector(`[data-widget-key="${CSS.escape(key)}"]`);
    if (existing) {
      // update id/class in case they changed on re-run
      existing.id = opts.id || '';
      existing.className = 'cell-widget' + (opts.class ? ' ' + opts.class : '');
      // just return current value, DOM stays — callbacks already updated above
      cell._inputs[key] = type === 'slider' ? parseFloat(val)
                         : type === 'checkbox' ? !!val
                         : val;
      return cell._inputs[key];
    }

    // create new widget
    const wrap = document.createElement('div');
    wrap.dataset.widgetKey = key;
    wrap.className = 'cell-widget' + (opts.class ? ' ' + opts.class : '');
    if (opts.id) wrap.id = opts.id;

    const lbl = document.createElement('span');
    lbl.textContent = label;
    lbl.className = 'cell-widget-label';
    wrap.appendChild(lbl);

    let input;
    if (type === 'slider') {
      input = document.createElement('input');
      input.type = 'range';
      input.min = opts.min ?? 0;
      input.max = opts.max ?? 100;
      input.step = opts.step ?? 1;
      input.value = val;
      const valSpan = document.createElement('span');
      valSpan.textContent = val;
      valSpan.className = 'cell-widget-val';
      input.oninput = () => {
        const n = parseFloat(input.value);
        cell._inputs[key] = n;
        valSpan.textContent = n;
        const cb = cell._callbacks[key];
        if (cb.onInput) { cb.onInput(n); }
        else if (!cb.onChange) { clearTimeout(cell._inputTimer); cell._inputTimer = setTimeout(() => runDAG([cell.id], true), 80); }
      };
      input.onchange = () => { const cb = cell._callbacks[key]; if (cb.onChange) cb.onChange(parseFloat(input.value)); };
      wrap.appendChild(input);
      wrap.appendChild(valSpan);
    } else if (type === 'dropdown') {
      input = document.createElement('select');
      for (const o of (opts.options || [])) {
        const opt = document.createElement('option');
        opt.value = o;
        opt.textContent = o;
        if (o === val) opt.selected = true;
        input.appendChild(opt);
      }
      input.onchange = () => {
        cell._inputs[key] = input.value;
        const cb = cell._callbacks[key];
        if (cb.onInput || cb.onChange) {
          if (cb.onInput) cb.onInput(input.value);
          if (cb.onChange) cb.onChange(input.value);
        } else { runDAG([cell.id], true); }
      };
      wrap.appendChild(input);
    } else if (type === 'checkbox') {
      input = document.createElement('input');
      input.type = 'checkbox';
      input.checked = !!val;
      input.onchange = () => {
        cell._inputs[key] = input.checked;
        const cb = cell._callbacks[key];
        if (cb.onInput || cb.onChange) {
          if (cb.onInput) cb.onInput(input.checked);
          if (cb.onChange) cb.onChange(input.checked);
        } else { runDAG([cell.id], true); }
      };
      wrap.appendChild(input);
    } else if (type === 'text') {
      input = document.createElement('input');
      input.type = 'text';
      input.value = val;
      input.oninput = () => {
        cell._inputs[key] = input.value;
        const cb = cell._callbacks[key];
        if (cb.onInput) { cb.onInput(input.value); }
        else if (!cb.onChange) { clearTimeout(cell._inputTimer); cell._inputTimer = setTimeout(() => runDAG([cell.id], true), 300); }
      };
      input.onchange = () => { const cb = cell._callbacks[key]; if (cb.onChange) cb.onChange(input.value); };
      wrap.appendChild(input);
    }

    widgetEl.appendChild(wrap);
    cell._inputs[key] = type === 'slider' ? parseFloat(val)
                       : type === 'checkbox' ? !!val
                       : val;
    return cell._inputs[key];
  };

  const slider = (label, defaultVal = 50, opts = {}) => mkInput(label, 'slider', defaultVal, opts);
  const dropdown = (label, options, defaultVal, opts = {}) => mkInput(label, 'dropdown', defaultVal || options[0], { ...opts, options });
  const checkbox = (label, defaultVal = false, opts = {}) => mkInput(label, 'checkbox', defaultVal, opts);
  const textInput = (label, defaultVal = '', opts = {}) => mkInput(label, 'text', defaultVal, opts);

  // execute with scoped parameters (only what this cell uses, for stable V8 JIT)
  // filter out injected names — they're per-cell params, not scope-propagated
  const _injected = ['ui', 'std', 'load', 'install', 'installBinary', 'invalidation', 'print', 'md', 'html', 'css', 'workshop', 'notebook'];
  const scopeKeys = cell.uses ? [...cell.uses].filter(k => !_injected.includes(k)).sort() : [];
  const defNames = cell.defines ? [...cell.defines].sort().join(', ') : '';

  // import cache — shared across all cells
  if (!window._importCache) window._importCache = {};
  if (!window._installedModules) window._installedModules = {}; // url -> { source, cellId }

  const load = async (url) => {
    // virtual modules
    if (url === '@std') return std;
    if (url === '@python') return python;
    if (url === '@python/this') { display(zenOfPython()); return python; }
    if (window._importCache[url]) return window._importCache[url];

    // binary assets — return blob URL
    if (window._installedModules[url]?.binary) {
      const blobUrl = await decodeBinary(window._installedModules[url]);
      window._importCache[url] = blobUrl;
      return blobUrl;
    }

    const langsBefore = window._taggedLanguages ? Object.keys(window._taggedLanguages).length : 0;

    let mod;
    // check installed (offline) modules first
    if (window._installedModules[url]) {
      const entry = window._installedModules[url];
      let src = typeof entry === 'string' ? entry : entry.source;
      // resolve root-relative paths for legacy saved modules
      try { src = resolveModulePaths(src, url); } catch {}
      const blob = new Blob([src], { type: 'application/javascript' });
      const blobUrl = URL.createObjectURL(blob);
      mod = await import(blobUrl);
    } else {
      mod = await import(url);
    }
    window._importCache[url] = mod;

    // if the module registered new tagged languages, re-highlight all code cells
    const langsAfter = window._taggedLanguages ? Object.keys(window._taggedLanguages).length : 0;
    if (langsAfter > langsBefore) {
      for (const c of S.cells) {
        if (c.type !== 'code') continue;
        const ta = c.el.querySelector('textarea');
        const hl = c.el.querySelector('.highlight-layer');
        if (ta && hl) highlightCode(ta, hl);
      }
    }

    return mod;
  };

  // resolve root-relative paths in module source so blob URLs work
  const resolveModulePaths = (source, responseUrl) => {
    const origin = new URL(responseUrl).origin;
    return source.replace(/(from\s+["'])(\/[^"']+)(["'])/g, '$1' + origin + '$2$3')
                 .replace(/(import\s*\(["'])(\/[^"']+)(["']\))/g, '$1' + origin + '$2$3')
                 .replace(/(export\s+\*\s+from\s+["'])(\/[^"']+)(["'])/g, '$1' + origin + '$2$3')
                 .replace(/(export\s*\{[^}]*\}\s*from\s+["'])(\/[^"']+)(["'])/g, '$1' + origin + '$2$3');
  };

  const install = async (url) => {
    // normalize: add ?bundle for esm.sh if not present
    let bundleUrl = url;
    if (bundleUrl.includes('esm.sh') && !bundleUrl.includes('?bundle') && !bundleUrl.includes('&bundle')) {
      bundleUrl += (bundleUrl.includes('?') ? '&' : '?') + 'bundle';
    }
    // fetch source
    const resp = await fetch(bundleUrl);
    if (!resp.ok) throw new Error(`Failed to fetch ${bundleUrl}: ${resp.status}`);
    let source = await resp.text();
    // resolve root-relative paths to absolute so blob URLs work
    source = resolveModulePaths(source, resp.url);
    // store under original url with cell reference
    window._installedModules[url] = { source, cellId: cell.id };
    // also load it into cache
    const blob = new Blob([source], { type: 'application/javascript' });
    const blobUrl = URL.createObjectURL(blob);
    const mod = await import(blobUrl);
    window._importCache[url] = mod;
    display(`installed ${url} (${(source.length / 1024).toFixed(1)} KB)`);
    return mod;
  };

  const installBinary = async (url, opts = {}) => {
    const compress = opts.compress !== false;
    // if already installed, decode and return blob URL
    if (window._installedModules[url]?.binary) {
      return decodeBinary(window._installedModules[url]);
    }
    const resp = await fetch(url);
    if (!resp.ok) throw new Error(`Failed to fetch ${url}: ${resp.status}`);
    const contentType = resp.headers.get('content-type')?.split(';')[0] || 'application/octet-stream';
    const buf = await resp.arrayBuffer();
    const raw = new Uint8Array(buf);
    let stored, isCompressed = false;
    if (compress) {
      const cs = new CompressionStream('gzip');
      const stream = new Blob([raw]).stream().pipeThrough(cs);
      const compressed = new Uint8Array(await new Response(stream).arrayBuffer());
      stored = uint8ToBase64(compressed);
      isCompressed = true;
    } else {
      stored = uint8ToBase64(raw);
    }
    window._installedModules[url] = { source: stored, cellId: cell.id, binary: true, compressed: isCompressed, type: contentType };
    const ratio = isCompressed ? ` \u2192 ${(stored.length / 1024).toFixed(1)} KB compressed` : '';
    display(`installed binary ${url} (${(buf.byteLength / 1024).toFixed(1)} KB${ratio})`);
    return URL.createObjectURL(new Blob([raw], { type: contentType }));
  };

  // ui object — constructed per-cell (closes over cell context)
  const ui = { display, print: display, canvas, table, slider, dropdown, checkbox, textInput };

  // tagged template builtins
  const md = taggedTemplate('md');
  const html = taggedTemplate('html');
  const css = taggedTemplate('css');

  // workshop builtin — slide-out side panel with navigable pages
  const workshop = (pages, opts) => {
    const key = '__workshop__';
    usedWidgets.add(key);
    const useOverlay = !!(opts && opts.overlay);

    // persist page index across re-runs
    if (cell._inputs[key] === undefined) cell._inputs[key] = 0;
    let currentPage = cell._inputs[key];

    // get or create panel DOM
    let panel = document.getElementById('workshopPanel');
    let overlay = document.getElementById('workshopOverlay');
    if (!panel) {
      overlay = document.createElement('div');
      overlay.id = 'workshopOverlay';
      overlay.className = 'workshop-overlay';
      overlay.onclick = () => toggleWorkshop(false);
      document.body.appendChild(overlay);

      panel = document.createElement('div');
      panel.id = 'workshopPanel';
      panel.className = 'workshop-panel';
      document.body.appendChild(panel);
    }

    // side tab attached to the panel edge
    let toggleBtn = document.getElementById('workshopToggle');
    if (!toggleBtn) {
      toggleBtn = document.createElement('button');
      toggleBtn.id = 'workshopToggle';
      toggleBtn.className = 'workshop-tab';
      toggleBtn.title = 'toggle workshop panel';
      toggleBtn.textContent = 'workshop';
      document.body.appendChild(toggleBtn);
      toggleBtn.onclick = () => toggleWorkshop();
    }

    function toggleWorkshop(show) {
      const isOpen = panel.classList.contains('open');
      const shouldOpen = show !== undefined ? show : !isOpen;
      panel.classList.toggle('open', shouldOpen);
      if (useOverlay) overlay.classList.toggle('visible', shouldOpen);
    }

    function renderPage(idx) {
      idx = Math.max(0, Math.min(idx, pages.length - 1));
      currentPage = idx;
      cell._inputs[key] = idx;
      const page = pages[idx];

      panel.innerHTML = '';

      // header with close button
      const header = document.createElement('div');
      header.className = 'workshop-header';
      const title = document.createElement('span');
      title.className = 'workshop-title';
      title.textContent = page.title || `Page ${idx + 1}`;
      header.appendChild(title);
      const closeBtn = document.createElement('button');
      closeBtn.className = 'workshop-close';
      closeBtn.textContent = '\u00d7';
      closeBtn.onclick = () => toggleWorkshop(false);
      header.appendChild(closeBtn);
      panel.appendChild(header);

      // content
      const body = document.createElement('div');
      body.className = 'workshop-body';
      if (page.content instanceof Element) {
        body.appendChild(page.content);
      } else if (page.content instanceof TaggedContent) {
        if (page.content.type === 'md') {
          body.innerHTML = renderMd(page.content.content);
        } else if (page.content.type === 'css') {
          const pre = document.createElement('pre');
          pre.textContent = page.content.content;
          body.appendChild(pre);
        } else {
          body.innerHTML = page.content.content;
        }
      } else {
        body.textContent = String(page.content ?? '');
      }
      panel.appendChild(body);

      // progress pips
      const pips = document.createElement('div');
      pips.className = 'workshop-pips';
      for (let i = 0; i < pages.length; i++) {
        const pip = document.createElement('span');
        pip.className = 'workshop-pip' + (i === idx ? ' active' : '') + (i < idx ? ' done' : '');
        pip.onclick = () => navigate(i);
        pips.appendChild(pip);
      }
      panel.appendChild(pips);

      // nav buttons
      const nav = document.createElement('div');
      nav.className = 'workshop-nav';
      if (idx > 0) {
        const prev = document.createElement('button');
        prev.textContent = '\u2190 prev';
        prev.onclick = () => navigate(idx - 1);
        nav.appendChild(prev);
      }
      const spacer = document.createElement('span');
      spacer.style.flex = '1';
      nav.appendChild(spacer);
      const counter = document.createElement('span');
      counter.className = 'workshop-counter';
      counter.textContent = `${idx + 1} / ${pages.length}`;
      nav.appendChild(counter);
      if (idx < pages.length - 1) {
        const next = document.createElement('button');
        next.className = 'workshop-next';
        next.textContent = 'next \u2192';
        if (page.canAdvance && !page.canAdvance()) {
          next.disabled = true;
          next.title = 'complete the task to continue';
        }
        next.onclick = () => navigate(idx + 1);
        nav.appendChild(next);
      }
      panel.appendChild(nav);

      // fire onEnter
      if (page.onEnter) page.onEnter();
    }

    function navigate(idx) {
      const prevPage = pages[currentPage];
      if (prevPage?.onLeave) prevPage.onLeave();
      renderPage(idx);
    }

    // store re-check function for canAdvance gating
    cell._workshopRecheck = () => {
      const page = pages[currentPage];
      if (!page?.canAdvance) return;
      const nextBtn = panel.querySelector('.workshop-next');
      if (nextBtn) {
        nextBtn.disabled = !page.canAdvance();
      }
    };

    renderPage(currentPage);

    // auto-open on first creation
    if (!panel.classList.contains('open') && !cell._workshopShown) {
      toggleWorkshop(true);
      cell._workshopShown = true;
    }

    // store cleanup so deleteCell can tear down workshop DOM
    cell._workshopCleanup = () => {
      panel.remove();
      overlay.remove();
      toggleBtn.remove();
      cell._workshopRecheck = null;
    };
    // on re-run, just clear the recheck — DOM is reused by ID
    invalidation.then(() => {
      cell._workshopRecheck = null;
    });

    return { goto: navigate, toggle: toggleWorkshop, recheck: cell._workshopRecheck };
  };

  // notebook API — programmatic notebook control
  const notebook = {
    get cells() { return S.cells.map(c => ({ id: c.id, type: c.type, code: c.code })); },
    get scope() { return { ...S.scope }; },
    addCell: (type, code, afterId) => addCell(type, code, afterId),
    scrollTo: (id) => {
      const c = S.cells.find(c => c.id === id);
      if (c?.el) c.el.scrollIntoView({ behavior: 'smooth', block: 'center' });
    },
    focus: (id) => {
      const c = S.cells.find(c => c.id === id);
      if (c?.el) {
        c.el.scrollIntoView({ behavior: 'smooth', block: 'center' });
        const ta = c.el.querySelector('textarea');
        if (ta) ta.focus();
      }
    },
    collapse: (id) => {
      const c = S.cells.find(c => c.id === id);
      if (c?.el) c.el.classList.add('collapsed');
    },
    expand: (id) => {
      const c = S.cells.find(c => c.id === id);
      if (c?.el) c.el.classList.remove('collapsed');
    },
    run: (ids) => runDAG(Array.isArray(ids) ? ids : [ids], true),
  };

  // function caching — reuse compiled function if code/uses/defines unchanged
  const cacheKey = scopeKeys.join(',') + '|' + defNames + '|' + cell.code;

  try {
    let fn;
    if (cell._cacheKey === cacheKey && cell._cachedFn) {
      fn = cell._cachedFn;
    } else {
      const AsyncFunction = Object.getPrototypeOf(async function(){}).constructor;
      const cellName = parseCellName(cell.code);
      const slug = cellName ? '-' + cellName.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/(^-|-$)/g, '') : '';
      fn = new AsyncFunction(
        ...scopeKeys,
        'ui', 'std', 'load', 'install', 'installBinary', 'invalidation', 'print',
        'md', 'html', 'css', 'workshop', 'notebook',
        `"use strict";\n${cell.code}\n\n` +
        `return { ${defNames} };\n` +
        `//# sourceURL=auditable://cell-${cell.id}${slug}.js`
      );
      cell._cachedFn = fn;
      cell._cacheKey = cacheKey;
    }

    const scopeVals = scopeKeys.map(k => S.scope[k]);
    const result = await fn(...scopeVals, ui, std, load, install, installBinary, invalidation, display,
      md, html, css, workshop, notebook);

    // update scope with defined variables
    if (result && typeof result === 'object') {
      cell._lastResult = result;
      for (const [k, v] of Object.entries(result)) {
        if (v !== undefined) S.scope[k] = v;
      }
    }

    cell.el.classList.remove('stale', 'error');
    cell.el.classList.add('fresh');
    setTimeout(() => cell.el.classList.remove('fresh'), 800);

    // remove widgets no longer referenced by code
    for (const w of widgetEl.querySelectorAll('[data-widget-key]')) {
      if (!usedWidgets.has(w.dataset.widgetKey)) {
        delete cell._inputs[w.dataset.widgetKey];
        delete cell._callbacks[w.dataset.widgetKey];
        w.remove();
      }
    }

  } catch (e) {
    cell.error = e.message;
    outputEl.textContent = e.message;
    outputEl.className = 'cell-output error';
    cell.el.classList.remove('stale', 'fresh');
    cell.el.classList.add('error');
  }
}

async function runDAG(dirtyIds, force = false) {
  buildDAG();
  const isAutorun = S.autorun && !force;

  // determine which cells need execution via topo sort
  const runSet = new Set(topoSort(dirtyIds));

  if (window._dagStart) window._dagStart();

  // rebuild scope in document order, only executing cells in runSet
  S.scope = {};
  const poisoned = new Set(); // variable names defined by errored cells
  for (let i = 0; i < S.cells.length; i++) {
    const cell = S.cells[i];

    if (cell.type === 'html') {
      if (runSet.has(cell.id)) {
        // check if any used variable is poisoned
        if (cell.uses && [...cell.uses].some(n => poisoned.has(n))) {
          cell.el.classList.remove('fresh');
          cell.el.classList.add('stale');
        } else {
          renderHtmlCell(cell);
        }
      }
      continue;
    }
    if (cell.type !== 'code') continue;

    // skip norun cells (unless explicitly triggered)
    if (isNorun(cell.code) && !dirtyIds.includes(cell.id)) {
      if (cell._lastResult) {
        for (const [k, v] of Object.entries(cell._lastResult)) {
          if (v !== undefined) S.scope[k] = v;
        }
      }
      continue;
    }

    // skip manual cells unless force or explicitly triggered
    if (!force && isManual(cell.code) && !dirtyIds.includes(cell.id)) {
      if (cell._lastResult) {
        for (const [k, v] of Object.entries(cell._lastResult)) {
          if (v !== undefined) S.scope[k] = v;
        }
      }
      cell.el.classList.add('stale');
      continue;
    }

    // not in run set — restore cached results, skip execution
    if (!runSet.has(cell.id)) {
      if (cell._lastResult) {
        for (const [k, v] of Object.entries(cell._lastResult)) {
          if (v !== undefined) S.scope[k] = v;
        }
      }
      continue;
    }

    // error isolation: if any upstream dependency is poisoned, skip this cell
    if (cell.uses && cell.uses.size > 0) {
      let blocked = false;
      for (const name of cell.uses) {
        if (poisoned.has(name)) { blocked = true; break; }
      }
      if (blocked) {
        const outputEl = cell.el.querySelector('.cell-output');
        if (outputEl && !cell.error) {
          outputEl.textContent = 'blocked by upstream error';
          outputEl.className = 'cell-output error';
        }
        cell.el.classList.remove('stale', 'fresh');
        cell.el.classList.add('error');
        // poison our own defines so downstream also blocks
        if (cell.defines) for (const name of cell.defines) poisoned.add(name);
        continue;
      }
    }

    // value-equality gating: if this cell is a downstream dependent (not directly
    // dirty) and all its input values are unchanged, skip re-execution entirely
    if (!dirtyIds.includes(cell.id) && cell._lastResult && cell.uses && cell.uses.size > 0) {
      let inputsChanged = false;
      for (const name of cell.uses) {
        if (S.scope[name] !== cell._prevInputs?.[name]) { inputsChanged = true; break; }
      }
      if (!inputsChanged) {
        // inputs identical — restore previous results, skip execution
        for (const [k, v] of Object.entries(cell._lastResult)) {
          if (v !== undefined) S.scope[k] = v;
        }
        continue;
      }
    }

    if (window._beforeExec) window._beforeExec(cell);
    await execCell(cell);

    // if the cell errored, poison its defines
    if (cell.error) {
      if (cell.defines) for (const name of cell.defines) poisoned.add(name);
    }

    // snapshot input values for future equality checks
    if (cell.uses) {
      cell._prevInputs = {};
      for (const name of cell.uses) cell._prevInputs[name] = S.scope[name];
    }

    if (window._afterExec && !isAutorun) {
      const jump = window._afterExec(cell, i);
      if (jump >= 0) { i = jump - 1; continue; }
    }
  }

  updateStatus();

  // recheck workshop canAdvance gates after scope changes
  for (const c of S.cells) {
    if (c._workshopRecheck) c._workshopRecheck();
  }
}

async function runAll() {
  const ids = S.cells.filter(c => c.type === 'code' || c.type === 'html').map(c => c.id);
  if (ids.length === 0) return;
  await runDAG(ids, true);
  setMsg('ran all cells', 'ok');
}

// late import to avoid circular dependency at module load time

// -- markdown.js --

// ── MARKDOWN RENDERING (minimal) ──

function renderMd(src) {
  let html = src
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;');

  // headings
  html = html.replace(/^### (.+)$/gm, '<h3>$1</h3>');
  html = html.replace(/^## (.+)$/gm, '<h2>$1</h2>');
  html = html.replace(/^# (.+)$/gm, '<h1>$1</h1>');

  // bold/italic
  html = html.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
  html = html.replace(/\*(.+?)\*/g, '<em>$1</em>');

  // inline code
  html = html.replace(/`(.+?)`/g, '<code>$1</code>');

  // links
  html = html.replace(/\[(.+?)\]\((.+?)\)/g, '<a href="$2">$1</a>');

  // paragraphs
  html = html.replace(/\n\n/g, '</p><p>');
  if (!html.startsWith('<h') && !html.startsWith('<p')) html = '<p>' + html + '</p>';

  return html;
}

// -- cell-dom.js --

// ── CELL DOM ──

function cssSummary(code) {
  if (!code || !code.trim()) return '';
  const rules = (code.match(/[^{}]+\{/g) || []).length;
  const lines = code.split('\n').length;
  return `${rules} rule${rules !== 1 ? 's' : ''} \u00b7 ${lines} line${lines !== 1 ? 's' : ''}`;
}

function cellHeaderHTML(type, id) {
  return `<div class="cell-header">
    <span class="cell-type">${type}</span>
    <button class="cell-btn cell-convert" onclick="toggleTypePicker(${id})" title="convert type">\u21c4</button>
    <div class="cell-type-picker" data-cell-id="${id}">
      <button onclick="convertCell(${id},'code')">code</button>
      <button onclick="convertCell(${id},'md')">md</button>
      <button onclick="convertCell(${id},'css')">css</button>
      <button onclick="convertCell(${id},'html')">html</button>
    </div>
    <button class="cell-btn cell-insert" onclick="showInsertPicker(${id},'before')" title="insert above">+\u2191</button>
    <button class="cell-btn cell-insert" onclick="showInsertPicker(${id},'after')" title="insert below">+\u2193</button>
    <button class="cell-btn" onclick="moveCell(${id},-1)" title="move up">\u2191</button>
    <button class="cell-btn" onclick="moveCell(${id},1)" title="move down">\u2193</button>
    <button class="cell-btn del" onclick="deleteCellWithUndo(${id})" title="delete">\u00d7</button>
  </div>`;
}

function createCellEl(type, id) {
  const div = document.createElement('div');
  div.className = 'cell';
  div.dataset.id = id;
  div.dataset.type = type;

  if (type === 'code') {
    div.innerHTML = `
      ${cellHeaderHTML('code', id)}
      <div class="cell-code">
        <div class="editor-wrap">
          <div class="line-numbers" aria-hidden="true">1</div>
          <textarea rows="3" spellcheck="false" wrap="off" placeholder="// code"></textarea>
          <div class="highlight-layer" aria-hidden="true"></div>
        </div>
      </div>
      <div class="cell-widgets"></div>
      <div class="cell-output"></div>
    `;

    const ta = div.querySelector('textarea');
    const hl = div.querySelector('.highlight-layer');
    div.querySelector('.cell-type').addEventListener('click', () => div.classList.toggle('collapsed'));
    const ln = div.querySelector('.line-numbers');
    ta.addEventListener('input', () => { highlightCode(ta, hl); onCodeEdit(id); });
    ta.addEventListener('scroll', () => { hl.scrollTop = ta.scrollTop; hl.scrollLeft = ta.scrollLeft; ln.scrollTop = ta.scrollTop; });
    attachAutocomplete(ta, id);
    ta.addEventListener('keydown', handleTab);
    ta.addEventListener('input', autoResize);
  } else if (type === 'css') {
    div.innerHTML = `
      ${cellHeaderHTML('css', id)}
      <div class="cell-css-view"></div>
      <div class="cell-css-edit" style="display:none">
        <div class="editor-wrap">
          <div class="line-numbers" aria-hidden="true">1</div>
          <textarea rows="3" spellcheck="false" wrap="off" placeholder="/* css */"></textarea>
          <div class="highlight-layer" aria-hidden="true"></div>
        </div>
      </div>
    `;

    const cssView = div.querySelector('.cell-css-view');
    const cssEditWrap = div.querySelector('.cell-css-edit');
    const ta = div.querySelector('textarea');
    const hl = div.querySelector('.highlight-layer');
    div.querySelector('.cell-type').addEventListener('click', () => div.classList.toggle('collapsed'));

    cssView.addEventListener('click', () => {
      cssEditWrap.style.display = '';
      cssView.style.display = 'none';
      ta.focus();
      autoResize({ target: ta });
    });

    ta.addEventListener('blur', () => {
      if (S.findActive) return;
      const cell = S.cells.find(c => c.id === id);
      if (cell) {
        cell.code = ta.value;
        cssView.textContent = cssSummary(ta.value);
      }
      cssEditWrap.style.display = 'none';
      cssView.style.display = '';
    });

    const ln = div.querySelector('.line-numbers');
    ta.addEventListener('input', () => { highlightCss(ta, hl); onCssEdit(id); });
    ta.addEventListener('scroll', () => { hl.scrollTop = ta.scrollTop; hl.scrollLeft = ta.scrollLeft; ln.scrollTop = ta.scrollTop; });
    ta.addEventListener('input', autoResize);
    ta.addEventListener('keydown', handleTab);
  } else if (type === 'html') {
    div.innerHTML = `
      ${cellHeaderHTML('html', id)}
      <div class="cell-html-view"></div>
      <div class="cell-html-edit" style="display:none">
        <div class="editor-wrap">
          <div class="line-numbers" aria-hidden="true">1</div>
          <textarea rows="2" spellcheck="false" wrap="off" placeholder="<html template>"></textarea>
          <div class="highlight-layer" aria-hidden="true"></div>
        </div>
      </div>
      <div class="cell-output"></div>
    `;

    const view = div.querySelector('.cell-html-view');
    const editWrap = div.querySelector('.cell-html-edit');
    const ta = div.querySelector('.cell-html-edit textarea');
    const hl = div.querySelector('.highlight-layer');
    div.querySelector('.cell-type').addEventListener('click', () => div.classList.toggle('collapsed'));

    view.addEventListener('click', () => {
      editWrap.style.display = '';
      view.style.display = 'none';
      ta.focus();
      autoResize({ target: ta });
    });

    ta.addEventListener('blur', () => {
      if (S.findActive) return;
      const cell = S.cells.find(c => c.id === id);
      if (cell) {
        cell.code = ta.value;
        renderHtmlCell(cell);
      }
      editWrap.style.display = 'none';
      view.style.display = '';
    });

    const ln = div.querySelector('.line-numbers');
    ta.addEventListener('input', () => { highlightHtml(ta, hl); onHtmlEdit(id); });
    ta.addEventListener('scroll', () => { hl.scrollTop = ta.scrollTop; hl.scrollLeft = ta.scrollLeft; ln.scrollTop = ta.scrollTop; });
    ta.addEventListener('input', autoResize);
    ta.addEventListener('keydown', handleTab);
  } else {
    div.innerHTML = `
      ${cellHeaderHTML('md', id)}
      <div class="cell-md-view"></div>
      <div class="cell-md-edit" style="display:none">
        <textarea rows="2" spellcheck="false" placeholder="markdown"></textarea>
      </div>
    `;

    const view = div.querySelector('.cell-md-view');
    const editWrap = div.querySelector('.cell-md-edit');
    const ta = div.querySelector('.cell-md-edit textarea');
    div.querySelector('.cell-type').addEventListener('click', () => div.classList.toggle('collapsed'));

    view.addEventListener('click', () => {
      editWrap.style.display = '';
      view.style.display = 'none';
      ta.focus();
      autoResize({ target: ta });
    });

    ta.addEventListener('blur', () => {
      if (S.findActive) return;
      const cell = S.cells.find(c => c.id === id);
      if (cell) {
        cell.code = ta.value;
        view.innerHTML = renderMd(ta.value);
      }
      editWrap.style.display = 'none';
      view.style.display = '';
    });

    ta.addEventListener('input', autoResize);
    ta.addEventListener('keydown', handleTab);
  }

  return div;
}

// undoable text replacement — uses execCommand so the browser records it in the undo stack
function replaceRange(ta, from, to, text) {
  ta.focus();
  ta.selectionStart = from;
  ta.selectionEnd = to;
  document.execCommand('insertText', false, text);
}

function handleTab(e) {
  const ta = e.target;
  const start = ta.selectionStart;
  const end = ta.selectionEnd;

  if (e.key === 'Tab') {
    e.preventDefault();

    if (start === end) {
      // no selection — insert 2 spaces
      replaceRange(ta, start, end, '  ');
    } else {
      // selection — indent/unindent lines
      const val = ta.value;
      const lineStart = val.lastIndexOf('\n', start - 1) + 1;
      const lineEnd = val.indexOf('\n', end);
      const blockEnd = lineEnd === -1 ? val.length : lineEnd;
      const block = val.slice(lineStart, blockEnd);
      let newBlock;
      if (e.shiftKey) {
        newBlock = block.replace(/^  /gm, '');
      } else {
        newBlock = block.replace(/^/gm, '  ');
      }
      replaceRange(ta, lineStart, blockEnd, newBlock);
      ta.selectionStart = lineStart;
      ta.selectionEnd = lineStart + newBlock.length;
    }
    ta.dispatchEvent(new Event('input'));
    return;
  }

  // Enter — auto-indent
  if (e.key === 'Enter') {
    e.preventDefault();
    const val = ta.value;
    const before = val.slice(0, start);
    const after = val.slice(end);

    // find current line's leading whitespace
    const lineStart = before.lastIndexOf('\n') + 1;
    const line = before.slice(lineStart);
    const indent = line.match(/^(\s*)/)[1];

    // check if the character before cursor is an opener
    const charBefore = before.trimEnd().slice(-1);
    const extra = '{(['.includes(charBefore) ? '  ' : '';

    // check if the character after cursor is a matching closer
    const charAfter = after.trimStart()[0];
    const pairs = { '{': '}', '(': ')', '[': ']' };
    const needClose = extra && charAfter === pairs[charBefore];

    if (needClose) {
      // cursor between brackets: add indented line + closing line
      const insert = '\n' + indent + extra + '\n' + indent;
      replaceRange(ta, start, end, insert);
      ta.selectionStart = ta.selectionEnd = start + 1 + indent.length + extra.length;
    } else {
      const insert = '\n' + indent + extra;
      replaceRange(ta, start, end, insert);
    }
    ta.dispatchEvent(new Event('input'));
    return;
  }

  // Ctrl+X / Ctrl+C with no selection — whole-line cut/copy
  if ((e.key === 'x' || e.key === 'c') && (e.ctrlKey || e.metaKey) && !e.shiftKey && !e.altKey && start === end) {
    e.preventDefault();
    const val = ta.value;
    const lineStart = val.lastIndexOf('\n', start - 1) + 1;
    let lineEnd = val.indexOf('\n', start);
    if (lineEnd === -1) lineEnd = val.length;
    else lineEnd++; // include the newline

    const lineText = val.slice(lineStart, lineEnd);
    navigator.clipboard.writeText(lineText);

    if (e.key === 'x') {
      replaceRange(ta, lineStart, lineEnd, '');
      ta.dispatchEvent(new Event('input'));
    }
    return;
  }
}

function toggleComment(ta) {
  const val = ta.value;
  const start = ta.selectionStart;
  const end = ta.selectionEnd;

  // find affected line range
  const lineStart = val.lastIndexOf('\n', start - 1) + 1;
  let lineEnd = val.indexOf('\n', end);
  if (lineEnd === -1) lineEnd = val.length;

  const block = val.slice(lineStart, lineEnd);
  const lines = block.split('\n');

  // check if all lines are commented
  const allCommented = lines.every(l => /^\s*\/\//.test(l) || l.trim() === '');

  let newLines;
  if (allCommented) {
    // uncomment: remove first // (and one trailing space if present)
    newLines = lines.map(l => l.replace(/^(\s*)\/\/ ?/, '$1'));
  } else {
    // comment: add // at the minimum indent level
    const indents = lines.filter(l => l.trim()).map(l => l.match(/^(\s*)/)[1].length);
    const minIndent = indents.length ? Math.min(...indents) : 0;
    newLines = lines.map(l => {
      if (l.trim() === '') return l;
      return l.slice(0, minIndent) + '// ' + l.slice(minIndent);
    });
  }

  const newBlock = newLines.join('\n');
  replaceRange(ta, lineStart, lineEnd, newBlock);
  ta.selectionStart = lineStart;
  ta.selectionEnd = lineStart + newBlock.length;
  ta.dispatchEvent(new Event('input'));
}

function updateLineNumbers(ta) {
  const wrap = ta.closest('.editor-wrap');
  if (!wrap) return;
  const gutter = wrap.querySelector('.line-numbers');
  if (!gutter) return;
  const count = ta.value.split('\n').length;
  const lines = [];
  for (let i = 1; i <= count; i++) lines.push(i);
  gutter.textContent = lines.join('\n');
}

function autoResize(e) {
  const ta = e.target || e;
  ta.style.height = 'auto';
  ta.style.height = ta.scrollHeight + 'px';
  // sync highlight layer if present
  const hl = ta.parentElement && ta.parentElement.querySelector('.highlight-layer');
  if (hl) { hl.style.height = ta.style.height; }
  updateLineNumbers(ta);
}

// -- cell-ops.js --

// ── CELL OPERATIONS ──

function addCell(type, code = '', afterId = null, beforeId = null) {
  const id = S.cellId++;
  const cell = {
    id, type, code,
    defines: new Set(),
    uses: new Set(),
    error: null,
    el: createCellEl(type, id)
  };

  const nb = $('#notebook');
  if (beforeId !== null) {
    const idx = S.cells.findIndex(c => c.id === beforeId);
    if (idx >= 0) {
      S.cells.splice(idx, 0, cell);
      S.cells[idx + 1].el.before(cell.el);
    } else {
      S.cells.push(cell);
      nb.appendChild(cell.el);
    }
  } else if (afterId !== null) {
    const idx = S.cells.findIndex(c => c.id === afterId);
    if (idx >= 0) {
      S.cells.splice(idx + 1, 0, cell);
      if (idx < S.cells.length - 2) {
        S.cells[idx + 2].el.before(cell.el);
      } else {
        nb.appendChild(cell.el);
      }
    } else {
      S.cells.push(cell);
      nb.appendChild(cell.el);
    }
  } else {
    S.cells.push(cell);
    nb.appendChild(cell.el);
  }

  // set code
  const ta = cell.el.querySelector('textarea');
  if (code) {
    ta.value = code;
    autoResize({ target: ta });
    if (type === 'code') {
      const hl = cell.el.querySelector('.highlight-layer');
      if (hl) highlightCode(ta, hl);
      if (isManual(code)) cell.el.classList.add('manual');
    }
    if (type === 'md') {
      cell.el.querySelector('.cell-md-view').innerHTML = renderMd(code);
    }
  }

  // CSS cell: create <style> element in <head>
  if (type === 'css') {
    const hl = cell.el.querySelector('.highlight-layer');
    if (hl && code) highlightCss(ta, hl);
    const cssView = cell.el.querySelector('.cell-css-view');
    if (cssView && code) cssView.textContent = cssSummary(code);
    const styleEl = document.createElement('style');
    styleEl.dataset.cellId = id;
    styleEl.textContent = code;
    document.head.appendChild(styleEl);
    cell._styleEl = styleEl;
  }

  // HTML cell: render template
  if (type === 'html' && code) {
    renderHtmlCell(cell);
  }

  ta.focus();
  updateStatus();
  notifyDirty();
  return cell;
}

function deleteCell(id) {
  const idx = S.cells.findIndex(c => c.id === id);
  if (idx < 0) return;
  // fire invalidation so cell resources (timers, etc.) clean up
  if (S.cells[idx]._invalidate) { S.cells[idx]._invalidate(); S.cells[idx]._invalidate = null; }
  // tear down workshop DOM if this cell had one
  if (S.cells[idx]._workshopCleanup) { S.cells[idx]._workshopCleanup(); S.cells[idx]._workshopCleanup = null; }
  if (S.cells[idx]._styleEl) {
    S.cells[idx]._styleEl.remove();
    S.cells[idx]._styleEl = null;
  }
  S.cells[idx].el.remove();
  S.cells.splice(idx, 1);
  // re-run to clean scope
  if (S.cells.some(c => c.type === 'code' || c.type === 'html')) runAll();
  updateStatus();
  notifyDirty();
}

function convertCell(id, newType) {
  const cell = S.cells.find(c => c.id === id);
  if (!cell || cell.type === newType) return;

  const code = cell.code;

  // cleanup old type
  if (cell._styleEl) {
    cell._styleEl.remove();
    cell._styleEl = null;
  }

  // create new cell element
  const newEl = createCellEl(newType, id);
  cell.el.replaceWith(newEl);
  cell.el = newEl;
  cell.type = newType;

  // set code
  const ta = newEl.querySelector('textarea');
  ta.value = code;
  cell.code = code;
  autoResize({ target: ta });

  if (newType === 'code') {
    const hl = newEl.querySelector('.highlight-layer');
    if (hl) highlightCode(ta, hl);
  }
  if (newType === 'md') {
    newEl.querySelector('.cell-md-view').innerHTML = renderMd(code);
  }
  if (newType === 'css') {
    const hl = newEl.querySelector('.highlight-layer');
    if (hl) highlightCss(ta, hl);
    const cssView = newEl.querySelector('.cell-css-view');
    if (cssView && code) cssView.textContent = cssSummary(code);
    const styleEl = document.createElement('style');
    styleEl.dataset.cellId = id;
    styleEl.textContent = code;
    document.head.appendChild(styleEl);
    cell._styleEl = styleEl;
  }
  if (newType === 'html') {
    renderHtmlCell(cell);
  }

  selectCell(id);
  updateStatus();
  notifyDirty();
  if (S.cells.some(c => c.type === 'code' || c.type === 'html')) runAll();
}

function moveCell(id, dir) {
  const idx = S.cells.findIndex(c => c.id === id);
  const newIdx = idx + dir;
  if (newIdx < 0 || newIdx >= S.cells.length) return;

  const [cell] = S.cells.splice(idx, 1);
  S.cells.splice(newIdx, 0, cell);

  // re-order DOM
  const nb = $('#notebook');
  nb.innerHTML = '';
  for (const c of S.cells) nb.appendChild(c.el);

  // re-order CSS <style> elements in <head> to match cell order
  for (const c of S.cells) {
    if (c._styleEl) document.head.appendChild(c._styleEl);
  }

  notifyDirty();
  if (S.cells.some(c => c.type === 'code' || c.type === 'html')) runAll();
}

// -- editor.js --

// ── EDITING ──

function notifyDirty() {
  if (S.initialized && window.__AF_BRIDGE__) window.parent.postMessage({ type: 'af:dirty' }, '*');
}

function toggleAutorun() {
  S.autorun = !S.autorun;
  const btn = $('#autorunBtn');
  const btnMobile = document.getElementById('autorunBtnMobile');
  const cls = S.autorun ? 'autorun-on' : 'autorun-off';
  const text = S.autorun ? '\u25b6' : '\u2016';
  btn.textContent = text;
  btn.title = S.autorun ? 'reactive mode \u2014 cells auto-run on edit' : 'manual mode \u2014 only Run All or Ctrl+Enter';
  btn.className = cls;
  if (btnMobile) {
    btnMobile.textContent = text;
    btnMobile.className = cls;
  }
  const sel = $('#setExecMode');
  if (sel) sel.value = S.autorun ? 'reactive' : 'manual';
  setMsg(S.autorun ? 'autorun on' : 'autorun off', 'ok');
}

function onCssEdit(id) {
  const cell = S.cells.find(c => c.id === id);
  if (!cell) return;
  cell.code = cell.el.querySelector('textarea').value;
  if (cell._styleEl) cell._styleEl.textContent = cell.code;
  notifyDirty();
}

function onHtmlEdit(id) {
  const cell = S.cells.find(c => c.id === id);
  if (!cell) return;
  cell.code = cell.el.querySelector('textarea').value;
  cell.el.classList.add('stale');
  notifyDirty();

  if (S.autorun) {
    clearTimeout(S.editTimer);
    S.editTimer = setTimeout(() => runDAG([id], false), 400);
  }
}

function onCodeEdit(id) {
  const cell = S.cells.find(c => c.id === id);
  if (!cell) return;
  const ta = cell.el.querySelector('textarea');
  cell.code = ta.value;

  // update manual state
  if (isManual(cell.code)) {
    cell.el.classList.add('manual');
  } else {
    cell.el.classList.remove('manual');
  }

  cell.el.classList.add('stale');
  notifyDirty();

  if (S.autorun) {
    clearTimeout(S.editTimer);
    S.editTimer = setTimeout(() => runDAG([id], false), 400);
  }
}

// -- settings.js --

// ── SETTINGS ──

// Safe localStorage access — blob URL iframes have opaque origins where localStorage throws
function lsGet(key) { try { return localStorage.getItem(key); } catch { return null; } }
function lsSet(key, val) { try { localStorage.setItem(key, val); } catch {} }
function lsRemove(key) { try { localStorage.removeItem(key); } catch {} }

function toggleSettings() {
  const overlay = $('#settingsOverlay');
  const panel = $('#settingsPanel');
  const open = !overlay.classList.contains('visible');
  overlay.classList.toggle('visible');
  panel.style.display = open ? 'block' : 'none';
  if (open) refreshModuleList();
}

function applyTheme(theme) {
  if (theme === 'light') {
    document.documentElement.classList.add('light');
  } else {
    document.documentElement.classList.remove('light');
  }
  $('#setTheme').value = theme;
}

function applyFontSize(size) {
  size = parseInt(size);
  document.documentElement.style.setProperty('--editor-font-size', size + 'px');
  $('#setFontSize').value = size;
  $('#setFontSizeVal').textContent = size;
}

function applyWidth(w) {
  const nb = $('#notebook');
  nb.style.maxWidth = w;
  $('#setWidth').value = w;
}

function applyLineNumbers(show) {
  const on = show === true || show === 'true' || show === 'on';
  document.documentElement.classList.toggle('hide-line-numbers', !on);
  const el = $('#setLineNumbers');
  if (el) el.value = on ? 'on' : 'off';
}

function applyHeader(mode) {
  const root = document.documentElement;
  root.classList.remove('header-always', 'header-hover', 'header-compact');
  if (mode === 'always') root.classList.add('header-always');
  else if (mode === 'hover') root.classList.add('header-hover');
  else if (mode === 'compact') root.classList.add('header-compact');
  // 'auto' = no class, CSS media queries handle it
  $('#setHeader').value = mode;
}

// ── EXECUTION MODE ──

const __AUDITABLE_DEFAULT_EXEC_MODE__ = 'reactive';
const __AUDITABLE_DEFAULT_RUN_ON_LOAD__ = 'yes';

let _runOnLoad = 'yes';
let _showToggle = 'yes';

function applyExecMode(mode) {
  S.autorun = (mode === 'reactive');
  const btn = $('#autorunBtn');
  const btnMobile = document.getElementById('autorunBtnMobile');
  const cls = S.autorun ? 'autorun-on' : 'autorun-off';
  const text = S.autorun ? '\u25b6' : '\u2016';
  if (btn) { btn.textContent = text; btn.className = cls; btn.title = S.autorun ? 'reactive mode \u2014 cells auto-run on edit' : 'manual mode \u2014 only Run All or Ctrl+Enter'; }
  if (btnMobile) { btnMobile.textContent = text; btnMobile.className = cls; }
  const sel = $('#setExecMode');
  if (sel) sel.value = mode;
}

function applyRunOnLoad(val) {
  _runOnLoad = val;
  const sel = $('#setRunOnLoad');
  if (sel) sel.value = val;
}

function applyShowToggle(val) {
  _showToggle = val;
  document.documentElement.classList.toggle('hide-run-toggle', val === 'no');
  const sel = $('#setShowToggle');
  if (sel) sel.value = val;
}

function applyGlobalExecMode(val) {
  if (val) lsSet('auditable-exec-mode', val);
  else lsRemove('auditable-exec-mode');
}

function applyGlobalRunOnLoad(val) {
  if (val) lsSet('auditable-run-on-load', val);
  else lsRemove('auditable-run-on-load');
}

function resolveExecMode() {
  return lsGet('auditable-exec-mode')
    || $('#setExecMode')?.value
    || __AUDITABLE_DEFAULT_EXEC_MODE__;
}

function resolveRunOnLoad() {
  return lsGet('auditable-run-on-load')
    || _runOnLoad
    || __AUDITABLE_DEFAULT_RUN_ON_LOAD__;
}

function getSettings() {
  const s = {
    theme: document.documentElement.classList.contains('light') ? 'light' : 'dark',
    fontSize: parseInt($('#setFontSize').value),
    width: $('#setWidth').value,
    header: $('#setHeader').value,
    lineNumbers: document.documentElement.classList.contains('hide-line-numbers') ? 'off' : 'on',
    execMode: S.autorun ? 'reactive' : 'manual',
    runOnLoad: _runOnLoad,
    showToggle: _showToggle,
  };
  if (window._sizeCompare) s.sizeCompare = true;
  if (window._sizeCompareRef === 'content') s.sizeCompareRef = 'content';
  return s;
}

function applySettings(s) {
  if (!s) return;
  if (s.theme) applyTheme(s.theme);
  if (s.fontSize) applyFontSize(s.fontSize);
  if (s.width) applyWidth(s.width);
  if (s.header) applyHeader(s.header);
  if (s.lineNumbers) applyLineNumbers(s.lineNumbers);
  if (s.execMode) applyExecMode(s.execMode);
  if (s.runOnLoad) applyRunOnLoad(s.runOnLoad);
  if (s.showToggle) applyShowToggle(s.showToggle);
  // optional: size-compare.js (typeof guards for --lean builds without it)
  if (s.sizeCompare !== undefined && typeof applySizeCompare === 'function') applySizeCompare(s.sizeCompare);
  if (s.sizeCompareRef !== undefined && typeof applySizeCompareRef === 'function') applySizeCompareRef(s.sizeCompareRef);
}

function togglePresent() {
  document.body.classList.toggle('presenting');
}

// ── ABOUT ──

const __AUDITABLE_VERSION__ = '0.3.0';
const __AUDITABLE_RELEASE__ = 'dev';
const __AUDITABLE_BUILD_DATE__ = '2026-02-23';
const __AUDITABLE_BASE_SIZE__ = 250774;

(function() {
  const ver = $('#aboutVersion');
  const build = $('#aboutBuild');
  const rt = $('#aboutRuntime');
  if (ver) ver.textContent = 'auditable v' + __AUDITABLE_VERSION__;
  if (build) build.textContent = (__AUDITABLE_RELEASE__ !== 'dev' ? __AUDITABLE_RELEASE__ + ' \u00b7 ' : '') + 'built ' + __AUDITABLE_BUILD_DATE__;
  if (rt && __AUDITABLE_BASE_SIZE__ > 0) rt.textContent = 'runtime ' + (__AUDITABLE_BASE_SIZE__ / 1024).toFixed(1) + ' KB';
})();

// ── EXECUTION SETTINGS INIT ──

(function() {
  const gm = lsGet('auditable-exec-mode') || '';
  const gr = lsGet('auditable-run-on-load') || '';
  const selGm = $('#setGlobalExecMode');
  const selGr = $('#setGlobalRunOnLoad');
  if (selGm) selGm.value = gm;
  if (selGr) selGr.value = gr;
})();

// ── MODULE MANAGEMENT ──

function formatSize(bytes) {
  return (bytes / 1024).toFixed(1) + ' KB';
}

function renderEntryRow(url, entry) {
  const src = typeof entry === 'string' ? entry : entry.source;
  const cellId = typeof entry === 'string' ? null : entry.cellId;
  const isBinary = typeof entry === 'object' && entry.binary;
  const size = src ? src.length : 0;
  const displaySize = isBinary ? Math.floor(size * 3 / 4) : size;

  const row = document.createElement('div');
  row.className = 'module-row';

  const urlSpan = document.createElement('span');
  urlSpan.className = 'module-url';
  urlSpan.textContent = url;
  urlSpan.title = url;
  row.appendChild(urlSpan);

  const info = document.createElement('span');
  info.className = 'module-info';
  info.textContent = (cellId != null ? 'cell ' + cellId + '  ' : '')
    + (isBinary && entry.compressed ? 'gzipped  ' : '')
    + formatSize(displaySize);
  row.appendChild(info);

  const btn = document.createElement('button');
  btn.className = 'module-remove';
  btn.textContent = '\u00d7';
  btn.title = isBinary ? 'remove binary' : 'remove module';
  btn.onclick = () => removeModule(url);
  row.appendChild(btn);

  return { row, size };
}

function renderSection(list, urls, mods, emptyText) {
  list.innerHTML = '';
  if (urls.length === 0) {
    const empty = document.createElement('div');
    empty.className = 'module-empty';
    empty.textContent = emptyText;
    list.appendChild(empty);
    return 0;
  }
  let totalSize = 0;
  for (const url of urls) {
    const { row, size } = renderEntryRow(url, mods[url]);
    list.appendChild(row);
    totalSize += size;
  }
  const total = document.createElement('div');
  total.className = 'module-total';
  total.textContent = 'total  ' + formatSize(totalSize);
  list.appendChild(total);
  return totalSize;
}

function refreshModuleList() {
  const modList = $('#moduleList');
  const binList = $('#binaryList');
  if (!modList) return;

  const mods = window._installedModules || {};
  const modUrls = [];
  const binUrls = [];
  for (const url of Object.keys(mods)) {
    const entry = mods[url];
    if (typeof entry === 'object' && entry.binary) binUrls.push(url);
    else modUrls.push(url);
  }

  renderSection(modList, modUrls, mods, 'no modules installed');
  if (binList) renderSection(binList, binUrls, mods, 'no binaries installed');
}

function removeModule(url) {
  const entry = window._installedModules?.[url];
  const cellId = entry && typeof entry === 'object' ? entry.cellId : null;
  const kind = entry?.binary ? 'binary' : 'module';
  if (window._installedModules) delete window._installedModules[url];
  if (window._importCache) delete window._importCache[url];
  refreshModuleList();
  updateStatus();
  if (cellId != null) {
    setMsg(`removed ${kind} \u2014 cell ${cellId} will re-install it on next run`, 'warn');
  }
}

// -- update.js --

// ── UPDATE PANEL ──

function toggleUpdate() {
  const overlay = $('#updateOverlay');
  const panel = $('#updatePanel');
  const open = !overlay.classList.contains('visible');
  overlay.classList.toggle('visible');
  panel.style.display = open ? 'block' : 'none';
}

// ── SELF-UPDATE SYSTEM ──

const __AUDITABLE_PUBLIC_KEY__ = '';
const __AUDITABLE_REPO__ = 'endarthur/auditable';
const __AUDITABLE_PAGES_URL__ = 'https://endarthur.github.io/auditable';

// ── SIGNATURE EXTRACTION ──

function extractSignature(html) {
  const m = html.match(/<!--AUDITABLE-SIGNATURE\n([\s\S]*?)\nAUDITABLE-SIGNATURE-->/);
  if (!m) return null;
  try { return JSON.parse(m[1]); } catch { return null; }
}

// ── RUNTIME EXTRACTION ──

function extractRuntime(html) {
  const style = html.match(/<style>([\s\S]*?)<\/style>/);
  const script = html.match(/<script>([\s\S]*?)<\/script>/);
  if (!style || !script) return null;
  return { style: style[1], script: script[1] };
}

// ── DATA EXTRACTION ──

function extractData(html) {
  const data = html.match(/<!--AUDITABLE-DATA\n([\s\S]*?)\nAUDITABLE-DATA-->/);
  const settings = html.match(/<!--AUDITABLE-SETTINGS\n([\s\S]*?)\nAUDITABLE-SETTINGS-->/);
  const modules = html.match(/<!--AUDITABLE-MODULES\n([\s\S]*?)\nAUDITABLE-MODULES-->/);
  const title = html.match(/<title>([^<]*)<\/title>/);
  return {
    data: data ? data[0] : null,
    settings: settings ? settings[0] : null,
    modules: modules ? modules[0] : null,
    title: title ? title[1].replace(/^Auditable\s*\u2014\s*/, '') : 'untitled',
  };
}

// ── SIGNED CONTENT CONSTRUCTION ──

function buildSignedContent(style, script) {
  return 'AUDITABLE-SIGNED-CONTENT\n'
    + style + '\n'
    + 'AUDITABLE-STYLE-SCRIPT-BOUNDARY\n'
    + script;
}

// ── SIGNATURE VERIFICATION (Web Crypto) ──

async function verifySignature(html) {
  const sig = extractSignature(html);
  if (!sig) return { status: 'unsigned' };

  const pubKeyB64 = __AUDITABLE_PUBLIC_KEY__;
  if (!pubKeyB64) return { status: 'no-key', sig };

  // Check if the signature's public key matches ours
  if (sig.pub !== pubKeyB64) return { status: 'wrong-key', sig };

  const runtime = extractRuntime(html);
  if (!runtime) return { status: 'error', message: 'could not extract runtime' };

  const content = buildSignedContent(runtime.style, runtime.script);

  try {
    const pubBytes = Uint8Array.from(atob(pubKeyB64), c => c.charCodeAt(0));
    const key = await crypto.subtle.importKey(
      'raw', pubBytes, { name: 'Ed25519' }, false, ['verify']
    );
    const sigBytes = Uint8Array.from(atob(sig.sig), c => c.charCodeAt(0));
    const msgBytes = new TextEncoder().encode(content);
    const valid = await crypto.subtle.verify('Ed25519', key, sigBytes, msgBytes);
    return { status: valid ? 'valid' : 'invalid', sig };
  } catch (e) {
    if (e.name === 'NotSupportedError') {
      return { status: 'unsupported', message: 'browser does not support Ed25519 verification' };
    }
    return { status: 'error', message: e.message };
  }
}

// ── REASSEMBLE ──

function reassemble(newHtml, oldData) {
  let html = newHtml;

  // Remove any existing data/settings/modules comments (and their description comments) from the new template
  html = html.replace(/(?:<!-- [^\n]*-->\n)?<!--AUDITABLE-DATA\n[\s\S]*?\nAUDITABLE-DATA-->\n?/g, '');
  html = html.replace(/(?:<!-- [^\n]*-->\n)?<!--AUDITABLE-SETTINGS\n[\s\S]*?\nAUDITABLE-SETTINGS-->\n?/g, '');
  html = html.replace(/(?:<!-- [^\n]*-->\n)?<!--AUDITABLE-MODULES\n[\s\S]*?\nAUDITABLE-MODULES-->\n?/g, '');

  // Build data block to inject
  const parts = [];
  if (oldData.data) parts.push(oldData.data);
  if (oldData.modules) parts.push(oldData.modules);
  if (oldData.settings) parts.push(oldData.settings);
  const dataBlock = parts.length ? '\n' + parts.join('\n') + '\n' : '';

  // Inject before the signature comment or before <script>
  const sigIdx = html.indexOf('<!--AUDITABLE-SIGNATURE');
  const scriptIdx = html.indexOf('<script>');
  const insertIdx = sigIdx >= 0 ? sigIdx : scriptIdx;
  if (insertIdx >= 0) {
    html = html.slice(0, insertIdx) + dataBlock + html.slice(insertIdx);
  }

  // Update title
  if (oldData.title && oldData.title !== 'untitled') {
    html = html.replace(/<title>[^<]*<\/title>/, '<title>Auditable \u2014 ' + escHtml(oldData.title) + '</title>');
    // Also update the docTitle input value
    html = html.replace(/(<input[^>]*id="docTitle"[^>]*value=")[^"]*"/, '$1' + escHtml(oldData.title) + '"');
  }

  return html;
}

function escHtml(s) {
  return s.replace(/&/g, '&amp;').replace(/"/g, '&quot;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
}

// ── VERSION COMPARISON ──

function compareVersions(a, b) {
  // compare semver strings like "0.1.0" vs "0.2.0"
  const pa = a.replace(/^v/, '').split('.').map(Number);
  const pb = b.replace(/^v/, '').split('.').map(Number);
  for (let i = 0; i < Math.max(pa.length, pb.length); i++) {
    const na = pa[i] || 0, nb = pb[i] || 0;
    if (na < nb) return -1;
    if (na > nb) return 1;
  }
  return 0;
}

// ── TOOLBAR BADGES ──

function setBadge(id, label, cls) {
  const container = $('#toolbarBadges');
  if (!container) return;
  let el = container.querySelector('[data-badge="' + id + '"]');
  if (!label) {
    if (el) el.remove();
    return;
  }
  if (!el) {
    el = document.createElement('span');
    el.className = 'toolbar-badge toolbar-badge-' + id;
    el.setAttribute('data-badge', id);
    container.appendChild(el);
  }
  el.textContent = label;
  if (cls) el.className = 'toolbar-badge ' + cls;
}

// ── UPDATE STATUS UI ──

function setUpdateStatus(html, cls) {
  const el = $('#updateStatus');
  if (el) {
    el.innerHTML = html;
    el.className = 'update-status' + (cls ? ' update-' + cls : '');
  }
}

// ── CHECK FOR UPDATE (GitHub API) ──

async function checkForUpdate() {
  const btn = $('#updateCheckBtn');
  if (btn) btn.disabled = true;
  setUpdateStatus('checking...', '');

  try {
    // Fetch version.json from GitHub Pages (CORS-friendly)
    const vResp = await fetch(__AUDITABLE_PAGES_URL__ + '/version.json');
    if (!vResp.ok) throw new Error('version check failed: ' + vResp.status);
    const vData = await vResp.json();
    const remoteVersion = vData.version || '';
    const currentRelease = $('#updateRelease')?.textContent || 'dev';

    if (currentRelease === 'dev') {
      // Dev builds always offer the latest release
    } else if (compareVersions(currentRelease, remoteVersion) >= 0) {
      setUpdateStatus('up to date (' + currentRelease + ')', 'ok');
      if (btn) btn.disabled = false;
      return;
    }

    const notes = vData.notes || '';
    const notesHtml = notes
      ? '<div class="update-notes">' + renderMd(notes) + '</div>'
      : '';

    setUpdateStatus(
      '<strong>' + remoteVersion + '</strong> available'
      + notesHtml
      + '<button id="updateApplyBtn" onclick="applyOnlineUpdate()">update</button>',
      'available'
    );

    window._updateVersion = remoteVersion;
  } catch (e) {
    setUpdateStatus('error: ' + escHtml(e.message), 'err');
  }
  if (btn) btn.disabled = false;
}

// ── APPLY ONLINE UPDATE ──

async function applyOnlineUpdate() {
  setUpdateStatus('downloading...', '');

  try {
    // Download signed build from GitHub Pages (CORS-friendly)
    const resp = await fetch(__AUDITABLE_PAGES_URL__ + '/auditable.html');
    if (!resp.ok) throw new Error('download failed: ' + resp.status);
    const newHtml = await resp.text();
    await applyUpdate(newHtml, window._updateVersion);
  } catch (e) {
    setUpdateStatus('error: ' + escHtml(e.message), 'err');
  }
}

// ── APPLY UPDATE (verify + reassemble + download) ──

async function applyUpdate(newHtml, version) {
  setUpdateStatus('verifying signature...', '');

  const result = await verifySignature(newHtml);

  if (result.status === 'invalid') {
    setUpdateStatus('signature verification FAILED \u2014 update rejected', 'err');
    return;
  }

  const warnMessages = {
    'unsigned': 'this file is not signed',
    'no-key': 'no public key configured \u2014 cannot verify signature',
    'wrong-key': 'signed with an unknown key',
  };
  if (warnMessages[result.status]) {
    setUpdateStatus(
      'warning: ' + warnMessages[result.status]
      + '<div class="update-confirm">'
      + '<button onclick="proceedUpdate()">proceed anyway</button>'
      + '<button onclick="cancelUpdate()">cancel</button>'
      + '</div>',
      'warn'
    );
    window._pendingUpdateHtml = newHtml;
    window._pendingUpdateVersion = version;
    return;
  }

  if (result.status === 'unsupported') {
    setUpdateStatus(
      result.message
      + '<div class="update-confirm">'
      + '<button onclick="proceedUpdate()">proceed without verification</button>'
      + '<button onclick="cancelUpdate()">cancel</button>'
      + '</div>',
      'warn'
    );
    window._pendingUpdateHtml = newHtml;
    window._pendingUpdateVersion = version;
    return;
  }

  if (result.status === 'error') {
    setUpdateStatus('verification error: ' + escHtml(result.message), 'err');
    return;
  }

  // Valid signature — proceed
  finishUpdate(newHtml, version);
}

function proceedUpdate() {
  if (window._pendingUpdateHtml) {
    finishUpdate(window._pendingUpdateHtml, window._pendingUpdateVersion);
    delete window._pendingUpdateHtml;
    delete window._pendingUpdateVersion;
  }
}

function cancelUpdate() {
  delete window._pendingUpdateHtml;
  delete window._pendingUpdateVersion;
  setUpdateStatus('update cancelled', '');
}

function finishUpdate(newHtml, version) {
  setUpdateStatus('reassembling...', '');

  // Extract current document as HTML to get data comments
  const currentHtml = document.documentElement.outerHTML;
  // But the data comments are in the body innerHTML at load time; grab from live source
  const bodyHtml = document.body.innerHTML;
  const fullHtml = '<!DOCTYPE html>\n<html>' + document.head.outerHTML + '<body>' + bodyHtml + '</body></html>';

  const oldData = extractData(fullHtml);
  // Override title from live doc
  const titleInput = $('#docTitle');
  if (titleInput) oldData.title = titleInput.value || 'untitled';

  // Build fresh data comments from live state (more reliable than regex from DOM)
  if (S.cells.length) {
    const cellData = S.cells.map(c => ({
      type: c.type,
      code: c.code,
      collapsed: c.el?.classList.contains('collapsed') || undefined
    }));
    oldData.data = '<!-- cell data: JSON array of {type, code, collapsed?} -->\n<!--AUDITABLE-DATA\n' + JSON.stringify(cellData) + '\nAUDITABLE-DATA-->';
  }
  if (window._installedModules && Object.keys(window._installedModules).length) {
    oldData.modules = '<!-- installed modules: base64-encoded JSON mapping URLs to {source, cellId} -->\n<!--AUDITABLE-MODULES\n' + encodeModules(window._installedModules) + '\nAUDITABLE-MODULES-->';
  }
  oldData.settings = '<!-- notebook settings: JSON {theme, fontSize, width, ...} -->\n<!--AUDITABLE-SETTINGS\n' + JSON.stringify(getSettings()) + '\nAUDITABLE-SETTINGS-->';

  const result = reassemble(newHtml, oldData);

  // Offer as download
  const title = (titleInput ? titleInput.value : 'untitled') || 'untitled';
  const blob = new Blob([result], { type: 'text/html' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = title.replace(/[^a-zA-Z0-9_-]/g, '_') + '.html';
  a.click();
  URL.revokeObjectURL(url);

  const vLabel = version ? ' to ' + version : '';
  setUpdateStatus('updated' + vLabel + ' \u2014 saved as ' + a.download, 'ok');
  setMsg('updated' + vLabel, 'ok');
}

// ── UPDATE FROM FILE ──

function updateFromFile() {
  const input = document.createElement('input');
  input.type = 'file';
  input.accept = '.html';
  input.onchange = async () => {
    const file = input.files[0];
    if (!file) return;
    setUpdateStatus('reading file...', '');
    const text = await file.text();

    // Try to extract version from the file
    const vMatch = text.match(/__AUDITABLE_VERSION__\s*=\s*'([^']+)'/);
    const version = vMatch ? 'v' + vMatch[1] : null;

    await applyUpdate(text, version);
  };
  input.click();
}

// ── VERIFY CURRENT DOCUMENT ──

async function verifySelf() {
  const el = $('#updateSigStatus');
  if (!el) return;

  // Reconstruct from live DOM
  const styleEl = document.querySelector('style');
  const scriptEl = document.querySelector('script');
  if (!styleEl || !scriptEl) {
    el.textContent = 'error: no style/script';
    el.className = 'update-sig update-err';
    return;
  }

  const raw = document.body.innerHTML;
  const sigMatch = raw.match(/<!--AUDITABLE-SIGNATURE\n([\s\S]*?)\nAUDITABLE-SIGNATURE-->/);
  if (!sigMatch) {
    el.textContent = 'unsigned';
    el.className = 'update-sig update-warn';
    return;
  }

  let sig;
  try { sig = JSON.parse(sigMatch[1]); } catch {
    el.textContent = 'invalid signature format';
    el.className = 'update-sig update-err';
    return;
  }

  const pubKeyB64 = __AUDITABLE_PUBLIC_KEY__;
  if (!pubKeyB64) {
    el.textContent = 'no public key configured';
    el.className = 'update-sig update-warn';
    return;
  }

  if (sig.pub !== pubKeyB64) {
    el.textContent = 'signed with unknown key';
    el.className = 'update-sig update-warn';
    return;
  }

  const content = buildSignedContent(styleEl.textContent, scriptEl.textContent);

  try {
    const pubBytes = Uint8Array.from(atob(pubKeyB64), c => c.charCodeAt(0));
    const key = await crypto.subtle.importKey(
      'raw', pubBytes, { name: 'Ed25519' }, false, ['verify']
    );
    const sigBytes = Uint8Array.from(atob(sig.sig), c => c.charCodeAt(0));
    const msgBytes = new TextEncoder().encode(content);
    const valid = await crypto.subtle.verify('Ed25519', key, sigBytes, msgBytes);
    if (valid) {
      el.textContent = 'signed \u2713';
      el.className = 'update-sig update-ok';
      setBadge('signed', 'signed', 'toolbar-badge toolbar-badge-signed');
    } else {
      el.textContent = 'signature invalid';
      el.className = 'update-sig update-err';
    }
  } catch (e) {
    if (e.name === 'NotSupportedError') {
      el.textContent = 'Ed25519 not supported';
      el.className = 'update-sig update-warn';
    } else {
      el.textContent = 'error: ' + e.message;
      el.className = 'update-sig update-err';
    }
  }
}

// ── INIT ──
(function() {
  const ver = $('#updateCurrentVer');
  if (ver) ver.textContent = 'v' + __AUDITABLE_VERSION__;
  const rel = $('#updateRelease');
  if (rel) {
    rel.textContent = __AUDITABLE_RELEASE__;
    if (__AUDITABLE_RELEASE__ === 'dev') rel.className = 'update-sig update-warn';
  }
  // Show public key status
  const keyEl = $('#updatePubKey');
  if (keyEl) {
    if (__AUDITABLE_PUBLIC_KEY__) {
      keyEl.textContent = __AUDITABLE_PUBLIC_KEY__.slice(0, 8) + '...';
      keyEl.className = 'update-sig update-key-truncated';
      keyEl.onclick = () => {
        if (keyEl.classList.contains('update-key-expanded')) {
          keyEl.textContent = __AUDITABLE_PUBLIC_KEY__.slice(0, 8) + '...';
          keyEl.classList.remove('update-key-expanded');
          keyEl.classList.add('update-key-truncated');
        } else {
          keyEl.textContent = __AUDITABLE_PUBLIC_KEY__;
          keyEl.classList.remove('update-key-truncated');
          keyEl.classList.add('update-key-expanded');
        }
      };
    } else {
      keyEl.textContent = 'not configured';
      keyEl.className = 'update-sig update-warn';
    }
  }
  // Run self-verification on load
  verifySelf();
})();

// -- save.js --

// ── MODULES ENCODING ──
// base64-encode modules JSON to avoid HTML comment / String.replace issues
// (source code can contain --, $', etc.)

function encodeModules(obj) {
  const b64 = btoa(unescape(encodeURIComponent(JSON.stringify(obj))));
  return b64.replace(/.{1,76}/g, '$&\n').trimEnd();
}

function decodeModules(raw) {
  const b64 = raw.replace(/\s/g, '');
  // detect legacy format: starts with { means raw JSON (not base64)
  if (b64.startsWith('{') || b64.startsWith('%7B')) return JSON.parse(raw);
  return JSON.parse(decodeURIComponent(escape(atob(b64))));
}

// ── SAVE / LOAD ──

// save mode: 'normal' or 'packed'
let _saveMode = 'normal';

function getSaveMode() { return _saveMode; }

function toggleSaveTray() {
  const tray = $('#saveTray');
  if (tray) tray.classList.toggle('open');
}

function setSaveMode(mode) {
  _saveMode = mode;
  // update UI
  const label = $('#saveLabel');
  if (label) label.textContent = mode === 'packed' ? 'pack' : 'save';
  const tray = $('#saveTray');
  if (tray) tray.classList.remove('open');
  // update mobile buttons
  const mobSave = $('#mobileSaveBtn');
  const mobPack = $('#mobilePackBtn');
  if (mobSave) mobSave.classList.toggle('active-mode', mode === 'normal');
  if (mobPack) mobPack.classList.toggle('active-mode', mode === 'packed');
}

function buildNotebookHtml() {
  // serialize current state back to a self-contained HTML file
  const title = $('#docTitle').value || 'untitled';

  // collect cells as data
  const cellData = S.cells.map(c => ({
    type: c.type,
    code: c.code,
    collapsed: c.el.classList.contains('collapsed') || undefined
  }));

  // get the runtime and styles from current document
  const styleEl = document.querySelector('style');
  const styles = styleEl.textContent;

  // get the script
  const scriptEl = document.querySelector('script');
  const script = scriptEl.textContent;

  // read static elements from live DOM
  const helpHTML = $('#helpOverlay').outerHTML;
  const settingsOvHTML = $('#settingsOverlay').outerHTML;
  const settingsPanHTML = $('#settingsPanel').outerHTML.replace(/display:\s*block;?/, '');
  const updateOvHTML = $('#updateOverlay').outerHTML.replace(/\bvisible\b/, '').replace(/class="\s*"/, 'class=""');
  const updatePanEl = $('#updatePanel').cloneNode(true);
  updatePanEl.style.display = '';
  // reset update status and dynamic text
  const uStatus = updatePanEl.querySelector('#updateStatus');
  if (uStatus) { uStatus.innerHTML = ''; uStatus.className = 'update-status'; }
  const updatePanHTML = updatePanEl.outerHTML.replace(/display:\s*block;?/, '');
  const statusbarHTML = document.querySelector('.statusbar').outerHTML;

  // read toolbar from live DOM and patch the title value
  const toolbarEl = document.querySelector('.toolbar').cloneNode(true);
  toolbarEl.querySelector('#docTitle').value = title;
  toolbarEl.querySelector('#toolbarStatus').textContent = '';
  // reset autorun button state to match saved mode
  const autoBtn = toolbarEl.querySelector('#autorunBtn');
  const savedMode = S.autorun ? 'reactive' : 'manual';
  if (autoBtn) {
    autoBtn.className = savedMode === 'reactive' ? 'autorun-on' : 'autorun-off';
    autoBtn.textContent = savedMode === 'reactive' ? '\u25b6' : '\u2016';
  }
  // close overflow and save tray if open
  const overflow = toolbarEl.querySelector('.toolbar-overflow');
  if (overflow) overflow.classList.remove('open');
  const saveTray = toolbarEl.querySelector('#saveTray');
  if (saveTray) saveTray.classList.remove('open');
  // reset save label to default
  const saveLabel = toolbarEl.querySelector('#saveLabel');
  if (saveLabel) saveLabel.textContent = 'save';
  // clear badges (they get set dynamically on load)
  const badges = toolbarEl.querySelector('.toolbar-badges');
  if (badges) badges.innerHTML = '';
  const toolbarHTML = toolbarEl.outerHTML;

  // capture find bar and reset to default state
  const findBarEl = $('#findBar').cloneNode(true);
  findBarEl.style.display = '';
  findBarEl.classList.remove('show-replace');
  findBarEl.querySelector('#findInput').value = '';
  findBarEl.querySelector('#replaceInput').value = '';
  findBarEl.querySelector('#findCount').textContent = '';
  findBarEl.querySelector('#findCaseBtn').classList.remove('active');
  findBarEl.querySelector('#findRegexBtn').classList.remove('active');
  const findBarHTML = findBarEl.outerHTML;

  // build output HTML
  return `<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Auditable \u2014 ${esc(title)}</title>
<style>\n${styles}\n</style>
</head>
<body>

${helpHTML}

${settingsOvHTML}
${settingsPanHTML}

${updateOvHTML}
${updatePanHTML}

${toolbarHTML}

${findBarHTML}

<button class="present-exit" onclick="togglePresent()">\u2715 exit</button>

<div class="notebook" id="notebook">
</div>

${statusbarHTML}

${'<!-- cell data: JSON array of {type, code, collapsed?} -->\n<!--AUDITABLE-DATA\n' + JSON.stringify(cellData) + '\nAUDITABLE-DATA-->'}
${Object.keys(window._installedModules || {}).length ? '<!-- installed modules: base64-encoded JSON mapping URLs to {source, cellId} -->\n<!--AUDITABLE-MODULES\n' + encodeModules(window._installedModules) + '\nAUDITABLE-MODULES-->' : ''}
${'<!-- notebook settings: JSON {theme, fontSize, width, ...} -->\n<!--AUDITABLE-SETTINGS\n' + JSON.stringify(getSettings()) + '\nAUDITABLE-SETTINGS-->'}

<script>\n${script}\n<\/script>
</body>
</html>`;
}

function downloadHtml(html, title) {
  const blob = new Blob([html], { type: 'text/html' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = title.replace(/[^a-zA-Z0-9_-]/g, '_') + '.html';
  a.click();
  URL.revokeObjectURL(url);
  return a.download;
}

function saveNotebook() {
  if (_saveMode === 'packed') {
    savePackedNotebook();
    return;
  }
  const title = $('#docTitle').value || 'untitled';
  const html = buildNotebookHtml();

  // AF bridge: send serialized HTML to parent shell instead of downloading
  if (window.__AF_BRIDGE__) {
    window.parent.postMessage({ type: 'af:serialized', payload: { html } }, '*');
    setMsg('saved', 'ok');
    return;
  }

  const fn = downloadHtml(html, title);
  setMsg('saved ' + fn, 'ok');
}

async function savePackedNotebook() {
  const title = $('#docTitle').value || 'untitled';
  const html = buildNotebookHtml();

  try {
    // compress via CompressionStream
    const blob = new Blob([html]);
    const cs = new CompressionStream('gzip');
    const stream = blob.stream().pipeThrough(cs);
    const compressed = await new Response(stream).arrayBuffer();
    const b64 = btoa(String.fromCharCode(...new Uint8Array(compressed)));
    const b64Lines = b64.replace(/.{1,76}/g, '$&\n');

    const loader = `<!DOCTYPE html>
<!-- packed auditable notebook -->
<!-- the full notebook is gzip-compressed and base64-encoded in the <pre> block below. -->
<!-- on load, the script decodes and decompresses it, then replaces the page contents. -->
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Auditable \u2014 ${esc(title)}</title>
  <style>
    html { background: #1a1a1a }
    body { color: #999; font: 14px/1.5 monospace; display: flex; justify-content: center; align-items: center; height: 100vh; margin: 0 }
    #_d { display: none }
  </style>
</head>
<body>
<div id="_l">unpacking\u2026</div>

<!-- base64-encoded gzip payload (76-char lines) -->
<pre id="_d">
${b64Lines}</pre>

<script>
(async () => {
  // 1. read base64 from the hidden <pre>, strip whitespace from line wrapping
  var b64 = document.getElementById('_d').textContent.replace(/\\s/g, '');

  // 2. decode base64 to binary
  var bytes = Uint8Array.from(atob(b64), c => c.charCodeAt(0));

  // 3. decompress gzip via DecompressionStream
  var stream = new Response(new Blob([bytes])).body.pipeThrough(new DecompressionStream('gzip'));
  var html = await new Response(stream).text();

  // 4. mark as packed (so the notebook knows it was loaded from a packed save)
  html = html.replace('<head>', '<head><meta name="auditable-packed">');

  // 5. replace the current page with the full notebook
  document.open();
  document.write(html);
  document.close();
})().catch(function(e) {
  document.getElementById('_l').textContent = 'error: ' + e.message;
});
<\/script>
</body>
</html>`;


    const fn = downloadHtml(loader, title);
    const kb = (loader.length / 1024).toFixed(0);
    setMsg('packed ' + fn + ' (' + kb + ' KB)', 'ok');
  } catch (e) {
    setMsg('pack failed: ' + e.message, 'err');
  }
}

function esc(s) {
  return s.replace(/"/g, '&quot;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
}

function exportAsTxt() {
  const title = $('#docTitle').value || 'untitled';
  const html = buildNotebookHtml();

  // extract notebook data from HTML
  const dataMatch = html.match(/<!--AUDITABLE-DATA\n([\s\S]*?)\nAUDITABLE-DATA-->/);
  let cells = [];
  if (dataMatch) {
    try { cells = JSON.parse(dataMatch[1]); } catch {}
  }

  const setMatch = html.match(/<!--AUDITABLE-SETTINGS\n([\s\S]*?)\nAUDITABLE-SETTINGS-->/);
  let settings = {};
  if (setMatch) {
    try { settings = JSON.parse(setMatch[1]); } catch {}
  }

  // extract module URLs (without sources — standalone export just records URLs)
  const modMatch = html.match(/<!--AUDITABLE-MODULES\n([\s\S]*?)\nAUDITABLE-MODULES-->/);
  let moduleUrls = [];
  if (modMatch) {
    try {
      const decoded = decodeModules(modMatch[1]);
      moduleUrls = Object.keys(decoded);
    } catch {}
  }

  // build /// formatted text
  const lines = ['/// auditable'];
  if (title && title !== 'untitled') {
    lines.push('/// title: ' + title);
  }
  const defaultSettings = { theme: 'dark', fontSize: 13, width: '860' };
  if (JSON.stringify(settings) !== JSON.stringify(defaultSettings)) {
    lines.push('/// settings: ' + JSON.stringify(settings));
  }
  for (const url of moduleUrls) {
    lines.push('/// module: ' + url);
  }
  for (const cell of cells) {
    lines.push('');
    const flags = cell.collapsed ? ' collapsed' : '';
    lines.push('/// ' + cell.type + flags);
    lines.push(cell.code || '');
  }
  const txt = lines.join('\n') + '\n';

  // download
  if (window.__AF_BRIDGE__) {
    window.parent.postMessage({ type: 'af:download', payload: { data: txt, filename: title.replace(/[^a-zA-Z0-9_-]/g, '_') + '.txt', mime: 'text/plain' } }, '*');
  } else {
    const blob = new Blob([txt], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = title.replace(/[^a-zA-Z0-9_-]/g, '_') + '.txt';
    a.click();
    URL.revokeObjectURL(url);
  }
  setMsg('exported .txt', 'ok');
}

function loadFromEmbed() {
  // look for embedded cell data in HTML comments
  const raw = document.body.innerHTML;

  // restore installed modules first (before cells run)
  const modMatch = raw.match(/<!--AUDITABLE-MODULES\n([\s\S]*?)\nAUDITABLE-MODULES-->/);
  if (modMatch) {
    try {
      window._installedModules = decodeModules(modMatch[1]);
    } catch (e) {
      console.error('Failed to parse installed modules:', e);
    }
  }

  // restore settings
  const setMatch = raw.match(/<!--AUDITABLE-SETTINGS\n([\s\S]*?)\nAUDITABLE-SETTINGS-->/);
  if (setMatch) {
    try {
      applySettings(JSON.parse(setMatch[1]));
    } catch (e) {
      console.error('Failed to parse settings:', e);
    }
  }

  // apply execution mode priority chain (localStorage > notebook > build default)
  const effectiveMode = resolveExecMode();
  const effectiveRun = resolveRunOnLoad();
  if (effectiveMode === 'manual') {
    S.autorun = false;
    const btn = document.getElementById('autorunBtn');
    const btnMobile = document.getElementById('autorunBtnMobile');
    if (btn) { btn.className = 'autorun-off'; btn.textContent = '\u2016'; btn.title = 'manual mode \u2014 only Run All or Ctrl+Enter'; }
    if (btnMobile) { btnMobile.className = 'autorun-off'; btnMobile.textContent = '\u2016'; }
    const sel = document.getElementById('setExecMode');
    if (sel) sel.value = 'manual';
  }

  const match = raw.match(/<!--AUDITABLE-DATA\n([\s\S]*?)\nAUDITABLE-DATA-->/);
  if (match) {
    try {
      const data = JSON.parse(match[1]);
      for (const c of data) {
        const cell = addCell(c.type, c.code);
        if (c.collapsed || isCollapsed(c.code)) cell.el.classList.add('collapsed');
      }
      // run after load (gated on resolved runOnLoad)
      if (effectiveRun === 'yes' && S.cells.some(c => c.type === 'code')) {
        setTimeout(runAll, 50);
      }
      return true;
    } catch (e) {
      console.error('Failed to parse embedded data:', e);
    }
  }
  return false;
}

// -- ui.js --

// ── STATUS ──

function estimateContentSize() {
  let modules = 0;
  for (const v of Object.values(window._installedModules || {})) {
    modules += typeof v === 'string' ? v.length : (v.source?.length || 0);
  }
  const cells = JSON.stringify(S.cells.map(c => ({ type: c.type, code: c.code }))).length;
  return modules + cells;
}

function estimateFileSize() {
  const style = document.querySelector('style')?.textContent.length || 0;
  const script = document.querySelector('script')?.textContent.length || 0;
  return style + script + estimateContentSize() + 2000; // ~2KB HTML boilerplate
}

function updateStatus() {
  const counts = { code: 0, md: 0, css: 0, html: 0 };
  for (const c of S.cells) if (counts[c.type] !== undefined) counts[c.type]++;
  const parts = [];
  for (const [t, n] of Object.entries(counts)) if (n > 0) parts.push(`${n} ${t}`);
  const statusText = parts.join(' \u00b7 ') || '0 cells';
  const totalBytes = estimateFileSize();
  const contentBytes = estimateContentSize();
  const useContent = window._sizeCompareRef === 'content';
  const displayBytes = useContent ? contentBytes : totalBytes;
  const sizeKB = displayBytes >= 1024 ? Math.round(displayBytes / 1024) : 1;
  const sizeText = '~' + sizeKB + ' KB' + (useContent ? ' content' : '');
  $('#statusCells').textContent = statusText;
  const compare = typeof sizeCompare === 'function' ? sizeCompare(displayBytes) : '';
  const sizeEl = document.getElementById('statusSize');
  if (sizeEl) sizeEl.textContent = (compare ? sizeText + ' \u00b7 ' + compare : sizeText) + ' \u00b7 ';
  // mirror to toolbar for mobile
  const toolbarStatus = document.getElementById('toolbarStatus');
  if (toolbarStatus) toolbarStatus.textContent = (compare || sizeText) + ' \u00b7 ' + statusText;
  updateInsertBars();
}

function updateInsertBars() {
  const nb = $('#notebook');
  // remove existing insert bars
  nb.querySelectorAll('.insert-bar').forEach(b => b.remove());

  // add one before first cell and between each pair
  for (let i = 0; i <= S.cells.length; i++) {
    const bar = document.createElement('div');
    bar.className = 'insert-bar';
    const afterId = i > 0 ? S.cells[i - 1].id : null;
    bar.innerHTML = `<div class="insert-btns">
      <button onclick="insertAt(${afterId},'code')">+ code</button>
      <button onclick="insertAt(${afterId},'md')">+ md</button>
      <button onclick="insertAt(${afterId},'css')">+ css</button>
      <button onclick="insertAt(${afterId},'html')">+ html</button>
    </div>`;
    if (i < S.cells.length) {
      S.cells[i].el.before(bar);
    } else {
      nb.appendChild(bar);
    }
  }
}

function insertAt(afterId, type) {
  let cell;
  if (afterId === null && S.cells.length > 0) {
    // insert before first cell
    cell = addCellWithUndo(type, '', null, S.cells[0].id);
  } else {
    cell = addCellWithUndo(type, '', afterId);
  }
  selectCell(cell.id);
  editCell(cell.id);
}

function setMsg(msg, cls = '') {
  const el = $('#statusMsg');
  el.textContent = msg;
  el.className = 'status-msg' + (cls ? ' ' + cls : '');
  if (cls) setTimeout(() => { el.textContent = ''; el.className = 'status-msg'; }, 3000);
}

// -- find.js --

// ── FIND / REPLACE ──

function openFind(showReplace) {
  const bar = $('#findBar');
  bar.style.display = 'flex';
  S.findActive = true;
  if (showReplace) bar.classList.add('show-replace');
  else bar.classList.remove('show-replace');
  const inp = $('#findInput');
  // pre-fill from textarea selection
  const active = document.activeElement;
  if (active && active.tagName === 'TEXTAREA') {
    const sel = active.value.substring(active.selectionStart, active.selectionEnd);
    if (sel && sel.indexOf('\n') === -1) inp.value = sel;
  }
  inp.focus();
  inp.select();
  if (inp.value) findComputeMatches();
}

function closeFind() {
  const bar = $('#findBar');
  bar.style.display = '';
  bar.classList.remove('show-replace');
  S.findActive = false;
  S.findQuery = '';
  S.findMatches = [];
  S.findCurrent = -1;
  $('#findCount').textContent = '';
  // remove all overlays
  document.querySelectorAll('.search-overlay').forEach(el => el.remove());
  document.querySelectorAll('.md-search-wrap').forEach(wrap => {
    const ta = wrap.querySelector('textarea');
    if (ta) wrap.parentNode.insertBefore(ta, wrap);
    wrap.remove();
  });
}

function escapeRegex(s) {
  return s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

function findComputeMatches() {
  const query = $('#findInput').value;
  S.findQuery = query;
  S.findMatches = [];
  if (!query) {
    S.findCurrent = -1;
    findUpdateCount();
    document.querySelectorAll('.search-overlay').forEach(el => el.remove());
    document.querySelectorAll('.md-search-wrap').forEach(wrap => {
      const ta = wrap.querySelector('textarea');
      if (ta) wrap.parentNode.insertBefore(ta, wrap);
      wrap.remove();
    });
    return;
  }
  const flags = S.findCase ? 'g' : 'gi';
  const pattern = S.findRegex ? query : escapeRegex(query);
  let re;
  try { re = new RegExp(pattern, flags); }
  catch (e) {
    S.findCurrent = -1;
    $('#findCount').textContent = 'bad regex';
    return;
  }

  for (const cell of S.cells) {
    let m;
    re.lastIndex = 0;
    while ((m = re.exec(cell.code)) !== null) {
      S.findMatches.push({ cellId: cell.id, index: m.index, length: m[0].length });
      if (m[0].length === 0) re.lastIndex++;  // prevent infinite loop on zero-length match
    }
  }
  // keep findCurrent in range
  if (S.findMatches.length === 0) S.findCurrent = -1;
  else if (S.findCurrent < 0 || S.findCurrent >= S.findMatches.length) S.findCurrent = 0;
  findUpdateOverlays();
  findUpdateCount();
}

function findNext() {
  if (!S.findMatches.length) return;
  S.findCurrent = (S.findCurrent + 1) % S.findMatches.length;
  findUpdateOverlays();
  findUpdateCount();
  findScrollToMatch();
}

function findPrev() {
  if (!S.findMatches.length) return;
  S.findCurrent = (S.findCurrent - 1 + S.findMatches.length) % S.findMatches.length;
  findUpdateOverlays();
  findUpdateCount();
  findScrollToMatch();
}

function findReplace() {
  if (S.findCurrent < 0 || S.findCurrent >= S.findMatches.length) return;
  const match = S.findMatches[S.findCurrent];
  const cell = S.cells.find(c => c.id === match.cellId);
  if (!cell) return;
  const replaceVal = $('#replaceInput').value;
  if (S.findRegex) {
    const flags = S.findCase ? '' : 'i';
    try {
      const re = new RegExp(S.findQuery, flags);
      const matched = cell.code.substring(match.index, match.index + match.length);
      const replaced = matched.replace(re, replaceVal);
      cell.code = cell.code.substring(0, match.index) + replaced + cell.code.substring(match.index + match.length);
    } catch (e) { return; }
  } else {
    cell.code = cell.code.substring(0, match.index) + replaceVal + cell.code.substring(match.index + match.length);
  }
  // update textarea
  const ta = cell.el.querySelector('textarea');
  if (ta) {
    ta.value = cell.code;
    ta.dispatchEvent(new Event('input'));
  }
  findComputeMatches();
}

function findReplaceAll() {
  const query = S.findQuery;
  if (!query) return;
  const replaceVal = $('#replaceInput').value;
  const flags = S.findCase ? 'g' : 'gi';
  const pattern = S.findRegex ? query : escapeRegex(query);
  let re;
  try { re = new RegExp(pattern, flags); }
  catch (e) { return; }
  let count = 0;
  for (const cell of S.cells) {
    const before = cell.code;
    if (S.findRegex) {
      cell.code = cell.code.replace(re, (...args) => { count++; return replaceVal.replace(/\$(\d+)/g, (_, n) => args[+n] != null ? args[+n] : ''); });
    } else {
      cell.code = cell.code.replace(re, () => { count++; return replaceVal; });
    }
    if (cell.code !== before) {
      const ta = cell.el.querySelector('textarea');
      if (ta) {
        ta.value = cell.code;
        ta.dispatchEvent(new Event('input'));
      }
    }
  }
  findComputeMatches();
}

function findUpdateOverlays() {
  // remove existing overlays
  document.querySelectorAll('.search-overlay').forEach(el => el.remove());
  // unwrap md-search-wraps
  document.querySelectorAll('.md-search-wrap').forEach(wrap => {
    const ta = wrap.querySelector('textarea');
    if (ta) wrap.parentNode.insertBefore(ta, wrap);
    wrap.remove();
  });

  if (!S.findQuery || !S.findMatches.length) return;

  // group matches by cellId
  const byCell = {};
  S.findMatches.forEach((m, i) => {
    if (!byCell[m.cellId]) byCell[m.cellId] = [];
    byCell[m.cellId].push({ ...m, globalIdx: i });
  });

  for (const cellId of Object.keys(byCell)) {
    const cell = S.cells.find(c => c.id === parseInt(cellId));
    if (!cell) continue;
    const matches = byCell[cellId];
    const code = cell.code;

    // build overlay content
    let html = '';
    let pos = 0;
    for (const m of matches) {
      // text before match
      html += escHtml(code.substring(pos, m.index));
      const cls = m.globalIdx === S.findCurrent ? 'search-match search-match-current' : 'search-match';
      html += `<mark class="${cls}">${escHtml(code.substring(m.index, m.index + m.length))}</mark>`;
      pos = m.index + m.length;
    }
    html += escHtml(code.substring(pos));

    const overlay = document.createElement('div');

    if (cell.type === 'md') {
      // markdown cells: wrap textarea in md-search-wrap
      overlay.className = 'search-overlay search-overlay-md';
      overlay.innerHTML = html;
      const editWrap = cell.el.querySelector('.cell-md-edit');
      const ta = editWrap.querySelector('textarea');
      let wrap = editWrap.querySelector('.md-search-wrap');
      if (!wrap) {
        wrap = document.createElement('div');
        wrap.className = 'md-search-wrap';
        ta.parentNode.insertBefore(wrap, ta);
        wrap.appendChild(ta);
      }
      wrap.appendChild(overlay);
      wireScrollSync(ta, overlay);
    } else {
      // code, css, html cells: insert in editor-wrap
      overlay.className = 'search-overlay';
      overlay.innerHTML = html;
      let editorWrap;
      if (cell.type === 'code') editorWrap = cell.el.querySelector('.cell-code .editor-wrap');
      else if (cell.type === 'css') editorWrap = cell.el.querySelector('.cell-css-edit .editor-wrap');
      else if (cell.type === 'html') editorWrap = cell.el.querySelector('.cell-html-edit .editor-wrap');
      if (editorWrap) {
        editorWrap.appendChild(overlay);
        const ta = editorWrap.querySelector('textarea');
        if (ta) wireScrollSync(ta, overlay);
      }
    }
  }
}

function wireScrollSync(ta, overlay) {
  if (ta._searchScrollWired) return;
  ta._searchScrollWired = true;
  ta.addEventListener('scroll', () => {
    const ov = ta.closest('.editor-wrap, .md-search-wrap');
    if (!ov) return;
    const so = ov.querySelector('.search-overlay');
    if (so) {
      so.scrollTop = ta.scrollTop;
      so.scrollLeft = ta.scrollLeft;
    }
  });
}

function findUpdateCount() {
  const el = $('#findCount');
  if (!S.findQuery) { el.textContent = ''; return; }
  if (S.findMatches.length === 0) { el.textContent = 'no results'; return; }
  el.textContent = `${S.findCurrent + 1}/${S.findMatches.length}`;
}

function findScrollToMatch() {
  if (S.findCurrent < 0) return;
  const match = S.findMatches[S.findCurrent];
  if (!match) return;
  const cell = S.cells.find(c => c.id === match.cellId);
  if (!cell) return;

  // open editor for non-code cells if needed
  if (cell.type === 'css') {
    const editWrap = cell.el.querySelector('.cell-css-edit');
    const view = cell.el.querySelector('.cell-css-view');
    if (editWrap.style.display === 'none') {
      const ta = editWrap.querySelector('textarea');
      editWrap.style.display = '';
      view.style.display = 'none';
      ta.value = cell.code;
      autoResize({ target: ta });
    }
  } else if (cell.type === 'html') {
    const editWrap = cell.el.querySelector('.cell-html-edit');
    const view = cell.el.querySelector('.cell-html-view');
    if (editWrap.style.display === 'none') {
      const ta = editWrap.querySelector('textarea');
      editWrap.style.display = '';
      view.style.display = 'none';
      ta.value = cell.code;
      autoResize({ target: ta });
    }
  } else if (cell.type === 'md') {
    const editWrap = cell.el.querySelector('.cell-md-edit');
    const view = cell.el.querySelector('.cell-md-view');
    if (editWrap.style.display === 'none') {
      const ta = editWrap.querySelector('textarea');
      editWrap.style.display = '';
      view.style.display = 'none';
      ta.value = cell.code;
      autoResize({ target: ta });
    }
  }

  // uncollapse if collapsed
  cell.el.classList.remove('collapsed');

  // scroll cell into view
  cell.el.scrollIntoView({ block: 'nearest', behavior: 'smooth' });

  // scroll textarea to match line
  const ta = cell.type === 'md'
    ? cell.el.querySelector('.cell-md-edit textarea')
    : cell.type === 'css'
    ? cell.el.querySelector('.cell-css-edit textarea')
    : cell.type === 'html'
    ? cell.el.querySelector('.cell-html-edit textarea')
    : cell.el.querySelector('textarea');
  if (ta) {
    const textBefore = cell.code.substring(0, match.index);
    const lineNum = textBefore.split('\n').length - 1;
    const lineHeight = parseFloat(getComputedStyle(ta).lineHeight) || 20;
    ta.scrollTop = Math.max(0, lineNum * lineHeight - ta.clientHeight / 2);
  }
}

function escHtml(s) {
  return s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
}

// ── EVENT WIRING ──
(function () {
  const findInput = $('#findInput');
  const replaceInput = $('#replaceInput');
  if (!findInput) return;

  findInput.addEventListener('input', () => findComputeMatches());

  findInput.addEventListener('keydown', (e) => {
    if (e.key === 'Enter' && e.shiftKey) { e.preventDefault(); findPrev(); }
    else if (e.key === 'Enter') { e.preventDefault(); findNext(); }
    else if (e.key === 'Escape') { e.preventDefault(); closeFind(); }
  });

  if (replaceInput) {
    replaceInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') { e.preventDefault(); findReplace(); }
      else if (e.key === 'Escape') { e.preventDefault(); closeFind(); }
    });
  }

  const nextBtn = $('#findNextBtn');
  const prevBtn = $('#findPrevBtn');
  const replBtn = $('#findReplaceBtn');
  const replAllBtn = $('#findReplaceAllBtn');
  const caseBtn = $('#findCaseBtn');
  const regexBtn = $('#findRegexBtn');
  const closeBtn = $('#findCloseBtn');

  if (nextBtn) nextBtn.addEventListener('click', findNext);
  if (prevBtn) prevBtn.addEventListener('click', findPrev);
  if (replBtn) replBtn.addEventListener('click', findReplace);
  if (replAllBtn) replAllBtn.addEventListener('click', findReplaceAll);
  if (closeBtn) closeBtn.addEventListener('click', closeFind);
  if (caseBtn) caseBtn.addEventListener('click', () => {
    S.findCase = !S.findCase;
    caseBtn.classList.toggle('active', S.findCase);
    findComputeMatches();
  });
  if (regexBtn) regexBtn.addEventListener('click', () => {
    S.findRegex = !S.findRegex;
    regexBtn.classList.toggle('active', S.findRegex);
    findComputeMatches();
  });

  // live recompute on edit — delegation
  let recomputeTimer = null;
  document.getElementById('notebook').addEventListener('input', (e) => {
    if (!S.findActive) return;
    if (e.target.tagName !== 'TEXTAREA') return;
    clearTimeout(recomputeTimer);
    recomputeTimer = setTimeout(findComputeMatches, 150);
  });
})();

// -- complete.js --

// ── AUTOCOMPLETE ENGINE ──

// well-known property lists for dot completion on builtins
const KNOWN_PROPS = {
  Math: ['abs','acos','asin','atan','atan2','ceil','cos','exp','floor','hypot',
         'log','log2','log10','max','min','pow','random','round','sign','sin',
         'sqrt','tan','trunc','PI','E','LN2','LN10'],
  Array: ['from','isArray','of'],
  Object: ['keys','values','entries','assign','freeze','create','defineProperty','fromEntries','hasOwn'],
  JSON: ['parse','stringify'],
  console: ['log','warn','error','info','table','time','timeEnd','clear'],
  Promise: ['all','allSettled','any','race','resolve','reject'],
  Number: ['isFinite','isInteger','isNaN','parseFloat','parseInt','MAX_SAFE_INTEGER','MIN_SAFE_INTEGER','EPSILON'],
  String: ['fromCharCode','fromCodePoint','raw'],
  ui: ['display','print','canvas','table','slider','dropdown','checkbox','textInput'],
  std: ['csv','fetchJSON','sum','mean','median','extent','bin','linspace',
        'unique','zip','cross','file','download','el','copy','fmt'],
};

// common prototype methods by type
const PROTO_PROPS = {
  array: ['push','pop','shift','unshift','splice','slice','concat','join','reverse',
          'sort','map','filter','reduce','reduceRight','find','findIndex','indexOf',
          'includes','every','some','flat','flatMap','fill','forEach','at','length'],
  string: ['charAt','charCodeAt','codePointAt','concat','endsWith','includes',
           'indexOf','lastIndexOf','match','matchAll','padEnd','padStart','repeat',
           'replace','replaceAll','search','slice','split','startsWith','substring',
           'toLowerCase','toUpperCase','trim','trimEnd','trimStart','at','length'],
  number: ['toFixed','toPrecision','toString','valueOf'],
};

// ── BUILTIN HELP (injected by build.js from src/builtins.json) ──

const BUILTIN_HELP = {
  "ui.display": {
    "sig": "ui.display(...values)",
    "desc": "output values to cell"
  },
  "ui.canvas": {
    "sig": "ui.canvas(w?, h?)",
    "desc": "create/reuse canvas (default 400\u00d7300)"
  },
  "ui.table": {
    "sig": "ui.table(data, columns?)",
    "desc": "render array of objects as table"
  },
  "ui.slider": {
    "sig": "ui.slider(label, default?, {min,max,step,onInput,onChange}?)",
    "desc": "range input \u2014 reactive, or callback via onInput/onChange"
  },
  "ui.dropdown": {
    "sig": "ui.dropdown(label, options, default?, {onInput,onChange}?)",
    "desc": "select menu \u2014 reactive, or callback via onInput/onChange"
  },
  "ui.checkbox": {
    "sig": "ui.checkbox(label, default?, {onInput,onChange}?)",
    "desc": "toggle \u2014 reactive, or callback via onInput/onChange"
  },
  "ui.textInput": {
    "sig": "ui.textInput(label, default?, {onInput,onChange}?)",
    "desc": "text field \u2014 reactive, or callback via onInput/onChange"
  },
  "std.csv": {
    "sig": "std.csv(text, {separator?, typed?}?)",
    "desc": "parse CSV text to array of objects"
  },
  "std.fetchJSON": {
    "sig": "std.fetchJSON(url)",
    "desc": "fetch URL and parse JSON"
  },
  "std.sum": {
    "sig": "std.sum(arr, fn?)",
    "desc": "sum array values"
  },
  "std.mean": {
    "sig": "std.mean(arr, fn?)",
    "desc": "arithmetic mean"
  },
  "std.median": {
    "sig": "std.median(arr, fn?)",
    "desc": "median value"
  },
  "std.extent": {
    "sig": "std.extent(arr, fn?)",
    "desc": "returns [min, max]"
  },
  "std.bin": {
    "sig": "std.bin(arr, n?, fn?)",
    "desc": "histogram bins (default 10)"
  },
  "std.linspace": {
    "sig": "std.linspace(start, stop, n)",
    "desc": "evenly-spaced numbers"
  },
  "std.unique": {
    "sig": "std.unique(arr, fn?)",
    "desc": "unique values with optional key fn"
  },
  "std.zip": {
    "sig": "std.zip(...arrays)",
    "desc": "zip arrays together"
  },
  "std.cross": {
    "sig": "std.cross(...arrays)",
    "desc": "cartesian product"
  },
  "std.file": {
    "sig": "std.file(accept?)",
    "desc": "open file picker"
  },
  "std.download": {
    "sig": "std.download(data, filename, mimeType?)",
    "desc": "download data as file"
  },
  "std.el": {
    "sig": "std.el(tag, attrs?, ...children)",
    "desc": "create DOM element"
  },
  "std.copy": {
    "sig": "std.copy(text)",
    "desc": "copy text to clipboard"
  },
  "std.fmt": {
    "sig": "std.fmt(number, {decimals?, prefix?, suffix?}?)",
    "desc": "format number to string"
  },
  "print": {
    "sig": "print(...values)",
    "desc": "output values to cell (alias for ui.display)"
  },
  "load": {
    "sig": "load(url)",
    "desc": "import ES module (cached). @std, @python supported."
  },
  "install": {
    "sig": "install(url)",
    "desc": "fetch & embed module for offline"
  },
  "invalidation": {
    "sig": "invalidation",
    "desc": "promise \u2014 resolves when cell re-runs"
  },
  "atra": {
    "sig": "atra`...` or atra({imports})`...`",
    "desc": "compile Fortran/Pascal to Wasm (load ext/atra/index.js)"
  }
};

// ── FUZZY MATCHING ──

// returns { score, indices } or null if no match
// indices = positions in `text` that matched characters from `query`
function fuzzyMatch(query, text) {
  const qLen = query.length;
  const tLen = text.length;
  if (qLen === 0) return { score: 0, indices: [] };
  if (qLen > tLen) return null;

  const qLower = query.toLowerCase();
  const tLower = text.toLowerCase();

  // fast check: all query chars exist in text in order
  let qi = 0;
  for (let ti = 0; ti < tLen && qi < qLen; ti++) {
    if (qLower[qi] === tLower[ti]) qi++;
  }
  if (qi < qLen) return null;

  // find best match using a greedy approach that prefers word boundaries
  // word boundaries: start of string, after _ or $, camelCase transitions
  const indices = [];
  qi = 0;

  // first pass: try to match at word boundaries
  const boundaryIndices = [];
  let bqi = 0;
  for (let ti = 0; ti < tLen && bqi < qLen; ti++) {
    if (qLower[bqi] !== tLower[ti]) continue;
    const isBoundary = ti === 0
      || text[ti - 1] === '_' || text[ti - 1] === '$'
      || (text[ti] >= 'A' && text[ti] <= 'Z' && (ti === 0 || text[ti - 1] < 'A' || text[ti - 1] > 'Z'));
    if (isBoundary) {
      boundaryIndices.push(ti);
      bqi++;
    }
  }

  if (bqi === qLen) {
    // all chars matched at boundaries — use those indices
    indices.push(...boundaryIndices);
  } else {
    // fallback: greedy left-to-right match, prefer consecutive runs
    qi = 0;
    for (let ti = 0; ti < tLen && qi < qLen; ti++) {
      if (qLower[qi] === tLower[ti]) {
        indices.push(ti);
        qi++;
      }
    }
  }

  // score the match
  let score = 0;

  // bonus for matching at start of string
  if (indices[0] === 0) score += 10;

  // bonus for consecutive characters
  for (let i = 1; i < indices.length; i++) {
    if (indices[i] === indices[i - 1] + 1) score += 5;
  }

  // bonus for word boundary matches
  for (const idx of indices) {
    if (idx === 0) { score += 3; continue; }
    const prev = text[idx - 1];
    if (prev === '_' || prev === '$') { score += 3; continue; }
    if (text[idx] >= 'A' && text[idx] <= 'Z' && (prev < 'A' || prev > 'Z')) score += 3;
  }

  // bonus for exact case match
  for (let i = 0; i < indices.length; i++) {
    if (query[i] === text[indices[i]]) score += 1;
  }

  // penalty for spread-out matches (large gaps between indices)
  const span = indices[indices.length - 1] - indices[0];
  score -= span * 0.5;

  // slight penalty for longer names (prefer shorter completions)
  score -= tLen * 0.1;

  return { score, indices };
}

// determine cursor context: is it inside a string or comment?
function cursorContext(code, cursor) {
  let i = 0;
  while (i < cursor) {
    const ch = code[i];
    // single-line comment
    if (ch === '/' && code[i + 1] === '/') {
      const nl = code.indexOf('\n', i);
      if (nl === -1 || nl >= cursor) return 'comment';
      i = nl + 1;
      continue;
    }
    // block comment
    if (ch === '/' && code[i + 1] === '*') {
      const end = code.indexOf('*/', i + 2);
      if (end === -1 || end + 2 > cursor) return 'comment';
      i = end + 2;
      continue;
    }
    // single-quoted string
    if (ch === "'") {
      i++;
      while (i < code.length) {
        if (code[i] === '\\') { i += 2; continue; }
        if (code[i] === "'") { i++; break; }
        if (i >= cursor) return 'string';
        i++;
      }
      continue;
    }
    // double-quoted string
    if (ch === '"') {
      i++;
      while (i < code.length) {
        if (code[i] === '\\') { i += 2; continue; }
        if (code[i] === '"') { i++; break; }
        if (i >= cursor) return 'string';
        i++;
      }
      continue;
    }
    // template literal (possibly tagged)
    if (ch === '`') {
      // look back for a tag name: identifier immediately before the backtick,
      // or curried form: identifier(...) before the backtick
      let tagName = null;
      if (i > 0 && typeof window !== 'undefined' && window._taggedLanguages) {
        let te = i;
        let ts = te;
        // direct form: ident`
        while (ts > 0 && /\w/.test(code[ts - 1])) ts--;
        if (ts < te) {
          const candidate = code.slice(ts, te);
          if (window._taggedLanguages[candidate]) tagName = candidate;
        }
        // curried form: ident(...)`
        if (!tagName && code[i - 1] === ')') {
          let p = i - 2, depth = 1;
          while (p >= 0 && depth > 0) {
            if (code[p] === ')') depth++;
            else if (code[p] === '(') depth--;
            p--;
          }
          // p now points one before the (
          let ne = p + 1;
          let ns = ne;
          while (ns > 0 && /\w/.test(code[ns - 1])) ns--;
          if (ns < ne) {
            const candidate = code.slice(ns, ne);
            if (window._taggedLanguages[candidate]) tagName = candidate;
          }
        }
      }

      i++;
      let depth = 0;
      while (i < code.length) {
        if (code[i] === '\\') { i += 2; continue; }
        if (code[i] === '$' && code[i + 1] === '{') {
          depth++;
          i += 2;
          // inside ${...} — this is code context
          let braces = 1;
          while (i < code.length && braces > 0) {
            if (code[i] === '{') braces++;
            else if (code[i] === '}') { braces--; if (braces === 0) break; }
            if (i >= cursor) return 'code'; // inside template expression = code
            i++;
          }
          if (i >= cursor) return 'code';
          i++; // skip closing }
          continue;
        }
        if (code[i] === '`') { i++; break; }
        if (i >= cursor) return tagName ? { type: 'tagged', lang: tagName } : 'string';
        i++;
      }
      continue;
    }
    i++;
  }
  return 'code';
}

// extract the word being typed at cursor position
function extractPrefix(code, cursor) {
  let end = cursor;
  let start = cursor;
  while (start > 0 && /[a-zA-Z0-9_$]/.test(code[start - 1])) start--;
  return { prefix: code.slice(start, end), start };
}

// detect dot access: returns the expression before the dot, or null
function detectDot(code, cursor) {
  // cursor is right after a dot or after dot + partial word
  const before = code.slice(0, cursor);
  // match patterns like "identifier." or "identifier.par" at end
  const m = before.match(/([a-zA-Z_$][\w$]*)\.\s*([a-zA-Z_$][\w$]*)?$/);
  if (m) return { obj: m[1], prefix: m[2] || '' };
  return null;
}

function getPropsForValue(val) {
  if (val == null) return [];
  const props = new Set();
  // own properties
  const own = Object.getOwnPropertyNames(val);
  for (const p of own) {
    if (/^[a-zA-Z_$]/.test(p)) props.add(p);
  }
  // prototype chain (1 level)
  const proto = Object.getPrototypeOf(val);
  if (proto && proto !== Object.prototype) {
    try {
      const pNames = Object.getOwnPropertyNames(proto);
      for (const p of pNames) {
        if (p !== 'constructor' && /^[a-zA-Z_$]/.test(p)) props.add(p);
      }
    } catch {}
  }
  return [...props];
}

function getCompletions(code, cursor, cellId) {
  const ctx = cursorContext(code, cursor);

  // tagged template literal — delegate to extension completions
  if (ctx && typeof ctx === 'object' && ctx.type === 'tagged') {
    const lang = typeof window !== 'undefined' && window._taggedLanguages
      && window._taggedLanguages[ctx.lang];
    if (lang && lang.completions) {
      const { prefix, start } = extractPrefix(code, cursor);
      if (!prefix) return { prefix: '', items: [] };
      const extItems = lang.completions(prefix);
      // score and annotate items
      const items = [];
      for (const it of extItems) {
        const m = fuzzyMatch(prefix, it.text);
        if (m) items.push({ text: it.text, kind: it.kind || 'var', score: m.score, indices: m.indices });
      }
      items.sort((a, b) => b.score - a.score || a.text.localeCompare(b.text));
      return { prefix, items: items.slice(0, 30) };
    }
    return { prefix: '', items: [] };
  }

  if (ctx !== 'code') return { prefix: '', items: [] };

  // check for dot completion
  const dot = detectDot(code, cursor);
  if (dot) {
    const items = [];
    const prefix = dot.prefix;
    let propList = [];

    // check known builtins
    if (KNOWN_PROPS[dot.obj]) {
      propList = KNOWN_PROPS[dot.obj];
    } else if (dot.obj in S.scope) {
      // live value inspection
      const val = S.scope[dot.obj];
      if (val != null) {
        propList = getPropsForValue(val);
        // also add type-based suggestions
        if (Array.isArray(val)) propList = [...new Set([...propList, ...PROTO_PROPS.array])];
        else if (typeof val === 'string') propList = [...new Set([...propList, ...PROTO_PROPS.string])];
        else if (typeof val === 'number') propList = [...new Set([...propList, ...PROTO_PROPS.number])];
      }
    }

    for (const p of propList) {
      if (!prefix) {
        items.push({ text: p, kind: 'prop', score: 0, indices: [] });
        continue;
      }
      const m = fuzzyMatch(prefix, p);
      if (m) items.push({ text: p, kind: 'prop', score: m.score, indices: m.indices });
    }

    items.sort((a, b) => b.score - a.score || a.text.localeCompare(b.text));
    return { prefix, items: items.slice(0, 30) };
  }

  // word prefix completion
  const { prefix, start } = extractPrefix(code, cursor);
  if (!prefix) return { prefix: '', items: [] };

  const items = [];
  const seen = new Set();

  // collect candidates from all sources with their kind
  const candidates = [];

  // 1. scope variables
  for (const name of Object.keys(S.scope)) {
    if (!seen.has(name)) { seen.add(name); candidates.push({ text: name, kind: 'var' }); }
  }

  // 2. own cell defines
  const cell = S.cells.find(c => c.id === cellId);
  if (cell && cell.defines) {
    for (const name of cell.defines) {
      if (!seen.has(name)) { seen.add(name); candidates.push({ text: name, kind: 'def' }); }
    }
  }

  // 3. builtin functions (with help detail)
  for (const name of Object.keys(BUILTIN_HELP)) {
    if (!seen.has(name)) {
      seen.add(name);
      const h = BUILTIN_HELP[name];
      candidates.push({ text: name, kind: 'fn', detail: h.sig });
    }
  }

  // 4. JS builtins
  for (const name of JS_BUILTINS) {
    if (!seen.has(name)) { seen.add(name); candidates.push({ text: name, kind: 'const' }); }
  }

  // 5. JS keywords (min 2 chars to avoid noise)
  if (prefix.length >= 2) {
    for (const name of JS_KEYWORDS) {
      if (!seen.has(name)) { seen.add(name); candidates.push({ text: name, kind: 'kw' }); }
    }
  }

  // fuzzy match all candidates
  for (const c of candidates) {
    if (c.text === prefix) continue; // skip exact match (already typed)
    const m = fuzzyMatch(prefix, c.text);
    if (m) {
      const item = { text: c.text, kind: c.kind, score: m.score, indices: m.indices };
      if (c.detail) item.detail = c.detail;
      items.push(item);
    }
  }

  // sort by score descending, then alphabetical
  items.sort((a, b) => b.score - a.score || a.text.localeCompare(b.text));

  return { prefix, items: items.slice(0, 30) };
}

// ── TEXTAREA ADAPTER ──

const KIND_LABELS = { var: 'v', fn: 'f', kw: 'k', const: 'c', prop: 'p', def: 'd' };

let activeMenu = null;
let activeState = null;
let activeSigHint = null;

function dismissAutocomplete() {
  if (activeMenu) {
    activeMenu.remove();
    activeMenu = null;
    activeState = null;
  }
}

function dismissSigHint() {
  if (activeSigHint) {
    activeSigHint.remove();
    activeSigHint = null;
  }
}

// detect if cursor is inside a function call's arguments for a known builtin
function detectCallContext(code, cursor) {
  // scan backwards from cursor to find an unmatched (
  let depth = 0;
  let i = cursor - 1;
  while (i >= 0) {
    const ch = code[i];
    if (ch === ')') depth++;
    else if (ch === '(') {
      if (depth === 0) {
        // found the opening paren — extract the function name before it (including dot for ui.slider etc.)
        let end = i;
        let start = end - 1;
        while (start >= 0 && /[a-zA-Z0-9_$.]/.test(code[start])) start--;
        start++;
        const fnName = code.slice(start, end);
        if (BUILTIN_HELP[fnName]) {
          // figure out which parameter we're on by counting commas at depth 0
          let paramIdx = 0;
          let d = 0;
          for (let j = i + 1; j < cursor; j++) {
            if (code[j] === '(' || code[j] === '[' || code[j] === '{') d++;
            else if (code[j] === ')' || code[j] === ']' || code[j] === '}') d--;
            else if (code[j] === ',' && d === 0) paramIdx++;
          }
          return { fnName, parenPos: i, paramIdx };
        }
        return null;
      }
      depth--;
    }
    i--;
  }
  return null;
}

function showSigHint(ta) {
  const code = ta.value;
  const cursor = ta.selectionStart;
  if (ta.selectionStart !== ta.selectionEnd) { dismissSigHint(); return; }

  const ctx = cursorContext(code, cursor);
  if (ctx !== 'code') { dismissSigHint(); return; }

  const call = detectCallContext(code, cursor);
  if (!call) { dismissSigHint(); return; }

  const wrap = ta.closest('.editor-wrap');
  if (!wrap) { dismissSigHint(); return; }

  const help = BUILTIN_HELP[call.fnName];
  const pos = measureCursorPos(ta, call.parenPos);

  if (!activeSigHint) {
    activeSigHint = document.createElement('div');
    activeSigHint.className = 'ac-sig-hint';
    wrap.appendChild(activeSigHint);
  } else if (activeSigHint.parentElement !== wrap) {
    activeSigHint.remove();
    wrap.appendChild(activeSigHint);
  }

  // highlight current parameter in the signature
  const sigHtml = highlightParam(help.sig, call.paramIdx);
  activeSigHint.innerHTML = `<span class="ac-sig-fn">${sigHtml}</span><span class="ac-sig-desc">${esc(help.desc)}</span>`;

  const cs = getComputedStyle(ta);
  const padLeft = parseFloat(cs.paddingLeft) || 0;
  const padTop = parseFloat(cs.paddingTop) || 0;
  const lineHeight = parseFloat(cs.lineHeight) || parseFloat(cs.fontSize) * 1.5;

  const left = pos.x + padLeft - ta.scrollLeft;

  // place above the current line; pos.y is bottom of the line
  // so subtract lineHeight (to get top of line) then the hint's own height
  activeSigHint.style.left = left + 'px';
  activeSigHint.style.top = '0px'; // render off-screen first to measure
  activeSigHint.style.visibility = 'hidden';
  const hintH = activeSigHint.offsetHeight || lineHeight;
  activeSigHint.style.visibility = '';

  let top = pos.y + padTop - ta.scrollTop - lineHeight - hintH;

  // if it would go above the editor, show below the current line instead
  const wrapRect = wrap.getBoundingClientRect();
  const taRect = ta.getBoundingClientRect();
  const absTop = taRect.top + top;
  if (absTop < wrapRect.top) {
    top = pos.y + padTop - ta.scrollTop;
  }

  activeSigHint.style.top = top + 'px';
}

function highlightParam(sig, paramIdx) {
  // find the params inside parens
  const openParen = sig.indexOf('(');
  if (openParen === -1) return esc(sig);
  const closeParen = sig.lastIndexOf(')');
  if (closeParen === -1) return esc(sig);

  const before = sig.slice(0, openParen + 1);
  const params = sig.slice(openParen + 1, closeParen);
  const after = sig.slice(closeParen);

  // split on commas (respecting nested braces)
  const parts = [];
  let depth = 0;
  let start = 0;
  for (let i = 0; i < params.length; i++) {
    if (params[i] === '{' || params[i] === '(' || params[i] === '[') depth++;
    else if (params[i] === '}' || params[i] === ')' || params[i] === ']') depth--;
    else if (params[i] === ',' && depth === 0) {
      parts.push(params.slice(start, i));
      start = i + 1;
    }
  }
  parts.push(params.slice(start));

  let html = esc(before);
  for (let i = 0; i < parts.length; i++) {
    if (i > 0) html += esc(',');
    if (i === paramIdx) {
      html += '<span class="ac-sig-active">' + esc(parts[i]) + '</span>';
    } else {
      html += esc(parts[i]);
    }
  }
  html += esc(after);
  return html;
}

function measureCursorPos(ta, cursor) {
  const text = ta.value.substring(0, cursor);
  const lines = text.split('\n');
  const lineNum = lines.length - 1;
  const colText = lines[lineNum];

  // measure column offset using a hidden span
  let measurer = ta._acMeasurer;
  if (!measurer) {
    measurer = document.createElement('span');
    measurer.style.cssText = 'position:absolute;visibility:hidden;white-space:pre;pointer-events:none;';
    document.body.appendChild(measurer);
    ta._acMeasurer = measurer;
  }
  const cs = getComputedStyle(ta);
  measurer.style.font = cs.font;
  measurer.style.fontSize = cs.fontSize;
  measurer.style.fontFamily = cs.fontFamily;
  measurer.style.letterSpacing = cs.letterSpacing;
  measurer.style.tabSize = cs.tabSize;
  measurer.textContent = colText;

  const lineHeight = parseFloat(cs.lineHeight) || parseFloat(cs.fontSize) * 1.5;
  const x = measurer.offsetWidth;
  const y = (lineNum + 1) * lineHeight;

  return { x, y, lineHeight };
}

function highlightMatches(text, indices) {
  if (!indices || !indices.length) return esc(text);
  const set = new Set(indices);
  let html = '';
  let inMatch = false;
  for (let i = 0; i < text.length; i++) {
    if (set.has(i)) {
      if (!inMatch) { html += '<span class="ac-match">'; inMatch = true; }
      html += esc(text[i]);
    } else {
      if (inMatch) { html += '</span>'; inMatch = false; }
      html += esc(text[i]);
    }
  }
  if (inMatch) html += '</span>';
  return html;
}

function renderMenu(items, prefix, selectedIdx) {
  let html = '';
  const max = Math.min(items.length, 30);
  for (let i = 0; i < max; i++) {
    const it = items[i];
    const cls = i === selectedIdx ? 'ac-item active' : 'ac-item';
    const kindCls = 'ac-kind ac-kind-' + it.kind;
    const label = KIND_LABELS[it.kind] || '?';
    const textHtml = highlightMatches(it.text, it.indices);
    const detailHtml = it.detail ? `<span class="ac-detail">${esc(it.detail)}</span>` : '';
    html += `<div class="${cls}" data-index="${i}"><span class="${kindCls}">${label}</span><span class="ac-text">${textHtml}</span>${detailHtml}</div>`;
  }
  return html;
}

function esc(s) {
  return s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
}

function showMenu(ta, cellId) {
  const code = ta.value;
  const cursor = ta.selectionStart;
  if (ta.selectionStart !== ta.selectionEnd) { dismissAutocomplete(); return; }

  const result = getCompletions(code, cursor, cellId);
  if (!result.items.length) { dismissAutocomplete(); return; }

  const wrap = ta.closest('.editor-wrap');
  if (!wrap) { dismissAutocomplete(); return; }

  const pos = measureCursorPos(ta, cursor);

  if (!activeMenu) {
    activeMenu = document.createElement('div');
    activeMenu.className = 'ac-menu';
    wrap.appendChild(activeMenu);
  } else if (activeMenu.parentElement !== wrap) {
    activeMenu.remove();
    wrap.appendChild(activeMenu);
  }

  activeState = {
    items: result.items,
    prefix: result.prefix,
    selected: 0,
    ta,
    cellId,
    cursorStart: cursor - result.prefix.length
  };

  activeMenu.innerHTML = renderMenu(result.items, result.prefix, 0);

  // position: account for padding and scroll
  const cs = getComputedStyle(ta);
  const padLeft = parseFloat(cs.paddingLeft) || 0;
  const padTop = parseFloat(cs.paddingTop) || 0;

  const left = pos.x + padLeft - ta.scrollLeft;
  const top = pos.y + padTop - ta.scrollTop;

  activeMenu.style.left = left + 'px';
  activeMenu.style.top = top + 'px';

  // flip above if it would overflow viewport
  const menuRect = activeMenu.getBoundingClientRect();
  if (menuRect.bottom > window.innerHeight - 20) {
    activeMenu.style.top = (top - pos.lineHeight - activeMenu.offsetHeight) + 'px';
  }

  // mouse interaction
  activeMenu.onmousedown = (e) => {
    e.preventDefault(); // don't blur textarea
    const item = e.target.closest('.ac-item');
    if (item) {
      activeState.selected = parseInt(item.dataset.index);
      acceptCompletion();
    }
  };
}

function updateSelection(idx) {
  if (!activeMenu || !activeState) return;
  activeState.selected = idx;
  const items = activeMenu.querySelectorAll('.ac-item');
  items.forEach((el, i) => el.classList.toggle('active', i === idx));
  // scroll into view
  if (items[idx]) items[idx].scrollIntoView({ block: 'nearest' });
}

function acceptCompletion() {
  if (!activeState) return;
  const { items, selected, ta, prefix, cursorStart } = activeState;
  const item = items[selected];
  if (!item) return;

  ta.focus();
  ta.selectionStart = cursorStart;
  ta.selectionEnd = cursorStart + prefix.length;
  document.execCommand('insertText', false, item.text);

  dismissAutocomplete();
  ta.dispatchEvent(new Event('input'));
}

function attachAutocomplete(textarea, cellId) {
  // keydown handler — must be added BEFORE handleTab so stopImmediatePropagation works
  textarea.addEventListener('keydown', (e) => {
    // Ctrl+Shift+Space — manual signature hint trigger
    if (e.key === ' ' && (e.ctrlKey || e.metaKey) && e.shiftKey) {
      e.preventDefault();
      e.stopImmediatePropagation();
      dismissAutocomplete();
      showSigHint(textarea);
      return;
    }

    if (!activeMenu || !activeState) return;

    if (e.key === 'ArrowDown') {
      e.preventDefault();
      e.stopImmediatePropagation();
      const next = (activeState.selected + 1) % activeState.items.length;
      updateSelection(next);
      return;
    }
    if (e.key === 'ArrowUp') {
      e.preventDefault();
      e.stopImmediatePropagation();
      const prev = (activeState.selected - 1 + activeState.items.length) % activeState.items.length;
      updateSelection(prev);
      return;
    }
    if (e.key === 'Tab' || e.key === 'Enter') {
      e.preventDefault();
      e.stopImmediatePropagation();
      acceptCompletion();
      return;
    }
    if (e.key === 'Escape') {
      e.preventDefault();
      e.stopImmediatePropagation();
      dismissAutocomplete();
      dismissSigHint();
      return;
    }
  });

  // input handler — show/update completions + signature hints
  textarea.addEventListener('input', () => {
    // use a microtask so the value is settled
    Promise.resolve().then(() => {
      showMenu(textarea, cellId);
      // show sig hint only when autocomplete menu is not visible
      if (!activeMenu) showSigHint(textarea);
      else dismissSigHint();
    });
  });

  // dismiss on blur
  textarea.addEventListener('blur', () => {
    // delay so mousedown on menu can fire first
    setTimeout(() => { dismissAutocomplete(); dismissSigHint(); }, 150);
  });

  // dismiss on scroll (position goes stale)
  textarea.addEventListener('scroll', () => {
    dismissAutocomplete();
    dismissSigHint();
  });
}

// -- keyboard.js --

// ── KEYBOARD / SELECTION ──

function addCellWithUndo(type, code, afterId, beforeId) {
  const cell = addCell(type, code, afterId, beforeId);
  S.trash.push({ action: 'add', id: cell.id });
  return cell;
}

function deleteCellWithUndo(id) {
  const idx = S.cells.findIndex(c => c.id === id);
  if (idx < 0) return;
  const cell = S.cells[idx];
  const afterId = idx > 0 ? S.cells[idx - 1].id : null;
  const beforeId = afterId === null && idx < S.cells.length - 1 ? S.cells[idx + 1].id : null;
  S.trash.push({ action: 'delete', type: cell.type, code: cell.code, afterId, beforeId, collapsed: !!cell.el.classList.contains('collapsed') });
  deleteCell(id);
  setMsg('deleted cell (z to undo)', 'ok');
}

function undo() {
  if (!S.trash.length) { setMsg('nothing to undo', ''); return; }
  const entry = S.trash.pop();

  if (entry.action === 'add') {
    // undo add = delete the cell (without pushing to undo stack)
    deleteCell(entry.id);
    setMsg('undid add', 'ok');
  } else {
    // undo delete = restore the cell
    const { type, code, afterId, beforeId, collapsed } = entry;
    const validAfter = afterId !== null && S.cells.find(c => c.id === afterId) ? afterId : null;
    const validBefore = beforeId !== null && S.cells.find(c => c.id === beforeId) ? beforeId : null;
    const newCell = addCell(type, code, validAfter, validBefore);
    if (collapsed) newCell.el.classList.add('collapsed');
    selectCell(newCell.id);
    if ((type === 'code' || type === 'html') && S.cells.some(c => c.type === 'code' || c.type === 'html')) runAll();
    setMsg('restored cell', 'ok');
  }
}

function selectCell(id, scroll) {
  // deselect previous
  $$('.cell.selected').forEach(el => el.classList.remove('selected'));
  S.selectedId = id;
  if (id === null) return;
  const cell = S.cells.find(c => c.id === id);
  if (cell) {
    cell.el.classList.add('selected');
    if (scroll) cell.el.scrollIntoView({ block: 'nearest' });
  }
}

function getEditingCell() {
  const active = document.activeElement;
  if (active && active.tagName === 'TEXTAREA') {
    const cellEl = active.closest('.cell');
    if (cellEl) {
      const id = parseInt(cellEl.dataset.id);
      return S.cells.find(c => c.id === id) || null;
    }
  }
  return null;
}

function editCell(id) {
  const cell = S.cells.find(c => c.id === id);
  if (!cell) return;
  selectCell(id);

  if (cell.type === 'md') {
    // open md editor
    const view = cell.el.querySelector('.cell-md-view');
    const editWrap = cell.el.querySelector('.cell-md-edit');
    const ta = cell.el.querySelector('.cell-md-edit textarea');
    editWrap.style.display = '';
    view.style.display = 'none';
    ta.value = cell.code;
    ta.focus();
    autoResize({ target: ta });
  } else if (cell.type === 'css') {
    // open css editor
    const view = cell.el.querySelector('.cell-css-view');
    const editWrap = cell.el.querySelector('.cell-css-edit');
    const ta = cell.el.querySelector('.cell-css-edit textarea');
    editWrap.style.display = '';
    view.style.display = 'none';
    ta.value = cell.code;
    ta.focus();
    autoResize({ target: ta });
  } else if (cell.type === 'html') {
    // open html editor
    const view = cell.el.querySelector('.cell-html-view');
    const editWrap = cell.el.querySelector('.cell-html-edit');
    const ta = cell.el.querySelector('.cell-html-edit textarea');
    editWrap.style.display = '';
    view.style.display = 'none';
    ta.value = cell.code;
    ta.focus();
    autoResize({ target: ta });
  } else {
    cell.el.querySelector('textarea').focus();
  }
}

function exitEdit() {
  const active = document.activeElement;
  if (active && active.tagName === 'TEXTAREA') {
    active.blur();
  }
}

function runSelected() {
  if (S.selectedId === null && S.cells.length) selectCell(S.cells[0].id);
  const cell = S.cells.find(c => c.id === S.selectedId);
  if (!cell) return;
  if (cell.type === 'code') {
    cell.code = cell.el.querySelector('.cell-code textarea').value;
    runDAG([cell.id]);
  } else if (cell.type === 'html') {
    renderHtmlCell(cell);
  }
}

// ── MOBILE TRAY TOGGLES ──

function closeAllTrays() {
  document.querySelectorAll('.action-add-tray.open, .action-more-tray.open, .cell-type-picker.open, .cell-insert-picker.open').forEach(el => el.classList.remove('open'));
}

function toggleToolbarMenu() {
  const menu = document.querySelector('.toolbar-overflow');
  if (!menu) return;
  menu.classList.toggle('open');
}

function toggleAddTray() {
  const tray = document.querySelector('.action-add-tray');
  if (!tray) return;
  const wasOpen = tray.classList.contains('open');
  closeAllTrays();
  if (!wasOpen) tray.classList.add('open');
}

function toggleMoreTray() {
  const tray = document.querySelector('.action-more-tray');
  if (!tray) return;
  const wasOpen = tray.classList.contains('open');
  closeAllTrays();
  if (!wasOpen) tray.classList.add('open');
}

function showInsertPicker(id, dir) {
  closeAllTrays();
  const cell = S.cells.find(c => c.id === id);
  if (!cell) return;
  document.querySelectorAll('.cell-insert-picker').forEach(el => el.remove());
  const picker = document.createElement('div');
  picker.className = 'cell-insert-picker open';
  let afterId;
  if (dir === 'after') {
    afterId = id;
  } else {
    const idx = S.cells.findIndex(c => c.id === id);
    afterId = idx > 0 ? S.cells[idx - 1].id : null;
  }
  picker.innerHTML = ['code', 'md', 'css', 'html'].map(t =>
    `<button onclick="insertAt(${afterId !== null ? afterId : 'null'},'${t}');this.closest('.cell-insert-picker').remove()">${t}</button>`
  ).join('');
  const header = cell.el.querySelector('.cell-header');
  header.style.position = 'relative';
  picker.style.top = '100%';
  picker.style.left = dir === 'before' ? '0' : 'auto';
  picker.style.right = dir === 'after' ? '0' : 'auto';
  header.appendChild(picker);
}

function toggleTypePicker(id) {
  closeAllTrays();
  const picker = document.querySelector(`.cell-type-picker[data-cell-id="${id}"]`);
  if (picker) picker.classList.toggle('open');
}

function collapseAll() {
  S.cells.forEach(c => c.el.classList.add('collapsed'));
  setMsg('collapsed all', 'ok');
}

function expandAll() {
  S.cells.forEach(c => c.el.classList.remove('collapsed'));
  setMsg('expanded all', 'ok');
}

function newNotebook() {
  if (!confirm('Clear all cells?')) return;
  while (S.cells.length) {
    const cell = S.cells[0];
    if (cell._styleEl) { cell._styleEl.remove(); cell._styleEl = null; }
    cell.el.remove();
    S.cells.shift();
  }
  S.scope = {};
  S.selectedId = null;
  S.clipboard = null;
  S.trash = [];
  $('#docTitle').value = 'untitled';
  updateStatus();
  setMsg('new notebook', 'ok');
}

function runSelectedCell() { runSelectedAndAdvance(); }

function runSelectedAndAdvance() {
  runSelected();
  if (S.selectedId === null) return;
  // respect goto target if set
  const gotoIdx = window._lastGotoTarget;
  if (gotoIdx != null && gotoIdx >= 0 && gotoIdx < S.cells.length) {
    editCell(S.cells[gotoIdx].id);
  } else {
    const idx = S.cells.findIndex(c => c.id === S.selectedId);
    if (idx < S.cells.length - 1) {
      editCell(S.cells[idx + 1].id);
    } else {
      const newCell = addCellWithUndo('code', '', S.selectedId);
      selectCell(newCell.id);
    }
  }
}

function navigateCell(dir) {
  if (!S.cells.length) return;
  if (S.selectedId === null) {
    selectCell(S.cells[0].id, true);
    return;
  }
  const idx = S.cells.findIndex(c => c.id === S.selectedId);
  const newIdx = idx + dir;
  if (newIdx >= 0 && newIdx < S.cells.length) {
    selectCell(S.cells[newIdx].id, true);
  }
}

document.addEventListener('keydown', (e) => {
  // find bar shortcuts (must be before edit/command branches)
  if ((e.key === 'f') && (e.ctrlKey || e.metaKey) && !e.altKey) {
    e.preventDefault(); openFind(false); return;
  }
  if ((e.key === 'h') && (e.ctrlKey || e.metaKey) && !e.altKey) {
    e.preventDefault(); openFind(true); return;
  }
  if (e.key === 'Escape' && S.findActive) {
    e.preventDefault(); closeFind(); return;
  }

  const editing = getEditingCell();

  if (editing) {
    // ── EDIT MODE ──
    if (e.key === '/' && (e.ctrlKey || e.metaKey)) {
      e.preventDefault();
      toggleComment(document.activeElement);
      return;
    }
    if (e.key === 'Escape') {
      e.preventDefault();
      exitEdit();
      selectCell(editing.id);
      return;
    }
    if (e.key === 'Enter' && e.ctrlKey) {
      e.preventDefault();
      editing.code = editing.el.querySelector('textarea').value;
      if (editing.type === 'code') runDAG([editing.id], true);
      return;
    }
    if (e.key === 'Enter' && e.shiftKey) {
      e.preventDefault();
      editing.code = editing.el.querySelector('textarea').value;
      if (editing.type === 'code') runDAG([editing.id], true);
      // advance — respect goto target if set
      const gotoIdx = window._lastGotoTarget;
      if (gotoIdx != null && gotoIdx >= 0 && gotoIdx < S.cells.length) {
        editCell(S.cells[gotoIdx].id);
      } else {
        const idx = S.cells.findIndex(c => c.id === editing.id);
        if (idx < S.cells.length - 1) {
          editCell(S.cells[idx + 1].id);
        } else {
          const newCell = addCellWithUndo('code', '', editing.id);
          selectCell(newCell.id);
          editCell(newCell.id);
        }
      }
      return;
    }
  } else {
    // ── COMMAND MODE ──
    // ignore if typing in any input field (title, find bar, etc.)
    if (document.activeElement && (document.activeElement.tagName === 'INPUT' || document.activeElement.id === 'docTitle')) return;

    // let browser shortcuts through (Ctrl+J downloads, etc.)
    if (e.ctrlKey || e.metaKey || e.altKey) return;

    if (e.key === 'ArrowUp' || e.key === 'k') {
      e.preventDefault();
      navigateCell(-1);
      return;
    }
    if (e.key === 'ArrowDown' || e.key === 'j') {
      e.preventDefault();
      navigateCell(1);
      return;
    }
    if (e.key === 'Enter') {
      e.preventDefault();
      if (S.selectedId !== null) editCell(S.selectedId);
      return;
    }
    if (e.key === 'a') {
      e.preventDefault();
      const newCell = addCellWithUndo('code', '', null, S.selectedId);
      selectCell(newCell.id);
      editCell(newCell.id);
      return;
    }
    if (e.key === 'b') {
      e.preventDefault();
      const newCell = addCellWithUndo('code', '', S.selectedId);
      selectCell(newCell.id);
      editCell(newCell.id);
      return;
    }
    if (e.key === 'd') {
      e.preventDefault();
      if (S.pendingD) {
        // dd — delete
        clearTimeout(S.pendingDTimer);
        S.pendingD = false;
        if (S.selectedId !== null) {
          const idx = S.cells.findIndex(c => c.id === S.selectedId);
          const nextId = idx < S.cells.length - 1 ? S.cells[idx + 1].id
                       : idx > 0 ? S.cells[idx - 1].id : null;
          deleteCellWithUndo(S.selectedId);
          if (nextId !== null) selectCell(nextId);
        }
      } else {
        S.pendingD = true;
        S.pendingDTimer = setTimeout(() => { S.pendingD = false; }, 600);
      }
      return;
    }
    if (e.key !== 'd' && S.pendingD) { S.pendingD = false; clearTimeout(S.pendingDTimer); }
    if (e.key === 'z') {
      e.preventDefault();
      undo();
      return;
    }
    if (e.key === 'c' && S.selectedId !== null) {
      e.preventDefault();
      const cell = S.cells.find(c => c.id === S.selectedId);
      if (cell) S.clipboard = { type: cell.type, code: cell.code };
      setMsg('copied cell', 'ok');
      return;
    }
    if (e.key === 'v' && S.clipboard) {
      e.preventDefault();
      const newCell = addCellWithUndo(S.clipboard.type, S.clipboard.code, S.selectedId);
      selectCell(newCell.id);
      if (S.clipboard.type === 'code' && S.cells.some(c => c.type === 'code')) runAll();
      return;
    }
    if (e.key === 'x' && S.selectedId !== null) {
      // cut = copy + delete
      e.preventDefault();
      const cell = S.cells.find(c => c.id === S.selectedId);
      if (cell) S.clipboard = { type: cell.type, code: cell.code };
      const idx = S.cells.findIndex(c => c.id === S.selectedId);
      const nextId = idx < S.cells.length - 1 ? S.cells[idx + 1].id
                   : idx > 0 ? S.cells[idx - 1].id : null;
      deleteCellWithUndo(S.selectedId);
      if (nextId !== null) selectCell(nextId);
      setMsg('cut cell', 'ok');
      return;
    }
    if (e.key === 'h' && S.selectedId !== null) {
      e.preventDefault();
      const cell = S.cells.find(c => c.id === S.selectedId);
      if (cell) cell.el.classList.toggle('collapsed');
      return;
    }
    if (e.key === 'l') {
      e.preventDefault();
      const on = getSettings().lineNumbers === 'on';
      applyLineNumbers(!on);
      setMsg(on ? 'line numbers off' : 'line numbers on', 'ok');
      return;
    }
    if (e.key === 'p') {
      e.preventDefault();
      togglePresent();
      return;
    }
    if (e.key === 'm' && S.selectedId !== null) {
      e.preventDefault();
      convertCell(S.selectedId, 'md');
      return;
    }
    if (e.key === 'y' && S.selectedId !== null) {
      e.preventDefault();
      convertCell(S.selectedId, 'code');
      return;
    }
    if (e.key === 's' && S.selectedId !== null) {
      e.preventDefault();
      convertCell(S.selectedId, 'css');
      return;
    }
    if (e.key === 't' && S.selectedId !== null) {
      e.preventDefault();
      convertCell(S.selectedId, 'html');
      return;
    }
  }

  // global: F1 help overlay
  if (e.key === 'F1') {
    e.preventDefault();
    $('#helpOverlay').classList.toggle('visible');
    return;
  }

  // close presentation mode on Escape
  if (e.key === 'Escape' && document.body.classList.contains('presenting')) {
    togglePresent();
    e.stopImmediatePropagation();
    return;
  }

  // close settings on Escape if visible
  if (e.key === 'Escape' && $('#settingsOverlay').classList.contains('visible')) {
    toggleSettings();
    e.stopImmediatePropagation();
    return;
  }

  // close help on Escape if visible
  if (e.key === 'Escape' && $('#helpOverlay').classList.contains('visible')) {
    $('#helpOverlay').classList.remove('visible');
    e.stopImmediatePropagation();
    return;
  }

  // global: Ctrl+S / Cmd+S
  if (e.key === 's' && (e.ctrlKey || e.metaKey)) {
    e.preventDefault();
    saveNotebook();
  }
});

// click to dismiss help
$('#helpOverlay').addEventListener('click', (e) => {
  if (e.target === $('#helpOverlay')) $('#helpOverlay').classList.remove('visible');
});

// click to select + close trays
document.addEventListener('click', (e) => {
  // close action trays if clicking outside their wrapper (wrapper = parent div with tray + button)
  const addTray = document.querySelector('.action-add-tray');
  const moreTray = document.querySelector('.action-more-tray');
  if (addTray && addTray.classList.contains('open') && !addTray.parentElement.contains(e.target)) {
    addTray.classList.remove('open');
  }
  if (moreTray && moreTray.classList.contains('open') && !moreTray.parentElement.contains(e.target)) {
    moreTray.classList.remove('open');
  }
  // close cell type pickers if clicking outside
  if (!e.target.closest('.cell-type-picker') && !e.target.closest('.cell-type')) {
    document.querySelectorAll('.cell-type-picker.open').forEach(el => el.classList.remove('open'));
  }
  // close cell insert pickers if clicking outside
  if (!e.target.closest('.cell-insert-picker')) {
    document.querySelectorAll('.cell-insert-picker').forEach(el => el.remove());
  }
  // close toolbar overflow menu if clicking outside
  const tbOverflow = document.querySelector('.toolbar-overflow');
  if (tbOverflow && tbOverflow.classList.contains('open') && !tbOverflow.contains(e.target)) {
    tbOverflow.classList.remove('open');
  }
  // close save tray if clicking outside
  const saveTray = document.getElementById('saveTray');
  if (saveTray && saveTray.classList.contains('open') && !saveTray.parentElement.contains(e.target)) {
    saveTray.classList.remove('open');
  }

  const cellEl = e.target.closest('.cell');
  if (cellEl) {
    const id = parseInt(cellEl.dataset.id);
    selectCell(id);
  }
});

// late import to avoid circular dependency at module load time

// -- goto.js --

// ── GOTO ── @optional

function parseGoto(code) {
  const m = code.match(/^\s*\/\/\s*%goto\b\s*(.*)/m);
  if (!m) return null;
  return m[1].trim() || '';
}

const MAX_VISITS = 1000;
let visits = {};

window._dagStart = function() {
  visits = {};
  window._lastGotoTarget = null;
};

window._beforeExec = function(cell) {
  const target = parseGoto(cell.code);
  if (target !== null) {
    S.scope.__goto = target;
    cell.defines.add('__goto');
  } else {
    delete S.scope.__goto;
  }
};

window._afterExec = function(cell, index) {
  const gotoTarget = S.scope.__goto;
  delete S.scope.__goto;
  window._lastGotoTarget = null;

  if (!gotoTarget) return -1;

  // resolve by cellName
  const targetIdx = S.cells.findIndex(c => parseCellName(c.code) === gotoTarget);
  if (targetIdx < 0) {
    const out = cell.el.querySelector('.cell-output');
    if (out) {
      out.appendChild(document.createTextNode('\ngoto: cell \u201c' + gotoTarget + '\u201d not found'));
      out.classList.add('error');
    }
    return -1;
  }

  // loop protection
  const key = index + ':' + targetIdx;
  visits[key] = (visits[key] || 0) + 1;
  if (visits[key] > MAX_VISITS) {
    const out = cell.el.querySelector('.cell-output');
    if (out) {
      out.appendChild(document.createTextNode('\ngoto: loop limit reached (' + MAX_VISITS + ' iterations)'));
      out.classList.add('error');
    }
    return -1;
  }

  window._lastGotoTarget = targetIdx;
  return targetIdx;
};

// -- size-compare.js --

// ── SIZE COMPARISON ── @optional

const SIZE_MEDIA = [
  [4096, 'an Atari 2600 cartridge'],
  [49152, 'a ZX Spectrum tape'],
  [73728, 'Apollo AGC rope memory'],
  [81920, 'an 8\u2033 floppy (SS/SD)'],
  [262144, 'an NES cartridge'],
  [368640, 'a 5.25\u2033 floppy (DS/DD)'],
  [737280, 'a 3.5\u2033 floppy (DS/DD)'],
  [1228800, 'a 5.25\u2033 floppy (DS/HD)'],
  [1474560, 'a 3.5\u2033 floppy (DS/HD)'],
];

function sizeCompare(bytes) {
  if (!window._sizeCompare) return '';
  for (const [size, name] of SIZE_MEDIA) {
    if (bytes <= size) return 'fits on ' + name;
  }
  const n = Math.ceil(bytes / 1474560);
  return n + '\u00d7 3.5\u2033 floppies';
}

function applySizeCompare(val) {
  const on = val === true || val === 'true' || val === 'on';
  window._sizeCompare = on;
  const el = $('#setSizeCompare');
  if (el) el.value = on ? 'on' : 'off';
  updateStatus();
}

function applySizeCompareRef(val) {
  window._sizeCompareRef = val === 'content' ? 'content' : 'total';
  const el = $('#setSizeCompareRef');
  if (el) el.value = window._sizeCompareRef;
  updateStatus();
}

// inject settings rows before modules section
(function() {
  const panel = $('#settingsPanel');
  if (!panel) return;
  const headings = panel.querySelectorAll('h2');
  const modulesH2 = headings[headings.length - 1];
  if (!modulesH2) return;

  const h2 = document.createElement('h2');
  h2.textContent = 'status bar';
  modulesH2.before(h2);

  const refRow = document.createElement('div');
  refRow.className = 'settings-row';
  refRow.innerHTML = '<label>size reference</label>' +
    '<select id="setSizeCompareRef" onchange="applySizeCompareRef(this.value)">' +
    '<option value="total" selected>total file</option>' +
    '<option value="content">content only</option></select>';
  modulesH2.before(refRow);

  const row = document.createElement('div');
  row.className = 'settings-row';
  row.innerHTML = '<label>size comparison</label>' +
    '<select id="setSizeCompare" onchange="applySizeCompare(this.value)">' +
    '<option value="off">off</option><option value="on" selected>on</option></select>';
  modulesH2.before(row);

  window._sizeCompare = true;
  window._sizeCompareRef = 'total';
})();

// -- globals.js --

// ── GLOBAL BINDINGS ──
// This module wires exported functions to window.* for use by onclick/onchange
// handlers in template HTML and dynamically generated markup.
// Modules stay pure (no side effects, no window assignments).











// state
window.$ = $;
window.S = S;

// editor
window.toggleAutorun = toggleAutorun;

// settings
window.toggleSettings = toggleSettings;
window.togglePresent = togglePresent;
window.applyTheme = applyTheme;
window.applyFontSize = applyFontSize;
window.applyWidth = applyWidth;
window.applyLineNumbers = applyLineNumbers;
window.applyHeader = applyHeader;
window.applyExecMode = applyExecMode;
window.applyRunOnLoad = applyRunOnLoad;
window.applyShowToggle = applyShowToggle;
window.applyGlobalExecMode = applyGlobalExecMode;
window.applyGlobalRunOnLoad = applyGlobalRunOnLoad;

// update
window.toggleUpdate = toggleUpdate;
window.checkForUpdate = checkForUpdate;
window.applyOnlineUpdate = applyOnlineUpdate;
window.proceedUpdate = proceedUpdate;
window.cancelUpdate = cancelUpdate;
window.updateFromFile = updateFromFile;

// save
window.saveNotebook = saveNotebook;
window.savePackedNotebook = savePackedNotebook;
window.setSaveMode = setSaveMode;
window.toggleSaveTray = toggleSaveTray;
window.exportAsTxt = exportAsTxt;

// exec
window.runAll = runAll;

// ui
window.insertAt = insertAt;

// find
window.openFind = openFind;
window.closeFind = closeFind;

// stdlib
window.__auditable_registerProvider = registerProvider;

// keyboard / toolbar
window.addCellWithUndo = addCellWithUndo;
window.deleteCellWithUndo = deleteCellWithUndo;
window.runSelectedCell = runSelectedCell;
window.toggleToolbarMenu = toggleToolbarMenu;
window.toggleAddTray = toggleAddTray;
window.toggleMoreTray = toggleMoreTray;
window.showInsertPicker = showInsertPicker;
window.toggleTypePicker = toggleTypePicker;
window.collapseAll = collapseAll;
window.expandAll = expandAll;
window.newNotebook = newNotebook;

// -- init.js --

// ── INIT ──

(function init() {
  // detect packed format (meta tag injected by loader)
  const packedMeta = document.querySelector('meta[name="auditable-packed"]');
  if (packedMeta) {
    packedMeta.remove();
    setBadge('packed', 'packed', 'toolbar-badge toolbar-badge-packed');
    setSaveMode('packed');
  }

  if (!loadFromEmbed()) {
    addCell('md', '');
    addCell('code', '');
  }
  S.initialized = true;
})();

// ── AF BRIDGE ──
// When running inside AF shell (iframe), establish postMessage communication.
// No-op when running standalone (window.parent === window).
//
// Message protocol (notebook ↔ AF shell):
//   af:ready          → sent on init with { title }
//   af:serialize      ← received to trigger saveNotebook()
//   af:saved          ← received after save (shows "saved" status)
//   af:setTitle       ← received to update docTitle input
//   af:resize         ← received when iframe becomes visible (recalc textareas)
//   af:titleChanged   → sent when user edits the title
//   af:fileRequest    → sent to request file picker { id, accept }
//   af:fileResult     ← received with picked file { id, file }
//   af:download       → sent to request download { data, filename, mimeType }
//   af:dirty          → sent when notebook has unsaved changes

(function afBridge() {
  if (window.parent === window) return;
  window.__AF_BRIDGE__ = true;

  // register AF-specific providers for file/download
  registerProvider('file', (accept) => {
    return new Promise((resolve) => {
      const id = 'af_file_' + Date.now();
      function handler(e) {
        if (e.data?.type === 'af:fileResult' && e.data.payload?.id === id) {
          window.removeEventListener('message', handler);
          resolve(e.data.payload.file);
        }
      }
      window.addEventListener('message', handler);
      window.parent.postMessage({ type: 'af:fileRequest', payload: { id, accept } }, '*');
    });
  });

  registerProvider('download', (data, filename, mimeType) => {
    const str = typeof data === 'string' ? data : JSON.stringify(data, null, 2);
    const mime = mimeType || (typeof data === 'string' ? 'text/plain' : 'application/json');
    window.parent.postMessage({
      type: 'af:download',
      payload: { data: str, filename, mimeType: mime }
    }, '*');
  });

  const title = document.getElementById('docTitle')?.value || 'untitled';
  window.parent.postMessage({ type: 'af:ready', payload: { title } }, '*');

  window.addEventListener('message', (e) => {
    const msg = e.data;
    if (!msg?.type) return;
    if (msg.type === 'af:serialize') saveNotebook();
    else if (msg.type === 'af:saved') setMsg('saved', 'ok');
    else if (msg.type === 'af:setTitle') {
      const input = document.getElementById('docTitle');
      if (input && msg.payload?.title) input.value = msg.payload.title;
    } else if (msg.type === 'af:resize') {
      // recalculate textarea heights after becoming visible
      document.querySelectorAll('textarea').forEach(ta => {
        ta.style.height = 'auto';
        ta.style.height = ta.scrollHeight + 'px';
        const hl = ta.parentElement?.querySelector('.highlight-layer');
        if (hl) hl.style.height = ta.style.height;
      });
    }
  });

  document.getElementById('docTitle')?.addEventListener('input', () => {
    window.parent.postMessage({
      type: 'af:titleChanged',
      payload: { title: document.getElementById('docTitle').value }
    }, '*');
  });
})();
</script>
</body>
<!-- good luck out there -->
</html>
