<!DOCTYPE html>
<!-- auditable — a reactive computational notebook in a single HTML file -->
<!-- https://github.com/endarthur/auditable — MIT license -->
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Auditable — atra — Wasm kernels</title>
<style>
:root {
  --bg: #0a0a0a;
  --bg1: #111;
  --bg2: #1a1a1a;
  --border: #222;
  --border-hi: #333;
  --fg: #aaa;
  --fg-dim: #555;
  --fg-bright: #ccc;
  --accent: #c89b3c;
  --accent-dim: #8a6c2a;
  --err: #a33;
  --ok: #3a7;
  --mono: 'Courier New', Courier, monospace;
  --editor-font-size: 13px;
}

* { margin: 0; padding: 0; box-sizing: border-box; }

/* scrollbar */
::-webkit-scrollbar { width: 6px; height: 6px; }
::-webkit-scrollbar-track { background: var(--bg); }
::-webkit-scrollbar-thumb { background: var(--border-hi); border-radius: 0; }
::-webkit-scrollbar-thumb:hover { background: var(--fg-dim); }
textarea::-webkit-scrollbar-thumb { background: var(--border); }
@supports (scrollbar-color: auto) {
  * { scrollbar-color: var(--border-hi) var(--bg); scrollbar-width: thin; }
}

html, body {
  background: var(--bg);
  color: var(--fg);
  font-family: var(--mono);
  font-size: 13px;
  line-height: 1.5;
  min-height: 100vh;
}

/* ── TOOLBAR ── */
.toolbar {
  position: sticky;
  top: 0;
  z-index: 100;
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 6px 12px;
  background: var(--bg);
  border-bottom: 1px solid var(--border);
}

.toolbar-title {
  font-size: 11px;
  letter-spacing: 3px;
  text-transform: uppercase;
  color: var(--accent);
  opacity: 0.8;
  user-select: none;
}

.toolbar-sep {
  width: 1px;
  height: 16px;
  background: var(--border);
  margin: 0 4px;
}

.toolbar-filename {
  font-size: 12px;
  color: var(--fg-dim);
  flex: 1;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.toolbar-filename input {
  background: none;
  border: none;
  border-bottom: 1px solid transparent;
  color: var(--fg);
  font-family: var(--mono);
  font-size: 12px;
  outline: none;
  width: 200px;
}
.toolbar-filename input:focus {
  border-bottom-color: var(--accent-dim);
}

button {
  background: var(--bg2);
  border: 1px solid var(--border);
  color: var(--fg-dim);
  font-family: var(--mono);
  font-size: 10px;
  letter-spacing: 1px;
  text-transform: uppercase;
  padding: 4px 10px;
  cursor: pointer;
  transition: border-color 0.15s, color 0.15s;
}
button:hover {
  border-color: var(--border-hi);
  color: var(--fg);
}
button.accent {
  border-color: var(--accent-dim);
  color: var(--accent);
}
button.accent:hover {
  border-color: var(--accent);
}

/* ── TOOLBAR BADGES ── */
.toolbar-badges {
  display: inline-flex;
  gap: 4px;
  margin-left: 6px;
  align-items: center;
}
.toolbar-badge {
  font-size: 9px;
  letter-spacing: 0.5px;
  padding: 1px 4px;
  border-radius: 2px;
  user-select: none;
  opacity: 0.85;
}
.toolbar-badge-signed {
  color: var(--ok);
  border: 1px solid color-mix(in srgb, var(--ok) 40%, transparent);
}
.toolbar-badge-packed {
  color: var(--fg-dim);
  border: 1px solid var(--border);
}

/* ── SPLIT SAVE BUTTON ── */
.save-split {
  display: inline-flex;
  position: relative;
}
.save-split button:first-child {
  border-right: none;
  border-radius: 3px 0 0 3px;
}
.save-caret {
  border-radius: 0 3px 3px 0 !important;
  padding: 4px 4px !important;
  font-size: 10px;
}
.save-tray {
  display: none;
  position: absolute;
  right: 0;
  top: 100%;
  margin-top: 4px;
  background: var(--bg);
  border: 1px solid var(--border);
  z-index: 100;
  min-width: 120px;
}
.save-tray.open { display: flex; flex-direction: column; }
.save-tray button {
  border: none;
  border-bottom: 1px solid var(--border);
  text-align: left;
  padding: 6px 10px;
  white-space: nowrap;
  font-size: 12px;
}
.save-tray button:last-child { border-bottom: none; }
.save-tray button:hover { background: var(--bg-hi); }

/* ── TRANSPORT CONTROLS ── */
.transport {
  display: inline-flex;
  border: 1px solid var(--border);
}
.transport button {
  border: none;
  border-right: 1px solid var(--border);
  padding: 4px 8px;
}
.transport button:last-child { border-right: none; }
.transport button.autorun-on {
  background: #33aa77;
  color: #111;
}
.transport button.autorun-off {
  background: #dd4444;
  color: #111;
}

.toolbar-right {
  margin-left: auto;
  display: flex;
  align-items: center;
  gap: 8px;
}

/* ── TOOLBAR OVERFLOW MENU ── */
.toolbar-overflow {
  position: relative;
  display: inline-block;
}
.toolbar-overflow-tray {
  display: none;
  position: absolute;
  top: 100%;
  right: 0;
  background: var(--bg1);
  border: 1px solid var(--border);
  z-index: 200;
  flex-direction: column;
  min-width: 140px;
}
.toolbar-overflow-tray button {
  border: none;
  border-bottom: 1px solid var(--border);
  text-align: left;
  padding: 8px 12px;
  background: var(--bg1);
  white-space: nowrap;
}
.toolbar-overflow-tray button:last-child { border-bottom: none; }
.toolbar-overflow-tray button:hover { background: var(--bg2); color: var(--fg-bright); }
.toolbar-overflow.open .toolbar-overflow-tray { display: flex; }

/* ── BOTTOM ACTION BAR ── */
.action-bar { display: none; }

/* ── ACTION BAR TRAYS ── */
.action-add-tray,
.action-more-tray {
  display: none;
  position: absolute;
  bottom: 100%;
  background: var(--bg1);
  border: 1px solid var(--border);
  flex-direction: column;
  z-index: 200;
}
.action-add-tray { left: 0; min-width: 120px; }
.action-more-tray { right: 0; min-width: 120px; }
.action-add-tray.open,
.action-more-tray.open { display: flex; }
.action-add-tray button,
.action-more-tray button {
  min-height: 48px;
  border: none;
  border-bottom: 1px solid var(--border);
  text-align: left;
  padding: 8px 16px;
  background: var(--bg1);
  color: var(--fg);
  font-family: var(--mono);
  font-size: 12px;
  letter-spacing: 1px;
  text-transform: uppercase;
}
.action-add-tray button:last-child,
.action-more-tray button:last-child { border-bottom: none; }
.action-add-tray button:hover,
.action-more-tray button:hover { background: var(--bg2); color: var(--fg-bright); }
.action-more-tray button.active-mode { color: var(--accent); }

/* ── CELL INSERT / CONVERT BUTTONS (touch only) ── */
.cell-insert { display: none; }
.cell-convert { display: none; }

/* ── CELL TYPE PICKER ── */
.cell-type-picker {
  display: none;
  gap: 2px;
  padding: 2px 8px 4px;
}
.cell-type-picker.open { display: flex; }
.cell-type-picker button {
  font-size: 9px;
  padding: 2px 8px;
  background: var(--bg2);
  border: 1px solid var(--border);
  color: var(--fg-dim);
  font-family: var(--mono);
  letter-spacing: 1px;
  text-transform: uppercase;
}
.cell-type-picker button:hover {
  border-color: var(--accent-dim);
  color: var(--accent);
}

/* ── CELL INSERT PICKER ── */
.cell-insert-picker {
  display: none;
  gap: 2px;
  position: absolute;
  background: var(--bg1);
  border: 1px solid var(--border);
  padding: 4px;
  z-index: 200;
}
.cell-insert-picker.open { display: flex; }
.cell-insert-picker button {
  font-size: 9px;
  padding: 4px 8px;
  background: var(--bg2);
  border: 1px solid var(--border);
  color: var(--fg-dim);
  font-family: var(--mono);
  letter-spacing: 1px;
  text-transform: uppercase;
  min-height: 36px;
}
.cell-insert-picker button:hover {
  border-color: var(--accent-dim);
  color: var(--accent);
}

/* ── TOOLBAR STATUS (mobile cell count) ── */
.toolbar-status { display: none; }

/* ── NOTEBOOK ── */
.notebook {
  max-width: 860px;
  margin: 0 auto;
  padding: 16px 12px 120px;
}

/* ── CELL ── */
.cell {
  position: relative;
  margin: 6px 0;
  border-left: 2px solid transparent;
  transition: border-color 0.15s;
}
.cell:hover {
  border-left-color: var(--border-hi);
}
.cell.selected {
  border-left-color: var(--accent);
}
.cell.selected .cell-header {
  opacity: 1;
}
.cell.manual .cell-type::after {
  content: ' \00b7 manual';
  color: var(--accent-dim);
}
.cell.stale {
  border-left-color: var(--accent-dim);
}
.cell.error {
  border-left-color: var(--err);
}
.cell.fresh {
  border-left-color: var(--ok);
  transition: border-color 0.5s;
}

/* cell header — type label + controls */
.cell-header {
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 2px 8px;
  opacity: 0;
  transition: opacity 0.15s;
  user-select: none;
}
.cell:hover .cell-header,
.cell:focus-within .cell-header {
  opacity: 1;
}

.cell.collapsed .cell-code,
.cell.collapsed .cell-md-edit,
.cell.collapsed .cell-css-edit,
.cell.collapsed .cell-html-edit {
  display: none !important;
}
.cell.collapsed .cell-type::before {
  content: '\25b8 ';
}
.cell:not(.collapsed) .cell-type::before {
  content: '\25be ';
}
.cell-type {
  cursor: pointer;
  user-select: none;
  font-size: 9px;
  letter-spacing: 2px;
  text-transform: uppercase;
  color: var(--fg-dim);
}
.cell[data-type="code"] .cell-type { color: #7aabcf; }
.cell[data-type="css"]  .cell-type { color: #d4955a; }
.cell[data-type="html"] .cell-type { color: #6dbfb8; }
.cell[data-type="md"]   .cell-type { color: var(--fg-dim); }

.cell-btn {
  background: none;
  border: none;
  color: var(--fg-dim);
  font-family: var(--mono);
  font-size: 10px;
  padding: 0 4px;
  cursor: pointer;
}
.cell-btn:hover { color: var(--fg); }
.cell-btn.del:hover { color: var(--err); }

/* ── CODE CELL ── */
.cell-code {
  position: relative;
}

.editor-wrap {
  --gutter: 36px;
  position: relative;
  overflow: hidden;
}

.line-numbers {
  position: absolute;
  top: 0; left: 0; bottom: 0;
  width: var(--gutter);
  padding: 8px 4px 8px 0;
  font-family: var(--mono);
  font-size: var(--editor-font-size);
  line-height: 1.5;
  text-align: right;
  color: var(--fg-dim);
  background: var(--bg1);
  border-right: 1px solid var(--border);
  border-top: 1px solid var(--border);
  border-bottom: 1px solid var(--border);
  border-left: 1px solid var(--border);
  overflow: hidden;
  z-index: 3;
  pointer-events: none;
  white-space: pre;
  box-sizing: border-box;
}

:root.hide-line-numbers .line-numbers { display: none; }
:root.hide-line-numbers .editor-wrap { --gutter: 0px; }

.cell-code textarea {
  display: block;
  width: 100%;
  background: transparent;
  border: 1px solid var(--border);
  color: var(--fg-bright);
  caret-color: var(--fg-bright);
  font-family: var(--mono);
  font-size: var(--editor-font-size);
  line-height: 1.5;
  padding: 8px 10px 8px calc(var(--gutter) + 10px);
  resize: vertical;
  min-height: 38px;
  outline: none;
  tab-size: 2;
  white-space: pre;
  overflow-x: auto;
  position: relative;
  z-index: 2;
  -webkit-text-fill-color: transparent;
}
.cell-code textarea::selection {
  -webkit-text-fill-color: var(--fg-bright);
  background: rgba(200,155,60,0.25);
}
.cell-code textarea:focus + .highlight-layer {
  border-color: var(--border-hi);
}
.cell-code textarea:focus ~ .line-numbers {
  border-color: var(--border-hi);
}

.highlight-layer {
  position: absolute;
  top: 0; left: 0; right: 0; bottom: 0;
  background: var(--bg1);
  border: 1px solid var(--border);
  padding: 8px 10px 8px calc(var(--gutter) + 10px);
  font-family: var(--mono);
  font-size: var(--editor-font-size);
  line-height: 1.5;
  tab-size: 2;
  white-space: pre;
  overflow: hidden;
  z-index: 1;
  pointer-events: none;
  color: var(--fg-bright);
}

/* syntax tokens */
.hl-kw { color: #7a9ec7; }
.hl-str { color: var(--accent); }
.hl-num { color: #8cb878; }
.hl-cmt { color: #555; font-style: italic; }
.hl-fn { color: #c4a6d0; }
.hl-const { color: #d09870; }
.hl-op { color: #888; }
.hl-punc { color: #666; }

/* CSS syntax tokens */
.hl-atrule { color: #7aabcf; }
.hl-prop { color: #7aabcf; }
.hl-sel { color: #d4955a; }
.hl-color { color: var(--accent); }
.hl-important { color: #d4555a; font-weight: bold; }

/* HTML syntax tokens */
.hl-tag { color: #6dbfb8; }
.hl-attr { color: #7aabcf; }
.hl-expr { color: var(--accent); }

.hl-swatch {
  display: inline-block;
  width: 10px;
  height: 10px;
  border: 1px solid var(--border-hi);
  vertical-align: middle;
  margin-right: 2px;
  cursor: pointer;
  pointer-events: auto;
}

.cell-output {
  padding: 4px 10px;
  min-height: 0;
  font-size: 12px;
  color: var(--fg);
  white-space: pre-wrap;
  word-break: break-all;
}
.cell-output:empty {
  display: none;
}
.cell-output.error {
  color: var(--err);
}

.cell-output canvas {
  max-width: 100%;
  display: block;
  margin: 4px 0;
}

.cell-output table {
  border-collapse: collapse;
  font-size: 11px;
  margin: 4px 0;
}
.cell-output table th,
.cell-output table td {
  border: 1px solid var(--border);
  padding: 2px 8px;
}
.cell-output table th {
  color: var(--accent);
  font-weight: normal;
  text-transform: uppercase;
  font-size: 9px;
  letter-spacing: 1px;
}

/* ── CSS CELL ── */
.cell-css-view {
  padding: 6px 10px;
  color: var(--fg-dim);
  cursor: text;
  min-height: 24px;
  font-size: 11px;
  font-style: italic;
}
.cell-css-view:empty::before {
  content: '(empty stylesheet)';
}

.cell-css-edit textarea {
  display: block;
  width: 100%;
  background: transparent;
  border: 1px solid var(--border);
  color: var(--fg-bright);
  caret-color: var(--fg-bright);
  font-family: var(--mono);
  font-size: var(--editor-font-size);
  line-height: 1.5;
  padding: 8px 10px 8px calc(var(--gutter) + 10px);
  resize: vertical;
  min-height: 38px;
  outline: none;
  tab-size: 2;
  white-space: pre;
  overflow-x: auto;
  position: relative;
  z-index: 2;
  -webkit-text-fill-color: transparent;
}
.cell-css-edit textarea::selection {
  -webkit-text-fill-color: var(--fg-bright);
  background: rgba(200,155,60,0.25);
}
.cell-css-edit textarea:focus + .highlight-layer {
  border-color: var(--border-hi);
}
.cell-css-edit textarea:focus ~ .line-numbers {
  border-color: var(--border-hi);
}

/* ── HTML CELL ── */
.cell-html-view {
  padding: 6px 10px;
  color: var(--fg);
  cursor: text;
  min-height: 24px;
}
.cell-html-view:empty::before {
  content: '(empty html template)';
  color: var(--fg-dim);
  font-style: italic;
  font-size: 11px;
}
.cell-html-edit textarea {
  display: block;
  width: 100%;
  background: transparent;
  border: 1px solid var(--border);
  color: var(--fg-bright);
  caret-color: var(--fg-bright);
  font-family: var(--mono);
  font-size: var(--editor-font-size);
  line-height: 1.5;
  padding: 8px 10px 8px calc(var(--gutter) + 10px);
  resize: vertical;
  min-height: 38px;
  outline: none;
  tab-size: 2;
  white-space: pre;
  overflow-x: auto;
  position: relative;
  z-index: 2;
  -webkit-text-fill-color: transparent;
}
.cell-html-edit textarea::selection {
  -webkit-text-fill-color: var(--fg-bright);
  background: rgba(200,155,60,0.25);
}
.cell-html-edit textarea:focus + .highlight-layer {
  border-color: var(--border-hi);
}
.cell-html-edit textarea:focus ~ .line-numbers {
  border-color: var(--border-hi);
}

/* ── MARKDOWN CELL ── */
.cell-md-view {
  padding: 6px 10px;
  color: var(--fg);
  cursor: text;
  min-height: 24px;
}
.cell-md-view:empty::before {
  content: '(empty markdown cell)';
  color: var(--fg-dim);
  font-style: italic;
  font-size: 11px;
}
.cell-md-view h1, .cell-md-view h2, .cell-md-view h3 {
  color: var(--fg-bright);
  font-weight: normal;
  margin: 4px 0;
}
.cell-md-view h1 { font-size: 18px; letter-spacing: 2px; }
.cell-md-view h2 { font-size: 15px; letter-spacing: 1px; color: var(--accent); }
.cell-md-view h3 { font-size: 13px; }
.cell-md-view p { margin: 4px 0; }
.cell-md-view code {
  background: var(--bg2);
  padding: 1px 4px;
  font-size: 12px;
}
.cell-md-view strong { color: var(--fg-bright); }
.cell-md-view em { font-style: italic; }
.cell-md-view a { color: var(--accent); }
.cell-md-view table {
  border-collapse: collapse;
  font-size: 11px;
  margin: 4px 0;
}
.cell-md-view table th,
.cell-md-view table td {
  border: 1px solid var(--border);
  padding: 2px 8px;
}
.cell-md-view table th {
  color: var(--accent);
  font-weight: normal;
  text-transform: uppercase;
  font-size: 9px;
  letter-spacing: 1px;
}

.cell-md-edit textarea {
  display: block;
  width: 100%;
  background: var(--bg1);
  border: 1px solid var(--border);
  color: var(--fg-bright);
  font-family: var(--mono);
  font-size: var(--editor-font-size);
  line-height: 1.5;
  padding: 8px 10px;
  resize: vertical;
  min-height: 38px;
  outline: none;
}

/* ── PRESENTATION MODE ── */
body.presenting .toolbar { display: none; }
body.presenting .cell-header { display: none; }
body.presenting .cell-code { display: none; }
body.presenting .cell-md-edit { display: none !important; }
body.presenting .cell-css-edit { display: none; }
body.presenting .cell-css-view { display: none; }
body.presenting .cell-html-edit { display: none !important; }
body.presenting .cell { border-left: none; margin: 0; }
body.presenting .cell:hover { border-left: none; }
body.presenting .insert-bar { display: none; }
body.presenting .notebook { max-width: 900px; padding-top: 40px; }
body.presenting .statusbar { display: none; }
body.presenting .present-hidden { display: none; }
body.presenting .present-exit {
  display: block;
  position: fixed;
  top: 12px;
  right: 12px;
  z-index: 200;
}
.present-exit { display: none; }

/* ── INSERT BAR (between cells) ── */
.insert-bar {
  height: 16px;
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  margin: -6px 0;
}
.insert-bar::before {
  content: '';
  position: absolute;
  left: 20px;
  right: 20px;
  top: 50%;
  height: 1px;
  background: var(--border);
  opacity: 0;
  transition: opacity 0.15s;
}
.insert-bar:hover::before { opacity: 1; }
.insert-bar .insert-btns {
  display: flex;
  gap: 4px;
  opacity: 0;
  transition: opacity 0.15s;
  position: relative;
  z-index: 10;
}
.insert-bar:hover .insert-btns { opacity: 1; }
.insert-bar .insert-btns button {
  font-size: 9px;
  padding: 1px 8px;
  background: var(--bg);
  border: 1px solid var(--border);
  color: var(--fg-dim);
}
.insert-bar .insert-btns button:hover {
  border-color: var(--accent-dim);
  color: var(--accent);
}

/* ── ADD CELL BAR ── */
.add-bar {
  display: flex;
  justify-content: center;
  gap: 8px;
  padding: 6px 0;
  opacity: 0;
  transition: opacity 0.15s;
}
.notebook:hover .add-bar,
.add-bar.visible {
  opacity: 0.5;
}
.add-bar:hover {
  opacity: 1 !important;
}

/* ── WIDGET CLASSES ── */
.cell-widget {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 2px 0;
  font-size: 12px;
  color: var(--fg-dim);
}
.cell-widget-label {
  min-width: 80px;
  font-size: 10px;
  letter-spacing: 1px;
  text-transform: uppercase;
  color: var(--fg-dim);
}
.cell-widget input[type="range"] {
  flex: 1;
  accent-color: var(--accent);
  max-width: 200px;
}
.cell-widget select {
  background: var(--bg2);
  border: 1px solid var(--border);
  color: var(--fg-bright);
  font-family: var(--mono);
  font-size: 12px;
  padding: 2px 4px;
}
.cell-widget input[type="checkbox"] {
  accent-color: var(--accent);
}
.cell-widget input[type="text"] {
  background: var(--bg2);
  border: 1px solid var(--border);
  color: var(--fg-bright);
  font-family: var(--mono);
  font-size: 12px;
  padding: 2px 6px;
  flex: 1;
  max-width: 200px;
}
.cell-widget-val {
  min-width: 40px;
  text-align: right;
  color: var(--fg-bright);
  font-size: 12px;
}

/* ── STATUS BAR ── */
.statusbar {
  position: fixed;
  bottom: 0;
  left: 0;
  right: 0;
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 4px 12px;
  background: var(--bg);
  border-top: 1px solid var(--border);
  font-size: 10px;
  color: var(--fg-dim);
  letter-spacing: 1px;
  z-index: 100;
}
.statusbar .status-size { color: var(--fg-dim); }
.statusbar .status-cells { color: var(--fg-dim); }
.statusbar .status-msg { flex: 1; text-align: right; }
.statusbar .status-msg.ok { color: var(--ok); }
.statusbar .status-msg.warn { color: var(--accent); }
.statusbar .status-msg.err { color: var(--err); }
.statusbar .status-attr { margin-left: auto; display: flex; align-items: center; gap: 6px; }
.statusbar .status-attr a {
  color: var(--fg-dim);
  text-decoration: none;
  transition: color 0.2s;
}
.statusbar .status-attr a:hover { color: var(--accent); }
.statusbar .status-attr svg { vertical-align: middle; }

/* ── EMPTY STATE ── */
.empty-state {
  text-align: center;
  padding: 80px 20px;
  color: var(--fg-dim);
}
.empty-state .logo {
  font-size: 11px;
  letter-spacing: 4px;
  text-transform: uppercase;
  color: var(--accent);
  margin-bottom: 16px;
}
.empty-state .tagline {
  font-size: 11px;
  margin-bottom: 24px;
}

.help-overlay {
  display: none;
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.85);
  z-index: 1000;
  overflow-y: auto;
  padding: 40px;
}
.help-overlay.visible { display: flex; justify-content: center; }
.help-content {
  position: relative;
  max-width: 600px;
  width: 100%;
  color: var(--fg);
  font-family: var(--mono);
  font-size: 13px;
  line-height: 1.8;
}
.help-content h2 {
  color: var(--accent);
  font-size: 14px;
  letter-spacing: 2px;
  text-transform: uppercase;
  margin: 24px 0 8px 0;
  border-bottom: 1px solid var(--border);
  padding-bottom: 4px;
}
.help-content h2:first-child { margin-top: 0; }
.help-row {
  display: flex;
  justify-content: space-between;
  padding: 2px 0;
}
.help-key {
  background: var(--bg2);
  border: 1px solid var(--border);
  border-radius: 3px;
  padding: 0 6px;
  font-size: 11px;
  color: var(--fg-bright);
  min-width: 80px;
  text-align: center;
  display: inline-block;
}
.help-desc { color: var(--fg); }
.help-close {
  color: var(--accent-dim);
  font-size: 11px;
  text-align: center;
  margin-top: 24px;
  letter-spacing: 1px;
}
.help-close-btn {
  position: absolute;
  top: 0;
  right: 0;
  background: none;
  border: 1px solid var(--border);
  color: var(--fg-dim);
  font-size: 20px;
  width: 44px;
  height: 44px;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 0;
  cursor: pointer;
  text-transform: none;
  letter-spacing: 0;
}
.help-close-btn:hover {
  border-color: var(--err);
  color: var(--err);
}

/* ── SETTINGS PANEL ── */
.settings-overlay {
  display: none;
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.5);
  z-index: 1000;
}
.settings-overlay.visible { display: block; }
.settings-panel {
  display: none;
  position: fixed;
  top: 0;
  right: 0;
  bottom: 0;
  width: 280px;
  max-width: 90vw;
  background: var(--bg1);
  border-left: 1px solid var(--border);
  padding: 20px;
  overflow-y: auto;
  z-index: 1001;
  font-family: var(--mono);
  font-size: 12px;
  color: var(--fg);
}
.settings-close {
  position: absolute;
  top: 12px;
  right: 12px;
  background: none;
  border: 1px solid var(--border);
  color: var(--fg-dim);
  font-size: 18px;
  width: 32px;
  height: 32px;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 0;
  cursor: pointer;
  text-transform: none;
  letter-spacing: 0;
}
.settings-close:hover {
  border-color: var(--err);
  color: var(--err);
}

.settings-panel h2 {
  color: var(--accent);
  font-size: 11px;
  letter-spacing: 2px;
  text-transform: uppercase;
  margin: 20px 0 10px 0;
}
.settings-panel h2:first-child { margin-top: 0; }
.settings-row {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 6px 0;
}
.settings-row label { color: var(--fg-dim); font-size: 11px; }
.settings-row select,
.settings-row input[type="range"] {
  background: var(--bg2);
  border: 1px solid var(--border);
  color: var(--fg-bright);
  font-family: var(--mono);
  font-size: 11px;
  padding: 2px 4px;
}
.settings-row input[type="range"] {
  accent-color: var(--accent);
  width: 100px;
}
.settings-val {
  min-width: 30px;
  text-align: right;
  color: var(--fg-bright);
  font-size: 11px;
}

/* ── SETTINGS DESCRIPTIONS ── */
.settings-desc {
  color: var(--fg-dim);
  font-size: 10px;
  line-height: 1.5;
  padding: 4px 0 8px;
}
.settings-desc strong {
  color: var(--fg);
}

/* ── HIDE RUN TOGGLE ── */
html.hide-run-toggle #autorunBtn,
html.hide-run-toggle #autorunBtnMobile { display: none; }

/* ── MODULE LIST (settings panel) ── */
.module-row {
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 4px 0;
  font-size: 11px;
}
.module-url {
  flex: 1;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  color: var(--fg);
}
.module-info {
  color: var(--fg-dim);
  white-space: nowrap;
  font-size: 10px;
}
.module-remove {
  background: none;
  border: none;
  color: var(--fg-dim);
  font-size: 14px;
  padding: 0 2px;
  cursor: pointer;
  line-height: 1;
  text-transform: none;
  letter-spacing: 0;
}
.module-remove:hover { color: var(--err); }
.module-total {
  padding: 4px 0;
  font-size: 10px;
  color: var(--fg-dim);
  border-top: 1px solid var(--border);
  text-align: right;
}
.module-empty {
  color: var(--fg-dim);
  font-size: 11px;
  font-style: italic;
  padding: 4px 0;
}
/* ── UPDATE PANEL ── */
.update-overlay {
  display: none;
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.5);
  z-index: 1000;
}
.update-overlay.visible { display: block; }
.update-panel {
  display: none;
  position: fixed;
  top: 0;
  right: 0;
  bottom: 0;
  width: 280px;
  max-width: 90vw;
  background: var(--bg1);
  border-left: 1px solid var(--border);
  padding: 20px;
  overflow-y: auto;
  z-index: 1001;
  font-family: var(--mono);
  font-size: 12px;
  color: var(--fg);
}
.update-panel h2 {
  color: var(--accent);
  font-size: 11px;
  letter-spacing: 2px;
  text-transform: uppercase;
  margin: 0 0 12px 0;
}
.update-panel .settings-row {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 6px 0;
}
.update-panel .settings-row label { color: var(--fg-dim); font-size: 11px; }
.update-actions {
  display: flex;
  flex-direction: column;
  gap: 6px;
  padding: 8px 0;
}
.update-actions button {
  width: 100%;
  padding: 8px 10px;
}
.update-status {
  font-size: 11px;
  padding: 8px 0;
  line-height: 1.5;
}
.update-status strong { color: var(--fg-bright); }
.update-status button {
  display: block;
  width: 100%;
  margin-top: 8px;
  padding: 8px 10px;
  border-color: var(--accent-dim);
  color: var(--accent);
}
.update-status button:hover {
  border-color: var(--accent);
}
.update-ok { color: var(--ok); }
.update-err { color: var(--err); }
.update-warn { color: var(--accent); }
.update-available { color: var(--fg); }
.update-notes {
  color: var(--fg-dim);
  font-size: 11px;
  padding: 6px 0;
  max-height: 120px;
  overflow-y: auto;
  line-height: 1.4;
}
.update-notes p { margin: 0 0 4px; }
.update-notes ul { margin: 2px 0; padding-left: 16px; }
.update-notes li { margin: 1px 0; }
.update-notes h1, .update-notes h2, .update-notes h3 { font-size: 11px; margin: 4px 0 2px; color: var(--fg); }
.update-confirm {
  display: flex;
  gap: 8px;
  padding: 6px 0;
}
.update-confirm button { width: auto; }
.update-sig {
  font-size: 11px;
}
.update-key-truncated {
  cursor: pointer;
}
.update-key-truncated:hover {
  color: var(--accent);
}
.update-key-expanded {
  word-break: break-all;
  user-select: all;
  cursor: pointer;
  color: var(--fg-bright);
}
/* ── UPDATE BUTTON IN OVERFLOW TRAY ── */
.toolbar-update-btn {
  color: var(--accent) !important;
}

.settings-about {
  margin-top: 24px;
  padding-top: 12px;
  border-top: 1px solid var(--border);
  font-size: 11px;
  color: var(--fg-dim);
  display: flex;
  flex-direction: column;
  gap: 2px;
}
.settings-about a {
  color: var(--accent);
  text-decoration: none;
}
.settings-about a:hover { text-decoration: underline; }

/* ── FIND BAR ── */
.find-bar {
  display: none;
  flex-direction: column;
  position: sticky;
  top: 33px;
  z-index: 99;
  float: right;
  max-width: 400px;
  width: 100%;
  background: var(--bg1);
  border: 1px solid var(--border);
  border-top: none;
  padding: 6px 8px;
  gap: 4px;
}
.find-row {
  display: flex;
  align-items: center;
  gap: 4px;
}
.find-replace-row {
  display: none;
  align-items: center;
  gap: 4px;
}
.find-bar.show-replace .find-replace-row { display: flex; }
.find-bar input[type="text"] {
  flex: 1;
  background: var(--bg2);
  border: 1px solid var(--border);
  color: var(--fg-bright);
  font-family: var(--mono);
  font-size: 12px;
  padding: 4px 8px;
  outline: none;
  min-width: 0;
}
.find-bar input[type="text"]:focus {
  border-color: var(--border-hi);
}
.find-count {
  font-size: 10px;
  color: var(--fg-dim);
  white-space: nowrap;
  min-width: 50px;
  text-align: center;
  letter-spacing: 1px;
}
.find-bar button {
  padding: 3px 8px;
  font-size: 10px;
  min-width: 28px;
}
.find-bar button.active {
  color: var(--accent);
  border-color: var(--accent-dim);
}
body.presenting .find-bar { display: none !important; }

/* ── SEARCH OVERLAY ── */
.search-overlay {
  position: absolute;
  top: 0; left: 0; right: 0; bottom: 0;
  padding: 8px 10px 8px calc(var(--gutter) + 10px);
  font-family: var(--mono);
  font-size: var(--editor-font-size);
  line-height: 1.5;
  tab-size: 2;
  white-space: pre;
  overflow: hidden;
  z-index: 1;
  pointer-events: none;
  color: transparent;
  border: 1px solid transparent;
}
.search-overlay-md {
  padding: 8px 10px;
}
.md-search-wrap {
  position: relative;
}
.search-match {
  background: rgba(200,155,60,0.25);
  color: transparent;
}
.search-match-current {
  background: rgba(200,155,60,0.5);
  outline: 1px solid var(--accent);
}

/* ── AUTOCOMPLETE MENU ── */
.ac-menu {
  position: absolute;
  z-index: 10;
  background: #1e1e1e;
  border: 1px solid #444;
  border-radius: 3px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.4);
  max-height: 200px;
  overflow-y: auto;
  font-family: var(--mono);
  font-size: var(--editor-font-size);
  min-width: 120px;
}
.ac-item {
  padding: 2px 8px;
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 6px;
  white-space: nowrap;
}
.ac-item.active,
.ac-item:hover {
  background: rgba(200,155,60,0.2);
}
.ac-kind {
  width: 16px;
  height: 16px;
  border-radius: 2px;
  font-size: 10px;
  text-align: center;
  line-height: 16px;
  flex-shrink: 0;
}
.ac-kind-var, .ac-kind-def { color: #5ca7e4; }
.ac-kind-fn { color: #c89b3c; }
.ac-kind-kw { color: #cc7832; }
.ac-kind-const { color: #9876aa; }
.ac-kind-prop { color: #6a8759; }
.ac-text { color: var(--fg-bright); }
.ac-detail {
  margin-left: auto;
  padding-left: 12px;
  color: var(--fg-dim);
  font-size: 11px;
}
.ac-match { font-weight: bold; }
.ac-sig-hint {
  position: absolute;
  z-index: 10;
  background: #1e1e1e;
  border: 1px solid #444;
  border-radius: 3px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.4);
  padding: 3px 8px;
  font-family: var(--mono);
  font-size: var(--editor-font-size);
  white-space: nowrap;
  display: flex;
  gap: 10px;
  align-items: baseline;
}
.ac-sig-fn { color: var(--fg-bright); }
.ac-sig-active { color: var(--accent); font-weight: bold; text-decoration: underline; }
.ac-sig-desc { color: var(--fg-dim); font-size: 11px; }
:root.light .ac-sig-hint {
  background: #eae8e3;
  border-color: #b0ab9f;
  box-shadow: 0 2px 8px rgba(0,0,0,0.15);
}
:root.light .ac-menu {
  background: #eae8e3;
  border-color: #b0ab9f;
  box-shadow: 0 2px 8px rgba(0,0,0,0.15);
}
:root.light .ac-item.active,
:root.light .ac-item:hover {
  background: rgba(153,107,31,0.15);
}

/* ── WORKSHOP PANEL ── */
.workshop-overlay {
  display: none;
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.3);
  z-index: 900;
}
.workshop-overlay.visible { display: block; }
.workshop-panel {
  position: fixed;
  top: 0;
  right: -380px;
  bottom: 0;
  width: 360px;
  max-width: 90vw;
  background: var(--bg1);
  border-left: 1px solid var(--border);
  z-index: 901;
  display: flex;
  flex-direction: column;
  font-family: var(--mono);
  font-size: 13px;
  color: var(--fg);
  transition: right 0.25s ease;
  overflow: hidden;
}
.workshop-panel.open { right: 0; }
.workshop-tab {
  position: fixed;
  right: 0;
  top: 50%;
  transform: translateY(-50%) rotate(180deg);
  writing-mode: vertical-rl;
  background: var(--bg1);
  border: 1px solid var(--border);
  border-right: none;
  color: var(--accent);
  font-family: var(--mono);
  font-size: 10px;
  letter-spacing: 2px;
  text-transform: uppercase;
  padding: 10px 5px;
  cursor: pointer;
  z-index: 902;
  transition: right 0.25s ease;
}
.workshop-tab:hover { background: var(--bg2); }
.workshop-panel.open ~ .workshop-tab { right: min(360px, 90vw); }
.workshop-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 16px 16px 12px;
  border-bottom: 1px solid var(--border);
}
.workshop-title {
  color: var(--accent);
  font-size: 11px;
  letter-spacing: 2px;
  text-transform: uppercase;
}
.workshop-close {
  background: none;
  border: 1px solid var(--border);
  color: var(--fg-dim);
  font-size: 18px;
  width: 28px; height: 28px;
  display: flex; align-items: center; justify-content: center;
  padding: 0; cursor: pointer;
  text-transform: none;
  letter-spacing: 0;
}
.workshop-close:hover { border-color: var(--err); color: var(--err); }
.workshop-body {
  flex: 1;
  overflow-y: auto;
  padding: 16px;
  line-height: 1.6;
}
.workshop-body h1, .workshop-body h2, .workshop-body h3 {
  color: var(--fg-bright);
  margin: 1em 0 0.5em;
}
.workshop-body h1:first-child, .workshop-body h2:first-child, .workshop-body h3:first-child {
  margin-top: 0;
}
.workshop-body code {
  background: var(--bg2);
  padding: 1px 4px;
  font-size: 0.9em;
}
.workshop-body strong { color: var(--accent); }
.workshop-pips {
  display: flex;
  justify-content: center;
  gap: 6px;
  padding: 8px 16px;
}
.workshop-pip {
  width: 8px; height: 8px;
  border-radius: 50%;
  background: var(--border);
  cursor: pointer;
}
.workshop-pip.done { background: var(--fg-dim); }
.workshop-pip.active { background: var(--accent); }
.workshop-nav {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 12px 16px;
  border-top: 1px solid var(--border);
}
.workshop-nav button {
  background: var(--bg2);
  border: 1px solid var(--border);
  color: var(--fg);
  font-family: var(--mono);
  font-size: 11px;
  padding: 4px 12px;
  cursor: pointer;
}
.workshop-nav button:hover { border-color: var(--accent); color: var(--accent); }
.workshop-nav button:disabled { opacity: 0.3; cursor: default; }
.workshop-nav button:disabled:hover { border-color: var(--border); color: var(--fg); }
.workshop-counter { color: var(--fg-dim); font-size: 11px; }

/* ── LIGHT THEME ── */
:root.light {
  --bg: #f5f4f0;
  --bg1: #eae8e3;
  --bg2: #dedad3;
  --border: #ccc8bf;
  --border-hi: #b0ab9f;
  --fg: #444;
  --fg-dim: #888;
  --fg-bright: #222;
  --accent: #996b1f;
  --accent-dim: #b8924a;
  --err: #c33;
  --ok: #287;
}
:root.light .cell[data-type="code"] .cell-type { color: #4a7a9e; }
:root.light .cell[data-type="css"]  .cell-type { color: #a56e33; }
:root.light .cell[data-type="html"] .cell-type { color: #3d8a83; }
:root.light ::-webkit-scrollbar-track { background: var(--bg); }
:root.light ::-webkit-scrollbar-thumb { background: var(--border-hi); }

/* ── TOUCH / HEADER MODES ── */
@media (hover: none) {
  .insert-bar { display: none; }
  .cell.selected .cell-insert { display: inline; }
  .cell.selected .cell-convert { display: inline; }
  .cell.selected .cell-header {
    gap: 2px;
  }
  .cell.selected .cell-btn {
    min-height: 36px;
    min-width: 36px;
    font-size: 14px;
    display: inline-flex;
    align-items: center;
    justify-content: center;
  }
}

/* compact header: ellipsis indicator, full controls on select */
@media (hover: none) {
  :root:not(.header-always):not(.header-hover) .cell-header > * { display: none; }
  :root:not(.header-always):not(.header-hover) .cell-header {
    opacity: 1;
    justify-content: center;
    padding: 1px 8px;
  }
  :root:not(.header-always):not(.header-hover) .cell-header::before {
    content: '\22ef';
    color: var(--fg-dim);
    font-size: 12px;
    opacity: 0.4;
  }
  :root:not(.header-always):not(.header-hover) .cell.selected .cell-header > * { display: inline; }
  :root:not(.header-always):not(.header-hover) .cell.selected .cell-header::before { display: none; }
  :root:not(.header-always):not(.header-hover) .cell.selected .cell-header {
    justify-content: flex-start;
    padding: 2px 8px;
  }
}

/* header-always: full header visible on all devices */
:root.header-always .cell-header { opacity: 0.6; }
:root.header-always .cell:hover .cell-header,
:root.header-always .cell.selected .cell-header { opacity: 1; }

/* header-compact: forced compact mode on all devices */
:root.header-compact .cell-header > * { display: none; }
:root.header-compact .cell-header {
  opacity: 1 !important;
  justify-content: center;
  padding: 1px 8px;
}
:root.header-compact .cell-header::before {
  content: '\22ef';
  color: var(--fg-dim);
  font-size: 12px;
  opacity: 0.4;
}
:root.header-compact .cell.selected .cell-header > * { display: inline; }
:root.header-compact .cell.selected .cell-header::before { display: none; }
:root.header-compact .cell.selected .cell-header {
  justify-content: flex-start;
  padding: 2px 8px;
}

/* ── RESPONSIVE ── */
@media (max-width: 640px) {
  /* slim top toolbar: filename + cell count only */
  .toolbar {
    flex-wrap: nowrap;
    gap: 4px;
    padding: 6px 8px;
  }
  .toolbar-title { display: none; }
  .toolbar-sep { display: none; }
  .toolbar .toolbar-add, .toolbar .toolbar-secondary { display: none; }
  .transport { display: none; }
  .toolbar-right { display: none; }
  .toolbar-filename { flex: 1; }
  .toolbar-filename input { width: 100%; }
  .toolbar-status {
    display: inline;
    font-size: 10px;
    color: var(--fg-dim);
    white-space: nowrap;
    letter-spacing: 1px;
  }

  /* bottom action bar replaces statusbar */
  .statusbar {
    display: block;
    padding: 0;
    height: 48px;
  }
  .statusbar .status-size,
  .statusbar .status-cells,
  .statusbar .status-msg,
  .statusbar .status-attr { display: none; }
  .action-bar {
    display: grid;
    grid-template-columns: repeat(5, 1fr);
    height: 48px;
  }
  /* wrapper divs for tray positioning must fill their grid cell */
  .action-bar > div {
    position: relative;
    display: flex;
  }
  .action-bar > div > button {
    flex: 1;
  }
  /* style only the 5 action buttons, not tray buttons */
  .action-bar > button,
  .action-bar > div > button {
    min-height: 48px;
    border: none;
    border-right: 1px solid var(--border);
    background: var(--bg);
    font-family: var(--mono);
    font-size: 16px;
    color: var(--fg);
    padding: 0;
    letter-spacing: 0;
    text-transform: none;
  }
  .action-bar > :last-child > button,
  .action-bar > button:last-child { border-right: none; }
  .action-bar > button:active,
  .action-bar > div > button:active { background: var(--bg2); }
  .action-bar > button.autorun-on,
  .action-bar > div > button.autorun-on {
    background: #33aa77;
    color: #111;
  }
  .action-bar > button.autorun-off,
  .action-bar > div > button.autorun-off {
    background: #dd4444;
    color: #111;
  }

  .find-bar { max-width: 100%; float: none; }
  .notebook { padding: 8px 6px 100px; }
  .cell-header { padding: 2px 4px; }
  .settings-close { width: 44px; height: 44px; font-size: 22px; }
  .settings-row { padding: 10px 0; }
  .settings-row select { min-height: 44px; font-size: 14px; padding: 4px 8px; }
  .settings-row input[type="range"] { height: 44px; }
  .help-overlay { padding: 20px 12px; }
  .settings-panel { width: 260px; }
}

</style>
</head>
<body>

<div class="help-overlay" id="helpOverlay">
<div class="help-content">
<button class="help-close-btn" onclick="$('#helpOverlay').classList.remove('visible')">&#x00d7;</button>
<h2>command mode</h2>
<div class="help-row"><span class="help-key">&#x2191; / k</span><span class="help-desc">select cell above</span></div>
<div class="help-row"><span class="help-key">&#x2193; / j</span><span class="help-desc">select cell below</span></div>
<div class="help-row"><span class="help-key">Enter</span><span class="help-desc">edit selected cell</span></div>
<div class="help-row"><span class="help-key">a</span><span class="help-desc">insert cell above</span></div>
<div class="help-row"><span class="help-key">b</span><span class="help-desc">insert cell below</span></div>
<div class="help-row"><span class="help-key">d d</span><span class="help-desc">delete cell</span></div>
<div class="help-row"><span class="help-key">z</span><span class="help-desc">undo delete</span></div>
<div class="help-row"><span class="help-key">c</span><span class="help-desc">copy cell</span></div>
<div class="help-row"><span class="help-key">v</span><span class="help-desc">paste cell below</span></div>
<div class="help-row"><span class="help-key">x</span><span class="help-desc">cut cell</span></div>
<div class="help-row"><span class="help-key">m</span><span class="help-desc">convert to markdown</span></div>
<div class="help-row"><span class="help-key">y</span><span class="help-desc">convert to code</span></div>
<div class="help-row"><span class="help-key">s</span><span class="help-desc">convert to css</span></div>
<div class="help-row"><span class="help-key">t</span><span class="help-desc">convert to html template</span></div>
<div class="help-row"><span class="help-key">h</span><span class="help-desc">collapse / expand cell</span></div>
<div class="help-row"><span class="help-key">l</span><span class="help-desc">toggle line numbers</span></div>
<div class="help-row"><span class="help-key">p</span><span class="help-desc">presentation mode</span></div>

<h2>edit mode</h2>
<div class="help-row"><span class="help-key">Esc</span><span class="help-desc">exit to command mode</span></div>
<div class="help-row"><span class="help-key">Ctrl+Enter</span><span class="help-desc">run cell</span></div>
<div class="help-row"><span class="help-key">Shift+Enter</span><span class="help-desc">run cell + advance</span></div>
<div class="help-row"><span class="help-key">Ctrl+/</span><span class="help-desc">toggle comment</span></div>
<div class="help-row"><span class="help-key">Tab</span><span class="help-desc">indent</span></div>
<div class="help-row"><span class="help-key">Shift+Tab</span><span class="help-desc">unindent</span></div>

<h2>global</h2>
<div class="help-row"><span class="help-key">F1</span><span class="help-desc">toggle this help</span></div>
<div class="help-row"><span class="help-key">Ctrl+S</span><span class="help-desc">save notebook</span></div>
<div class="help-row"><span class="help-key">Ctrl+F</span><span class="help-desc">find in notebook</span></div>
<div class="help-row"><span class="help-key">Ctrl+H</span><span class="help-desc">find and replace</span></div>

<h2>toolbar</h2>
<div class="help-row"><span class="help-key">&#x23f5; step</span><span class="help-desc">run selected cell</span></div>
<div class="help-row"><span class="help-key">&#x25b6;/&#x2016;</span><span class="help-desc">toggle reactive mode (autorun)</span></div>
<div class="help-row"><span class="help-key">&#x25b6;&#x25b6; run all</span><span class="help-desc">run all cells</span></div>

<h2>builtins</h2>
<div class="help-row"><span class="help-key">display()</span><span class="help-desc">show text, objects, or DOM elements</span></div>
<div class="help-row"><span class="help-key">canvas(w,h)</span><span class="help-desc">create a canvas element</span></div>
<div class="help-row"><span class="help-key">table(data)</span><span class="help-desc">render array of objects as table</span></div>
<div class="help-row"><span class="help-key">slider()</span><span class="help-desc">reactive range input</span></div>
<div class="help-row"><span class="help-key">dropdown()</span><span class="help-desc">reactive select input</span></div>
<div class="help-row"><span class="help-key">checkbox()</span><span class="help-desc">reactive boolean input</span></div>
<div class="help-row"><span class="help-key">textInput()</span><span class="help-desc">reactive text input</span></div>
<div class="help-row"><span class="help-key">load(url)</span><span class="help-desc">import ESM module (cached)</span></div>
<div class="help-row"><span class="help-key">install(url)</span><span class="help-desc">import + embed in HTML on save</span></div>
<div class="help-row"><span class="help-key">installBinary(url)</span><span class="help-desc">fetch binary asset + embed gzipped</span></div>
<div class="help-row"><span class="help-key">invalidation</span><span class="help-desc">promise that resolves before cell re-runs</span></div>
<div class="help-row"><span class="help-key">md``</span><span class="help-desc">markdown tagged template</span></div>
<div class="help-row"><span class="help-key">html``</span><span class="help-desc">HTML tagged template</span></div>
<div class="help-row"><span class="help-key">css``</span><span class="help-desc">CSS tagged template</span></div>
<div class="help-row"><span class="help-key">workshop(pages)</span><span class="help-desc">interactive side panel with pages</span></div>
<div class="help-row"><span class="help-key">notebook</span><span class="help-desc">API for cells, scope, scrollTo, focus</span></div>

<h2>directives</h2>
<div class="help-row"><span class="help-key">// %manual</span><span class="help-desc">skip cell on reactive updates</span></div>
<div class="help-row"><span class="help-key">// %norun</span><span class="help-desc">skip cell on Run All</span></div>
<div class="help-row"><span class="help-key">// %hide</span><span class="help-desc">hide cell in present mode</span></div>
<div class="help-row"><span class="help-key">// %cellName &lt;label&gt;</span><span class="help-desc">name cell in DevTools</span></div>
<div class="help-row"><span class="help-key">// %outputId &lt;id&gt;</span><span class="help-desc">set id on output div</span></div>
<div class="help-row"><span class="help-key">// %outputClass &lt;cls&gt;</span><span class="help-desc">add classes to output div</span></div>
<div class="help-row"><span class="help-key">// %goto &lt;label&gt;</span><span class="help-desc">jump to named cell after execution</span></div>
<div class="help-row"><span class="help-key">// %collapsed</span><span class="help-desc">start cell collapsed</span></div>

<div class="help-close">press F1 or Esc to close</div>
</div>
</div>

<div class="settings-overlay" id="settingsOverlay" onclick="if(event.target===this)toggleSettings()"></div>
<div class="settings-panel" id="settingsPanel">
  <button class="settings-close" onclick="toggleSettings()">&#x00d7;</button>
  <h2>theme</h2>
  <div class="settings-row">
    <label>color scheme</label>
    <select id="setTheme" onchange="applyTheme(this.value)">
      <option value="dark">dark</option>
      <option value="light">light</option>
    </select>
  </div>

  <h2>editor</h2>
  <div class="settings-row">
    <label>font size</label>
    <input type="range" id="setFontSize" min="10" max="20" value="13" oninput="applyFontSize(this.value)">
    <span class="settings-val" id="setFontSizeVal">13</span>
  </div>
  <div class="settings-row">
    <label>line numbers</label>
    <select id="setLineNumbers" onchange="applyLineNumbers(this.value)">
      <option value="on" selected>on</option>
      <option value="off">off</option>
    </select>
  </div>

  <h2>notebook</h2>
  <div class="settings-row">
    <label>max width</label>
    <select id="setWidth" onchange="applyWidth(this.value)">
      <option value="720">narrow</option>
      <option value="860" selected>default</option>
      <option value="1100">wide</option>
      <option value="100%">full</option>
    </select>
  </div>
  <div class="settings-row">
    <label>cell header</label>
    <select id="setHeader" onchange="applyHeader(this.value)">
      <option value="auto" selected>auto</option>
      <option value="always">always visible</option>
      <option value="compact">compact</option>
      <option value="hover">hover only</option>
    </select>
  </div>

  <h2>execution</h2>
  <div class="settings-row">
    <label>mode</label>
    <select id="setExecMode" onchange="applyExecMode(this.value)">
      <option value="reactive">reactive</option>
      <option value="manual">manual</option>
    </select>
  </div>
  <div class="settings-row">
    <label>run on load</label>
    <select id="setRunOnLoad" onchange="applyRunOnLoad(this.value)">
      <option value="yes">yes</option>
      <option value="no">no</option>
    </select>
  </div>
  <div class="settings-row">
    <label>show run toggle</label>
    <select id="setShowToggle" onchange="applyShowToggle(this.value)">
      <option value="yes">yes</option>
      <option value="no">no</option>
    </select>
  </div>
  <div class="settings-desc">
    <strong>reactive</strong>: cells auto-run on edit, changes propagate.<br>
    <strong>manual</strong>: only Ctrl+Enter, Shift+Enter, or Run All.
  </div>
  <div class="settings-row">
    <label>global override</label>
    <select id="setGlobalExecMode" onchange="applyGlobalExecMode(this.value)">
      <option value="">(notebook default)</option>
      <option value="reactive">always reactive</option>
      <option value="manual">always manual</option>
    </select>
  </div>
  <div class="settings-row">
    <label>global run on load</label>
    <select id="setGlobalRunOnLoad" onchange="applyGlobalRunOnLoad(this.value)">
      <option value="">(notebook default)</option>
      <option value="yes">always run</option>
      <option value="no">never run</option>
    </select>
  </div>

  <h2>modules</h2>
  <div id="moduleList"></div>
  <h2>binaries</h2>
  <div id="binaryList"></div>

  <div class="settings-about">
    <span id="aboutVersion"></span>
    <span id="aboutBuild"></span>
    <span id="aboutRuntime"></span>
    <a href="https://github.com/endarthur/auditable" target="_blank">github.com/endarthur/auditable</a>
  </div>
</div>

<div class="update-overlay" id="updateOverlay" onclick="if(event.target===this)toggleUpdate()"></div>
<div class="update-panel" id="updatePanel">
  <button class="settings-close" onclick="toggleUpdate()">&#x00d7;</button>
  <h2>update</h2>
  <div class="settings-row">
    <label>version</label>
    <span id="updateCurrentVer">v0.0.0</span>
  </div>
  <div class="settings-row">
    <label>release</label>
    <span id="updateRelease">dev</span>
  </div>
  <div class="settings-row">
    <label>signature</label>
    <span id="updateSigStatus" class="update-sig">checking...</span>
  </div>
  <div class="settings-row">
    <label>public key</label>
    <span id="updatePubKey" class="update-sig">-</span>
  </div>
  <div id="updateStatus" class="update-status"></div>
  <div class="update-actions">
    <button id="updateCheckBtn" onclick="checkForUpdate()">check for updates</button>
    <button onclick="updateFromFile()">update from file</button>
  </div>
</div>

<div class="toolbar">
  <span class="toolbar-title">auditable</span>
  <span class="toolbar-badges" id="toolbarBadges"></span>
  <span class="toolbar-sep"></span>
  <span class="toolbar-filename">
    <input type="text" id="docTitle" value="atra — Wasm kernels" spellcheck="false">
  </span>
  <span class="toolbar-status" id="toolbarStatus"></span>
  <button class="toolbar-add" onclick="addCellWithUndo('code','',S.selectedId)">+ code</button>
  <button class="toolbar-add" onclick="addCellWithUndo('md','',S.selectedId)">+ md</button>
  <button class="toolbar-secondary" onclick="addCellWithUndo('css','',S.selectedId)">+ css</button>
  <button class="toolbar-secondary" onclick="addCellWithUndo('html','',S.selectedId)">+ html</button>
  <span class="toolbar-sep"></span>
  <span class="transport">
    <button onclick="runSelectedCell()" title="run cell + advance (Shift+Enter)">&#x23f5;</button>
    <button id="autorunBtn" class="autorun-on" onclick="toggleAutorun()" title="reactive mode &#x2014; cells auto-run on edit">&#x25b6;</button>
    <button onclick="runAll()" title="run all cells">&#x25b6;&#x25b6;</button>
  </span>
  <span class="toolbar-right">
    <span class="save-split">
      <button class="accent" onclick="saveNotebook()"><span id="saveLabel">save</span></button><button class="accent save-caret" onclick="toggleSaveTray()">&#x25be;</button>
      <div class="save-tray" id="saveTray">
        <button onclick="setSaveMode('normal');saveNotebook()">save</button>
        <button onclick="setSaveMode('packed');saveNotebook()">save packed</button>
        <button onclick="exportAsTxt();toggleSaveTray()">export .txt</button>
      </div>
    </span>
    <div class="toolbar-overflow">
      <button onclick="toggleToolbarMenu()" title="more">&#x22ef;</button>
      <div class="toolbar-overflow-tray">
        <button onclick="newNotebook();toggleToolbarMenu()">new</button>
        <button onclick="collapseAll();toggleToolbarMenu()">collapse all</button>
        <button onclick="expandAll();toggleToolbarMenu()">expand all</button>
        <button onclick="$('#helpOverlay').classList.toggle('visible');toggleToolbarMenu()">help (F1)</button>
        <button onclick="toggleSettings();toggleToolbarMenu()">settings</button>
        <button class="toolbar-update-btn" onclick="toggleUpdate();toggleToolbarMenu()">update</button>
        <button onclick="togglePresent();toggleToolbarMenu()">present</button>
        <button onclick="openFind(false);toggleToolbarMenu()">find (Ctrl+F)</button>
      </div>
    </div>
  </span>
</div>

<div class="find-bar" id="findBar">
  <div class="find-row">
    <input type="text" id="findInput" placeholder="find" spellcheck="false" autocomplete="off">
    <span class="find-count" id="findCount"></span>
    <button id="findRegexBtn" title="use regex">.*</button>
    <button id="findCaseBtn" title="match case">Aa</button>
    <button id="findPrevBtn" title="previous (Shift+Enter)">&#x2191;</button>
    <button id="findNextBtn" title="next (Enter)">&#x2193;</button>
    <button id="findCloseBtn" title="close (Esc)">&#x00d7;</button>
  </div>
  <div class="find-replace-row" id="findReplaceRow">
    <input type="text" id="replaceInput" placeholder="replace" spellcheck="false" autocomplete="off">
    <button id="findReplaceBtn">replace</button>
    <button id="findReplaceAllBtn">all</button>
  </div>
</div>

<button class="present-exit" onclick="togglePresent()">&#x2715; exit</button>

<div class="notebook" id="notebook">
  <!-- cells go here -->
</div>

<div class="statusbar">
  <span class="status-size" id="statusSize"></span>
  <span class="status-cells" id="statusCells">0 cells</span>
  <span class="status-msg" id="statusMsg"></span>
  <span class="status-attr">
    <a href="https://endarthur.github.io" target="_blank">endarthur</a>
    <span>&middot;</span>
    <a href="https://gentropic.org" target="_blank">geoscientific chaos union</a>
    <span>&middot;</span>
    <a href="https://github.com/endarthur/auditable" target="_blank" title="source on GitHub"><svg width="14" height="14" viewBox="0 0 16 16" fill="currentColor"><path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"/></svg></a>
  </span>
  <div class="action-bar">
    <div>
      <div class="action-add-tray">
        <button onclick="insertAt(S.selectedId,'code');toggleAddTray()">+ code</button>
        <button onclick="insertAt(S.selectedId,'md');toggleAddTray()">+ md</button>
        <button onclick="insertAt(S.selectedId,'css');toggleAddTray()">+ css</button>
        <button onclick="insertAt(S.selectedId,'html');toggleAddTray()">+ html</button>
      </div>
      <button class="action-add" onclick="toggleAddTray()">+</button>
    </div>
    <button onclick="runSelectedCell()" title="run cell + advance">&#x23f5;</button>
    <button id="autorunBtnMobile" class="autorun-on" onclick="toggleAutorun()" title="autorun">&#x25b6;</button>
    <button onclick="runAll()" title="run all">&#x25b6;&#x25b6;</button>
    <div>
      <div class="action-more-tray">
        <button onclick="newNotebook();toggleMoreTray()">new</button>
        <button id="mobileSaveBtn" class="active-mode" onclick="setSaveMode('normal');saveNotebook();toggleMoreTray()">save</button>
        <button id="mobilePackBtn" onclick="setSaveMode('packed');saveNotebook();toggleMoreTray()">save packed</button>
        <button onclick="collapseAll();toggleMoreTray()">collapse all</button>
        <button onclick="expandAll();toggleMoreTray()">expand all</button>
        <button onclick="$('#helpOverlay').classList.toggle('visible');toggleMoreTray()">help</button>
        <button onclick="toggleSettings();toggleMoreTray()">settings</button>
        <button class="toolbar-update-btn" onclick="toggleUpdate();toggleMoreTray()">update</button>
        <button onclick="togglePresent();toggleMoreTray()">present</button>
        <button onclick="openFind(false);toggleMoreTray()">find</button>
      </div>
      <button class="action-more" onclick="toggleMoreTray()">&#x22ef;</button>
    </div>
  </div>
</div>


<!-- cell data: JSON array of {type, code, collapsed?} -->
<!--AUDITABLE-DATA
[{"type":"md","code":"# atra — WebAssembly numerical kernels\n\n[atra](ext/atra/SPEC.md) is a Fortran/Pascal hybrid that compiles to WebAssembly bytecode via tagged template literals. no toolchain, no build step — one JS file turns formulas into bytecode.\n\nthis notebook computes three **variogram models** (spherical, gaussian, exponential) and uses `call_indirect` to pass the selected model as a function reference to a grid evaluator — the hot loop runs entirely in Wasm, calling the chosen model through a function pointer."},{"type":"code","code":"const { atra } = await load(\"./ext/atra/index.js\");"},{"type":"code","code":"// three variogram models + indirect-call grid evaluator\n// compiled to WebAssembly — model selection via call_indirect\n\nconst modelName = ui.dropdown(\"model\", [\"spherical\",\"gaussian\",\"exponential\"]);\nconst range0 = ui.slider(\"range\", 60, {min:10, max:200, step:1});\nconst sill0 = ui.slider(\"sill\", 1.0, {min:0.1, max:3.0, step:0.1});\nconst nugget0 = ui.slider(\"nugget\", 0.1, {min:0.0, max:1.0, step:0.05});\nconst nPts = ui.slider(\"samples\", 30, {min:5, max:100, step:1});\nconst gridN = ui.slider(\"grid\", 120, {min:40, max:250, step:10});"},{"type":"code","code":"// compile atra kernels to Wasm\nconst mem = new WebAssembly.Memory({ initial: 4 }); // 256 KB\n\nconst wasm = atra({ memory: mem })`\n  ! ── variogram models ──\n  ! all share the same signature: (h, a, c1, c0: f64): f64\n\n  ! spherical: γ(h) = c0 + c1 * (1.5h/a - 0.5(h/a)^3)\n  function spherical(h, a, c1, c0: f64): f64\n  begin\n    if (h <= 0.0) then\n      spherical := 0.0\n    else if (h >= a) then\n      spherical := c0 + c1\n    else\n      spherical := c0 + c1 * (1.5 * h / a - 0.5 * (h / a) ** 3)\n    end if\n  end\n\n  ! gaussian: γ(h) = c0 + c1 * (1 - exp(-3(h/a)²))\n  function gaussian(h, a, c1, c0: f64): f64\n  begin\n    if (h <= 0.0) then\n      gaussian := 0.0\n    else\n      gaussian := c0 + c1 * (1.0 - exp(-3.0 * (h / a) ** 2))\n    end if\n  end\n\n  ! exponential: γ(h) = c0 + c1 * (1 - exp(-3h/a))\n  function exponential(h, a, c1, c0: f64): f64\n  begin\n    if (h <= 0.0) then\n      exponential := 0.0\n    else\n      exponential := c0 + c1 * (1.0 - exp(-3.0 * h / a))\n    end if\n  end\n\n  ! ── grid evaluator with indirect call ──\n  ! the model parameter is a function reference (table index)\n  ! call_indirect dispatches to whichever model was passed\n  subroutine eval_grid(\n    model: function(h, a, c1, c0: f64): f64,\n    samples: array f64; nSamples: i32;\n    grid: array f64; gridN: i32;\n    a, c1, c0: f64\n  )\n  var\n    ix, iy, k: i32\n    gx, gy, dx, dy, dist, gamma, w, wsum, vsum: f64\n  begin\n    for iy := 0, gridN\n      for ix := 0, gridN\n        gx := f64(ix) / f64(gridN)\n        gy := f64(iy) / f64(gridN)\n        wsum := 0.0\n        vsum := 0.0\n        for k := 0, nSamples\n          dx := gx - samples[k * 3]\n          dy := gy - samples[k * 3 + 1]\n          dist := sqrt(dx * dx + dy * dy)\n          if (dist < 1e-10) then\n            wsum := 1.0\n            vsum := samples[k * 3 + 2]\n            break\n          end if\n          gamma := model(dist, a, c1, c0)\n          if (gamma > 0.0) then\n            w := 1.0 / gamma\n          else\n            w := 1e10\n          end if\n          wsum += w\n          vsum += w * samples[k * 3 + 2]\n        end for\n        grid[iy * gridN + ix] := vsum / wsum\n      end for\n    end for\n  end\n\n  ! ── dispatch: select model by id, pass as function reference ──\n  subroutine run_model(\n    model_id: i32,\n    samples: array f64; nSamples: i32;\n    grid: array f64; gridN: i32;\n    a, c1, c0: f64\n  )\n  var model: function(h, a, c1, c0: f64): f64\n  begin\n    if (model_id == 0) then\n      model := @spherical\n    else if (model_id == 1) then\n      model := @gaussian\n    else\n      model := @exponential\n    end if\n    call eval_grid(model, samples, nSamples, grid, gridN, a, c1, c0)\n  end\n`;\n\n// wasm.__table maps function names to their call_indirect table indices\n// { spherical: 0, gaussian: 1, exponential: 2, eval_grid: 3, run_model: 4 }"},{"type":"code","code":"// generate seeded samples + run Wasm kernel\nfunction mulberry32(a) {\n  return function() {\n    a |= 0; a = a + 0x6D2B79F5 | 0;\n    let t = Math.imul(a ^ a >>> 15, 1 | a);\n    t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;\n    return ((t ^ t >>> 14) >>> 0) / 4294967296;\n  };\n}\nconst rng = mulberry32(42);\n\n// pack samples into Wasm memory as f64 triples\nconst buf = new Float64Array(mem.buffer);\nconst samplesPtr = 0;\nfor (let i = 0; i < nPts; i++) {\n  const x = rng(), y = rng();\n  const trend = 0.5 * Math.sin(x * 4.0) * Math.cos(y * 3.0) + 0.5;\n  buf[i * 3 + 0] = x;\n  buf[i * 3 + 1] = y;\n  buf[i * 3 + 2] = 0.3 * rng() + 0.7 * trend;\n}\n\nconst gridPtr = nPts * 3 * 8; // after sample data\n\nconst t0 = performance.now();\nwasm.run_model(wasm.__table[modelName], samplesPtr, nPts, gridPtr, gridN, range0 / 200, sill0, nugget0);\nconst elapsed = (performance.now() - t0).toFixed(2);\n\n// read grid back\nconst grid = new Float64Array(mem.buffer, gridPtr, gridN * gridN);"},{"type":"code","code":"// render\nconst size = Math.min(500, window.innerWidth - 80);\nconst c = ui.canvas(size, size);\nconst ctx = c.getContext(\"2d\");\n\nfunction viridis(t) {\n  t = Math.max(0, Math.min(1, t));\n  const r = Math.round(255 * Math.max(0, Math.min(1,\n    0.267 + t * (0.004 + t * (5.294 + t * (-14.05 + t * 8.5))))));\n  const g = Math.round(255 * Math.max(0, Math.min(1,\n    0.004 + t * (1.384 + t * (0.098 + t * (-2.74 + t * 2.23))))));\n  const b = Math.round(255 * Math.max(0, Math.min(1,\n    0.329 + t * (1.44 + t * (-5.11 + t * (6.87 + t * -3.57))))));\n  return `rgb(${r},${g},${b})`;\n}\n\nlet vmin = Infinity, vmax = -Infinity;\nfor (let i = 0; i < grid.length; i++) {\n  if (grid[i] < vmin) vmin = grid[i];\n  if (grid[i] > vmax) vmax = grid[i];\n}\nconst vrange = vmax - vmin || 1;\n\nconst cellW = size / gridN;\nfor (let iy = 0; iy < gridN; iy++) {\n  for (let ix = 0; ix < gridN; ix++) {\n    const t = (grid[iy * gridN + ix] - vmin) / vrange;\n    ctx.fillStyle = viridis(t);\n    ctx.fillRect(ix * cellW, iy * cellW, cellW + 0.5, cellW + 0.5);\n  }\n}\n\n// overlay sample points\nfor (let i = 0; i < nPts; i++) {\n  const x = buf[i * 3] * size, y = buf[i * 3 + 1] * size;\n  ctx.beginPath();\n  ctx.arc(x, y, 4, 0, Math.PI * 2);\n  ctx.fillStyle = \"#fff\";\n  ctx.fill();\n  ctx.lineWidth = 1.5;\n  ctx.strokeStyle = \"#000\";\n  ctx.stroke();\n}\n\nui.display(`${modelName} \\u00b7 ${gridN}\\u00d7${gridN} grid \\u00b7 ${nPts} samples \\u00b7 Wasm kernel: ${elapsed} ms`);"},{"type":"code","code":"// variogram curve plot\nconst cvs = ui.canvas(500, 200);\nconst cx = cvs.getContext(\"2d\");\nconst w = 500, h = 200, pad = 40;\n\ncx.fillStyle = \"#181818\";\ncx.fillRect(0, 0, w, h);\n\n// axes\ncx.strokeStyle = \"#555\";\ncx.lineWidth = 1;\ncx.beginPath();\ncx.moveTo(pad, h - pad); cx.lineTo(w - 10, h - pad);\ncx.moveTo(pad, h - pad); cx.lineTo(pad, 10);\ncx.stroke();\n\ncx.fillStyle = \"#999\";\ncx.font = \"11px monospace\";\ncx.fillText(\"h\", w - 20, h - pad + 4);\ncx.fillText(\"\\u03b3(h)\", pad - 4, 14);\n\n// plot selected model curve\nconst evalModel = wasm[modelName]; // spherical, gaussian, or exponential\nconst maxH = 1.2;\nconst maxG = nugget0 + sill0 * 1.15;\ncx.strokeStyle = \"#c89b3c\";\ncx.lineWidth = 2;\ncx.beginPath();\nfor (let i = 0; i <= 200; i++) {\n  const hv = (i / 200) * maxH;\n  const gv = evalModel(hv, range0 / 200, sill0, nugget0);\n  const px = pad + (hv / maxH) * (w - pad - 10);\n  const py = (h - pad) - (gv / maxG) * (h - pad - 20);\n  if (i === 0) cx.moveTo(px, py); else cx.lineTo(px, py);\n}\ncx.stroke();\n\n// tick labels\ncx.fillStyle = \"#888\";\nfor (let i = 0; i <= 4; i++) {\n  const hv = (i / 4) * maxH;\n  const px = pad + (hv / maxH) * (w - pad - 10);\n  cx.fillText(hv.toFixed(2), px - 12, h - pad + 14);\n}\nfor (let i = 0; i <= 3; i++) {\n  const gv = (i / 3) * maxG;\n  const py = (h - pad) - (gv / maxG) * (h - pad - 20);\n  cx.fillText(gv.toFixed(2), 2, py + 4);\n}"},{"type":"md","code":"**how it works:** the `atra` tagged template compiles three variogram models and a grid evaluator to WebAssembly bytecode — no toolchain, just `atra\\`...\\``. the grid evaluator takes a **function reference** as its first parameter (`model: function(...)`), so the same Wasm subroutine handles all three models via `call_indirect`. sample data is packed into Wasm linear memory as `f64` triples, and the nested loop runs as native Wasm instructions. the resulting grid is rendered with a viridis colormap."}]
AUDITABLE-DATA-->
<!-- installed modules: base64-encoded JSON mapping URLs to {source, cellId} -->
<!--AUDITABLE-MODULES
eyIuL2V4dC9hdHJhL2luZGV4LmpzIjp7InNvdXJjZSI6Ii8vIEBhdWRpdGFibGUvYXRyYSDigJQg
QXJpdGhtZXRpYyBUUkFuc3BpbGVyXG4vLyBGb3J0cmFuL1Bhc2NhbCBoeWJyaWQg4oaSIFdlYkFz
c2VtYmx5IGJ5dGVjb2RlLiBTaW5nbGUtZmlsZSBjb21waWxlci5cblxuLy8gLS0gaGlnaGxpZ2h0
LmpzIC0tXG5cbi8vIFN5bnRheCBoaWdobGlnaHRpbmcg4oCUIHRva2VuaXplciArIGNvbXBsZXRp
b25zIGZvciBhdWRpdGFibGUgZWRpdG9yIGludGVncmF0aW9uXG4vL1xuLy8gVGhlc2Uga2V5d29y
ZC90eXBlL2J1aWx0aW4gc2V0cyBkZWZpbmUgdGhlIGxhbmd1YWdlJ3Mgdm9jYWJ1bGFyeS4gVGhl
eSdyZSBzaGFyZWRcbi8vIGJldHdlZW4gdGhpcyBtb2R1bGUgKGVkaXRvciBoaWdobGlnaHRpbmcg
KyBjb21wbGV0aW9ucykgYW5kIGxleC5qcyAoY29tcGlsZXIgdG9rZW5pemVyKS5cblxuY29uc3Qg
QVRSQV9LRVlXT1JEUyA9IG5ldyBTZXQoW1xuICAnZnVuY3Rpb24nLCdzdWJyb3V0aW5lJywnYmVn
aW4nLCdlbmQnLCd2YXInLCdjb25zdCcsJ2lmJywndGhlbicsJ2Vsc2UnLFxuICAnZm9yJywnd2hp
bGUnLCdkbycsJ2JyZWFrJywnYW5kJywnb3InLCdub3QnLCdtb2QnLCdpbXBvcnQnLCdleHBvcnQn
LFxuICAnY2FsbCcsJ2FycmF5JywndHJ1ZScsJ2ZhbHNlJywnZnJvbScsJ3RhaWxjYWxsJywncmV0
dXJuJyxcbl0pO1xuXG5jb25zdCBBVFJBX1RZUEVTID0gbmV3IFNldChbJ2kzMicsJ2k2NCcsJ2Yz
MicsJ2Y2NCcsJ2Y2NHgyJywnZjMyeDQnLCdpMzJ4NCcsJ2k2NHgyJ10pO1xuXG5jb25zdCBBVFJB
X0JVSUxUSU5TID0gbmV3IFNldChbXG4gICdzaW4nLCdjb3MnLCdzcXJ0JywnYWJzJywnZmxvb3In
LCdjZWlsJywnbG4nLCdleHAnLCdwb3cnLFxuICAnbWluJywnbWF4JywndHJ1bmMnLCduZWFyZXN0
JywnY29weXNpZ24nLCdzZWxlY3QnLFxuICAnY2x6JywnY3R6JywncG9wY250Jywncm90bCcsJ3Jv
dHInLCdtZW1vcnlfc2l6ZScsJ21lbW9yeV9ncm93JyxcbiAgJ21lbW9yeV9jb3B5JywnbWVtb3J5
X2ZpbGwnLFxuXSk7XG5cbmNvbnN0IEFUUkFfVkVDVE9SX1RZUEVTID0gbmV3IFNldChbJ2Y2NHgy
JywnZjMyeDQnLCdpMzJ4NCcsJ2k2NHgyJ10pO1xuXG5mdW5jdGlvbiB0b2tlbml6ZUF0cmEoY29k
ZSkge1xuICBjb25zdCB0b2tlbnMgPSBbXTtcbiAgbGV0IGkgPSAwO1xuICBjb25zdCBsZW4gPSBj
b2RlLmxlbmd0aDtcblxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIC8vIGxpbmUgY29tbWVudDog
ISB0byBlbmQgb2YgbGluZVxuICAgIGlmIChjb2RlW2ldID09PSAnIScpIHtcbiAgICAgIGNvbnN0
IHN0YXJ0ID0gaTtcbiAgICAgIHdoaWxlIChpIDwgbGVuICYmIGNvZGVbaV0gIT09ICdcXG4nKSBp
Kys7XG4gICAgICB0b2tlbnMucHVzaCh7IHR5cGU6ICdjbXQnLCB0ZXh0OiBjb2RlLnNsaWNlKHN0
YXJ0LCBpKSB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICAvLyBudW1iZXJzICh3aXRo
IG9wdGlvbmFsIHR5cGUgc3VmZml4IF9mMzIsIF9mNjQsIF9pMzIsIF9pNjQpXG4gICAgaWYgKC9c
XGQvLnRlc3QoY29kZVtpXSkgfHwgKGNvZGVbaV0gPT09ICcuJyAmJiBpICsgMSA8IGxlbiAmJiAv
XFxkLy50ZXN0KGNvZGVbaSArIDFdKSkpIHtcbiAgICAgIGNvbnN0IHN0YXJ0ID0gaTtcbiAgICAg
IHdoaWxlIChpIDwgbGVuICYmIC9bMC05Ll0vLnRlc3QoY29kZVtpXSkpIGkrKztcbiAgICAgIGlm
IChpIDwgbGVuICYmIC9bZUVdLy50ZXN0KGNvZGVbaV0pKSB7XG4gICAgICAgIGkrKztcbiAgICAg
ICAgaWYgKGkgPCBsZW4gJiYgL1srLV0vLnRlc3QoY29kZVtpXSkpIGkrKztcbiAgICAgICAgd2hp
bGUgKGkgPCBsZW4gJiYgL1xcZC8udGVzdChjb2RlW2ldKSkgaSsrO1xuICAgICAgfVxuICAgICAg
Ly8gdHlwZSBzdWZmaXg6IF9mMzIsIF9mNjQsIF9pMzIsIF9pNjRcbiAgICAgIGlmIChjb2RlW2ld
ID09PSAnXycgJiYgaSArIDMgPD0gbGVuICYmIC9eW2ZpXS8udGVzdChjb2RlW2kgKyAxXSkpIHtc
biAgICAgICAgY29uc3Qgc3VmID0gY29kZS5zbGljZShpICsgMSwgaSArIDQpO1xuICAgICAgICBp
ZiAoQVRSQV9UWVBFUy5oYXMoc3VmKSkgaSArPSA0O1xuICAgICAgfVxuICAgICAgdG9rZW5zLnB1
c2goeyB0eXBlOiAnbnVtJywgdGV4dDogY29kZS5zbGljZShzdGFydCwgaSkgfSk7XG4gICAgICBj
b250aW51ZTtcbiAgICB9XG4gICAgLy8gaWRlbnRpZmllcnMgLyBrZXl3b3Jkc1xuICAgIGlmICgv
W2EtekEtWl9dLy50ZXN0KGNvZGVbaV0pKSB7XG4gICAgICBjb25zdCBzdGFydCA9IGk7XG4gICAg
ICB3aGlsZSAoaSA8IGxlbiAmJiAvW1xcdy5dLy50ZXN0KGNvZGVbaV0pKSBpKys7XG4gICAgICBj
b25zdCB3b3JkID0gY29kZS5zbGljZShzdGFydCwgaSk7XG4gICAgICBjb25zdCBsb3dlciA9IHdv
cmQudG9Mb3dlckNhc2UoKTtcbiAgICAgIGlmIChBVFJBX0tFWVdPUkRTLmhhcyhsb3dlcikpIHtc
biAgICAgICAgdG9rZW5zLnB1c2goeyB0eXBlOiAna3cnLCB0ZXh0OiB3b3JkIH0pO1xuICAgICAg
fSBlbHNlIGlmIChBVFJBX1RZUEVTLmhhcyhsb3dlcikpIHtcbiAgICAgICAgLy8gdHlwZSBuYW1l
cyBhcyBidWlsdGlucyB3aGVuIGZvbGxvd2VkIGJ5IChcbiAgICAgICAgaWYgKGkgPCBsZW4gJiYg
Y29kZVtpXSA9PT0gJygnKSB7XG4gICAgICAgICAgdG9rZW5zLnB1c2goeyB0eXBlOiAnZm4nLCB0
ZXh0OiB3b3JkIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRva2Vucy5wdXNoKHsg
dHlwZTogJ2NvbnN0JywgdGV4dDogd29yZCB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlm
IChBVFJBX0JVSUxUSU5TLmhhcyhsb3dlcikgfHwgbG93ZXIuc3RhcnRzV2l0aCgnd2FzbS4nKSB8
fFxuICAgICAgICAgICAgICAgICBsb3dlci5zdGFydHNXaXRoKCd2MTI4LicpIHx8IChBVFJBX1ZF
Q1RPUl9UWVBFUy5oYXMobG93ZXIuc3BsaXQoJy4nKVswXSkgJiYgbG93ZXIuaW5jbHVkZXMoJy4n
KSkpIHtcbiAgICAgICAgdG9rZW5zLnB1c2goeyB0eXBlOiAnZm4nLCB0ZXh0OiB3b3JkIH0pO1xu
ICAgICAgfSBlbHNlIGlmIChpIDwgbGVuICYmIGNvZGVbaV0gPT09ICcoJykge1xuICAgICAgICB0
b2tlbnMucHVzaCh7IHR5cGU6ICdmbicsIHRleHQ6IHdvcmQgfSk7XG4gICAgICB9IGVsc2Uge1xu
ICAgICAgICB0b2tlbnMucHVzaCh7IHR5cGU6ICdpZCcsIHRleHQ6IHdvcmQgfSk7XG4gICAgICB9
XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgLy8gbXVsdGktY2hhciBvcGVyYXRvcnNcbiAg
ICBpZiAoaSArIDEgPCBsZW4pIHtcbiAgICAgIGNvbnN0IHR3byA9IGNvZGVbaV0gKyBjb2RlW2kg
KyAxXTtcbiAgICAgIGlmICh0d28gPT09ICcqKicgfHwgdHdvID09PSAnOj0nIHx8IHR3byA9PT0g
Jys9JyB8fCB0d28gPT09ICctPScgfHxcbiAgICAgICAgICB0d28gPT09ICcqPScgfHwgdHdvID09
PSAnLz0nIHx8IHR3byA9PT0gJz09JyB8fCB0d28gPT09ICc8PScgfHxcbiAgICAgICAgICB0d28g
PT09ICc+PScgfHwgdHdvID09PSAnPDwnIHx8IHR3byA9PT0gJz4+Jykge1xuICAgICAgICB0b2tl
bnMucHVzaCh7IHR5cGU6ICdvcCcsIHRleHQ6IHR3byB9KTtcbiAgICAgICAgaSArPSAyO1xuICAg
ICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gc2luZ2xlLWNoYXIgb3BlcmF0
b3JzXG4gICAgaWYgKCcrLSovPD49JnxefkAnLmluY2x1ZGVzKGNvZGVbaV0pKSB7XG4gICAgICB0
b2tlbnMucHVzaCh7IHR5cGU6ICdvcCcsIHRleHQ6IGNvZGVbaV0gfSk7XG4gICAgICBpKys7XG4g
ICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgLy8gcHVuY3R1YXRpb25cbiAgICBpZiAoJygpW107
LDonLmluY2x1ZGVzKGNvZGVbaV0pKSB7XG4gICAgICB0b2tlbnMucHVzaCh7IHR5cGU6ICdwdW5j
JywgdGV4dDogY29kZVtpXSB9KTtcbiAgICAgIGkrKztcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1c
biAgICAvLyB3aGl0ZXNwYWNlIC8gb3RoZXJcbiAgICB0b2tlbnMucHVzaCh7IHR5cGU6ICcnLCB0
ZXh0OiBjb2RlW2ldIH0pO1xuICAgIGkrKztcbiAgfVxuICByZXR1cm4gdG9rZW5zO1xufVxuXG5m
dW5jdGlvbiBhdHJhQ29tcGxldGlvbnMoKSB7XG4gIGNvbnN0IGl0ZW1zID0gW107XG4gIGZvciAo
Y29uc3QgdyBvZiBBVFJBX0tFWVdPUkRTKSBpdGVtcy5wdXNoKHsgdGV4dDogdywga2luZDogJ2t3
JyB9KTtcbiAgZm9yIChjb25zdCB3IG9mIEFUUkFfVFlQRVMpICAgIGl0ZW1zLnB1c2goeyB0ZXh0
OiB3LCBraW5kOiAnY29uc3QnIH0pO1xuICBmb3IgKGNvbnN0IHcgb2YgQVRSQV9CVUlMVElOUykg
aXRlbXMucHVzaCh7IHRleHQ6IHcsIGtpbmQ6ICdmbicgfSk7XG4gIHJldHVybiBpdGVtcztcbn1c
blxuLy8gLS0gbGV4LmpzIC0tXG5cbi8vIExleGVyIOKAlCB0b2tlbml6ZXIgZm9yIHRoZSBwYXJz
ZXJcbi8vXG4vLyBBdHJhJ3MgbGV4aWNhbCBkZXNpZ24gYm9ycm93cyBmcm9tIEZvcnRyYW46ICEg
Zm9yIGxpbmUgY29tbWVudHMsIC89IGZvciBub3QtZXF1YWwsXG4vLyBzZW1pY29sb25zIGFzIHdo
aXRlc3BhY2UgKG9wdGlvbmFsIHN0YXRlbWVudCBzZXBhcmF0b3JzKS4gSWRlbnRpZmllcnMgY2Fu
IGNvbnRhaW4gZG90c1xuLy8gZm9yIG5hbWVzcGFjZS1zdHlsZSBhY2Nlc3MgKGUuZy4gcGh5c2lj
cy5ncmF2aXR5KSwgdHJlYXRlZCBhcyBhIHNpbmdsZSB0b2tlbi5cblxuXG5jb25zdCBUT0sgPSB7
XG4gIE5VTTogJ251bScsIElEOiAnaWQnLCBLVzogJ2t3JywgT1A6ICdvcCcsIFBVTkM6ICdwdW5j
JywgRU9GOiAnZW9mJyxcbn07XG5cbmZ1bmN0aW9uIGxleChzb3VyY2UpIHtcbiAgY29uc3QgdG9r
ZW5zID0gW107XG4gIGxldCBpID0gMCwgbGluZSA9IDEsIGNvbCA9IDE7XG4gIGNvbnN0IGxlbiA9
IHNvdXJjZS5sZW5ndGg7XG5cbiAgZnVuY3Rpb24gYWR2KCkgeyBpZiAoc291cmNlW2ldID09PSAn
XFxuJykgeyBsaW5lKys7IGNvbCA9IDE7IH0gZWxzZSB7IGNvbCsrOyB9IGkrKzsgfVxuICBmdW5j
dGlvbiBwZWVrKCkgeyByZXR1cm4gaSA8IGxlbiA/IHNvdXJjZVtpXSA6ICcnOyB9XG4gIGZ1bmN0
aW9uIHBlZWsyKCkgeyByZXR1cm4gaSArIDEgPCBsZW4gPyBzb3VyY2VbaV0gKyBzb3VyY2VbaSAr
IDFdIDogc291cmNlW2ldIHx8ICcnOyB9XG5cbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAvLyBz
a2lwIHdoaXRlc3BhY2UgYW5kIHNlbWljb2xvbnNcbiAgICBpZiAoJyBcXHRcXHJcXG47Jy5pbmNs
dWRlcyhzb3VyY2VbaV0pKSB7IGFkdigpOyBjb250aW51ZTsgfVxuICAgIC8vIGNvbW1lbnRcbiAg
ICBpZiAoc291cmNlW2ldID09PSAnIScpIHtcbiAgICAgIHdoaWxlIChpIDwgbGVuICYmIHNvdXJj
ZVtpXSAhPT0gJ1xcbicpIGFkdigpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0
IHRsID0gbGluZSwgdGMgPSBjb2w7XG4gICAgLy8gbnVtYmVyXG4gICAgaWYgKC9cXGQvLnRlc3Qo
c291cmNlW2ldKSB8fCAoc291cmNlW2ldID09PSAnLicgJiYgaSArIDEgPCBsZW4gJiYgL1xcZC8u
dGVzdChzb3VyY2VbaSArIDFdKSkpIHtcbiAgICAgIGNvbnN0IHN0YXJ0ID0gaTtcbiAgICAgIGxl
dCBpc0Zsb2F0ID0gZmFsc2U7XG4gICAgICB3aGlsZSAoaSA8IGxlbiAmJiAvXFxkLy50ZXN0KHNv
dXJjZVtpXSkpIGFkdigpO1xuICAgICAgaWYgKHBlZWsoKSA9PT0gJy4nICYmIC9cXGQvLnRlc3Qo
c291cmNlW2kgKyAxXSB8fCAnJykpIHsgaXNGbG9hdCA9IHRydWU7IGFkdigpOyB3aGlsZSAoaSA8
IGxlbiAmJiAvXFxkLy50ZXN0KHNvdXJjZVtpXSkpIGFkdigpOyB9XG4gICAgICBpZiAoL1tlRV0v
LnRlc3QocGVlaygpKSkgeyBpc0Zsb2F0ID0gdHJ1ZTsgYWR2KCk7IGlmICgvWystXS8udGVzdChw
ZWVrKCkpKSBhZHYoKTsgd2hpbGUgKGkgPCBsZW4gJiYgL1xcZC8udGVzdChzb3VyY2VbaV0pKSBh
ZHYoKTsgfVxuICAgICAgbGV0IHR5cGVTdWZmaXggPSBudWxsO1xuICAgICAgaWYgKHBlZWsoKSA9
PT0gJ18nKSB7XG4gICAgICAgIGNvbnN0IHMgPSBzb3VyY2Uuc2xpY2UoaSArIDEsIGkgKyA0KTtc
biAgICAgICAgaWYgKEFUUkFfVFlQRVMuaGFzKHMpKSB7IHR5cGVTdWZmaXggPSBzOyBhZHYoKTsg
YWR2KCk7IGFkdigpOyBhZHYoKTsgfVxuICAgICAgfVxuICAgICAgY29uc3QgcmF3ID0gc291cmNl
LnNsaWNlKHN0YXJ0LCBpKTtcbiAgICAgIHRva2Vucy5wdXNoKHsgdHlwZTogVE9LLk5VTSwgdmFs
dWU6IHJhdywgaXNGbG9hdCwgdHlwZVN1ZmZpeCwgbGluZTogdGwsIGNvbDogdGMgfSk7XG4gICAg
ICBjb250aW51ZTtcbiAgICB9XG4gICAgLy8gaWRlbnRpZmllciAoZG90cyBhbGxvd2VkIOKAlCBu
YW1lc3BhY2VzIGJ5IGNvbnZlbnRpb24pXG4gICAgaWYgKC9bYS16QS1aX10vLnRlc3Qoc291cmNl
W2ldKSkge1xuICAgICAgY29uc3Qgc3RhcnQgPSBpO1xuICAgICAgd2hpbGUgKGkgPCBsZW4gJiYg
L1tcXHcuXS8udGVzdChzb3VyY2VbaV0pKSBhZHYoKTtcbiAgICAgIC8vIFRyaW0gdHJhaWxpbmcg
ZG90OiBwYXJ0aWFsIG5hbWVzcGFjZSBhdCBFT0YgKGUuZy4gXCJuYW1lLlwiKSBzaG91bGRuJ3Rc
biAgICAgIC8vIHN3YWxsb3cgdGhlIGRvdC4gVGhpcyBsZXRzIHRoZSBlZGl0b3IgcmVjb3ZlciBn
cmFjZWZ1bGx5IG1pZC10eXBpbmcuXG4gICAgICB3aGlsZSAoaSA+IHN0YXJ0ICsgMSAmJiBzb3Vy
Y2VbaSAtIDFdID09PSAnLicpIHsgaS0tOyBjb2wtLTsgfVxuICAgICAgbGV0IHZhbCA9IHNvdXJj
ZS5zbGljZShzdGFydCwgaSk7XG4gICAgICAvLyBUYWdnZWQgdGVtcGxhdGUgaW50ZXJwb2xhdGlv
bnMgYmVjb21lIF9fSU5URVJQX05fXyBtYXJrZXJzIGluIHRoZSBzb3VyY2UgdGV4dC5cbiAgICAg
IC8vIFRoZSBwYXJzZXIgdHJlYXRzIHRoZW0gYXMgaWRlbnRpZmllcnM7IGNvZGVnZW4gcmVzb2x2
ZXMgdGhlbSB0byBpbXBvcnRzLlxuICAgICAgaWYgKC9eX19JTlRFUlBfXFxkK19fJC8udGVzdCh2
YWwpKSB7XG4gICAgICAgIHRva2Vucy5wdXNoKHsgdHlwZTogVE9LLklELCB2YWx1ZTogdmFsLCBp
bnRlcnA6IHRydWUsIGxpbmU6IHRsLCBjb2w6IHRjIH0pO1xuICAgICAgfSBlbHNlIGlmIChBVFJB
X0tFWVdPUkRTLmhhcyh2YWwpIHx8IEFUUkFfVFlQRVMuaGFzKHZhbCkpIHtcbiAgICAgICAgdG9r
ZW5zLnB1c2goeyB0eXBlOiBUT0suS1csIHZhbHVlOiB2YWwsIGxpbmU6IHRsLCBjb2w6IHRjIH0p
O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdG9rZW5zLnB1c2goeyB0eXBlOiBUT0suSUQsIHZh
bHVlOiB2YWwsIGxpbmU6IHRsLCBjb2w6IHRjIH0pO1xuICAgICAgfVxuICAgICAgY29udGludWU7
XG4gICAgfVxuICAgIC8vIG11bHRpLWNoYXIgb3BlcmF0b3JzXG4gICAgY29uc3QgdHcgPSBwZWVr
MigpO1xuICAgIGlmICh0dyA9PT0gJyoqJyB8fCB0dyA9PT0gJzo9JyB8fCB0dyA9PT0gJys9JyB8
fCB0dyA9PT0gJy09JyB8fCB0dyA9PT0gJyo9JyB8fFxuICAgICAgICB0dyA9PT0gJz09JyB8fCB0
dyA9PT0gJzw9JyB8fCB0dyA9PT0gJz49JyB8fCB0dyA9PT0gJzw8JyB8fCB0dyA9PT0gJz4+Jykg
e1xuICAgICAgdG9rZW5zLnB1c2goeyB0eXBlOiBUT0suT1AsIHZhbHVlOiB0dywgbGluZTogdGws
IGNvbDogdGMgfSk7XG4gICAgICBhZHYoKTsgYWR2KCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9
XG4gICAgLy8gLz0g4oCUIHRoaXMgaXMgbm90LWVxdWFsIGluIGF0cmFcbiAgICBpZiAoc291cmNl
W2ldID09PSAnLycgJiYgc291cmNlW2kgKyAxXSA9PT0gJz0nKSB7XG4gICAgICB0b2tlbnMucHVz
aCh7IHR5cGU6IFRPSy5PUCwgdmFsdWU6ICcvPScsIGxpbmU6IHRsLCBjb2w6IHRjIH0pO1xuICAg
ICAgYWR2KCk7IGFkdigpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIC8vIHNpbmdsZS1j
aGFyIG9wZXJhdG9yc1xuICAgIGlmICgnKy0qLzw+PSZ8Xn5AJy5pbmNsdWRlcyhzb3VyY2VbaV0p
KSB7XG4gICAgICB0b2tlbnMucHVzaCh7IHR5cGU6IFRPSy5PUCwgdmFsdWU6IHNvdXJjZVtpXSwg
bGluZTogdGwsIGNvbDogdGMgfSk7XG4gICAgICBhZHYoKTtcbiAgICAgIGNvbnRpbnVlO1xuICAg
IH1cbiAgICAvLyBwdW5jdHVhdGlvblxuICAgIGlmICgnKClbXTssOicuaW5jbHVkZXMoc291cmNl
W2ldKSkge1xuICAgICAgdG9rZW5zLnB1c2goeyB0eXBlOiBUT0suUFVOQywgdmFsdWU6IHNvdXJj
ZVtpXSwgbGluZTogdGwsIGNvbDogdGMgfSk7XG4gICAgICBhZHYoKTtcbiAgICAgIGNvbnRpbnVl
O1xuICAgIH1cbiAgICAvLyBza2lwIHVua25vd25cbiAgICBhZHYoKTtcbiAgfVxuICB0b2tlbnMu
cHVzaCh7IHR5cGU6IFRPSy5FT0YsIHZhbHVlOiAnJywgbGluZSwgY29sIH0pO1xuICByZXR1cm4g
dG9rZW5zO1xufVxuXG4vLyAtLSBwYXJzZS5qcyAtLVxuXG4vLyBQYXJzZXIg4oCUIHJlY3Vyc2l2
ZSBkZXNjZW50ICsgUHJhdHQgZXhwcmVzc2lvbnMg4oaSIEFTVFxuLy9cbi8vIEdyYW1tYXIgc2tl
dGNoOlxuLy8gICBwcm9ncmFtICAgID0geyBjb25zdERlY2wgfCB2YXJEZWNsIHwgZnVuY3Rpb24g
fCBzdWJyb3V0aW5lIHwgaW1wb3J0IHwgZXhwb3J0IGZ1bmN0aW9uIH1cbi8vICAgZnVuY3Rpb24g
ICA9ICdmdW5jdGlvbicgSUQgJygnIHBhcmFtcyAnKScgJzonIFRZUEUgW3ZhciBsb2NhbHNdICdi
ZWdpbicgc3RtdHMgJ2VuZCdcbi8vICAgc3Vicm91dGluZSA9ICdzdWJyb3V0aW5lJyBJRCAnKCcg
cGFyYW1zICcpJyBbdmFyIGxvY2Fsc10gJ2JlZ2luJyBzdG10cyAnZW5kJ1xuLy8gICBwYXJhbXMg
ICAgID0gbmFtZSB7JywnIG5hbWV9ICc6JyBUWVBFIHsnLCcgcGFyYW1zfSAgICDigJQgY29tbWEt
c2VwYXJhdGVkIG5hbWVzIHNoYXJlIGEgdHlwZVxuLy8gICBzdG10ICAgICAgID0gaWYgfCBmb3Ig
fCB3aGlsZSB8IGRvLXdoaWxlIHwgYnJlYWsgfCB0YWlsY2FsbCB8IGNhbGwgfCBhc3NpZ24gfCBh
cnJheVN0b3JlXG4vLyAgIGFzc2lnbiAgICAgPSBJRCAnOj0nIGV4cHIgIHwgIElEICcrPScgZXhw
ciAgfCAgSUQgJy89JyBleHByICAoZXRjLilcbi8vICAgaWYgICAgICAgICA9ICdpZicgJygnIGV4
cHIgJyknICd0aGVuJyBzdG10cyBbJ2Vsc2UnIHN0bXRzIHwgJ2Vsc2UnIGlmXSAnZW5kJyAnaWYn
XG4vLyAgIGZvciAgICAgICAgPSAnZm9yJyBJRCAnOj0nIGV4cHIgJywnIGV4cHIgWycsJyBzdGVw
XSBzdG10cyAnZW5kJyAnZm9yJ1xuLy8gICBleHByICAgICAgID0gUHJhdHQgZXhwcmVzc2lvbiAo
c2VlIGxicCBmb3IgcHJlY2VkZW5jZSB0b3dlcilcbi8vICAgYXRvbSAgICAgICA9IG51bWJlciB8
IElEIHwgSUQgJygnIGFyZ3MgJyknIHwgSUQgJ1snIGluZGljZXMgJ10nIHwgJygnIGV4cHIgJykn
XG4vLyAgICAgICAgICAgICAgfCBUWVBFICcoJyBhcmdzICcpJyAg4oCUIHR5cGUgY29udmVyc2lv
biAvIHZlY3RvciBjb25zdHJ1Y3RvclxuLy8gICAgICAgICAgICAgIHwgJ2lmJyAnKCcgZXhwciAn
KScgJ3RoZW4nIGV4cHIgJ2Vsc2UnIGV4cHIgIOKAlCB0ZXJuYXJ5XG5cblxuXG5mdW5jdGlvbiBw
YXJzZSh0b2tlbnMpIHtcbiAgbGV0IHBvcyA9IDA7XG4gIGZ1bmN0aW9uIGN1cigpIHsgcmV0dXJu
IHRva2Vuc1twb3NdOyB9XG4gIGZ1bmN0aW9uIGF0KHR5cGUsIHZhbHVlKSB7IGNvbnN0IHQgPSBj
dXIoKTsgcmV0dXJuIHQudHlwZSA9PT0gdHlwZSAmJiAodmFsdWUgPT09IHVuZGVmaW5lZCB8fCB0
LnZhbHVlID09PSB2YWx1ZSk7IH1cbiAgZnVuY3Rpb24gZWF0KHR5cGUsIHZhbHVlKSB7XG4gICAg
Y29uc3QgdCA9IGN1cigpO1xuICAgIGlmICh0LnR5cGUgIT09IHR5cGUgfHwgKHZhbHVlICE9PSB1
bmRlZmluZWQgJiYgdC52YWx1ZSAhPT0gdmFsdWUpKVxuICAgICAgdGhyb3cgbmV3IFN5bnRheEVy
cm9yKGBFeHBlY3RlZCAke3ZhbHVlIHx8IHR5cGV9IGJ1dCBnb3QgXCIke3QudmFsdWV9XCIgYXQg
JHt0LmxpbmV9OiR7dC5jb2x9YCk7XG4gICAgcG9zKys7XG4gICAgcmV0dXJuIHQ7XG4gIH1cbiAg
ZnVuY3Rpb24gbWF5YmUodHlwZSwgdmFsdWUpIHsgaWYgKGF0KHR5cGUsIHZhbHVlKSkgeyBwb3Mr
KzsgcmV0dXJuIHRydWU7IH0gcmV0dXJuIGZhbHNlOyB9XG5cbiAgZnVuY3Rpb24gcGFyc2VQcm9n
cmFtKCkge1xuICAgIGNvbnN0IGJvZHkgPSBbXTtcbiAgICB3aGlsZSAoIWF0KFRPSy5FT0YpKSB7
XG4gICAgICBpZiAoYXQoVE9LLktXLCAnY29uc3QnKSAmJiAhaXNMb2NhbENvbnRleHQoKSkgYm9k
eS5wdXNoKHBhcnNlR2xvYmFsQ29uc3QoKSk7XG4gICAgICBlbHNlIGlmIChhdChUT0suS1csICd2
YXInKSAmJiAhaXNMb2NhbENvbnRleHQoKSkgYm9keS5wdXNoKHBhcnNlR2xvYmFsVmFyKCkpO1xu
ICAgICAgZWxzZSBpZiAoYXQoVE9LLktXLCAnZnVuY3Rpb24nKSkgYm9keS5wdXNoKHBhcnNlRnVu
Y3Rpb24oKSk7XG4gICAgICBlbHNlIGlmIChhdChUT0suS1csICdzdWJyb3V0aW5lJykpIGJvZHku
cHVzaChwYXJzZVN1YnJvdXRpbmUoKSk7XG4gICAgICBlbHNlIGlmIChhdChUT0suS1csICdpbXBv
cnQnKSkgYm9keS5wdXNoKHBhcnNlSW1wb3J0KCkpO1xuICAgICAgZWxzZSBpZiAoYXQoVE9LLktX
LCAnZXhwb3J0JykpIHsgcG9zKys7IGJvZHkucHVzaChwYXJzZUZ1bmN0aW9uKHRydWUpKTsgfVxu
ICAgICAgZWxzZSB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFVuZXhwZWN0ZWQgXCIke2N1cigpLnZh
bHVlfVwiIGF0ICR7Y3VyKCkubGluZX06JHtjdXIoKS5jb2x9YCk7XG4gICAgfVxuICAgIHJldHVy
biB7IHR5cGU6ICdQcm9ncmFtJywgYm9keSB9O1xuICB9XG5cbiAgZnVuY3Rpb24gaXNMb2NhbENv
bnRleHQoKSB7IHJldHVybiBmYWxzZTsgfSAvLyBnbG9iYWxzIG9ubHkgYXQgdG9wIGxldmVsXG5c
biAgLy8gUGFyc2UgZnVuY3Rpb24gdHlwZSBzaWduYXR1cmU6IGZ1bmN0aW9uKHg6IGY2NCwgeTog
ZjY0KTogZjY0XG4gIGZ1bmN0aW9uIHBhcnNlRnVuY1R5cGVTaWcoKSB7XG4gICAgZWF0KFRPSy5L
VywgJ2Z1bmN0aW9uJyk7XG4gICAgZWF0KFRPSy5QVU5DLCAnKCcpO1xuICAgIGNvbnN0IHBhcmFt
cyA9IGF0KFRPSy5QVU5DLCAnKScpID8gW10gOiBwYXJzZVBhcmFtRW50cmllcygpO1xuICAgIGVh
dChUT0suUFVOQywgJyknKTtcbiAgICBsZXQgcmV0VHlwZSA9IG51bGw7XG4gICAgaWYgKG1heWJl
KFRPSy5QVU5DLCAnOicpKSByZXRUeXBlID0gZWF0KFRPSy5LVykudmFsdWU7XG4gICAgcmV0dXJu
IHsgcGFyYW1zLCByZXRUeXBlIH07XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUdsb2JhbENvbnN0
KCkge1xuICAgIGVhdChUT0suS1csICdjb25zdCcpO1xuICAgIGNvbnN0IG5hbWUgPSBlYXQoVE9L
LklEKS52YWx1ZTtcbiAgICBlYXQoVE9LLlBVTkMsICc6Jyk7XG4gICAgY29uc3QgdnR5cGUgPSBl
YXQoVE9LLktXKS52YWx1ZTtcbiAgICBlYXQoVE9LLk9QLCAnPScpO1xuICAgIGNvbnN0IGluaXQg
PSBwYXJzZUV4cHIoMCk7XG4gICAgcmV0dXJuIHsgdHlwZTogJ0NvbnN0RGVjbCcsIG5hbWUsIHZ0
eXBlLCBpbml0IH07XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUdsb2JhbFZhcigpIHtcbiAgICBl
YXQoVE9LLktXLCAndmFyJyk7XG4gICAgY29uc3QgbmFtZSA9IGVhdChUT0suSUQpLnZhbHVlO1xu
ICAgIGVhdChUT0suUFVOQywgJzonKTtcbiAgICBpZiAoYXQoVE9LLktXLCAnZnVuY3Rpb24nKSkg
e1xuICAgICAgY29uc3QgZnVuY1NpZyA9IHBhcnNlRnVuY1R5cGVTaWcoKTtcbiAgICAgIGxldCBp
bml0ID0gbnVsbDtcbiAgICAgIGlmIChtYXliZShUT0suT1AsICc9JykpIGluaXQgPSBwYXJzZUV4
cHIoMCk7XG4gICAgICByZXR1cm4geyB0eXBlOiAnVmFyRGVjbCcsIG5hbWUsIHZ0eXBlOiAnaTMy
JywgZnVuY1NpZywgaW5pdCB9O1xuICAgIH1cbiAgICBjb25zdCB2dHlwZSA9IGVhdChUT0suS1cp
LnZhbHVlO1xuICAgIGxldCBpbml0ID0gbnVsbDtcbiAgICBpZiAobWF5YmUoVE9LLk9QLCAnPScp
KSBpbml0ID0gcGFyc2VFeHByKDApO1xuICAgIHJldHVybiB7IHR5cGU6ICdWYXJEZWNsJywgbmFt
ZSwgdnR5cGUsIGluaXQgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlSW1wb3J0KCkge1xuICAg
IGVhdChUT0suS1csICdpbXBvcnQnKTtcbiAgICAvLyBpbXBvcnQgZnVuY3Rpb24gbmFtZShwYXJh
bXMpOiByZXRUeXBlIGZyb20gJ21vZHVsZSdcbiAgICAvLyBpbXBvcnQgbmFtZSA9ICR7aW50ZXJw
fVxuICAgIC8vIGltcG9ydCBuYW1lKHBhcmFtcyk6IHJldFR5cGUgPSAke2ludGVycH1cbiAgICBp
ZiAoYXQoVE9LLktXLCAnZnVuY3Rpb24nKSkge1xuICAgICAgcG9zKys7XG4gICAgfVxuICAgIGNv
bnN0IG5hbWUgPSBlYXQoVE9LLklEKS52YWx1ZTtcbiAgICBsZXQgcGFyYW1zID0gW10sIHJldFR5
cGUgPSBudWxsLCBtb2R1bGVOYW1lID0gJ2hvc3QnLCBpbnRlcnBJZHggPSBudWxsO1xuICAgIGlm
IChhdChUT0suUFVOQywgJygnKSkge1xuICAgICAgcGFyYW1zID0gcGFyc2VQYXJhbUxpc3QoKTtc
biAgICB9XG4gICAgaWYgKG1heWJlKFRPSy5QVU5DLCAnOicpKSB7XG4gICAgICByZXRUeXBlID0g
ZWF0KFRPSy5LVykudmFsdWU7XG4gICAgfVxuICAgIGlmIChtYXliZShUT0suT1AsICc9JykpIHtc
biAgICAgIC8vIGludGVycG9sYXRpb24gbWFya2VyXG4gICAgICBjb25zdCB0ID0gZWF0KFRPSy5J
RCk7XG4gICAgICBpbnRlcnBJZHggPSB0LnZhbHVlO1xuICAgIH0gZWxzZSBpZiAobWF5YmUoVE9L
LktXLCAnZnJvbScpKSB7XG4gICAgICAvLyAnbW9kdWxlJyDigJQgd2UganVzdCByZWFkIHRoZSBp
ZGVudGlmaWVyIGFzIGEgc3RyaW5nLWxpa2UgdGhpbmdcbiAgICAgIG1vZHVsZU5hbWUgPSBlYXQo
VE9LLklEKS52YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHsgdHlwZTogJ0ltcG9ydERlY2wnLCBu
YW1lLCBwYXJhbXMsIHJldFR5cGUsIG1vZHVsZU5hbWUsIGludGVycElkeCB9O1xuICB9XG5cbiAg
ZnVuY3Rpb24gcGFyc2VGdW5jdGlvbihleHBvcnRlZCA9IGZhbHNlKSB7XG4gICAgZWF0KFRPSy5L
VywgJ2Z1bmN0aW9uJyk7XG4gICAgY29uc3QgbmFtZSA9IGVhdChUT0suSUQpLnZhbHVlO1xuICAg
IGVhdChUT0suUFVOQywgJygnKTtcbiAgICBjb25zdCBwYXJhbXMgPSBhdChUT0suUFVOQywgJykn
KSA/IFtdIDogcGFyc2VQYXJhbUVudHJpZXMoKTtcbiAgICBlYXQoVE9LLlBVTkMsICcpJyk7XG4g
ICAgZWF0KFRPSy5QVU5DLCAnOicpO1xuICAgIGNvbnN0IHJldFR5cGUgPSBlYXQoVE9LLktXKS52
YWx1ZTtcbiAgICBjb25zdCBsb2NhbHMgPSBbXTtcbiAgICBpZiAoYXQoVE9LLktXLCAndmFyJykp
IHtcbiAgICAgIHBvcysrO1xuICAgICAgd2hpbGUgKCFhdChUT0suS1csICdiZWdpbicpKSB7XG4g
ICAgICAgIGNvbnN0IGxuYW1lcyA9IFtlYXQoVE9LLklEKS52YWx1ZV07XG4gICAgICAgIHdoaWxl
IChtYXliZShUT0suUFVOQywgJywnKSkgbG5hbWVzLnB1c2goZWF0KFRPSy5JRCkudmFsdWUpO1xu
ICAgICAgICBlYXQoVE9LLlBVTkMsICc6Jyk7XG4gICAgICAgIGlmIChhdChUT0suS1csICdmdW5j
dGlvbicpKSB7XG4gICAgICAgICAgY29uc3QgZnVuY1NpZyA9IHBhcnNlRnVuY1R5cGVTaWcoKTtc
biAgICAgICAgICBmb3IgKGNvbnN0IGxuIG9mIGxuYW1lcykgbG9jYWxzLnB1c2goeyB0eXBlOiAn
TG9jYWwnLCBuYW1lOiBsbiwgdnR5cGU6ICdpMzInLCBmdW5jU2lnIH0pO1xuICAgICAgICB9IGVs
c2Uge1xuICAgICAgICAgIGNvbnN0IGx0ID0gZWF0KFRPSy5LVykudmFsdWU7XG4gICAgICAgICAg
Zm9yIChjb25zdCBsbiBvZiBsbmFtZXMpIGxvY2Fscy5wdXNoKHsgdHlwZTogJ0xvY2FsJywgbmFt
ZTogbG4sIHZ0eXBlOiBsdCB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBlYXQo
VE9LLktXLCAnYmVnaW4nKTtcbiAgICBjb25zdCBib2R5ID0gcGFyc2VTdGF0ZW1lbnRzKCdlbmQn
KTtcbiAgICBlYXQoVE9LLktXLCAnZW5kJyk7XG4gICAgcmV0dXJuIHsgdHlwZTogJ0Z1bmN0aW9u
JywgbmFtZSwgcGFyYW1zLCByZXRUeXBlLCBsb2NhbHMsIGJvZHksIGV4cG9ydGVkIH07XG4gIH1c
blxuICBmdW5jdGlvbiBwYXJzZVN1YnJvdXRpbmUoKSB7XG4gICAgZWF0KFRPSy5LVywgJ3N1YnJv
dXRpbmUnKTtcbiAgICBjb25zdCBuYW1lID0gZWF0KFRPSy5JRCkudmFsdWU7XG4gICAgZWF0KFRP
Sy5QVU5DLCAnKCcpO1xuICAgIGNvbnN0IHBhcmFtcyA9IGF0KFRPSy5QVU5DLCAnKScpID8gW10g
OiBwYXJzZVBhcmFtRW50cmllcygpO1xuICAgIGVhdChUT0suUFVOQywgJyknKTtcbiAgICBjb25z
dCBsb2NhbHMgPSBbXTtcbiAgICBpZiAoYXQoVE9LLktXLCAndmFyJykpIHtcbiAgICAgIHBvcysr
O1xuICAgICAgd2hpbGUgKCFhdChUT0suS1csICdiZWdpbicpKSB7XG4gICAgICAgIGNvbnN0IGxu
YW1lcyA9IFtlYXQoVE9LLklEKS52YWx1ZV07XG4gICAgICAgIHdoaWxlIChtYXliZShUT0suUFVO
QywgJywnKSkgbG5hbWVzLnB1c2goZWF0KFRPSy5JRCkudmFsdWUpO1xuICAgICAgICBlYXQoVE9L
LlBVTkMsICc6Jyk7XG4gICAgICAgIGlmIChhdChUT0suS1csICdmdW5jdGlvbicpKSB7XG4gICAg
ICAgICAgY29uc3QgZnVuY1NpZyA9IHBhcnNlRnVuY1R5cGVTaWcoKTtcbiAgICAgICAgICBmb3Ig
KGNvbnN0IGxuIG9mIGxuYW1lcykgbG9jYWxzLnB1c2goeyB0eXBlOiAnTG9jYWwnLCBuYW1lOiBs
biwgdnR5cGU6ICdpMzInLCBmdW5jU2lnIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAg
IGNvbnN0IGx0ID0gZWF0KFRPSy5LVykudmFsdWU7XG4gICAgICAgICAgZm9yIChjb25zdCBsbiBv
ZiBsbmFtZXMpIGxvY2Fscy5wdXNoKHsgdHlwZTogJ0xvY2FsJywgbmFtZTogbG4sIHZ0eXBlOiBs
dCB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBlYXQoVE9LLktXLCAnYmVnaW4n
KTtcbiAgICBjb25zdCBib2R5ID0gcGFyc2VTdGF0ZW1lbnRzKCdlbmQnKTtcbiAgICBlYXQoVE9L
LktXLCAnZW5kJyk7XG4gICAgcmV0dXJuIHsgdHlwZTogJ1N1YnJvdXRpbmUnLCBuYW1lLCBwYXJh
bXMsIGxvY2FscywgYm9keSB9O1xuICB9XG5cbiAgLy8gUGFyYW0gZ3JvdXBpbmc6IFwieCwgeTog
ZjY0XCIgc2hhcmVzIGEgdHlwZSBhY3Jvc3MgY29tbWEtc2VwYXJhdGVkIG5hbWVzLlxuICAvLyBU
aGUgbG9va2FoZWFkIChwb3MrMiBpcyAnLCcgb3IgJzonKSBkaXN0aW5ndWlzaGVzIGdyb3VwZWQg
bmFtZXMgZnJvbSB0aGUgbmV4dCBwYXJhbSBncm91cC5cbiAgZnVuY3Rpb24gcGFyc2VQYXJhbUVu
dHJpZXMoKSB7XG4gICAgY29uc3QgcGFyYW1zID0gW107XG4gICAgd2hpbGUgKGN1cigpLnR5cGUg
PT09IFRPSy5JRCkge1xuICAgICAgY29uc3QgbmFtZXMgPSBbZWF0KFRPSy5JRCkudmFsdWVdO1xu
ICAgICAgd2hpbGUgKGF0KFRPSy5QVU5DLCAnLCcpICYmIHRva2Vuc1twb3MgKyAxXSAmJiB0b2tl
bnNbcG9zICsgMV0udHlwZSA9PT0gVE9LLklEICYmXG4gICAgICAgICAgICAgdG9rZW5zW3BvcyAr
IDJdICYmICh0b2tlbnNbcG9zICsgMl0udmFsdWUgPT09ICcsJyB8fCB0b2tlbnNbcG9zICsgMl0u
dmFsdWUgPT09ICc6JykpIHtcbiAgICAgICAgcG9zKys7IC8vIHNraXAgLFxuICAgICAgICBuYW1l
cy5wdXNoKGVhdChUT0suSUQpLnZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGVhdChUT0suUFVOQywg
JzonKTtcbiAgICAgIC8vIGZ1bmN0aW9uIHR5cGU6IGNhbGxiYWNrOiBmdW5jdGlvbih4OiBmNjQp
OiBmNjRcbiAgICAgIGlmIChhdChUT0suS1csICdmdW5jdGlvbicpKSB7XG4gICAgICAgIGNvbnN0
IGZ1bmNTaWcgPSBwYXJzZUZ1bmNUeXBlU2lnKCk7XG4gICAgICAgIGZvciAoY29uc3QgbiBvZiBu
YW1lcykgcGFyYW1zLnB1c2goeyB0eXBlOiAnUGFyYW0nLCBuYW1lOiBuLCB2dHlwZTogJ2kzMics
IGlzQXJyYXk6IGZhbHNlLCBhcnJheURpbXM6IG51bGwsIGZ1bmNTaWcgfSk7XG4gICAgICAgIG1h
eWJlKFRPSy5QVU5DLCAnLCcpOyAvLyBjb25zdW1lIGNvbW1hIGJldHdlZW4gcGFyYW0gZ3JvdXBz
XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgbGV0IGlzQXJyYXkgPSBmYWxzZSwg
YXJyYXlEaW1zID0gbnVsbDtcbiAgICAgIGlmIChhdChUT0suS1csICdhcnJheScpKSB7XG4gICAg
ICAgIHBvcysrO1xuICAgICAgICBpc0FycmF5ID0gdHJ1ZTtcbiAgICAgICAgaWYgKGF0KFRPSy5Q
VU5DLCAnKCcpKSB7XG4gICAgICAgICAgcG9zKys7XG4gICAgICAgICAgYXJyYXlEaW1zID0gW107
XG4gICAgICAgICAgYXJyYXlEaW1zLnB1c2gocGFyc2VFeHByKDApKTtcbiAgICAgICAgICB3aGls
ZSAobWF5YmUoVE9LLlBVTkMsICcsJykpIGFycmF5RGltcy5wdXNoKHBhcnNlRXhwcigwKSk7XG4g
ICAgICAgICAgZWF0KFRPSy5QVU5DLCAnKScpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBj
b25zdCB2dHlwZSA9IGVhdChUT0suS1cpLnZhbHVlO1xuICAgICAgZm9yIChjb25zdCBuIG9mIG5h
bWVzKSBwYXJhbXMucHVzaCh7IHR5cGU6ICdQYXJhbScsIG5hbWU6IG4sIHZ0eXBlLCBpc0FycmF5
LCBhcnJheURpbXMgfSk7XG4gICAgICBtYXliZShUT0suUFVOQywgJywnKTsgLy8gY29uc3VtZSBj
b21tYSBiZXR3ZWVuIHBhcmFtIGdyb3Vwc1xuICAgIH1cbiAgICByZXR1cm4gcGFyYW1zO1xuICB9
XG5cbiAgZnVuY3Rpb24gcGFyc2VQYXJhbUxpc3QoKSB7XG4gICAgLy8gc2ltcGxpZmllZCBwYXJh
bSBsaXN0IGZvciBpbXBvcnRzOiBuYW1lOiB0eXBlLCAuLi5cbiAgICBlYXQoVE9LLlBVTkMsICco
Jyk7XG4gICAgY29uc3QgcGFyYW1zID0gW107XG4gICAgd2hpbGUgKGN1cigpLnR5cGUgPT09IFRP
Sy5JRCkge1xuICAgICAgY29uc3QgbmFtZXMgPSBbZWF0KFRPSy5JRCkudmFsdWVdO1xuICAgICAg
d2hpbGUgKGF0KFRPSy5QVU5DLCAnLCcpICYmIHRva2Vuc1twb3MgKyAxXSAmJiB0b2tlbnNbcG9z
ICsgMV0udHlwZSA9PT0gVE9LLklEICYmXG4gICAgICAgICAgICAgdG9rZW5zW3BvcyArIDJdICYm
ICh0b2tlbnNbcG9zICsgMl0udmFsdWUgPT09ICcsJyB8fCB0b2tlbnNbcG9zICsgMl0udmFsdWUg
PT09ICc6JykpIHtcbiAgICAgICAgcG9zKys7XG4gICAgICAgIG5hbWVzLnB1c2goZWF0KFRPSy5J
RCkudmFsdWUpO1xuICAgICAgfVxuICAgICAgZWF0KFRPSy5QVU5DLCAnOicpO1xuICAgICAgY29u
c3QgdnR5cGUgPSBlYXQoVE9LLktXKS52YWx1ZTtcbiAgICAgIGZvciAoY29uc3QgbiBvZiBuYW1l
cykgcGFyYW1zLnB1c2goeyB0eXBlOiAnUGFyYW0nLCBuYW1lOiBuLCB2dHlwZSwgaXNBcnJheTog
ZmFsc2UsIGFycmF5RGltczogbnVsbCB9KTtcbiAgICAgIG1heWJlKFRPSy5QVU5DLCAnLCcpOyAv
LyBjb25zdW1lIGNvbW1hIGJldHdlZW4gcGFyYW0gZ3JvdXBzXG4gICAgfVxuICAgIGVhdChUT0su
UFVOQywgJyknKTtcbiAgICByZXR1cm4gcGFyYW1zO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VT
dGF0ZW1lbnRzKGVuZEt3KSB7XG4gICAgY29uc3Qgc3RtdHMgPSBbXTtcbiAgICB3aGlsZSAoIWF0
KFRPSy5LVywgZW5kS3cpICYmICFhdChUT0suRU9GKSkge1xuICAgICAgLy8gYWxzbyBzdG9wIGF0
ICdlbHNlJyBmb3IgaWYgYmxvY2tzXG4gICAgICBpZiAoZW5kS3cgPT09ICdlbmQnICYmIGF0KFRP
Sy5LVywgJ2Vsc2UnKSkgYnJlYWs7XG4gICAgICBzdG10cy5wdXNoKHBhcnNlU3RhdGVtZW50KCkp
O1xuICAgIH1cbiAgICByZXR1cm4gc3RtdHM7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVN0YXRl
bWVudCgpIHtcbiAgICBpZiAoYXQoVE9LLktXLCAnaWYnKSkgcmV0dXJuIHBhcnNlSWYoKTtcbiAg
ICBpZiAoYXQoVE9LLktXLCAnZm9yJykpIHJldHVybiBwYXJzZUZvcigpO1xuICAgIGlmIChhdChU
T0suS1csICd3aGlsZScpKSByZXR1cm4gcGFyc2VXaGlsZSgpO1xuICAgIGlmIChhdChUT0suS1cs
ICdkbycpKSByZXR1cm4gcGFyc2VEb1doaWxlKCk7XG4gICAgaWYgKGF0KFRPSy5LVywgJ2JyZWFr
JykpIHsgcG9zKys7IHJldHVybiB7IHR5cGU6ICdCcmVhaycgfTsgfVxuICAgIGlmIChhdChUT0su
S1csICd0YWlsY2FsbCcpKSB7IHBvcysrOyBjb25zdCBuYW1lID0gZWF0KFRPSy5JRCkudmFsdWU7
IGVhdChUT0suUFVOQywgJygnKTsgY29uc3QgYXJncyA9IHBhcnNlQXJncygpOyBlYXQoVE9LLlBV
TkMsICcpJyk7IHJldHVybiB7IHR5cGU6ICdUYWlsQ2FsbCcsIG5hbWUsIGFyZ3MgfTsgfVxuICAg
IGlmIChhdChUT0suS1csICdjYWxsJykpIHsgcG9zKys7IGNvbnN0IG5hbWUgPSBhdChUT0suS1cs
ICdyZXR1cm4nKSA/IChwb3MrKywgJ3JldHVybicpIDogZWF0KFRPSy5JRCkudmFsdWU7IGVhdChU
T0suUFVOQywgJygnKTsgY29uc3QgYXJncyA9IHBhcnNlQXJncygpOyBlYXQoVE9LLlBVTkMsICcp
Jyk7IHJldHVybiB7IHR5cGU6ICdDYWxsJywgbmFtZSwgYXJncyB9OyB9XG5cbiAgICAvLyBhc3Np
Z25tZW50IG9yIGV4cHJlc3Npb24gc3RhdGVtZW50XG4gICAgLy8gbG9vayBhaGVhZDogaWQgOj0g
LyBpZFsuLi5dIDo9IC8gaWQgKz0gZXRjLlxuICAgIGlmIChjdXIoKS50eXBlID09PSBUT0suSUQp
IHtcbiAgICAgIGNvbnN0IG5hbWUgPSBjdXIoKS52YWx1ZTtcbiAgICAgIC8vIGNoZWNrIGZvciBh
cnJheSBzdG9yZTogaWRbXG4gICAgICBpZiAodG9rZW5zW3BvcyArIDFdICYmIHRva2Vuc1twb3Mg
KyAxXS52YWx1ZSA9PT0gJ1snKSB7XG4gICAgICAgIHBvcysrO1xuICAgICAgICBlYXQoVE9LLlBV
TkMsICdbJyk7XG4gICAgICAgIGNvbnN0IGluZGljZXMgPSBbcGFyc2VFeHByKDApXTtcbiAgICAg
ICAgd2hpbGUgKG1heWJlKFRPSy5QVU5DLCAnLCcpKSBpbmRpY2VzLnB1c2gocGFyc2VFeHByKDAp
KTtcbiAgICAgICAgZWF0KFRPSy5QVU5DLCAnXScpO1xuICAgICAgICBpZiAoYXQoVE9LLk9QLCAn
Oj0nKSkge1xuICAgICAgICAgIHBvcysrO1xuICAgICAgICAgIGNvbnN0IHZhbHVlID0gcGFyc2VF
eHByKDApO1xuICAgICAgICAgIHJldHVybiB7IHR5cGU6ICdBcnJheVN0b3JlJywgbmFtZSwgaW5k
aWNlcywgdmFsdWUgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjb21wb3VuZCBhc3NpZ25tZW50
IG9uIGFycmF5XG4gICAgICAgIGNvbnN0IGNvcCA9IGN1cigpLnZhbHVlO1xuICAgICAgICBpZiAo
Y29wID09PSAnKz0nIHx8IGNvcCA9PT0gJy09JyB8fCBjb3AgPT09ICcqPScgfHwgY29wID09PSAn
Lz0nKSB7XG4gICAgICAgICAgLy8gTm90ZTogLz0gaXMgYW1iaWd1b3VzIOKAlCBhcyBhIHN0YXRl
bWVudCBzdGFydCBhZnRlciBhcnJheSBhY2Nlc3MsIGl0J3MgY29tcG91bmQgYXNzaWduXG4gICAg
ICAgICAgcG9zKys7XG4gICAgICAgICAgY29uc3QgcmhzID0gcGFyc2VFeHByKDApO1xuICAgICAg
ICAgIGNvbnN0IG9wID0gY29wWzBdOyAvLyArLCAtLCAqLCAvXG4gICAgICAgICAgcmV0dXJuIHsg
dHlwZTogJ0FycmF5U3RvcmUnLCBuYW1lLCBpbmRpY2VzLCB2YWx1ZToge1xuICAgICAgICAgICAg
dHlwZTogJ0Jpbk9wJywgb3AsIGxlZnQ6IHsgdHlwZTogJ0FycmF5QWNjZXNzJywgbmFtZSwgaW5k
aWNlcyB9LCByaWdodDogcmhzXG4gICAgICAgICAgfX07XG4gICAgICAgIH1cbiAgICAgICAgdGhy
b3cgbmV3IFN5bnRheEVycm9yKGBFeHBlY3RlZCA6PSBvciBjb21wb3VuZCBhc3NpZ25tZW50IGFm
dGVyIGFycmF5IGFjY2VzcyBhdCAke2N1cigpLmxpbmV9OiR7Y3VyKCkuY29sfWApO1xuICAgICAg
fVxuICAgICAgaWYgKHRva2Vuc1twb3MgKyAxXSAmJiB0b2tlbnNbcG9zICsgMV0udmFsdWUgPT09
ICc6PScpIHtcbiAgICAgICAgcG9zKys7IHBvcysrO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHBh
cnNlRXhwcigwKTtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogJ0Fzc2lnbicsIG5hbWUsIHZhbHVl
IH07XG4gICAgICB9XG4gICAgICAvLyBjb21wb3VuZCBhc3NpZ25tZW50OiArPSwgLT0sICo9XG4g
ICAgICBpZiAodG9rZW5zW3BvcyArIDFdICYmICh0b2tlbnNbcG9zICsgMV0udmFsdWUgPT09ICcr
PScgfHwgdG9rZW5zW3BvcyArIDFdLnZhbHVlID09PSAnLT0nIHx8IHRva2Vuc1twb3MgKyAxXS52
YWx1ZSA9PT0gJyo9JykpIHtcbiAgICAgICAgY29uc3QgY29wID0gdG9rZW5zW3BvcyArIDFdLnZh
bHVlO1xuICAgICAgICBjb25zdCBvcCA9IGNvcFswXTtcbiAgICAgICAgcG9zKys7IHBvcysrO1xu
ICAgICAgICBjb25zdCByaHMgPSBwYXJzZUV4cHIoMCk7XG4gICAgICAgIHJldHVybiB7IHR5cGU6
ICdBc3NpZ24nLCBuYW1lLCB2YWx1ZTogeyB0eXBlOiAnQmluT3AnLCBvcCwgbGVmdDogeyB0eXBl
OiAnSWRlbnQnLCBuYW1lIH0sIHJpZ2h0OiByaHMgfSB9O1xuICAgICAgfVxuICAgICAgLy8gLz0g
Y29tcG91bmQgYXNzaWdubWVudCAob25seSB3aGVuIG5vdCBpbiBleHByZXNzaW9uIGNvbnRleHQg
4oCUIHN0YXRlbWVudCBsZXZlbClcbiAgICAgIC8vIERpc2FtYmlndWF0aW9uOiBhdCBzdGF0ZW1l
bnQgbGV2ZWwsIGlkIC89IGV4cHIgaXMgY29tcG91bmQgZGl2aWRlLWFzc2lnblxuICAgICAgLy8g
QnV0IC89IGlzIGFsc28gbm90LWVxdWFsIG9wZXJhdG9yLiBBdCBzdGF0ZW1lbnQgbGV2ZWw6IGlk
IC89IGV4cHIg4oaSIGRpdmlkZS1hc3NpZ24uXG4gICAgICBpZiAodG9rZW5zW3BvcyArIDFdICYm
IHRva2Vuc1twb3MgKyAxXS52YWx1ZSA9PT0gJy89Jykge1xuICAgICAgICAvLyBsb29rIGZ1cnRo
ZXI6IGlmIHRoaXMgaXMgYSBzdGFuZGFsb25lIHN0YXRlbWVudCAoaWQgLz0gZXhwciksIHRyZWF0
IGFzIGNvbXBvdW5kIGFzc2lnblxuICAgICAgICBjb25zdCBvcCA9ICcvJztcbiAgICAgICAgcG9z
Kys7IHBvcysrO1xuICAgICAgICBjb25zdCByaHMgPSBwYXJzZUV4cHIoMCk7XG4gICAgICAgIHJl
dHVybiB7IHR5cGU6ICdBc3NpZ24nLCBuYW1lLCB2YWx1ZTogeyB0eXBlOiAnQmluT3AnLCBvcCwg
bGVmdDogeyB0eXBlOiAnSWRlbnQnLCBuYW1lIH0sIHJpZ2h0OiByaHMgfSB9O1xuICAgICAgfVxu
ICAgIH1cblxuICAgIC8vIGV4cHJlc3Npb24gc3RhdGVtZW50IChlLmcuLCBiYXJlIGZ1bmN0aW9u
IGNhbGwpXG4gICAgY29uc3QgZXhwciA9IHBhcnNlRXhwcigwKTtcbiAgICBpZiAoZXhwci50eXBl
ID09PSAnRnVuY0NhbGwnKSByZXR1cm4geyB0eXBlOiAnQ2FsbCcsIG5hbWU6IGV4cHIubmFtZSwg
YXJnczogZXhwci5hcmdzIH07XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVk
IGV4cHJlc3Npb24gc3RhdGVtZW50IGF0ICR7Y3VyKCkubGluZX06JHtjdXIoKS5jb2x9YCk7XG4g
IH1cblxuICAvLyBUaGUgaXNFbHNlSWYgZmxhZyBjb250cm9scyAnZW5kIGlmJyBjb25zdW1wdGlv
bjogaW5uZXIgaWYgaW4gYW4gZWxzZS1pZiBjaGFpblxuICAvLyBsZXRzIHRoZSBvdXRlcm1vc3Qg
aWYgY29uc3VtZSB0aGUgc2luZ2xlICdlbmQgaWYnLiBXaXRob3V0IHRoaXMsIGVhY2ggbGV2ZWxc
biAgLy8gd291bGQgZWF0IG9uZSAnZW5kJyBhbmQgdGhlIG5lc3Rpbmcgd291bGQgYnJlYWsuXG4g
IGZ1bmN0aW9uIHBhcnNlSWYoaXNFbHNlSWYpIHtcbiAgICBlYXQoVE9LLktXLCAnaWYnKTtcbiAg
ICBlYXQoVE9LLlBVTkMsICcoJyk7XG4gICAgY29uc3QgY29uZCA9IHBhcnNlRXhwcigwKTtcbiAg
ICBlYXQoVE9LLlBVTkMsICcpJyk7XG4gICAgZWF0KFRPSy5LVywgJ3RoZW4nKTtcbiAgICBjb25z
dCBib2R5ID0gW107XG4gICAgd2hpbGUgKCFhdChUT0suS1csICdlbHNlJykgJiYgIWF0KFRPSy5L
VywgJ2VuZCcpICYmICFhdChUT0suRU9GKSkge1xuICAgICAgYm9keS5wdXNoKHBhcnNlU3RhdGVt
ZW50KCkpO1xuICAgIH1cbiAgICBsZXQgZWxzZUJvZHkgPSBudWxsO1xuICAgIGlmIChtYXliZShU
T0suS1csICdlbHNlJykpIHtcbiAgICAgIGlmIChhdChUT0suS1csICdpZicpKSB7XG4gICAgICAg
IC8vIGVsc2UgaWYgY2hhaW46IGlubmVyIHBhcnNlSWYgaGFuZGxlcyBldmVyeXRoaW5nIGluY2x1
ZGluZyBlbmQgaWZcbiAgICAgICAgZWxzZUJvZHkgPSBbcGFyc2VJZih0cnVlKV07XG4gICAgICB9
IGVsc2Uge1xuICAgICAgICBlbHNlQm9keSA9IFtdO1xuICAgICAgICB3aGlsZSAoIWF0KFRPSy5L
VywgJ2VuZCcpICYmICFhdChUT0suRU9GKSkge1xuICAgICAgICAgIGVsc2VCb2R5LnB1c2gocGFy
c2VTdGF0ZW1lbnQoKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gT25seSBj
b25zdW1lICdlbmQgaWYnIGF0IHRoZSBvdXRlcm1vc3QgaWYgKG5vdCBpbiBlbHNlLWlmIGNoYWlu
KVxuICAgIGlmICghaXNFbHNlSWYgJiYgYXQoVE9LLktXLCAnZW5kJykpIHtcbiAgICAgIHBvcysr
O1xuICAgICAgbWF5YmUoVE9LLktXLCAnaWYnKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgdHlwZTog
J0lmJywgY29uZCwgYm9keSwgZWxzZUJvZHkgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlRm9y
KCkge1xuICAgIGVhdChUT0suS1csICdmb3InKTtcbiAgICBjb25zdCB2YXJOYW1lID0gZWF0KFRP
Sy5JRCkudmFsdWU7XG4gICAgZWF0KFRPSy5PUCwgJzo9Jyk7XG4gICAgY29uc3Qgc3RhcnQgPSBw
YXJzZUV4cHIoMCk7XG4gICAgZWF0KFRPSy5QVU5DLCAnLCcpO1xuICAgIGNvbnN0IGVuZCA9IHBh
cnNlRXhwcigwKTtcbiAgICBsZXQgc3RlcCA9IG51bGw7XG4gICAgaWYgKG1heWJlKFRPSy5QVU5D
LCAnLCcpKSBzdGVwID0gcGFyc2VFeHByKDApO1xuICAgIGNvbnN0IGJvZHkgPSBbXTtcbiAgICB3
aGlsZSAoIWF0KFRPSy5LVywgJ2VuZCcpICYmICFhdChUT0suRU9GKSkgYm9keS5wdXNoKHBhcnNl
U3RhdGVtZW50KCkpO1xuICAgIGVhdChUT0suS1csICdlbmQnKTtcbiAgICBlYXQoVE9LLktXLCAn
Zm9yJyk7XG4gICAgcmV0dXJuIHsgdHlwZTogJ0ZvcicsIHZhck5hbWUsIHN0YXJ0LCBlbmQsIHN0
ZXAsIGJvZHkgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlV2hpbGUoKSB7XG4gICAgZWF0KFRP
Sy5LVywgJ3doaWxlJyk7XG4gICAgZWF0KFRPSy5QVU5DLCAnKCcpO1xuICAgIGNvbnN0IGNvbmQg
PSBwYXJzZUV4cHIoMCk7XG4gICAgZWF0KFRPSy5QVU5DLCAnKScpO1xuICAgIGNvbnN0IGJvZHkg
PSBbXTtcbiAgICB3aGlsZSAoIWF0KFRPSy5LVywgJ2VuZCcpICYmICFhdChUT0suRU9GKSkgYm9k
eS5wdXNoKHBhcnNlU3RhdGVtZW50KCkpO1xuICAgIGVhdChUT0suS1csICdlbmQnKTtcbiAgICBl
YXQoVE9LLktXLCAnd2hpbGUnKTtcbiAgICByZXR1cm4geyB0eXBlOiAnV2hpbGUnLCBjb25kLCBi
b2R5IH07XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZURvV2hpbGUoKSB7XG4gICAgZWF0KFRPSy5L
VywgJ2RvJyk7XG4gICAgY29uc3QgYm9keSA9IFtdO1xuICAgIHdoaWxlICghYXQoVE9LLktXLCAn
d2hpbGUnKSAmJiAhYXQoVE9LLkVPRikpIGJvZHkucHVzaChwYXJzZVN0YXRlbWVudCgpKTtcbiAg
ICBlYXQoVE9LLktXLCAnd2hpbGUnKTtcbiAgICBlYXQoVE9LLlBVTkMsICcoJyk7XG4gICAgY29u
c3QgY29uZCA9IHBhcnNlRXhwcigwKTtcbiAgICBlYXQoVE9LLlBVTkMsICcpJyk7XG4gICAgcmV0
dXJuIHsgdHlwZTogJ0RvV2hpbGUnLCBjb25kLCBib2R5IH07XG4gIH1cblxuICBmdW5jdGlvbiBw
YXJzZUFyZ3MoKSB7XG4gICAgY29uc3QgYXJncyA9IFtdO1xuICAgIGlmICghYXQoVE9LLlBVTkMs
ICcpJykpIHtcbiAgICAgIGFyZ3MucHVzaChwYXJzZUV4cHIoMCkpO1xuICAgICAgd2hpbGUgKG1h
eWJlKFRPSy5QVU5DLCAnLCcpKSBhcmdzLnB1c2gocGFyc2VFeHByKDApKTtcbiAgICB9XG4gICAg
cmV0dXJuIGFyZ3M7XG4gIH1cblxuICAvLyDilIDilIAgUHJhdHQgZXhwcmVzc2lvbiBwYXJzZXIg
4pSA4pSAXG5cbiAgLy8gQmluZGluZyBwb3dlcnMgKGhpZ2hlciA9IHRpZ2h0ZXIpOlxuICAvLyAg
IG9yKDIpIDwgYW5kKDQpIDwgPT0vPS88IC8+Lzw9Lz49KDYpIDwgfCg4KSA8IF4oMTApIDwgJigx
MilcbiAgLy8gICA8IDw8Lz4+ICgxNCkgPCArLy0oMTYpIDwgKi/Dty9tb2QoMTgpIDwgKiooMjIs
IHJpZ2h0LWFzc29jKVxuICBmdW5jdGlvbiBsYnAodG9rKSB7XG4gICAgaWYgKHRvay50eXBlID09
PSBUT0suS1cpIHtcbiAgICAgIGlmICh0b2sudmFsdWUgPT09ICdvcicpIHJldHVybiAyO1xuICAg
ICAgaWYgKHRvay52YWx1ZSA9PT0gJ2FuZCcpIHJldHVybiA0O1xuICAgICAgaWYgKHRvay52YWx1
ZSA9PT0gJ21vZCcpIHJldHVybiAxODtcbiAgICB9XG4gICAgaWYgKHRvay50eXBlID09PSBUT0su
T1ApIHtcbiAgICAgIGNvbnN0IHYgPSB0b2sudmFsdWU7XG4gICAgICBpZiAodiA9PT0gJz09JyB8
fCB2ID09PSAnLz0nIHx8IHYgPT09ICc8JyB8fCB2ID09PSAnPicgfHwgdiA9PT0gJzw9JyB8fCB2
ID09PSAnPj0nKSByZXR1cm4gNjtcbiAgICAgIGlmICh2ID09PSAnfCcpIHJldHVybiA4O1xuICAg
ICAgaWYgKHYgPT09ICdeJykgcmV0dXJuIDEwO1xuICAgICAgaWYgKHYgPT09ICcmJykgcmV0dXJu
IDEyO1xuICAgICAgaWYgKHYgPT09ICc8PCcgfHwgdiA9PT0gJz4+JykgcmV0dXJuIDE0O1xuICAg
ICAgaWYgKHYgPT09ICcrJyB8fCB2ID09PSAnLScpIHJldHVybiAxNjtcbiAgICAgIGlmICh2ID09
PSAnKicgfHwgdiA9PT0gJy8nKSByZXR1cm4gMTg7XG4gICAgICBpZiAodiA9PT0gJyoqJykgcmV0
dXJuIDIyOyAvLyByaWdodC1hc3NvYzogcGFyc2VFeHByKGJwKSBub3QgcGFyc2VFeHByKGJwKzEp
XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VFeHByKG1pbkJw
KSB7XG4gICAgbGV0IGxlZnQgPSBwYXJzZVByZWZpeCgpO1xuXG4gICAgd2hpbGUgKHRydWUpIHtc
biAgICAgIGNvbnN0IHQgPSBjdXIoKTtcbiAgICAgIGNvbnN0IGJwID0gbGJwKHQpO1xuICAgICAg
aWYgKGJwID09PSAwIHx8IGJwIDwgbWluQnApIGJyZWFrO1xuXG4gICAgICAvLyBpZi1leHByZXNz
aW9uICh0ZXJuYXJ5KTogaWYgKGNvbmQpIHRoZW4gYSBlbHNlIGJcbiAgICAgIC8vIE5vdCBoYW5k
bGVkIGhlcmUg4oCUIGl0J3MgYSBwcmVmaXggZm9ybVxuICAgICAgaWYgKHQudHlwZSA9PT0gVE9L
LktXICYmIHQudmFsdWUgPT09ICdvcicpIHsgcG9zKys7IGxlZnQgPSB7IHR5cGU6ICdCaW5PcCcs
IG9wOiAnb3InLCBsZWZ0LCByaWdodDogcGFyc2VFeHByKGJwICsgMSkgfTsgY29udGludWU7IH1c
biAgICAgIGlmICh0LnR5cGUgPT09IFRPSy5LVyAmJiB0LnZhbHVlID09PSAnYW5kJykgeyBwb3Mr
KzsgbGVmdCA9IHsgdHlwZTogJ0Jpbk9wJywgb3A6ICdhbmQnLCBsZWZ0LCByaWdodDogcGFyc2VF
eHByKGJwICsgMSkgfTsgY29udGludWU7IH1cbiAgICAgIGlmICh0LnR5cGUgPT09IFRPSy5LVyAm
JiB0LnZhbHVlID09PSAnbW9kJykgeyBwb3MrKzsgbGVmdCA9IHsgdHlwZTogJ0Jpbk9wJywgb3A6
ICdtb2QnLCBsZWZ0LCByaWdodDogcGFyc2VFeHByKGJwICsgMSkgfTsgY29udGludWU7IH1cblxu
ICAgICAgaWYgKHQudHlwZSA9PT0gVE9LLk9QKSB7XG4gICAgICAgIGlmICh0LnZhbHVlID09PSAn
KionKSB7XG4gICAgICAgICAgcG9zKys7XG4gICAgICAgICAgLy8gUmlnaHQtYXNzb2NpYXRpdml0
eSB0cmljazogcGFyc2VFeHByKGJwKSBpbnN0ZWFkIG9mIHBhcnNlRXhwcihicCsxKVxuICAgICAg
ICAgIC8vIGxldHMgMioqMyoqNCBwYXJzZSBhcyAyKiooMyoqNCkuXG4gICAgICAgICAgbGVmdCA9
IHsgdHlwZTogJ0Jpbk9wJywgb3A6ICcqKicsIGxlZnQsIHJpZ2h0OiBwYXJzZUV4cHIoYnApIH07
XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgcG9zKys7XG4gICAgICAg
IGxlZnQgPSB7IHR5cGU6ICdCaW5PcCcsIG9wOiB0LnZhbHVlLCBsZWZ0LCByaWdodDogcGFyc2VF
eHByKGJwICsgMSkgfTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBicmVhaztc
biAgICB9XG4gICAgcmV0dXJuIGxlZnQ7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVByZWZpeCgp
IHtcbiAgICBjb25zdCB0ID0gY3VyKCk7XG5cbiAgICAvLyBwYXJlbnRoZXNpemVkIGV4cHJlc3Np
b25cbiAgICBpZiAodC50eXBlID09PSBUT0suUFVOQyAmJiB0LnZhbHVlID09PSAnKCcpIHtcbiAg
ICAgIHBvcysrO1xuICAgICAgY29uc3QgZXhwciA9IHBhcnNlRXhwcigwKTtcbiAgICAgIGVhdChU
T0suUFVOQywgJyknKTtcbiAgICAgIHJldHVybiBleHByO1xuICAgIH1cblxuICAgIC8vIGlmLWV4
cHJlc3Npb24gKHRlcm5hcnkpOiBpZiAoY29uZCkgdGhlbiBhIGVsc2UgYlxuICAgIGlmICh0LnR5
cGUgPT09IFRPSy5LVyAmJiB0LnZhbHVlID09PSAnaWYnKSB7XG4gICAgICBwb3MrKztcbiAgICAg
IGVhdChUT0suUFVOQywgJygnKTtcbiAgICAgIGNvbnN0IGNvbmQgPSBwYXJzZUV4cHIoMCk7XG4g
ICAgICBlYXQoVE9LLlBVTkMsICcpJyk7XG4gICAgICBlYXQoVE9LLktXLCAndGhlbicpO1xuICAg
ICAgY29uc3QgdGhlbkV4cHIgPSBwYXJzZUV4cHIoMCk7XG4gICAgICBlYXQoVE9LLktXLCAnZWxz
ZScpO1xuICAgICAgY29uc3QgZWxzZUV4cHIgPSBwYXJzZUV4cHIoMCk7XG4gICAgICByZXR1cm4g
eyB0eXBlOiAnSWZFeHByJywgY29uZCwgdGhlbkV4cHIsIGVsc2VFeHByIH07XG4gICAgfVxuXG4g
ICAgLy8gdW5hcnkgbWludXNcbiAgICBpZiAodC50eXBlID09PSBUT0suT1AgJiYgdC52YWx1ZSA9
PT0gJy0nKSB7XG4gICAgICBwb3MrKztcbiAgICAgIHJldHVybiB7IHR5cGU6ICdVbmFyeU9wJywg
b3A6ICctJywgb3BlcmFuZDogcGFyc2VFeHByKDIxKSB9O1xuICAgIH1cbiAgICAvLyBub3RcbiAg
ICBpZiAodC50eXBlID09PSBUT0suS1cgJiYgdC52YWx1ZSA9PT0gJ25vdCcpIHtcbiAgICAgIHBv
cysrO1xuICAgICAgcmV0dXJuIHsgdHlwZTogJ1VuYXJ5T3AnLCBvcDogJ25vdCcsIG9wZXJhbmQ6
IHBhcnNlRXhwcigyMSkgfTtcbiAgICB9XG4gICAgLy8gYml0d2lzZSBub3RcbiAgICBpZiAodC50
eXBlID09PSBUT0suT1AgJiYgdC52YWx1ZSA9PT0gJ34nKSB7XG4gICAgICBwb3MrKztcbiAgICAg
IHJldHVybiB7IHR5cGU6ICdVbmFyeU9wJywgb3A6ICd+Jywgb3BlcmFuZDogcGFyc2VFeHByKDIx
KSB9O1xuICAgIH1cbiAgICAvLyBmdW5jdGlvbiByZWZlcmVuY2U6IEBmdW5jbmFtZSDihpIgdGFi
bGUgaW5kZXhcbiAgICBpZiAodC50eXBlID09PSBUT0suT1AgJiYgdC52YWx1ZSA9PT0gJ0AnKSB7
XG4gICAgICBwb3MrKztcbiAgICAgIGNvbnN0IG5hbWUgPSBjdXIoKTtcbiAgICAgIGlmIChuYW1l
LnR5cGUgIT09IFRPSy5JRCkgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBFeHBlY3RlZCBmdW5jdGlv
biBuYW1lIGFmdGVyIEAgYXQgJHtuYW1lLmxpbmV9OiR7bmFtZS5jb2x9YCk7XG4gICAgICBwb3Mr
KztcbiAgICAgIC8vIGNvbnN1bWUgZG90dGVkIHBhcnRzOiBAbnMuZnVuY1xuICAgICAgbGV0IGZ1
bGxOYW1lID0gbmFtZS52YWx1ZTtcbiAgICAgIHdoaWxlIChjdXIoKS50eXBlID09PSBUT0suT1Ag
JiYgY3VyKCkudmFsdWUgPT09ICcuJyAmJiB0b2tlbnNbcG9zICsgMV0gJiYgdG9rZW5zW3BvcyAr
IDFdLnR5cGUgPT09IFRPSy5JRCkge1xuICAgICAgICBwb3MrKzsgLy8gc2tpcCBkb3RcbiAgICAg
ICAgZnVsbE5hbWUgKz0gJy4nICsgY3VyKCkudmFsdWU7XG4gICAgICAgIHBvcysrOyAvLyBza2lw
IGlkXG4gICAgICB9XG4gICAgICByZXR1cm4geyB0eXBlOiAnRnVuY1JlZicsIG5hbWU6IGZ1bGxO
YW1lIH07XG4gICAgfVxuICAgIC8vIG51bWJlciBsaXRlcmFsXG4gICAgaWYgKHQudHlwZSA9PT0g
VE9LLk5VTSkge1xuICAgICAgcG9zKys7XG4gICAgICByZXR1cm4geyB0eXBlOiAnTnVtYmVyTGl0
JywgdmFsdWU6IHQudmFsdWUsIGlzRmxvYXQ6IHQuaXNGbG9hdCwgdHlwZVN1ZmZpeDogdC50eXBl
U3VmZml4IH07XG4gICAgfVxuICAgIC8vIHRydWUvZmFsc2VcbiAgICBpZiAodC50eXBlID09PSBU
T0suS1cgJiYgKHQudmFsdWUgPT09ICd0cnVlJyB8fCB0LnZhbHVlID09PSAnZmFsc2UnKSkge1xu
ICAgICAgcG9zKys7XG4gICAgICByZXR1cm4geyB0eXBlOiAnTnVtYmVyTGl0JywgdmFsdWU6IHQu
dmFsdWUgPT09ICd0cnVlJyA/ICcxJyA6ICcwJywgaXNGbG9hdDogZmFsc2UsIHR5cGVTdWZmaXg6
ICdpMzInIH07XG4gICAgfVxuICAgIC8vIGlkZW50aWZpZXIg4oCUIG1heSBiZSBmdW5jdGlvbiBj
YWxsLCBhcnJheSBhY2Nlc3MsIG9yIHBsYWluIHZhcmlhYmxlXG4gICAgaWYgKHQudHlwZSA9PT0g
VE9LLklEKSB7XG4gICAgICBwb3MrKztcbiAgICAgIGNvbnN0IG5hbWUgPSB0LnZhbHVlO1xuICAg
ICAgLy8gZnVuY3Rpb24gY2FsbDogbmFtZSguLi4pXG4gICAgICBpZiAoYXQoVE9LLlBVTkMsICco
JykpIHtcbiAgICAgICAgcG9zKys7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSBwYXJzZUFyZ3MoKTtc
biAgICAgICAgZWF0KFRPSy5QVU5DLCAnKScpO1xuICAgICAgICByZXR1cm4geyB0eXBlOiAnRnVu
Y0NhbGwnLCBuYW1lLCBhcmdzIH07XG4gICAgICB9XG4gICAgICAvLyBhcnJheSBhY2Nlc3M6IG5h
bWVbLi4uXVxuICAgICAgaWYgKGF0KFRPSy5QVU5DLCAnWycpKSB7XG4gICAgICAgIHBvcysrO1xu
ICAgICAgICBjb25zdCBpbmRpY2VzID0gW3BhcnNlRXhwcigwKV07XG4gICAgICAgIHdoaWxlICht
YXliZShUT0suUFVOQywgJywnKSkgaW5kaWNlcy5wdXNoKHBhcnNlRXhwcigwKSk7XG4gICAgICAg
IGVhdChUT0suUFVOQywgJ10nKTtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogJ0FycmF5QWNjZXNz
JywgbmFtZSwgaW5kaWNlcyB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgdHlwZTogJ0lkZW50
JywgbmFtZSB9O1xuICAgIH1cbiAgICAvLyB0eXBlIGNvbnZlcnNpb24gLyB2ZWN0b3IgY29uc3Ry
dWN0b3I6IGkzMiguLi4pLCBmNjQoLi4uKSwgZjY0eDIoYSwgYiksIGV0Yy5cbiAgICBpZiAodC50
eXBlID09PSBUT0suS1cgJiYgQVRSQV9UWVBFUy5oYXModC52YWx1ZSkgJiYgdG9rZW5zW3BvcyAr
IDFdICYmIHRva2Vuc1twb3MgKyAxXS52YWx1ZSA9PT0gJygnKSB7XG4gICAgICBwb3MrKzsgLy8g
c2tpcCB0eXBlIGtleXdvcmRcbiAgICAgIHBvcysrOyAvLyBza2lwIChcbiAgICAgIGNvbnN0IGFy
Z3MgPSBwYXJzZUFyZ3MoKTtcbiAgICAgIGVhdChUT0suUFVOQywgJyknKTtcbiAgICAgIHJldHVy
biB7IHR5cGU6ICdGdW5jQ2FsbCcsIG5hbWU6IHQudmFsdWUsIGFyZ3MgfTtcbiAgICB9XG4gICAg
dGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIHRva2VuIFwiJHt0LnZhbHVlfVwiIGF0
ICR7dC5saW5lfToke3QuY29sfWApO1xuICB9XG5cbiAgcmV0dXJuIHBhcnNlUHJvZ3JhbSgpO1xu
fVxuXG4vLyAtLSBvcGNvZGVzLmpzIC0tXG5cbi8vIE9wY29kZXMg4oCUIFdhc20gb3Bjb2RlIGNv
bnN0YW50cywgdHlwZSBjb2RlcywgYW5kIFNJTUQgb3BzXG4vL1xuLy8gVGhlIFdhc20gb3Bjb2Rl
IHNwYWNlIGlzIG9yZ2FuaXplZCBieSBjYXRlZ29yeTogY29udHJvbCBmbG93IGF0IDB4MDAsIHZh
cmlhYmxlIGFjY2Vzc1xuLy8gYXQgMHgyMCwgbWVtb3J5IGF0IDB4MjgsIGNvbnN0YW50cyBhdCAw
eDQxLiBXaXRoaW4gdGhlIGFyaXRobWV0aWMgcmVnaW9uICgweDQ14oCTMHhhNiksXG4vLyBvcGNv
ZGVzIGZvcm0gYSB0eXBlw5dvcGVyYXRpb24gZ3JpZDogZWFjaCBvcGVyYXRpb24gaGFzIGZvdXIg
dmFyaWFudHMgKGkzMi9pNjQvZjMyL2Y2NClcbi8vIGxhaWQgb3V0IGluIGNvbnRpZ3VvdXMgYmxv
Y2tzLiBUd28tYnl0ZSBvcGNvZGVzICgweEZDLzB4RkQgcHJlZml4KSBleHRlbmQgdGhlIHNwYWNl
XG4vLyBmb3Igc2F0dXJhdGluZyB0cnVuY2F0aW9uIGFuZCBTSU1ELlxuXG4vLyDilIDilIAgQ29u
dHJvbCBmbG93ICgweDAw4oCTMHgxYikg4pSA4pSAXG5jb25zdCBPUF9VTlJFQUNIQUJMRSA9IDB4
MDAsIE9QX05PUCA9IDB4MDEsIE9QX0JMT0NLID0gMHgwMiwgT1BfTE9PUCA9IDB4MDMsXG4gIE9Q
X0lGID0gMHgwNCwgT1BfRUxTRSA9IDB4MDUsIE9QX0VORCA9IDB4MGIsIE9QX0JSID0gMHgwYywg
T1BfQlJfSUYgPSAweDBkLFxuICBPUF9SRVRVUk4gPSAweDBmLCBPUF9DQUxMID0gMHgxMCwgT1Bf
Q0FMTF9JTkRJUkVDVCA9IDB4MTEsXG4gIE9QX1JFVFVSTl9DQUxMID0gMHgxMiwgT1BfUkVUVVJO
X0NBTExfSU5ESVJFQ1QgPSAweDEzLCBPUF9TRUxFQ1QgPSAweDFiLFxuXG4vLyDilIDilIAgVmFy
aWFibGUgYWNjZXNzICgweDIw4oCTMHgyNCkg4pSA4pSAXG4gIE9QX0xPQ0FMX0dFVCA9IDB4MjAs
IE9QX0xPQ0FMX1NFVCA9IDB4MjEsIE9QX0xPQ0FMX1RFRSA9IDB4MjIsXG4gIE9QX0dMT0JBTF9H
RVQgPSAweDIzLCBPUF9HTE9CQUxfU0VUID0gMHgyNCxcblxuLy8g4pSA4pSAIE1lbW9yeSAoMHgy
OOKAkzB4NDApIOKUgOKUgFxuICBPUF9JMzJfTE9BRCA9IDB4MjgsIE9QX0k2NF9MT0FEID0gMHgy
OSwgT1BfRjMyX0xPQUQgPSAweDJhLCBPUF9GNjRfTE9BRCA9IDB4MmIsXG4gIE9QX0kzMl9TVE9S
RSA9IDB4MzYsIE9QX0k2NF9TVE9SRSA9IDB4MzcsIE9QX0YzMl9TVE9SRSA9IDB4MzgsIE9QX0Y2
NF9TVE9SRSA9IDB4MzksXG4gIE9QX01FTU9SWV9TSVpFID0gMHgzZiwgT1BfTUVNT1JZX0dST1cg
PSAweDQwLFxuXG4vLyDilIDilIAgQ29uc3RhbnRzICgweDQx4oCTMHg0NCkg4pSA4pSAXG4gIE9Q
X0kzMl9DT05TVCA9IDB4NDEsIE9QX0k2NF9DT05TVCA9IDB4NDIsIE9QX0YzMl9DT05TVCA9IDB4
NDMsIE9QX0Y2NF9DT05TVCA9IDB4NDQsXG5cbi8vIOKUgOKUgCBDb21wYXJpc29uICgweDQ14oCT
MHg2Nikg4oCUIHR5cGXDl29wZXJhdGlvbiBncmlkOiBlcXovZXEvbmUvbHQvZ3QvbGUvZ2UgcGVy
IHR5cGUg4pSA4pSAXG4gIE9QX0kzMl9FUVogPSAweDQ1LCBPUF9JMzJfRVEgPSAweDQ2LCBPUF9J
MzJfTkUgPSAweDQ3LFxuICBPUF9JMzJfTFRfUyA9IDB4NDgsIE9QX0kzMl9MVF9VID0gMHg0OSwg
T1BfSTMyX0dUX1MgPSAweDRhLCBPUF9JMzJfR1RfVSA9IDB4NGIsXG4gIE9QX0kzMl9MRV9TID0g
MHg0YywgT1BfSTMyX0xFX1UgPSAweDRkLCBPUF9JMzJfR0VfUyA9IDB4NGUsIE9QX0kzMl9HRV9V
ID0gMHg0ZixcbiAgT1BfSTY0X0VRWiA9IDB4NTAsIE9QX0k2NF9FUSA9IDB4NTEsIE9QX0k2NF9O
RSA9IDB4NTIsXG4gIE9QX0k2NF9MVF9TID0gMHg1MywgT1BfSTY0X0xUX1UgPSAweDU0LCBPUF9J
NjRfR1RfUyA9IDB4NTUsIE9QX0k2NF9HVF9VID0gMHg1NixcbiAgT1BfSTY0X0xFX1MgPSAweDU3
LCBPUF9JNjRfTEVfVSA9IDB4NTgsIE9QX0k2NF9HRV9TID0gMHg1OSwgT1BfSTY0X0dFX1UgPSAw
eDVhLFxuICBPUF9GMzJfRVEgPSAweDViLCBPUF9GMzJfTkUgPSAweDVjLCBPUF9GMzJfTFQgPSAw
eDVkLCBPUF9GMzJfR1QgPSAweDVlLCBPUF9GMzJfTEUgPSAweDVmLCBPUF9GMzJfR0UgPSAweDYw
LFxuICBPUF9GNjRfRVEgPSAweDYxLCBPUF9GNjRfTkUgPSAweDYyLCBPUF9GNjRfTFQgPSAweDYz
LCBPUF9GNjRfR1QgPSAweDY0LCBPUF9GNjRfTEUgPSAweDY1LCBPUF9GNjRfR0UgPSAweDY2LFxu
XG4vLyDilIDilIAgaTMyIGFyaXRobWV0aWMgKDB4NjfigJMweDc4KSDilIDilIBcbiAgT1BfSTMy
X0NMWiA9IDB4NjcsIE9QX0kzMl9DVFogPSAweDY4LCBPUF9JMzJfUE9QQ05UID0gMHg2OSxcbiAg
T1BfSTMyX0FERCA9IDB4NmEsIE9QX0kzMl9TVUIgPSAweDZiLCBPUF9JMzJfTVVMID0gMHg2Yyxc
biAgT1BfSTMyX0RJVl9TID0gMHg2ZCwgT1BfSTMyX0RJVl9VID0gMHg2ZSwgT1BfSTMyX1JFTV9T
ID0gMHg2ZiwgT1BfSTMyX1JFTV9VID0gMHg3MCxcbiAgT1BfSTMyX0FORCA9IDB4NzEsIE9QX0kz
Ml9PUiA9IDB4NzIsIE9QX0kzMl9YT1IgPSAweDczLFxuICBPUF9JMzJfU0hMID0gMHg3NCwgT1Bf
STMyX1NIUl9TID0gMHg3NSwgT1BfSTMyX1NIUl9VID0gMHg3NixcbiAgT1BfSTMyX1JPVEwgPSAw
eDc3LCBPUF9JMzJfUk9UUiA9IDB4NzgsXG5cbi8vIOKUgOKUgCBpNjQgYXJpdGhtZXRpYyAoMHg3
OeKAkzB4OGEpIOKUgOKUgFxuICBPUF9JNjRfQ0xaID0gMHg3OSwgT1BfSTY0X0NUWiA9IDB4N2Es
IE9QX0k2NF9QT1BDTlQgPSAweDdiLFxuICBPUF9JNjRfQUREID0gMHg3YywgT1BfSTY0X1NVQiA9
IDB4N2QsIE9QX0k2NF9NVUwgPSAweDdlLFxuICBPUF9JNjRfRElWX1MgPSAweDdmLCBPUF9JNjRf
RElWX1UgPSAweDgwLCBPUF9JNjRfUkVNX1MgPSAweDgxLCBPUF9JNjRfUkVNX1UgPSAweDgyLFxu
ICBPUF9JNjRfQU5EID0gMHg4MywgT1BfSTY0X09SID0gMHg4NCwgT1BfSTY0X1hPUiA9IDB4ODUs
XG4gIE9QX0k2NF9TSEwgPSAweDg2LCBPUF9JNjRfU0hSX1MgPSAweDg3LCBPUF9JNjRfU0hSX1Ug
PSAweDg4LFxuICBPUF9JNjRfUk9UTCA9IDB4ODksIE9QX0k2NF9ST1RSID0gMHg4YSxcblxuLy8g
4pSA4pSAIGYzMiB1bmFyeSArIGJpbmFyeSAoMHg4YuKAkzB4OTgpIOKUgOKUgFxuICBPUF9GMzJf
QUJTID0gMHg4YiwgT1BfRjMyX05FRyA9IDB4OGMsIE9QX0YzMl9DRUlMID0gMHg4ZCwgT1BfRjMy
X0ZMT09SID0gMHg4ZSxcbiAgT1BfRjMyX1RSVU5DID0gMHg4ZiwgT1BfRjMyX05FQVJFU1QgPSAw
eDkwLCBPUF9GMzJfU1FSVCA9IDB4OTEsXG4gIE9QX0YzMl9BREQgPSAweDkyLCBPUF9GMzJfU1VC
ID0gMHg5MywgT1BfRjMyX01VTCA9IDB4OTQsIE9QX0YzMl9ESVYgPSAweDk1LFxuICBPUF9GMzJf
TUlOID0gMHg5NiwgT1BfRjMyX01BWCA9IDB4OTcsIE9QX0YzMl9DT1BZU0lHTiA9IDB4OTgsXG5c
bi8vIOKUgOKUgCBmNjQgdW5hcnkgKyBiaW5hcnkgKDB4OTnigJMweGE2KSDilIDilIBcbiAgT1Bf
RjY0X0FCUyA9IDB4OTksIE9QX0Y2NF9ORUcgPSAweDlhLCBPUF9GNjRfQ0VJTCA9IDB4OWIsIE9Q
X0Y2NF9GTE9PUiA9IDB4OWMsXG4gIE9QX0Y2NF9UUlVOQyA9IDB4OWQsIE9QX0Y2NF9ORUFSRVNU
ID0gMHg5ZSwgT1BfRjY0X1NRUlQgPSAweDlmLFxuICBPUF9GNjRfQUREID0gMHhhMCwgT1BfRjY0
X1NVQiA9IDB4YTEsIE9QX0Y2NF9NVUwgPSAweGEyLCBPUF9GNjRfRElWID0gMHhhMyxcbiAgT1Bf
RjY0X01JTiA9IDB4YTQsIE9QX0Y2NF9NQVggPSAweGE1LCBPUF9GNjRfQ09QWVNJR04gPSAweGE2
LFxuXG4vLyDilIDilIAgQ29udmVyc2lvbnMgKDB4YTfigJMweGM0KSDilIDilIBcbiAgT1BfSTMy
X1dSQVBfSTY0ID0gMHhhNyxcbiAgT1BfSTMyX1RSVU5DX0YzMl9TID0gMHhhOCwgT1BfSTMyX1RS
VU5DX0Y2NF9TID0gMHhhYSxcbiAgT1BfSTY0X0VYVEVORF9JMzJfUyA9IDB4YWMsIE9QX0k2NF9F
WFRFTkRfSTMyX1UgPSAweGFkLFxuICBPUF9JNjRfVFJVTkNfRjMyX1MgPSAweGFlLCBPUF9JNjRf
VFJVTkNfRjY0X1MgPSAweGIwLFxuICBPUF9GMzJfQ09OVkVSVF9JMzJfUyA9IDB4YjIsIE9QX0Yz
Ml9DT05WRVJUX0k2NF9TID0gMHhiNCxcbiAgT1BfRjMyX0RFTU9URV9GNjQgPSAweGI2LFxuICBP
UF9GNjRfQ09OVkVSVF9JMzJfUyA9IDB4YjcsIE9QX0Y2NF9DT05WRVJUX0k2NF9TID0gMHhiOSxc
biAgT1BfRjY0X1BST01PVEVfRjMyID0gMHhiYixcbiAgT1BfSTMyX1JFSU5URVJQUkVUX0YzMiA9
IDB4YmMsIE9QX0k2NF9SRUlOVEVSUFJFVF9GNjQgPSAweGJkLFxuICBPUF9GMzJfUkVJTlRFUlBS
RVRfSTMyID0gMHhiZSwgT1BfRjY0X1JFSU5URVJQUkVUX0k2NCA9IDB4YmYsXG4gIE9QX0kzMl9F
WFRFTkQ4X1MgPSAweGMwLCBPUF9JMzJfRVhURU5EMTZfUyA9IDB4YzEsXG4gIE9QX0k2NF9FWFRF
TkQ4X1MgPSAweGMyLCBPUF9JNjRfRVhURU5EMTZfUyA9IDB4YzMsIE9QX0k2NF9FWFRFTkQzMl9T
ID0gMHhjNDtcblxuLy8g4pSA4pSAIEZDIHByZWZpeCAoMHhGQyArIHUzMikg4oCUIHNhdHVyYXRp
bmcgdHJ1bmNhdGlvbiDilIDilIBcbmNvbnN0IE9QX0ZDX1BSRUZJWCA9IDB4ZmM7XG5jb25zdCBP
UF9JMzJfVFJVTkNfU0FUX0YzMl9TID0gMCwgT1BfSTMyX1RSVU5DX1NBVF9GMzJfVSA9IDEsXG4g
IE9QX0kzMl9UUlVOQ19TQVRfRjY0X1MgPSAyLCBPUF9JMzJfVFJVTkNfU0FUX0Y2NF9VID0gMyxc
biAgT1BfSTY0X1RSVU5DX1NBVF9GMzJfUyA9IDQsIE9QX0k2NF9UUlVOQ19TQVRfRjMyX1UgPSA1
LFxuICBPUF9JNjRfVFJVTkNfU0FUX0Y2NF9TID0gNiwgT1BfSTY0X1RSVU5DX1NBVF9GNjRfVSA9
IDc7XG5cbi8vIOKUgOKUgCBUeXBlIGNvZGVzIOKUgOKUgFxuLy8gRGVzY2VuZGluZyBmcm9tIDB4
N2Y6IGkzMiwgaTY0LCBmMzIsIGY2NCwgdjEyOC4gVGhlc2UgYXJlIG5lZ2F0aXZlIHZhbHVlcyBp
blxuLy8gc2lnbmVkIExFQjEyOCwgd2hpY2ggaXMgaG93IHRoZXkgYXBwZWFyIGluIGZ1bmN0aW9u
IHNpZ25hdHVyZXMgYW5kIGxvY2FsIGRlY2xhcmF0aW9ucy5cbmNvbnN0IFdBU01fSTMyID0gMHg3
ZiwgV0FTTV9JNjQgPSAweDdlLCBXQVNNX0YzMiA9IDB4N2QsIFdBU01fRjY0ID0gMHg3YztcbmNv
bnN0IFdBU01fVjEyOCA9IDB4N2I7XG5jb25zdCBXQVNNX1ZPSUQgPSAweDQwO1xuXG4vLyDilIDi
lIAgU0lNRCBwcmVmaXggKDB4RkQgKyB1MzIpIOKUgOKUgFxuY29uc3QgT1BfU0lNRF9QUkVGSVgg
PSAweGZkO1xuXG4vLyBTSU1EIG9wY29kZSB0YWJsZSDigJQga2V5ZWQgYnkgXCJ0eXBlLm9wZXJh
dGlvblwiIGZvciBlYXN5IGxvb2t1cCBmcm9tIGNvZGVnZW5cbmNvbnN0IFNJTURfT1BTID0ge1xu
ICAvLyBzcGxhdFxuICAnaTMyeDQuc3BsYXQnOiAweDExLCAnaTY0eDIuc3BsYXQnOiAweDEyLCAn
ZjMyeDQuc3BsYXQnOiAweDEzLCAnZjY0eDIuc3BsYXQnOiAweDE0LFxuICAvLyBleHRyYWN0X2xh
bmVcbiAgJ2kzMng0LmV4dHJhY3RfbGFuZSc6IDB4MWIsICdpNjR4Mi5leHRyYWN0X2xhbmUnOiAw
eDFkLCAnZjMyeDQuZXh0cmFjdF9sYW5lJzogMHgxZiwgJ2Y2NHgyLmV4dHJhY3RfbGFuZSc6IDB4
MjEsXG4gIC8vIHJlcGxhY2VfbGFuZVxuICAnaTMyeDQucmVwbGFjZV9sYW5lJzogMHgxYywgJ2k2
NHgyLnJlcGxhY2VfbGFuZSc6IDB4MWUsICdmMzJ4NC5yZXBsYWNlX2xhbmUnOiAweDIwLCAnZjY0
eDIucmVwbGFjZV9sYW5lJzogMHgyMixcbiAgLy8gYWRkXG4gICdpMzJ4NC5hZGQnOiAweGFlLCAn
aTY0eDIuYWRkJzogMHhjZSwgJ2YzMng0LmFkZCc6IDB4ZTQsICdmNjR4Mi5hZGQnOiAweGYwLFxu
ICAvLyBzdWJcbiAgJ2kzMng0LnN1Yic6IDB4YjEsICdpNjR4Mi5zdWInOiAweGQxLCAnZjMyeDQu
c3ViJzogMHhlNSwgJ2Y2NHgyLnN1Yic6IDB4ZjEsXG4gIC8vIG11bFxuICAnaTMyeDQubXVsJzog
MHhiNSwgJ2k2NHgyLm11bCc6IDB4ZDUsICdmMzJ4NC5tdWwnOiAweGU2LCAnZjY0eDIubXVsJzog
MHhmMixcbiAgLy8gZGl2IChmbG9hdCBvbmx5KVxuICAnZjMyeDQuZGl2JzogMHhlNywgJ2Y2NHgy
LmRpdic6IDB4ZjMsXG4gIC8vIG5lZ1xuICAnaTMyeDQubmVnJzogMHhhMSwgJ2k2NHgyLm5lZyc6
IDB4YzEsICdmMzJ4NC5uZWcnOiAweGUxLCAnZjY0eDIubmVnJzogMHhlZCxcbiAgLy8gYWJzIChm
bG9hdCBvbmx5KVxuICAnZjMyeDQuYWJzJzogMHhlMCwgJ2Y2NHgyLmFicyc6IDB4ZWMsXG4gIC8v
IHNxcnQgKGZsb2F0IG9ubHkpXG4gICdmMzJ4NC5zcXJ0JzogMHhlMywgJ2Y2NHgyLnNxcnQnOiAw
eGVmLFxuICAvLyBtaW4vbWF4IChmbG9hdCBvbmx5KVxuICAnZjMyeDQubWluJzogMHhlOCwgJ2Y2
NHgyLm1pbic6IDB4ZjQsICdmMzJ4NC5tYXgnOiAweGU5LCAnZjY0eDIubWF4JzogMHhmNSxcbiAg
Ly8gY29tcGFyaXNvbiDigJQgZXFcbiAgJ2kzMng0LmVxJzogMHgzNywgJ2k2NHgyLmVxJzogMHhk
NiwgJ2YzMng0LmVxJzogMHg0MSwgJ2Y2NHgyLmVxJzogMHg0NyxcbiAgLy8gbmVcbiAgJ2kzMng0
Lm5lJzogMHgzOCwgJ2YzMng0Lm5lJzogMHg0MiwgJ2Y2NHgyLm5lJzogMHg0OCxcbiAgLy8gbHRc
biAgJ2kzMng0Lmx0X3MnOiAweDM5LCAnaTY0eDIubHRfcyc6IDB4ZDcsICdmMzJ4NC5sdCc6IDB4
NDMsICdmNjR4Mi5sdCc6IDB4NDksXG4gIC8vIGd0XG4gICdpMzJ4NC5ndF9zJzogMHgzYiwgJ2k2
NHgyLmd0X3MnOiAweGQ5LCAnZjMyeDQuZ3QnOiAweDQ0LCAnZjY0eDIuZ3QnOiAweDRhLFxuICAv
LyBsZVxuICAnaTMyeDQubGVfcyc6IDB4M2QsICdpNjR4Mi5sZV9zJzogMHhkYiwgJ2YzMng0Lmxl
JzogMHg0NSwgJ2Y2NHgyLmxlJzogMHg0YixcbiAgLy8gZ2VcbiAgJ2kzMng0LmdlX3MnOiAweDNm
LCAnaTY0eDIuZ2Vfcyc6IDB4ZGQsICdmMzJ4NC5nZSc6IDB4NDYsICdmNjR4Mi5nZSc6IDB4NGMs
XG4gIC8vIHYxMjggYml0d2lzZVxuICAndjEyOC5ub3QnOiAweDRkLCAndjEyOC5hbmQnOiAweDRl
LCAndjEyOC5vcic6IDB4NTAsICd2MTI4Lnhvcic6IDB4NTEsXG4gIC8vIHYxMjggbWVtb3J5XG4g
ICd2MTI4LmxvYWQnOiAweDAwLCAndjEyOC5zdG9yZSc6IDB4MGIsICd2MTI4LmNvbnN0JzogMHgw
YyxcbiAgLy8gcmVsYXhlZCBTSU1EICgweEZEIHByZWZpeCwgb3Bjb2RlcyA+IDB4MTAwKVxuICAn
ZjMyeDQucmVsYXhlZF9tYWRkJzogMHgxMDUsICdmMzJ4NC5yZWxheGVkX25tYWRkJzogMHgxMDYs
XG4gICdmNjR4Mi5yZWxheGVkX21hZGQnOiAweDEwNywgJ2Y2NHgyLnJlbGF4ZWRfbm1hZGQnOiAw
eDEwOCxcbn07XG5cbmZ1bmN0aW9uIHdhc21UeXBlKHQpIHtcbiAgaWYgKHQgPT09ICdpMzInKSBy
ZXR1cm4gV0FTTV9JMzI7XG4gIGlmICh0ID09PSAnaTY0JykgcmV0dXJuIFdBU01fSTY0O1xuICBp
ZiAodCA9PT0gJ2YzMicpIHJldHVybiBXQVNNX0YzMjtcbiAgaWYgKHQgPT09ICdmNjQnKSByZXR1
cm4gV0FTTV9GNjQ7XG4gIGlmIChpc1ZlY3Rvcih0KSkgcmV0dXJuIFdBU01fVjEyODtcbiAgdGhy
b3cgbmV3IEVycm9yKCdVbmtub3duIHR5cGU6ICcgKyB0KTtcbn1cblxuZnVuY3Rpb24gdHlwZVNp
emUodCkge1xuICBpZiAodCA9PT0gJ2kzMicgfHwgdCA9PT0gJ2YzMicpIHJldHVybiA0O1xuICBp
ZiAodCA9PT0gJ2k2NCcgfHwgdCA9PT0gJ2Y2NCcpIHJldHVybiA4O1xuICBpZiAoaXNWZWN0b3Io
dCkpIHJldHVybiAxNjtcbiAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHR5cGU6ICcgKyB0KTtc
bn1cblxuZnVuY3Rpb24gaXNWZWN0b3IodCkgeyByZXR1cm4gdCA9PT0gJ2Y2NHgyJyB8fCB0ID09
PSAnZjMyeDQnIHx8IHQgPT09ICdpMzJ4NCcgfHwgdCA9PT0gJ2k2NHgyJzsgfVxuZnVuY3Rpb24g
dmVjdG9yU2NhbGFyVHlwZSh0KSB7XG4gIGlmICh0ID09PSAnZjY0eDInKSByZXR1cm4gJ2Y2NCc7
XG4gIGlmICh0ID09PSAnZjMyeDQnKSByZXR1cm4gJ2YzMic7XG4gIGlmICh0ID09PSAnaTMyeDQn
KSByZXR1cm4gJ2kzMic7XG4gIGlmICh0ID09PSAnaTY0eDInKSByZXR1cm4gJ2k2NCc7XG4gIHJl
dHVybiBudWxsO1xufVxuXG4vLyAtLSBieXRld3JpdGVyLmpzIC0tXG5cbi8vIEJ5dGVXcml0ZXIg
4oCUIGJpbmFyeSBidWlsZGVyIGZvciBXYXNtIG91dHB1dFxuLy9cbi8vIFdhc20gdXNlcyBMRUIx
MjggKExpdHRsZS1FbmRpYW4gQmFzZSAxMjgpIGZvciBhbGwgaW50ZWdlcnMg4oCUIGEgdmFyaWFi
bGUtbGVuZ3RoXG4vLyBlbmNvZGluZyB3aGVyZSBlYWNoIGJ5dGUgdXNlcyA3IGRhdGEgYml0cyAr
IDEgY29udGludWF0aW9uIGJpdC4gVGhpcyBrZWVwc1xuLy8gc21hbGwgdmFsdWVzIGNvbXBhY3Qg
KDEgYnl0ZSBmb3IgMOKAkzEyNykgd2hpbGUgc3RpbGwgc3VwcG9ydGluZyB0aGUgZnVsbCByYW5n
ZS5cblxuY2xhc3MgQnl0ZVdyaXRlciB7XG4gIGNvbnN0cnVjdG9yKCkgeyB0aGlzLmJ1ZiA9IFtd
OyB9XG4gIGJ5dGUoYikgeyB0aGlzLmJ1Zi5wdXNoKGIgJiAweGZmKTsgfVxuICBieXRlcyhhcnIp
IHsgZm9yIChjb25zdCBiIG9mIGFycikgdGhpcy5ieXRlKGIpOyB9XG4gIHUzMih2KSB7IC8vIExF
QjEyOCB1bnNpZ25lZFxuICAgIGRvIHsgbGV0IGIgPSB2ICYgMHg3ZjsgdiA+Pj49IDc7IGlmICh2
KSBiIHw9IDB4ODA7IHRoaXMuYnl0ZShiKTsgfSB3aGlsZSAodik7XG4gIH1cbiAgczMyKHYpIHsg
Ly8gTEVCMTI4IHNpZ25lZFxuICAgIGxldCBtb3JlID0gdHJ1ZTtcbiAgICB3aGlsZSAobW9yZSkg
e1xuICAgICAgbGV0IGIgPSB2ICYgMHg3ZjsgdiA+Pj0gNztcbiAgICAgIGlmICgodiA9PT0gMCAm
JiAhKGIgJiAweDQwKSkgfHwgKHYgPT09IC0xICYmIChiICYgMHg0MCkpKSBtb3JlID0gZmFsc2U7
IGVsc2UgYiB8PSAweDgwO1xuICAgICAgdGhpcy5ieXRlKGIpO1xuICAgIH1cbiAgfVxuICBzNjQo
dikgeyAvLyBMRUIxMjggc2lnbmVkIGZvciBpNjQgKEJpZ0ludClcbiAgICB2ID0gQmlnSW50KHYp
O1xuICAgIGxldCBtb3JlID0gdHJ1ZTtcbiAgICB3aGlsZSAobW9yZSkge1xuICAgICAgbGV0IGIg
PSBOdW1iZXIodiAmIDB4N2ZuKTsgdiA+Pj0gN247XG4gICAgICBpZiAoKHYgPT09IDBuICYmICEo
YiAmIDB4NDApKSB8fCAodiA9PT0gLTFuICYmIChiICYgMHg0MCkpKSBtb3JlID0gZmFsc2U7IGVs
c2UgYiB8PSAweDgwO1xuICAgICAgdGhpcy5ieXRlKGIpO1xuICAgIH1cbiAgfVxuICBmMzIodikg
eyBjb25zdCBidWYgPSBuZXcgQXJyYXlCdWZmZXIoNCk7IG5ldyBEYXRhVmlldyhidWYpLnNldEZs
b2F0MzIoMCwgdiwgdHJ1ZSk7IHRoaXMuYnl0ZXMobmV3IFVpbnQ4QXJyYXkoYnVmKSk7IH1cbiAg
ZjY0KHYpIHsgY29uc3QgYnVmID0gbmV3IEFycmF5QnVmZmVyKDgpOyBuZXcgRGF0YVZpZXcoYnVm
KS5zZXRGbG9hdDY0KDAsIHYsIHRydWUpOyB0aGlzLmJ5dGVzKG5ldyBVaW50OEFycmF5KGJ1Zikp
OyB9XG4gIHN0cihzKSB7IGNvbnN0IGVuYyA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShzKTsg
dGhpcy51MzIoZW5jLmxlbmd0aCk7IHRoaXMuYnl0ZXMoZW5jKTsgfVxuICAvLyBXYXNtIHNlY3Rp
b25zIGFyZSBsZW5ndGgtcHJlZml4ZWQsIGJ1dCB0aGUgbGVuZ3RoIGlzbid0IGtub3duIHVudGls
IHRoZSBjb250ZW50XG4gIC8vIGlzIHdyaXR0ZW4uIFNvbHV0aW9uOiB3cml0ZSBpbnRvIGEgdGVt
cG9yYXJ5IGJ1ZmZlciwgbWVhc3VyZSwgdGhlbiBlbWl0IGlkICsgc2l6ZSArIGNvbnRlbnQuXG4g
IHNlY3Rpb24oaWQsIGNvbnRlbnRGbikge1xuICAgIGNvbnN0IGlubmVyID0gbmV3IEJ5dGVXcml0
ZXIoKTtcbiAgICBjb250ZW50Rm4oaW5uZXIpO1xuICAgIHRoaXMuYnl0ZShpZCk7XG4gICAgdGhp
cy51MzIoaW5uZXIuYnVmLmxlbmd0aCk7XG4gICAgdGhpcy5ieXRlcyhpbm5lci5idWYpO1xuICB9
XG4gIHRvVWludDhBcnJheSgpIHsgcmV0dXJuIG5ldyBVaW50OEFycmF5KHRoaXMuYnVmKTsgfVxu
fVxuXG4vLyAtLSBjb2RlZ2VuLmpzIC0tXG5cbi8vIENvZGVnZW4g4oCUIEFTVCDihpIgV2FzbSBi
aW5hcnlcbi8vXG4vLyBTaW5nbGUtcGFzcyBjb21waWxlcjogQVNUIGluLCBXYXNtIGJ5dGVzIG91
dC4gTm8gb3B0aW1pemF0aW9uLCBubyBpbnRlcm1lZGlhdGVcbi8vIHJlcHJlc2VudGF0aW9uLiBD
bG9zdXJlLWJhc2VkIGFyY2hpdGVjdHVyZTogZW1pdEZ1bmN0aW9uQm9keSBjYXB0dXJlcyBpbmRl
eCB0YWJsZXNcbi8vIChmdW5jSW5kZXgsIGdsb2JhbEluZGV4LCBsb2NhbE1hcCkgZnJvbSB0aGUg
b3V0ZXIgY29kZWdlbiBzY29wZS5cbi8vXG4vLyBPdXRwdXQgZm9sbG93cyBXYXNtIGJpbmFyeSBz
ZWN0aW9uIG9yZGVyaW5nOiBUeXBlKDEpLCBJbXBvcnQoMiksIEZ1bmN0aW9uKDMpLFxuLy8gVGFi
bGUoNCksIE1lbW9yeSg1KSwgR2xvYmFsKDYpLCBFeHBvcnQoNyksIEVsZW1lbnQoOSksIENvZGUo
MTApLlxuLy9cbi8vIE1vc3QgZW1pdHRlcnMgYnJhbmNoIG9uIHR5cGUgKGY2NC9mMzIvaTMyL2k2
NC92ZWN0b3IpIGJlY2F1c2UgV2FzbSdzIGluc3RydWN0aW9uXG4vLyBzZXQgaXMgZnVsbHkgdHlw
ZWQg4oCUIHRoZXJlJ3Mgbm8gcG9seW1vcnBoaWMgYWRkLCBvbmx5IGkzMi5hZGQsIGY2NC5hZGQs
IGV0Yy5cblxuXG5cblxuLy8gTmVzdGVkIEpTIG9iamVjdHMg4oaSIGZsYXQgXCJhLmIuY1wiIGtl
eXMuIFdhc20gaW1wb3J0cyB1c2UgYSB0d28tbGV2ZWwgbmFtZXNwYWNlXG4vLyAobW9kdWxlICsg
bmFtZSksIHNvIG5lc3RlZCB1c2VyIGltcG9ydHMgbGlrZSB7cGh5c2ljczoge2dyYXZpdHk6IGZu
fX0gbmVlZCBmbGF0dGVuaW5nLlxuZnVuY3Rpb24gZmxhdHRlbkltcG9ydHMob2JqLCBwcmVmaXgp
IHtcbiAgY29uc3QgZmxhdCA9IHt9O1xuICBmb3IgKGNvbnN0IFtrLCB2XSBvZiBPYmplY3QuZW50
cmllcyhvYmopKSB7XG4gICAgaWYgKCFwcmVmaXggJiYgKGsgPT09ICdfX21lbW9yeScgfHwgayA9
PT0gJ21lbW9yeScgfHwgayA9PT0gJ19fdGFibGUnKSkgY29udGludWU7XG4gICAgY29uc3Qga2V5
ID0gcHJlZml4ID8gcHJlZml4ICsgJy4nICsgayA6IGs7XG4gICAgaWYgKHR5cGVvZiB2ID09PSAn
ZnVuY3Rpb24nKSBmbGF0W2tleV0gPSB2O1xuICAgIGVsc2UgaWYgKHYgJiYgdHlwZW9mIHYgPT09
ICdvYmplY3QnICYmICFBcnJheUJ1ZmZlci5pc1ZpZXcodikpIE9iamVjdC5hc3NpZ24oZmxhdCwg
ZmxhdHRlbkltcG9ydHModiwga2V5KSk7XG4gIH1cbiAgcmV0dXJuIGZsYXQ7XG59XG5cbmZ1bmN0
aW9uIGNvZGVnZW4oYXN0LCBpbnRlcnBWYWx1ZXMsIHVzZXJJbXBvcnRzKSB7XG4gIGNvbnN0IHcg
PSBuZXcgQnl0ZVdyaXRlcigpO1xuXG4gIC8vIOKUgOKUgCBDb2xsZWN0IGluZm8g4pSA4pSAXG4g
IGNvbnN0IGdsb2JhbHMgPSBbXTsgICAgLy8geyBuYW1lLCB2dHlwZSwgbXV0YWJsZSwgaW5pdCB9
XG4gIGNvbnN0IGZ1bmN0aW9ucyA9IFtdOyAgLy8gQVNUIG5vZGVzXG4gIGNvbnN0IGltcG9ydHMg
PSBbXTsgICAgLy8geyBuYW1lLCBtb2R1bGVOYW1lLCBwYXJhbXMsIHJldFR5cGUsIGludGVycElk
eCB9XG4gIGNvbnN0IGxvY2FsRnVuY05hbWVzID0gbmV3IFNldCgpO1xuXG4gIGZvciAoY29uc3Qg
bm9kZSBvZiBhc3QuYm9keSkge1xuICAgIGlmIChub2RlLnR5cGUgPT09ICdDb25zdERlY2wnKSBn
bG9iYWxzLnB1c2goeyBuYW1lOiBub2RlLm5hbWUsIHZ0eXBlOiBub2RlLnZ0eXBlLCBtdXRhYmxl
OiBmYWxzZSwgaW5pdDogbm9kZS5pbml0IH0pO1xuICAgIGVsc2UgaWYgKG5vZGUudHlwZSA9PT0g
J1ZhckRlY2wnKSB7XG4gICAgICBjb25zdCBnID0geyBuYW1lOiBub2RlLm5hbWUsIHZ0eXBlOiBu
b2RlLnZ0eXBlLCBtdXRhYmxlOiB0cnVlLCBpbml0OiBub2RlLmluaXQgfTtcbiAgICAgIGlmIChu
b2RlLmZ1bmNTaWcpIGcuZnVuY1NpZyA9IG5vZGUuZnVuY1NpZztcbiAgICAgIGdsb2JhbHMucHVz
aChnKTtcbiAgICB9XG4gICAgZWxzZSBpZiAobm9kZS50eXBlID09PSAnRnVuY3Rpb24nIHx8IG5v
ZGUudHlwZSA9PT0gJ1N1YnJvdXRpbmUnKSB7IGZ1bmN0aW9ucy5wdXNoKG5vZGUpOyBsb2NhbEZ1
bmNOYW1lcy5hZGQobm9kZS5uYW1lKTsgfVxuICAgIGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gJ0lt
cG9ydERlY2wnKSBpbXBvcnRzLnB1c2gobm9kZSk7XG4gIH1cblxuICAvLyBNYXRoIGJ1aWx0aW5z
OiBpbXBvcnRlZCBmcm9tIEpTIE1hdGggb2JqZWN0LiBWYWx1ZSA9IHBhcmFtIGNvdW50LlxuICBj
b25zdCBNQVRIX0JVSUxUSU5TID0geyBzaW46IDEsIGNvczogMSwgbG46IDEsIGV4cDogMSwgcG93
OiAyLCBhdGFuMjogMiB9O1xuICAvLyBOYXRpdmUgYnVpbHRpbnM6IG1hcCBkaXJlY3RseSB0byBX
YXNtIG9wY29kZXMsIG5vIGltcG9ydCBuZWVkZWRcbiAgY29uc3QgTkFUSVZFX0JVSUxUSU5TID0g
bmV3IFNldChbXG4gICAgJ3NxcnQnLCdhYnMnLCdmbG9vcicsJ2NlaWwnLCd0cnVuYycsJ25lYXJl
c3QnLCdjb3B5c2lnbicsXG4gICAgJ21pbicsJ21heCcsJ3NlbGVjdCcsXG4gICAgJ2NseicsJ2N0
eicsJ3BvcGNudCcsJ3JvdGwnLCdyb3RyJyxcbiAgICAnbWVtb3J5X3NpemUnLCdtZW1vcnlfZ3Jv
dycsJ21lbW9yeV9jb3B5JywnbWVtb3J5X2ZpbGwnLFxuICAgICdpMzInLCdpNjQnLCdmMzInLCdm
NjQnLCAvLyB0eXBlIGNvbnZlcnNpb25zXG4gICAgJ2Y2NHgyJywnZjMyeDQnLCdpMzJ4NCcsJ2k2
NHgyJywgLy8gdmVjdG9yIGNvbnN0cnVjdG9yc1xuICBdKTtcblxuICAvLyBTY2FuIGFsbCBmdW5j
dGlvbiBib2RpZXMgZm9yIHVucmVzb2x2ZWQgY2FsbHNcbiAgY29uc3QgdXNlZENhbGxzID0gbmV3
IFNldCgpO1xuICBmdW5jdGlvbiBzY2FuQ2FsbHMoc3RtdHMpIHtcbiAgICBmb3IgKGNvbnN0IHMg
b2Ygc3RtdHMpIHtcbiAgICAgIGlmIChzLnR5cGUgPT09ICdDYWxsJyB8fCBzLnR5cGUgPT09ICdG
dW5jQ2FsbCcpIHVzZWRDYWxscy5hZGQocy5uYW1lKTtcbiAgICAgIGlmIChzLnR5cGUgPT09ICdJ
ZicpIHsgc2NhbkNhbGxzKHMuYm9keSk7IGlmIChzLmVsc2VCb2R5KSBzY2FuQ2FsbHMocy5lbHNl
Qm9keSk7IH1cbiAgICAgIGlmIChzLnR5cGUgPT09ICdGb3InIHx8IHMudHlwZSA9PT0gJ1doaWxl
JyB8fCBzLnR5cGUgPT09ICdEb1doaWxlJykgc2NhbkNhbGxzKHMuYm9keSk7XG4gICAgICAvLyBz
Y2FuIGV4cHJlc3Npb25zXG4gICAgICBzY2FuRXhwckNhbGxzKHMpO1xuICAgIH1cbiAgfVxuICBm
dW5jdGlvbiBzY2FuRXhwckNhbGxzKG5vZGUpIHtcbiAgICBpZiAoIW5vZGUgfHwgdHlwZW9mIG5v
ZGUgIT09ICdvYmplY3QnKSByZXR1cm47XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gJ0Z1bmNDYWxs
JykgdXNlZENhbGxzLmFkZChub2RlLm5hbWUpO1xuICAgIC8vICoqIG9wZXJhdG9yIG1heSBuZWVk
IHBvdyBpbXBvcnQgKGZvciBub24tc3FydCwgbm9uLXNtYWxsLWludCBleHBvbmVudHMpXG4gICAg
aWYgKG5vZGUudHlwZSA9PT0gJ0Jpbk9wJyAmJiBub2RlLm9wID09PSAnKionKSB1c2VkQ2FsbHMu
YWRkKCdwb3cnKTtcbiAgICBmb3IgKGNvbnN0IGsgb2YgT2JqZWN0LmtleXMobm9kZSkpIHtcbiAg
ICAgIGNvbnN0IHYgPSBub2RlW2tdO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodikpIHYuZm9y
RWFjaChzY2FuRXhwckNhbGxzKTtcbiAgICAgIGVsc2UgaWYgKHYgJiYgdHlwZW9mIHYgPT09ICdv
YmplY3QnICYmIHYudHlwZSkgc2NhbkV4cHJDYWxscyh2KTtcbiAgICB9XG4gIH1cbiAgZm9yIChj
b25zdCBmbiBvZiBmdW5jdGlvbnMpIHNjYW5DYWxscyhmbi5ib2R5KTtcblxuICAvLyBBdXRvLWlt
cG9ydCBtYXRoIGJ1aWx0aW5zIHRoYXQgYXJlIGFjdHVhbGx5IHVzZWRcbiAgY29uc3QgbWF0aElt
cG9ydHMgPSBbXTtcbiAgZm9yIChjb25zdCBuYW1lIG9mIHVzZWRDYWxscykge1xuICAgIGlmIChN
QVRIX0JVSUxUSU5TW25hbWVdICE9PSB1bmRlZmluZWQgJiYgIWxvY2FsRnVuY05hbWVzLmhhcyhu
YW1lKSAmJiAhaW1wb3J0cy5maW5kKGltID0+IGltLm5hbWUgPT09IG5hbWUpKSB7XG4gICAgICBj
b25zdCBuUGFyYW1zID0gTUFUSF9CVUlMVElOU1tuYW1lXTtcbiAgICAgIGNvbnN0IHBhcmFtcyA9
IFtdO1xuICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBuUGFyYW1zOyBrKyspIHBhcmFtcy5wdXNo
KHsgdHlwZTogJ1BhcmFtJywgbmFtZTogJ3gnICsgaywgdnR5cGU6ICdmNjQnLCBpc0FycmF5OiBm
YWxzZSwgYXJyYXlEaW1zOiBudWxsIH0pO1xuICAgICAgbWF0aEltcG9ydHMucHVzaCh7IG5hbWUs
IG1vZHVsZU5hbWU6ICdtYXRoJywgcGFyYW1zLCByZXRUeXBlOiAnZjY0JywgaW50ZXJwSWR4OiBu
dWxsIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8vIEF1dG8taW1wb3J0OiBzY2FuIEFTVCBmb3IgdW5y
ZXNvbHZlZCBjYWxscywgY2hlY2sgdXNlckltcG9ydHMgdGhlbiBnbG9iYWxUaGlzLlxuICAvLyBQ
YXJhbSB0eXBlcyBkZWZhdWx0IHRvIGY2NCDigJQgaW5mZXJyZWQgZnJvbSB0aGUgSlMgZnVuY3Rp
b24ncyAubGVuZ3RoLlxuICBjb25zdCBmbGF0SW1wb3J0cyA9IHVzZXJJbXBvcnRzID8gZmxhdHRl
bkltcG9ydHModXNlckltcG9ydHMpIDoge307XG4gIGNvbnN0IGhvc3RJbXBvcnRzID0gW107XG4g
IGZvciAoY29uc3QgbmFtZSBvZiB1c2VkQ2FsbHMpIHtcbiAgICBpZiAobG9jYWxGdW5jTmFtZXMu
aGFzKG5hbWUpIHx8IE5BVElWRV9CVUlMVElOUy5oYXMobmFtZSkgfHwgbmFtZS5zdGFydHNXaXRo
KCd3YXNtLicpIHx8XG4gICAgICAgIG5hbWUuc3RhcnRzV2l0aCgndjEyOC4nKSB8fCBBVFJBX1ZF
Q1RPUl9UWVBFUy5oYXMobmFtZS5zcGxpdCgnLicpWzBdKSB8fFxuICAgICAgICBNQVRIX0JVSUxU
SU5TW25hbWVdICE9PSB1bmRlZmluZWQgfHwgaW1wb3J0cy5maW5kKGltID0+IGltLm5hbWUgPT09
IG5hbWUpKSBjb250aW51ZTtcbiAgICAvLyBjaGVjayBmbGF0dGVuZWQgdXNlckltcG9ydHMgdGhl
biBnbG9iYWxUaGlzXG4gICAgbGV0IGZuID0gZmxhdEltcG9ydHNbbmFtZV07XG4gICAgaWYgKCFm
biAmJiB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcpIGZuID0gZ2xvYmFsVGhpc1tu
YW1lXTtcbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb25zdCBu
UGFyYW1zID0gZm4ubGVuZ3RoO1xuICAgICAgY29uc3QgcGFyYW1zID0gW107XG4gICAgICBmb3Ig
KGxldCBrID0gMDsgayA8IG5QYXJhbXM7IGsrKykgcGFyYW1zLnB1c2goeyB0eXBlOiAnUGFyYW0n
LCBuYW1lOiAneCcgKyBrLCB2dHlwZTogJ2Y2NCcsIGlzQXJyYXk6IGZhbHNlLCBhcnJheURpbXM6
IG51bGwgfSk7XG4gICAgICBob3N0SW1wb3J0cy5wdXNoKHsgbmFtZSwgbW9kdWxlTmFtZTogJ2hv
c3QnLCBwYXJhbXMsIHJldFR5cGU6ICdmNjQnLCBpbnRlcnBJZHg6IG51bGwsIGpzRm46IGZuIH0p
O1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGFsbEltcG9ydHMgPSBbLi4ubWF0aEltcG9ydHMsIC4u
LmltcG9ydHMsIC4uLmhvc3RJbXBvcnRzXTtcblxuICAvLyBCdWlsZCBmdW5jdGlvbiBpbmRleCB0
YWJsZTogaW1wb3J0cyBmaXJzdCwgdGhlbiBsb2NhbCBmdW5jdGlvbnNcbiAgY29uc3QgZnVuY0lu
ZGV4ID0ge307XG4gIGxldCBpZHggPSAwO1xuICBmb3IgKGNvbnN0IGltIG9mIGFsbEltcG9ydHMp
IHsgZnVuY0luZGV4W2ltLm5hbWVdID0gaWR4Kys7IH1cbiAgZm9yIChjb25zdCBmbiBvZiBmdW5j
dGlvbnMpIHsgZnVuY0luZGV4W2ZuLm5hbWVdID0gaWR4Kys7IH1cblxuICAvLyBHbG9iYWwgaW5k
ZXggdGFibGUgKCsgdHJhY2sgZnVuY1NpZyBmb3IgZnVuY3Rpb24tdHlwZWQgZ2xvYmFscylcbiAg
Y29uc3QgZ2xvYmFsSW5kZXggPSB7fTtcbiAgY29uc3QgZ2xvYmFsRnVuY1NpZyA9IHt9OyAvLyBu
YW1lIOKGkiBmdW5jU2lnIGZvciBmdW5jdGlvbi10eXBlZCBnbG9iYWxzXG4gIGZvciAobGV0IGdp
ID0gMDsgZ2kgPCBnbG9iYWxzLmxlbmd0aDsgZ2krKykge1xuICAgIGdsb2JhbEluZGV4W2dsb2Jh
bHNbZ2ldLm5hbWVdID0gZ2k7XG4gICAgaWYgKGdsb2JhbHNbZ2ldLmZ1bmNTaWcpIGdsb2JhbEZ1
bmNTaWdbZ2xvYmFsc1tnaV0ubmFtZV0gPSBnbG9iYWxzW2dpXS5mdW5jU2lnO1xuICB9XG5cbiAg
Ly8g4pSA4pSAIFNjYW4gZm9yIGZ1bmN0aW9uIHJlZmVyZW5jZXMgKGJhcmUgZnVuY3Rpb24gbmFt
ZXMgdXNlZCBhcyB2YWx1ZXMpIOKUgOKUgFxuICBjb25zdCByZWZlcmVuY2VkRnVuY3MgPSBuZXcg
U2V0KCk7XG4gIGZ1bmN0aW9uIHNjYW5GdW5jUmVmcyhzdG10cywgbG9jYWxOYW1lcykge1xuICAg
IGZvciAoY29uc3QgcyBvZiBzdG10cykgc2Nhbk5vZGVSZWZzKHMsIGxvY2FsTmFtZXMpO1xuICB9
XG4gIGZ1bmN0aW9uIHNjYW5Ob2RlUmVmcyhub2RlLCBsb2NhbE5hbWVzKSB7XG4gICAgaWYgKCFu
b2RlIHx8IHR5cGVvZiBub2RlICE9PSAnb2JqZWN0JykgcmV0dXJuO1xuICAgIGlmIChub2RlLnR5
cGUgPT09ICdGdW5jUmVmJyAmJiBmdW5jSW5kZXhbbm9kZS5uYW1lXSAhPT0gdW5kZWZpbmVkKSB7
XG4gICAgICByZWZlcmVuY2VkRnVuY3MuYWRkKG5vZGUubmFtZSk7XG4gICAgfVxuICAgIGZvciAo
Y29uc3QgayBvZiBPYmplY3Qua2V5cyhub2RlKSkge1xuICAgICAgY29uc3QgdiA9IG5vZGVba107
XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2KSkgdi5mb3JFYWNoKGMgPT4gc2Nhbk5vZGVSZWZz
KGMsIGxvY2FsTmFtZXMpKTtcbiAgICAgIGVsc2UgaWYgKHYgJiYgdHlwZW9mIHYgPT09ICdvYmpl
Y3QnICYmIHYudHlwZSkgc2Nhbk5vZGVSZWZzKHYsIGxvY2FsTmFtZXMpO1xuICAgIH1cbiAgfVxu
ICBmb3IgKGNvbnN0IGZuIG9mIGZ1bmN0aW9ucykge1xuICAgIGNvbnN0IGxvY2FsTmFtZXMgPSBu
ZXcgU2V0KCk7XG4gICAgZm9yIChjb25zdCBwIG9mIGZuLnBhcmFtcykgbG9jYWxOYW1lcy5hZGQo
cC5uYW1lKTtcbiAgICBmb3IgKGNvbnN0IGwgb2YgZm4ubG9jYWxzKSBsb2NhbE5hbWVzLmFkZChs
Lm5hbWUpO1xuICAgIGlmIChmbi50eXBlID09PSAnRnVuY3Rpb24nKSBsb2NhbE5hbWVzLmFkZChm
bi5uYW1lKTsgLy8gcmV0dXJuIHZhclxuICAgIHNjYW5GdW5jUmVmcyhmbi5ib2R5LCBsb2NhbE5h
bWVzKTtcbiAgfVxuXG4gIC8vIERldGVjdCBpZiBjYWxsX2luZGlyZWN0IGlzIG5lZWRlZCAoZnVu
Y3Rpb24tdHlwZWQgcGFyYW1zL2xvY2Fscy9nbG9iYWxzIGV4aXN0KVxuICBsZXQgaGFzSW5kaXJl
Y3RDYWxscyA9IE9iamVjdC5rZXlzKGdsb2JhbEZ1bmNTaWcpLmxlbmd0aCA+IDA7XG4gIGlmICgh
aGFzSW5kaXJlY3RDYWxscykge1xuICAgIGZvciAoY29uc3QgZm4gb2YgZnVuY3Rpb25zKSB7XG4g
ICAgICBpZiAoZm4ucGFyYW1zLnNvbWUocCA9PiBwLmZ1bmNTaWcpIHx8IGZuLmxvY2Fscy5zb21l
KGwgPT4gbC5mdW5jU2lnKSkgeyBoYXNJbmRpcmVjdENhbGxzID0gdHJ1ZTsgYnJlYWs7IH1cbiAg
ICB9XG4gIH1cblxuICAvLyBCdWlsZCB0YWJsZTogZXhwbGljaXRseSByZWZlcmVuY2VkIGZ1bmNz
IGFsd2F5czsgaWYgY2FsbF9pbmRpcmVjdCB1c2VkLCBhbHNvIGV4cGxpY2l0IGltcG9ydHMgKyBs
b2NhbCBmdW5jdGlvbnMuXG4gIC8vIEF1dG8taW1wb3J0cyBvbmx5IGVudGVyIHRoZSB0YWJsZSBp
ZiBleHBsaWNpdGx5IHJlZmVyZW5jZWQgYnkgYmFyZSBuYW1lLlxuICBjb25zdCBhdXRvSW1wb3J0
TmFtZXMgPSBuZXcgU2V0KFsuLi5tYXRoSW1wb3J0cy5tYXAobSA9PiBtLm5hbWUpLCAuLi5ob3N0
SW1wb3J0cy5tYXAobSA9PiBtLm5hbWUpXSk7XG4gIGxldCB0YWJsZUZ1bmNTZXQ7XG4gIGlmICho
YXNJbmRpcmVjdENhbGxzKSB7XG4gICAgdGFibGVGdW5jU2V0ID0gbmV3IFNldChbXG4gICAgICAu
Li5pbXBvcnRzLm1hcChpbSA9PiBpbS5uYW1lKSxcbiAgICAgIC4uLmZ1bmN0aW9ucy5tYXAoZm4g
PT4gZm4ubmFtZSksXG4gICAgICAuLi5yZWZlcmVuY2VkRnVuY3MsXG4gICAgXSk7XG4gICAgLy8g
RXhjbHVkZSBhdXRvLWltcG9ydHMgdGhhdCBhcmVuJ3QgZXhwbGljaXRseSByZWZlcmVuY2VkIGJ5
IGJhcmUgbmFtZVxuICAgIGZvciAoY29uc3QgbmFtZSBvZiBhdXRvSW1wb3J0TmFtZXMpIHtcbiAg
ICAgIGlmICghcmVmZXJlbmNlZEZ1bmNzLmhhcyhuYW1lKSkgdGFibGVGdW5jU2V0LmRlbGV0ZShu
YW1lKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGFibGVGdW5jU2V0ID0gbmV3IFNldChyZWZl
cmVuY2VkRnVuY3MpO1xuICB9XG4gIGNvbnN0IHRhYmxlRnVuY3MgPSBbLi4udGFibGVGdW5jU2V0
XS5zb3J0KChhLCBiKSA9PiBmdW5jSW5kZXhbYV0gLSBmdW5jSW5kZXhbYl0pO1xuICBjb25zdCB0
YWJsZVNsb3QgPSB7fTsgLy8gZnVuY05hbWUg4oaSIHRhYmxlIGluZGV4XG4gIGZvciAobGV0IHRp
ID0gMDsgdGkgPCB0YWJsZUZ1bmNzLmxlbmd0aDsgdGkrKykgdGFibGVTbG90W3RhYmxlRnVuY3Nb
dGldXSA9IHRpO1xuXG4gIC8vIOKUgOKUgCBCdWlsZCB0eXBlIHNpZ25hdHVyZXMg4pSA4pSAIGV2
ZXJ5IHVuaXF1ZSBmdW5jdGlvbiBzaWduYXR1cmUsIGRlZHVwZWQgYnkgc2lnS2V5XG4gIGZ1bmN0
aW9uIHBhcmFtV2FzbVR5cGUocCkgeyByZXR1cm4gcC5pc0FycmF5ID8gJ2kzMicgOiBwLnZ0eXBl
OyB9XG4gIGZ1bmN0aW9uIHNpZ0tleShwYXJhbXMsIHJldFR5cGUpIHtcbiAgICByZXR1cm4gcGFy
YW1zLm1hcChwID0+IHBhcmFtV2FzbVR5cGUocCkpLmpvaW4oJywnKSArICc6JyArIChyZXRUeXBl
IHx8ICcnKTtcbiAgfVxuICBjb25zdCBzaWdNYXAgPSBuZXcgTWFwKCk7XG4gIGNvbnN0IHNpZ0xp
c3QgPSBbXTsgLy8gW3twYXJhbXMsIHJldFR5cGV9XVxuICBmdW5jdGlvbiBnZXRPckFkZFNpZyhw
YXJhbXMsIHJldFR5cGUpIHtcbiAgICBjb25zdCBrZXkgPSBzaWdLZXkocGFyYW1zLCByZXRUeXBl
KTtcbiAgICBpZiAoc2lnTWFwLmhhcyhrZXkpKSByZXR1cm4gc2lnTWFwLmdldChrZXkpO1xuICAg
IGNvbnN0IGlkID0gc2lnTGlzdC5sZW5ndGg7XG4gICAgc2lnTGlzdC5wdXNoKHsgcGFyYW1zLCBy
ZXRUeXBlIH0pO1xuICAgIHNpZ01hcC5zZXQoa2V5LCBpZCk7XG4gICAgcmV0dXJuIGlkO1xuICB9
XG5cbiAgLy8gUmVnaXN0ZXIgYWxsIHNpZ25hdHVyZXNcbiAgY29uc3QgaW1wb3J0U2lnSWRzID0g
YWxsSW1wb3J0cy5tYXAoaW0gPT4gZ2V0T3JBZGRTaWcoaW0ucGFyYW1zLCBpbS5yZXRUeXBlKSk7
XG4gIGNvbnN0IGZ1bmNTaWdJZHMgPSBmdW5jdGlvbnMubWFwKGZuID0+IHtcbiAgICBjb25zdCBy
ZXRUeXBlID0gZm4udHlwZSA9PT0gJ1N1YnJvdXRpbmUnID8gbnVsbCA6IGZuLnJldFR5cGU7XG4g
ICAgcmV0dXJuIGdldE9yQWRkU2lnKGZuLnBhcmFtcywgcmV0VHlwZSk7XG4gIH0pO1xuXG4gIC8v
IOKUgOKUgCBEZXRlcm1pbmUgbWVtb3J5IOKUgOKUgFxuICBjb25zdCBoYXNNZW1vcnkgPSBmdW5j
dGlvbnMuc29tZShmbiA9PiBmbi5wYXJhbXMuc29tZShwID0+IHAuaXNBcnJheSkpO1xuICBjb25z
dCBpbXBvcnRNZW1vcnkgPSB1c2VySW1wb3J0cyAmJiB1c2VySW1wb3J0cy5fX21lbW9yeTtcblxu
ICAvLyDilIDilIAgRW1pdCBXYXNtIGJpbmFyeSDilIDilIBcbiAgLy8gTWFnaWMgKyB2ZXJzaW9u
XG4gIHcuYnl0ZXMoWzB4MDAsIDB4NjEsIDB4NzMsIDB4NmRdKTsgLy8gXFwwYXNtXG4gIHcuYnl0
ZXMoWzB4MDEsIDB4MDAsIDB4MDAsIDB4MDBdKTsgLy8gdmVyc2lvbiAxXG5cbiAgLy8gVHlwZSBz
ZWN0aW9uICgxKSDigJQgZXZlcnkgdW5pcXVlIChwYXJhbXMg4oaSIHJldFR5cGUpIHNpZ25hdHVy
ZVxuICB3LnNlY3Rpb24oMSwgcyA9PiB7XG4gICAgcy51MzIoc2lnTGlzdC5sZW5ndGgpO1xuICAg
IGZvciAoY29uc3Qgc2lnIG9mIHNpZ0xpc3QpIHtcbiAgICAgIHMuYnl0ZSgweDYwKTsgLy8gZnVu
YyB0eXBlXG4gICAgICBzLnUzMihzaWcucGFyYW1zLmxlbmd0aCk7XG4gICAgICBmb3IgKGNvbnN0
IHAgb2Ygc2lnLnBhcmFtcykgcy5ieXRlKHdhc21UeXBlKHBhcmFtV2FzbVR5cGUocCkpKTtcbiAg
ICAgIGlmIChzaWcucmV0VHlwZSkgeyBzLnUzMigxKTsgcy5ieXRlKHdhc21UeXBlKHNpZy5yZXRU
eXBlKSk7IH1cbiAgICAgIGVsc2Ugcy51MzIoMCk7XG4gICAgfVxuICB9KTtcblxuICAvLyBJbXBv
cnQgc2VjdGlvbiAoMikg4oCUIG1hdGggYnVpbHRpbnMgKGF1dG8tZGV0ZWN0ZWQpLCBleHBsaWNp
dCBpbXBvcnRzLCBob3N0IGZ1bmN0aW9uc1xuICBpZiAoYWxsSW1wb3J0cy5sZW5ndGggPiAwIHx8
IGltcG9ydE1lbW9yeSkge1xuICAgIHcuc2VjdGlvbigyLCBzID0+IHtcbiAgICAgIHMudTMyKGFs
bEltcG9ydHMubGVuZ3RoICsgKGltcG9ydE1lbW9yeSA/IDEgOiAwKSk7XG4gICAgICBmb3IgKGxl
dCBpaSA9IDA7IGlpIDwgYWxsSW1wb3J0cy5sZW5ndGg7IGlpKyspIHtcbiAgICAgICAgY29uc3Qg
aW0gPSBhbGxJbXBvcnRzW2lpXTtcbiAgICAgICAgcy5zdHIoaW0ubW9kdWxlTmFtZSk7XG4gICAg
ICAgIHMuc3RyKGltLm5hbWUpO1xuICAgICAgICBzLmJ5dGUoMHgwMCk7IC8vIGZ1bmMgaW1wb3J0
XG4gICAgICAgIHMudTMyKGltcG9ydFNpZ0lkc1tpaV0pO1xuICAgICAgfVxuICAgICAgaWYgKGlt
cG9ydE1lbW9yeSkge1xuICAgICAgICBzLnN0cignZW52Jyk7XG4gICAgICAgIHMuc3RyKCdtZW1v
cnknKTtcbiAgICAgICAgcy5ieXRlKDB4MDIpOyAvLyBtZW1vcnkgaW1wb3J0XG4gICAgICAgIHMu
Ynl0ZSgweDAwKTsgLy8gbm8gbWF4XG4gICAgICAgIHMudTMyKDEpOyAvLyBpbml0aWFsIDEgcGFn
ZVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLy8gRnVuY3Rpb24gc2VjdGlvbiAoMylcbiAg
dy5zZWN0aW9uKDMsIHMgPT4ge1xuICAgIHMudTMyKGZ1bmN0aW9ucy5sZW5ndGgpO1xuICAgIGZv
ciAoY29uc3Qgc2lnSWQgb2YgZnVuY1NpZ0lkcykgcy51MzIoc2lnSWQpO1xuICB9KTtcblxuICAv
LyBUYWJsZSBzZWN0aW9uICg0KSDigJQgZnVuY3JlZiB0YWJsZSBmb3IgY2FsbF9pbmRpcmVjdCAo
ZnVuY3Rpb24gcG9pbnRlcnMpXG4gIGlmICh0YWJsZUZ1bmNzLmxlbmd0aCA+IDApIHtcbiAgICB3
LnNlY3Rpb24oNCwgcyA9PiB7XG4gICAgICBzLnUzMigxKTsgLy8gb25lIHRhYmxlXG4gICAgICBz
LmJ5dGUoMHg3MCk7IC8vIGZ1bmNyZWZcbiAgICAgIHMuYnl0ZSgweDAwKTsgLy8gbm8gbWF4XG4g
ICAgICBzLnUzMih0YWJsZUZ1bmNzLmxlbmd0aCk7IC8vIGluaXRpYWwgc2l6ZSA9IG51bWJlciBv
ZiByZWZlcmVuY2VkIGZ1bmN0aW9uc1xuICAgIH0pO1xuICB9XG5cbiAgLy8gTWVtb3J5IHNlY3Rp
b24gKDUpIOKAlCBvbmx5IGlmIGFycmF5cyB1c2VkIGFuZCBubyBpbXBvcnRlZCBtZW1vcnlcbiAg
aWYgKGhhc01lbW9yeSAmJiAhaW1wb3J0TWVtb3J5KSB7XG4gICAgdy5zZWN0aW9uKDUsIHMgPT4g
e1xuICAgICAgcy51MzIoMSk7XG4gICAgICBzLmJ5dGUoMHgwMCk7IC8vIG5vIG1heFxuICAgICAg
cy51MzIoMSk7IC8vIGluaXRpYWw6IDEgcGFnZSAoNjRLQilcbiAgICB9KTtcbiAgfVxuXG4gIC8v
IEdsb2JhbCBzZWN0aW9uICg2KVxuICBpZiAoZ2xvYmFscy5sZW5ndGggPiAwKSB7XG4gICAgdy5z
ZWN0aW9uKDYsIHMgPT4ge1xuICAgICAgcy51MzIoZ2xvYmFscy5sZW5ndGgpO1xuICAgICAgZm9y
IChjb25zdCBnIG9mIGdsb2JhbHMpIHtcbiAgICAgICAgcy5ieXRlKHdhc21UeXBlKGcudnR5cGUp
KTtcbiAgICAgICAgcy5ieXRlKGcubXV0YWJsZSA/IDB4MDEgOiAweDAwKTtcbiAgICAgICAgLy8g
aW5pdCBleHByZXNzaW9uXG4gICAgICAgIGVtaXRDb25zdEV4cHIocywgZy5pbml0LCBnLnZ0eXBl
KTtcbiAgICAgICAgcy5ieXRlKE9QX0VORCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAv
LyBFeHBvcnQgc2VjdGlvbiAoNylcbiAgdy5zZWN0aW9uKDcsIHMgPT4ge1xuICAgIGNvbnN0IGV4
cG9ydHMgPSBmdW5jdGlvbnMubWFwKChmbiwgaSkgPT4gKHsgbmFtZTogZm4ubmFtZSwgaWR4OiBh
bGxJbXBvcnRzLmxlbmd0aCArIGkgfSkpO1xuICAgIGNvbnN0IG1lbUV4cG9ydCA9IChoYXNNZW1v
cnkgJiYgIWltcG9ydE1lbW9yeSkgPyAxIDogMDtcbiAgICBzLnUzMihleHBvcnRzLmxlbmd0aCAr
IG1lbUV4cG9ydCk7XG4gICAgZm9yIChjb25zdCBlIG9mIGV4cG9ydHMpIHtcbiAgICAgIHMuc3Ry
KGUubmFtZSk7XG4gICAgICBzLmJ5dGUoMHgwMCk7IC8vIGZ1bmMgZXhwb3J0XG4gICAgICBzLnUz
MihlLmlkeCk7XG4gICAgfVxuICAgIGlmIChtZW1FeHBvcnQpIHtcbiAgICAgIHMuc3RyKCdtZW1v
cnknKTtcbiAgICAgIHMuYnl0ZSgweDAyKTsgLy8gbWVtb3J5IGV4cG9ydFxuICAgICAgcy51MzIo
MCk7XG4gICAgfVxuICB9KTtcblxuICAvLyBFbGVtZW50IHNlY3Rpb24gKDkpIOKAlCBwb3B1bGF0
ZSB0YWJsZSB3aXRoIGZ1bmN0aW9uIHJlZmVyZW5jZXMgYXQgb2Zmc2V0IDBcbiAgaWYgKHRhYmxl
RnVuY3MubGVuZ3RoID4gMCkge1xuICAgIHcuc2VjdGlvbig5LCBzID0+IHtcbiAgICAgIHMudTMy
KDEpOyAvLyBvbmUgZWxlbWVudCBzZWdtZW50XG4gICAgICBzLnUzMigwKTsgLy8gdGFibGUgaW5k
ZXggMFxuICAgICAgLy8gb2Zmc2V0IGV4cHJlc3Npb246IGkzMi5jb25zdCAwXG4gICAgICBzLmJ5
dGUoT1BfSTMyX0NPTlNUKTsgcy5zMzIoMCk7IHMuYnl0ZShPUF9FTkQpO1xuICAgICAgcy51MzIo
dGFibGVGdW5jcy5sZW5ndGgpO1xuICAgICAgZm9yIChjb25zdCBmbmFtZSBvZiB0YWJsZUZ1bmNz
KSBzLnUzMihmdW5jSW5kZXhbZm5hbWVdKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIENvZGUgc2Vj
dGlvbiAoMTApIOKAlCBvbmUgYm9keSBwZXIgbG9jYWwgZnVuY3Rpb24sIGVhY2ggd2l0aCBjb21w
cmVzc2VkIGxvY2FscyArIGJ5dGVjb2RlXG4gIHcuc2VjdGlvbigxMCwgcyA9PiB7XG4gICAgcy51
MzIoZnVuY3Rpb25zLmxlbmd0aCk7XG4gICAgZm9yIChjb25zdCBmbiBvZiBmdW5jdGlvbnMpIHtc
biAgICAgIGNvbnN0IGJvZHlXcml0ZXIgPSBuZXcgQnl0ZVdyaXRlcigpO1xuICAgICAgZW1pdEZ1
bmN0aW9uQm9keShib2R5V3JpdGVyLCBmbik7XG4gICAgICBzLnUzMihib2R5V3JpdGVyLmJ1Zi5s
ZW5ndGgpO1xuICAgICAgcy5ieXRlcyhib2R5V3JpdGVyLmJ1Zik7XG4gICAgfVxuICB9KTtcblxu
ICBjb25zdCBieXRlcyA9IHcudG9VaW50OEFycmF5KCk7XG4gIGNvbnN0IHRhYmxlID0gdGFibGVG
dW5jcy5sZW5ndGggPiAwID8geyAuLi50YWJsZVNsb3QgfSA6IG51bGw7XG4gIHJldHVybiB7IGJ5
dGVzLCB0YWJsZSB9O1xuXG4gIC8vIOKUgOKUgCBIZWxwZXI6IGVtaXQgY29uc3RhbnQgaW5pdCBl
eHByZXNzaW9uIOKUgOKUgFxuICBmdW5jdGlvbiBlbWl0Q29uc3RFeHByKHMsIG5vZGUsIHZ0eXBl
KSB7XG4gICAgaWYgKCFub2RlKSB7XG4gICAgICAvLyBkZWZhdWx0IHplcm9cbiAgICAgIGlmICh2
dHlwZSA9PT0gJ2kzMicpIHsgcy5ieXRlKE9QX0kzMl9DT05TVCk7IHMuczMyKDApOyB9XG4gICAg
ICBlbHNlIGlmICh2dHlwZSA9PT0gJ2k2NCcpIHsgcy5ieXRlKE9QX0k2NF9DT05TVCk7IHMuczY0
KDBuKTsgfVxuICAgICAgZWxzZSBpZiAodnR5cGUgPT09ICdmMzInKSB7IHMuYnl0ZShPUF9GMzJf
Q09OU1QpOyBzLmYzMigwKTsgfVxuICAgICAgZWxzZSBpZiAodnR5cGUgPT09ICdmNjQnKSB7IHMu
Ynl0ZShPUF9GNjRfQ09OU1QpOyBzLmY2NCgwKTsgfVxuICAgICAgZWxzZSBpZiAoaXNWZWN0b3Io
dnR5cGUpKSB7XG4gICAgICAgIC8vIHYxMjguY29uc3Qgd2l0aCAxNiB6ZXJvIGJ5dGVzXG4gICAg
ICAgIHMuYnl0ZShPUF9TSU1EX1BSRUZJWCk7IHMudTMyKFNJTURfT1BTWyd2MTI4LmNvbnN0J10p
O1xuICAgICAgICBmb3IgKGxldCB2aSA9IDA7IHZpIDwgMTY7IHZpKyspIHMuYnl0ZSgwKTtcbiAg
ICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gJ051bWJl
ckxpdCcpIHtcbiAgICAgIGNvbnN0IHZhbCA9IHBhcnNlTnVtZXJpY1ZhbHVlKG5vZGUsIHZ0eXBl
KTtcbiAgICAgIGVtaXRUeXBlZENvbnN0KHMsIHZ0eXBlLCB2YWwpO1xuICAgICAgcmV0dXJuO1xu
ICAgIH1cbiAgICBpZiAobm9kZS50eXBlID09PSAnVW5hcnlPcCcgJiYgbm9kZS5vcCA9PT0gJy0n
ICYmIG5vZGUub3BlcmFuZC50eXBlID09PSAnTnVtYmVyTGl0Jykge1xuICAgICAgY29uc3QgdmFs
ID0gLXBhcnNlTnVtZXJpY1ZhbHVlKG5vZGUub3BlcmFuZCwgdnR5cGUpO1xuICAgICAgZW1pdFR5
cGVkQ29uc3QocywgdnR5cGUsIHZhbCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRocm93
IG5ldyBFcnJvcignR2xvYmFsIGluaXQgbXVzdCBiZSBhIGNvbnN0YW50IGV4cHJlc3Npb24nKTtc
biAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlTnVtZXJpY1ZhbHVlKG5vZGUsIGRlZmF1bHRUeXBlKSB7
XG4gICAgY29uc3QgcmF3ID0gbm9kZS52YWx1ZTtcbiAgICBpZiAocmF3LmluY2x1ZGVzKCcuJykg
fHwgcmF3LmluY2x1ZGVzKCdlJykgfHwgcmF3LmluY2x1ZGVzKCdFJykgfHwgbm9kZS5pc0Zsb2F0
KSByZXR1cm4gcGFyc2VGbG9hdChyYXcpO1xuICAgIHJldHVybiBwYXJzZUludChyYXcsIDEwKTtc
biAgfVxuXG4gIGZ1bmN0aW9uIGVtaXRUeXBlZENvbnN0KHMsIHZ0eXBlLCB2YWwpIHtcbiAgICBp
ZiAodnR5cGUgPT09ICdpMzInKSB7IHMuYnl0ZShPUF9JMzJfQ09OU1QpOyBzLnMzMih2YWwgfCAw
KTsgfVxuICAgIGVsc2UgaWYgKHZ0eXBlID09PSAnaTY0JykgeyBzLmJ5dGUoT1BfSTY0X0NPTlNU
KTsgcy5zNjQoQmlnSW50KHZhbCkpOyB9XG4gICAgZWxzZSBpZiAodnR5cGUgPT09ICdmMzInKSB7
IHMuYnl0ZShPUF9GMzJfQ09OU1QpOyBzLmYzMih2YWwpOyB9XG4gICAgZWxzZSBpZiAodnR5cGUg
PT09ICdmNjQnKSB7IHMuYnl0ZShPUF9GNjRfQ09OU1QpOyBzLmY2NCh2YWwpOyB9XG4gIH1cblxu
ICAvLyDilIDilIAgRW1pdCBmdW5jdGlvbiBib2R5IOKUgOKUgFxuICBmdW5jdGlvbiBlbWl0RnVu
Y3Rpb25Cb2R5KGJ3LCBmbikge1xuICAgIGNvbnN0IGlzRnVuYyA9IGZuLnR5cGUgPT09ICdGdW5j
dGlvbic7XG4gICAgY29uc3QgcmV0VHlwZSA9IGlzRnVuYyA/IGZuLnJldFR5cGUgOiBudWxsO1xu
XG4gICAgLy8g4pSA4pSAIExvY2FsIGxheW91dCDilIDilIAgcGFyYW1zLCBkZWNsYXJlZCBsb2Nh
bHMsIGhpZGRlbiByZXR1cm4gdmFyaWFibGVcbiAgICBjb25zdCBsb2NhbE1hcCA9IHt9OyAvLyBu
YW1lIOKGkiB7IGlkeCwgdnR5cGUgfVxuICAgIGxldCBsb2NhbElkeCA9IDA7XG4gICAgZm9yIChj
b25zdCBwIG9mIGZuLnBhcmFtcykge1xuICAgICAgY29uc3QgZW50cnkgPSB7XG4gICAgICAgIGlk
eDogbG9jYWxJZHgrKyxcbiAgICAgICAgdnR5cGU6IHAuaXNBcnJheSA/ICdpMzInIDogcC52dHlw
ZSwgLy8gV2FzbSBoYXMgbm8gYXJyYXkgdHlwZTsgYXJyYXlzIGFyZSBpMzIgbWVtb3J5IHBvaW50
ZXJzXG4gICAgICAgIGlzQXJyYXk6IHAuaXNBcnJheSxcbiAgICAgICAgYXJyYXlEaW1zOiBwLmFy
cmF5RGltcyxcbiAgICAgICAgZWxlbVR5cGU6IHAuaXNBcnJheSA/IHAudnR5cGUgOiBudWxsICAv
LyBlbGVtZW50IHR5cGUgZm9yIGxvYWQvc3RvcmVcbiAgICAgIH07XG4gICAgICBpZiAocC5mdW5j
U2lnKSBlbnRyeS5mdW5jU2lnID0gcC5mdW5jU2lnO1xuICAgICAgbG9jYWxNYXBbcC5uYW1lXSA9
IGVudHJ5O1xuICAgIH1cbiAgICBjb25zdCBkZWNsYXJlZExvY2FscyA9IFsuLi5mbi5sb2NhbHNd
O1xuICAgIGlmIChpc0Z1bmMpIHtcbiAgICAgIC8vICRfcmV0dXJuOiBGb3J0cmFuIGNvbnZlbnRp
b24g4oCUIGFzc2lnbmluZyB0byB0aGUgZnVuY3Rpb24gbmFtZSBzZXRzIHRoZSByZXR1cm4gdmFs
dWUuXG4gICAgICAvLyBNYXBwZWQgdG8gYSBoaWRkZW4gbG9jYWw7IHRoZSBmdW5jdGlvbiBlcGls
b2d1ZSByZWFkcyBpdCB3aXRoIGxvY2FsLmdldC5cbiAgICAgIGRlY2xhcmVkTG9jYWxzLnB1c2go
eyBuYW1lOiAnJF9yZXR1cm4nLCB2dHlwZTogcmV0VHlwZSB9KTtcbiAgICB9XG4gICAgZm9yIChj
b25zdCBsb2Mgb2YgZGVjbGFyZWRMb2NhbHMpIHtcbiAgICAgIGNvbnN0IGVudHJ5ID0geyBpZHg6
IGxvY2FsSWR4KyssIHZ0eXBlOiBsb2MudnR5cGUgfTtcbiAgICAgIGlmIChsb2MuZnVuY1NpZykg
ZW50cnkuZnVuY1NpZyA9IGxvYy5mdW5jU2lnO1xuICAgICAgbG9jYWxNYXBbbG9jLm5hbWVdID0g
ZW50cnk7XG4gICAgfVxuXG4gICAgLy8gRW1pdCBsb2NhbCBkZWNsYXJhdGlvbnMgKG9ubHkgdGhl
IG5vbi1wYXJhbSBvbmVzKVxuICAgIGNvbnN0IGxvY2FsVHlwZXMgPSBkZWNsYXJlZExvY2Fscy5t
YXAobCA9PiBsLnZ0eXBlKTtcbiAgICAvLyBDb21wcmVzczogcnVucyBvZiBzYW1lIHR5cGVcbiAg
ICBjb25zdCBsb2NhbFJ1bnMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGx0IG9mIGxvY2FsVHlwZXMp
IHtcbiAgICAgIGlmIChsb2NhbFJ1bnMubGVuZ3RoID4gMCAmJiBsb2NhbFJ1bnNbbG9jYWxSdW5z
Lmxlbmd0aCAtIDFdLnR5cGUgPT09IGx0KSBsb2NhbFJ1bnNbbG9jYWxSdW5zLmxlbmd0aCAtIDFd
LmNvdW50Kys7XG4gICAgICBlbHNlIGxvY2FsUnVucy5wdXNoKHsgY291bnQ6IDEsIHR5cGU6IGx0
IH0pO1xuICAgIH1cbiAgICBidy51MzIobG9jYWxSdW5zLmxlbmd0aCk7XG4gICAgZm9yIChjb25z
dCBydW4gb2YgbG9jYWxSdW5zKSB7XG4gICAgICBidy51MzIocnVuLmNvdW50KTtcbiAgICAgIGJ3
LmJ5dGUod2FzbVR5cGUocnVuLnR5cGUpKTtcbiAgICB9XG5cbiAgICAvLyBTSU1EIGhlbHBlclxu
ICAgIGZ1bmN0aW9uIGVtaXRTaW1kKG9wKSB7IGJ3LmJ5dGUoT1BfU0lNRF9QUkVGSVgpOyBidy51
MzIob3ApOyB9XG5cbiAgICAvLyDilIDilIAgU3RhdGVtZW50IGVtaXNzaW9uIOKUgOKUgFxuICAg
IGxldCBkZXB0aCA9IDA7IC8vIGN1cnJlbnQgYmxvY2sgbmVzdGluZyBkZXB0aFxuICAgIGNvbnN0
IGJyZWFrVGFyZ2V0cyA9IFtdOyAvLyBzdGFjayBvZiB7ZGVwdGh9IGZvciBlYWNoIGVuY2xvc2lu
ZyBsb29wJ3MgYnJlYWsgYmxvY2tcblxuICAgIGZ1bmN0aW9uIGVtaXRTdG10cyhzdG10cykgeyBm
b3IgKGNvbnN0IHMgb2Ygc3RtdHMpIGVtaXRTdG10KHMpOyB9XG5cbiAgICBmdW5jdGlvbiBlbWl0
U3RtdChzdG10KSB7XG4gICAgICBzd2l0Y2ggKHN0bXQudHlwZSkge1xuICAgICAgICBjYXNlICdB
c3NpZ24nOiB7XG4gICAgICAgICAgY29uc3QgdGFyZ2V0ID0gc3RtdC5uYW1lO1xuICAgICAgICAg
IC8vIEFzc2lnbm1lbnQgdG8gZnVuY3Rpb24gbmFtZSA9IHNldCByZXR1cm4gdmFyaWFibGVcbiAg
ICAgICAgICBpZiAoaXNGdW5jICYmIHRhcmdldCA9PT0gZm4ubmFtZSkge1xuICAgICAgICAgICAg
ZW1pdEV4cHIoc3RtdC52YWx1ZSwgcmV0VHlwZSk7XG4gICAgICAgICAgICBidy5ieXRlKE9QX0xP
Q0FMX1NFVCk7XG4gICAgICAgICAgICBidy51MzIobG9jYWxNYXBbJyRfcmV0dXJuJ10uaWR4KTtc
biAgICAgICAgICB9IGVsc2UgaWYgKGxvY2FsTWFwW3RhcmdldF0pIHtcbiAgICAgICAgICAgIGVt
aXRFeHByKHN0bXQudmFsdWUsIGxvY2FsTWFwW3RhcmdldF0udnR5cGUpO1xuICAgICAgICAgICAg
YncuYnl0ZShPUF9MT0NBTF9TRVQpO1xuICAgICAgICAgICAgYncudTMyKGxvY2FsTWFwW3Rhcmdl
dF0uaWR4KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGdsb2JhbEluZGV4W3RhcmdldF0gIT09IHVu
ZGVmaW5lZCkge1xuICAgICAgICAgICAgZW1pdEV4cHIoc3RtdC52YWx1ZSwgZ2xvYmFsc1tnbG9i
YWxJbmRleFt0YXJnZXRdXS52dHlwZSk7XG4gICAgICAgICAgICBidy5ieXRlKE9QX0dMT0JBTF9T
RVQpO1xuICAgICAgICAgICAgYncudTMyKGdsb2JhbEluZGV4W3RhcmdldF0pO1xuICAgICAgICAg
IH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZGVmaW5lZCB2YXJpYWJs
ZTogJHt0YXJnZXR9YCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9
XG4gICAgICAgIGNhc2UgJ0FycmF5U3RvcmUnOiB7XG4gICAgICAgICAgY29uc3QgaW5mbyA9IGxv
Y2FsTWFwW3N0bXQubmFtZV07XG4gICAgICAgICAgaWYgKCFpbmZvKSB0aHJvdyBuZXcgRXJyb3Io
YFVuZGVmaW5lZCBhcnJheTogJHtzdG10Lm5hbWV9YCk7XG4gICAgICAgICAgY29uc3QgZWxlbVR5
cGUgPSBpbmZvLmVsZW1UeXBlIHx8IGluZm8udnR5cGU7XG4gICAgICAgICAgLy8gY29tcHV0ZSBh
ZGRyZXNzXG4gICAgICAgICAgZW1pdEFycmF5QWRkcihzdG10Lm5hbWUsIHN0bXQuaW5kaWNlcywg
aW5mbywgZWxlbVR5cGUpO1xuICAgICAgICAgIC8vIGNvbXB1dGUgdmFsdWVcbiAgICAgICAgICBl
bWl0RXhwcihzdG10LnZhbHVlLCBlbGVtVHlwZSk7XG4gICAgICAgICAgLy8gc3RvcmVcbiAgICAg
ICAgICBlbWl0U3RvcmUoZWxlbVR5cGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4g
ICAgICAgIGNhc2UgJ0lmJzoge1xuICAgICAgICAgIGVtaXRFeHByKHN0bXQuY29uZCwgJ2kzMicp
O1xuICAgICAgICAgIGJ3LmJ5dGUoT1BfSUYpO1xuICAgICAgICAgIGJ3LmJ5dGUoV0FTTV9WT0lE
KTtcbiAgICAgICAgICBkZXB0aCsrO1xuICAgICAgICAgIGVtaXRTdG10cyhzdG10LmJvZHkpO1xu
ICAgICAgICAgIGlmIChzdG10LmVsc2VCb2R5KSB7XG4gICAgICAgICAgICBidy5ieXRlKE9QX0VM
U0UpO1xuICAgICAgICAgICAgZW1pdFN0bXRzKHN0bXQuZWxzZUJvZHkpO1xuICAgICAgICAgIH1c
biAgICAgICAgICBkZXB0aC0tO1xuICAgICAgICAgIGJ3LmJ5dGUoT1BfRU5EKTtcbiAgICAgICAg
ICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdGb3InOiB7XG4gICAgICAgICAgY29u
c3QgdkluZm8gPSBsb2NhbE1hcFtzdG10LnZhck5hbWVdO1xuICAgICAgICAgIGlmICghdkluZm8p
IHRocm93IG5ldyBFcnJvcihgVW5kZWZpbmVkIGxvb3AgdmFyaWFibGU6ICR7c3RtdC52YXJOYW1l
fWApO1xuICAgICAgICAgIGNvbnN0IHZ0ID0gdkluZm8udnR5cGU7XG4gICAgICAgICAgZW1pdEV4
cHIoc3RtdC5zdGFydCwgdnQpO1xuICAgICAgICAgIGJ3LmJ5dGUoT1BfTE9DQUxfU0VUKTtcbiAg
ICAgICAgICBidy51MzIodkluZm8uaWR4KTtcblxuICAgICAgICAgIGNvbnN0IGhhc1N0ZXAgPSBz
dG10LnN0ZXAgIT09IG51bGw7XG5cbiAgICAgICAgICBidy5ieXRlKE9QX0JMT0NLKTsgYncuYnl0
ZShXQVNNX1ZPSUQpOyBkZXB0aCsrO1xuICAgICAgICAgIGNvbnN0IGJyZWFrRGVwdGggPSBkZXB0
aDsgLy8gYnJlYWsgdGFyZ2V0ID0gdGhpcyBibG9ja1xuICAgICAgICAgIGJ3LmJ5dGUoT1BfTE9P
UCk7IGJ3LmJ5dGUoV0FTTV9WT0lEKTsgZGVwdGgrKztcbiAgICAgICAgICBicmVha1RhcmdldHMu
cHVzaChicmVha0RlcHRoKTtcblxuICAgICAgICAgIC8vIGNvbmRpdGlvbiBjaGVjazogYnJfaWYg
dG8gYnJlYWsgYmxvY2tcbiAgICAgICAgICBidy5ieXRlKE9QX0xPQ0FMX0dFVCk7IGJ3LnUzMih2
SW5mby5pZHgpO1xuICAgICAgICAgIGVtaXRFeHByKHN0bXQuZW5kLCB2dCk7XG4gICAgICAgICAg
aWYgKCFoYXNTdGVwKSB7XG4gICAgICAgICAgICBlbWl0Q21wKCc+PScsIHZ0KTtcbiAgICAgICAg
ICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qgc3RlcElzTmVnTGl0ID0gc3RtdC5zdGVwLnR5
cGUgPT09ICdVbmFyeU9wJyAmJiBzdG10LnN0ZXAub3AgPT09ICctJyAmJiBzdG10LnN0ZXAub3Bl
cmFuZC50eXBlID09PSAnTnVtYmVyTGl0JztcbiAgICAgICAgICAgIGNvbnN0IHN0ZXBJc05lZ0Nv
bnN0ID0gc3RlcElzTmVnTGl0IHx8IChzdG10LnN0ZXAudHlwZSA9PT0gJ051bWJlckxpdCcgJiYg
cGFyc2VGbG9hdChzdG10LnN0ZXAudmFsdWUpIDwgMCk7XG4gICAgICAgICAgICBlbWl0Q21wKHN0
ZXBJc05lZ0NvbnN0ID8gJzw9JyA6ICc+PScsIHZ0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAg
YncuYnl0ZShPUF9CUl9JRik7IGJ3LnUzMihkZXB0aCAtIGJyZWFrRGVwdGgpO1xuXG4gICAgICAg
ICAgZW1pdFN0bXRzKHN0bXQuYm9keSk7XG5cbiAgICAgICAgICAvLyBpbmNyZW1lbnRcbiAgICAg
ICAgICBidy5ieXRlKE9QX0xPQ0FMX0dFVCk7IGJ3LnUzMih2SW5mby5pZHgpO1xuICAgICAgICAg
IGlmIChoYXNTdGVwKSB7IGVtaXRFeHByKHN0bXQuc3RlcCwgdnQpOyB9IGVsc2UgeyBlbWl0VHlw
ZWRDb25zdChidywgdnQsIDEpOyB9XG4gICAgICAgICAgZW1pdEFkZCh2dCk7XG4gICAgICAgICAg
YncuYnl0ZShPUF9MT0NBTF9TRVQpOyBidy51MzIodkluZm8uaWR4KTtcblxuICAgICAgICAgIGJ3
LmJ5dGUoT1BfQlIpOyBidy51MzIoMCk7IC8vIGNvbnRpbnVlIHRvIGxvb3BcbiAgICAgICAgICBk
ZXB0aC0tOyBidy5ieXRlKE9QX0VORCk7IC8vIGVuZCBsb29wXG4gICAgICAgICAgYnJlYWtUYXJn
ZXRzLnBvcCgpO1xuICAgICAgICAgIGRlcHRoLS07IGJ3LmJ5dGUoT1BfRU5EKTsgLy8gZW5kIGJs
b2NrXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnV2hpbGUnOiB7
XG4gICAgICAgICAgYncuYnl0ZShPUF9CTE9DSyk7IGJ3LmJ5dGUoV0FTTV9WT0lEKTsgZGVwdGgr
KztcbiAgICAgICAgICBjb25zdCBicmVha0RlcHRoID0gZGVwdGg7XG4gICAgICAgICAgYncuYnl0
ZShPUF9MT09QKTsgYncuYnl0ZShXQVNNX1ZPSUQpOyBkZXB0aCsrO1xuICAgICAgICAgIGJyZWFr
VGFyZ2V0cy5wdXNoKGJyZWFrRGVwdGgpO1xuXG4gICAgICAgICAgZW1pdEV4cHIoc3RtdC5jb25k
LCAnaTMyJyk7XG4gICAgICAgICAgYncuYnl0ZShPUF9JMzJfRVFaKTtcbiAgICAgICAgICBidy5i
eXRlKE9QX0JSX0lGKTsgYncudTMyKGRlcHRoIC0gYnJlYWtEZXB0aCk7XG5cbiAgICAgICAgICBl
bWl0U3RtdHMoc3RtdC5ib2R5KTtcblxuICAgICAgICAgIGJ3LmJ5dGUoT1BfQlIpOyBidy51MzIo
MCk7IC8vIGNvbnRpbnVlIGxvb3BcbiAgICAgICAgICBkZXB0aC0tOyBidy5ieXRlKE9QX0VORCk7
IC8vIGVuZCBsb29wXG4gICAgICAgICAgYnJlYWtUYXJnZXRzLnBvcCgpO1xuICAgICAgICAgIGRl
cHRoLS07IGJ3LmJ5dGUoT1BfRU5EKTsgLy8gZW5kIGJsb2NrXG4gICAgICAgICAgYnJlYWs7XG4g
ICAgICAgIH1cbiAgICAgICAgY2FzZSAnRG9XaGlsZSc6IHtcbiAgICAgICAgICBidy5ieXRlKE9Q
X0JMT0NLKTsgYncuYnl0ZShXQVNNX1ZPSUQpOyBkZXB0aCsrO1xuICAgICAgICAgIGNvbnN0IGJy
ZWFrRGVwdGggPSBkZXB0aDtcbiAgICAgICAgICBidy5ieXRlKE9QX0xPT1ApOyBidy5ieXRlKFdB
U01fVk9JRCk7IGRlcHRoKys7XG4gICAgICAgICAgYnJlYWtUYXJnZXRzLnB1c2goYnJlYWtEZXB0
aCk7XG5cbiAgICAgICAgICBlbWl0U3RtdHMoc3RtdC5ib2R5KTtcblxuICAgICAgICAgIGVtaXRF
eHByKHN0bXQuY29uZCwgJ2kzMicpO1xuICAgICAgICAgIGJ3LmJ5dGUoT1BfQlJfSUYpOyBidy51
MzIoMCk7IC8vIGNvbnRpbnVlIGlmIHRydWVcblxuICAgICAgICAgIGRlcHRoLS07IGJ3LmJ5dGUo
T1BfRU5EKTsgLy8gZW5kIGxvb3BcbiAgICAgICAgICBicmVha1RhcmdldHMucG9wKCk7XG4gICAg
ICAgICAgZGVwdGgtLTsgYncuYnl0ZShPUF9FTkQpOyAvLyBlbmQgYmxvY2tcbiAgICAgICAgICBi
cmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdCcmVhayc6IHtcbiAgICAgICAgICBpZiAo
YnJlYWtUYXJnZXRzLmxlbmd0aCA9PT0gMCkgdGhyb3cgbmV3IEVycm9yKCdicmVhayBvdXRzaWRl
IGxvb3AnKTtcbiAgICAgICAgICBjb25zdCB0YXJnZXREZXB0aCA9IGJyZWFrVGFyZ2V0c1ticmVh
a1RhcmdldHMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgYncuYnl0ZShPUF9CUik7XG4gICAgICAg
ICAgYncudTMyKGRlcHRoIC0gdGFyZ2V0RGVwdGgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAg
ICB9XG4gICAgICAgIGNhc2UgJ0NhbGwnOiB7XG4gICAgICAgICAgLy8gRWFybHkgcmV0dXJuOiBj
YWxsIHJldHVybihleHByKSBvciBjYWxsIHJldHVybigpXG4gICAgICAgICAgaWYgKHN0bXQubmFt
ZSA9PT0gJ3JldHVybicpIHtcbiAgICAgICAgICAgIGlmIChpc0Z1bmMpIHtcbiAgICAgICAgICAg
ICAgaWYgKHN0bXQuYXJncy5sZW5ndGggIT09IDEpIHRocm93IG5ldyBFcnJvcigncmV0dXJuKCkg
aW4gYSBmdW5jdGlvbiByZXF1aXJlcyBleGFjdGx5IG9uZSBhcmd1bWVudCcpO1xuICAgICAgICAg
ICAgICBlbWl0RXhwcihzdG10LmFyZ3NbMF0sIHJldFR5cGUpO1xuICAgICAgICAgICAgfSBlbHNl
IHtcbiAgICAgICAgICAgICAgaWYgKHN0bXQuYXJncy5sZW5ndGggIT09IDApIHRocm93IG5ldyBF
cnJvcigncmV0dXJuKCkgaW4gYSBzdWJyb3V0aW5lIHRha2VzIG5vIGFyZ3VtZW50cycpO1xuICAg
ICAgICAgICAgfVxuICAgICAgICAgICAgYncuYnl0ZShPUF9SRVRVUk4pO1xuICAgICAgICAgICAg
YnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFNJTUQgbmFtZXNwYWNlZCBidWlsdGlu
cyB1c2VkIGFzIHN0YXRlbWVudHMgKGUuZy4gY2FsbCB2MTI4LnN0b3JlKC4uLikpXG4gICAgICAg
ICAgY29uc3QgY2FsbERvdElkeCA9IHN0bXQubmFtZS5pbmRleE9mKCcuJyk7XG4gICAgICAgICAg
aWYgKGNhbGxEb3RJZHggIT09IC0xKSB7XG4gICAgICAgICAgICBjb25zdCBjYWxsUHJlZml4ID0g
c3RtdC5uYW1lLnNsaWNlKDAsIGNhbGxEb3RJZHgpO1xuICAgICAgICAgICAgY29uc3QgY2FsbE1l
dGhvZCA9IHN0bXQubmFtZS5zbGljZShjYWxsRG90SWR4ICsgMSk7XG4gICAgICAgICAgICBpZiAo
aXNWZWN0b3IoY2FsbFByZWZpeCkgfHwgY2FsbFByZWZpeCA9PT0gJ3YxMjgnKSB7XG4gICAgICAg
ICAgICAgIGVtaXRTaW1kQnVpbHRpbihjYWxsUHJlZml4LCBjYWxsTWV0aG9kLCBzdG10LCBudWxs
KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAg
ICAgICAgIC8vIE5hdGl2ZSBidWlsdGlucyB1c2VkIGFzIHN0YXRlbWVudHMgKGUuZy4gY2FsbCBt
ZW1vcnlfY29weSguLi4pKVxuICAgICAgICAgIGlmIChOQVRJVkVfQlVJTFRJTlMuaGFzKHN0bXQu
bmFtZSkpIHtcbiAgICAgICAgICAgIGVtaXRGdW5jQ2FsbChzdG10LCBudWxsKTtcbiAgICAgICAg
ICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBJbmRpcmVjdCBjYWxsIHZpYSBm
dW5jdGlvbi10eXBlZCB2YXJpYWJsZSB1c2VkIGFzIHN0YXRlbWVudFxuICAgICAgICAgIGNvbnN0
IGNhbGxMb2NhbEluZm8gPSBsb2NhbE1hcFtzdG10Lm5hbWVdO1xuICAgICAgICAgIGNvbnN0IGNh
bGxHU2lnID0gZ2xvYmFsRnVuY1NpZ1tzdG10Lm5hbWVdO1xuICAgICAgICAgIGlmICgoY2FsbExv
Y2FsSW5mbyAmJiBjYWxsTG9jYWxJbmZvLmZ1bmNTaWcpIHx8IGNhbGxHU2lnKSB7XG4gICAgICAg
ICAgICBlbWl0RnVuY0NhbGwoc3RtdCwgbnVsbCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAg
ICAgICB9XG4gICAgICAgICAgLy8gc3Vicm91dGluZSBjYWxsIG9yIGZ1bmN0aW9uIGNhbGwgKHJl
c3VsdCBkaXNjYXJkZWQpXG4gICAgICAgICAgY29uc3QgZklkeCA9IGZ1bmNJbmRleFtzdG10Lm5h
bWVdO1xuICAgICAgICAgIGlmIChmSWR4ID09PSB1bmRlZmluZWQpIHRocm93IG5ldyBFcnJvcihg
VW5kZWZpbmVkIGZ1bmN0aW9uOiAke3N0bXQubmFtZX1gKTtcbiAgICAgICAgICBmb3IgKGxldCBh
aSA9IDA7IGFpIDwgc3RtdC5hcmdzLmxlbmd0aDsgYWkrKykge1xuICAgICAgICAgICAgLy8gaW5m
ZXIgcGFyYW0gdHlwZSBmcm9tIGRlY2xhcmF0aW9uXG4gICAgICAgICAgICBjb25zdCBwYXJhbVR5
cGUgPSBnZXRQYXJhbVR5cGUoc3RtdC5uYW1lLCBhaSk7XG4gICAgICAgICAgICBlbWl0RXhwcihz
dG10LmFyZ3NbYWldLCBwYXJhbVR5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBidy5ieXRl
KE9QX0NBTEwpO1xuICAgICAgICAgIGJ3LnUzMihmSWR4KTtcbiAgICAgICAgICBicmVhaztcbiAg
ICAgICAgfVxuICAgICAgICBjYXNlICdUYWlsQ2FsbCc6IHtcbiAgICAgICAgICBjb25zdCB0Y05h
bWUgPSBzdG10Lm5hbWU7XG5cbiAgICAgICAgICAvLyBJbmRpcmVjdCB0YWlsIGNhbGwgdmlhIGZ1
bmN0aW9uLXR5cGVkIHZhcmlhYmxlXG4gICAgICAgICAgY29uc3QgdGNMb2NhbEluZm8gPSBsb2Nh
bE1hcFt0Y05hbWVdO1xuICAgICAgICAgIGNvbnN0IHRjR1NpZyA9IGdsb2JhbEZ1bmNTaWdbdGNO
YW1lXTtcbiAgICAgICAgICBpZiAoKHRjTG9jYWxJbmZvICYmIHRjTG9jYWxJbmZvLmZ1bmNTaWcp
IHx8IHRjR1NpZykge1xuICAgICAgICAgICAgY29uc3Qgc2lnID0gKHRjTG9jYWxJbmZvICYmIHRj
TG9jYWxJbmZvLmZ1bmNTaWcpIHx8IHRjR1NpZztcbiAgICAgICAgICAgIGNvbnN0IGNhbGxlZVJl
dCA9IHNpZy5yZXRUeXBlIHx8IG51bGw7XG4gICAgICAgICAgICBpZiAoY2FsbGVlUmV0ICE9PSBy
ZXRUeXBlKVxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHRhaWxjYWxsIHR5cGUgbWlz
bWF0Y2g6ICR7dGNOYW1lfSByZXR1cm5zICR7Y2FsbGVlUmV0IHx8ICd2b2lkJ30sIGN1cnJlbnQg
ZnVuY3Rpb24gcmV0dXJucyAke3JldFR5cGUgfHwgJ3ZvaWQnfWApO1xuICAgICAgICAgICAgZm9y
IChsZXQgYWkgPSAwOyBhaSA8IHN0bXQuYXJncy5sZW5ndGg7IGFpKyspIHtcbiAgICAgICAgICAg
ICAgY29uc3QgcHQgPSBzaWcucGFyYW1zW2FpXSA/IChzaWcucGFyYW1zW2FpXS5pc0FycmF5ID8g
J2kzMicgOiBzaWcucGFyYW1zW2FpXS52dHlwZSkgOiAnZjY0JztcbiAgICAgICAgICAgICAgZW1p
dEV4cHIoc3RtdC5hcmdzW2FpXSwgcHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYg
KHRjTG9jYWxJbmZvKSB7IGJ3LmJ5dGUoT1BfTE9DQUxfR0VUKTsgYncudTMyKHRjTG9jYWxJbmZv
LmlkeCk7IH1cbiAgICAgICAgICAgIGVsc2UgeyBidy5ieXRlKE9QX0dMT0JBTF9HRVQpOyBidy51
MzIoZ2xvYmFsSW5kZXhbdGNOYW1lXSk7IH1cbiAgICAgICAgICAgIGNvbnN0IGluZGlyZWN0U2ln
SWQgPSBnZXRPckFkZFNpZyhzaWcucGFyYW1zLCBzaWcucmV0VHlwZSk7XG4gICAgICAgICAgICBi
dy5ieXRlKE9QX1JFVFVSTl9DQUxMX0lORElSRUNUKTtcbiAgICAgICAgICAgIGJ3LnUzMihpbmRp
cmVjdFNpZ0lkKTtcbiAgICAgICAgICAgIGJ3LnUzMigwKTtcbiAgICAgICAgICAgIGJyZWFrO1xu
ICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIERpcmVjdCB0YWlsIGNhbGwg4oCUIHR5cGUgdmFs
aWRhdGlvblxuICAgICAgICAgIGNvbnN0IGNhbGxlZUZuID0gZnVuY3Rpb25zLmZpbmQoZiA9PiBm
Lm5hbWUgPT09IHRjTmFtZSk7XG4gICAgICAgICAgY29uc3QgY2FsbGVlSW0gPSAhY2FsbGVlRm4g
JiYgYWxsSW1wb3J0cy5maW5kKGkgPT4gaS5uYW1lID09PSB0Y05hbWUpO1xuICAgICAgICAgIGNv
bnN0IGNhbGxlZVJldCA9IGNhbGxlZUZuID8gKGNhbGxlZUZuLnR5cGUgPT09ICdTdWJyb3V0aW5l
JyA/IG51bGwgOiBjYWxsZWVGbi5yZXRUeXBlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICA6
IGNhbGxlZUltID8gY2FsbGVlSW0ucmV0VHlwZSA6IG51bGw7XG4gICAgICAgICAgaWYgKGNhbGxl
ZVJldCAhPT0gcmV0VHlwZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgdGFpbGNhbGwg
dHlwZSBtaXNtYXRjaDogJHt0Y05hbWV9IHJldHVybnMgJHtjYWxsZWVSZXQgfHwgJ3ZvaWQnfSwg
Y3VycmVudCBmdW5jdGlvbiByZXR1cm5zICR7cmV0VHlwZSB8fCAndm9pZCd9YCk7XG5cbiAgICAg
ICAgICBjb25zdCB0Y0ZJZHggPSBmdW5jSW5kZXhbdGNOYW1lXTtcbiAgICAgICAgICBpZiAodGNG
SWR4ID09PSB1bmRlZmluZWQpIHRocm93IG5ldyBFcnJvcihgVW5kZWZpbmVkIGZ1bmN0aW9uOiAk
e3RjTmFtZX1gKTtcbiAgICAgICAgICBmb3IgKGxldCBhaSA9IDA7IGFpIDwgc3RtdC5hcmdzLmxl
bmd0aDsgYWkrKykge1xuICAgICAgICAgICAgZW1pdEV4cHIoc3RtdC5hcmdzW2FpXSwgZ2V0UGFy
YW1UeXBlKHRjTmFtZSwgYWkpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYncuYnl0ZShPUF9S
RVRVUk5fQ0FMTCk7XG4gICAgICAgICAgYncudTMyKHRjRklkeCk7XG4gICAgICAgICAgYnJlYWs7
XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3Io
YFVua25vd24gc3RhdGVtZW50IHR5cGU6ICR7c3RtdC50eXBlfWApO1xuICAgICAgfVxuICAgIH1c
blxuICAgIGZ1bmN0aW9uIGdldFBhcmFtVHlwZShmdW5jTmFtZSwgcGFyYW1JZHgpIHtcbiAgICAg
IC8vIGNoZWNrIGxvY2FsIGZ1bmN0aW9uc1xuICAgICAgY29uc3QgZm4gPSBmdW5jdGlvbnMuZmlu
ZChmID0+IGYubmFtZSA9PT0gZnVuY05hbWUpO1xuICAgICAgaWYgKGZuICYmIGZuLnBhcmFtc1tw
YXJhbUlkeF0pIHJldHVybiBmbi5wYXJhbXNbcGFyYW1JZHhdLmlzQXJyYXkgPyAnaTMyJyA6IGZu
LnBhcmFtc1twYXJhbUlkeF0udnR5cGU7XG4gICAgICAvLyBjaGVjayBpbXBvcnRzXG4gICAgICBj
b25zdCBpbSA9IGFsbEltcG9ydHMuZmluZChpID0+IGkubmFtZSA9PT0gZnVuY05hbWUpO1xuICAg
ICAgaWYgKGltICYmIGltLnBhcmFtc1twYXJhbUlkeF0pIHJldHVybiBpbS5wYXJhbXNbcGFyYW1J
ZHhdLnZ0eXBlO1xuICAgICAgcmV0dXJuICdmNjQnOyAvLyBkZWZhdWx0XG4gICAgfVxuXG4gICAg
ZnVuY3Rpb24gcmVzb2x2ZVR5cGUobmFtZSkge1xuICAgICAgaWYgKGxvY2FsTWFwW25hbWVdKSBy
ZXR1cm4gbG9jYWxNYXBbbmFtZV0udnR5cGU7XG4gICAgICBpZiAoZ2xvYmFsSW5kZXhbbmFtZV0g
IT09IHVuZGVmaW5lZCkgcmV0dXJuIGdsb2JhbHNbZ2xvYmFsSW5kZXhbbmFtZV1dLnZ0eXBlO1xu
ICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gVHlwZSBpbmZlcmVuY2UgZmFsbGJh
Y2s6IHdoZW4gZXhwZWN0ZWRUeXBlIGlzIG51bGwsIGd1ZXNzIGZyb20gQVNUIHNoYXBlLiBEZWZh
dWx0IGlzIGY2NC5cbiAgICBmdW5jdGlvbiBpbmZlckV4cHJUeXBlKGV4cHIpIHtcbiAgICAgIHN3
aXRjaCAoZXhwci50eXBlKSB7XG4gICAgICAgIGNhc2UgJ051bWJlckxpdCc6IHtcbiAgICAgICAg
ICBpZiAoZXhwci50eXBlU3VmZml4KSByZXR1cm4gZXhwci50eXBlU3VmZml4O1xuICAgICAgICAg
IGlmIChleHByLmlzRmxvYXQgfHwgZXhwci52YWx1ZS5pbmNsdWRlcygnLicpIHx8IGV4cHIudmFs
dWUuaW5jbHVkZXMoJ2UnKSB8fCBleHByLnZhbHVlLmluY2x1ZGVzKCdFJykpIHJldHVybiAnZjY0
JztcbiAgICAgICAgICByZXR1cm4gJ2kzMic7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnRnVu
Y1JlZic6IHJldHVybiAnaTMyJztcbiAgICAgICAgY2FzZSAnSWRlbnQnOiByZXR1cm4gcmVzb2x2
ZVR5cGUoZXhwci5uYW1lKSB8fCAnZjY0JztcbiAgICAgICAgY2FzZSAnQmluT3AnOiB7XG4gICAg
ICAgICAgY29uc3Qgb3AgPSBleHByLm9wO1xuICAgICAgICAgIGlmIChvcCA9PT0gJz09JyB8fCBv
cCA9PT0gJy89JyB8fCBvcCA9PT0gJzwnIHx8IG9wID09PSAnPicgfHwgb3AgPT09ICc8PScgfHwg
b3AgPT09ICc+PSdcbiAgICAgICAgICAgIHx8IG9wID09PSAnYW5kJyB8fCBvcCA9PT0gJ29yJykg
cmV0dXJuICdpMzInO1xuICAgICAgICAgIHJldHVybiBpbmZlckV4cHJUeXBlKGV4cHIubGVmdCk7
XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnVW5hcnlPcCc6IHJldHVybiBpbmZlckV4cHJUeXBl
KGV4cHIub3BlcmFuZCk7XG4gICAgICAgIGNhc2UgJ0Z1bmNDYWxsJzoge1xuICAgICAgICAgIC8v
IHR5cGUgY29udmVyc2lvbnMgLyB2ZWN0b3IgY29uc3RydWN0b3JzXG4gICAgICAgICAgaWYgKEFU
UkFfVFlQRVMuaGFzKGV4cHIubmFtZSkpIHJldHVybiBleHByLm5hbWU7XG4gICAgICAgICAgLy8g
U0lNRCBuYW1lc3BhY2VkIGJ1aWx0aW5zXG4gICAgICAgICAgY29uc3QgZG90SWR4ID0gZXhwci5u
YW1lLmluZGV4T2YoJy4nKTtcbiAgICAgICAgICBpZiAoZG90SWR4ICE9PSAtMSkge1xuICAgICAg
ICAgICAgY29uc3QgcHJlZml4ID0gZXhwci5uYW1lLnNsaWNlKDAsIGRvdElkeCk7XG4gICAgICAg
ICAgICBjb25zdCBtZXRob2QgPSBleHByLm5hbWUuc2xpY2UoZG90SWR4ICsgMSk7XG4gICAgICAg
ICAgICBpZiAoaXNWZWN0b3IocHJlZml4KSkge1xuICAgICAgICAgICAgICAvLyBleHRyYWN0X2xh
bmUgcmV0dXJucyB0aGUgc2NhbGFyIHR5cGVcbiAgICAgICAgICAgICAgaWYgKG1ldGhvZCA9PT0g
J2V4dHJhY3RfbGFuZScpIHJldHVybiB2ZWN0b3JTY2FsYXJUeXBlKHByZWZpeCk7XG4gICAgICAg
ICAgICAgIC8vIHNwbGF0LCByZXBsYWNlX2xhbmUsIGFkZCwgc3ViLCBtdWwsIGRpdiwgbmVnLCBh
YnMsIHNxcnQsIGVxLCBldGMuIHJldHVybiB0aGUgdmVjdG9yIHR5cGVcbiAgICAgICAgICAgICAg
cmV0dXJuIHByZWZpeDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcmVmaXggPT09
ICd2MTI4Jykge1xuICAgICAgICAgICAgICAvLyB2MTI4LmFuZC9vci94b3Ivbm90L2xvYWQgcmV0
dXJuIHYxMjgg4oCUIGluZmVyIGZyb20gZmlyc3QgYXJnXG4gICAgICAgICAgICAgIGlmIChtZXRo
b2QgPT09ICdsb2FkJykgcmV0dXJuIGluZmVyRXhwclR5cGUoZXhwci5hcmdzWzBdKSB8fCAnZjY0
eDInOyAvLyBkZWZhdWx0IHRvIGY2NHgyXG4gICAgICAgICAgICAgIGlmIChbJ2FuZCcsJ29yJywn
eG9yJywnbm90J10uaW5jbHVkZXMobWV0aG9kKSkgcmV0dXJuIGluZmVyRXhwclR5cGUoZXhwci5h
cmdzWzBdKTtcbiAgICAgICAgICAgICAgaWYgKG1ldGhvZCA9PT0gJ3N0b3JlJykgcmV0dXJuICdp
MzInOyAvLyBzdG9yZSBpcyBhIHN0YXRlbWVudCwgYnV0IHR5cGUgZG9lc24ndCBtYXR0ZXIgbXVj
aFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBJbmRpcmVjdCBjYWxs
IHZpYSBmdW5jdGlvbi10eXBlZCB2YXJpYWJsZVxuICAgICAgICAgIGNvbnN0IGNhbGxJbmZvID0g
bG9jYWxNYXBbZXhwci5uYW1lXTtcbiAgICAgICAgICBpZiAoY2FsbEluZm8gJiYgY2FsbEluZm8u
ZnVuY1NpZyAmJiBjYWxsSW5mby5mdW5jU2lnLnJldFR5cGUpIHJldHVybiBjYWxsSW5mby5mdW5j
U2lnLnJldFR5cGU7XG4gICAgICAgICAgaWYgKGdsb2JhbEZ1bmNTaWdbZXhwci5uYW1lXSAmJiBn
bG9iYWxGdW5jU2lnW2V4cHIubmFtZV0ucmV0VHlwZSkgcmV0dXJuIGdsb2JhbEZ1bmNTaWdbZXhw
ci5uYW1lXS5yZXRUeXBlO1xuICAgICAgICAgIC8vIGtub3duIHJldHVybiB0eXBlc1xuICAgICAg
ICAgIGNvbnN0IGZuID0gZnVuY3Rpb25zLmZpbmQoZiA9PiBmLm5hbWUgPT09IGV4cHIubmFtZSk7
XG4gICAgICAgICAgaWYgKGZuICYmIGZuLnJldFR5cGUpIHJldHVybiBmbi5yZXRUeXBlO1xuICAg
ICAgICAgIHJldHVybiAnZjY0JztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdBcnJheUFjY2Vz
cyc6IHtcbiAgICAgICAgICBjb25zdCBpbmZvID0gbG9jYWxNYXBbZXhwci5uYW1lXTtcbiAgICAg
ICAgICByZXR1cm4gaW5mbyA/IChpbmZvLmVsZW1UeXBlIHx8IGluZm8udnR5cGUpIDogJ2Y2NCc7
XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnSWZFeHByJzogcmV0dXJuIGluZmVyRXhwclR5cGUo
ZXhwci50aGVuRXhwcik7XG4gICAgICAgIGRlZmF1bHQ6IHJldHVybiAnZjY0JztcbiAgICAgIH1c
biAgICB9XG5cbiAgICAvLyDilIDilIAgRXhwcmVzc2lvbiBlbWlzc2lvbiDilIDilIBcbiAgICBm
dW5jdGlvbiBlbWl0RXhwcihleHByLCBleHBlY3RlZFR5cGUpIHtcbiAgICAgIGNvbnN0IGFjdHVh
bFR5cGUgPSBleHBlY3RlZFR5cGUgfHwgaW5mZXJFeHByVHlwZShleHByKTtcblxuICAgICAgc3dp
dGNoIChleHByLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnTnVtYmVyTGl0Jzoge1xuICAgICAgICAg
IGNvbnN0IHQgPSBleHBlY3RlZFR5cGUgfHwgaW5mZXJFeHByVHlwZShleHByKTtcbiAgICAgICAg
ICBjb25zdCByYXcgPSBleHByLnZhbHVlO1xuICAgICAgICAgIGlmICh0ID09PSAnaTMyJykgeyBi
dy5ieXRlKE9QX0kzMl9DT05TVCk7IGJ3LnMzMihwYXJzZUludChyYXcsIDEwKSB8IDApOyB9XG4g
ICAgICAgICAgZWxzZSBpZiAodCA9PT0gJ2k2NCcpIHsgYncuYnl0ZShPUF9JNjRfQ09OU1QpOyBi
dy5zNjQoQmlnSW50KHBhcnNlSW50KHJhdywgMTApKSk7IH1cbiAgICAgICAgICBlbHNlIGlmICh0
ID09PSAnZjMyJykgeyBidy5ieXRlKE9QX0YzMl9DT05TVCk7IGJ3LmYzMihwYXJzZUZsb2F0KHJh
dykpOyB9XG4gICAgICAgICAgZWxzZSB7IGJ3LmJ5dGUoT1BfRjY0X0NPTlNUKTsgYncuZjY0KHBh
cnNlRmxvYXQocmF3KSk7IH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBj
YXNlICdGdW5jUmVmJzoge1xuICAgICAgICAgIGNvbnN0IG5hbWUgPSBleHByLm5hbWU7XG4gICAg
ICAgICAgaWYgKHRhYmxlU2xvdFtuYW1lXSA9PT0gdW5kZWZpbmVkKSB0aHJvdyBuZXcgRXJyb3Io
YFVua25vd24gZnVuY3Rpb246ICR7bmFtZX1gKTtcbiAgICAgICAgICBidy5ieXRlKE9QX0kzMl9D
T05TVCk7IGJ3LnMzMih0YWJsZVNsb3RbbmFtZV0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAg
ICB9XG4gICAgICAgIGNhc2UgJ0lkZW50Jzoge1xuICAgICAgICAgIGNvbnN0IG5hbWUgPSBleHBy
Lm5hbWU7XG4gICAgICAgICAgaWYgKGlzRnVuYyAmJiBuYW1lID09PSBmbi5uYW1lKSB7XG4gICAg
ICAgICAgICAvLyBGb3J0cmFuIGNvbnZlbnRpb246IGJhcmUgZnVuY3Rpb24gbmFtZSByZWFkcyB0
aGUgcmV0dXJuIGFjY3VtdWxhdG9yXG4gICAgICAgICAgICBidy5ieXRlKE9QX0xPQ0FMX0dFVCk7
IGJ3LnUzMihsb2NhbE1hcFsnJF9yZXR1cm4nXS5pZHgpO1xuICAgICAgICAgIH1cbiAgICAgICAg
ICBlbHNlIGlmIChsb2NhbE1hcFtuYW1lXSkgeyBidy5ieXRlKE9QX0xPQ0FMX0dFVCk7IGJ3LnUz
Mihsb2NhbE1hcFtuYW1lXS5pZHgpOyB9XG4gICAgICAgICAgZWxzZSBpZiAoZ2xvYmFsSW5kZXhb
bmFtZV0gIT09IHVuZGVmaW5lZCkgeyBidy5ieXRlKE9QX0dMT0JBTF9HRVQpOyBidy51MzIoZ2xv
YmFsSW5kZXhbbmFtZV0pOyB9XG4gICAgICAgICAgZWxzZSB0aHJvdyBuZXcgRXJyb3IoYFVuZGVm
aW5lZCB2YXJpYWJsZTogJHtuYW1lfWApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4g
ICAgICAgIGNhc2UgJ0Jpbk9wJzoge1xuICAgICAgICAgIGNvbnN0IHQgPSBleHBlY3RlZFR5cGUg
fHwgaW5mZXJFeHByVHlwZShleHByKTtcbiAgICAgICAgICBlbWl0QmluT3AoZXhwciwgdCk7XG4g
ICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnVW5hcnlPcCc6IHtcbiAg
ICAgICAgICBjb25zdCB0ID0gZXhwZWN0ZWRUeXBlIHx8IGluZmVyRXhwclR5cGUoZXhwcik7XG4g
ICAgICAgICAgaWYgKGV4cHIub3AgPT09ICctJykge1xuICAgICAgICAgICAgaWYgKHQgPT09ICdm
NjQnKSB7IGVtaXRFeHByKGV4cHIub3BlcmFuZCwgdCk7IGJ3LmJ5dGUoT1BfRjY0X05FRyk7IH1c
biAgICAgICAgICAgIGVsc2UgaWYgKHQgPT09ICdmMzInKSB7IGVtaXRFeHByKGV4cHIub3BlcmFu
ZCwgdCk7IGJ3LmJ5dGUoT1BfRjMyX05FRyk7IH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHQgPT09
ICdpMzInKSB7IGJ3LmJ5dGUoT1BfSTMyX0NPTlNUKTsgYncuczMyKDApOyBlbWl0RXhwcihleHBy
Lm9wZXJhbmQsIHQpOyBidy5ieXRlKE9QX0kzMl9TVUIpOyB9XG4gICAgICAgICAgICBlbHNlIGlm
ICh0ID09PSAnaTY0JykgeyBidy5ieXRlKE9QX0k2NF9DT05TVCk7IGJ3LnM2NCgwbik7IGVtaXRF
eHByKGV4cHIub3BlcmFuZCwgdCk7IGJ3LmJ5dGUoT1BfSTY0X1NVQik7IH1cbiAgICAgICAgICAg
IGVsc2UgaWYgKGlzVmVjdG9yKHQpKSB7IGVtaXRFeHByKGV4cHIub3BlcmFuZCwgdCk7IGVtaXRT
aW1kKFNJTURfT1BTW3QgKyAnLm5lZyddKTsgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoZXhwci5v
cCA9PT0gJ25vdCcpIHtcbiAgICAgICAgICAgIGVtaXRFeHByKGV4cHIub3BlcmFuZCwgJ2kzMicp
O1xuICAgICAgICAgICAgYncuYnl0ZShPUF9JMzJfRVFaKTtcbiAgICAgICAgICB9IGVsc2UgaWYg
KGV4cHIub3AgPT09ICd+Jykge1xuICAgICAgICAgICAgZW1pdEV4cHIoZXhwci5vcGVyYW5kLCB0
KTtcbiAgICAgICAgICAgIGlmICh0ID09PSAnaTMyJykgeyBidy5ieXRlKE9QX0kzMl9DT05TVCk7
IGJ3LnMzMigtMSk7IGJ3LmJ5dGUoT1BfSTMyX1hPUik7IH1cbiAgICAgICAgICAgIGVsc2UgaWYg
KHQgPT09ICdpNjQnKSB7IGJ3LmJ5dGUoT1BfSTY0X0NPTlNUKTsgYncuczY0KC0xbik7IGJ3LmJ5
dGUoT1BfSTY0X1hPUik7IH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZW1pdEV4
cHIoZXhwci5vcGVyYW5kLCB0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAg
ICAgIH1cbiAgICAgICAgY2FzZSAnRnVuY0NhbGwnOiB7XG4gICAgICAgICAgZW1pdEZ1bmNDYWxs
KGV4cHIsIGV4cGVjdGVkVHlwZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAg
ICAgY2FzZSAnQXJyYXlBY2Nlc3MnOiB7XG4gICAgICAgICAgY29uc3QgaW5mbyA9IGxvY2FsTWFw
W2V4cHIubmFtZV07XG4gICAgICAgICAgaWYgKCFpbmZvKSB0aHJvdyBuZXcgRXJyb3IoYFVuZGVm
aW5lZCBhcnJheTogJHtleHByLm5hbWV9YCk7XG4gICAgICAgICAgY29uc3QgZWxlbVR5cGUgPSBp
bmZvLmVsZW1UeXBlIHx8IGluZm8udnR5cGU7XG4gICAgICAgICAgZW1pdEFycmF5QWRkcihleHBy
Lm5hbWUsIGV4cHIuaW5kaWNlcywgaW5mbywgZWxlbVR5cGUpO1xuICAgICAgICAgIGVtaXRMb2Fk
KGVsZW1UeXBlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdJ
ZkV4cHInOiB7XG4gICAgICAgICAgY29uc3QgdCA9IGV4cGVjdGVkVHlwZSB8fCBpbmZlckV4cHJU
eXBlKGV4cHIudGhlbkV4cHIpO1xuICAgICAgICAgIGVtaXRFeHByKGV4cHIuY29uZCwgJ2kzMicp
O1xuICAgICAgICAgIGJ3LmJ5dGUoT1BfSUYpO1xuICAgICAgICAgIGJ3LmJ5dGUod2FzbVR5cGUo
dCkpO1xuICAgICAgICAgIGVtaXRFeHByKGV4cHIudGhlbkV4cHIsIHQpO1xuICAgICAgICAgIGJ3
LmJ5dGUoT1BfRUxTRSk7XG4gICAgICAgICAgZW1pdEV4cHIoZXhwci5lbHNlRXhwciwgdCk7XG4g
ICAgICAgICAgYncuYnl0ZShPUF9FTkQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4g
ICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGV4cHJl
c3Npb24gdHlwZTogJHtleHByLnR5cGV9YCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8g4pSA
4pSAIEJpbmFyeSBvcGVyYXRvcnMg4pSA4pSAXG4gICAgZnVuY3Rpb24gZW1pdEJpbk9wKGV4cHIs
IHQpIHtcbiAgICAgIGNvbnN0IG9wID0gZXhwci5vcDtcblxuICAgICAgLy8gRXhwb25lbnRpYXRp
b25cbiAgICAgIGlmIChvcCA9PT0gJyoqJykge1xuICAgICAgICBlbWl0UG93KGV4cHIsIHQpO1xu
ICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIENvbXBhcmlzb24gb3BlcmF0b3Jz
IHJldHVybiBpMzJcbiAgICAgIGlmIChvcCA9PT0gJz09JyB8fCBvcCA9PT0gJy89JyB8fCBvcCA9
PT0gJzwnIHx8IG9wID09PSAnPicgfHwgb3AgPT09ICc8PScgfHwgb3AgPT09ICc+PScpIHtcbiAg
ICAgICAgY29uc3Qgb3BlcmFuZFR5cGUgPSBpbmZlckV4cHJUeXBlKGV4cHIubGVmdCk7XG4gICAg
ICAgIGVtaXRFeHByKGV4cHIubGVmdCwgb3BlcmFuZFR5cGUpO1xuICAgICAgICBlbWl0RXhwcihl
eHByLnJpZ2h0LCBvcGVyYW5kVHlwZSk7XG4gICAgICAgIGVtaXRDbXAob3AsIG9wZXJhbmRUeXBl
KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBMb2dpY2FsOiBhbmQsIG9y
XG4gICAgICBpZiAob3AgPT09ICdhbmQnKSB7XG4gICAgICAgIGVtaXRFeHByKGV4cHIubGVmdCwg
J2kzMicpO1xuICAgICAgICBlbWl0RXhwcihleHByLnJpZ2h0LCAnaTMyJyk7XG4gICAgICAgIGJ3
LmJ5dGUoT1BfSTMyX0FORCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChv
cCA9PT0gJ29yJykge1xuICAgICAgICBlbWl0RXhwcihleHByLmxlZnQsICdpMzInKTtcbiAgICAg
ICAgZW1pdEV4cHIoZXhwci5yaWdodCwgJ2kzMicpO1xuICAgICAgICBidy5ieXRlKE9QX0kzMl9P
Uik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZW1pdEV4cHIoZXhwci5sZWZ0
LCB0KTtcbiAgICAgIGVtaXRFeHByKGV4cHIucmlnaHQsIHQpO1xuXG4gICAgICBpZiAob3AgPT09
ICcrJykgZW1pdEFkZCh0KTtcbiAgICAgIGVsc2UgaWYgKG9wID09PSAnLScpIGVtaXRTdWIodCk7
XG4gICAgICBlbHNlIGlmIChvcCA9PT0gJyonKSBlbWl0TXVsKHQpO1xuICAgICAgZWxzZSBpZiAo
b3AgPT09ICcvJykgZW1pdERpdih0KTtcbiAgICAgIGVsc2UgaWYgKG9wID09PSAnbW9kJykge1xu
ICAgICAgICBpZiAodCA9PT0gJ2kzMicpIGJ3LmJ5dGUoT1BfSTMyX1JFTV9TKTtcbiAgICAgICAg
ZWxzZSBpZiAodCA9PT0gJ2k2NCcpIGJ3LmJ5dGUoT1BfSTY0X1JFTV9TKTtcbiAgICAgICAgZWxz
ZSB0aHJvdyBuZXcgRXJyb3IoJ21vZCByZXF1aXJlcyBpbnRlZ2VyIHR5cGUnKTtcbiAgICAgIH1c
biAgICAgIGVsc2UgaWYgKG9wID09PSAnJicpIHsgaWYgKHQgPT09ICdpMzInKSBidy5ieXRlKE9Q
X0kzMl9BTkQpOyBlbHNlIGJ3LmJ5dGUoT1BfSTY0X0FORCk7IH1cbiAgICAgIGVsc2UgaWYgKG9w
ID09PSAnfCcpIHsgaWYgKHQgPT09ICdpMzInKSBidy5ieXRlKE9QX0kzMl9PUik7IGVsc2UgYncu
Ynl0ZShPUF9JNjRfT1IpOyB9XG4gICAgICBlbHNlIGlmIChvcCA9PT0gJ14nKSB7IGlmICh0ID09
PSAnaTMyJykgYncuYnl0ZShPUF9JMzJfWE9SKTsgZWxzZSBidy5ieXRlKE9QX0k2NF9YT1IpOyB9
XG4gICAgICBlbHNlIGlmIChvcCA9PT0gJzw8JykgeyBpZiAodCA9PT0gJ2kzMicpIGJ3LmJ5dGUo
T1BfSTMyX1NITCk7IGVsc2UgYncuYnl0ZShPUF9JNjRfU0hMKTsgfVxuICAgICAgZWxzZSBpZiAo
b3AgPT09ICc+PicpIHsgaWYgKHQgPT09ICdpMzInKSBidy5ieXRlKE9QX0kzMl9TSFJfUyk7IGVs
c2UgYncuYnl0ZShPUF9JNjRfU0hSX1MpOyB9XG4gICAgICBlbHNlIHRocm93IG5ldyBFcnJvcihg
VW5rbm93biBvcGVyYXRvcjogJHtvcH1gKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlbWl0UG93
KGV4cHIsIHQpIHtcbiAgICAgIC8vICoqMC41IOKGkiBzcXJ0XG4gICAgICBpZiAoZXhwci5yaWdo
dC50eXBlID09PSAnTnVtYmVyTGl0JyAmJiAoZXhwci5yaWdodC52YWx1ZSA9PT0gJzAuNScgfHwg
ZXhwci5yaWdodC52YWx1ZSA9PT0gJy41JykpIHtcbiAgICAgICAgZW1pdEV4cHIoZXhwci5sZWZ0
LCB0KTtcbiAgICAgICAgaWYgKHQgPT09ICdmNjQnKSBidy5ieXRlKE9QX0Y2NF9TUVJUKTtcbiAg
ICAgICAgZWxzZSBpZiAodCA9PT0gJ2YzMicpIGJ3LmJ5dGUoT1BfRjMyX1NRUlQpO1xuICAgICAg
ICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBHZW5lcmFsOiBjYWxsIHBvdyBpbXBvcnQgKHdv
cmtzIGZvciBhbGwgY2FzZXMgaW5jbHVkaW5nICoqMiwgKiozKVxuICAgICAgZW1pdEV4cHIoZXhw
ci5sZWZ0LCAnZjY0Jyk7XG4gICAgICBlbWl0RXhwcihleHByLnJpZ2h0LCAnZjY0Jyk7XG4gICAg
ICBidy5ieXRlKE9QX0NBTEwpO1xuICAgICAgYncudTMyKGZ1bmNJbmRleFsncG93J10pO1xuICAg
ICAgLy8gQ29udmVydCByZXN1bHQgYmFjayBpZiBuZWVkZWRcbiAgICAgIGlmICh0ID09PSAnZjMy
JykgYncuYnl0ZShPUF9GMzJfREVNT1RFX0Y2NCk7XG4gICAgfVxuXG4gICAgLy8g4pSA4pSAIEZ1
bmN0aW9uIGNhbGwgZGlzcGF0Y2gg4pSA4pSAXG4gICAgLy8gUHJpb3JpdHk6IHZlY3RvciBjb25z
dHJ1Y3RvcnMgPiB0eXBlIGNvbnZlcnNpb25zID4gU0lNRCBidWlsdGlucyA+IG5hdGl2ZSBidWls
dGluc1xuICAgIC8vICAgICAgICAgPiB3YXNtLiogZXNjYXBlIGhhdGNoID4gaW5kaXJlY3QgY2Fs
bHMgKGNhbGxfaW5kaXJlY3QpID4gcmVndWxhciBjYWxsc1xuICAgIGZ1bmN0aW9uIGVtaXRGdW5j
Q2FsbChleHByLCBleHBlY3RlZFR5cGUpIHtcbiAgICAgIGNvbnN0IG5hbWUgPSBleHByLm5hbWU7
XG5cbiAgICAgIC8vIFZlY3RvciBjb25zdHJ1Y3RvcnM6IGY2NHgyKGEsIGIpLCBmMzJ4NChhLCBi
LCBjLCBkKSwgZXRjLlxuICAgICAgaWYgKGlzVmVjdG9yKG5hbWUpKSB7XG4gICAgICAgIGVtaXRW
ZWN0b3JDb25zdHJ1Y3RvcihuYW1lLCBleHByLmFyZ3MpO1xuICAgICAgICByZXR1cm47XG4gICAg
ICB9XG5cbiAgICAgIC8vIFNjYWxhciB0eXBlIGNvbnZlcnNpb25zOiBpMzIoeCksIGY2NCh4KSwg
ZXRjLlxuICAgICAgaWYgKEFUUkFfVFlQRVMuaGFzKG5hbWUpKSB7XG4gICAgICAgIGNvbnN0IGZy
b21UeXBlID0gaW5mZXJFeHByVHlwZShleHByLmFyZ3NbMF0pO1xuICAgICAgICBjb25zdCB0b1R5
cGUgPSBuYW1lO1xuICAgICAgICBlbWl0RXhwcihleHByLmFyZ3NbMF0sIGZyb21UeXBlKTtcbiAg
ICAgICAgZW1pdENvbnZlcnNpb24oZnJvbVR5cGUsIHRvVHlwZSk7XG4gICAgICAgIHJldHVybjtc
biAgICAgIH1cblxuICAgICAgLy8gU0lNRCBuYW1lc3BhY2VkIGJ1aWx0aW5zOiBmNjR4Mi5zcGxh
dCwgdjEyOC5hbmQsIGV0Yy5cbiAgICAgIGNvbnN0IGRvdElkeCA9IG5hbWUuaW5kZXhPZignLicp
O1xuICAgICAgaWYgKGRvdElkeCAhPT0gLTEpIHtcbiAgICAgICAgY29uc3QgcHJlZml4ID0gbmFt
ZS5zbGljZSgwLCBkb3RJZHgpO1xuICAgICAgICBjb25zdCBtZXRob2QgPSBuYW1lLnNsaWNlKGRv
dElkeCArIDEpO1xuICAgICAgICBpZiAoaXNWZWN0b3IocHJlZml4KSB8fCBwcmVmaXggPT09ICd2
MTI4Jykge1xuICAgICAgICAgIGVtaXRTaW1kQnVpbHRpbihwcmVmaXgsIG1ldGhvZCwgZXhwciwg
ZXhwZWN0ZWRUeXBlKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cblxu
ICAgICAgLy8gTmF0aXZlIGJ1aWx0aW5zIOKAlCB3aXRoIHZlY3RvciB0eXBlIHN1cHBvcnRcbiAg
ICAgIGlmIChuYW1lID09PSAnc3FydCcpIHtcbiAgICAgICAgZW1pdEV4cHIoZXhwci5hcmdzWzBd
LCBleHBlY3RlZFR5cGUpO1xuICAgICAgICBpZiAoaXNWZWN0b3IoZXhwZWN0ZWRUeXBlKSkgeyBj
b25zdCBvcCA9IFNJTURfT1BTW2V4cGVjdGVkVHlwZSArICcuc3FydCddOyBpZiAob3AgPT09IHVu
ZGVmaW5lZCkgdGhyb3cgbmV3IEVycm9yKCdzcXJ0IG5vdCBzdXBwb3J0ZWQgZm9yICcgKyBleHBl
Y3RlZFR5cGUpOyBlbWl0U2ltZChvcCk7IH1cbiAgICAgICAgZWxzZSBpZiAoZXhwZWN0ZWRUeXBl
ID09PSAnZjMyJykgYncuYnl0ZShPUF9GMzJfU1FSVCk7XG4gICAgICAgIGVsc2UgYncuYnl0ZShP
UF9GNjRfU1FSVCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChuYW1lID09
PSAnYWJzJykge1xuICAgICAgICBlbWl0RXhwcihleHByLmFyZ3NbMF0sIGV4cGVjdGVkVHlwZSk7
XG4gICAgICAgIGlmIChpc1ZlY3RvcihleHBlY3RlZFR5cGUpKSB7IGNvbnN0IG9wID0gU0lNRF9P
UFNbZXhwZWN0ZWRUeXBlICsgJy5hYnMnXTsgaWYgKG9wID09PSB1bmRlZmluZWQpIHRocm93IG5l
dyBFcnJvcignYWJzIG5vdCBzdXBwb3J0ZWQgZm9yICcgKyBleHBlY3RlZFR5cGUpOyBlbWl0U2lt
ZChvcCk7IH1cbiAgICAgICAgZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSAnZjMyJykgYncuYnl0
ZShPUF9GMzJfQUJTKTtcbiAgICAgICAgZWxzZSBidy5ieXRlKE9QX0Y2NF9BQlMpO1xuICAgICAg
ICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAobmFtZSA9PT0gJ2Zsb29yJykgeyBlbWl0RXhw
cihleHByLmFyZ3NbMF0sIGV4cGVjdGVkVHlwZSk7IGlmIChleHBlY3RlZFR5cGUgPT09ICdmMzIn
KSBidy5ieXRlKE9QX0YzMl9GTE9PUik7IGVsc2UgYncuYnl0ZShPUF9GNjRfRkxPT1IpOyByZXR1
cm47IH1cbiAgICAgIGlmIChuYW1lID09PSAnY2VpbCcpIHsgZW1pdEV4cHIoZXhwci5hcmdzWzBd
LCBleHBlY3RlZFR5cGUpOyBpZiAoZXhwZWN0ZWRUeXBlID09PSAnZjMyJykgYncuYnl0ZShPUF9G
MzJfQ0VJTCk7IGVsc2UgYncuYnl0ZShPUF9GNjRfQ0VJTCk7IHJldHVybjsgfVxuICAgICAgaWYg
KG5hbWUgPT09ICd0cnVuYycpIHsgZW1pdEV4cHIoZXhwci5hcmdzWzBdLCBleHBlY3RlZFR5cGUp
OyBpZiAoZXhwZWN0ZWRUeXBlID09PSAnZjMyJykgYncuYnl0ZShPUF9GMzJfVFJVTkMpOyBlbHNl
IGJ3LmJ5dGUoT1BfRjY0X1RSVU5DKTsgcmV0dXJuOyB9XG4gICAgICBpZiAobmFtZSA9PT0gJ25l
YXJlc3QnKSB7IGVtaXRFeHByKGV4cHIuYXJnc1swXSwgZXhwZWN0ZWRUeXBlKTsgaWYgKGV4cGVj
dGVkVHlwZSA9PT0gJ2YzMicpIGJ3LmJ5dGUoT1BfRjMyX05FQVJFU1QpOyBlbHNlIGJ3LmJ5dGUo
T1BfRjY0X05FQVJFU1QpOyByZXR1cm47IH1cbiAgICAgIGlmIChuYW1lID09PSAnbWluJykge1xu
ICAgICAgICBpZiAoaXNWZWN0b3IoZXhwZWN0ZWRUeXBlKSkge1xuICAgICAgICAgIGVtaXRFeHBy
KGV4cHIuYXJnc1swXSwgZXhwZWN0ZWRUeXBlKTsgZW1pdEV4cHIoZXhwci5hcmdzWzFdLCBleHBl
Y3RlZFR5cGUpO1xuICAgICAgICAgIGNvbnN0IG9wID0gU0lNRF9PUFNbZXhwZWN0ZWRUeXBlICsg
Jy5taW4nXTsgaWYgKG9wID09PSB1bmRlZmluZWQpIHRocm93IG5ldyBFcnJvcignbWluIG5vdCBz
dXBwb3J0ZWQgZm9yICcgKyBleHBlY3RlZFR5cGUpOyBlbWl0U2ltZChvcCk7XG4gICAgICAgIH0g
ZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSAnaTMyJyB8fCBleHBlY3RlZFR5cGUgPT09ICdpNjQn
KSB7XG4gICAgICAgICAgLy8gV2FzbSBoYXMgbm8gaTMyLm1pbi9pNjQubWluIOKAlCBlbWl0OiBh
IGIgYSBiIGx0X3Mgc2VsZWN0XG4gICAgICAgICAgZW1pdEV4cHIoZXhwci5hcmdzWzBdLCBleHBl
Y3RlZFR5cGUpO1xuICAgICAgICAgIGVtaXRFeHByKGV4cHIuYXJnc1sxXSwgZXhwZWN0ZWRUeXBl
KTtcbiAgICAgICAgICBlbWl0RXhwcihleHByLmFyZ3NbMF0sIGV4cGVjdGVkVHlwZSk7XG4gICAg
ICAgICAgZW1pdEV4cHIoZXhwci5hcmdzWzFdLCBleHBlY3RlZFR5cGUpO1xuICAgICAgICAgIGJ3
LmJ5dGUoZXhwZWN0ZWRUeXBlID09PSAnaTMyJyA/IE9QX0kzMl9MVF9TIDogT1BfSTY0X0xUX1Mp
O1xuICAgICAgICAgIGJ3LmJ5dGUoT1BfU0VMRUNUKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAg
ICAgICBlbWl0RXhwcihleHByLmFyZ3NbMF0sIGV4cGVjdGVkVHlwZSk7IGVtaXRFeHByKGV4cHIu
YXJnc1sxXSwgZXhwZWN0ZWRUeXBlKTtcbiAgICAgICAgICBpZiAoZXhwZWN0ZWRUeXBlID09PSAn
ZjMyJykgYncuYnl0ZShPUF9GMzJfTUlOKTtcbiAgICAgICAgICBlbHNlIGJ3LmJ5dGUoT1BfRjY0
X01JTik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKG5h
bWUgPT09ICdtYXgnKSB7XG4gICAgICAgIGlmIChpc1ZlY3RvcihleHBlY3RlZFR5cGUpKSB7XG4g
ICAgICAgICAgZW1pdEV4cHIoZXhwci5hcmdzWzBdLCBleHBlY3RlZFR5cGUpOyBlbWl0RXhwcihl
eHByLmFyZ3NbMV0sIGV4cGVjdGVkVHlwZSk7XG4gICAgICAgICAgY29uc3Qgb3AgPSBTSU1EX09Q
U1tleHBlY3RlZFR5cGUgKyAnLm1heCddOyBpZiAob3AgPT09IHVuZGVmaW5lZCkgdGhyb3cgbmV3
IEVycm9yKCdtYXggbm90IHN1cHBvcnRlZCBmb3IgJyArIGV4cGVjdGVkVHlwZSk7IGVtaXRTaW1k
KG9wKTtcbiAgICAgICAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09ICdpMzInIHx8IGV4cGVj
dGVkVHlwZSA9PT0gJ2k2NCcpIHtcbiAgICAgICAgICAvLyBXYXNtIGhhcyBubyBpMzIubWF4L2k2
NC5tYXgg4oCUIGVtaXQ6IGEgYiBhIGIgZ3RfcyBzZWxlY3RcbiAgICAgICAgICBlbWl0RXhwcihl
eHByLmFyZ3NbMF0sIGV4cGVjdGVkVHlwZSk7XG4gICAgICAgICAgZW1pdEV4cHIoZXhwci5hcmdz
WzFdLCBleHBlY3RlZFR5cGUpO1xuICAgICAgICAgIGVtaXRFeHByKGV4cHIuYXJnc1swXSwgZXhw
ZWN0ZWRUeXBlKTtcbiAgICAgICAgICBlbWl0RXhwcihleHByLmFyZ3NbMV0sIGV4cGVjdGVkVHlw
ZSk7XG4gICAgICAgICAgYncuYnl0ZShleHBlY3RlZFR5cGUgPT09ICdpMzInID8gT1BfSTMyX0dU
X1MgOiBPUF9JNjRfR1RfUyk7XG4gICAgICAgICAgYncuYnl0ZShPUF9TRUxFQ1QpO1xuICAgICAg
ICB9IGVsc2Uge1xuICAgICAgICAgIGVtaXRFeHByKGV4cHIuYXJnc1swXSwgZXhwZWN0ZWRUeXBl
KTsgZW1pdEV4cHIoZXhwci5hcmdzWzFdLCBleHBlY3RlZFR5cGUpO1xuICAgICAgICAgIGlmIChl
eHBlY3RlZFR5cGUgPT09ICdmMzInKSBidy5ieXRlKE9QX0YzMl9NQVgpO1xuICAgICAgICAgIGVs
c2UgYncuYnl0ZShPUF9GNjRfTUFYKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAg
ICB9XG4gICAgICBpZiAobmFtZSA9PT0gJ2NvcHlzaWduJykgeyBlbWl0RXhwcihleHByLmFyZ3Nb
MF0sIGV4cGVjdGVkVHlwZSk7IGVtaXRFeHByKGV4cHIuYXJnc1sxXSwgZXhwZWN0ZWRUeXBlKTsg
aWYgKGV4cGVjdGVkVHlwZSA9PT0gJ2YzMicpIGJ3LmJ5dGUoT1BfRjMyX0NPUFlTSUdOKTsgZWxz
ZSBidy5ieXRlKE9QX0Y2NF9DT1BZU0lHTik7IHJldHVybjsgfVxuICAgICAgaWYgKG5hbWUgPT09
ICdzZWxlY3QnKSB7XG4gICAgICAgIC8vIHNlbGVjdChhLCBiLCBjb25kKSDigJQgV2FzbSBzZWxl
Y3QgcGlja3MgYSBpZiBjb25kIT0wLCBiIG90aGVyd2lzZVxuICAgICAgICBjb25zdCB0ID0gZXhw
ZWN0ZWRUeXBlIHx8IGluZmVyRXhwclR5cGUoZXhwci5hcmdzWzBdKTtcbiAgICAgICAgZW1pdEV4
cHIoZXhwci5hcmdzWzBdLCB0KTtcbiAgICAgICAgZW1pdEV4cHIoZXhwci5hcmdzWzFdLCB0KTtc
biAgICAgICAgZW1pdEV4cHIoZXhwci5hcmdzWzJdLCAnaTMyJyk7XG4gICAgICAgIGJ3LmJ5dGUo
T1BfU0VMRUNUKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKG5hbWUgPT09
ICdjbHonKSB7IGVtaXRFeHByKGV4cHIuYXJnc1swXSwgZXhwZWN0ZWRUeXBlKTsgaWYgKGV4cGVj
dGVkVHlwZSA9PT0gJ2k2NCcpIGJ3LmJ5dGUoT1BfSTY0X0NMWik7IGVsc2UgYncuYnl0ZShPUF9J
MzJfQ0xaKTsgcmV0dXJuOyB9XG4gICAgICBpZiAobmFtZSA9PT0gJ2N0eicpIHsgZW1pdEV4cHIo
ZXhwci5hcmdzWzBdLCBleHBlY3RlZFR5cGUpOyBpZiAoZXhwZWN0ZWRUeXBlID09PSAnaTY0Jykg
YncuYnl0ZShPUF9JNjRfQ1RaKTsgZWxzZSBidy5ieXRlKE9QX0kzMl9DVFopOyByZXR1cm47IH1c
biAgICAgIGlmIChuYW1lID09PSAncG9wY250JykgeyBlbWl0RXhwcihleHByLmFyZ3NbMF0sIGV4
cGVjdGVkVHlwZSk7IGlmIChleHBlY3RlZFR5cGUgPT09ICdpNjQnKSBidy5ieXRlKE9QX0k2NF9Q
T1BDTlQpOyBlbHNlIGJ3LmJ5dGUoT1BfSTMyX1BPUENOVCk7IHJldHVybjsgfVxuICAgICAgaWYg
KG5hbWUgPT09ICdyb3RsJykgeyBlbWl0RXhwcihleHByLmFyZ3NbMF0sIGV4cGVjdGVkVHlwZSk7
IGVtaXRFeHByKGV4cHIuYXJnc1sxXSwgZXhwZWN0ZWRUeXBlKTsgaWYgKGV4cGVjdGVkVHlwZSA9
PT0gJ2k2NCcpIGJ3LmJ5dGUoT1BfSTY0X1JPVEwpOyBlbHNlIGJ3LmJ5dGUoT1BfSTMyX1JPVEwp
OyByZXR1cm47IH1cbiAgICAgIGlmIChuYW1lID09PSAncm90cicpIHsgZW1pdEV4cHIoZXhwci5h
cmdzWzBdLCBleHBlY3RlZFR5cGUpOyBlbWl0RXhwcihleHByLmFyZ3NbMV0sIGV4cGVjdGVkVHlw
ZSk7IGlmIChleHBlY3RlZFR5cGUgPT09ICdpNjQnKSBidy5ieXRlKE9QX0k2NF9ST1RSKTsgZWxz
ZSBidy5ieXRlKE9QX0kzMl9ST1RSKTsgcmV0dXJuOyB9XG4gICAgICBpZiAobmFtZSA9PT0gJ21l
bW9yeV9zaXplJykgeyBidy5ieXRlKE9QX01FTU9SWV9TSVpFKTsgYncudTMyKDApOyByZXR1cm47
IH1cbiAgICAgIGlmIChuYW1lID09PSAnbWVtb3J5X2dyb3cnKSB7IGVtaXRFeHByKGV4cHIuYXJn
c1swXSwgJ2kzMicpOyBidy5ieXRlKE9QX01FTU9SWV9HUk9XKTsgYncudTMyKDApOyByZXR1cm47
IH1cbiAgICAgIGlmIChuYW1lID09PSAnbWVtb3J5X2NvcHknKSB7XG4gICAgICAgIGVtaXRFeHBy
KGV4cHIuYXJnc1swXSwgJ2kzMicpOyBlbWl0RXhwcihleHByLmFyZ3NbMV0sICdpMzInKTsgZW1p
dEV4cHIoZXhwci5hcmdzWzJdLCAnaTMyJyk7XG4gICAgICAgIGJ3LmJ5dGUoT1BfRkNfUFJFRklY
KTsgYncudTMyKDEwKTsgYncudTMyKDApOyBidy51MzIoMCk7IC8vIG1lbW9yeS5jb3B5LCBkc3Rf
bWVtPTAsIHNyY19tZW09MFxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAobmFt
ZSA9PT0gJ21lbW9yeV9maWxsJykge1xuICAgICAgICBlbWl0RXhwcihleHByLmFyZ3NbMF0sICdp
MzInKTsgZW1pdEV4cHIoZXhwci5hcmdzWzFdLCAnaTMyJyk7IGVtaXRFeHByKGV4cHIuYXJnc1sy
XSwgJ2kzMicpO1xuICAgICAgICBidy5ieXRlKE9QX0ZDX1BSRUZJWCk7IGJ3LnUzMigxMSk7IGJ3
LnUzMigwKTsgLy8gbWVtb3J5LmZpbGwsIG1lbT0wXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1c
blxuICAgICAgLy8gd2FzbS4qIGVzY2FwZSBoYXRjaFxuICAgICAgaWYgKG5hbWUuc3RhcnRzV2l0
aCgnd2FzbS4nKSkge1xuICAgICAgICBlbWl0V2FzbUJ1aWx0aW4obmFtZS5zbGljZSg1KSwgZXhw
ciwgZXhwZWN0ZWRUeXBlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBJ
bmRpcmVjdCBjYWxsIHZpYSBmdW5jdGlvbi10eXBlZCB2YXJpYWJsZVxuICAgICAgY29uc3QgbG9j
YWxJbmZvID0gbG9jYWxNYXBbbmFtZV07XG4gICAgICBjb25zdCBnU2lnID0gZ2xvYmFsRnVuY1Np
Z1tuYW1lXTtcbiAgICAgIGlmICgobG9jYWxJbmZvICYmIGxvY2FsSW5mby5mdW5jU2lnKSB8fCBn
U2lnKSB7XG4gICAgICAgIGNvbnN0IHNpZyA9IChsb2NhbEluZm8gJiYgbG9jYWxJbmZvLmZ1bmNT
aWcpIHx8IGdTaWc7XG4gICAgICAgIC8vIEVtaXQgYXJndW1lbnRzIHVzaW5nIGZ1bmNTaWcgcGFy
YW0gdHlwZXNcbiAgICAgICAgZm9yIChsZXQgYWkgPSAwOyBhaSA8IGV4cHIuYXJncy5sZW5ndGg7
IGFpKyspIHtcbiAgICAgICAgICBjb25zdCBwdCA9IHNpZy5wYXJhbXNbYWldID8gKHNpZy5wYXJh
bXNbYWldLmlzQXJyYXkgPyAnaTMyJyA6IHNpZy5wYXJhbXNbYWldLnZ0eXBlKSA6ICdmNjQnO1xu
ICAgICAgICAgIGVtaXRFeHByKGV4cHIuYXJnc1thaV0sIHB0KTtcbiAgICAgICAgfVxuICAgICAg
ICAvLyBQdXNoIHRoZSB0YWJsZSBpbmRleCAodGhlIHZhcmlhYmxlIHZhbHVlKVxuICAgICAgICBp
ZiAobG9jYWxJbmZvKSB7IGJ3LmJ5dGUoT1BfTE9DQUxfR0VUKTsgYncudTMyKGxvY2FsSW5mby5p
ZHgpOyB9XG4gICAgICAgIGVsc2UgeyBidy5ieXRlKE9QX0dMT0JBTF9HRVQpOyBidy51MzIoZ2xv
YmFsSW5kZXhbbmFtZV0pOyB9XG4gICAgICAgIC8vIGNhbGxfaW5kaXJlY3QgdHlwZV9pbmRleCB0
YWJsZV9pbmRleFxuICAgICAgICBjb25zdCBpbmRpcmVjdFNpZ0lkID0gZ2V0T3JBZGRTaWcoc2ln
LnBhcmFtcywgc2lnLnJldFR5cGUpO1xuICAgICAgICBidy5ieXRlKE9QX0NBTExfSU5ESVJFQ1Qp
O1xuICAgICAgICBidy51MzIoaW5kaXJlY3RTaWdJZCk7XG4gICAgICAgIGJ3LnUzMigwKTsgLy8g
dGFibGUgaW5kZXggMFxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFJlZ3Vs
YXIgZnVuY3Rpb24gY2FsbFxuICAgICAgY29uc3QgZklkeCA9IGZ1bmNJbmRleFtuYW1lXTtcbiAg
ICAgIGlmIChmSWR4ID09PSB1bmRlZmluZWQpIHRocm93IG5ldyBFcnJvcihgVW5kZWZpbmVkIGZ1
bmN0aW9uOiAke25hbWV9YCk7XG4gICAgICBmb3IgKGxldCBhaSA9IDA7IGFpIDwgZXhwci5hcmdz
Lmxlbmd0aDsgYWkrKykge1xuICAgICAgICBjb25zdCBwYXJhbVR5cGUgPSBnZXRQYXJhbVR5cGUo
bmFtZSwgYWkpO1xuICAgICAgICBlbWl0RXhwcihleHByLmFyZ3NbYWldLCBwYXJhbVR5cGUpO1xu
ICAgICAgfVxuICAgICAgYncuYnl0ZShPUF9DQUxMKTtcbiAgICAgIGJ3LnUzMihmSWR4KTtcbiAg
ICB9XG5cbiAgICBmdW5jdGlvbiBlbWl0V2FzbUJ1aWx0aW4ob3AsIGV4cHIsIGV4cGVjdGVkVHlw
ZSkge1xuICAgICAgY29uc3QgdCA9IGV4cGVjdGVkVHlwZSB8fCAnaTMyJztcbiAgICAgIGlmIChv
cCA9PT0gJ2Rpdl91JykgeyBlbWl0RXhwcihleHByLmFyZ3NbMF0sIHQpOyBlbWl0RXhwcihleHBy
LmFyZ3NbMV0sIHQpOyBidy5ieXRlKHQgPT09ICdpNjQnID8gT1BfSTY0X0RJVl9VIDogT1BfSTMy
X0RJVl9VKTsgcmV0dXJuOyB9XG4gICAgICBpZiAob3AgPT09ICdyZW1fdScpIHsgZW1pdEV4cHIo
ZXhwci5hcmdzWzBdLCB0KTsgZW1pdEV4cHIoZXhwci5hcmdzWzFdLCB0KTsgYncuYnl0ZSh0ID09
PSAnaTY0JyA/IE9QX0k2NF9SRU1fVSA6IE9QX0kzMl9SRU1fVSk7IHJldHVybjsgfVxuICAgICAg
aWYgKG9wID09PSAnc2hyX3UnKSB7IGVtaXRFeHByKGV4cHIuYXJnc1swXSwgdCk7IGVtaXRFeHBy
KGV4cHIuYXJnc1sxXSwgdCk7IGJ3LmJ5dGUodCA9PT0gJ2k2NCcgPyBPUF9JNjRfU0hSX1UgOiBP
UF9JMzJfU0hSX1UpOyByZXR1cm47IH1cbiAgICAgIGlmIChvcCA9PT0gJ2x0X3UnKSB7IGVtaXRF
eHByKGV4cHIuYXJnc1swXSwgdCk7IGVtaXRFeHByKGV4cHIuYXJnc1sxXSwgdCk7IGJ3LmJ5dGUo
dCA9PT0gJ2k2NCcgPyBPUF9JNjRfTFRfVSA6IE9QX0kzMl9MVF9VKTsgcmV0dXJuOyB9XG4gICAg
ICBpZiAob3AgPT09ICdndF91JykgeyBlbWl0RXhwcihleHByLmFyZ3NbMF0sIHQpOyBlbWl0RXhw
cihleHByLmFyZ3NbMV0sIHQpOyBidy5ieXRlKHQgPT09ICdpNjQnID8gT1BfSTY0X0dUX1UgOiBP
UF9JMzJfR1RfVSk7IHJldHVybjsgfVxuICAgICAgaWYgKG9wID09PSAnbGVfdScpIHsgZW1pdEV4
cHIoZXhwci5hcmdzWzBdLCB0KTsgZW1pdEV4cHIoZXhwci5hcmdzWzFdLCB0KTsgYncuYnl0ZSh0
ID09PSAnaTY0JyA/IE9QX0k2NF9MRV9VIDogT1BfSTMyX0xFX1UpOyByZXR1cm47IH1cbiAgICAg
IGlmIChvcCA9PT0gJ2dlX3UnKSB7IGVtaXRFeHByKGV4cHIuYXJnc1swXSwgdCk7IGVtaXRFeHBy
KGV4cHIuYXJnc1sxXSwgdCk7IGJ3LmJ5dGUodCA9PT0gJ2k2NCcgPyBPUF9JNjRfR0VfVSA6IE9Q
X0kzMl9HRV9VKTsgcmV0dXJuOyB9XG4gICAgICBpZiAob3AgPT09ICdyZWludGVycHJldF9mNjQn
KSB7IGVtaXRFeHByKGV4cHIuYXJnc1swXSwgJ2Y2NCcpOyBidy5ieXRlKE9QX0k2NF9SRUlOVEVS
UFJFVF9GNjQpOyByZXR1cm47IH1cbiAgICAgIGlmIChvcCA9PT0gJ3JlaW50ZXJwcmV0X2YzMicp
IHsgZW1pdEV4cHIoZXhwci5hcmdzWzBdLCAnZjMyJyk7IGJ3LmJ5dGUoT1BfSTMyX1JFSU5URVJQ
UkVUX0YzMik7IHJldHVybjsgfVxuICAgICAgaWYgKG9wID09PSAncmVpbnRlcnByZXRfaTY0Jykg
eyBlbWl0RXhwcihleHByLmFyZ3NbMF0sICdpNjQnKTsgYncuYnl0ZShPUF9GNjRfUkVJTlRFUlBS
RVRfSTY0KTsgcmV0dXJuOyB9XG4gICAgICBpZiAob3AgPT09ICdyZWludGVycHJldF9pMzInKSB7
IGVtaXRFeHByKGV4cHIuYXJnc1swXSwgJ2kzMicpOyBidy5ieXRlKE9QX0YzMl9SRUlOVEVSUFJF
VF9JMzIpOyByZXR1cm47IH1cbiAgICAgIGlmIChvcCA9PT0gJ2V4dGVuZDhfcycpIHsgZW1pdEV4
cHIoZXhwci5hcmdzWzBdLCB0KTsgYncuYnl0ZSh0ID09PSAnaTY0JyA/IE9QX0k2NF9FWFRFTkQ4
X1MgOiBPUF9JMzJfRVhURU5EOF9TKTsgcmV0dXJuOyB9XG4gICAgICBpZiAob3AgPT09ICdleHRl
bmQxNl9zJykgeyBlbWl0RXhwcihleHByLmFyZ3NbMF0sIHQpOyBidy5ieXRlKHQgPT09ICdpNjQn
ID8gT1BfSTY0X0VYVEVORDE2X1MgOiBPUF9JMzJfRVhURU5EMTZfUyk7IHJldHVybjsgfVxuICAg
ICAgaWYgKG9wID09PSAndHJ1bmNfc2F0X3MnKSB7XG4gICAgICAgIGNvbnN0IGZyb21UeXBlID0g
aW5mZXJFeHByVHlwZShleHByLmFyZ3NbMF0pO1xuICAgICAgICBlbWl0RXhwcihleHByLmFyZ3Nb
MF0sIGZyb21UeXBlKTtcbiAgICAgICAgYncuYnl0ZShPUF9GQ19QUkVGSVgpO1xuICAgICAgICBp
ZiAodCA9PT0gJ2kzMicgJiYgZnJvbVR5cGUgPT09ICdmMzInKSBidy51MzIoT1BfSTMyX1RSVU5D
X1NBVF9GMzJfUyk7XG4gICAgICAgIGVsc2UgaWYgKHQgPT09ICdpMzInICYmIGZyb21UeXBlID09
PSAnZjY0JykgYncudTMyKE9QX0kzMl9UUlVOQ19TQVRfRjY0X1MpO1xuICAgICAgICBlbHNlIGlm
ICh0ID09PSAnaTY0JyAmJiBmcm9tVHlwZSA9PT0gJ2YzMicpIGJ3LnUzMihPUF9JNjRfVFJVTkNf
U0FUX0YzMl9TKTtcbiAgICAgICAgZWxzZSBpZiAodCA9PT0gJ2k2NCcgJiYgZnJvbVR5cGUgPT09
ICdmNjQnKSBidy51MzIoT1BfSTY0X1RSVU5DX1NBVF9GNjRfUyk7XG4gICAgICAgIHJldHVybjtc
biAgICAgIH1cbiAgICAgIGlmIChvcCA9PT0gJ3RydW5jX3NhdF91Jykge1xuICAgICAgICBjb25z
dCBmcm9tVHlwZSA9IGluZmVyRXhwclR5cGUoZXhwci5hcmdzWzBdKTtcbiAgICAgICAgZW1pdEV4
cHIoZXhwci5hcmdzWzBdLCBmcm9tVHlwZSk7XG4gICAgICAgIGJ3LmJ5dGUoT1BfRkNfUFJFRklY
KTtcbiAgICAgICAgaWYgKHQgPT09ICdpMzInICYmIGZyb21UeXBlID09PSAnZjMyJykgYncudTMy
KE9QX0kzMl9UUlVOQ19TQVRfRjMyX1UpO1xuICAgICAgICBlbHNlIGlmICh0ID09PSAnaTMyJyAm
JiBmcm9tVHlwZSA9PT0gJ2Y2NCcpIGJ3LnUzMihPUF9JMzJfVFJVTkNfU0FUX0Y2NF9VKTtcbiAg
ICAgICAgZWxzZSBpZiAodCA9PT0gJ2k2NCcgJiYgZnJvbVR5cGUgPT09ICdmMzInKSBidy51MzIo
T1BfSTY0X1RSVU5DX1NBVF9GMzJfVSk7XG4gICAgICAgIGVsc2UgaWYgKHQgPT09ICdpNjQnICYm
IGZyb21UeXBlID09PSAnZjY0JykgYncudTMyKE9QX0k2NF9UUlVOQ19TQVRfRjY0X1UpO1xuICAg
ICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gd2Fz
bSBidWlsdGluOiB3YXNtLiR7b3B9YCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZW1pdFZlY3Rv
ckNvbnN0cnVjdG9yKHZlY1R5cGUsIGFyZ3MpIHtcbiAgICAgIGNvbnN0IHNjYWxhciA9IHZlY3Rv
clNjYWxhclR5cGUodmVjVHlwZSk7XG4gICAgICBjb25zdCBsYW5lQ291bnQgPSB2ZWNUeXBlID09
PSAnZjMyeDQnIHx8IHZlY1R5cGUgPT09ICdpMzJ4NCcgPyA0IDogMjtcblxuICAgICAgaWYgKGFy
Z3MubGVuZ3RoICE9PSBsYW5lQ291bnQpIHRocm93IG5ldyBFcnJvcihgJHt2ZWNUeXBlfSBjb25z
dHJ1Y3RvciBleHBlY3RzICR7bGFuZUNvdW50fSBhcmdzLCBnb3QgJHthcmdzLmxlbmd0aH1gKTtc
blxuICAgICAgLy8gQ2hlY2sgaWYgYWxsIGFyZ3MgYXJlIGNvbnN0YW50IChOdW1iZXJMaXQgb3Ig
bmVnYXRpdmUgTnVtYmVyTGl0KVxuICAgICAgY29uc3QgYWxsQ29uc3QgPSBhcmdzLmV2ZXJ5KGEg
PT5cbiAgICAgICAgYS50eXBlID09PSAnTnVtYmVyTGl0JyB8fFxuICAgICAgICAoYS50eXBlID09
PSAnVW5hcnlPcCcgJiYgYS5vcCA9PT0gJy0nICYmIGEub3BlcmFuZC50eXBlID09PSAnTnVtYmVy
TGl0JykpO1xuXG4gICAgICBpZiAoYWxsQ29uc3QpIHtcbiAgICAgICAgLy8gRW1pdCB2MTI4LmNv
bnN0IHdpdGggaW5saW5lIGJ5dGVzXG4gICAgICAgIGVtaXRTaW1kKFNJTURfT1BTWyd2MTI4LmNv
bnN0J10pO1xuICAgICAgICBjb25zdCBhYnVmID0gbmV3IEFycmF5QnVmZmVyKDE2KTtcbiAgICAg
ICAgY29uc3QgdmlldyA9IG5ldyBEYXRhVmlldyhhYnVmKTtcbiAgICAgICAgZm9yIChsZXQgbGkg
PSAwOyBsaSA8IGxhbmVDb3VudDsgbGkrKykge1xuICAgICAgICAgIGNvbnN0IGEgPSBhcmdzW2xp
XTtcbiAgICAgICAgICBjb25zdCByYXcgPSBhLnR5cGUgPT09ICdOdW1iZXJMaXQnID8gYS52YWx1
ZSA6IGEub3BlcmFuZC52YWx1ZTtcbiAgICAgICAgICBjb25zdCB2YWwgPSBhLnR5cGUgPT09ICdV
bmFyeU9wJyA/IC1wYXJzZUZsb2F0KHJhdykgOiBwYXJzZUZsb2F0KHJhdyk7XG4gICAgICAgICAg
aWYgKHNjYWxhciA9PT0gJ2Y2NCcpIHZpZXcuc2V0RmxvYXQ2NChsaSAqIDgsIHZhbCwgdHJ1ZSk7
XG4gICAgICAgICAgZWxzZSBpZiAoc2NhbGFyID09PSAnZjMyJykgdmlldy5zZXRGbG9hdDMyKGxp
ICogNCwgdmFsLCB0cnVlKTtcbiAgICAgICAgICBlbHNlIGlmIChzY2FsYXIgPT09ICdpMzInKSB2
aWV3LnNldEludDMyKGxpICogNCwgdmFsIHwgMCwgdHJ1ZSk7XG4gICAgICAgICAgZWxzZSBpZiAo
c2NhbGFyID09PSAnaTY0Jykge1xuICAgICAgICAgICAgLy8gQmlnSW50NjQgYXMgdHdvIGkzMnMs
IGxpdHRsZS1lbmRpYW5cbiAgICAgICAgICAgIGNvbnN0IGJ2ID0gQmlnSW50KE1hdGgudHJ1bmMo
dmFsKSk7XG4gICAgICAgICAgICB2aWV3LnNldEludDMyKGxpICogOCwgTnVtYmVyKGJ2ICYgMHhm
ZmZmZmZmZm4pLCB0cnVlKTtcbiAgICAgICAgICAgIHZpZXcuc2V0SW50MzIobGkgKiA4ICsgNCwg
TnVtYmVyKChidiA+PiAzMm4pICYgMHhmZmZmZmZmZm4pLCB0cnVlKTtcbiAgICAgICAgICB9XG4g
ICAgICAgIH1cbiAgICAgICAgYncuYnl0ZXMobmV3IFVpbnQ4QXJyYXkoYWJ1ZikpO1xuICAgICAg
fSBlbHNlIHtcbiAgICAgICAgLy8gU3BsYXQgZmlyc3QgYXJnLCB0aGVuIHJlcGxhY2VfbGFuZSBm
b3IgdGhlIHJlc3RcbiAgICAgICAgZW1pdEV4cHIoYXJnc1swXSwgc2NhbGFyKTtcbiAgICAgICAg
ZW1pdFNpbWQoU0lNRF9PUFNbdmVjVHlwZSArICcuc3BsYXQnXSk7XG4gICAgICAgIGZvciAobGV0
IGxpID0gMTsgbGkgPCBsYW5lQ291bnQ7IGxpKyspIHtcbiAgICAgICAgICBlbWl0RXhwcihhcmdz
W2xpXSwgc2NhbGFyKTtcbiAgICAgICAgICBlbWl0U2ltZChTSU1EX09QU1t2ZWNUeXBlICsgJy5y
ZXBsYWNlX2xhbmUnXSk7XG4gICAgICAgICAgYncuYnl0ZShsaSk7XG4gICAgICAgIH1cbiAgICAg
IH1cbiAgICB9XG5cbiAgICAvLyDilIDilIAgU0lNRCBidWlsdGlucyDilIDilIBcbiAgICBmdW5j
dGlvbiBlbWl0U2ltZEJ1aWx0aW4ocHJlZml4LCBtZXRob2QsIGV4cHIsIGV4cGVjdGVkVHlwZSkg
e1xuICAgICAgLy8gZjY0eDIuc3BsYXQoeCksIGkzMng0LnNwbGF0KHgpLCBldGMuXG4gICAgICBp
ZiAobWV0aG9kID09PSAnc3BsYXQnKSB7XG4gICAgICAgIGNvbnN0IHNjYWxhciA9IHZlY3RvclNj
YWxhclR5cGUocHJlZml4KTtcbiAgICAgICAgZW1pdEV4cHIoZXhwci5hcmdzWzBdLCBzY2FsYXIp
O1xuICAgICAgICBlbWl0U2ltZChTSU1EX09QU1twcmVmaXggKyAnLnNwbGF0J10pO1xuICAgICAg
ICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIGY2NHgyLmV4dHJhY3RfbGFuZSh2LCBsYW5l
KVxuICAgICAgaWYgKG1ldGhvZCA9PT0gJ2V4dHJhY3RfbGFuZScpIHtcbiAgICAgICAgZW1pdEV4
cHIoZXhwci5hcmdzWzBdLCBwcmVmaXgpO1xuICAgICAgICBlbWl0U2ltZChTSU1EX09QU1twcmVm
aXggKyAnLmV4dHJhY3RfbGFuZSddKTtcbiAgICAgICAgLy8gbGFuZSBtdXN0IGJlIGEgY29uc3Rh
bnRcbiAgICAgICAgaWYgKGV4cHIuYXJnc1sxXS50eXBlICE9PSAnTnVtYmVyTGl0JykgdGhyb3cg
bmV3IEVycm9yKCdleHRyYWN0X2xhbmUgcmVxdWlyZXMgY29uc3RhbnQgbGFuZSBpbmRleCcpO1xu
ICAgICAgICBidy5ieXRlKHBhcnNlSW50KGV4cHIuYXJnc1sxXS52YWx1ZSwgMTApKTtcbiAgICAg
ICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBmNjR4Mi5yZXBsYWNlX2xhbmUodiwgbGFu
ZSwgeClcbiAgICAgIGlmIChtZXRob2QgPT09ICdyZXBsYWNlX2xhbmUnKSB7XG4gICAgICAgIGNv
bnN0IHNjYWxhciA9IHZlY3RvclNjYWxhclR5cGUocHJlZml4KTtcbiAgICAgICAgZW1pdEV4cHIo
ZXhwci5hcmdzWzBdLCBwcmVmaXgpOyAvLyB2MTI4IHZhbHVlXG4gICAgICAgIGVtaXRFeHByKGV4
cHIuYXJnc1syXSwgc2NhbGFyKTsgLy8gcmVwbGFjZW1lbnQgc2NhbGFyXG4gICAgICAgIGVtaXRT
aW1kKFNJTURfT1BTW3ByZWZpeCArICcucmVwbGFjZV9sYW5lJ10pO1xuICAgICAgICBpZiAoZXhw
ci5hcmdzWzFdLnR5cGUgIT09ICdOdW1iZXJMaXQnKSB0aHJvdyBuZXcgRXJyb3IoJ3JlcGxhY2Vf
bGFuZSByZXF1aXJlcyBjb25zdGFudCBsYW5lIGluZGV4Jyk7XG4gICAgICAgIGJ3LmJ5dGUocGFy
c2VJbnQoZXhwci5hcmdzWzFdLnZhbHVlLCAxMCkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9
XG5cbiAgICAgIC8vIGY2NHgyLmVxLCBmNjR4Mi5uZSwgZjY0eDIubHQsIGY2NHgyLmd0LCBmNjR4
Mi5sZSwgZjY0eDIuZ2VcbiAgICAgIGlmIChbJ2VxJywnbmUnLCdsdCcsJ2d0JywnbGUnLCdnZScs
J2x0X3MnLCdndF9zJywnbGVfcycsJ2dlX3MnXS5pbmNsdWRlcyhtZXRob2QpKSB7XG4gICAgICAg
IGVtaXRFeHByKGV4cHIuYXJnc1swXSwgcHJlZml4KTtcbiAgICAgICAgZW1pdEV4cHIoZXhwci5h
cmdzWzFdLCBwcmVmaXgpO1xuICAgICAgICBjb25zdCBrZXkgPSBwcmVmaXggKyAnLicgKyBtZXRo
b2Q7XG4gICAgICAgIGNvbnN0IG9wID0gU0lNRF9PUFNba2V5XTtcbiAgICAgICAgaWYgKG9wID09
PSB1bmRlZmluZWQpIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBTSU1EIG9wOiAke2tleX1gKTtc
biAgICAgICAgZW1pdFNpbWQob3ApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAg
IC8vIGY2NHgyLm5lZywgZjY0eDIuYWJzLCBmNjR4Mi5zcXJ0ICh1bmFyeSlcbiAgICAgIGlmIChb
J25lZycsJ2FicycsJ3NxcnQnXS5pbmNsdWRlcyhtZXRob2QpKSB7XG4gICAgICAgIGVtaXRFeHBy
KGV4cHIuYXJnc1swXSwgcHJlZml4KTtcbiAgICAgICAgY29uc3Qga2V5ID0gcHJlZml4ICsgJy4n
ICsgbWV0aG9kO1xuICAgICAgICBjb25zdCBvcCA9IFNJTURfT1BTW2tleV07XG4gICAgICAgIGlm
IChvcCA9PT0gdW5kZWZpbmVkKSB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gU0lNRCBvcDogJHtr
ZXl9YCk7XG4gICAgICAgIGVtaXRTaW1kKG9wKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxu
XG4gICAgICAvLyBmNjR4Mi5hZGQsIGY2NHgyLnN1YiwgZjY0eDIubXVsLCBmNjR4Mi5kaXYsIGY2
NHgyLm1pbiwgZjY0eDIubWF4IChiaW5hcnkpXG4gICAgICBpZiAoWydhZGQnLCdzdWInLCdtdWwn
LCdkaXYnLCdtaW4nLCdtYXgnXS5pbmNsdWRlcyhtZXRob2QpKSB7XG4gICAgICAgIGVtaXRFeHBy
KGV4cHIuYXJnc1swXSwgcHJlZml4KTtcbiAgICAgICAgZW1pdEV4cHIoZXhwci5hcmdzWzFdLCBw
cmVmaXgpO1xuICAgICAgICBjb25zdCBrZXkgPSBwcmVmaXggKyAnLicgKyBtZXRob2Q7XG4gICAg
ICAgIGNvbnN0IG9wID0gU0lNRF9PUFNba2V5XTtcbiAgICAgICAgaWYgKG9wID09PSB1bmRlZmlu
ZWQpIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBTSU1EIG9wOiAke2tleX1gKTtcbiAgICAgICAg
ZW1pdFNpbWQob3ApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIGY2NHgy
LnJlbGF4ZWRfbWFkZChhLCBiLCBjKSwgZjY0eDIucmVsYXhlZF9ubWFkZChhLCBiLCBjKSAodGVy
bmFyeTogYSpiK2MgLyAtKGEqYikrYylcbiAgICAgIGlmIChbJ3JlbGF4ZWRfbWFkZCcsJ3JlbGF4
ZWRfbm1hZGQnXS5pbmNsdWRlcyhtZXRob2QpKSB7XG4gICAgICAgIGVtaXRFeHByKGV4cHIuYXJn
c1swXSwgcHJlZml4KTtcbiAgICAgICAgZW1pdEV4cHIoZXhwci5hcmdzWzFdLCBwcmVmaXgpO1xu
ICAgICAgICBlbWl0RXhwcihleHByLmFyZ3NbMl0sIHByZWZpeCk7XG4gICAgICAgIGNvbnN0IGtl
eSA9IHByZWZpeCArICcuJyArIG1ldGhvZDtcbiAgICAgICAgY29uc3Qgb3AgPSBTSU1EX09QU1tr
ZXldO1xuICAgICAgICBpZiAob3AgPT09IHVuZGVmaW5lZCkgdGhyb3cgbmV3IEVycm9yKGBVbmtu
b3duIFNJTUQgb3A6ICR7a2V5fWApO1xuICAgICAgICBlbWl0U2ltZChvcCk7XG4gICAgICAgIHJl
dHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gdjEyOC5hbmQsIHYxMjgub3IsIHYxMjgueG9yIChi
aW5hcnkgYml0d2lzZSlcbiAgICAgIGlmIChwcmVmaXggPT09ICd2MTI4JyAmJiBbJ2FuZCcsJ29y
JywneG9yJ10uaW5jbHVkZXMobWV0aG9kKSkge1xuICAgICAgICAvLyBJbmZlciBvcGVyYW5kIHR5
cGUgZnJvbSBmaXJzdCBhcmdcbiAgICAgICAgY29uc3QgdnQgPSBpbmZlckV4cHJUeXBlKGV4cHIu
YXJnc1swXSk7XG4gICAgICAgIGVtaXRFeHByKGV4cHIuYXJnc1swXSwgdnQpO1xuICAgICAgICBl
bWl0RXhwcihleHByLmFyZ3NbMV0sIHZ0KTtcbiAgICAgICAgZW1pdFNpbWQoU0lNRF9PUFNbJ3Yx
MjguJyArIG1ldGhvZF0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIHYx
Mjgubm90ICh1bmFyeSBiaXR3aXNlKVxuICAgICAgaWYgKHByZWZpeCA9PT0gJ3YxMjgnICYmIG1l
dGhvZCA9PT0gJ25vdCcpIHtcbiAgICAgICAgY29uc3QgdnQgPSBpbmZlckV4cHJUeXBlKGV4cHIu
YXJnc1swXSk7XG4gICAgICAgIGVtaXRFeHByKGV4cHIuYXJnc1swXSwgdnQpO1xuICAgICAgICBl
bWl0U2ltZChTSU1EX09QU1sndjEyOC5ub3QnXSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1c
blxuICAgICAgLy8gdjEyOC5sb2FkKGFyciwgaSkg4oCUIGxvYWQgMTYgYnl0ZXMgZnJvbSBtZW1v
cnkgYXQgYXJyICsgaSAqIDE2XG4gICAgICBpZiAocHJlZml4ID09PSAndjEyOCcgJiYgbWV0aG9k
ID09PSAnbG9hZCcpIHtcbiAgICAgICAgLy8gQ29tcHV0ZSBhZGRyZXNzOiBhcnIgKyBpICogMTZc
biAgICAgICAgZW1pdEV4cHIoZXhwci5hcmdzWzBdLCAnaTMyJyk7IC8vIGJhc2UgcG9pbnRlclxu
ICAgICAgICBlbWl0RXhwcihleHByLmFyZ3NbMV0sICdpMzInKTsgLy8gaW5kZXhcbiAgICAgICAg
YncuYnl0ZShPUF9JMzJfQ09OU1QpOyBidy5zMzIoMTYpO1xuICAgICAgICBidy5ieXRlKE9QX0kz
Ml9NVUwpO1xuICAgICAgICBidy5ieXRlKE9QX0kzMl9BREQpO1xuICAgICAgICBlbWl0U2ltZChT
SU1EX09QU1sndjEyOC5sb2FkJ10pOyBidy51MzIoNCk7IGJ3LnUzMigwKTsgLy8gYWxpZ249MTZc
biAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyB2MTI4LnN0b3JlKGFyciwgaSwg
dikg4oCUIHN0b3JlIDE2IGJ5dGVzIHRvIG1lbW9yeSBhdCBhcnIgKyBpICogMTZcbiAgICAgIGlm
IChwcmVmaXggPT09ICd2MTI4JyAmJiBtZXRob2QgPT09ICdzdG9yZScpIHtcbiAgICAgICAgLy8g
Q29tcHV0ZSBhZGRyZXNzXG4gICAgICAgIGVtaXRFeHByKGV4cHIuYXJnc1swXSwgJ2kzMicpO1xu
ICAgICAgICBlbWl0RXhwcihleHByLmFyZ3NbMV0sICdpMzInKTtcbiAgICAgICAgYncuYnl0ZShP
UF9JMzJfQ09OU1QpOyBidy5zMzIoMTYpO1xuICAgICAgICBidy5ieXRlKE9QX0kzMl9NVUwpO1xu
ICAgICAgICBidy5ieXRlKE9QX0kzMl9BREQpO1xuICAgICAgICAvLyBFbWl0IHZhbHVlXG4gICAg
ICAgIGNvbnN0IHZ0ID0gaW5mZXJFeHByVHlwZShleHByLmFyZ3NbMl0pO1xuICAgICAgICBlbWl0
RXhwcihleHByLmFyZ3NbMl0sIHZ0KTtcbiAgICAgICAgZW1pdFNpbWQoU0lNRF9PUFNbJ3YxMjgu
c3RvcmUnXSk7IGJ3LnUzMig0KTsgYncudTMyKDApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9
XG5cbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBTSU1EIGJ1aWx0aW46ICR7cHJlZml4
fS4ke21ldGhvZH1gKTtcbiAgICB9XG5cbiAgICAvLyDilIDilIAgVHlwZSBjb252ZXJzaW9uIOKU
gOKUgFxuICAgIGZ1bmN0aW9uIGVtaXRDb252ZXJzaW9uKGZyb20sIHRvKSB7XG4gICAgICBpZiAo
ZnJvbSA9PT0gdG8pIHJldHVybjtcbiAgICAgIGlmIChmcm9tID09PSAnaTMyJyAmJiB0byA9PT0g
J2Y2NCcpIGJ3LmJ5dGUoT1BfRjY0X0NPTlZFUlRfSTMyX1MpO1xuICAgICAgZWxzZSBpZiAoZnJv
bSA9PT0gJ2kzMicgJiYgdG8gPT09ICdmMzInKSBidy5ieXRlKE9QX0YzMl9DT05WRVJUX0kzMl9T
KTtcbiAgICAgIGVsc2UgaWYgKGZyb20gPT09ICdpMzInICYmIHRvID09PSAnaTY0JykgYncuYnl0
ZShPUF9JNjRfRVhURU5EX0kzMl9TKTtcbiAgICAgIGVsc2UgaWYgKGZyb20gPT09ICdpNjQnICYm
IHRvID09PSAnaTMyJykgYncuYnl0ZShPUF9JMzJfV1JBUF9JNjQpO1xuICAgICAgZWxzZSBpZiAo
ZnJvbSA9PT0gJ2k2NCcgJiYgdG8gPT09ICdmNjQnKSBidy5ieXRlKE9QX0Y2NF9DT05WRVJUX0k2
NF9TKTtcbiAgICAgIGVsc2UgaWYgKGZyb20gPT09ICdpNjQnICYmIHRvID09PSAnZjMyJykgYncu
Ynl0ZShPUF9GMzJfQ09OVkVSVF9JNjRfUyk7XG4gICAgICBlbHNlIGlmIChmcm9tID09PSAnZjY0
JyAmJiB0byA9PT0gJ2kzMicpIGJ3LmJ5dGUoT1BfSTMyX1RSVU5DX0Y2NF9TKTtcbiAgICAgIGVs
c2UgaWYgKGZyb20gPT09ICdmNjQnICYmIHRvID09PSAnaTY0JykgYncuYnl0ZShPUF9JNjRfVFJV
TkNfRjY0X1MpO1xuICAgICAgZWxzZSBpZiAoZnJvbSA9PT0gJ2Y2NCcgJiYgdG8gPT09ICdmMzIn
KSBidy5ieXRlKE9QX0YzMl9ERU1PVEVfRjY0KTtcbiAgICAgIGVsc2UgaWYgKGZyb20gPT09ICdm
MzInICYmIHRvID09PSAnZjY0JykgYncuYnl0ZShPUF9GNjRfUFJPTU9URV9GMzIpO1xuICAgICAg
ZWxzZSBpZiAoZnJvbSA9PT0gJ2YzMicgJiYgdG8gPT09ICdpMzInKSBidy5ieXRlKE9QX0kzMl9U
UlVOQ19GMzJfUyk7XG4gICAgICBlbHNlIGlmIChmcm9tID09PSAnZjMyJyAmJiB0byA9PT0gJ2k2
NCcpIGJ3LmJ5dGUoT1BfSTY0X1RSVU5DX0YzMl9TKTtcbiAgICAgIGVsc2UgdGhyb3cgbmV3IEVy
cm9yKGBDYW5ub3QgY29udmVydCAke2Zyb219IHRvICR7dG99YCk7XG4gICAgfVxuXG4gICAgLy8g
4pSA4pSAIE1lbW9yeSBhY2Nlc3Mg4pSA4pSAIGFycmF5IGFkZHJlc3Npbmc6IGJhc2UgKyBpbmRl
eCAqIHNpemVvZihlbGVtVHlwZSlcbiAgICBmdW5jdGlvbiBlbWl0QXJyYXlBZGRyKG5hbWUsIGlu
ZGljZXMsIGluZm8sIGVsZW1UeXBlKSB7XG4gICAgICAvLyBCYXNlIHBvaW50ZXJcbiAgICAgIGJ3
LmJ5dGUoT1BfTE9DQUxfR0VUKTtcbiAgICAgIGJ3LnUzMihpbmZvLmlkeCk7XG5cbiAgICAgIGNv
bnN0IHN6ID0gdHlwZVNpemUoZWxlbVR5cGUpO1xuXG4gICAgICBpZiAoaW5kaWNlcy5sZW5ndGgg
PT09IDEpIHtcbiAgICAgICAgLy8gMUQ6IGJhc2UgKyBpICogc2l6ZW9mXG4gICAgICAgIGVtaXRF
eHByKGluZGljZXNbMF0sICdpMzInKTtcbiAgICAgICAgYncuYnl0ZShPUF9JMzJfQ09OU1QpOyBi
dy5zMzIoc3opO1xuICAgICAgICBidy5ieXRlKE9QX0kzMl9NVUwpO1xuICAgICAgICBidy5ieXRl
KE9QX0kzMl9BREQpO1xuICAgICAgfSBlbHNlIGlmIChpbmRpY2VzLmxlbmd0aCA9PT0gMyAmJiAh
aW5mby5hcnJheURpbXMpIHtcbiAgICAgICAgLy8gMkQgd2l0aCBleHBsaWNpdCBzdHJpZGU6IGFb
aSwgc3RyaWRlLCBqXSDihpIgYmFzZSArIChpKnN0cmlkZSArIGopICogc2l6ZW9mXG4gICAgICAg
IGVtaXRFeHByKGluZGljZXNbMF0sICdpMzInKTtcbiAgICAgICAgZW1pdEV4cHIoaW5kaWNlc1sx
XSwgJ2kzMicpO1xuICAgICAgICBidy5ieXRlKE9QX0kzMl9NVUwpO1xuICAgICAgICBlbWl0RXhw
cihpbmRpY2VzWzJdLCAnaTMyJyk7XG4gICAgICAgIGJ3LmJ5dGUoT1BfSTMyX0FERCk7XG4gICAg
ICAgIGJ3LmJ5dGUoT1BfSTMyX0NPTlNUKTsgYncuczMyKHN6KTtcbiAgICAgICAgYncuYnl0ZShP
UF9JMzJfTVVMKTtcbiAgICAgICAgYncuYnl0ZShPUF9JMzJfQUREKTtcbiAgICAgIH0gZWxzZSBp
ZiAoaW5kaWNlcy5sZW5ndGggPT09IDIgJiYgaW5mby5hcnJheURpbXMgJiYgaW5mby5hcnJheURp
bXMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIC8vIDJEIHdpdGggZGVjbGFyZWQgZGltczogYVtp
LCBqXSDihpIgYmFzZSArIChpKmRpbTEgKyBqKSAqIHNpemVvZlxuICAgICAgICBlbWl0RXhwcihp
bmRpY2VzWzBdLCAnaTMyJyk7XG4gICAgICAgIGVtaXRFeHByKGluZm8uYXJyYXlEaW1zWzFdLCAn
aTMyJyk7XG4gICAgICAgIGJ3LmJ5dGUoT1BfSTMyX01VTCk7XG4gICAgICAgIGVtaXRFeHByKGlu
ZGljZXNbMV0sICdpMzInKTtcbiAgICAgICAgYncuYnl0ZShPUF9JMzJfQUREKTtcbiAgICAgICAg
YncuYnl0ZShPUF9JMzJfQ09OU1QpOyBidy5zMzIoc3opO1xuICAgICAgICBidy5ieXRlKE9QX0kz
Ml9NVUwpO1xuICAgICAgICBidy5ieXRlKE9QX0kzMl9BREQpO1xuICAgICAgfSBlbHNlIHtcbiAg
ICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBhcnJheSBpbmRleCBwYXR0ZXJuIGZv
ciAke25hbWV9YCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZW1pdExvYWQodCkg
e1xuICAgICAgaWYgKHQgPT09ICdpMzInKSB7IGJ3LmJ5dGUoT1BfSTMyX0xPQUQpOyBidy51MzIo
Mik7IGJ3LnUzMigwKTsgfSAvLyBhbGlnbj00XG4gICAgICBlbHNlIGlmICh0ID09PSAnaTY0Jykg
eyBidy5ieXRlKE9QX0k2NF9MT0FEKTsgYncudTMyKDMpOyBidy51MzIoMCk7IH1cbiAgICAgIGVs
c2UgaWYgKHQgPT09ICdmMzInKSB7IGJ3LmJ5dGUoT1BfRjMyX0xPQUQpOyBidy51MzIoMik7IGJ3
LnUzMigwKTsgfVxuICAgICAgZWxzZSBpZiAodCA9PT0gJ2Y2NCcpIHsgYncuYnl0ZShPUF9GNjRf
TE9BRCk7IGJ3LnUzMigzKTsgYncudTMyKDApOyB9XG4gICAgICBlbHNlIGlmIChpc1ZlY3Rvcih0
KSkgeyBlbWl0U2ltZChTSU1EX09QU1sndjEyOC5sb2FkJ10pOyBidy51MzIoNCk7IGJ3LnUzMigw
KTsgfSAvLyBhbGlnbj0xNlxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVtaXRTdG9yZSh0KSB7XG4g
ICAgICBpZiAodCA9PT0gJ2kzMicpIHsgYncuYnl0ZShPUF9JMzJfU1RPUkUpOyBidy51MzIoMik7
IGJ3LnUzMigwKTsgfVxuICAgICAgZWxzZSBpZiAodCA9PT0gJ2k2NCcpIHsgYncuYnl0ZShPUF9J
NjRfU1RPUkUpOyBidy51MzIoMyk7IGJ3LnUzMigwKTsgfVxuICAgICAgZWxzZSBpZiAodCA9PT0g
J2YzMicpIHsgYncuYnl0ZShPUF9GMzJfU1RPUkUpOyBidy51MzIoMik7IGJ3LnUzMigwKTsgfVxu
ICAgICAgZWxzZSBpZiAodCA9PT0gJ2Y2NCcpIHsgYncuYnl0ZShPUF9GNjRfU1RPUkUpOyBidy51
MzIoMyk7IGJ3LnUzMigwKTsgfVxuICAgICAgZWxzZSBpZiAoaXNWZWN0b3IodCkpIHsgZW1pdFNp
bWQoU0lNRF9PUFNbJ3YxMjguc3RvcmUnXSk7IGJ3LnUzMig0KTsgYncudTMyKDApOyB9IC8vIGFs
aWduPTE2XG4gICAgfVxuXG4gICAgLy8g4pSA4pSAIENvbXBhcmlzb24gKyBhcml0aG1ldGljIGhl
bHBlcnMg4pSA4pSAXG4gICAgZnVuY3Rpb24gZW1pdENtcChvcCwgdCkge1xuICAgICAgaWYgKHQg
PT09ICdmNjQnKSB7XG4gICAgICAgIGlmIChvcCA9PT0gJz09JykgYncuYnl0ZShPUF9GNjRfRVEp
O1xuICAgICAgICBlbHNlIGlmIChvcCA9PT0gJy89JykgYncuYnl0ZShPUF9GNjRfTkUpO1xuICAg
ICAgICBlbHNlIGlmIChvcCA9PT0gJzwnKSBidy5ieXRlKE9QX0Y2NF9MVCk7XG4gICAgICAgIGVs
c2UgaWYgKG9wID09PSAnPicpIGJ3LmJ5dGUoT1BfRjY0X0dUKTtcbiAgICAgICAgZWxzZSBpZiAo
b3AgPT09ICc8PScpIGJ3LmJ5dGUoT1BfRjY0X0xFKTtcbiAgICAgICAgZWxzZSBpZiAob3AgPT09
ICc+PScpIGJ3LmJ5dGUoT1BfRjY0X0dFKTtcbiAgICAgIH0gZWxzZSBpZiAodCA9PT0gJ2YzMicp
IHtcbiAgICAgICAgaWYgKG9wID09PSAnPT0nKSBidy5ieXRlKE9QX0YzMl9FUSk7XG4gICAgICAg
IGVsc2UgaWYgKG9wID09PSAnLz0nKSBidy5ieXRlKE9QX0YzMl9ORSk7XG4gICAgICAgIGVsc2Ug
aWYgKG9wID09PSAnPCcpIGJ3LmJ5dGUoT1BfRjMyX0xUKTtcbiAgICAgICAgZWxzZSBpZiAob3Ag
PT09ICc+JykgYncuYnl0ZShPUF9GMzJfR1QpO1xuICAgICAgICBlbHNlIGlmIChvcCA9PT0gJzw9
JykgYncuYnl0ZShPUF9GMzJfTEUpO1xuICAgICAgICBlbHNlIGlmIChvcCA9PT0gJz49JykgYncu
Ynl0ZShPUF9GMzJfR0UpO1xuICAgICAgfSBlbHNlIGlmICh0ID09PSAnaTMyJykge1xuICAgICAg
ICBpZiAob3AgPT09ICc9PScpIGJ3LmJ5dGUoT1BfSTMyX0VRKTtcbiAgICAgICAgZWxzZSBpZiAo
b3AgPT09ICcvPScpIGJ3LmJ5dGUoT1BfSTMyX05FKTtcbiAgICAgICAgZWxzZSBpZiAob3AgPT09
ICc8JykgYncuYnl0ZShPUF9JMzJfTFRfUyk7XG4gICAgICAgIGVsc2UgaWYgKG9wID09PSAnPicp
IGJ3LmJ5dGUoT1BfSTMyX0dUX1MpO1xuICAgICAgICBlbHNlIGlmIChvcCA9PT0gJzw9JykgYncu
Ynl0ZShPUF9JMzJfTEVfUyk7XG4gICAgICAgIGVsc2UgaWYgKG9wID09PSAnPj0nKSBidy5ieXRl
KE9QX0kzMl9HRV9TKTtcbiAgICAgIH0gZWxzZSBpZiAodCA9PT0gJ2k2NCcpIHtcbiAgICAgICAg
aWYgKG9wID09PSAnPT0nKSBidy5ieXRlKE9QX0k2NF9FUSk7XG4gICAgICAgIGVsc2UgaWYgKG9w
ID09PSAnLz0nKSBidy5ieXRlKE9QX0k2NF9ORSk7XG4gICAgICAgIGVsc2UgaWYgKG9wID09PSAn
PCcpIGJ3LmJ5dGUoT1BfSTY0X0xUX1MpO1xuICAgICAgICBlbHNlIGlmIChvcCA9PT0gJz4nKSBi
dy5ieXRlKE9QX0k2NF9HVF9TKTtcbiAgICAgICAgZWxzZSBpZiAob3AgPT09ICc8PScpIGJ3LmJ5
dGUoT1BfSTY0X0xFX1MpO1xuICAgICAgICBlbHNlIGlmIChvcCA9PT0gJz49JykgYncuYnl0ZShP
UF9JNjRfR0VfUyk7XG4gICAgICB9IGVsc2UgaWYgKGlzVmVjdG9yKHQpKSB7XG4gICAgICAgIC8v
IFZlY3RvciBjb21wYXJpc29ucyDigJQgbWFwIGF0cmEgb3BzIHRvIFNJTUQgb3Bjb2RlIGtleXNc
biAgICAgICAgY29uc3QgaXNJbnRWZWMgPSAodCA9PT0gJ2kzMng0JyB8fCB0ID09PSAnaTY0eDIn
KTtcbiAgICAgICAgY29uc3Qgc3VmZml4ID0gaXNJbnRWZWMgPyAnX3MnIDogJyc7XG4gICAgICAg
IGxldCBrZXk7XG4gICAgICAgIGlmIChvcCA9PT0gJz09Jykga2V5ID0gdCArICcuZXEnO1xuICAg
ICAgICBlbHNlIGlmIChvcCA9PT0gJy89Jykga2V5ID0gdCArICcubmUnO1xuICAgICAgICBlbHNl
IGlmIChvcCA9PT0gJzwnKSBrZXkgPSB0ICsgKGlzSW50VmVjID8gJy5sdF9zJyA6ICcubHQnKTtc
biAgICAgICAgZWxzZSBpZiAob3AgPT09ICc+Jykga2V5ID0gdCArIChpc0ludFZlYyA/ICcuZ3Rf
cycgOiAnLmd0Jyk7XG4gICAgICAgIGVsc2UgaWYgKG9wID09PSAnPD0nKSBrZXkgPSB0ICsgKGlz
SW50VmVjID8gJy5sZV9zJyA6ICcubGUnKTtcbiAgICAgICAgZWxzZSBpZiAob3AgPT09ICc+PScp
IGtleSA9IHQgKyAoaXNJbnRWZWMgPyAnLmdlX3MnIDogJy5nZScpO1xuICAgICAgICBjb25zdCBv
cGNvZGUgPSBTSU1EX09QU1trZXldO1xuICAgICAgICBpZiAob3Bjb2RlID09PSB1bmRlZmluZWQp
IHRocm93IG5ldyBFcnJvcihgQ29tcGFyaXNvbiAke29wfSBub3Qgc3VwcG9ydGVkIGZvciAke3R9
YCk7XG4gICAgICAgIGVtaXRTaW1kKG9wY29kZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVu
Y3Rpb24gZW1pdEFkZCh0KSB7XG4gICAgICBpZiAodCA9PT0gJ2Y2NCcpIGJ3LmJ5dGUoT1BfRjY0
X0FERCk7XG4gICAgICBlbHNlIGlmICh0ID09PSAnZjMyJykgYncuYnl0ZShPUF9GMzJfQUREKTtc
biAgICAgIGVsc2UgaWYgKHQgPT09ICdpMzInKSBidy5ieXRlKE9QX0kzMl9BREQpO1xuICAgICAg
ZWxzZSBpZiAodCA9PT0gJ2k2NCcpIGJ3LmJ5dGUoT1BfSTY0X0FERCk7XG4gICAgICBlbHNlIGlm
IChpc1ZlY3Rvcih0KSkgZW1pdFNpbWQoU0lNRF9PUFNbdCArICcuYWRkJ10pO1xuICAgIH1cblxu
ICAgIGZ1bmN0aW9uIGVtaXRTdWIodCkge1xuICAgICAgaWYgKHQgPT09ICdmNjQnKSBidy5ieXRl
KE9QX0Y2NF9TVUIpO1xuICAgICAgZWxzZSBpZiAodCA9PT0gJ2YzMicpIGJ3LmJ5dGUoT1BfRjMy
X1NVQik7XG4gICAgICBlbHNlIGlmICh0ID09PSAnaTMyJykgYncuYnl0ZShPUF9JMzJfU1VCKTtc
biAgICAgIGVsc2UgaWYgKHQgPT09ICdpNjQnKSBidy5ieXRlKE9QX0k2NF9TVUIpO1xuICAgICAg
ZWxzZSBpZiAoaXNWZWN0b3IodCkpIGVtaXRTaW1kKFNJTURfT1BTW3QgKyAnLnN1YiddKTtcbiAg
ICB9XG5cbiAgICBmdW5jdGlvbiBlbWl0TXVsKHQpIHtcbiAgICAgIGlmICh0ID09PSAnZjY0Jykg
YncuYnl0ZShPUF9GNjRfTVVMKTtcbiAgICAgIGVsc2UgaWYgKHQgPT09ICdmMzInKSBidy5ieXRl
KE9QX0YzMl9NVUwpO1xuICAgICAgZWxzZSBpZiAodCA9PT0gJ2kzMicpIGJ3LmJ5dGUoT1BfSTMy
X01VTCk7XG4gICAgICBlbHNlIGlmICh0ID09PSAnaTY0JykgYncuYnl0ZShPUF9JNjRfTVVMKTtc
biAgICAgIGVsc2UgaWYgKGlzVmVjdG9yKHQpKSBlbWl0U2ltZChTSU1EX09QU1t0ICsgJy5tdWwn
XSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZW1pdERpdih0KSB7XG4gICAgICBpZiAodCA9PT0g
J2Y2NCcpIGJ3LmJ5dGUoT1BfRjY0X0RJVik7XG4gICAgICBlbHNlIGlmICh0ID09PSAnZjMyJykg
YncuYnl0ZShPUF9GMzJfRElWKTtcbiAgICAgIGVsc2UgaWYgKHQgPT09ICdpMzInKSBidy5ieXRl
KE9QX0kzMl9ESVZfUyk7XG4gICAgICBlbHNlIGlmICh0ID09PSAnaTY0JykgYncuYnl0ZShPUF9J
NjRfRElWX1MpO1xuICAgICAgZWxzZSBpZiAoaXNWZWN0b3IodCkpIHtcbiAgICAgICAgY29uc3Qg
b3AgPSBTSU1EX09QU1t0ICsgJy5kaXYnXTtcbiAgICAgICAgaWYgKCFvcCkgdGhyb3cgbmV3IEVy
cm9yKCdEaXZpc2lvbiBub3Qgc3VwcG9ydGVkIGZvciAnICsgdCk7XG4gICAgICAgIGVtaXRTaW1k
KG9wKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyDilIDilIAgRW1pdCBmdW5jdGlvbiBib2R5
IHN0YXRlbWVudHMg4pSA4pSAXG4gICAgZW1pdFN0bXRzKGZuLmJvZHkpO1xuXG4gICAgLy8g4pSA
4pSAIEVuZCBvZiBmdW5jdGlvbiBib2R5OiByZXR1cm4gdmFsdWUg4pSA4pSAXG4gICAgaWYgKGlz
RnVuYykge1xuICAgICAgYncuYnl0ZShPUF9MT0NBTF9HRVQpO1xuICAgICAgYncudTMyKGxvY2Fs
TWFwWyckX3JldHVybiddLmlkeCk7XG4gICAgfVxuICAgIGJ3LmJ5dGUoT1BfRU5EKTtcbiAgfVxu
fVxuXG4vLyAtLSBhdHJhLmpzIC0tXG5cbi8vIFB1YmxpYyBBUEkg4oCUIHRhZ2dlZCB0ZW1wbGF0
ZSwgLmNvbXBpbGUsIC5wYXJzZSwgLmR1bXAsIC5ydW4sIHNlbGYtcmVnaXN0cmF0aW9uXG4vL1xu
Ly8gUGlwZWxpbmU6IHNvdXJjZSDihpIgbGV4IOKGkiBwYXJzZSDihpIgY29kZWdlbiDihpIgYnl0
ZXMg4oaSIFdlYkFzc2VtYmx5Lk1vZHVsZSDihpIgZXhwb3J0c1xuXG5cblxuXG5cbmZ1bmN0aW9u
IGNvbXBpbGVTb3VyY2Uoc291cmNlLCBpbnRlcnBWYWx1ZXMsIHVzZXJJbXBvcnRzKSB7XG4gIGNv
bnN0IHRva2VucyA9IGxleChzb3VyY2UpO1xuICBjb25zdCBhc3QgPSBwYXJzZSh0b2tlbnMpO1xu
ICByZXR1cm4gY29kZWdlbihhc3QsIGludGVycFZhbHVlcywgdXNlckltcG9ydHMpO1xufVxuXG5m
dW5jdGlvbiBpbnN0YW50aWF0ZShieXRlcywgdXNlckltcG9ydHMsIGludGVycFZhbHVlcykge1xu
ICBjb25zdCBpbXBvcnRPYmogPSB7XG4gICAgbWF0aDogeyBzaW46IE1hdGguc2luLCBjb3M6IE1h
dGguY29zLCBsbjogTWF0aC5sb2csIGV4cDogTWF0aC5leHAsIHBvdzogTWF0aC5wb3csIGF0YW4y
OiBNYXRoLmF0YW4yIH0sXG4gICAgaG9zdDoge30sXG4gIH07XG4gIGlmICh1c2VySW1wb3J0cykg
e1xuICAgIGNvbnN0IGZsYXQgPSBmbGF0dGVuSW1wb3J0cyh1c2VySW1wb3J0cyk7XG4gICAgZm9y
IChjb25zdCBbaywgdl0gb2YgT2JqZWN0LmVudHJpZXMoZmxhdCkpIGltcG9ydE9iai5ob3N0W2td
ID0gdjtcbiAgfVxuXG4gIC8vIEludGVycG9sYXRlZCBpbXBvcnRzXG4gIGlmIChpbnRlcnBWYWx1
ZXMpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGludGVycFZhbHVlcy5sZW5ndGg7IGkrKykg
e1xuICAgICAgY29uc3QgdiA9IGludGVycFZhbHVlc1tpXTtcbiAgICAgIGlmICh0eXBlb2YgdiA9
PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBpbXBvcnRPYmouaG9zdFsnX19JTlRFUlBfJyArIGkg
KyAnX18nXSA9IHY7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gTWVtb3J5XG4gIGlmICh1
c2VySW1wb3J0cyAmJiB1c2VySW1wb3J0cy5fX21lbW9yeSkge1xuICAgIGlmICghaW1wb3J0T2Jq
LmVudikgaW1wb3J0T2JqLmVudiA9IHt9O1xuICAgIGltcG9ydE9iai5lbnYubWVtb3J5ID0gdXNl
ckltcG9ydHMuX19tZW1vcnk7XG4gIH1cblxuICBjb25zdCBtb2QgPSBuZXcgV2ViQXNzZW1ibHku
TW9kdWxlKGJ5dGVzKTtcbiAgY29uc3QgaW5zdGFuY2UgPSBuZXcgV2ViQXNzZW1ibHkuSW5zdGFu
Y2UobW9kLCBpbXBvcnRPYmopO1xuICByZXR1cm4gaW5zdGFuY2U7XG59XG5cbmZ1bmN0aW9uIHdy
YXBFeHBvcnRzKGluc3RhbmNlLCB0YWJsZSkge1xuICBjb25zdCBleHBvcnRzID0gT2JqZWN0LmNy
ZWF0ZShpbnN0YW5jZS5leHBvcnRzKTtcbiAgaWYgKHRhYmxlKSBleHBvcnRzLl9fdGFibGUgPSB0
YWJsZTtcbiAgLy8gTmVzdCBkb3R0ZWQgZXhwb3J0IG5hbWVzOiBcInBoeXNpY3MuZ3Jhdml0eVwi
IOKGkiBleHBvcnRzLnBoeXNpY3MuZ3Jhdml0eVxuICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qu
a2V5cyhpbnN0YW5jZS5leHBvcnRzKSkge1xuICAgIGlmIChrZXkuaW5jbHVkZXMoJy4nKSkge1xu
ICAgICAgY29uc3QgcGFydHMgPSBrZXkuc3BsaXQoJy4nKTtcbiAgICAgIGxldCBvYmogPSBleHBv
cnRzO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGggLSAxOyBpKyspIHtc
biAgICAgICAgaWYgKCFvYmpbcGFydHNbaV1dIHx8IHR5cGVvZiBvYmpbcGFydHNbaV1dICE9PSAn
b2JqZWN0Jykgb2JqW3BhcnRzW2ldXSA9IHt9O1xuICAgICAgICBvYmogPSBvYmpbcGFydHNbaV1d
O1xuICAgICAgfVxuICAgICAgb2JqW3BhcnRzW3BhcnRzLmxlbmd0aCAtIDFdXSA9IGluc3RhbmNl
LmV4cG9ydHNba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGV4cG9ydHM7XG59XG5cbmZ1bmN0
aW9uIG5vcm1hbGl6ZU1lbW9yeUltcG9ydCh1c2VySW1wb3J0cykge1xuICBpZiAodXNlckltcG9y
dHMgJiYgdXNlckltcG9ydHMubWVtb3J5ICYmICF1c2VySW1wb3J0cy5fX21lbW9yeSkge1xuICAg
IHJldHVybiBPYmplY3QuYXNzaWduKHt9LCB1c2VySW1wb3J0cywgeyBfX21lbW9yeTogdXNlcklt
cG9ydHMubWVtb3J5IH0pO1xuICB9XG4gIHJldHVybiB1c2VySW1wb3J0cztcbn1cblxuZnVuY3Rp
b24gY29tcGlsZUFuZEluc3RhbnRpYXRlKHN0cmluZ3MsIHZhbHVlcywgdXNlckltcG9ydHMpIHtc
biAgdXNlckltcG9ydHMgPSBub3JtYWxpemVNZW1vcnlJbXBvcnQodXNlckltcG9ydHMpO1xuICAv
LyBKb2luIHRlbXBsYXRlIHN0cmluZ3Mgd2l0aCBpbnRlcnBvbGF0aW9uIG1hcmtlcnNcbiAgbGV0
IHNvdXJjZSA9IHN0cmluZ3NbMF07XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0
aDsgaSsrKSB7XG4gICAgLy8gTnVtYmVycyBhbmQgc3RyaW5ncyBpbmxpbmUgZGlyZWN0bHkgaW50
byBzb3VyY2UgdGV4dC5cbiAgICAvLyBTdHJpbmdzIGFjdCBhcyBzb3VyY2UgaW5jbHVzaW9uIChs
aWtlICNpbmNsdWRlKS5cbiAgICAvLyBGdW5jdGlvbnMgYmVjb21lIF9fSU5URVJQX05fXyBtYXJr
ZXJzLCByZXNvbHZlZCBhcyBob3N0IGltcG9ydHMgYnkgY29kZWdlbi5cbiAgICBpZiAodHlwZW9m
IHZhbHVlc1tpXSA9PT0gJ251bWJlcicpIHtcbiAgICAgIHNvdXJjZSArPSBTdHJpbmcodmFsdWVz
W2ldKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZXNbaV0gPT09ICdzdHJpbmcnKSB7XG4g
ICAgICBzb3VyY2UgKz0gdmFsdWVzW2ldO1xuICAgIH0gZWxzZSB7XG4gICAgICBzb3VyY2UgKz0g
J19fSU5URVJQXycgKyBpICsgJ19fJztcbiAgICB9XG4gICAgc291cmNlICs9IHN0cmluZ3NbaSAr
IDFdO1xuICB9XG5cbiAgY29uc3QgeyBieXRlcywgdGFibGUgfSA9IGNvbXBpbGVTb3VyY2Uoc291
cmNlLCB2YWx1ZXMsIHVzZXJJbXBvcnRzKTtcbiAgY29uc3QgaW5zdGFuY2UgPSBpbnN0YW50aWF0
ZShieXRlcywgdXNlckltcG9ydHMsIHZhbHVlcyk7XG4gIHJldHVybiB3cmFwRXhwb3J0cyhpbnN0
YW5jZSwgdGFibGUpO1xufVxuXG5mdW5jdGlvbiBhdHJhKHN0cmluZ3NPck9wdHMsIC4uLnZhbHVl
cykge1xuICAvLyBDdXJyaWVkIGZvcm0gZGV0ZWN0aW9uOiBhdHJhKHtpbXBvcnRzfSlgLi4uYCB2
cyBhdHJhYC4uLmBcbiAgLy8gVGFnZ2VkIHRlbXBsYXRlcyBwYXNzIGEgc3RyaW5ncyBhcnJheSB3
aXRoIGEgLnJhdyBwcm9wZXJ0eTsgYSBwbGFpbiBvYmplY3Qgd29uJ3QgaGF2ZSBpdC5cbiAgaWYg
KHN0cmluZ3NPck9wdHMgJiYgIUFycmF5LmlzQXJyYXkoc3RyaW5nc09yT3B0cykgJiYgdHlwZW9m
IHN0cmluZ3NPck9wdHMgPT09ICdvYmplY3QnICYmICFzdHJpbmdzT3JPcHRzLnJhdykge1xuICAg
IGNvbnN0IG9wdHMgPSBzdHJpbmdzT3JPcHRzO1xuICAgIHJldHVybiBmdW5jdGlvbihzdHJpbmdz
LCAuLi52YWxzKSB7XG4gICAgICByZXR1cm4gY29tcGlsZUFuZEluc3RhbnRpYXRlKHN0cmluZ3Ms
IHZhbHMsIG9wdHMpO1xuICAgIH07XG4gIH1cbiAgLy8gRGlyZWN0IGZvcm06IGF0cmFgLi4uYFxu
ICByZXR1cm4gY29tcGlsZUFuZEluc3RhbnRpYXRlKHN0cmluZ3NPck9wdHMsIHZhbHVlcywgbnVs
bCk7XG59XG5cbi8vIERpcmVjdCBjb21waWxlciBhY2Nlc3NcbmF0cmEuY29tcGlsZSA9IGZ1bmN0
aW9uKHNvdXJjZSwgdXNlckltcG9ydHMpIHtcbiAgcmV0dXJuIGNvbXBpbGVTb3VyY2Uoc291cmNl
LCBudWxsLCB1c2VySW1wb3J0cyB8fCBudWxsKS5ieXRlcztcbn07XG5cbmF0cmEucGFyc2UgPSBm
dW5jdGlvbihzb3VyY2UpIHtcbiAgY29uc3QgdG9rZW5zID0gbGV4KHNvdXJjZSk7XG4gIHJldHVy
biBwYXJzZSh0b2tlbnMpO1xufTtcblxuYXRyYS5kdW1wID0gZnVuY3Rpb24oc291cmNlKSB7XG4g
IGNvbnN0IHsgYnl0ZXMgfSA9IGNvbXBpbGVTb3VyY2Uoc291cmNlLCBudWxsLCBudWxsKTtcbiAg
cmV0dXJuIEFycmF5LmZyb20oYnl0ZXMpLm1hcChiID0+IGIudG9TdHJpbmcoMTYpLnBhZFN0YXJ0
KDIsICcwJykpLmpvaW4oJyAnKTtcbn07XG5cbmF0cmEucnVuID0gZnVuY3Rpb24oc291cmNlLCB1
c2VySW1wb3J0cykge1xuICB1c2VySW1wb3J0cyA9IG5vcm1hbGl6ZU1lbW9yeUltcG9ydCh1c2Vy
SW1wb3J0cyk7XG4gIGNvbnN0IHsgYnl0ZXMsIHRhYmxlIH0gPSBjb21waWxlU291cmNlKHNvdXJj
ZSwgbnVsbCwgdXNlckltcG9ydHMpO1xuICBjb25zdCBpbnN0YW5jZSA9IGluc3RhbnRpYXRlKGJ5
dGVzLCB1c2VySW1wb3J0cywgbnVsbCk7XG4gIHJldHVybiB3cmFwRXhwb3J0cyhpbnN0YW5jZSwg
dGFibGUpO1xufTtcblxuLy8g4pSA4pSAIFNlbGYtcmVnaXN0cmF0aW9uIOKUgOKUgFxuXG5pZiAo
dHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgaWYgKCF3aW5kb3cuX3RhZ2dlZExh
bmd1YWdlcykgd2luZG93Ll90YWdnZWRMYW5ndWFnZXMgPSB7fTtcbiAgd2luZG93Ll90YWdnZWRM
YW5ndWFnZXMuYXRyYSA9IHsgdG9rZW5pemU6IHRva2VuaXplQXRyYSwgY29tcGxldGlvbnM6IGF0
cmFDb21wbGV0aW9ucyB9O1xufVxuXG4vLyBBdHRhY2ggaW50ZXJuYWxzIGZvciB0ZXN0aW5nIC8g
YWR2YW5jZWQgdXNlXG5hdHJhLl9sZXggPSBsZXg7XG5hdHJhLl9wYXJzZSA9IHBhcnNlO1xuYXRy
YS5fdG9rZW5pemUgPSB0b2tlbml6ZUF0cmE7XG5cbmV4cG9ydCB7IGF0cmEgfTtcbiIsImNlbGxJ
ZCI6bnVsbH19
AUDITABLE-MODULES-->
<!-- notebook settings: JSON {theme, fontSize, width, ...} -->
<!--AUDITABLE-SETTINGS
{"theme":"dark","fontSize":13,"width":"860"}
AUDITABLE-SETTINGS-->

<script>
// -- state.js --

// ═══════════════════════════════════════════════════
// AUDITABLE — reactive notebook runtime
// Geoscientific Chaos Union, 2025
// ═══════════════════════════════════════════════════

const $ = s => document.querySelector(s);
const $$ = s => [...document.querySelectorAll(s)];

// ── STATE ──
const S = {
  cells: [],        // { id, type, code, el, defines, uses, output, error }
  scope: {},        // shared variable scope
  cellId: 0,        // unique cell ID counter
  editTimer: null,  // debounce timer for autorun
  autorun: true,    // reactive mode flag
  selectedId: null, // currently selected cell
  pendingD: false,  // for "dd" double-tap delete
  pendingDTimer: null,
  clipboard: null,  // copied cell data
  trash: [],        // undo stack for deleted cells
  findActive: false,
  findQuery: '',
  findCase: false,
  findRegex: false,
  findMatches: [],   // { cellId, index, length }
  findCurrent: -1,
  initialized: false, // set after loadFromEmbed/init completes
};

const JS_KEYWORDS = new Set([
  'const','let','var','function','return','if','else','for','while','do',
  'switch','case','break','continue','new','this','class','extends','import',
  'export','default','from','of','in','typeof','instanceof','void','delete',
  'throw','try','catch','finally','async','await','yield','true','false',
  'null','undefined','NaN','Infinity'
]);

const JS_BUILTINS = new Set([
  'Math','Array','Object','String','Number','Float64Array','Float32Array',
  'Int32Array','Uint8Array','Map','Set','Promise','console','JSON',
  'ui','std','load','install','print',
  'workshop','notebook','md','html','css'
]);


// -- stdlib.js --

// ── STDLIB ──
// Bundled standard library for notebook work.
// Module-level — no per-cell state needed.

// ── Provider Registry ──

const _providers = { file: null, download: null };

function registerProvider(name, fn) {
  if (name in _providers) _providers[name] = fn;
}

// ── Data ──

function csv(text, opts = {}) {
  const sep = opts.separator || ',';
  const typed = !!opts.typed;
  const lines = [];
  let i = 0;
  const len = text.length;

  while (i < len) {
    const row = [];
    while (i < len) {
      if (text[i] === '"') {
        // quoted field
        i++;
        let field = '';
        while (i < len) {
          if (text[i] === '"') {
            if (text[i + 1] === '"') { field += '"'; i += 2; }
            else { i++; break; }
          } else { field += text[i]; i++; }
        }
        row.push(field);
        if (text[i] === sep) i++;
        else if (text[i] === '\r') { i++; if (text[i] === '\n') i++; break; }
        else if (text[i] === '\n') { i++; break; }
        else if (i >= len) break;
      } else {
        // unquoted field
        let field = '';
        while (i < len && text[i] !== sep && text[i] !== '\n' && text[i] !== '\r') {
          field += text[i]; i++;
        }
        row.push(field);
        if (text[i] === sep) i++;
        else if (text[i] === '\r') { i++; if (text[i] === '\n') i++; break; }
        else if (text[i] === '\n') { i++; break; }
        else break;
      }
    }
    if (row.length > 0 && !(row.length === 1 && row[0] === '')) lines.push(row);
  }

  if (lines.length < 2) return [];
  const headers = lines[0];
  const result = [];
  for (let r = 1; r < lines.length; r++) {
    const obj = {};
    for (let c = 0; c < headers.length; c++) {
      let val = lines[r][c] !== undefined ? lines[r][c] : '';
      if (typed) {
        const num = Number(val);
        if (val !== '' && !isNaN(num)) val = num;
        else if (val === 'true') val = true;
        else if (val === 'false') val = false;
        else if (val === '') val = null;
      }
      obj[headers[c]] = val;
    }
    result.push(obj);
  }
  return result;
}

async function fetchJSON(url) {
  const resp = await fetch(url);
  if (!resp.ok) throw new Error(`fetchJSON: ${resp.status} ${resp.statusText}`);
  return resp.json();
}

// ── Math / Stats ──

function _acc(arr, fn) {
  return fn ? arr.map(fn) : arr;
}

function sum(arr, fn) {
  const vals = _acc(arr, fn);
  let s = 0;
  for (let i = 0; i < vals.length; i++) s += vals[i];
  return s;
}

function mean(arr, fn) {
  if (!arr.length) return NaN;
  return sum(arr, fn) / arr.length;
}

function median(arr, fn) {
  const vals = _acc(arr, fn).slice().sort((a, b) => a - b);
  const n = vals.length;
  if (n === 0) return NaN;
  if (n % 2 === 1) return vals[(n - 1) / 2];
  return (vals[n / 2 - 1] + vals[n / 2]) / 2;
}

function extent(arr, fn) {
  const vals = _acc(arr, fn);
  let lo = Infinity, hi = -Infinity;
  for (let i = 0; i < vals.length; i++) {
    if (vals[i] < lo) lo = vals[i];
    if (vals[i] > hi) hi = vals[i];
  }
  return [lo, hi];
}

function bin(arr, n = 10, fn) {
  const vals = _acc(arr, fn);
  const [lo, hi] = extent(vals);
  const range = hi - lo || 1;
  const step = range / n;
  const bins = [];
  for (let i = 0; i < n; i++) {
    bins.push({ x0: lo + i * step, x1: lo + (i + 1) * step, values: [] });
  }
  for (const v of vals) {
    let idx = Math.floor((v - lo) / step);
    if (idx >= n) idx = n - 1;
    if (idx < 0) idx = 0;
    bins[idx].values.push(v);
  }
  return bins;
}

function linspace(start, stop, n) {
  if (n < 2) return n === 1 ? [start] : [];
  const result = new Array(n);
  const step = (stop - start) / (n - 1);
  for (let i = 0; i < n; i++) result[i] = start + i * step;
  result[n - 1] = stop; // exact endpoint
  return result;
}

// ── Array ──

function unique(arr, fn) {
  if (!fn) return [...new Set(arr)];
  const seen = new Set();
  const result = [];
  for (const item of arr) {
    const key = fn(item);
    if (!seen.has(key)) { seen.add(key); result.push(item); }
  }
  return result;
}

function zip(...arrays) {
  const len = Math.min(...arrays.map(a => a.length));
  const result = new Array(len);
  for (let i = 0; i < len; i++) {
    result[i] = arrays.map(a => a[i]);
  }
  return result;
}

function cross(...arrays) {
  if (arrays.length === 0) return [[]];
  const [first, ...rest] = arrays;
  const sub = cross(...rest);
  const result = [];
  for (const item of first) {
    for (const tail of sub) {
      result.push([item, ...tail]);
    }
  }
  return result;
}

// ── DOM / IO ──

async function file(accept) {
  if (_providers.file) return _providers.file(accept);
  return new Promise((resolve, reject) => {
    const input = document.createElement('input');
    input.type = 'file';
    if (accept) input.accept = accept;
    input.onchange = async () => {
      const f = input.files[0];
      if (!f) { reject(new Error('no file selected')); return; }
      const text = await f.text();
      resolve({ name: f.name, text, size: f.size });
    };
    input.click();
  });
}

function download(data, filename, mimeType) {
  if (_providers.download) return _providers.download(data, filename, mimeType);
  const str = typeof data === 'string' ? data : JSON.stringify(data, null, 2);
  const mime = mimeType || (typeof data === 'string' ? 'text/plain' : 'application/json');
  const blob = new Blob([str], { type: mime });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename || 'download';
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  setTimeout(() => URL.revokeObjectURL(url), 1000);
}

function el(tag, attrs, ...children) {
  const elem = document.createElement(tag);
  if (attrs && typeof attrs === 'object' && !(attrs instanceof Node)) {
    for (const [k, v] of Object.entries(attrs)) {
      if (k === 'style' && typeof v === 'object') {
        Object.assign(elem.style, v);
      } else if (k.startsWith('on') && typeof v === 'function') {
        elem.addEventListener(k.slice(2), v);
      } else {
        elem.setAttribute(k, v);
      }
    }
  } else if (attrs != null) {
    // attrs is actually a child
    children.unshift(attrs);
  }
  for (const child of children) {
    if (child instanceof Node) elem.appendChild(child);
    else if (child != null) elem.appendChild(document.createTextNode(String(child)));
  }
  return elem;
}

async function copy(text) {
  await navigator.clipboard.writeText(text);
}

function fmt(number, opts = {}) {
  const { decimals, prefix, suffix } = opts;
  let s = decimals != null ? number.toFixed(decimals)
    : new Intl.NumberFormat(undefined, { maximumFractionDigits: 6 }).format(number);
  if (prefix) s = prefix + s;
  if (suffix) s = s + suffix;
  return s;
}

// ── Source inclusion with dependency resolution ──

function include(libs, ...names) {
  // accept single library or array of libraries
  const list = Array.isArray(libs) && libs[0] && libs[0].sources ? libs : [libs];
  // merge all libraries into unified sources + deps
  const sources = {}, deps = {};
  for (const lib of list) {
    if (!lib || !lib.sources || !lib.deps)
      throw new Error('include: expected library with sources and deps');
    Object.assign(sources, lib.sources);
    Object.assign(deps, lib.deps);
  }
  const needed = new Set();
  function walk(name) {
    if (needed.has(name)) return;
    if (!sources[name]) throw new Error(`include: unknown routine '${name}'`);
    needed.add(name);
    for (const dep of deps[name] || []) walk(dep);
  }
  names.forEach(walk);
  // topological sort: deps before dependents
  const sorted = [];
  const visited = new Set();
  function visit(name) {
    if (visited.has(name)) return;
    visited.add(name);
    for (const dep of deps[name] || []) visit(dep);
    sorted.push(name);
  }
  needed.forEach(visit);
  return sorted.map(n => sources[n]).join('\n\n');
}

// ── Export ──

const std = {
  csv, fetchJSON,
  sum, mean, median, extent, bin, linspace,
  unique, zip, cross,
  file, download, el, copy, fmt,
  include,
};

// -- python.js --

// ── @python COMPAT HELPERS ──
// Python-familiar functions for users transitioning from Python.
// Each has a .help property showing the idiomatic JS equivalent.

function range(a, b, step) {
  let start, stop, s;
  if (b === undefined) { start = 0; stop = a; s = 1; }
  else { start = a; stop = b; s = step || 1; }
  const result = [];
  if (s > 0) { for (let i = start; i < stop; i += s) result.push(i); }
  else if (s < 0) { for (let i = start; i > stop; i += s) result.push(i); }
  return result;
}
range.help = 'JS: Array.from({length: n}, (_, i) => start + i * step)';

function enumerate(arr) {
  return arr.map((v, i) => [i, v]);
}
enumerate.help = 'JS: arr.map((v, i) => [i, v]) or arr.entries()';

function len(x) {
  if (x == null) throw new TypeError('len() of unsized object');
  if (x.size !== undefined) return x.size;
  return x.length;
}
len.help = 'JS: x.length or x.size';

function sorted(arr, key, reverse) {
  const copy = [...arr];
  if (key) copy.sort((a, b) => {
    const ka = key(a), kb = key(b);
    return ka < kb ? -1 : ka > kb ? 1 : 0;
  });
  else copy.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
  if (reverse) copy.reverse();
  return copy;
}
sorted.help = 'JS: arr.toSorted((a, b) => ...)';

function reversed(arr) {
  return [...arr].reverse();
}
reversed.help = 'JS: arr.toReversed()';

function isinstance(obj, cls) {
  return obj instanceof cls;
}
isinstance.help = 'JS: obj instanceof cls';

function type(x) {
  if (x === null) return 'null';
  if (Array.isArray(x)) return 'array';
  return typeof x;
}
type.help = 'JS: typeof x';

const python = {
  range, enumerate, len, sorted, reversed,
  isinstance, type,
};

function zenOfPython() {
  return [
    'The Zen of Python, by Tim Peters',
    '',
    'Beautiful is better than ugly.',
    'Explicit is better than implicit.',
    'Simple is better than complex.',
    'Complex is better than complicated.',
    'Flat is better than nested.',
    'Sparse is better than dense.',
    'Readability counts.',
    "Special cases aren't special enough to break the rules.",
    'Although practicality beats purity.',
    'Errors should never pass silently.',
    'Unless explicitly silenced.',
    'In the face of ambiguity, refuse the temptation to guess.',
    'There should be one-- and preferably only one --obvious way to do it.',
    "Although that way may not be obvious at first unless you're Dutch.",
    'Now is better than never.',
    'Although never is often better than *right* now.',
    "If the implementation is hard to explain, it's a bad idea.",
    'If the implementation is easy to explain, it may be a good idea.',
    "Namespaces are one honking great idea -- let's do more of those!",
  ].join('\n');
}

// -- syntax.js --

// ── SYNTAX HIGHLIGHTING ──

const CSS_NAMED_COLORS = new Set([
  'black','silver','gray','white','maroon','red','purple','fuchsia',
  'green','lime','olive','yellow','navy','blue','teal','aqua','orange'
]);

// detect curried tagged template: scan back through tokens for lang({...})`
function detectCurriedTag(tokens) {
  // last non-whitespace token must be )
  let j = tokens.length - 1;
  while (j >= 0 && tokens[j].type === '') j--;
  if (j < 0 || tokens[j].text !== ')') return null;
  // scan back to matching (
  let depth = 1;
  j--;
  while (j >= 0 && depth > 0) {
    if (tokens[j].text === ')') depth++;
    else if (tokens[j].text === '(') depth--;
    j--;
  }
  // token before ( should be the language name
  while (j >= 0 && tokens[j].type === '') j--;
  if (j < 0) return null;
  const name = tokens[j].text;
  if (window._taggedLanguages && window._taggedLanguages[name]) {
    return window._taggedLanguages[name];
  }
  return null;
}

// tokenize a tagged template literal starting at the opening backtick
function tokenizeTaggedTemplate(code, i, len, lang, tokens) {
  tokens.push({ type: 'punc', text: '`' });
  i++; // skip opening backtick
  let strBuf = '';
  while (i < len && code[i] !== '`') {
    if (code[i] === '\\') {
      strBuf += code[i] + (i + 1 < len ? code[i + 1] : '');
      i += 2;
      continue;
    }
    if (code[i] === '$' && i + 1 < len && code[i + 1] === '{') {
      if (strBuf) {
        tokens.push(...lang.tokenize(strBuf));
        strBuf = '';
      }
      tokens.push({ type: 'punc', text: '${' });
      i += 2;
      let depth = 1;
      let exprStart = i;
      while (i < len && depth > 0) {
        if (code[i] === '{') depth++;
        else if (code[i] === '}') { depth--; if (depth === 0) break; }
        else if (code[i] === '`') {
          i++;
          while (i < len && code[i] !== '`') {
            if (code[i] === '\\') i++;
            i++;
          }
        } else if (code[i] === '"' || code[i] === "'") {
          const q = code[i]; i++;
          while (i < len && code[i] !== q) {
            if (code[i] === '\\') i++;
            i++;
          }
        }
        i++;
      }
      const expr = code.slice(exprStart, i);
      if (expr) tokens.push(...tokenize(expr));
      if (i < len && code[i] === '}') {
        tokens.push({ type: 'punc', text: '}' });
        i++;
      }
      continue;
    }
    strBuf += code[i];
    i++;
  }
  if (strBuf) tokens.push(...lang.tokenize(strBuf));
  if (i < len && code[i] === '`') {
    tokens.push({ type: 'punc', text: '`' });
    i++;
  }
  return i;
}

function tokenize(code) {
  const tokens = [];
  let i = 0;
  const len = code.length;

  while (i < len) {
    // line comment
    if (code[i] === '/' && code[i+1] === '/') {
      const start = i;
      while (i < len && code[i] !== '\n') i++;
      tokens.push({ type: 'cmt', text: code.slice(start, i) });
      continue;
    }
    // block comment
    if (code[i] === '/' && code[i+1] === '*') {
      const start = i;
      i += 2;
      while (i < len && !(code[i-1] === '*' && code[i] === '/')) i++;
      if (i < len) i++;
      tokens.push({ type: 'cmt', text: code.slice(start, i) });
      continue;
    }
    // strings
    if (code[i] === '"' || code[i] === "'" || code[i] === '`') {
      // curried tagged template: lang({...})`...` — detect before treating as plain string
      if (code[i] === '`' && typeof window !== 'undefined' && window._taggedLanguages) {
        const lang = detectCurriedTag(tokens);
        if (lang) {
          i = tokenizeTaggedTemplate(code, i, len, lang, tokens);
          continue;
        }
      }
      const q = code[i];
      const start = i;
      i++;
      while (i < len && code[i] !== q) {
        if (code[i] === '\\') i++;
        i++;
      }
      if (i < len) i++;
      tokens.push({ type: 'str', text: code.slice(start, i) });
      continue;
    }
    // numbers
    if (/\d/.test(code[i]) || (code[i] === '.' && i+1 < len && /\d/.test(code[i+1]))) {
      const start = i;
      if (code[i] === '0' && (code[i+1] === 'x' || code[i+1] === 'X')) {
        i += 2;
        while (i < len && /[0-9a-fA-F_]/.test(code[i])) i++;
      } else {
        while (i < len && /[0-9._eE+-]/.test(code[i])) i++;
      }
      tokens.push({ type: 'num', text: code.slice(start, i) });
      continue;
    }
    // identifiers / keywords
    if (/[a-zA-Z_$]/.test(code[i])) {
      const start = i;
      while (i < len && /\w/.test(code[i])) i++;
      const word = code.slice(start, i);

      // tagged template literal — delegate to registered language tokenizer
      if (i < len && code[i] === '`' && typeof window !== 'undefined'
          && window._taggedLanguages && window._taggedLanguages[word]) {
        tokens.push({ type: 'fn', text: word });
        i = tokenizeTaggedTemplate(code, i, len, window._taggedLanguages[word], tokens);
        continue;
      }

      if (JS_KEYWORDS.has(word)) {
        tokens.push({ type: 'kw', text: word });
      } else if (JS_BUILTINS.has(word)) {
        tokens.push({ type: 'const', text: word });
      } else if (i < len && code[i] === '(') {
        tokens.push({ type: 'fn', text: word });
      } else {
        tokens.push({ type: 'id', text: word });
      }
      continue;
    }
    // operators
    if ('=+-*/<>!&|^~%?:'.includes(code[i])) {
      tokens.push({ type: 'op', text: code[i] });
      i++;
      continue;
    }
    // punctuation
    if ('(){}[];,.'.includes(code[i])) {
      tokens.push({ type: 'punc', text: code[i] });
      i++;
      continue;
    }
    // whitespace / other — pass through
    tokens.push({ type: '', text: code[i] });
    i++;
  }

  return tokens;
}

function highlightCode(ta, hl) {
  const code = ta.value;
  if (!code) { hl.innerHTML = '\n'; return; }

  const tokens = tokenize(code);
  let html = '';
  for (const t of tokens) {
    const escaped = t.text
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;');
    if (t.type && t.type !== 'id') {
      html += `<span class="hl-${t.type}">${escaped}</span>`;
    } else {
      html += escaped;
    }
  }
  // trailing newline so highlight layer matches textarea height
  hl.innerHTML = html + '\n';
}

// ── CSS SYNTAX HIGHLIGHTING ──

function tokenizeCss(code) {
  const tokens = [];
  let i = 0;
  const len = code.length;
  let ctx = 'sel'; // 'sel' | 'prop' | 'val'
  let depth = 0;

  while (i < len) {
    // block comment
    if (code[i] === '/' && code[i+1] === '*') {
      const start = i;
      i += 2;
      while (i < len && !(code[i-1] === '*' && code[i] === '/')) i++;
      if (i < len) i++;
      tokens.push({ type: 'cmt', text: code.slice(start, i) });
      continue;
    }
    // strings
    if (code[i] === '"' || code[i] === "'") {
      const q = code[i];
      const start = i;
      i++;
      while (i < len && code[i] !== q) {
        if (code[i] === '\\') i++;
        i++;
      }
      if (i < len) i++;
      tokens.push({ type: 'str', text: code.slice(start, i) });
      continue;
    }
    // punctuation with context transitions
    if (code[i] === '{') {
      tokens.push({ type: 'punc', text: '{' });
      depth++;
      ctx = 'prop';
      i++;
      continue;
    }
    if (code[i] === '}') {
      tokens.push({ type: 'punc', text: '}' });
      depth--;
      ctx = depth > 0 ? 'prop' : 'sel';
      i++;
      continue;
    }
    if (code[i] === ':' && ctx === 'prop') {
      tokens.push({ type: 'punc', text: ':' });
      ctx = 'val';
      i++;
      continue;
    }
    if (code[i] === ';') {
      tokens.push({ type: 'punc', text: ';' });
      ctx = 'prop';
      i++;
      continue;
    }
    if ('(),'.includes(code[i])) {
      tokens.push({ type: 'punc', text: code[i] });
      i++;
      continue;
    }
    // @-rules
    if (code[i] === '@') {
      const start = i;
      i++;
      while (i < len && /[a-zA-Z-]/.test(code[i])) i++;
      tokens.push({ type: 'atrule', text: code.slice(start, i) });
      continue;
    }
    // !important
    if (code[i] === '!' && ctx === 'val') {
      const start = i;
      i++;
      while (i < len && /[a-zA-Z]/.test(code[i])) i++;
      tokens.push({ type: 'important', text: code.slice(start, i) });
      continue;
    }
    // # — hex color in val, ID selector in sel
    if (code[i] === '#') {
      if (ctx === 'val') {
        const start = i;
        i++;
        while (i < len && /[0-9a-fA-F]/.test(code[i])) i++;
        tokens.push({ type: 'color', text: code.slice(start, i) });
      } else {
        // ID selector
        const start = i;
        i++;
        while (i < len && /[\w-]/.test(code[i])) i++;
        tokens.push({ type: 'sel', text: code.slice(start, i) });
      }
      continue;
    }
    // : in selector context = pseudo-class
    if (code[i] === ':' && ctx === 'sel') {
      const start = i;
      i++;
      if (i < len && code[i] === ':') i++; // ::
      while (i < len && /[a-zA-Z-]/.test(code[i])) i++;
      // handle pseudo with parens like :nth-child(...)
      if (i < len && code[i] === '(') {
        i++;
        let pdepth = 1;
        while (i < len && pdepth > 0) {
          if (code[i] === '(') pdepth++;
          else if (code[i] === ')') pdepth--;
          if (pdepth > 0) i++;
        }
        if (i < len) i++;
      }
      tokens.push({ type: 'sel', text: code.slice(start, i) });
      continue;
    }
    // . in selector context = class selector
    if (code[i] === '.' && ctx === 'sel') {
      const start = i;
      i++;
      while (i < len && /[\w-]/.test(code[i])) i++;
      tokens.push({ type: 'sel', text: code.slice(start, i) });
      continue;
    }
    // numbers (with units)
    if (ctx === 'val' && (/\d/.test(code[i]) || (code[i] === '.' && i+1 < len && /\d/.test(code[i+1])))) {
      const start = i;
      while (i < len && /[0-9.]/.test(code[i])) i++;
      // units
      while (i < len && /[a-zA-Z%]/.test(code[i])) i++;
      tokens.push({ type: 'num', text: code.slice(start, i) });
      continue;
    }
    // identifiers
    if (/[a-zA-Z_-]/.test(code[i])) {
      const start = i;
      while (i < len && /[\w-]/.test(code[i])) i++;
      const word = code.slice(start, i);
      // function call
      if (i < len && code[i] === '(') {
        tokens.push({ type: 'fn', text: word });
        continue;
      }
      if (ctx === 'val' && CSS_NAMED_COLORS.has(word.toLowerCase())) {
        tokens.push({ type: 'color', text: word });
      } else if (ctx === 'prop') {
        tokens.push({ type: 'prop', text: word });
      } else if (ctx === 'sel') {
        tokens.push({ type: 'sel', text: word });
      } else {
        tokens.push({ type: '', text: word });
      }
      continue;
    }
    // whitespace / other
    tokens.push({ type: '', text: code[i] });
    i++;
  }

  return tokens;
}

function resolveToHex(colorStr) {
  const d = document.createElement('div');
  d.style.color = colorStr;
  document.body.appendChild(d);
  const rgb = getComputedStyle(d).color;
  d.remove();
  const m = rgb.match(/(\d+)/g);
  if (!m || m.length < 3) return colorStr;
  return '#' + m.slice(0, 3).map(n => parseInt(n).toString(16).padStart(2, '0')).join('');
}

let _colorPicker = null;
let _pickerTarget = null; // { ta, offset, len }

function ensureColorPicker() {
  if (_colorPicker) return _colorPicker;
  _colorPicker = document.createElement('input');
  _colorPicker.type = 'color';
  _colorPicker.style.cssText = 'position:absolute;visibility:hidden;width:0;height:0;';
  document.body.appendChild(_colorPicker);
  _colorPicker.addEventListener('input', () => {
    if (!_pickerTarget) return;
    const { ta, offset, len } = _pickerTarget;
    const newColor = _colorPicker.value;
    ta.focus();
    ta.selectionStart = offset;
    ta.selectionEnd = offset + len;
    document.execCommand('insertText', false, newColor);
    ta.dispatchEvent(new Event('input'));
    // update offset for new length
    _pickerTarget.len = newColor.length;
  });
  return _colorPicker;
}

function highlightCss(ta, hl) {
  const code = ta.value;
  if (!code) { hl.innerHTML = '\n'; return; }

  const tokens = tokenizeCss(code);
  let html = '';
  let offset = 0;
  for (const t of tokens) {
    const escaped = t.text
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;');
    if (t.type === 'color') {
      const hex = resolveToHex(t.text);
      html += `<span class="hl-color"><span class="hl-swatch" style="background:${hex}" data-offset="${offset}" data-len="${t.text.length}"></span>${escaped}</span>`;
    } else if (t.type && t.type !== 'id') {
      html += `<span class="hl-${t.type}">${escaped}</span>`;
    } else {
      html += escaped;
    }
    offset += t.text.length;
  }
  hl.innerHTML = html + '\n';

  // wire swatch clicks (only add once per highlight layer)
  if (!hl._swatchWired) {
    hl._swatchWired = true;
    hl.addEventListener('click', (e) => {
      const swatch = e.target.closest('.hl-swatch');
      if (!swatch) return;
      const off = parseInt(swatch.dataset.offset);
      const len = parseInt(swatch.dataset.len);
      const picker = ensureColorPicker();
      _pickerTarget = { ta, offset: off, len };
      const hex = resolveToHex(ta.value.slice(off, off + len));
      picker.value = hex;
      picker.click();
    });
  }
}

// ── HTML SYNTAX HIGHLIGHTING ──

function tokenizeHtml(code) {
  const tokens = [];
  let i = 0;
  const len = code.length;

  while (i < len) {
    // template expression ${...}
    if (code[i] === '$' && i + 1 < len && code[i + 1] === '{') {
      const start = i;
      i += 2;
      let depth = 1;
      while (i < len && depth > 0) {
        if (code[i] === '{') depth++;
        else if (code[i] === '}') depth--;
        if (depth > 0) i++;
      }
      if (i < len) i++;
      tokens.push({ type: 'expr', text: code.slice(start, i) });
      continue;
    }
    // comment <!-- ... -->
    if (code[i] === '<' && code[i + 1] === '!' && code[i + 2] === '-' && code[i + 3] === '-') {
      const start = i;
      i += 4;
      while (i < len) {
        if (code[i] === '-' && code[i + 1] === '-' && code[i + 2] === '>') { i += 3; break; }
        i++;
      }
      tokens.push({ type: 'cmt', text: code.slice(start, i) });
      continue;
    }
    // tag
    if (code[i] === '<') {
      tokens.push({ type: 'tag', text: '<' });
      i++;
      // closing slash
      if (i < len && code[i] === '/') { tokens.push({ type: 'tag', text: '/' }); i++; }
      // tag name
      const ns = i;
      while (i < len && /[a-zA-Z0-9-]/.test(code[i])) i++;
      if (i > ns) tokens.push({ type: 'tag', text: code.slice(ns, i) });
      // attributes until >
      while (i < len && code[i] !== '>') {
        // template expression inside tag
        if (code[i] === '$' && i + 1 < len && code[i + 1] === '{') {
          const start = i;
          i += 2;
          let depth = 1;
          while (i < len && depth > 0) {
            if (code[i] === '{') depth++;
            else if (code[i] === '}') depth--;
            if (depth > 0) i++;
          }
          if (i < len) i++;
          tokens.push({ type: 'expr', text: code.slice(start, i) });
          continue;
        }
        if (/\s/.test(code[i])) { tokens.push({ type: '', text: code[i] }); i++; continue; }
        if (code[i] === '/') { tokens.push({ type: 'tag', text: '/' }); i++; continue; }
        if (code[i] === '=') { tokens.push({ type: 'punc', text: '=' }); i++; continue; }
        // quoted attribute value
        if (code[i] === '"' || code[i] === "'") {
          const q = code[i];
          const start = i;
          i++;
          while (i < len && code[i] !== q) { if (code[i] === '\\') i++; i++; }
          if (i < len) i++;
          tokens.push({ type: 'str', text: code.slice(start, i) });
          continue;
        }
        // attribute name or unquoted value
        const as = i;
        while (i < len && !/[\s=>/"']/.test(code[i])) i++;
        if (i > as) {
          let j = i;
          while (j < len && /\s/.test(code[j])) j++;
          tokens.push({ type: (j < len && code[j] === '=') ? 'attr' : 'attr', text: code.slice(as, i) });
        }
      }
      if (i < len && code[i] === '>') { tokens.push({ type: 'tag', text: '>' }); i++; }
      continue;
    }
    // plain text
    tokens.push({ type: '', text: code[i] });
    i++;
  }

  return tokens;
}

function highlightHtml(ta, hl) {
  const code = ta.value;
  if (!code) { hl.innerHTML = '\n'; return; }

  const tokens = tokenizeHtml(code);
  let html = '';
  for (const t of tokens) {
    const escaped = t.text
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;');
    if (t.type) {
      html += `<span class="hl-${t.type}">${escaped}</span>`;
    } else {
      html += escaped;
    }
  }
  hl.innerHTML = html + '\n';
}

// -- dag.js --

// ── REACTIVE DAG ──

// ── directive helpers ──

function hasDirective(code, name) {
  return new RegExp(String.raw`^\s*\/\/\s*%${name}\b`, 'm').test(code);
}

function getDirective(code, name) {
  const m = code.match(new RegExp(String.raw`^\s*\/\/\s*%${name}\s+(.+)`, 'm'));
  return m ? m[1].trim() : null;
}

const isManual    = code => hasDirective(code, 'manual');
const isHidden    = code => hasDirective(code, 'hide');
const isNorun     = code => hasDirective(code, 'norun');
const isCollapsed = code => hasDirective(code, 'collapsed');
const parseCellName    = code => getDirective(code, 'cellName');
const parseOutputId    = code => { const v = getDirective(code, 'outputId'); return v ? v.split(/\s+/)[0] : null; };
const parseOutputClass = code => getDirective(code, 'outputClass');

// ── code analysis ──

function stripCommentsAndStrings(code) {
  // single-pass: strings take precedence over comments (// inside "..." is not a comment)
  let out = '', i = 0;
  while (i < code.length) {
    // single-quoted string
    if (code[i] === "'") {
      out += '""';
      i++;
      while (i < code.length && code[i] !== "'") { if (code[i] === '\\') i++; i++; }
      i++; // skip closing quote
      continue;
    }
    // double-quoted string
    if (code[i] === '"') {
      out += '""';
      i++;
      while (i < code.length && code[i] !== '"') { if (code[i] === '\\') i++; i++; }
      i++; // skip closing quote
      continue;
    }
    // template literal: replace string parts with spaces but keep ${expr} content
    if (code[i] === '`') {
      i++;
      while (i < code.length && code[i] !== '`') {
        if (code[i] === '\\') { i += 2; continue; }
        if (code[i] === '$' && code[i + 1] === '{') {
          i += 2;
          let depth = 1;
          out += ' ';
          while (i < code.length && depth > 0) {
            if (code[i] === '{') depth++;
            else if (code[i] === '}') { depth--; if (depth === 0) break; }
            out += code[i];
            i++;
          }
          out += ' ';
          i++; // skip closing }
          continue;
        }
        i++;
      }
      i++; // skip closing backtick
      continue;
    }
    // line comment
    if (code[i] === '/' && code[i + 1] === '/') {
      while (i < code.length && code[i] !== '\n') i++;
      continue;
    }
    // block comment
    if (code[i] === '/' && code[i + 1] === '*') {
      i += 2;
      while (i < code.length && !(code[i - 1] === '*' && code[i] === '/')) i++;
      i++;
      continue;
    }
    out += code[i];
    i++;
  }
  return out;
}

function parseNames(code) {
  // extract ONLY top-level variable definitions (brace depth 0)
  const defines = new Set();

  const stripped = stripCommentsAndStrings(code);

  let depth = 0;
  let parenDepth = 0;
  let i = 0;
  while (i < stripped.length) {
    const ch = stripped[i];
    if (ch === '{') { depth++; i++; continue; }
    if (ch === '}') { depth--; i++; continue; }
    if (ch === '(') { parenDepth++; i++; continue; }
    if (ch === ')') { parenDepth--; i++; continue; }

    if (depth === 0 && parenDepth === 0) {
      // check for const/let/var
      const rest = stripped.slice(i);
      const dm = rest.match(/^(?:const|let|var)\s+(\w+)/);
      if (dm) {
        defines.add(dm[1]);
        // scan forward for comma-separated declarations: const W = 80, H = 60
        // skip initializer expressions tracking depth, grab identifiers after commas
        let j = dm[0].length;
        let d = 0, pd = 0, bd = 0;
        while (j < rest.length) {
          const ch = rest[j];
          if (ch === '{') d++;
          else if (ch === '}') d--;
          else if (ch === '(') pd++;
          else if (ch === ')') pd--;
          else if (ch === '[') bd++;
          else if (ch === ']') bd--;
          else if (ch === ';' || ch === '\n') {
            if (d === 0 && pd === 0 && bd === 0) break;
          }
          else if (ch === ',' && d === 0 && pd === 0 && bd === 0) {
            // next identifier after comma
            const after = rest.slice(j + 1).match(/^\s*(\w+)/);
            if (after) defines.add(after[1]);
          }
          j++;
        }
        i += j;
        continue;
      }
      // destructuring: const { a, b } = ... or const [ a, b ] = ...
      const destruct = rest.match(/^(?:const|let|var)\s*[\{\[]/);
      if (destruct) {
        // find the closing } or ] then extract identifiers
        const opener = rest[destruct[0].length - 1];
        const closer = opener === '{' ? '}' : ']';
        const closeIdx = rest.indexOf(closer, destruct[0].length);
        if (closeIdx > 0) {
          const inner = rest.slice(destruct[0].length, closeIdx);
          // split on commas, take last word of each part (handles renaming)
          inner.split(',').forEach(part => {
            const parts = part.trim().split(/\s*:\s*/);
            const name = (parts.length > 1 ? parts[1] : parts[0]).trim().match(/^\w+/);
            if (name) defines.add(name[0]);
          });
          i += closeIdx + 1;
          continue;
        }
      }
      // check for function declarations
      const fm = rest.match(/^function\s+(\w+)/);
      if (fm) {
        defines.add(fm[1]);
        i += fm[0].length;
        continue;
      }
    }
    i++;
  }

  return { defines };
}

function findUses(code, allDefined, selfDefined) {
  // find identifiers that reference other cells' definitions
  const uses = new Set();
  const stripped = stripCommentsAndStrings(code);
  if (!selfDefined) selfDefined = parseNames(code).defines;

  const idRe = /\b([a-zA-Z_$]\w*)\b/g;
  let m;
  while ((m = idRe.exec(stripped))) {
    if (allDefined.has(m[1]) && !selfDefined.has(m[1])) {
      uses.add(m[1]);
    }
  }
  return uses;
}

function findHtmlUses(code, allDefined) {
  const uses = new Set();
  const re = /\$\{([^}]+)\}/g;
  let m;
  while ((m = re.exec(code))) {
    const expr = m[1];
    const idRe = /\b([a-zA-Z_$]\w*)\b/g;
    let im;
    while ((im = idRe.exec(expr))) {
      if (allDefined.has(im[1])) uses.add(im[1]);
    }
  }
  return uses;
}

function buildDAG() {
  // collect all defined names globally (only re-parse changed cells)
  const allDefined = new Map(); // name -> cell id
  for (const c of S.cells) {
    if (c.type !== 'code') continue;
    if (c.code !== c._parsedCode) {
      const { defines } = parseNames(c.code);
      c.defines = defines;
      c._parsedCode = c.code;
    }
    for (const name of c.defines) {
      allDefined.set(name, c.id);
    }
  }

  // find uses for each cell (invalidate if code changed or global names changed)
  const definedNames = new Set(allDefined.keys());
  const definedKey = [...definedNames].sort().join(',');
  for (const c of S.cells) {
    if (c.type === 'code') {
      if (c.code !== c._usesCode || c._definedKey !== definedKey) {
        c.uses = findUses(c.code, definedNames, c.defines);
        c._usesCode = c.code;
        c._definedKey = definedKey;
      }
    } else if (c.type === 'html') {
      if (c.code !== c._usesCode || c._definedKey !== definedKey) {
        c.uses = findHtmlUses(c.code, definedNames);
        c._usesCode = c.code;
        c._definedKey = definedKey;
      }
    }
  }

  return allDefined;
}

function topoSort(dirtyIds) {
  // BFS from dirty cells to find all downstream dependents
  const dependents = new Map(); // varName -> Set<cellId>
  for (const c of S.cells) {
    if (!c.uses) continue;
    for (const name of c.uses) {
      if (!dependents.has(name)) dependents.set(name, new Set());
      dependents.get(name).add(c.id);
    }
  }

  const needsRun = new Set(dirtyIds);
  const queue = [...dirtyIds];
  while (queue.length) {
    const id = queue.shift();
    const cell = S.cells.find(c => c.id === id);
    if (!cell || !cell.defines) continue;
    for (const name of cell.defines) {
      const deps = dependents.get(name);
      if (!deps) continue;
      for (const depId of deps) {
        if (!needsRun.has(depId)) {
          needsRun.add(depId);
          queue.push(depId);
        }
      }
    }
  }

  // return in document order
  return S.cells.filter(c => needsRun.has(c.id)).map(c => c.id);
}

// -- exec.js --

// ── EXECUTION ENGINE ──
//
// Scope model: each cell runs inside an AsyncFunction where upstream variables
// are passed as parameters. This is pass-by-value for primitives — reassigning
// a variable in cell A (e.g. `grid = next`) does NOT propagate to cell B.
// Mutable state that needs to survive across callbacks belongs in %manual cells
// using DOM elements, objects, or closures.
//
// Cell builtins (display, canvas, slider, load, install, installBinary, etc.)
// are injected as additional parameters — listed in _injected, not in scope.
// They are NOT propagated to downstream cells.

// ── BINARY HELPERS ──

function uint8ToBase64(bytes) {
  let bin = '';
  for (let i = 0; i < bytes.length; i++) bin += String.fromCharCode(bytes[i]);
  return btoa(bin);
}

async function decodeBinary(entry) {
  const type = entry.type || 'application/octet-stream';
  const bytes = Uint8Array.from(atob(entry.source), c => c.charCodeAt(0));
  if (entry.compressed) {
    const ds = new DecompressionStream('gzip');
    const stream = new Blob([bytes]).stream().pipeThrough(ds);
    const decompressed = new Uint8Array(await new Response(stream).arrayBuffer());
    return URL.createObjectURL(new Blob([decompressed], { type }));
  }
  return URL.createObjectURL(new Blob([bytes], { type }));
}

// ── TAGGED CONTENT ──

class TaggedContent {
  constructor(type, content) { this.type = type; this.content = content; }
  toString() { return this.content; }
}

function taggedTemplate(type) {
  return (strings, ...values) => {
    let result = strings[0];
    for (let i = 0; i < values.length; i++) result += String(values[i]) + strings[i + 1];
    return new TaggedContent(type, result);
  };
}

// ── EXECUTION ──

function renderHtmlCell(cell) {
  const viewEl = cell.el.querySelector('.cell-html-view');
  const outputEl = cell.el.querySelector('.cell-output');
  if (!viewEl) return;
  if (outputEl) { outputEl.textContent = ''; outputEl.className = 'cell-output'; }

  // use only variables this cell references for stable function signatures
  const scopeKeys = cell.uses ? [...cell.uses].sort() : [];
  const scopeVals = scopeKeys.map(k => S.scope[k]);

  // cache compiled template functions per expression
  if (!cell._tplCache) cell._tplCache = {};
  const scopeSig = scopeKeys.join(',');
  if (cell._tplScopeSig !== scopeSig) {
    cell._tplCache = {};  // scope signature changed, invalidate all
    cell._tplScopeSig = scopeSig;
  }

  let rendered = cell.code.replace(/\$\{([^}]+)\}/g, (match, expr) => {
    try {
      let fn = cell._tplCache[expr];
      if (!fn) {
        fn = new Function(...scopeKeys, '"use strict"; return (' + expr + ')');
        cell._tplCache[expr] = fn;
      }
      const val = fn(...scopeVals);
      return val === undefined ? '' : String(val);
    } catch (e) {
      return '[Error: ' + e.message + ']';
    }
  });

  viewEl.innerHTML = rendered;
  cell.el.classList.remove('stale', 'error');
  cell.el.classList.add('fresh');
  setTimeout(() => cell.el.classList.remove('fresh'), 800);
}

async function execCell(cell) {
  // fire invalidation promise from previous run (cleanup resources)
  if (cell._invalidate) { cell._invalidate(); cell._invalidate = null; }

  const outputEl = cell.el.querySelector('.cell-output');
  const widgetEl = cell.el.querySelector('.cell-widgets');

  // preserve canvases before clearing output
  const prevCanvases = [...outputEl.querySelectorAll('canvas')];
  outputEl.textContent = '';
  outputEl.className = 'cell-output';
  const outClass = parseOutputClass(cell.code);
  if (outClass) outputEl.classList.add(...outClass.split(/\s+/));
  const outId = parseOutputId(cell.code);
  outputEl.id = outId || '';
  cell.el.classList.toggle('present-hidden', isHidden(cell.code));
  cell.error = null;

  // create invalidation promise for this run
  let invalidationResolve;
  const invalidation = new Promise(r => { invalidationResolve = r; });
  cell._invalidate = invalidationResolve;

  // track which widgets are used this run
  const usedWidgets = new Set();
  let canvasIdx = 0;

  // build display function for this cell
  const display = (...args) => {
    for (const arg of args) {
      if (arg instanceof Element) {
        outputEl.appendChild(arg);
      } else if (typeof arg === 'object' && arg !== null) {
        const pre = document.createElement('span');
        try { pre.textContent = JSON.stringify(arg, null, 2); }
        catch { pre.textContent = String(arg); }
        outputEl.appendChild(pre);
        outputEl.appendChild(document.createTextNode('\n'));
      } else {
        outputEl.appendChild(document.createTextNode(String(arg) + '\n'));
      }
    }
  };

  // canvas helper — reuses existing canvas if dimensions match
  const canvas = (w = 400, h = 300) => {
    const prev = prevCanvases[canvasIdx++];
    if (prev && prev.width === w && prev.height === h) {
      outputEl.appendChild(prev);
      return prev;
    }
    const c = document.createElement('canvas');
    c.width = w; c.height = h;
    c.style.background = '#000';
    outputEl.appendChild(c);
    return c;
  };

  // table helper
  const table = (data, columns) => {
    if (!data || !data.length) return;
    const cols = columns || Object.keys(data[0]);

    // detect numeric columns by scanning first 10 rows
    const isNumCol = {};
    for (const c of cols) {
      let allNum = true;
      const scanRows = data.slice(0, 10);
      for (const row of scanRows) {
        const v = row[c];
        if (v !== null && v !== undefined && typeof v !== 'number') { allNum = false; break; }
      }
      isNumCol[c] = allNum;
    }

    const t = document.createElement('table');
    const thead = document.createElement('thead');
    const hr = document.createElement('tr');
    for (const c of cols) {
      const th = document.createElement('th');
      th.textContent = c;
      th.style.textAlign = isNumCol[c] ? 'right' : 'left';
      hr.appendChild(th);
    }
    thead.appendChild(hr);
    t.appendChild(thead);
    const tbody = document.createElement('tbody');
    for (const row of data) {
      const tr = document.createElement('tr');
      for (const c of cols) {
        const td = document.createElement('td');
        const v = row[c];
        td.textContent = typeof v === 'number' ? (Number.isInteger(v) ? v : v.toFixed(4)) : String(v ?? '');
        td.style.textAlign = isNumCol[c] ? 'right' : 'left';
        tr.appendChild(td);
      }
      tbody.appendChild(tr);
    }
    t.appendChild(tbody);
    outputEl.appendChild(t);
  };

  // input widget helpers — persist state and DOM across re-runs
  if (!cell._inputs) cell._inputs = {};
  if (!cell._callbacks) cell._callbacks = {};

  const mkInput = (label, type, defaultVal, opts = {}) => {
    const key = label;
    const prev = cell._inputs[key];
    let val = prev !== undefined ? prev : defaultVal;
    usedWidgets.add(key);
    cell._callbacks[key] = { onInput: opts.onInput, onChange: opts.onChange };

    // check if widget DOM already exists
    const existing = widgetEl.querySelector(`[data-widget-key="${CSS.escape(key)}"]`);
    if (existing) {
      // update id/class in case they changed on re-run
      existing.id = opts.id || '';
      existing.className = 'cell-widget' + (opts.class ? ' ' + opts.class : '');
      // just return current value, DOM stays — callbacks already updated above
      cell._inputs[key] = type === 'slider' ? parseFloat(val)
                         : type === 'checkbox' ? !!val
                         : val;
      return cell._inputs[key];
    }

    // create new widget
    const wrap = document.createElement('div');
    wrap.dataset.widgetKey = key;
    wrap.className = 'cell-widget' + (opts.class ? ' ' + opts.class : '');
    if (opts.id) wrap.id = opts.id;

    const lbl = document.createElement('span');
    lbl.textContent = label;
    lbl.className = 'cell-widget-label';
    wrap.appendChild(lbl);

    let input;
    if (type === 'slider') {
      input = document.createElement('input');
      input.type = 'range';
      input.min = opts.min ?? 0;
      input.max = opts.max ?? 100;
      input.step = opts.step ?? 1;
      input.value = val;
      const valSpan = document.createElement('span');
      valSpan.textContent = val;
      valSpan.className = 'cell-widget-val';
      input.oninput = () => {
        const n = parseFloat(input.value);
        cell._inputs[key] = n;
        valSpan.textContent = n;
        const cb = cell._callbacks[key];
        if (cb.onInput) { cb.onInput(n); }
        else if (!cb.onChange) { clearTimeout(cell._inputTimer); cell._inputTimer = setTimeout(() => runDAG([cell.id], true), 80); }
      };
      input.onchange = () => { const cb = cell._callbacks[key]; if (cb.onChange) cb.onChange(parseFloat(input.value)); };
      wrap.appendChild(input);
      wrap.appendChild(valSpan);
    } else if (type === 'dropdown') {
      input = document.createElement('select');
      for (const o of (opts.options || [])) {
        const opt = document.createElement('option');
        opt.value = o;
        opt.textContent = o;
        if (o === val) opt.selected = true;
        input.appendChild(opt);
      }
      input.onchange = () => {
        cell._inputs[key] = input.value;
        const cb = cell._callbacks[key];
        if (cb.onInput || cb.onChange) {
          if (cb.onInput) cb.onInput(input.value);
          if (cb.onChange) cb.onChange(input.value);
        } else { runDAG([cell.id], true); }
      };
      wrap.appendChild(input);
    } else if (type === 'checkbox') {
      input = document.createElement('input');
      input.type = 'checkbox';
      input.checked = !!val;
      input.onchange = () => {
        cell._inputs[key] = input.checked;
        const cb = cell._callbacks[key];
        if (cb.onInput || cb.onChange) {
          if (cb.onInput) cb.onInput(input.checked);
          if (cb.onChange) cb.onChange(input.checked);
        } else { runDAG([cell.id], true); }
      };
      wrap.appendChild(input);
    } else if (type === 'text') {
      input = document.createElement('input');
      input.type = 'text';
      input.value = val;
      input.oninput = () => {
        cell._inputs[key] = input.value;
        const cb = cell._callbacks[key];
        if (cb.onInput) { cb.onInput(input.value); }
        else if (!cb.onChange) { clearTimeout(cell._inputTimer); cell._inputTimer = setTimeout(() => runDAG([cell.id], true), 300); }
      };
      input.onchange = () => { const cb = cell._callbacks[key]; if (cb.onChange) cb.onChange(input.value); };
      wrap.appendChild(input);
    }

    widgetEl.appendChild(wrap);
    cell._inputs[key] = type === 'slider' ? parseFloat(val)
                       : type === 'checkbox' ? !!val
                       : val;
    return cell._inputs[key];
  };

  const slider = (label, defaultVal = 50, opts = {}) => mkInput(label, 'slider', defaultVal, opts);
  const dropdown = (label, options, defaultVal, opts = {}) => mkInput(label, 'dropdown', defaultVal || options[0], { ...opts, options });
  const checkbox = (label, defaultVal = false, opts = {}) => mkInput(label, 'checkbox', defaultVal, opts);
  const textInput = (label, defaultVal = '', opts = {}) => mkInput(label, 'text', defaultVal, opts);

  // execute with scoped parameters (only what this cell uses, for stable V8 JIT)
  // filter out injected names — they're per-cell params, not scope-propagated
  const _injected = ['ui', 'std', 'load', 'install', 'installBinary', 'invalidation', 'print', 'md', 'html', 'css', 'workshop', 'notebook'];
  const scopeKeys = cell.uses ? [...cell.uses].filter(k => !_injected.includes(k)).sort() : [];
  const defNames = cell.defines ? [...cell.defines].sort().join(', ') : '';

  // import cache — shared across all cells
  if (!window._importCache) window._importCache = {};
  if (!window._installedModules) window._installedModules = {}; // url -> { source, cellId }

  const load = async (url) => {
    // virtual modules
    if (url === '@std') return std;
    if (url === '@python') return python;
    if (url === '@python/this') { display(zenOfPython()); return python; }

    // @atra/<name> — atra library binary distributions
    // if pre-installed (via /// module: directive or install()), the existing
    // _installedModules[url] check below handles it. this fallback covers
    // development mode where the file is available at a relative path.
    if (url.startsWith('@atra/')) {
      if (!window._importCache[url] && !window._installedModules[url]) {
        const name = url.slice(6);
        const mod = await import('./ext/atra/lib/' + name + '.js');
        window._importCache[url] = mod;
        return mod;
      }
      // fall through to normal _importCache / _installedModules handling below
    }

    if (window._importCache[url]) return window._importCache[url];

    // binary assets — return blob URL
    if (window._installedModules[url]?.binary) {
      const blobUrl = await decodeBinary(window._installedModules[url]);
      window._importCache[url] = blobUrl;
      return blobUrl;
    }

    const langsBefore = window._taggedLanguages ? Object.keys(window._taggedLanguages).length : 0;

    let mod;
    // check installed (offline) modules first
    if (window._installedModules[url]) {
      const entry = window._installedModules[url];
      let src = typeof entry === 'string' ? entry : entry.source;
      // resolve root-relative paths for legacy saved modules
      try { src = resolveModulePaths(src, url); } catch {}
      const blob = new Blob([src], { type: 'application/javascript' });
      const blobUrl = URL.createObjectURL(blob);
      mod = await import(blobUrl);
    } else {
      mod = await import(url);
    }
    window._importCache[url] = mod;

    // if the module registered new tagged languages, re-highlight all code cells
    const langsAfter = window._taggedLanguages ? Object.keys(window._taggedLanguages).length : 0;
    if (langsAfter > langsBefore) {
      for (const c of S.cells) {
        if (c.type !== 'code') continue;
        const ta = c.el.querySelector('textarea');
        const hl = c.el.querySelector('.highlight-layer');
        if (ta && hl) highlightCode(ta, hl);
      }
    }

    return mod;
  };

  // resolve root-relative paths in module source so blob URLs work
  const resolveModulePaths = (source, responseUrl) => {
    const origin = new URL(responseUrl).origin;
    return source.replace(/(from\s+["'])(\/[^"']+)(["'])/g, '$1' + origin + '$2$3')
                 .replace(/(import\s*\(["'])(\/[^"']+)(["']\))/g, '$1' + origin + '$2$3')
                 .replace(/(export\s+\*\s+from\s+["'])(\/[^"']+)(["'])/g, '$1' + origin + '$2$3')
                 .replace(/(export\s*\{[^}]*\}\s*from\s+["'])(\/[^"']+)(["'])/g, '$1' + origin + '$2$3');
  };

  const install = async (url) => {
    // @atra/<name> — resolve to CDN URL, store under virtual key
    if (url.startsWith('@atra/')) {
      const name = url.slice(6);
      const realUrl = __AUDITABLE_PAGES_URL__ + '/ext/atra/lib/' + name + '.js';
      const resp = await fetch(realUrl);
      if (!resp.ok) throw new Error(`Failed to fetch ${realUrl}: ${resp.status}`);
      const source = await resp.text();
      window._installedModules[url] = { source, cellId: cell.id };
      const blob = new Blob([source], { type: 'application/javascript' });
      const blobUrl = URL.createObjectURL(blob);
      const mod = await import(blobUrl);
      window._importCache[url] = mod;
      display(`installed ${url} (${(source.length / 1024).toFixed(1)} KB)`);
      return mod;
    }
    // normalize: add ?bundle for esm.sh if not present
    let bundleUrl = url;
    if (bundleUrl.includes('esm.sh') && !bundleUrl.includes('?bundle') && !bundleUrl.includes('&bundle')) {
      bundleUrl += (bundleUrl.includes('?') ? '&' : '?') + 'bundle';
    }
    // fetch source
    const resp = await fetch(bundleUrl);
    if (!resp.ok) throw new Error(`Failed to fetch ${bundleUrl}: ${resp.status}`);
    let source = await resp.text();
    // resolve root-relative paths to absolute so blob URLs work
    source = resolveModulePaths(source, resp.url);
    // store under original url with cell reference
    window._installedModules[url] = { source, cellId: cell.id };
    // also load it into cache
    const blob = new Blob([source], { type: 'application/javascript' });
    const blobUrl = URL.createObjectURL(blob);
    const mod = await import(blobUrl);
    window._importCache[url] = mod;
    display(`installed ${url} (${(source.length / 1024).toFixed(1)} KB)`);
    return mod;
  };

  const installBinary = async (url, opts = {}) => {
    const compress = opts.compress !== false;
    // if already installed, decode and return blob URL
    if (window._installedModules[url]?.binary) {
      return decodeBinary(window._installedModules[url]);
    }
    const resp = await fetch(url);
    if (!resp.ok) throw new Error(`Failed to fetch ${url}: ${resp.status}`);
    const contentType = resp.headers.get('content-type')?.split(';')[0] || 'application/octet-stream';
    const buf = await resp.arrayBuffer();
    const raw = new Uint8Array(buf);
    let stored, isCompressed = false;
    if (compress) {
      const cs = new CompressionStream('gzip');
      const stream = new Blob([raw]).stream().pipeThrough(cs);
      const compressed = new Uint8Array(await new Response(stream).arrayBuffer());
      stored = uint8ToBase64(compressed);
      isCompressed = true;
    } else {
      stored = uint8ToBase64(raw);
    }
    window._installedModules[url] = { source: stored, cellId: cell.id, binary: true, compressed: isCompressed, type: contentType };
    const ratio = isCompressed ? ` \u2192 ${(stored.length / 1024).toFixed(1)} KB compressed` : '';
    display(`installed binary ${url} (${(buf.byteLength / 1024).toFixed(1)} KB${ratio})`);
    return URL.createObjectURL(new Blob([raw], { type: contentType }));
  };

  // ui object — constructed per-cell (closes over cell context)
  const ui = { display, print: display, canvas, table, slider, dropdown, checkbox, textInput };

  // tagged template builtins
  const md = taggedTemplate('md');
  const html = taggedTemplate('html');
  const css = taggedTemplate('css');

  // workshop builtin — slide-out side panel with navigable pages
  const workshop = (pages, opts) => {
    const key = '__workshop__';
    usedWidgets.add(key);
    const useOverlay = !!(opts && opts.overlay);

    // persist page index across re-runs
    if (cell._inputs[key] === undefined) cell._inputs[key] = 0;
    let currentPage = cell._inputs[key];

    // get or create panel DOM
    let panel = document.getElementById('workshopPanel');
    let overlay = document.getElementById('workshopOverlay');
    if (!panel) {
      overlay = document.createElement('div');
      overlay.id = 'workshopOverlay';
      overlay.className = 'workshop-overlay';
      overlay.onclick = () => toggleWorkshop(false);
      document.body.appendChild(overlay);

      panel = document.createElement('div');
      panel.id = 'workshopPanel';
      panel.className = 'workshop-panel';
      document.body.appendChild(panel);
    }

    // side tab attached to the panel edge
    let toggleBtn = document.getElementById('workshopToggle');
    if (!toggleBtn) {
      toggleBtn = document.createElement('button');
      toggleBtn.id = 'workshopToggle';
      toggleBtn.className = 'workshop-tab';
      toggleBtn.title = 'toggle workshop panel';
      toggleBtn.textContent = 'workshop';
      document.body.appendChild(toggleBtn);
      toggleBtn.onclick = () => toggleWorkshop();
    }

    function toggleWorkshop(show) {
      const isOpen = panel.classList.contains('open');
      const shouldOpen = show !== undefined ? show : !isOpen;
      panel.classList.toggle('open', shouldOpen);
      if (useOverlay) overlay.classList.toggle('visible', shouldOpen);
    }

    function renderPage(idx) {
      idx = Math.max(0, Math.min(idx, pages.length - 1));
      currentPage = idx;
      cell._inputs[key] = idx;
      const page = pages[idx];

      panel.innerHTML = '';

      // header with close button
      const header = document.createElement('div');
      header.className = 'workshop-header';
      const title = document.createElement('span');
      title.className = 'workshop-title';
      title.textContent = page.title || `Page ${idx + 1}`;
      header.appendChild(title);
      const closeBtn = document.createElement('button');
      closeBtn.className = 'workshop-close';
      closeBtn.textContent = '\u00d7';
      closeBtn.onclick = () => toggleWorkshop(false);
      header.appendChild(closeBtn);
      panel.appendChild(header);

      // content
      const body = document.createElement('div');
      body.className = 'workshop-body';
      if (page.content instanceof Element) {
        body.appendChild(page.content);
      } else if (page.content instanceof TaggedContent) {
        if (page.content.type === 'md') {
          body.innerHTML = renderMd(page.content.content);
        } else if (page.content.type === 'css') {
          const pre = document.createElement('pre');
          pre.textContent = page.content.content;
          body.appendChild(pre);
        } else {
          body.innerHTML = page.content.content;
        }
      } else {
        body.textContent = String(page.content ?? '');
      }
      panel.appendChild(body);

      // progress pips
      const pips = document.createElement('div');
      pips.className = 'workshop-pips';
      for (let i = 0; i < pages.length; i++) {
        const pip = document.createElement('span');
        pip.className = 'workshop-pip' + (i === idx ? ' active' : '') + (i < idx ? ' done' : '');
        pip.onclick = () => navigate(i);
        pips.appendChild(pip);
      }
      panel.appendChild(pips);

      // nav buttons
      const nav = document.createElement('div');
      nav.className = 'workshop-nav';
      if (idx > 0) {
        const prev = document.createElement('button');
        prev.textContent = '\u2190 prev';
        prev.onclick = () => navigate(idx - 1);
        nav.appendChild(prev);
      }
      const spacer = document.createElement('span');
      spacer.style.flex = '1';
      nav.appendChild(spacer);
      const counter = document.createElement('span');
      counter.className = 'workshop-counter';
      counter.textContent = `${idx + 1} / ${pages.length}`;
      nav.appendChild(counter);
      if (idx < pages.length - 1) {
        const next = document.createElement('button');
        next.className = 'workshop-next';
        next.textContent = 'next \u2192';
        if (page.canAdvance && !page.canAdvance()) {
          next.disabled = true;
          next.title = 'complete the task to continue';
        }
        next.onclick = () => navigate(idx + 1);
        nav.appendChild(next);
      }
      panel.appendChild(nav);

      // fire onEnter
      if (page.onEnter) page.onEnter();
    }

    function navigate(idx) {
      const prevPage = pages[currentPage];
      if (prevPage?.onLeave) prevPage.onLeave();
      renderPage(idx);
    }

    // store re-check function for canAdvance gating
    cell._workshopRecheck = () => {
      const page = pages[currentPage];
      if (!page?.canAdvance) return;
      const nextBtn = panel.querySelector('.workshop-next');
      if (nextBtn) {
        nextBtn.disabled = !page.canAdvance();
      }
    };

    renderPage(currentPage);

    // auto-open on first creation
    if (!panel.classList.contains('open') && !cell._workshopShown) {
      toggleWorkshop(true);
      cell._workshopShown = true;
    }

    // store cleanup so deleteCell can tear down workshop DOM
    cell._workshopCleanup = () => {
      panel.remove();
      overlay.remove();
      toggleBtn.remove();
      cell._workshopRecheck = null;
    };
    // on re-run, just clear the recheck — DOM is reused by ID
    invalidation.then(() => {
      cell._workshopRecheck = null;
    });

    return { goto: navigate, toggle: toggleWorkshop, recheck: cell._workshopRecheck };
  };

  // notebook API — programmatic notebook control
  const notebook = {
    get cells() { return S.cells.map(c => ({ id: c.id, type: c.type, code: c.code })); },
    get scope() { return { ...S.scope }; },
    addCell: (type, code, afterId) => addCell(type, code, afterId),
    scrollTo: (id) => {
      const c = S.cells.find(c => c.id === id);
      if (c?.el) c.el.scrollIntoView({ behavior: 'smooth', block: 'center' });
    },
    focus: (id) => {
      const c = S.cells.find(c => c.id === id);
      if (c?.el) {
        c.el.scrollIntoView({ behavior: 'smooth', block: 'center' });
        const ta = c.el.querySelector('textarea');
        if (ta) ta.focus();
      }
    },
    collapse: (id) => {
      const c = S.cells.find(c => c.id === id);
      if (c?.el) c.el.classList.add('collapsed');
    },
    expand: (id) => {
      const c = S.cells.find(c => c.id === id);
      if (c?.el) c.el.classList.remove('collapsed');
    },
    run: (ids) => runDAG(Array.isArray(ids) ? ids : [ids], true),
  };

  // function caching — reuse compiled function if code/uses/defines unchanged
  const cacheKey = scopeKeys.join(',') + '|' + defNames + '|' + cell.code;

  try {
    let fn;
    if (cell._cacheKey === cacheKey && cell._cachedFn) {
      fn = cell._cachedFn;
    } else {
      const AsyncFunction = Object.getPrototypeOf(async function(){}).constructor;
      const cellName = parseCellName(cell.code);
      const slug = cellName ? '-' + cellName.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/(^-|-$)/g, '') : '';
      fn = new AsyncFunction(
        ...scopeKeys,
        'ui', 'std', 'load', 'install', 'installBinary', 'invalidation', 'print',
        'md', 'html', 'css', 'workshop', 'notebook',
        `"use strict";\n${cell.code}\n\n` +
        `return { ${defNames} };\n` +
        `//# sourceURL=auditable://cell-${cell.id}${slug}.js`
      );
      cell._cachedFn = fn;
      cell._cacheKey = cacheKey;
    }

    const scopeVals = scopeKeys.map(k => S.scope[k]);
    const result = await fn(...scopeVals, ui, std, load, install, installBinary, invalidation, display,
      md, html, css, workshop, notebook);

    // update scope with defined variables
    if (result && typeof result === 'object') {
      cell._lastResult = result;
      for (const [k, v] of Object.entries(result)) {
        if (v !== undefined) S.scope[k] = v;
      }
    }

    cell.el.classList.remove('stale', 'error');
    cell.el.classList.add('fresh');
    setTimeout(() => cell.el.classList.remove('fresh'), 800);

    // remove widgets no longer referenced by code
    for (const w of widgetEl.querySelectorAll('[data-widget-key]')) {
      if (!usedWidgets.has(w.dataset.widgetKey)) {
        delete cell._inputs[w.dataset.widgetKey];
        delete cell._callbacks[w.dataset.widgetKey];
        w.remove();
      }
    }

  } catch (e) {
    cell.error = e.message;
    outputEl.textContent = e.message;
    outputEl.className = 'cell-output error';
    cell.el.classList.remove('stale', 'fresh');
    cell.el.classList.add('error');
  }
}

async function runDAG(dirtyIds, force = false) {
  buildDAG();
  const isAutorun = S.autorun && !force;

  // determine which cells need execution via topo sort
  const runSet = new Set(topoSort(dirtyIds));

  if (window._dagStart) window._dagStart();

  // rebuild scope in document order, only executing cells in runSet
  S.scope = {};
  const poisoned = new Set(); // variable names defined by errored cells
  for (let i = 0; i < S.cells.length; i++) {
    const cell = S.cells[i];

    if (cell.type === 'html') {
      if (runSet.has(cell.id)) {
        // check if any used variable is poisoned
        if (cell.uses && [...cell.uses].some(n => poisoned.has(n))) {
          cell.el.classList.remove('fresh');
          cell.el.classList.add('stale');
        } else {
          renderHtmlCell(cell);
        }
      }
      continue;
    }
    if (cell.type !== 'code') continue;

    // skip norun cells (unless explicitly triggered)
    if (isNorun(cell.code) && !dirtyIds.includes(cell.id)) {
      if (cell._lastResult) {
        for (const [k, v] of Object.entries(cell._lastResult)) {
          if (v !== undefined) S.scope[k] = v;
        }
      }
      continue;
    }

    // skip manual cells unless force or explicitly triggered
    if (!force && isManual(cell.code) && !dirtyIds.includes(cell.id)) {
      if (cell._lastResult) {
        for (const [k, v] of Object.entries(cell._lastResult)) {
          if (v !== undefined) S.scope[k] = v;
        }
      }
      cell.el.classList.add('stale');
      continue;
    }

    // not in run set — restore cached results, skip execution
    if (!runSet.has(cell.id)) {
      if (cell._lastResult) {
        for (const [k, v] of Object.entries(cell._lastResult)) {
          if (v !== undefined) S.scope[k] = v;
        }
      }
      continue;
    }

    // error isolation: if any upstream dependency is poisoned, skip this cell
    if (cell.uses && cell.uses.size > 0) {
      let blocked = false;
      for (const name of cell.uses) {
        if (poisoned.has(name)) { blocked = true; break; }
      }
      if (blocked) {
        const outputEl = cell.el.querySelector('.cell-output');
        if (outputEl && !cell.error) {
          outputEl.textContent = 'blocked by upstream error';
          outputEl.className = 'cell-output error';
        }
        cell.el.classList.remove('stale', 'fresh');
        cell.el.classList.add('error');
        // poison our own defines so downstream also blocks
        if (cell.defines) for (const name of cell.defines) poisoned.add(name);
        continue;
      }
    }

    // value-equality gating: if this cell is a downstream dependent (not directly
    // dirty) and all its input values are unchanged, skip re-execution entirely
    if (!dirtyIds.includes(cell.id) && cell._lastResult && cell.uses && cell.uses.size > 0) {
      let inputsChanged = false;
      for (const name of cell.uses) {
        if (S.scope[name] !== cell._prevInputs?.[name]) { inputsChanged = true; break; }
      }
      if (!inputsChanged) {
        // inputs identical — restore previous results, skip execution
        for (const [k, v] of Object.entries(cell._lastResult)) {
          if (v !== undefined) S.scope[k] = v;
        }
        continue;
      }
    }

    if (window._beforeExec) window._beforeExec(cell);
    await execCell(cell);

    // if the cell errored, poison its defines
    if (cell.error) {
      if (cell.defines) for (const name of cell.defines) poisoned.add(name);
    }

    // snapshot input values for future equality checks
    if (cell.uses) {
      cell._prevInputs = {};
      for (const name of cell.uses) cell._prevInputs[name] = S.scope[name];
    }

    if (window._afterExec && !isAutorun) {
      const jump = window._afterExec(cell, i);
      if (jump >= 0) { i = jump - 1; continue; }
    }
  }

  updateStatus();

  // recheck workshop canAdvance gates after scope changes
  for (const c of S.cells) {
    if (c._workshopRecheck) c._workshopRecheck();
  }
}

async function runAll() {
  const ids = S.cells.filter(c => c.type === 'code' || c.type === 'html').map(c => c.id);
  if (ids.length === 0) return;
  await runDAG(ids, true);
  setMsg('ran all cells', 'ok');
}

// late import to avoid circular dependency at module load time

// -- markdown.js --

// ── MARKDOWN RENDERING (minimal) ──

function renderMd(src) {
  let html = src
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;');

  // headings
  html = html.replace(/^### (.+)$/gm, '<h3>$1</h3>');
  html = html.replace(/^## (.+)$/gm, '<h2>$1</h2>');
  html = html.replace(/^# (.+)$/gm, '<h1>$1</h1>');

  // bold/italic
  html = html.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
  html = html.replace(/\*(.+?)\*/g, '<em>$1</em>');

  // inline code
  html = html.replace(/`(.+?)`/g, '<code>$1</code>');

  // links
  html = html.replace(/\[(.+?)\]\((.+?)\)/g, '<a href="$2">$1</a>');

  // tables — detect pipe-delimited blocks before paragraph wrapping
  html = html.replace(
    /((?:^\|.+\|[ \t]*$\n?)+)/gm,
    (block) => {
      const rows = block.trim().split('\n').map(r =>
        r.trim().replace(/^\|/, '').replace(/\|$/, '').split('|').map(c => c.trim())
      );
      if (rows.length < 2) return block;
      // check for separator row (--- or :--- etc)
      const sep = rows[1];
      if (!sep.every(c => /^:?-{1,}:?$/.test(c))) return block;
      const hdr = rows[0];
      const body = rows.slice(2);
      let t = '<table><thead><tr>' +
        hdr.map(c => `<th>${c}</th>`).join('') +
        '</tr></thead><tbody>';
      for (const row of body) {
        t += '<tr>' + row.map(c => `<td>${c}</td>`).join('') + '</tr>';
      }
      t += '</tbody></table>';
      return t;
    }
  );

  // paragraphs
  html = html.replace(/\n\n/g, '</p><p>');
  if (!html.startsWith('<h') && !html.startsWith('<p') && !html.startsWith('<table')) html = '<p>' + html + '</p>';

  return html;
}

// -- cell-dom.js --

// ── CELL DOM ──

function cssSummary(code) {
  if (!code || !code.trim()) return '';
  const rules = (code.match(/[^{}]+\{/g) || []).length;
  const lines = code.split('\n').length;
  return `${rules} rule${rules !== 1 ? 's' : ''} \u00b7 ${lines} line${lines !== 1 ? 's' : ''}`;
}

function cellHeaderHTML(type, id) {
  return `<div class="cell-header">
    <span class="cell-type">${type}</span>
    <button class="cell-btn cell-convert" onclick="toggleTypePicker(${id})" title="convert type">\u21c4</button>
    <div class="cell-type-picker" data-cell-id="${id}">
      <button onclick="convertCell(${id},'code')">code</button>
      <button onclick="convertCell(${id},'md')">md</button>
      <button onclick="convertCell(${id},'css')">css</button>
      <button onclick="convertCell(${id},'html')">html</button>
    </div>
    <button class="cell-btn cell-insert" onclick="showInsertPicker(${id},'before')" title="insert above">+\u2191</button>
    <button class="cell-btn cell-insert" onclick="showInsertPicker(${id},'after')" title="insert below">+\u2193</button>
    <button class="cell-btn" onclick="moveCell(${id},-1)" title="move up">\u2191</button>
    <button class="cell-btn" onclick="moveCell(${id},1)" title="move down">\u2193</button>
    <button class="cell-btn del" onclick="deleteCellWithUndo(${id})" title="delete">\u00d7</button>
  </div>`;
}

function createCellEl(type, id) {
  const div = document.createElement('div');
  div.className = 'cell';
  div.dataset.id = id;
  div.dataset.type = type;

  if (type === 'code') {
    div.innerHTML = `
      ${cellHeaderHTML('code', id)}
      <div class="cell-code">
        <div class="editor-wrap">
          <div class="line-numbers" aria-hidden="true">1</div>
          <textarea rows="3" spellcheck="false" wrap="off" placeholder="// code"></textarea>
          <div class="highlight-layer" aria-hidden="true"></div>
        </div>
      </div>
      <div class="cell-widgets"></div>
      <div class="cell-output"></div>
    `;

    const ta = div.querySelector('textarea');
    const hl = div.querySelector('.highlight-layer');
    div.querySelector('.cell-type').addEventListener('click', () => div.classList.toggle('collapsed'));
    const ln = div.querySelector('.line-numbers');
    ta.addEventListener('input', () => { highlightCode(ta, hl); onCodeEdit(id); });
    ta.addEventListener('scroll', () => { hl.scrollTop = ta.scrollTop; hl.scrollLeft = ta.scrollLeft; ln.scrollTop = ta.scrollTop; });
    attachAutocomplete(ta, id);
    ta.addEventListener('keydown', handleTab);
    ta.addEventListener('input', autoResize);
  } else if (type === 'css') {
    div.innerHTML = `
      ${cellHeaderHTML('css', id)}
      <div class="cell-css-view"></div>
      <div class="cell-css-edit" style="display:none">
        <div class="editor-wrap">
          <div class="line-numbers" aria-hidden="true">1</div>
          <textarea rows="3" spellcheck="false" wrap="off" placeholder="/* css */"></textarea>
          <div class="highlight-layer" aria-hidden="true"></div>
        </div>
      </div>
    `;

    const cssView = div.querySelector('.cell-css-view');
    const cssEditWrap = div.querySelector('.cell-css-edit');
    const ta = div.querySelector('textarea');
    const hl = div.querySelector('.highlight-layer');
    div.querySelector('.cell-type').addEventListener('click', () => div.classList.toggle('collapsed'));

    cssView.addEventListener('click', () => {
      cssEditWrap.style.display = '';
      cssView.style.display = 'none';
      ta.focus();
      autoResize({ target: ta });
    });

    ta.addEventListener('blur', () => {
      if (S.findActive) return;
      const cell = S.cells.find(c => c.id === id);
      if (cell) {
        cell.code = ta.value;
        cssView.textContent = cssSummary(ta.value);
      }
      cssEditWrap.style.display = 'none';
      cssView.style.display = '';
    });

    const ln = div.querySelector('.line-numbers');
    ta.addEventListener('input', () => { highlightCss(ta, hl); onCssEdit(id); });
    ta.addEventListener('scroll', () => { hl.scrollTop = ta.scrollTop; hl.scrollLeft = ta.scrollLeft; ln.scrollTop = ta.scrollTop; });
    ta.addEventListener('input', autoResize);
    ta.addEventListener('keydown', handleTab);
  } else if (type === 'html') {
    div.innerHTML = `
      ${cellHeaderHTML('html', id)}
      <div class="cell-html-view"></div>
      <div class="cell-html-edit" style="display:none">
        <div class="editor-wrap">
          <div class="line-numbers" aria-hidden="true">1</div>
          <textarea rows="2" spellcheck="false" wrap="off" placeholder="<html template>"></textarea>
          <div class="highlight-layer" aria-hidden="true"></div>
        </div>
      </div>
      <div class="cell-output"></div>
    `;

    const view = div.querySelector('.cell-html-view');
    const editWrap = div.querySelector('.cell-html-edit');
    const ta = div.querySelector('.cell-html-edit textarea');
    const hl = div.querySelector('.highlight-layer');
    div.querySelector('.cell-type').addEventListener('click', () => div.classList.toggle('collapsed'));

    view.addEventListener('click', () => {
      editWrap.style.display = '';
      view.style.display = 'none';
      ta.focus();
      autoResize({ target: ta });
    });

    ta.addEventListener('blur', () => {
      if (S.findActive) return;
      const cell = S.cells.find(c => c.id === id);
      if (cell) {
        cell.code = ta.value;
        renderHtmlCell(cell);
      }
      editWrap.style.display = 'none';
      view.style.display = '';
    });

    const ln = div.querySelector('.line-numbers');
    ta.addEventListener('input', () => { highlightHtml(ta, hl); onHtmlEdit(id); });
    ta.addEventListener('scroll', () => { hl.scrollTop = ta.scrollTop; hl.scrollLeft = ta.scrollLeft; ln.scrollTop = ta.scrollTop; });
    ta.addEventListener('input', autoResize);
    ta.addEventListener('keydown', handleTab);
  } else {
    div.innerHTML = `
      ${cellHeaderHTML('md', id)}
      <div class="cell-md-view"></div>
      <div class="cell-md-edit" style="display:none">
        <textarea rows="2" spellcheck="false" placeholder="markdown"></textarea>
      </div>
    `;

    const view = div.querySelector('.cell-md-view');
    const editWrap = div.querySelector('.cell-md-edit');
    const ta = div.querySelector('.cell-md-edit textarea');
    div.querySelector('.cell-type').addEventListener('click', () => div.classList.toggle('collapsed'));

    view.addEventListener('click', () => {
      editWrap.style.display = '';
      view.style.display = 'none';
      ta.focus();
      autoResize({ target: ta });
    });

    ta.addEventListener('blur', () => {
      if (S.findActive) return;
      const cell = S.cells.find(c => c.id === id);
      if (cell) {
        cell.code = ta.value;
        view.innerHTML = renderMd(ta.value);
      }
      editWrap.style.display = 'none';
      view.style.display = '';
    });

    ta.addEventListener('input', autoResize);
    ta.addEventListener('keydown', handleTab);
  }

  return div;
}

// undoable text replacement — uses execCommand so the browser records it in the undo stack
function replaceRange(ta, from, to, text) {
  ta.focus();
  ta.selectionStart = from;
  ta.selectionEnd = to;
  document.execCommand('insertText', false, text);
}

function handleTab(e) {
  const ta = e.target;
  const start = ta.selectionStart;
  const end = ta.selectionEnd;

  if (e.key === 'Tab') {
    e.preventDefault();

    if (start === end) {
      // no selection — insert 2 spaces
      replaceRange(ta, start, end, '  ');
    } else {
      // selection — indent/unindent lines
      const val = ta.value;
      const lineStart = val.lastIndexOf('\n', start - 1) + 1;
      const lineEnd = val.indexOf('\n', end);
      const blockEnd = lineEnd === -1 ? val.length : lineEnd;
      const block = val.slice(lineStart, blockEnd);
      let newBlock;
      if (e.shiftKey) {
        newBlock = block.replace(/^  /gm, '');
      } else {
        newBlock = block.replace(/^/gm, '  ');
      }
      replaceRange(ta, lineStart, blockEnd, newBlock);
      ta.selectionStart = lineStart;
      ta.selectionEnd = lineStart + newBlock.length;
    }
    ta.dispatchEvent(new Event('input'));
    return;
  }

  // Enter — auto-indent
  if (e.key === 'Enter') {
    e.preventDefault();
    const val = ta.value;
    const before = val.slice(0, start);
    const after = val.slice(end);

    // find current line's leading whitespace
    const lineStart = before.lastIndexOf('\n') + 1;
    const line = before.slice(lineStart);
    const indent = line.match(/^(\s*)/)[1];

    // check if the character before cursor is an opener
    const charBefore = before.trimEnd().slice(-1);
    const extra = '{(['.includes(charBefore) ? '  ' : '';

    // check if the character after cursor is a matching closer
    const charAfter = after.trimStart()[0];
    const pairs = { '{': '}', '(': ')', '[': ']' };
    const needClose = extra && charAfter === pairs[charBefore];

    if (needClose) {
      // cursor between brackets: add indented line + closing line
      const insert = '\n' + indent + extra + '\n' + indent;
      replaceRange(ta, start, end, insert);
      ta.selectionStart = ta.selectionEnd = start + 1 + indent.length + extra.length;
    } else {
      const insert = '\n' + indent + extra;
      replaceRange(ta, start, end, insert);
    }
    ta.dispatchEvent(new Event('input'));
    return;
  }

  // Ctrl+X / Ctrl+C with no selection — whole-line cut/copy
  if ((e.key === 'x' || e.key === 'c') && (e.ctrlKey || e.metaKey) && !e.shiftKey && !e.altKey && start === end) {
    e.preventDefault();
    const val = ta.value;
    const lineStart = val.lastIndexOf('\n', start - 1) + 1;
    let lineEnd = val.indexOf('\n', start);
    if (lineEnd === -1) lineEnd = val.length;
    else lineEnd++; // include the newline

    const lineText = val.slice(lineStart, lineEnd);
    navigator.clipboard.writeText(lineText);

    if (e.key === 'x') {
      replaceRange(ta, lineStart, lineEnd, '');
      ta.dispatchEvent(new Event('input'));
    }
    return;
  }
}

function toggleComment(ta) {
  const val = ta.value;
  const start = ta.selectionStart;
  const end = ta.selectionEnd;

  // find affected line range
  const lineStart = val.lastIndexOf('\n', start - 1) + 1;
  let lineEnd = val.indexOf('\n', end);
  if (lineEnd === -1) lineEnd = val.length;

  const block = val.slice(lineStart, lineEnd);
  const lines = block.split('\n');

  // check if all lines are commented
  const allCommented = lines.every(l => /^\s*\/\//.test(l) || l.trim() === '');

  let newLines;
  if (allCommented) {
    // uncomment: remove first // (and one trailing space if present)
    newLines = lines.map(l => l.replace(/^(\s*)\/\/ ?/, '$1'));
  } else {
    // comment: add // at the minimum indent level
    const indents = lines.filter(l => l.trim()).map(l => l.match(/^(\s*)/)[1].length);
    const minIndent = indents.length ? Math.min(...indents) : 0;
    newLines = lines.map(l => {
      if (l.trim() === '') return l;
      return l.slice(0, minIndent) + '// ' + l.slice(minIndent);
    });
  }

  const newBlock = newLines.join('\n');
  replaceRange(ta, lineStart, lineEnd, newBlock);
  ta.selectionStart = lineStart;
  ta.selectionEnd = lineStart + newBlock.length;
  ta.dispatchEvent(new Event('input'));
}

function updateLineNumbers(ta) {
  const wrap = ta.closest('.editor-wrap');
  if (!wrap) return;
  const gutter = wrap.querySelector('.line-numbers');
  if (!gutter) return;
  const count = ta.value.split('\n').length;
  const lines = [];
  for (let i = 1; i <= count; i++) lines.push(i);
  gutter.textContent = lines.join('\n');
}

function autoResize(e) {
  const ta = e.target || e;
  ta.style.height = 'auto';
  ta.style.height = ta.scrollHeight + 'px';
  // sync highlight layer if present
  const hl = ta.parentElement && ta.parentElement.querySelector('.highlight-layer');
  if (hl) { hl.style.height = ta.style.height; }
  updateLineNumbers(ta);
}

// -- cell-ops.js --

// ── CELL OPERATIONS ──

function addCell(type, code = '', afterId = null, beforeId = null) {
  const id = S.cellId++;
  const cell = {
    id, type, code,
    defines: new Set(),
    uses: new Set(),
    error: null,
    el: createCellEl(type, id)
  };

  const nb = $('#notebook');
  if (beforeId !== null) {
    const idx = S.cells.findIndex(c => c.id === beforeId);
    if (idx >= 0) {
      S.cells.splice(idx, 0, cell);
      S.cells[idx + 1].el.before(cell.el);
    } else {
      S.cells.push(cell);
      nb.appendChild(cell.el);
    }
  } else if (afterId !== null) {
    const idx = S.cells.findIndex(c => c.id === afterId);
    if (idx >= 0) {
      S.cells.splice(idx + 1, 0, cell);
      if (idx < S.cells.length - 2) {
        S.cells[idx + 2].el.before(cell.el);
      } else {
        nb.appendChild(cell.el);
      }
    } else {
      S.cells.push(cell);
      nb.appendChild(cell.el);
    }
  } else {
    S.cells.push(cell);
    nb.appendChild(cell.el);
  }

  // set code
  const ta = cell.el.querySelector('textarea');
  if (code) {
    ta.value = code;
    autoResize({ target: ta });
    if (type === 'code') {
      const hl = cell.el.querySelector('.highlight-layer');
      if (hl) highlightCode(ta, hl);
      if (isManual(code)) cell.el.classList.add('manual');
    }
    if (type === 'md') {
      cell.el.querySelector('.cell-md-view').innerHTML = renderMd(code);
    }
  }

  // CSS cell: create <style> element in <head>
  if (type === 'css') {
    const hl = cell.el.querySelector('.highlight-layer');
    if (hl && code) highlightCss(ta, hl);
    const cssView = cell.el.querySelector('.cell-css-view');
    if (cssView && code) cssView.textContent = cssSummary(code);
    const styleEl = document.createElement('style');
    styleEl.dataset.cellId = id;
    styleEl.textContent = code;
    document.head.appendChild(styleEl);
    cell._styleEl = styleEl;
  }

  // HTML cell: render template
  if (type === 'html' && code) {
    renderHtmlCell(cell);
  }

  if (S.initialized) ta.focus();
  updateStatus();
  notifyDirty();
  return cell;
}

function deleteCell(id) {
  const idx = S.cells.findIndex(c => c.id === id);
  if (idx < 0) return;
  // fire invalidation so cell resources (timers, etc.) clean up
  if (S.cells[idx]._invalidate) { S.cells[idx]._invalidate(); S.cells[idx]._invalidate = null; }
  // tear down workshop DOM if this cell had one
  if (S.cells[idx]._workshopCleanup) { S.cells[idx]._workshopCleanup(); S.cells[idx]._workshopCleanup = null; }
  if (S.cells[idx]._styleEl) {
    S.cells[idx]._styleEl.remove();
    S.cells[idx]._styleEl = null;
  }
  S.cells[idx].el.remove();
  S.cells.splice(idx, 1);
  // re-run to clean scope
  if (S.cells.some(c => c.type === 'code' || c.type === 'html')) runAll();
  updateStatus();
  notifyDirty();
}

function convertCell(id, newType) {
  const cell = S.cells.find(c => c.id === id);
  if (!cell || cell.type === newType) return;

  const code = cell.code;

  // cleanup old type
  if (cell._styleEl) {
    cell._styleEl.remove();
    cell._styleEl = null;
  }

  // create new cell element
  const newEl = createCellEl(newType, id);
  cell.el.replaceWith(newEl);
  cell.el = newEl;
  cell.type = newType;

  // set code
  const ta = newEl.querySelector('textarea');
  ta.value = code;
  cell.code = code;
  autoResize({ target: ta });

  if (newType === 'code') {
    const hl = newEl.querySelector('.highlight-layer');
    if (hl) highlightCode(ta, hl);
  }
  if (newType === 'md') {
    newEl.querySelector('.cell-md-view').innerHTML = renderMd(code);
  }
  if (newType === 'css') {
    const hl = newEl.querySelector('.highlight-layer');
    if (hl) highlightCss(ta, hl);
    const cssView = newEl.querySelector('.cell-css-view');
    if (cssView && code) cssView.textContent = cssSummary(code);
    const styleEl = document.createElement('style');
    styleEl.dataset.cellId = id;
    styleEl.textContent = code;
    document.head.appendChild(styleEl);
    cell._styleEl = styleEl;
  }
  if (newType === 'html') {
    renderHtmlCell(cell);
  }

  selectCell(id);
  updateStatus();
  notifyDirty();
  if (S.cells.some(c => c.type === 'code' || c.type === 'html')) runAll();
}

function moveCell(id, dir) {
  const idx = S.cells.findIndex(c => c.id === id);
  const newIdx = idx + dir;
  if (newIdx < 0 || newIdx >= S.cells.length) return;

  const [cell] = S.cells.splice(idx, 1);
  S.cells.splice(newIdx, 0, cell);

  // re-order DOM
  const nb = $('#notebook');
  nb.innerHTML = '';
  for (const c of S.cells) nb.appendChild(c.el);

  // re-order CSS <style> elements in <head> to match cell order
  for (const c of S.cells) {
    if (c._styleEl) document.head.appendChild(c._styleEl);
  }

  notifyDirty();
  if (S.cells.some(c => c.type === 'code' || c.type === 'html')) runAll();
}

// -- editor.js --

// ── EDITING ──

function notifyDirty() {
  if (S.initialized && window.__AF_BRIDGE__) window.parent.postMessage({ type: 'af:dirty' }, '*');
}

function toggleAutorun() {
  S.autorun = !S.autorun;
  const btn = $('#autorunBtn');
  const btnMobile = document.getElementById('autorunBtnMobile');
  const cls = S.autorun ? 'autorun-on' : 'autorun-off';
  const text = S.autorun ? '\u25b6' : '\u2016';
  btn.textContent = text;
  btn.title = S.autorun ? 'reactive mode \u2014 cells auto-run on edit' : 'manual mode \u2014 only Run All or Ctrl+Enter';
  btn.className = cls;
  if (btnMobile) {
    btnMobile.textContent = text;
    btnMobile.className = cls;
  }
  const sel = $('#setExecMode');
  if (sel) sel.value = S.autorun ? 'reactive' : 'manual';
  setMsg(S.autorun ? 'autorun on' : 'autorun off', 'ok');
}

function onCssEdit(id) {
  const cell = S.cells.find(c => c.id === id);
  if (!cell) return;
  cell.code = cell.el.querySelector('textarea').value;
  if (cell._styleEl) cell._styleEl.textContent = cell.code;
  notifyDirty();
}

function onHtmlEdit(id) {
  const cell = S.cells.find(c => c.id === id);
  if (!cell) return;
  cell.code = cell.el.querySelector('textarea').value;
  cell.el.classList.add('stale');
  notifyDirty();

  if (S.autorun) {
    clearTimeout(S.editTimer);
    S.editTimer = setTimeout(() => runDAG([id], false), 400);
  }
}

function onCodeEdit(id) {
  const cell = S.cells.find(c => c.id === id);
  if (!cell) return;
  const ta = cell.el.querySelector('textarea');
  cell.code = ta.value;

  // update manual state
  if (isManual(cell.code)) {
    cell.el.classList.add('manual');
  } else {
    cell.el.classList.remove('manual');
  }

  cell.el.classList.add('stale');
  notifyDirty();

  if (S.autorun) {
    clearTimeout(S.editTimer);
    S.editTimer = setTimeout(() => runDAG([id], false), 400);
  }
}

// -- settings.js --

// ── SETTINGS ──

// Safe localStorage access — blob URL iframes have opaque origins where localStorage throws
function lsGet(key) { try { return localStorage.getItem(key); } catch { return null; } }
function lsSet(key, val) { try { localStorage.setItem(key, val); } catch {} }
function lsRemove(key) { try { localStorage.removeItem(key); } catch {} }

function toggleSettings() {
  const overlay = $('#settingsOverlay');
  const panel = $('#settingsPanel');
  const open = !overlay.classList.contains('visible');
  overlay.classList.toggle('visible');
  panel.style.display = open ? 'block' : 'none';
  if (open) refreshModuleList();
}

function applyTheme(theme) {
  if (theme === 'light') {
    document.documentElement.classList.add('light');
  } else {
    document.documentElement.classList.remove('light');
  }
  $('#setTheme').value = theme;
}

function applyFontSize(size) {
  size = parseInt(size);
  document.documentElement.style.setProperty('--editor-font-size', size + 'px');
  $('#setFontSize').value = size;
  $('#setFontSizeVal').textContent = size;
}

function applyWidth(w) {
  const nb = $('#notebook');
  nb.style.maxWidth = w;
  $('#setWidth').value = w;
}

function applyLineNumbers(show) {
  const on = show === true || show === 'true' || show === 'on';
  document.documentElement.classList.toggle('hide-line-numbers', !on);
  const el = $('#setLineNumbers');
  if (el) el.value = on ? 'on' : 'off';
}

function applyHeader(mode) {
  const root = document.documentElement;
  root.classList.remove('header-always', 'header-hover', 'header-compact');
  if (mode === 'always') root.classList.add('header-always');
  else if (mode === 'hover') root.classList.add('header-hover');
  else if (mode === 'compact') root.classList.add('header-compact');
  // 'auto' = no class, CSS media queries handle it
  $('#setHeader').value = mode;
}

// ── EXECUTION MODE ──

const __AUDITABLE_DEFAULT_EXEC_MODE__ = 'reactive';
const __AUDITABLE_DEFAULT_RUN_ON_LOAD__ = 'yes';

let _runOnLoad = 'yes';
let _showToggle = 'yes';

function applyExecMode(mode) {
  S.autorun = (mode === 'reactive');
  const btn = $('#autorunBtn');
  const btnMobile = document.getElementById('autorunBtnMobile');
  const cls = S.autorun ? 'autorun-on' : 'autorun-off';
  const text = S.autorun ? '\u25b6' : '\u2016';
  if (btn) { btn.textContent = text; btn.className = cls; btn.title = S.autorun ? 'reactive mode \u2014 cells auto-run on edit' : 'manual mode \u2014 only Run All or Ctrl+Enter'; }
  if (btnMobile) { btnMobile.textContent = text; btnMobile.className = cls; }
  const sel = $('#setExecMode');
  if (sel) sel.value = mode;
}

function applyRunOnLoad(val) {
  _runOnLoad = val;
  const sel = $('#setRunOnLoad');
  if (sel) sel.value = val;
}

function applyShowToggle(val) {
  _showToggle = val;
  document.documentElement.classList.toggle('hide-run-toggle', val === 'no');
  const sel = $('#setShowToggle');
  if (sel) sel.value = val;
}

function applyGlobalExecMode(val) {
  if (val) lsSet('auditable-exec-mode', val);
  else lsRemove('auditable-exec-mode');
}

function applyGlobalRunOnLoad(val) {
  if (val) lsSet('auditable-run-on-load', val);
  else lsRemove('auditable-run-on-load');
}

function resolveExecMode() {
  return lsGet('auditable-exec-mode')
    || $('#setExecMode')?.value
    || __AUDITABLE_DEFAULT_EXEC_MODE__;
}

function resolveRunOnLoad() {
  return lsGet('auditable-run-on-load')
    || _runOnLoad
    || __AUDITABLE_DEFAULT_RUN_ON_LOAD__;
}

function getSettings() {
  const s = {
    theme: document.documentElement.classList.contains('light') ? 'light' : 'dark',
    fontSize: parseInt($('#setFontSize').value),
    width: $('#setWidth').value,
    header: $('#setHeader').value,
    lineNumbers: document.documentElement.classList.contains('hide-line-numbers') ? 'off' : 'on',
    execMode: S.autorun ? 'reactive' : 'manual',
    runOnLoad: _runOnLoad,
    showToggle: _showToggle,
  };
  if (window._sizeCompare) s.sizeCompare = true;
  if (window._sizeCompareRef === 'content') s.sizeCompareRef = 'content';
  return s;
}

function applySettings(s) {
  if (!s) return;
  if (s.theme) applyTheme(s.theme);
  if (s.fontSize) applyFontSize(s.fontSize);
  if (s.width) applyWidth(s.width);
  if (s.header) applyHeader(s.header);
  if (s.lineNumbers) applyLineNumbers(s.lineNumbers);
  if (s.execMode) applyExecMode(s.execMode);
  if (s.runOnLoad) applyRunOnLoad(s.runOnLoad);
  if (s.showToggle) applyShowToggle(s.showToggle);
  // optional: size-compare.js (typeof guards for --lean builds without it)
  if (s.sizeCompare !== undefined && typeof applySizeCompare === 'function') applySizeCompare(s.sizeCompare);
  if (s.sizeCompareRef !== undefined && typeof applySizeCompareRef === 'function') applySizeCompareRef(s.sizeCompareRef);
}

function togglePresent() {
  document.body.classList.toggle('presenting');
}

// ── ABOUT ──

const __AUDITABLE_VERSION__ = '0.3.0';
const __AUDITABLE_RELEASE__ = 'dev';
const __AUDITABLE_BUILD_DATE__ = '2026-02-26';
const __AUDITABLE_BASE_SIZE__ = 254544;

(function() {
  const ver = $('#aboutVersion');
  const build = $('#aboutBuild');
  const rt = $('#aboutRuntime');
  if (ver) ver.textContent = 'auditable v' + __AUDITABLE_VERSION__;
  if (build) build.textContent = (__AUDITABLE_RELEASE__ !== 'dev' ? __AUDITABLE_RELEASE__ + ' \u00b7 ' : '') + 'built ' + __AUDITABLE_BUILD_DATE__;
  if (rt && __AUDITABLE_BASE_SIZE__ > 0) rt.textContent = 'runtime ' + (__AUDITABLE_BASE_SIZE__ / 1024).toFixed(1) + ' KB';
})();

// ── EXECUTION SETTINGS INIT ──

(function() {
  const gm = lsGet('auditable-exec-mode') || '';
  const gr = lsGet('auditable-run-on-load') || '';
  const selGm = $('#setGlobalExecMode');
  const selGr = $('#setGlobalRunOnLoad');
  if (selGm) selGm.value = gm;
  if (selGr) selGr.value = gr;
})();

// ── MODULE MANAGEMENT ──

function formatSize(bytes) {
  return (bytes / 1024).toFixed(1) + ' KB';
}

function renderEntryRow(url, entry) {
  const src = typeof entry === 'string' ? entry : entry.source;
  const cellId = typeof entry === 'string' ? null : entry.cellId;
  const isBinary = typeof entry === 'object' && entry.binary;
  const size = src ? src.length : 0;
  const displaySize = isBinary ? Math.floor(size * 3 / 4) : size;

  const row = document.createElement('div');
  row.className = 'module-row';

  const urlSpan = document.createElement('span');
  urlSpan.className = 'module-url';
  urlSpan.textContent = url;
  urlSpan.title = url;
  row.appendChild(urlSpan);

  const info = document.createElement('span');
  info.className = 'module-info';
  info.textContent = (cellId != null ? 'cell ' + cellId + '  ' : '')
    + (isBinary && entry.compressed ? 'gzipped  ' : '')
    + formatSize(displaySize);
  row.appendChild(info);

  const btn = document.createElement('button');
  btn.className = 'module-remove';
  btn.textContent = '\u00d7';
  btn.title = isBinary ? 'remove binary' : 'remove module';
  btn.onclick = () => removeModule(url);
  row.appendChild(btn);

  return { row, size };
}

function renderSection(list, urls, mods, emptyText) {
  list.innerHTML = '';
  if (urls.length === 0) {
    const empty = document.createElement('div');
    empty.className = 'module-empty';
    empty.textContent = emptyText;
    list.appendChild(empty);
    return 0;
  }
  let totalSize = 0;
  for (const url of urls) {
    const { row, size } = renderEntryRow(url, mods[url]);
    list.appendChild(row);
    totalSize += size;
  }
  const total = document.createElement('div');
  total.className = 'module-total';
  total.textContent = 'total  ' + formatSize(totalSize);
  list.appendChild(total);
  return totalSize;
}

function refreshModuleList() {
  const modList = $('#moduleList');
  const binList = $('#binaryList');
  if (!modList) return;

  const mods = window._installedModules || {};
  const modUrls = [];
  const binUrls = [];
  for (const url of Object.keys(mods)) {
    const entry = mods[url];
    if (typeof entry === 'object' && entry.binary) binUrls.push(url);
    else modUrls.push(url);
  }

  renderSection(modList, modUrls, mods, 'no modules installed');
  if (binList) renderSection(binList, binUrls, mods, 'no binaries installed');
}

function removeModule(url) {
  const entry = window._installedModules?.[url];
  const cellId = entry && typeof entry === 'object' ? entry.cellId : null;
  const kind = entry?.binary ? 'binary' : 'module';
  if (window._installedModules) delete window._installedModules[url];
  if (window._importCache) delete window._importCache[url];
  refreshModuleList();
  updateStatus();
  if (cellId != null) {
    setMsg(`removed ${kind} \u2014 cell ${cellId} will re-install it on next run`, 'warn');
  }
}

// -- update.js --

// ── UPDATE PANEL ──

function toggleUpdate() {
  const overlay = $('#updateOverlay');
  const panel = $('#updatePanel');
  const open = !overlay.classList.contains('visible');
  overlay.classList.toggle('visible');
  panel.style.display = open ? 'block' : 'none';
}

// ── SELF-UPDATE SYSTEM ──

const __AUDITABLE_PUBLIC_KEY__ = '';
const __AUDITABLE_REPO__ = 'endarthur/auditable';
const __AUDITABLE_PAGES_URL__ = 'https://endarthur.github.io/auditable';

// ── SIGNATURE EXTRACTION ──

function extractSignature(html) {
  const m = html.match(/<!--AUDITABLE-SIGNATURE\n([\s\S]*?)\nAUDITABLE-SIGNATURE-->/);
  if (!m) return null;
  try { return JSON.parse(m[1]); } catch { return null; }
}

// ── RUNTIME EXTRACTION ──

function extractRuntime(html) {
  const style = html.match(/<style>([\s\S]*?)<\/style>/);
  const script = html.match(/<script>([\s\S]*?)<\/script>/);
  if (!style || !script) return null;
  return { style: style[1], script: script[1] };
}

// ── DATA EXTRACTION ──

function extractData(html) {
  const data = html.match(/<!--AUDITABLE-DATA\n([\s\S]*?)\nAUDITABLE-DATA-->/);
  const settings = html.match(/<!--AUDITABLE-SETTINGS\n([\s\S]*?)\nAUDITABLE-SETTINGS-->/);
  const modules = html.match(/<!--AUDITABLE-MODULES\n([\s\S]*?)\nAUDITABLE-MODULES-->/);
  const title = html.match(/<title>([^<]*)<\/title>/);
  return {
    data: data ? data[0] : null,
    settings: settings ? settings[0] : null,
    modules: modules ? modules[0] : null,
    title: title ? title[1].replace(/^Auditable\s*\u2014\s*/, '') : 'untitled',
  };
}

// ── SIGNED CONTENT CONSTRUCTION ──

function buildSignedContent(style, script) {
  return 'AUDITABLE-SIGNED-CONTENT\n'
    + style + '\n'
    + 'AUDITABLE-STYLE-SCRIPT-BOUNDARY\n'
    + script;
}

// ── SIGNATURE VERIFICATION (Web Crypto) ──

async function verifySignature(html) {
  const sig = extractSignature(html);
  if (!sig) return { status: 'unsigned' };

  const pubKeyB64 = __AUDITABLE_PUBLIC_KEY__;
  if (!pubKeyB64) return { status: 'no-key', sig };

  // Check if the signature's public key matches ours
  if (sig.pub !== pubKeyB64) return { status: 'wrong-key', sig };

  const runtime = extractRuntime(html);
  if (!runtime) return { status: 'error', message: 'could not extract runtime' };

  const content = buildSignedContent(runtime.style, runtime.script);

  try {
    const pubBytes = Uint8Array.from(atob(pubKeyB64), c => c.charCodeAt(0));
    const key = await crypto.subtle.importKey(
      'raw', pubBytes, { name: 'Ed25519' }, false, ['verify']
    );
    const sigBytes = Uint8Array.from(atob(sig.sig), c => c.charCodeAt(0));
    const msgBytes = new TextEncoder().encode(content);
    const valid = await crypto.subtle.verify('Ed25519', key, sigBytes, msgBytes);
    return { status: valid ? 'valid' : 'invalid', sig };
  } catch (e) {
    if (e.name === 'NotSupportedError') {
      return { status: 'unsupported', message: 'browser does not support Ed25519 verification' };
    }
    return { status: 'error', message: e.message };
  }
}

// ── REASSEMBLE ──

function reassemble(newHtml, oldData) {
  let html = newHtml;

  // Remove any existing data/settings/modules comments (and their description comments) from the new template
  html = html.replace(/(?:<!-- [^\n]*-->\n)?<!--AUDITABLE-DATA\n[\s\S]*?\nAUDITABLE-DATA-->\n?/g, '');
  html = html.replace(/(?:<!-- [^\n]*-->\n)?<!--AUDITABLE-SETTINGS\n[\s\S]*?\nAUDITABLE-SETTINGS-->\n?/g, '');
  html = html.replace(/(?:<!-- [^\n]*-->\n)?<!--AUDITABLE-MODULES\n[\s\S]*?\nAUDITABLE-MODULES-->\n?/g, '');

  // Build data block to inject
  const parts = [];
  if (oldData.data) parts.push(oldData.data);
  if (oldData.modules) parts.push(oldData.modules);
  if (oldData.settings) parts.push(oldData.settings);
  const dataBlock = parts.length ? '\n' + parts.join('\n') + '\n' : '';

  // Inject before the signature comment or before <script>
  const sigIdx = html.indexOf('<!--AUDITABLE-SIGNATURE');
  const scriptIdx = html.indexOf('<script>');
  const insertIdx = sigIdx >= 0 ? sigIdx : scriptIdx;
  if (insertIdx >= 0) {
    html = html.slice(0, insertIdx) + dataBlock + html.slice(insertIdx);
  }

  // Update title
  if (oldData.title && oldData.title !== 'untitled') {
    html = html.replace(/<title>[^<]*<\/title>/, '<title>Auditable \u2014 ' + escHtml(oldData.title) + '</title>');
    // Also update the docTitle input value
    html = html.replace(/(<input[^>]*id="docTitle"[^>]*value=")[^"]*"/, '$1' + escHtml(oldData.title) + '"');
  }

  return html;
}

function escHtml(s) {
  return s.replace(/&/g, '&amp;').replace(/"/g, '&quot;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
}

// ── VERSION COMPARISON ──

function compareVersions(a, b) {
  // compare semver strings like "0.1.0" vs "0.2.0"
  const pa = a.replace(/^v/, '').split('.').map(Number);
  const pb = b.replace(/^v/, '').split('.').map(Number);
  for (let i = 0; i < Math.max(pa.length, pb.length); i++) {
    const na = pa[i] || 0, nb = pb[i] || 0;
    if (na < nb) return -1;
    if (na > nb) return 1;
  }
  return 0;
}

// ── TOOLBAR BADGES ──

function setBadge(id, label, cls) {
  const container = $('#toolbarBadges');
  if (!container) return;
  let el = container.querySelector('[data-badge="' + id + '"]');
  if (!label) {
    if (el) el.remove();
    return;
  }
  if (!el) {
    el = document.createElement('span');
    el.className = 'toolbar-badge toolbar-badge-' + id;
    el.setAttribute('data-badge', id);
    container.appendChild(el);
  }
  el.textContent = label;
  if (cls) el.className = 'toolbar-badge ' + cls;
}

// ── UPDATE STATUS UI ──

function setUpdateStatus(html, cls) {
  const el = $('#updateStatus');
  if (el) {
    el.innerHTML = html;
    el.className = 'update-status' + (cls ? ' update-' + cls : '');
  }
}

// ── CHECK FOR UPDATE (GitHub API) ──

async function checkForUpdate() {
  const btn = $('#updateCheckBtn');
  if (btn) btn.disabled = true;
  setUpdateStatus('checking...', '');

  try {
    // Fetch version.json from GitHub Pages (CORS-friendly)
    const vResp = await fetch(__AUDITABLE_PAGES_URL__ + '/version.json');
    if (!vResp.ok) throw new Error('version check failed: ' + vResp.status);
    const vData = await vResp.json();
    const remoteVersion = vData.version || '';
    const currentRelease = $('#updateRelease')?.textContent || 'dev';

    if (currentRelease === 'dev') {
      // Dev builds always offer the latest release
    } else if (compareVersions(currentRelease, remoteVersion) >= 0) {
      setUpdateStatus('up to date (' + currentRelease + ')', 'ok');
      if (btn) btn.disabled = false;
      return;
    }

    const notes = vData.notes || '';
    const notesHtml = notes
      ? '<div class="update-notes">' + renderMd(notes) + '</div>'
      : '';

    setUpdateStatus(
      '<strong>' + remoteVersion + '</strong> available'
      + notesHtml
      + '<button id="updateApplyBtn" onclick="applyOnlineUpdate()">update</button>',
      'available'
    );

    window._updateVersion = remoteVersion;
  } catch (e) {
    setUpdateStatus('error: ' + escHtml(e.message), 'err');
  }
  if (btn) btn.disabled = false;
}

// ── APPLY ONLINE UPDATE ──

async function applyOnlineUpdate() {
  setUpdateStatus('downloading...', '');

  try {
    // Download signed build from GitHub Pages (CORS-friendly)
    const resp = await fetch(__AUDITABLE_PAGES_URL__ + '/auditable.html');
    if (!resp.ok) throw new Error('download failed: ' + resp.status);
    const newHtml = await resp.text();
    await applyUpdate(newHtml, window._updateVersion);
  } catch (e) {
    setUpdateStatus('error: ' + escHtml(e.message), 'err');
  }
}

// ── APPLY UPDATE (verify + reassemble + download) ──

async function applyUpdate(newHtml, version) {
  setUpdateStatus('verifying signature...', '');

  const result = await verifySignature(newHtml);

  if (result.status === 'invalid') {
    setUpdateStatus('signature verification FAILED \u2014 update rejected', 'err');
    return;
  }

  const warnMessages = {
    'unsigned': 'this file is not signed',
    'no-key': 'no public key configured \u2014 cannot verify signature',
    'wrong-key': 'signed with an unknown key',
  };
  if (warnMessages[result.status]) {
    setUpdateStatus(
      'warning: ' + warnMessages[result.status]
      + '<div class="update-confirm">'
      + '<button onclick="proceedUpdate()">proceed anyway</button>'
      + '<button onclick="cancelUpdate()">cancel</button>'
      + '</div>',
      'warn'
    );
    window._pendingUpdateHtml = newHtml;
    window._pendingUpdateVersion = version;
    return;
  }

  if (result.status === 'unsupported') {
    setUpdateStatus(
      result.message
      + '<div class="update-confirm">'
      + '<button onclick="proceedUpdate()">proceed without verification</button>'
      + '<button onclick="cancelUpdate()">cancel</button>'
      + '</div>',
      'warn'
    );
    window._pendingUpdateHtml = newHtml;
    window._pendingUpdateVersion = version;
    return;
  }

  if (result.status === 'error') {
    setUpdateStatus('verification error: ' + escHtml(result.message), 'err');
    return;
  }

  // Valid signature — proceed
  finishUpdate(newHtml, version);
}

function proceedUpdate() {
  if (window._pendingUpdateHtml) {
    finishUpdate(window._pendingUpdateHtml, window._pendingUpdateVersion);
    delete window._pendingUpdateHtml;
    delete window._pendingUpdateVersion;
  }
}

function cancelUpdate() {
  delete window._pendingUpdateHtml;
  delete window._pendingUpdateVersion;
  setUpdateStatus('update cancelled', '');
}

function finishUpdate(newHtml, version) {
  setUpdateStatus('reassembling...', '');

  // Extract current document as HTML to get data comments
  const currentHtml = document.documentElement.outerHTML;
  // But the data comments are in the body innerHTML at load time; grab from live source
  const bodyHtml = document.body.innerHTML;
  const fullHtml = '<!DOCTYPE html>\n<html>' + document.head.outerHTML + '<body>' + bodyHtml + '</body></html>';

  const oldData = extractData(fullHtml);
  // Override title from live doc
  const titleInput = $('#docTitle');
  if (titleInput) oldData.title = titleInput.value || 'untitled';

  // Build fresh data comments from live state (more reliable than regex from DOM)
  if (S.cells.length) {
    const cellData = S.cells.map(c => ({
      type: c.type,
      code: c.code,
      collapsed: c.el?.classList.contains('collapsed') || undefined
    }));
    oldData.data = '<!-- cell data: JSON array of {type, code, collapsed?} -->\n<!--AUDITABLE-DATA\n' + JSON.stringify(cellData) + '\nAUDITABLE-DATA-->';
  }
  if (window._installedModules && Object.keys(window._installedModules).length) {
    oldData.modules = '<!-- installed modules: base64-encoded JSON mapping URLs to {source, cellId} -->\n<!--AUDITABLE-MODULES\n' + encodeModules(window._installedModules) + '\nAUDITABLE-MODULES-->';
  }
  oldData.settings = '<!-- notebook settings: JSON {theme, fontSize, width, ...} -->\n<!--AUDITABLE-SETTINGS\n' + JSON.stringify(getSettings()) + '\nAUDITABLE-SETTINGS-->';

  const result = reassemble(newHtml, oldData);

  // Offer as download
  const title = (titleInput ? titleInput.value : 'untitled') || 'untitled';
  const blob = new Blob([result], { type: 'text/html' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = title.replace(/[^a-zA-Z0-9_-]/g, '_') + '.html';
  a.click();
  URL.revokeObjectURL(url);

  const vLabel = version ? ' to ' + version : '';
  setUpdateStatus('updated' + vLabel + ' \u2014 saved as ' + a.download, 'ok');
  setMsg('updated' + vLabel, 'ok');
}

// ── UPDATE FROM FILE ──

function updateFromFile() {
  const input = document.createElement('input');
  input.type = 'file';
  input.accept = '.html';
  input.onchange = async () => {
    const file = input.files[0];
    if (!file) return;
    setUpdateStatus('reading file...', '');
    const text = await file.text();

    // Try to extract version from the file
    const vMatch = text.match(/__AUDITABLE_VERSION__\s*=\s*'([^']+)'/);
    const version = vMatch ? 'v' + vMatch[1] : null;

    await applyUpdate(text, version);
  };
  input.click();
}

// ── VERIFY CURRENT DOCUMENT ──

async function verifySelf() {
  const el = $('#updateSigStatus');
  if (!el) return;

  // Reconstruct from live DOM
  const styleEl = document.querySelector('style');
  const scriptEl = document.querySelector('script');
  if (!styleEl || !scriptEl) {
    el.textContent = 'error: no style/script';
    el.className = 'update-sig update-err';
    return;
  }

  const raw = document.body.innerHTML;
  const sigMatch = raw.match(/<!--AUDITABLE-SIGNATURE\n([\s\S]*?)\nAUDITABLE-SIGNATURE-->/);
  if (!sigMatch) {
    el.textContent = 'unsigned';
    el.className = 'update-sig update-warn';
    return;
  }

  let sig;
  try { sig = JSON.parse(sigMatch[1]); } catch {
    el.textContent = 'invalid signature format';
    el.className = 'update-sig update-err';
    return;
  }

  const pubKeyB64 = __AUDITABLE_PUBLIC_KEY__;
  if (!pubKeyB64) {
    el.textContent = 'no public key configured';
    el.className = 'update-sig update-warn';
    return;
  }

  if (sig.pub !== pubKeyB64) {
    el.textContent = 'signed with unknown key';
    el.className = 'update-sig update-warn';
    return;
  }

  const content = buildSignedContent(styleEl.textContent, scriptEl.textContent);

  try {
    const pubBytes = Uint8Array.from(atob(pubKeyB64), c => c.charCodeAt(0));
    const key = await crypto.subtle.importKey(
      'raw', pubBytes, { name: 'Ed25519' }, false, ['verify']
    );
    const sigBytes = Uint8Array.from(atob(sig.sig), c => c.charCodeAt(0));
    const msgBytes = new TextEncoder().encode(content);
    const valid = await crypto.subtle.verify('Ed25519', key, sigBytes, msgBytes);
    if (valid) {
      el.textContent = 'signed \u2713';
      el.className = 'update-sig update-ok';
      setBadge('signed', 'signed', 'toolbar-badge toolbar-badge-signed');
    } else {
      el.textContent = 'signature invalid';
      el.className = 'update-sig update-err';
    }
  } catch (e) {
    if (e.name === 'NotSupportedError') {
      el.textContent = 'Ed25519 not supported';
      el.className = 'update-sig update-warn';
    } else {
      el.textContent = 'error: ' + e.message;
      el.className = 'update-sig update-err';
    }
  }
}

// ── INIT ──
(function() {
  const ver = $('#updateCurrentVer');
  if (ver) ver.textContent = 'v' + __AUDITABLE_VERSION__;
  const rel = $('#updateRelease');
  if (rel) {
    rel.textContent = __AUDITABLE_RELEASE__;
    if (__AUDITABLE_RELEASE__ === 'dev') rel.className = 'update-sig update-warn';
  }
  // Show public key status
  const keyEl = $('#updatePubKey');
  if (keyEl) {
    if (__AUDITABLE_PUBLIC_KEY__) {
      keyEl.textContent = __AUDITABLE_PUBLIC_KEY__.slice(0, 8) + '...';
      keyEl.className = 'update-sig update-key-truncated';
      keyEl.onclick = () => {
        if (keyEl.classList.contains('update-key-expanded')) {
          keyEl.textContent = __AUDITABLE_PUBLIC_KEY__.slice(0, 8) + '...';
          keyEl.classList.remove('update-key-expanded');
          keyEl.classList.add('update-key-truncated');
        } else {
          keyEl.textContent = __AUDITABLE_PUBLIC_KEY__;
          keyEl.classList.remove('update-key-truncated');
          keyEl.classList.add('update-key-expanded');
        }
      };
    } else {
      keyEl.textContent = 'not configured';
      keyEl.className = 'update-sig update-warn';
    }
  }
  // Run self-verification on load
  verifySelf();
})();

// -- save.js --

// ── MODULES ENCODING ──
// base64-encode modules JSON to avoid HTML comment / String.replace issues
// (source code can contain --, $', etc.)

function encodeModules(obj) {
  const b64 = btoa(unescape(encodeURIComponent(JSON.stringify(obj))));
  return b64.replace(/.{1,76}/g, '$&\n').trimEnd();
}

function decodeModules(raw) {
  const b64 = raw.replace(/\s/g, '');
  // detect legacy format: starts with { means raw JSON (not base64)
  if (b64.startsWith('{') || b64.startsWith('%7B')) return JSON.parse(raw);
  return JSON.parse(decodeURIComponent(escape(atob(b64))));
}

// ── SAVE / LOAD ──

// save mode: 'normal' or 'packed'
let _saveMode = 'normal';

function getSaveMode() { return _saveMode; }

function toggleSaveTray() {
  const tray = $('#saveTray');
  if (tray) tray.classList.toggle('open');
}

function setSaveMode(mode) {
  _saveMode = mode;
  // update UI
  const label = $('#saveLabel');
  if (label) label.textContent = mode === 'packed' ? 'pack' : 'save';
  const tray = $('#saveTray');
  if (tray) tray.classList.remove('open');
  // update mobile buttons
  const mobSave = $('#mobileSaveBtn');
  const mobPack = $('#mobilePackBtn');
  if (mobSave) mobSave.classList.toggle('active-mode', mode === 'normal');
  if (mobPack) mobPack.classList.toggle('active-mode', mode === 'packed');
}

function buildNotebookHtml() {
  // serialize current state back to a self-contained HTML file
  const title = $('#docTitle').value || 'untitled';

  // collect cells as data
  const cellData = S.cells.map(c => ({
    type: c.type,
    code: c.code,
    collapsed: c.el.classList.contains('collapsed') || undefined
  }));

  // get the runtime and styles from current document
  const styleEl = document.querySelector('style');
  const styles = styleEl.textContent;

  // get the script
  const scriptEl = document.querySelector('script');
  const script = scriptEl.textContent;

  // read static elements from live DOM
  const helpHTML = $('#helpOverlay').outerHTML;
  const settingsOvHTML = $('#settingsOverlay').outerHTML;
  const settingsPanHTML = $('#settingsPanel').outerHTML.replace(/display:\s*block;?/, '');
  const updateOvHTML = $('#updateOverlay').outerHTML.replace(/\bvisible\b/, '').replace(/class="\s*"/, 'class=""');
  const updatePanEl = $('#updatePanel').cloneNode(true);
  updatePanEl.style.display = '';
  // reset update status and dynamic text
  const uStatus = updatePanEl.querySelector('#updateStatus');
  if (uStatus) { uStatus.innerHTML = ''; uStatus.className = 'update-status'; }
  const updatePanHTML = updatePanEl.outerHTML.replace(/display:\s*block;?/, '');
  const statusbarHTML = document.querySelector('.statusbar').outerHTML;

  // read toolbar from live DOM and patch the title value
  const toolbarEl = document.querySelector('.toolbar').cloneNode(true);
  toolbarEl.querySelector('#docTitle').value = title;
  toolbarEl.querySelector('#toolbarStatus').textContent = '';
  // reset autorun button state to match saved mode
  const autoBtn = toolbarEl.querySelector('#autorunBtn');
  const savedMode = S.autorun ? 'reactive' : 'manual';
  if (autoBtn) {
    autoBtn.className = savedMode === 'reactive' ? 'autorun-on' : 'autorun-off';
    autoBtn.textContent = savedMode === 'reactive' ? '\u25b6' : '\u2016';
  }
  // close overflow and save tray if open
  const overflow = toolbarEl.querySelector('.toolbar-overflow');
  if (overflow) overflow.classList.remove('open');
  const saveTray = toolbarEl.querySelector('#saveTray');
  if (saveTray) saveTray.classList.remove('open');
  // reset save label to default
  const saveLabel = toolbarEl.querySelector('#saveLabel');
  if (saveLabel) saveLabel.textContent = 'save';
  // clear badges (they get set dynamically on load)
  const badges = toolbarEl.querySelector('.toolbar-badges');
  if (badges) badges.innerHTML = '';
  const toolbarHTML = toolbarEl.outerHTML;

  // capture find bar and reset to default state
  const findBarEl = $('#findBar').cloneNode(true);
  findBarEl.style.display = '';
  findBarEl.classList.remove('show-replace');
  findBarEl.querySelector('#findInput').value = '';
  findBarEl.querySelector('#replaceInput').value = '';
  findBarEl.querySelector('#findCount').textContent = '';
  findBarEl.querySelector('#findCaseBtn').classList.remove('active');
  findBarEl.querySelector('#findRegexBtn').classList.remove('active');
  const findBarHTML = findBarEl.outerHTML;

  // build output HTML
  return `<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Auditable \u2014 ${esc(title)}</title>
<style>\n${styles}\n</style>
</head>
<body>

${helpHTML}

${settingsOvHTML}
${settingsPanHTML}

${updateOvHTML}
${updatePanHTML}

${toolbarHTML}

${findBarHTML}

<button class="present-exit" onclick="togglePresent()">\u2715 exit</button>

<div class="notebook" id="notebook">
</div>

${statusbarHTML}

${'<!-- cell data: JSON array of {type, code, collapsed?} -->\n<!--AUDITABLE-DATA\n' + JSON.stringify(cellData) + '\nAUDITABLE-DATA-->'}
${Object.keys(window._installedModules || {}).length ? '<!-- installed modules: base64-encoded JSON mapping URLs to {source, cellId} -->\n<!--AUDITABLE-MODULES\n' + encodeModules(window._installedModules) + '\nAUDITABLE-MODULES-->' : ''}
${'<!-- notebook settings: JSON {theme, fontSize, width, ...} -->\n<!--AUDITABLE-SETTINGS\n' + JSON.stringify(getSettings()) + '\nAUDITABLE-SETTINGS-->'}

<script>\n${script}\n<\/script>
</body>
</html>`;
}

function downloadHtml(html, title) {
  const blob = new Blob([html], { type: 'text/html' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = title.replace(/[^a-zA-Z0-9_-]/g, '_') + '.html';
  a.click();
  URL.revokeObjectURL(url);
  return a.download;
}

function saveNotebook() {
  if (_saveMode === 'packed') {
    savePackedNotebook();
    return;
  }
  const title = $('#docTitle').value || 'untitled';
  const html = buildNotebookHtml();

  // AF bridge: send serialized HTML to parent shell instead of downloading
  if (window.__AF_BRIDGE__) {
    window.parent.postMessage({ type: 'af:serialized', payload: { html } }, '*');
    setMsg('saved', 'ok');
    return;
  }

  const fn = downloadHtml(html, title);
  setMsg('saved ' + fn, 'ok');
}

async function savePackedNotebook() {
  const title = $('#docTitle').value || 'untitled';
  const html = buildNotebookHtml();

  try {
    // compress via CompressionStream
    const blob = new Blob([html]);
    const cs = new CompressionStream('gzip');
    const stream = blob.stream().pipeThrough(cs);
    const compressed = await new Response(stream).arrayBuffer();
    const b64 = btoa(String.fromCharCode(...new Uint8Array(compressed)));
    const b64Lines = b64.replace(/.{1,76}/g, '$&\n');

    const loader = `<!DOCTYPE html>
<!-- packed auditable notebook -->
<!-- the full notebook is gzip-compressed and base64-encoded in the <pre> block below. -->
<!-- on load, the script decodes and decompresses it, then replaces the page contents. -->
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Auditable \u2014 ${esc(title)}</title>
  <style>
    html { background: #1a1a1a }
    body { color: #999; font: 14px/1.5 monospace; display: flex; justify-content: center; align-items: center; height: 100vh; margin: 0 }
    #_d { display: none }
  </style>
</head>
<body>
<div id="_l">unpacking\u2026</div>

<!-- base64-encoded gzip payload (76-char lines) -->
<pre id="_d">
${b64Lines}</pre>

<script>
(async () => {
  // 1. read base64 from the hidden <pre>, strip whitespace from line wrapping
  var b64 = document.getElementById('_d').textContent.replace(/\\s/g, '');

  // 2. decode base64 to binary
  var bytes = Uint8Array.from(atob(b64), c => c.charCodeAt(0));

  // 3. decompress gzip via DecompressionStream
  var stream = new Response(new Blob([bytes])).body.pipeThrough(new DecompressionStream('gzip'));
  var html = await new Response(stream).text();

  // 4. mark as packed (so the notebook knows it was loaded from a packed save)
  html = html.replace('<head>', '<head><meta name="auditable-packed">');

  // 5. replace the current page with the full notebook
  document.open();
  document.write(html);
  document.close();
})().catch(function(e) {
  document.getElementById('_l').textContent = 'error: ' + e.message;
});
<\/script>
</body>
</html>`;


    const fn = downloadHtml(loader, title);
    const kb = (loader.length / 1024).toFixed(0);
    setMsg('packed ' + fn + ' (' + kb + ' KB)', 'ok');
  } catch (e) {
    setMsg('pack failed: ' + e.message, 'err');
  }
}

function esc(s) {
  return s.replace(/"/g, '&quot;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
}

function exportAsTxt() {
  const title = $('#docTitle').value || 'untitled';
  const html = buildNotebookHtml();

  // extract notebook data from HTML
  const dataMatch = html.match(/<!--AUDITABLE-DATA\n([\s\S]*?)\nAUDITABLE-DATA-->/);
  let cells = [];
  if (dataMatch) {
    try { cells = JSON.parse(dataMatch[1]); } catch {}
  }

  const setMatch = html.match(/<!--AUDITABLE-SETTINGS\n([\s\S]*?)\nAUDITABLE-SETTINGS-->/);
  let settings = {};
  if (setMatch) {
    try { settings = JSON.parse(setMatch[1]); } catch {}
  }

  // extract module URLs (without sources — standalone export just records URLs)
  const modMatch = html.match(/<!--AUDITABLE-MODULES\n([\s\S]*?)\nAUDITABLE-MODULES-->/);
  let moduleUrls = [];
  if (modMatch) {
    try {
      const decoded = decodeModules(modMatch[1]);
      moduleUrls = Object.keys(decoded);
    } catch {}
  }

  // build /// formatted text
  const lines = ['/// auditable'];
  if (title && title !== 'untitled') {
    lines.push('/// title: ' + title);
  }
  const defaultSettings = { theme: 'dark', fontSize: 13, width: '860' };
  if (JSON.stringify(settings) !== JSON.stringify(defaultSettings)) {
    lines.push('/// settings: ' + JSON.stringify(settings));
  }
  for (const url of moduleUrls) {
    lines.push('/// module: ' + url);
  }
  for (const cell of cells) {
    lines.push('');
    const flags = cell.collapsed ? ' collapsed' : '';
    lines.push('/// ' + cell.type + flags);
    lines.push(cell.code || '');
  }
  const txt = lines.join('\n') + '\n';

  // download
  if (window.__AF_BRIDGE__) {
    window.parent.postMessage({ type: 'af:download', payload: { data: txt, filename: title.replace(/[^a-zA-Z0-9_-]/g, '_') + '.txt', mime: 'text/plain' } }, '*');
  } else {
    const blob = new Blob([txt], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = title.replace(/[^a-zA-Z0-9_-]/g, '_') + '.txt';
    a.click();
    URL.revokeObjectURL(url);
  }
  setMsg('exported .txt', 'ok');
}

function loadFromEmbed() {
  // look for embedded cell data in HTML comments
  const raw = document.body.innerHTML;

  // restore installed modules first (before cells run)
  const modMatch = raw.match(/<!--AUDITABLE-MODULES\n([\s\S]*?)\nAUDITABLE-MODULES-->/);
  if (modMatch) {
    try {
      window._installedModules = decodeModules(modMatch[1]);
    } catch (e) {
      console.error('Failed to parse installed modules:', e);
    }
  }

  // restore settings
  const setMatch = raw.match(/<!--AUDITABLE-SETTINGS\n([\s\S]*?)\nAUDITABLE-SETTINGS-->/);
  if (setMatch) {
    try {
      applySettings(JSON.parse(setMatch[1]));
    } catch (e) {
      console.error('Failed to parse settings:', e);
    }
  }

  // apply execution mode priority chain (localStorage > notebook > build default)
  const effectiveMode = resolveExecMode();
  const effectiveRun = resolveRunOnLoad();
  if (effectiveMode === 'manual') {
    S.autorun = false;
    const btn = document.getElementById('autorunBtn');
    const btnMobile = document.getElementById('autorunBtnMobile');
    if (btn) { btn.className = 'autorun-off'; btn.textContent = '\u2016'; btn.title = 'manual mode \u2014 only Run All or Ctrl+Enter'; }
    if (btnMobile) { btnMobile.className = 'autorun-off'; btnMobile.textContent = '\u2016'; }
    const sel = document.getElementById('setExecMode');
    if (sel) sel.value = 'manual';
  }

  const match = raw.match(/<!--AUDITABLE-DATA\n([\s\S]*?)\nAUDITABLE-DATA-->/);
  if (match) {
    try {
      const data = JSON.parse(match[1]);
      for (const c of data) {
        const cell = addCell(c.type, c.code);
        if (c.collapsed || isCollapsed(c.code)) cell.el.classList.add('collapsed');
      }
      // run after load (gated on resolved runOnLoad)
      if (effectiveRun === 'yes' && S.cells.some(c => c.type === 'code')) {
        setTimeout(runAll, 50);
      }
      return true;
    } catch (e) {
      console.error('Failed to parse embedded data:', e);
    }
  }
  return false;
}

// -- ui.js --

// ── STATUS ──

function estimateContentSize() {
  let modules = 0;
  for (const v of Object.values(window._installedModules || {})) {
    modules += typeof v === 'string' ? v.length : (v.source?.length || 0);
  }
  const cells = JSON.stringify(S.cells.map(c => ({ type: c.type, code: c.code }))).length;
  return modules + cells;
}

function estimateFileSize() {
  const style = document.querySelector('style')?.textContent.length || 0;
  const script = document.querySelector('script')?.textContent.length || 0;
  return style + script + estimateContentSize() + 2000; // ~2KB HTML boilerplate
}

function updateStatus() {
  const counts = { code: 0, md: 0, css: 0, html: 0 };
  for (const c of S.cells) if (counts[c.type] !== undefined) counts[c.type]++;
  const parts = [];
  for (const [t, n] of Object.entries(counts)) if (n > 0) parts.push(`${n} ${t}`);
  const statusText = parts.join(' \u00b7 ') || '0 cells';
  const totalBytes = estimateFileSize();
  const contentBytes = estimateContentSize();
  const useContent = window._sizeCompareRef === 'content';
  const displayBytes = useContent ? contentBytes : totalBytes;
  const sizeKB = displayBytes >= 1024 ? Math.round(displayBytes / 1024) : 1;
  const sizeText = '~' + sizeKB + ' KB' + (useContent ? ' content' : '');
  $('#statusCells').textContent = statusText;
  const compare = typeof sizeCompare === 'function' ? sizeCompare(displayBytes) : '';
  const sizeEl = document.getElementById('statusSize');
  if (sizeEl) sizeEl.textContent = (compare ? sizeText + ' \u00b7 ' + compare : sizeText) + ' \u00b7 ';
  // mirror to toolbar for mobile
  const toolbarStatus = document.getElementById('toolbarStatus');
  if (toolbarStatus) toolbarStatus.textContent = (compare || sizeText) + ' \u00b7 ' + statusText;
  updateInsertBars();
}

function updateInsertBars() {
  const nb = $('#notebook');
  // remove existing insert bars
  nb.querySelectorAll('.insert-bar').forEach(b => b.remove());

  // add one before first cell and between each pair
  for (let i = 0; i <= S.cells.length; i++) {
    const bar = document.createElement('div');
    bar.className = 'insert-bar';
    const afterId = i > 0 ? S.cells[i - 1].id : null;
    bar.innerHTML = `<div class="insert-btns">
      <button onclick="insertAt(${afterId},'code')">+ code</button>
      <button onclick="insertAt(${afterId},'md')">+ md</button>
      <button onclick="insertAt(${afterId},'css')">+ css</button>
      <button onclick="insertAt(${afterId},'html')">+ html</button>
    </div>`;
    if (i < S.cells.length) {
      S.cells[i].el.before(bar);
    } else {
      nb.appendChild(bar);
    }
  }
}

function insertAt(afterId, type) {
  let cell;
  if (afterId === null && S.cells.length > 0) {
    // insert before first cell
    cell = addCellWithUndo(type, '', null, S.cells[0].id);
  } else {
    cell = addCellWithUndo(type, '', afterId);
  }
  selectCell(cell.id);
  editCell(cell.id);
}

function setMsg(msg, cls = '') {
  const el = $('#statusMsg');
  el.textContent = msg;
  el.className = 'status-msg' + (cls ? ' ' + cls : '');
  if (cls) setTimeout(() => { el.textContent = ''; el.className = 'status-msg'; }, 3000);
}

// -- find.js --

// ── FIND / REPLACE ──

function openFind(showReplace) {
  const bar = $('#findBar');
  bar.style.display = 'flex';
  S.findActive = true;
  if (showReplace) bar.classList.add('show-replace');
  else bar.classList.remove('show-replace');
  const inp = $('#findInput');
  // pre-fill from textarea selection
  const active = document.activeElement;
  if (active && active.tagName === 'TEXTAREA') {
    const sel = active.value.substring(active.selectionStart, active.selectionEnd);
    if (sel && sel.indexOf('\n') === -1) inp.value = sel;
  }
  inp.focus();
  inp.select();
  if (inp.value) findComputeMatches();
}

function closeFind() {
  const bar = $('#findBar');
  bar.style.display = '';
  bar.classList.remove('show-replace');
  S.findActive = false;
  S.findQuery = '';
  S.findMatches = [];
  S.findCurrent = -1;
  $('#findCount').textContent = '';
  // remove all overlays
  document.querySelectorAll('.search-overlay').forEach(el => el.remove());
  document.querySelectorAll('.md-search-wrap').forEach(wrap => {
    const ta = wrap.querySelector('textarea');
    if (ta) wrap.parentNode.insertBefore(ta, wrap);
    wrap.remove();
  });
}

function escapeRegex(s) {
  return s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

function findComputeMatches() {
  const query = $('#findInput').value;
  S.findQuery = query;
  S.findMatches = [];
  if (!query) {
    S.findCurrent = -1;
    findUpdateCount();
    document.querySelectorAll('.search-overlay').forEach(el => el.remove());
    document.querySelectorAll('.md-search-wrap').forEach(wrap => {
      const ta = wrap.querySelector('textarea');
      if (ta) wrap.parentNode.insertBefore(ta, wrap);
      wrap.remove();
    });
    return;
  }
  const flags = S.findCase ? 'g' : 'gi';
  const pattern = S.findRegex ? query : escapeRegex(query);
  let re;
  try { re = new RegExp(pattern, flags); }
  catch (e) {
    S.findCurrent = -1;
    $('#findCount').textContent = 'bad regex';
    return;
  }

  for (const cell of S.cells) {
    let m;
    re.lastIndex = 0;
    while ((m = re.exec(cell.code)) !== null) {
      S.findMatches.push({ cellId: cell.id, index: m.index, length: m[0].length });
      if (m[0].length === 0) re.lastIndex++;  // prevent infinite loop on zero-length match
    }
  }
  // keep findCurrent in range
  if (S.findMatches.length === 0) S.findCurrent = -1;
  else if (S.findCurrent < 0 || S.findCurrent >= S.findMatches.length) S.findCurrent = 0;
  findUpdateOverlays();
  findUpdateCount();
}

function findNext() {
  if (!S.findMatches.length) return;
  S.findCurrent = (S.findCurrent + 1) % S.findMatches.length;
  findUpdateOverlays();
  findUpdateCount();
  findScrollToMatch();
}

function findPrev() {
  if (!S.findMatches.length) return;
  S.findCurrent = (S.findCurrent - 1 + S.findMatches.length) % S.findMatches.length;
  findUpdateOverlays();
  findUpdateCount();
  findScrollToMatch();
}

function findReplace() {
  if (S.findCurrent < 0 || S.findCurrent >= S.findMatches.length) return;
  const match = S.findMatches[S.findCurrent];
  const cell = S.cells.find(c => c.id === match.cellId);
  if (!cell) return;
  const replaceVal = $('#replaceInput').value;
  if (S.findRegex) {
    const flags = S.findCase ? '' : 'i';
    try {
      const re = new RegExp(S.findQuery, flags);
      const matched = cell.code.substring(match.index, match.index + match.length);
      const replaced = matched.replace(re, replaceVal);
      cell.code = cell.code.substring(0, match.index) + replaced + cell.code.substring(match.index + match.length);
    } catch (e) { return; }
  } else {
    cell.code = cell.code.substring(0, match.index) + replaceVal + cell.code.substring(match.index + match.length);
  }
  // update textarea
  const ta = cell.el.querySelector('textarea');
  if (ta) {
    ta.value = cell.code;
    ta.dispatchEvent(new Event('input'));
  }
  findComputeMatches();
}

function findReplaceAll() {
  const query = S.findQuery;
  if (!query) return;
  const replaceVal = $('#replaceInput').value;
  const flags = S.findCase ? 'g' : 'gi';
  const pattern = S.findRegex ? query : escapeRegex(query);
  let re;
  try { re = new RegExp(pattern, flags); }
  catch (e) { return; }
  let count = 0;
  for (const cell of S.cells) {
    const before = cell.code;
    if (S.findRegex) {
      cell.code = cell.code.replace(re, (...args) => { count++; return replaceVal.replace(/\$(\d+)/g, (_, n) => args[+n] != null ? args[+n] : ''); });
    } else {
      cell.code = cell.code.replace(re, () => { count++; return replaceVal; });
    }
    if (cell.code !== before) {
      const ta = cell.el.querySelector('textarea');
      if (ta) {
        ta.value = cell.code;
        ta.dispatchEvent(new Event('input'));
      }
    }
  }
  findComputeMatches();
}

function findUpdateOverlays() {
  // remove existing overlays
  document.querySelectorAll('.search-overlay').forEach(el => el.remove());
  // unwrap md-search-wraps
  document.querySelectorAll('.md-search-wrap').forEach(wrap => {
    const ta = wrap.querySelector('textarea');
    if (ta) wrap.parentNode.insertBefore(ta, wrap);
    wrap.remove();
  });

  if (!S.findQuery || !S.findMatches.length) return;

  // group matches by cellId
  const byCell = {};
  S.findMatches.forEach((m, i) => {
    if (!byCell[m.cellId]) byCell[m.cellId] = [];
    byCell[m.cellId].push({ ...m, globalIdx: i });
  });

  for (const cellId of Object.keys(byCell)) {
    const cell = S.cells.find(c => c.id === parseInt(cellId));
    if (!cell) continue;
    const matches = byCell[cellId];
    const code = cell.code;

    // build overlay content
    let html = '';
    let pos = 0;
    for (const m of matches) {
      // text before match
      html += escHtml(code.substring(pos, m.index));
      const cls = m.globalIdx === S.findCurrent ? 'search-match search-match-current' : 'search-match';
      html += `<mark class="${cls}">${escHtml(code.substring(m.index, m.index + m.length))}</mark>`;
      pos = m.index + m.length;
    }
    html += escHtml(code.substring(pos));

    const overlay = document.createElement('div');

    if (cell.type === 'md') {
      // markdown cells: wrap textarea in md-search-wrap
      overlay.className = 'search-overlay search-overlay-md';
      overlay.innerHTML = html;
      const editWrap = cell.el.querySelector('.cell-md-edit');
      const ta = editWrap.querySelector('textarea');
      let wrap = editWrap.querySelector('.md-search-wrap');
      if (!wrap) {
        wrap = document.createElement('div');
        wrap.className = 'md-search-wrap';
        ta.parentNode.insertBefore(wrap, ta);
        wrap.appendChild(ta);
      }
      wrap.appendChild(overlay);
      wireScrollSync(ta, overlay);
    } else {
      // code, css, html cells: insert in editor-wrap
      overlay.className = 'search-overlay';
      overlay.innerHTML = html;
      let editorWrap;
      if (cell.type === 'code') editorWrap = cell.el.querySelector('.cell-code .editor-wrap');
      else if (cell.type === 'css') editorWrap = cell.el.querySelector('.cell-css-edit .editor-wrap');
      else if (cell.type === 'html') editorWrap = cell.el.querySelector('.cell-html-edit .editor-wrap');
      if (editorWrap) {
        editorWrap.appendChild(overlay);
        const ta = editorWrap.querySelector('textarea');
        if (ta) wireScrollSync(ta, overlay);
      }
    }
  }
}

function wireScrollSync(ta, overlay) {
  if (ta._searchScrollWired) return;
  ta._searchScrollWired = true;
  ta.addEventListener('scroll', () => {
    const ov = ta.closest('.editor-wrap, .md-search-wrap');
    if (!ov) return;
    const so = ov.querySelector('.search-overlay');
    if (so) {
      so.scrollTop = ta.scrollTop;
      so.scrollLeft = ta.scrollLeft;
    }
  });
}

function findUpdateCount() {
  const el = $('#findCount');
  if (!S.findQuery) { el.textContent = ''; return; }
  if (S.findMatches.length === 0) { el.textContent = 'no results'; return; }
  el.textContent = `${S.findCurrent + 1}/${S.findMatches.length}`;
}

function findScrollToMatch() {
  if (S.findCurrent < 0) return;
  const match = S.findMatches[S.findCurrent];
  if (!match) return;
  const cell = S.cells.find(c => c.id === match.cellId);
  if (!cell) return;

  // open editor for non-code cells if needed
  if (cell.type === 'css') {
    const editWrap = cell.el.querySelector('.cell-css-edit');
    const view = cell.el.querySelector('.cell-css-view');
    if (editWrap.style.display === 'none') {
      const ta = editWrap.querySelector('textarea');
      editWrap.style.display = '';
      view.style.display = 'none';
      ta.value = cell.code;
      autoResize({ target: ta });
    }
  } else if (cell.type === 'html') {
    const editWrap = cell.el.querySelector('.cell-html-edit');
    const view = cell.el.querySelector('.cell-html-view');
    if (editWrap.style.display === 'none') {
      const ta = editWrap.querySelector('textarea');
      editWrap.style.display = '';
      view.style.display = 'none';
      ta.value = cell.code;
      autoResize({ target: ta });
    }
  } else if (cell.type === 'md') {
    const editWrap = cell.el.querySelector('.cell-md-edit');
    const view = cell.el.querySelector('.cell-md-view');
    if (editWrap.style.display === 'none') {
      const ta = editWrap.querySelector('textarea');
      editWrap.style.display = '';
      view.style.display = 'none';
      ta.value = cell.code;
      autoResize({ target: ta });
    }
  }

  // uncollapse if collapsed
  cell.el.classList.remove('collapsed');

  // scroll cell into view
  cell.el.scrollIntoView({ block: 'nearest', behavior: 'smooth' });

  // scroll textarea to match line
  const ta = cell.type === 'md'
    ? cell.el.querySelector('.cell-md-edit textarea')
    : cell.type === 'css'
    ? cell.el.querySelector('.cell-css-edit textarea')
    : cell.type === 'html'
    ? cell.el.querySelector('.cell-html-edit textarea')
    : cell.el.querySelector('textarea');
  if (ta) {
    const textBefore = cell.code.substring(0, match.index);
    const lineNum = textBefore.split('\n').length - 1;
    const lineHeight = parseFloat(getComputedStyle(ta).lineHeight) || 20;
    ta.scrollTop = Math.max(0, lineNum * lineHeight - ta.clientHeight / 2);
  }
}

function escHtml(s) {
  return s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
}

// ── EVENT WIRING ──
(function () {
  const findInput = $('#findInput');
  const replaceInput = $('#replaceInput');
  if (!findInput) return;

  findInput.addEventListener('input', () => findComputeMatches());

  findInput.addEventListener('keydown', (e) => {
    if (e.key === 'Enter' && e.shiftKey) { e.preventDefault(); findPrev(); }
    else if (e.key === 'Enter') { e.preventDefault(); findNext(); }
    else if (e.key === 'Escape') { e.preventDefault(); closeFind(); }
  });

  if (replaceInput) {
    replaceInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') { e.preventDefault(); findReplace(); }
      else if (e.key === 'Escape') { e.preventDefault(); closeFind(); }
    });
  }

  const nextBtn = $('#findNextBtn');
  const prevBtn = $('#findPrevBtn');
  const replBtn = $('#findReplaceBtn');
  const replAllBtn = $('#findReplaceAllBtn');
  const caseBtn = $('#findCaseBtn');
  const regexBtn = $('#findRegexBtn');
  const closeBtn = $('#findCloseBtn');

  if (nextBtn) nextBtn.addEventListener('click', findNext);
  if (prevBtn) prevBtn.addEventListener('click', findPrev);
  if (replBtn) replBtn.addEventListener('click', findReplace);
  if (replAllBtn) replAllBtn.addEventListener('click', findReplaceAll);
  if (closeBtn) closeBtn.addEventListener('click', closeFind);
  if (caseBtn) caseBtn.addEventListener('click', () => {
    S.findCase = !S.findCase;
    caseBtn.classList.toggle('active', S.findCase);
    findComputeMatches();
  });
  if (regexBtn) regexBtn.addEventListener('click', () => {
    S.findRegex = !S.findRegex;
    regexBtn.classList.toggle('active', S.findRegex);
    findComputeMatches();
  });

  // live recompute on edit — delegation
  let recomputeTimer = null;
  document.getElementById('notebook').addEventListener('input', (e) => {
    if (!S.findActive) return;
    if (e.target.tagName !== 'TEXTAREA') return;
    clearTimeout(recomputeTimer);
    recomputeTimer = setTimeout(findComputeMatches, 150);
  });
})();

// -- complete.js --

// ── AUTOCOMPLETE ENGINE ──

// well-known property lists for dot completion on builtins
const KNOWN_PROPS = {
  Math: ['abs','acos','asin','atan','atan2','ceil','cos','exp','floor','hypot',
         'log','log2','log10','max','min','pow','random','round','sign','sin',
         'sqrt','tan','trunc','PI','E','LN2','LN10'],
  Array: ['from','isArray','of'],
  Object: ['keys','values','entries','assign','freeze','create','defineProperty','fromEntries','hasOwn'],
  JSON: ['parse','stringify'],
  console: ['log','warn','error','info','table','time','timeEnd','clear'],
  Promise: ['all','allSettled','any','race','resolve','reject'],
  Number: ['isFinite','isInteger','isNaN','parseFloat','parseInt','MAX_SAFE_INTEGER','MIN_SAFE_INTEGER','EPSILON'],
  String: ['fromCharCode','fromCodePoint','raw'],
  ui: ['display','print','canvas','table','slider','dropdown','checkbox','textInput'],
  std: ['csv','fetchJSON','sum','mean','median','extent','bin','linspace',
        'unique','zip','cross','file','download','el','copy','fmt'],
};

// common prototype methods by type
const PROTO_PROPS = {
  array: ['push','pop','shift','unshift','splice','slice','concat','join','reverse',
          'sort','map','filter','reduce','reduceRight','find','findIndex','indexOf',
          'includes','every','some','flat','flatMap','fill','forEach','at','length'],
  string: ['charAt','charCodeAt','codePointAt','concat','endsWith','includes',
           'indexOf','lastIndexOf','match','matchAll','padEnd','padStart','repeat',
           'replace','replaceAll','search','slice','split','startsWith','substring',
           'toLowerCase','toUpperCase','trim','trimEnd','trimStart','at','length'],
  number: ['toFixed','toPrecision','toString','valueOf'],
};

// ── BUILTIN HELP (injected by build.js from src/builtins.json) ──

const BUILTIN_HELP = {
  "ui.display": {
    "sig": "ui.display(...values)",
    "desc": "output values to cell"
  },
  "ui.canvas": {
    "sig": "ui.canvas(w?, h?)",
    "desc": "create/reuse canvas (default 400\u00d7300)"
  },
  "ui.table": {
    "sig": "ui.table(data, columns?)",
    "desc": "render array of objects as table"
  },
  "ui.slider": {
    "sig": "ui.slider(label, default?, {min,max,step,onInput,onChange}?)",
    "desc": "range input \u2014 reactive, or callback via onInput/onChange"
  },
  "ui.dropdown": {
    "sig": "ui.dropdown(label, options, default?, {onInput,onChange}?)",
    "desc": "select menu \u2014 reactive, or callback via onInput/onChange"
  },
  "ui.checkbox": {
    "sig": "ui.checkbox(label, default?, {onInput,onChange}?)",
    "desc": "toggle \u2014 reactive, or callback via onInput/onChange"
  },
  "ui.textInput": {
    "sig": "ui.textInput(label, default?, {onInput,onChange}?)",
    "desc": "text field \u2014 reactive, or callback via onInput/onChange"
  },
  "std.csv": {
    "sig": "std.csv(text, {separator?, typed?}?)",
    "desc": "parse CSV text to array of objects"
  },
  "std.fetchJSON": {
    "sig": "std.fetchJSON(url)",
    "desc": "fetch URL and parse JSON"
  },
  "std.sum": {
    "sig": "std.sum(arr, fn?)",
    "desc": "sum array values"
  },
  "std.mean": {
    "sig": "std.mean(arr, fn?)",
    "desc": "arithmetic mean"
  },
  "std.median": {
    "sig": "std.median(arr, fn?)",
    "desc": "median value"
  },
  "std.extent": {
    "sig": "std.extent(arr, fn?)",
    "desc": "returns [min, max]"
  },
  "std.bin": {
    "sig": "std.bin(arr, n?, fn?)",
    "desc": "histogram bins (default 10)"
  },
  "std.linspace": {
    "sig": "std.linspace(start, stop, n)",
    "desc": "evenly-spaced numbers"
  },
  "std.unique": {
    "sig": "std.unique(arr, fn?)",
    "desc": "unique values with optional key fn"
  },
  "std.zip": {
    "sig": "std.zip(...arrays)",
    "desc": "zip arrays together"
  },
  "std.cross": {
    "sig": "std.cross(...arrays)",
    "desc": "cartesian product"
  },
  "std.file": {
    "sig": "std.file(accept?)",
    "desc": "open file picker"
  },
  "std.download": {
    "sig": "std.download(data, filename, mimeType?)",
    "desc": "download data as file"
  },
  "std.el": {
    "sig": "std.el(tag, attrs?, ...children)",
    "desc": "create DOM element"
  },
  "std.copy": {
    "sig": "std.copy(text)",
    "desc": "copy text to clipboard"
  },
  "std.fmt": {
    "sig": "std.fmt(number, {decimals?, prefix?, suffix?}?)",
    "desc": "format number to string"
  },
  "print": {
    "sig": "print(...values)",
    "desc": "output values to cell (alias for ui.display)"
  },
  "load": {
    "sig": "load(url)",
    "desc": "import ES module (cached). @std, @python supported."
  },
  "install": {
    "sig": "install(url)",
    "desc": "fetch & embed module for offline"
  },
  "invalidation": {
    "sig": "invalidation",
    "desc": "promise \u2014 resolves when cell re-runs"
  },
  "atra": {
    "sig": "atra`...` or atra({imports})`...`",
    "desc": "compile Fortran/Pascal to Wasm (load ext/atra/index.js)"
  }
};

// ── FUZZY MATCHING ──

// returns { score, indices } or null if no match
// indices = positions in `text` that matched characters from `query`
function fuzzyMatch(query, text) {
  const qLen = query.length;
  const tLen = text.length;
  if (qLen === 0) return { score: 0, indices: [] };
  if (qLen > tLen) return null;

  const qLower = query.toLowerCase();
  const tLower = text.toLowerCase();

  // fast check: all query chars exist in text in order
  let qi = 0;
  for (let ti = 0; ti < tLen && qi < qLen; ti++) {
    if (qLower[qi] === tLower[ti]) qi++;
  }
  if (qi < qLen) return null;

  // find best match using a greedy approach that prefers word boundaries
  // word boundaries: start of string, after _ or $, camelCase transitions
  const indices = [];
  qi = 0;

  // first pass: try to match at word boundaries
  const boundaryIndices = [];
  let bqi = 0;
  for (let ti = 0; ti < tLen && bqi < qLen; ti++) {
    if (qLower[bqi] !== tLower[ti]) continue;
    const isBoundary = ti === 0
      || text[ti - 1] === '_' || text[ti - 1] === '$'
      || (text[ti] >= 'A' && text[ti] <= 'Z' && (ti === 0 || text[ti - 1] < 'A' || text[ti - 1] > 'Z'));
    if (isBoundary) {
      boundaryIndices.push(ti);
      bqi++;
    }
  }

  if (bqi === qLen) {
    // all chars matched at boundaries — use those indices
    indices.push(...boundaryIndices);
  } else {
    // fallback: greedy left-to-right match, prefer consecutive runs
    qi = 0;
    for (let ti = 0; ti < tLen && qi < qLen; ti++) {
      if (qLower[qi] === tLower[ti]) {
        indices.push(ti);
        qi++;
      }
    }
  }

  // score the match
  let score = 0;

  // bonus for matching at start of string
  if (indices[0] === 0) score += 10;

  // bonus for consecutive characters
  for (let i = 1; i < indices.length; i++) {
    if (indices[i] === indices[i - 1] + 1) score += 5;
  }

  // bonus for word boundary matches
  for (const idx of indices) {
    if (idx === 0) { score += 3; continue; }
    const prev = text[idx - 1];
    if (prev === '_' || prev === '$') { score += 3; continue; }
    if (text[idx] >= 'A' && text[idx] <= 'Z' && (prev < 'A' || prev > 'Z')) score += 3;
  }

  // bonus for exact case match
  for (let i = 0; i < indices.length; i++) {
    if (query[i] === text[indices[i]]) score += 1;
  }

  // penalty for spread-out matches (large gaps between indices)
  const span = indices[indices.length - 1] - indices[0];
  score -= span * 0.5;

  // slight penalty for longer names (prefer shorter completions)
  score -= tLen * 0.1;

  return { score, indices };
}

// determine cursor context: is it inside a string or comment?
function cursorContext(code, cursor) {
  let i = 0;
  while (i < cursor) {
    const ch = code[i];
    // single-line comment
    if (ch === '/' && code[i + 1] === '/') {
      const nl = code.indexOf('\n', i);
      if (nl === -1 || nl >= cursor) return 'comment';
      i = nl + 1;
      continue;
    }
    // block comment
    if (ch === '/' && code[i + 1] === '*') {
      const end = code.indexOf('*/', i + 2);
      if (end === -1 || end + 2 > cursor) return 'comment';
      i = end + 2;
      continue;
    }
    // single-quoted string
    if (ch === "'") {
      i++;
      while (i < code.length) {
        if (code[i] === '\\') { i += 2; continue; }
        if (code[i] === "'") { i++; break; }
        if (i >= cursor) return 'string';
        i++;
      }
      continue;
    }
    // double-quoted string
    if (ch === '"') {
      i++;
      while (i < code.length) {
        if (code[i] === '\\') { i += 2; continue; }
        if (code[i] === '"') { i++; break; }
        if (i >= cursor) return 'string';
        i++;
      }
      continue;
    }
    // template literal (possibly tagged)
    if (ch === '`') {
      // look back for a tag name: identifier immediately before the backtick,
      // or curried form: identifier(...) before the backtick
      let tagName = null;
      if (i > 0 && typeof window !== 'undefined' && window._taggedLanguages) {
        let te = i;
        let ts = te;
        // direct form: ident`
        while (ts > 0 && /\w/.test(code[ts - 1])) ts--;
        if (ts < te) {
          const candidate = code.slice(ts, te);
          if (window._taggedLanguages[candidate]) tagName = candidate;
        }
        // curried form: ident(...)`
        if (!tagName && code[i - 1] === ')') {
          let p = i - 2, depth = 1;
          while (p >= 0 && depth > 0) {
            if (code[p] === ')') depth++;
            else if (code[p] === '(') depth--;
            p--;
          }
          // p now points one before the (
          let ne = p + 1;
          let ns = ne;
          while (ns > 0 && /\w/.test(code[ns - 1])) ns--;
          if (ns < ne) {
            const candidate = code.slice(ns, ne);
            if (window._taggedLanguages[candidate]) tagName = candidate;
          }
        }
      }

      i++;
      let depth = 0;
      while (i < code.length) {
        if (code[i] === '\\') { i += 2; continue; }
        if (code[i] === '$' && code[i + 1] === '{') {
          depth++;
          i += 2;
          // inside ${...} — this is code context
          let braces = 1;
          while (i < code.length && braces > 0) {
            if (code[i] === '{') braces++;
            else if (code[i] === '}') { braces--; if (braces === 0) break; }
            if (i >= cursor) return 'code'; // inside template expression = code
            i++;
          }
          if (i >= cursor) return 'code';
          i++; // skip closing }
          continue;
        }
        if (code[i] === '`') { i++; break; }
        if (i >= cursor) return tagName ? { type: 'tagged', lang: tagName } : 'string';
        i++;
      }
      continue;
    }
    i++;
  }
  return 'code';
}

// extract the word being typed at cursor position
function extractPrefix(code, cursor) {
  let end = cursor;
  let start = cursor;
  while (start > 0 && /[a-zA-Z0-9_$]/.test(code[start - 1])) start--;
  return { prefix: code.slice(start, end), start };
}

// detect dot access: returns the expression before the dot, or null
function detectDot(code, cursor) {
  // cursor is right after a dot or after dot + partial word
  const before = code.slice(0, cursor);
  // match patterns like "identifier." or "identifier.par" at end
  const m = before.match(/([a-zA-Z_$][\w$]*)\.\s*([a-zA-Z_$][\w$]*)?$/);
  if (m) return { obj: m[1], prefix: m[2] || '' };
  return null;
}

function getPropsForValue(val) {
  if (val == null) return [];
  const props = new Set();
  // own properties
  const own = Object.getOwnPropertyNames(val);
  for (const p of own) {
    if (/^[a-zA-Z_$]/.test(p)) props.add(p);
  }
  // prototype chain (1 level)
  const proto = Object.getPrototypeOf(val);
  if (proto && proto !== Object.prototype) {
    try {
      const pNames = Object.getOwnPropertyNames(proto);
      for (const p of pNames) {
        if (p !== 'constructor' && /^[a-zA-Z_$]/.test(p)) props.add(p);
      }
    } catch {}
  }
  return [...props];
}

function getCompletions(code, cursor, cellId) {
  const ctx = cursorContext(code, cursor);

  // tagged template literal — delegate to extension completions
  if (ctx && typeof ctx === 'object' && ctx.type === 'tagged') {
    const lang = typeof window !== 'undefined' && window._taggedLanguages
      && window._taggedLanguages[ctx.lang];
    if (lang && lang.completions) {
      const { prefix, start } = extractPrefix(code, cursor);
      if (!prefix) return { prefix: '', items: [] };
      const extItems = lang.completions(prefix);
      // score and annotate items
      const items = [];
      for (const it of extItems) {
        const m = fuzzyMatch(prefix, it.text);
        if (m) items.push({ text: it.text, kind: it.kind || 'var', score: m.score, indices: m.indices });
      }
      items.sort((a, b) => b.score - a.score || a.text.localeCompare(b.text));
      return { prefix, items: items.slice(0, 30) };
    }
    return { prefix: '', items: [] };
  }

  if (ctx !== 'code') return { prefix: '', items: [] };

  // check for dot completion
  const dot = detectDot(code, cursor);
  if (dot) {
    const items = [];
    const prefix = dot.prefix;
    let propList = [];

    // check known builtins
    if (KNOWN_PROPS[dot.obj]) {
      propList = KNOWN_PROPS[dot.obj];
    } else if (dot.obj in S.scope) {
      // live value inspection
      const val = S.scope[dot.obj];
      if (val != null) {
        propList = getPropsForValue(val);
        // also add type-based suggestions
        if (Array.isArray(val)) propList = [...new Set([...propList, ...PROTO_PROPS.array])];
        else if (typeof val === 'string') propList = [...new Set([...propList, ...PROTO_PROPS.string])];
        else if (typeof val === 'number') propList = [...new Set([...propList, ...PROTO_PROPS.number])];
      }
    }

    for (const p of propList) {
      if (!prefix) {
        items.push({ text: p, kind: 'prop', score: 0, indices: [] });
        continue;
      }
      const m = fuzzyMatch(prefix, p);
      if (m) items.push({ text: p, kind: 'prop', score: m.score, indices: m.indices });
    }

    items.sort((a, b) => b.score - a.score || a.text.localeCompare(b.text));
    return { prefix, items: items.slice(0, 30) };
  }

  // word prefix completion
  const { prefix, start } = extractPrefix(code, cursor);
  if (!prefix) return { prefix: '', items: [] };

  const items = [];
  const seen = new Set();

  // collect candidates from all sources with their kind
  const candidates = [];

  // 1. scope variables
  for (const name of Object.keys(S.scope)) {
    if (!seen.has(name)) { seen.add(name); candidates.push({ text: name, kind: 'var' }); }
  }

  // 2. own cell defines
  const cell = S.cells.find(c => c.id === cellId);
  if (cell && cell.defines) {
    for (const name of cell.defines) {
      if (!seen.has(name)) { seen.add(name); candidates.push({ text: name, kind: 'def' }); }
    }
  }

  // 3. builtin functions (with help detail)
  for (const name of Object.keys(BUILTIN_HELP)) {
    if (!seen.has(name)) {
      seen.add(name);
      const h = BUILTIN_HELP[name];
      candidates.push({ text: name, kind: 'fn', detail: h.sig });
    }
  }

  // 4. JS builtins
  for (const name of JS_BUILTINS) {
    if (!seen.has(name)) { seen.add(name); candidates.push({ text: name, kind: 'const' }); }
  }

  // 5. JS keywords (min 2 chars to avoid noise)
  if (prefix.length >= 2) {
    for (const name of JS_KEYWORDS) {
      if (!seen.has(name)) { seen.add(name); candidates.push({ text: name, kind: 'kw' }); }
    }
  }

  // fuzzy match all candidates
  for (const c of candidates) {
    if (c.text === prefix) continue; // skip exact match (already typed)
    const m = fuzzyMatch(prefix, c.text);
    if (m) {
      const item = { text: c.text, kind: c.kind, score: m.score, indices: m.indices };
      if (c.detail) item.detail = c.detail;
      items.push(item);
    }
  }

  // sort by score descending, then alphabetical
  items.sort((a, b) => b.score - a.score || a.text.localeCompare(b.text));

  return { prefix, items: items.slice(0, 30) };
}

// ── TEXTAREA ADAPTER ──

const KIND_LABELS = { var: 'v', fn: 'f', kw: 'k', const: 'c', prop: 'p', def: 'd' };

let activeMenu = null;
let activeState = null;
let activeSigHint = null;

function dismissAutocomplete() {
  if (activeMenu) {
    activeMenu.remove();
    activeMenu = null;
    activeState = null;
  }
}

function dismissSigHint() {
  if (activeSigHint) {
    activeSigHint.remove();
    activeSigHint = null;
  }
}

// detect if cursor is inside a function call's arguments for a known builtin
function detectCallContext(code, cursor) {
  // scan backwards from cursor to find an unmatched (
  let depth = 0;
  let i = cursor - 1;
  while (i >= 0) {
    const ch = code[i];
    if (ch === ')') depth++;
    else if (ch === '(') {
      if (depth === 0) {
        // found the opening paren — extract the function name before it (including dot for ui.slider etc.)
        let end = i;
        let start = end - 1;
        while (start >= 0 && /[a-zA-Z0-9_$.]/.test(code[start])) start--;
        start++;
        const fnName = code.slice(start, end);
        if (BUILTIN_HELP[fnName]) {
          // figure out which parameter we're on by counting commas at depth 0
          let paramIdx = 0;
          let d = 0;
          for (let j = i + 1; j < cursor; j++) {
            if (code[j] === '(' || code[j] === '[' || code[j] === '{') d++;
            else if (code[j] === ')' || code[j] === ']' || code[j] === '}') d--;
            else if (code[j] === ',' && d === 0) paramIdx++;
          }
          return { fnName, parenPos: i, paramIdx };
        }
        return null;
      }
      depth--;
    }
    i--;
  }
  return null;
}

function showSigHint(ta) {
  const code = ta.value;
  const cursor = ta.selectionStart;
  if (ta.selectionStart !== ta.selectionEnd) { dismissSigHint(); return; }

  const ctx = cursorContext(code, cursor);
  if (ctx !== 'code') { dismissSigHint(); return; }

  const call = detectCallContext(code, cursor);
  if (!call) { dismissSigHint(); return; }

  const wrap = ta.closest('.editor-wrap');
  if (!wrap) { dismissSigHint(); return; }

  const help = BUILTIN_HELP[call.fnName];
  const pos = measureCursorPos(ta, call.parenPos);

  if (!activeSigHint) {
    activeSigHint = document.createElement('div');
    activeSigHint.className = 'ac-sig-hint';
    wrap.appendChild(activeSigHint);
  } else if (activeSigHint.parentElement !== wrap) {
    activeSigHint.remove();
    wrap.appendChild(activeSigHint);
  }

  // highlight current parameter in the signature
  const sigHtml = highlightParam(help.sig, call.paramIdx);
  activeSigHint.innerHTML = `<span class="ac-sig-fn">${sigHtml}</span><span class="ac-sig-desc">${esc(help.desc)}</span>`;

  const cs = getComputedStyle(ta);
  const padLeft = parseFloat(cs.paddingLeft) || 0;
  const padTop = parseFloat(cs.paddingTop) || 0;
  const lineHeight = parseFloat(cs.lineHeight) || parseFloat(cs.fontSize) * 1.5;

  const left = pos.x + padLeft - ta.scrollLeft;

  // place above the current line; pos.y is bottom of the line
  // so subtract lineHeight (to get top of line) then the hint's own height
  activeSigHint.style.left = left + 'px';
  activeSigHint.style.top = '0px'; // render off-screen first to measure
  activeSigHint.style.visibility = 'hidden';
  const hintH = activeSigHint.offsetHeight || lineHeight;
  activeSigHint.style.visibility = '';

  let top = pos.y + padTop - ta.scrollTop - lineHeight - hintH;

  // if it would go above the editor, show below the current line instead
  const wrapRect = wrap.getBoundingClientRect();
  const taRect = ta.getBoundingClientRect();
  const absTop = taRect.top + top;
  if (absTop < wrapRect.top) {
    top = pos.y + padTop - ta.scrollTop;
  }

  activeSigHint.style.top = top + 'px';
}

function highlightParam(sig, paramIdx) {
  // find the params inside parens
  const openParen = sig.indexOf('(');
  if (openParen === -1) return esc(sig);
  const closeParen = sig.lastIndexOf(')');
  if (closeParen === -1) return esc(sig);

  const before = sig.slice(0, openParen + 1);
  const params = sig.slice(openParen + 1, closeParen);
  const after = sig.slice(closeParen);

  // split on commas (respecting nested braces)
  const parts = [];
  let depth = 0;
  let start = 0;
  for (let i = 0; i < params.length; i++) {
    if (params[i] === '{' || params[i] === '(' || params[i] === '[') depth++;
    else if (params[i] === '}' || params[i] === ')' || params[i] === ']') depth--;
    else if (params[i] === ',' && depth === 0) {
      parts.push(params.slice(start, i));
      start = i + 1;
    }
  }
  parts.push(params.slice(start));

  let html = esc(before);
  for (let i = 0; i < parts.length; i++) {
    if (i > 0) html += esc(',');
    if (i === paramIdx) {
      html += '<span class="ac-sig-active">' + esc(parts[i]) + '</span>';
    } else {
      html += esc(parts[i]);
    }
  }
  html += esc(after);
  return html;
}

function measureCursorPos(ta, cursor) {
  const text = ta.value.substring(0, cursor);
  const lines = text.split('\n');
  const lineNum = lines.length - 1;
  const colText = lines[lineNum];

  // measure column offset using a hidden span
  let measurer = ta._acMeasurer;
  if (!measurer) {
    measurer = document.createElement('span');
    measurer.style.cssText = 'position:absolute;visibility:hidden;white-space:pre;pointer-events:none;';
    document.body.appendChild(measurer);
    ta._acMeasurer = measurer;
  }
  const cs = getComputedStyle(ta);
  measurer.style.font = cs.font;
  measurer.style.fontSize = cs.fontSize;
  measurer.style.fontFamily = cs.fontFamily;
  measurer.style.letterSpacing = cs.letterSpacing;
  measurer.style.tabSize = cs.tabSize;
  measurer.textContent = colText;

  const lineHeight = parseFloat(cs.lineHeight) || parseFloat(cs.fontSize) * 1.5;
  const x = measurer.offsetWidth;
  const y = (lineNum + 1) * lineHeight;

  return { x, y, lineHeight };
}

function highlightMatches(text, indices) {
  if (!indices || !indices.length) return esc(text);
  const set = new Set(indices);
  let html = '';
  let inMatch = false;
  for (let i = 0; i < text.length; i++) {
    if (set.has(i)) {
      if (!inMatch) { html += '<span class="ac-match">'; inMatch = true; }
      html += esc(text[i]);
    } else {
      if (inMatch) { html += '</span>'; inMatch = false; }
      html += esc(text[i]);
    }
  }
  if (inMatch) html += '</span>';
  return html;
}

function renderMenu(items, prefix, selectedIdx) {
  let html = '';
  const max = Math.min(items.length, 30);
  for (let i = 0; i < max; i++) {
    const it = items[i];
    const cls = i === selectedIdx ? 'ac-item active' : 'ac-item';
    const kindCls = 'ac-kind ac-kind-' + it.kind;
    const label = KIND_LABELS[it.kind] || '?';
    const textHtml = highlightMatches(it.text, it.indices);
    const detailHtml = it.detail ? `<span class="ac-detail">${esc(it.detail)}</span>` : '';
    html += `<div class="${cls}" data-index="${i}"><span class="${kindCls}">${label}</span><span class="ac-text">${textHtml}</span>${detailHtml}</div>`;
  }
  return html;
}

function esc(s) {
  return s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
}

function showMenu(ta, cellId) {
  const code = ta.value;
  const cursor = ta.selectionStart;
  if (ta.selectionStart !== ta.selectionEnd) { dismissAutocomplete(); return; }

  const result = getCompletions(code, cursor, cellId);
  if (!result.items.length) { dismissAutocomplete(); return; }

  const wrap = ta.closest('.editor-wrap');
  if (!wrap) { dismissAutocomplete(); return; }

  const pos = measureCursorPos(ta, cursor);

  if (!activeMenu) {
    activeMenu = document.createElement('div');
    activeMenu.className = 'ac-menu';
    wrap.appendChild(activeMenu);
  } else if (activeMenu.parentElement !== wrap) {
    activeMenu.remove();
    wrap.appendChild(activeMenu);
  }

  activeState = {
    items: result.items,
    prefix: result.prefix,
    selected: 0,
    ta,
    cellId,
    cursorStart: cursor - result.prefix.length
  };

  activeMenu.innerHTML = renderMenu(result.items, result.prefix, 0);

  // position: account for padding and scroll
  const cs = getComputedStyle(ta);
  const padLeft = parseFloat(cs.paddingLeft) || 0;
  const padTop = parseFloat(cs.paddingTop) || 0;

  const left = pos.x + padLeft - ta.scrollLeft;
  const top = pos.y + padTop - ta.scrollTop;

  activeMenu.style.left = left + 'px';
  activeMenu.style.top = top + 'px';

  // flip above if it would overflow viewport
  const menuRect = activeMenu.getBoundingClientRect();
  if (menuRect.bottom > window.innerHeight - 20) {
    activeMenu.style.top = (top - pos.lineHeight - activeMenu.offsetHeight) + 'px';
  }

  // mouse interaction
  activeMenu.onmousedown = (e) => {
    e.preventDefault(); // don't blur textarea
    const item = e.target.closest('.ac-item');
    if (item) {
      activeState.selected = parseInt(item.dataset.index);
      acceptCompletion();
    }
  };
}

function updateSelection(idx) {
  if (!activeMenu || !activeState) return;
  activeState.selected = idx;
  const items = activeMenu.querySelectorAll('.ac-item');
  items.forEach((el, i) => el.classList.toggle('active', i === idx));
  // scroll into view
  if (items[idx]) items[idx].scrollIntoView({ block: 'nearest' });
}

function acceptCompletion() {
  if (!activeState) return;
  const { items, selected, ta, prefix, cursorStart } = activeState;
  const item = items[selected];
  if (!item) return;

  ta.focus();
  ta.selectionStart = cursorStart;
  ta.selectionEnd = cursorStart + prefix.length;
  document.execCommand('insertText', false, item.text);

  dismissAutocomplete();
  ta.dispatchEvent(new Event('input'));
}

function attachAutocomplete(textarea, cellId) {
  // keydown handler — must be added BEFORE handleTab so stopImmediatePropagation works
  textarea.addEventListener('keydown', (e) => {
    // Ctrl+Shift+Space — manual signature hint trigger
    if (e.key === ' ' && (e.ctrlKey || e.metaKey) && e.shiftKey) {
      e.preventDefault();
      e.stopImmediatePropagation();
      dismissAutocomplete();
      showSigHint(textarea);
      return;
    }

    if (!activeMenu || !activeState) return;

    if (e.key === 'ArrowDown') {
      e.preventDefault();
      e.stopImmediatePropagation();
      const next = (activeState.selected + 1) % activeState.items.length;
      updateSelection(next);
      return;
    }
    if (e.key === 'ArrowUp') {
      e.preventDefault();
      e.stopImmediatePropagation();
      const prev = (activeState.selected - 1 + activeState.items.length) % activeState.items.length;
      updateSelection(prev);
      return;
    }
    if (e.key === 'Tab' || e.key === 'Enter') {
      e.preventDefault();
      e.stopImmediatePropagation();
      acceptCompletion();
      return;
    }
    if (e.key === 'Escape') {
      e.preventDefault();
      e.stopImmediatePropagation();
      dismissAutocomplete();
      dismissSigHint();
      return;
    }
  });

  // input handler — show/update completions + signature hints
  textarea.addEventListener('input', () => {
    // use a microtask so the value is settled
    Promise.resolve().then(() => {
      showMenu(textarea, cellId);
      // show sig hint only when autocomplete menu is not visible
      if (!activeMenu) showSigHint(textarea);
      else dismissSigHint();
    });
  });

  // dismiss on blur
  textarea.addEventListener('blur', () => {
    // delay so mousedown on menu can fire first
    setTimeout(() => { dismissAutocomplete(); dismissSigHint(); }, 150);
  });

  // dismiss on scroll (position goes stale)
  textarea.addEventListener('scroll', () => {
    dismissAutocomplete();
    dismissSigHint();
  });
}

// -- keyboard.js --

// ── KEYBOARD / SELECTION ──

function addCellWithUndo(type, code, afterId, beforeId) {
  const cell = addCell(type, code, afterId, beforeId);
  S.trash.push({ action: 'add', id: cell.id });
  return cell;
}

function deleteCellWithUndo(id) {
  const idx = S.cells.findIndex(c => c.id === id);
  if (idx < 0) return;
  const cell = S.cells[idx];
  const afterId = idx > 0 ? S.cells[idx - 1].id : null;
  const beforeId = afterId === null && idx < S.cells.length - 1 ? S.cells[idx + 1].id : null;
  S.trash.push({ action: 'delete', type: cell.type, code: cell.code, afterId, beforeId, collapsed: !!cell.el.classList.contains('collapsed') });
  deleteCell(id);
  setMsg('deleted cell (z to undo)', 'ok');
}

function undo() {
  if (!S.trash.length) { setMsg('nothing to undo', ''); return; }
  const entry = S.trash.pop();

  if (entry.action === 'add') {
    // undo add = delete the cell (without pushing to undo stack)
    deleteCell(entry.id);
    setMsg('undid add', 'ok');
  } else {
    // undo delete = restore the cell
    const { type, code, afterId, beforeId, collapsed } = entry;
    const validAfter = afterId !== null && S.cells.find(c => c.id === afterId) ? afterId : null;
    const validBefore = beforeId !== null && S.cells.find(c => c.id === beforeId) ? beforeId : null;
    const newCell = addCell(type, code, validAfter, validBefore);
    if (collapsed) newCell.el.classList.add('collapsed');
    selectCell(newCell.id);
    if ((type === 'code' || type === 'html') && S.cells.some(c => c.type === 'code' || c.type === 'html')) runAll();
    setMsg('restored cell', 'ok');
  }
}

function selectCell(id, scroll) {
  // deselect previous
  $$('.cell.selected').forEach(el => el.classList.remove('selected'));
  S.selectedId = id;
  if (id === null) return;
  const cell = S.cells.find(c => c.id === id);
  if (cell) {
    cell.el.classList.add('selected');
    if (scroll) cell.el.scrollIntoView({ block: 'nearest' });
  }
}

function getEditingCell() {
  const active = document.activeElement;
  if (active && active.tagName === 'TEXTAREA') {
    const cellEl = active.closest('.cell');
    if (cellEl) {
      const id = parseInt(cellEl.dataset.id);
      return S.cells.find(c => c.id === id) || null;
    }
  }
  return null;
}

function editCell(id) {
  const cell = S.cells.find(c => c.id === id);
  if (!cell) return;
  selectCell(id);

  if (cell.type === 'md') {
    // open md editor
    const view = cell.el.querySelector('.cell-md-view');
    const editWrap = cell.el.querySelector('.cell-md-edit');
    const ta = cell.el.querySelector('.cell-md-edit textarea');
    editWrap.style.display = '';
    view.style.display = 'none';
    ta.value = cell.code;
    ta.focus();
    autoResize({ target: ta });
  } else if (cell.type === 'css') {
    // open css editor
    const view = cell.el.querySelector('.cell-css-view');
    const editWrap = cell.el.querySelector('.cell-css-edit');
    const ta = cell.el.querySelector('.cell-css-edit textarea');
    editWrap.style.display = '';
    view.style.display = 'none';
    ta.value = cell.code;
    ta.focus();
    autoResize({ target: ta });
  } else if (cell.type === 'html') {
    // open html editor
    const view = cell.el.querySelector('.cell-html-view');
    const editWrap = cell.el.querySelector('.cell-html-edit');
    const ta = cell.el.querySelector('.cell-html-edit textarea');
    editWrap.style.display = '';
    view.style.display = 'none';
    ta.value = cell.code;
    ta.focus();
    autoResize({ target: ta });
  } else {
    cell.el.querySelector('textarea').focus();
  }
}

function exitEdit() {
  const active = document.activeElement;
  if (active && active.tagName === 'TEXTAREA') {
    active.blur();
  }
}

function runSelected() {
  if (S.selectedId === null && S.cells.length) selectCell(S.cells[0].id);
  const cell = S.cells.find(c => c.id === S.selectedId);
  if (!cell) return;
  if (cell.type === 'code') {
    cell.code = cell.el.querySelector('.cell-code textarea').value;
    runDAG([cell.id]);
  } else if (cell.type === 'html') {
    renderHtmlCell(cell);
  }
}

// ── MOBILE TRAY TOGGLES ──

function closeAllTrays() {
  document.querySelectorAll('.action-add-tray.open, .action-more-tray.open, .cell-type-picker.open, .cell-insert-picker.open').forEach(el => el.classList.remove('open'));
}

function toggleToolbarMenu() {
  const menu = document.querySelector('.toolbar-overflow');
  if (!menu) return;
  menu.classList.toggle('open');
}

function toggleAddTray() {
  const tray = document.querySelector('.action-add-tray');
  if (!tray) return;
  const wasOpen = tray.classList.contains('open');
  closeAllTrays();
  if (!wasOpen) tray.classList.add('open');
}

function toggleMoreTray() {
  const tray = document.querySelector('.action-more-tray');
  if (!tray) return;
  const wasOpen = tray.classList.contains('open');
  closeAllTrays();
  if (!wasOpen) tray.classList.add('open');
}

function showInsertPicker(id, dir) {
  closeAllTrays();
  const cell = S.cells.find(c => c.id === id);
  if (!cell) return;
  document.querySelectorAll('.cell-insert-picker').forEach(el => el.remove());
  const picker = document.createElement('div');
  picker.className = 'cell-insert-picker open';
  let afterId;
  if (dir === 'after') {
    afterId = id;
  } else {
    const idx = S.cells.findIndex(c => c.id === id);
    afterId = idx > 0 ? S.cells[idx - 1].id : null;
  }
  picker.innerHTML = ['code', 'md', 'css', 'html'].map(t =>
    `<button onclick="insertAt(${afterId !== null ? afterId : 'null'},'${t}');this.closest('.cell-insert-picker').remove()">${t}</button>`
  ).join('');
  const header = cell.el.querySelector('.cell-header');
  header.style.position = 'relative';
  picker.style.top = '100%';
  picker.style.left = dir === 'before' ? '0' : 'auto';
  picker.style.right = dir === 'after' ? '0' : 'auto';
  header.appendChild(picker);
}

function toggleTypePicker(id) {
  closeAllTrays();
  const picker = document.querySelector(`.cell-type-picker[data-cell-id="${id}"]`);
  if (picker) picker.classList.toggle('open');
}

function collapseAll() {
  S.cells.forEach(c => c.el.classList.add('collapsed'));
  setMsg('collapsed all', 'ok');
}

function expandAll() {
  S.cells.forEach(c => c.el.classList.remove('collapsed'));
  setMsg('expanded all', 'ok');
}

function newNotebook() {
  if (!confirm('Clear all cells?')) return;
  while (S.cells.length) {
    const cell = S.cells[0];
    if (cell._styleEl) { cell._styleEl.remove(); cell._styleEl = null; }
    cell.el.remove();
    S.cells.shift();
  }
  S.scope = {};
  S.selectedId = null;
  S.clipboard = null;
  S.trash = [];
  $('#docTitle').value = 'untitled';
  updateStatus();
  setMsg('new notebook', 'ok');
}

function runSelectedCell() { runSelectedAndAdvance(); }

function runSelectedAndAdvance() {
  runSelected();
  if (S.selectedId === null) return;
  // respect goto target if set
  const gotoIdx = window._lastGotoTarget;
  if (gotoIdx != null && gotoIdx >= 0 && gotoIdx < S.cells.length) {
    editCell(S.cells[gotoIdx].id);
  } else {
    const idx = S.cells.findIndex(c => c.id === S.selectedId);
    if (idx < S.cells.length - 1) {
      editCell(S.cells[idx + 1].id);
    } else {
      const newCell = addCellWithUndo('code', '', S.selectedId);
      selectCell(newCell.id);
    }
  }
}

function navigateCell(dir) {
  if (!S.cells.length) return;
  if (S.selectedId === null) {
    selectCell(S.cells[0].id, true);
    return;
  }
  const idx = S.cells.findIndex(c => c.id === S.selectedId);
  const newIdx = idx + dir;
  if (newIdx >= 0 && newIdx < S.cells.length) {
    selectCell(S.cells[newIdx].id, true);
  }
}

document.addEventListener('keydown', (e) => {
  // find bar shortcuts (must be before edit/command branches)
  if ((e.key === 'f') && (e.ctrlKey || e.metaKey) && !e.altKey) {
    e.preventDefault(); openFind(false); return;
  }
  if ((e.key === 'h') && (e.ctrlKey || e.metaKey) && !e.altKey) {
    e.preventDefault(); openFind(true); return;
  }
  if (e.key === 'Escape' && S.findActive) {
    e.preventDefault(); closeFind(); return;
  }

  const editing = getEditingCell();

  if (editing) {
    // ── EDIT MODE ──
    if (e.key === '/' && (e.ctrlKey || e.metaKey)) {
      e.preventDefault();
      toggleComment(document.activeElement);
      return;
    }
    if (e.key === 'Escape') {
      e.preventDefault();
      exitEdit();
      selectCell(editing.id);
      return;
    }
    if (e.key === 'Enter' && e.ctrlKey) {
      e.preventDefault();
      editing.code = editing.el.querySelector('textarea').value;
      if (editing.type === 'code') runDAG([editing.id], true);
      return;
    }
    if (e.key === 'Enter' && e.shiftKey) {
      e.preventDefault();
      editing.code = editing.el.querySelector('textarea').value;
      if (editing.type === 'code') runDAG([editing.id], true);
      // advance — respect goto target if set
      const gotoIdx = window._lastGotoTarget;
      if (gotoIdx != null && gotoIdx >= 0 && gotoIdx < S.cells.length) {
        editCell(S.cells[gotoIdx].id);
      } else {
        const idx = S.cells.findIndex(c => c.id === editing.id);
        if (idx < S.cells.length - 1) {
          editCell(S.cells[idx + 1].id);
        } else {
          const newCell = addCellWithUndo('code', '', editing.id);
          selectCell(newCell.id);
          editCell(newCell.id);
        }
      }
      return;
    }
  } else {
    // ── COMMAND MODE ──
    // ignore if typing in any input field (title, find bar, etc.)
    if (document.activeElement && (document.activeElement.tagName === 'INPUT' || document.activeElement.id === 'docTitle')) return;

    // let browser shortcuts through (Ctrl+J downloads, etc.)
    if (e.ctrlKey || e.metaKey || e.altKey) return;

    if (e.key === 'ArrowUp' || e.key === 'k') {
      e.preventDefault();
      navigateCell(-1);
      return;
    }
    if (e.key === 'ArrowDown' || e.key === 'j') {
      e.preventDefault();
      navigateCell(1);
      return;
    }
    if (e.key === 'Enter') {
      e.preventDefault();
      if (S.selectedId !== null) editCell(S.selectedId);
      return;
    }
    if (e.key === 'a') {
      e.preventDefault();
      const newCell = addCellWithUndo('code', '', null, S.selectedId);
      selectCell(newCell.id);
      editCell(newCell.id);
      return;
    }
    if (e.key === 'b') {
      e.preventDefault();
      const newCell = addCellWithUndo('code', '', S.selectedId);
      selectCell(newCell.id);
      editCell(newCell.id);
      return;
    }
    if (e.key === 'd') {
      e.preventDefault();
      if (S.pendingD) {
        // dd — delete
        clearTimeout(S.pendingDTimer);
        S.pendingD = false;
        if (S.selectedId !== null) {
          const idx = S.cells.findIndex(c => c.id === S.selectedId);
          const nextId = idx < S.cells.length - 1 ? S.cells[idx + 1].id
                       : idx > 0 ? S.cells[idx - 1].id : null;
          deleteCellWithUndo(S.selectedId);
          if (nextId !== null) selectCell(nextId);
        }
      } else {
        S.pendingD = true;
        S.pendingDTimer = setTimeout(() => { S.pendingD = false; }, 600);
      }
      return;
    }
    if (e.key !== 'd' && S.pendingD) { S.pendingD = false; clearTimeout(S.pendingDTimer); }
    if (e.key === 'z') {
      e.preventDefault();
      undo();
      return;
    }
    if (e.key === 'c' && S.selectedId !== null) {
      e.preventDefault();
      const cell = S.cells.find(c => c.id === S.selectedId);
      if (cell) S.clipboard = { type: cell.type, code: cell.code };
      setMsg('copied cell', 'ok');
      return;
    }
    if (e.key === 'v' && S.clipboard) {
      e.preventDefault();
      const newCell = addCellWithUndo(S.clipboard.type, S.clipboard.code, S.selectedId);
      selectCell(newCell.id);
      if (S.clipboard.type === 'code' && S.cells.some(c => c.type === 'code')) runAll();
      return;
    }
    if (e.key === 'x' && S.selectedId !== null) {
      // cut = copy + delete
      e.preventDefault();
      const cell = S.cells.find(c => c.id === S.selectedId);
      if (cell) S.clipboard = { type: cell.type, code: cell.code };
      const idx = S.cells.findIndex(c => c.id === S.selectedId);
      const nextId = idx < S.cells.length - 1 ? S.cells[idx + 1].id
                   : idx > 0 ? S.cells[idx - 1].id : null;
      deleteCellWithUndo(S.selectedId);
      if (nextId !== null) selectCell(nextId);
      setMsg('cut cell', 'ok');
      return;
    }
    if (e.key === 'h' && S.selectedId !== null) {
      e.preventDefault();
      const cell = S.cells.find(c => c.id === S.selectedId);
      if (cell) cell.el.classList.toggle('collapsed');
      return;
    }
    if (e.key === 'l') {
      e.preventDefault();
      const on = getSettings().lineNumbers === 'on';
      applyLineNumbers(!on);
      setMsg(on ? 'line numbers off' : 'line numbers on', 'ok');
      return;
    }
    if (e.key === 'p') {
      e.preventDefault();
      togglePresent();
      return;
    }
    if (e.key === 'm' && S.selectedId !== null) {
      e.preventDefault();
      convertCell(S.selectedId, 'md');
      return;
    }
    if (e.key === 'y' && S.selectedId !== null) {
      e.preventDefault();
      convertCell(S.selectedId, 'code');
      return;
    }
    if (e.key === 's' && S.selectedId !== null) {
      e.preventDefault();
      convertCell(S.selectedId, 'css');
      return;
    }
    if (e.key === 't' && S.selectedId !== null) {
      e.preventDefault();
      convertCell(S.selectedId, 'html');
      return;
    }
  }

  // global: F1 help overlay
  if (e.key === 'F1') {
    e.preventDefault();
    $('#helpOverlay').classList.toggle('visible');
    return;
  }

  // close presentation mode on Escape
  if (e.key === 'Escape' && document.body.classList.contains('presenting')) {
    togglePresent();
    e.stopImmediatePropagation();
    return;
  }

  // close settings on Escape if visible
  if (e.key === 'Escape' && $('#settingsOverlay').classList.contains('visible')) {
    toggleSettings();
    e.stopImmediatePropagation();
    return;
  }

  // close help on Escape if visible
  if (e.key === 'Escape' && $('#helpOverlay').classList.contains('visible')) {
    $('#helpOverlay').classList.remove('visible');
    e.stopImmediatePropagation();
    return;
  }

  // global: Ctrl+S / Cmd+S
  if (e.key === 's' && (e.ctrlKey || e.metaKey)) {
    e.preventDefault();
    saveNotebook();
  }
});

// click to dismiss help
$('#helpOverlay').addEventListener('click', (e) => {
  if (e.target === $('#helpOverlay')) $('#helpOverlay').classList.remove('visible');
});

// click to select + close trays
document.addEventListener('click', (e) => {
  // close action trays if clicking outside their wrapper (wrapper = parent div with tray + button)
  const addTray = document.querySelector('.action-add-tray');
  const moreTray = document.querySelector('.action-more-tray');
  if (addTray && addTray.classList.contains('open') && !addTray.parentElement.contains(e.target)) {
    addTray.classList.remove('open');
  }
  if (moreTray && moreTray.classList.contains('open') && !moreTray.parentElement.contains(e.target)) {
    moreTray.classList.remove('open');
  }
  // close cell type pickers if clicking outside
  if (!e.target.closest('.cell-type-picker') && !e.target.closest('.cell-type')) {
    document.querySelectorAll('.cell-type-picker.open').forEach(el => el.classList.remove('open'));
  }
  // close cell insert pickers if clicking outside
  if (!e.target.closest('.cell-insert-picker')) {
    document.querySelectorAll('.cell-insert-picker').forEach(el => el.remove());
  }
  // close toolbar overflow menu if clicking outside
  const tbOverflow = document.querySelector('.toolbar-overflow');
  if (tbOverflow && tbOverflow.classList.contains('open') && !tbOverflow.contains(e.target)) {
    tbOverflow.classList.remove('open');
  }
  // close save tray if clicking outside
  const saveTray = document.getElementById('saveTray');
  if (saveTray && saveTray.classList.contains('open') && !saveTray.parentElement.contains(e.target)) {
    saveTray.classList.remove('open');
  }

  const cellEl = e.target.closest('.cell');
  if (cellEl) {
    const id = parseInt(cellEl.dataset.id);
    selectCell(id);
  }
});

// late import to avoid circular dependency at module load time

// -- goto.js --

// ── GOTO ── @optional

function parseGoto(code) {
  const m = code.match(/^\s*\/\/\s*%goto\b\s*(.*)/m);
  if (!m) return null;
  return m[1].trim() || '';
}

const MAX_VISITS = 1000;
let visits = {};

window._dagStart = function() {
  visits = {};
  window._lastGotoTarget = null;
};

window._beforeExec = function(cell) {
  const target = parseGoto(cell.code);
  if (target !== null) {
    S.scope.__goto = target;
    cell.defines.add('__goto');
  } else {
    delete S.scope.__goto;
  }
};

window._afterExec = function(cell, index) {
  const gotoTarget = S.scope.__goto;
  delete S.scope.__goto;
  window._lastGotoTarget = null;

  if (!gotoTarget) return -1;

  // resolve by cellName
  const targetIdx = S.cells.findIndex(c => parseCellName(c.code) === gotoTarget);
  if (targetIdx < 0) {
    const out = cell.el.querySelector('.cell-output');
    if (out) {
      out.appendChild(document.createTextNode('\ngoto: cell \u201c' + gotoTarget + '\u201d not found'));
      out.classList.add('error');
    }
    return -1;
  }

  // loop protection
  const key = index + ':' + targetIdx;
  visits[key] = (visits[key] || 0) + 1;
  if (visits[key] > MAX_VISITS) {
    const out = cell.el.querySelector('.cell-output');
    if (out) {
      out.appendChild(document.createTextNode('\ngoto: loop limit reached (' + MAX_VISITS + ' iterations)'));
      out.classList.add('error');
    }
    return -1;
  }

  window._lastGotoTarget = targetIdx;
  return targetIdx;
};

// -- size-compare.js --

// ── SIZE COMPARISON ── @optional

const SIZE_MEDIA = [
  [4096, 'an Atari 2600 cartridge'],
  [49152, 'a ZX Spectrum tape'],
  [73728, 'Apollo AGC rope memory'],
  [81920, 'an 8\u2033 floppy (SS/SD)'],
  [262144, 'an NES cartridge'],
  [368640, 'a 5.25\u2033 floppy (DS/DD)'],
  [737280, 'a 3.5\u2033 floppy (DS/DD)'],
  [1228800, 'a 5.25\u2033 floppy (DS/HD)'],
  [1474560, 'a 3.5\u2033 floppy (DS/HD)'],
];

function sizeCompare(bytes) {
  if (!window._sizeCompare) return '';
  for (const [size, name] of SIZE_MEDIA) {
    if (bytes <= size) return 'fits on ' + name;
  }
  const n = Math.ceil(bytes / 1474560);
  return n + '\u00d7 3.5\u2033 floppies';
}

function applySizeCompare(val) {
  const on = val === true || val === 'true' || val === 'on';
  window._sizeCompare = on;
  const el = $('#setSizeCompare');
  if (el) el.value = on ? 'on' : 'off';
  updateStatus();
}

function applySizeCompareRef(val) {
  window._sizeCompareRef = val === 'content' ? 'content' : 'total';
  const el = $('#setSizeCompareRef');
  if (el) el.value = window._sizeCompareRef;
  updateStatus();
}

// inject settings rows before modules section
(function() {
  const panel = $('#settingsPanel');
  if (!panel) return;
  const headings = panel.querySelectorAll('h2');
  const modulesH2 = headings[headings.length - 1];
  if (!modulesH2) return;

  const h2 = document.createElement('h2');
  h2.textContent = 'status bar';
  modulesH2.before(h2);

  const refRow = document.createElement('div');
  refRow.className = 'settings-row';
  refRow.innerHTML = '<label>size reference</label>' +
    '<select id="setSizeCompareRef" onchange="applySizeCompareRef(this.value)">' +
    '<option value="total" selected>total file</option>' +
    '<option value="content">content only</option></select>';
  modulesH2.before(refRow);

  const row = document.createElement('div');
  row.className = 'settings-row';
  row.innerHTML = '<label>size comparison</label>' +
    '<select id="setSizeCompare" onchange="applySizeCompare(this.value)">' +
    '<option value="off">off</option><option value="on" selected>on</option></select>';
  modulesH2.before(row);

  window._sizeCompare = true;
  window._sizeCompareRef = 'total';
})();

// -- globals.js --

// ── GLOBAL BINDINGS ──
// This module wires exported functions to window.* for use by onclick/onchange
// handlers in template HTML and dynamically generated markup.
// Modules stay pure (no side effects, no window assignments).











// state
window.$ = $;
window.S = S;

// editor
window.toggleAutorun = toggleAutorun;

// settings
window.toggleSettings = toggleSettings;
window.togglePresent = togglePresent;
window.applyTheme = applyTheme;
window.applyFontSize = applyFontSize;
window.applyWidth = applyWidth;
window.applyLineNumbers = applyLineNumbers;
window.applyHeader = applyHeader;
window.applyExecMode = applyExecMode;
window.applyRunOnLoad = applyRunOnLoad;
window.applyShowToggle = applyShowToggle;
window.applyGlobalExecMode = applyGlobalExecMode;
window.applyGlobalRunOnLoad = applyGlobalRunOnLoad;

// update
window.toggleUpdate = toggleUpdate;
window.checkForUpdate = checkForUpdate;
window.applyOnlineUpdate = applyOnlineUpdate;
window.proceedUpdate = proceedUpdate;
window.cancelUpdate = cancelUpdate;
window.updateFromFile = updateFromFile;

// save
window.saveNotebook = saveNotebook;
window.savePackedNotebook = savePackedNotebook;
window.setSaveMode = setSaveMode;
window.toggleSaveTray = toggleSaveTray;
window.exportAsTxt = exportAsTxt;

// exec
window.runAll = runAll;

// ui
window.insertAt = insertAt;

// find
window.openFind = openFind;
window.closeFind = closeFind;

// stdlib
window.__auditable_registerProvider = registerProvider;

// keyboard / toolbar
window.addCellWithUndo = addCellWithUndo;
window.deleteCellWithUndo = deleteCellWithUndo;
window.runSelectedCell = runSelectedCell;
window.toggleToolbarMenu = toggleToolbarMenu;
window.toggleAddTray = toggleAddTray;
window.toggleMoreTray = toggleMoreTray;
window.showInsertPicker = showInsertPicker;
window.toggleTypePicker = toggleTypePicker;
window.collapseAll = collapseAll;
window.expandAll = expandAll;
window.newNotebook = newNotebook;

// -- init.js --

// ── INIT ──

(function init() {
  // detect packed format (meta tag injected by loader)
  const packedMeta = document.querySelector('meta[name="auditable-packed"]');
  if (packedMeta) {
    packedMeta.remove();
    setBadge('packed', 'packed', 'toolbar-badge toolbar-badge-packed');
    setSaveMode('packed');
  }

  if (!loadFromEmbed()) {
    addCell('md', '');
    addCell('code', '');
  }
  S.initialized = true;
})();

// ── AF BRIDGE ──
// When running inside AF shell (iframe), establish postMessage communication.
// No-op when running standalone (window.parent === window).
//
// Message protocol (notebook ↔ AF shell):
//   af:ready          → sent on init with { title }
//   af:serialize      ← received to trigger saveNotebook()
//   af:saved          ← received after save (shows "saved" status)
//   af:setTitle       ← received to update docTitle input
//   af:resize         ← received when iframe becomes visible (recalc textareas)
//   af:titleChanged   → sent when user edits the title
//   af:fileRequest    → sent to request file picker { id, accept }
//   af:fileResult     ← received with picked file { id, file }
//   af:download       → sent to request download { data, filename, mimeType }
//   af:dirty          → sent when notebook has unsaved changes

(function afBridge() {
  if (window.parent === window) return;
  window.__AF_BRIDGE__ = true;

  // register AF-specific providers for file/download
  registerProvider('file', (accept) => {
    return new Promise((resolve) => {
      const id = 'af_file_' + Date.now();
      function handler(e) {
        if (e.data?.type === 'af:fileResult' && e.data.payload?.id === id) {
          window.removeEventListener('message', handler);
          resolve(e.data.payload.file);
        }
      }
      window.addEventListener('message', handler);
      window.parent.postMessage({ type: 'af:fileRequest', payload: { id, accept } }, '*');
    });
  });

  registerProvider('download', (data, filename, mimeType) => {
    const str = typeof data === 'string' ? data : JSON.stringify(data, null, 2);
    const mime = mimeType || (typeof data === 'string' ? 'text/plain' : 'application/json');
    window.parent.postMessage({
      type: 'af:download',
      payload: { data: str, filename, mimeType: mime }
    }, '*');
  });

  const title = document.getElementById('docTitle')?.value || 'untitled';
  window.parent.postMessage({ type: 'af:ready', payload: { title } }, '*');

  window.addEventListener('message', (e) => {
    const msg = e.data;
    if (!msg?.type) return;
    if (msg.type === 'af:serialize') saveNotebook();
    else if (msg.type === 'af:saved') setMsg('saved', 'ok');
    else if (msg.type === 'af:setTitle') {
      const input = document.getElementById('docTitle');
      if (input && msg.payload?.title) input.value = msg.payload.title;
    } else if (msg.type === 'af:resize') {
      // recalculate textarea heights after becoming visible
      document.querySelectorAll('textarea').forEach(ta => {
        ta.style.height = 'auto';
        ta.style.height = ta.scrollHeight + 'px';
        const hl = ta.parentElement?.querySelector('.highlight-layer');
        if (hl) hl.style.height = ta.style.height;
      });
    }
  });

  document.getElementById('docTitle')?.addEventListener('input', () => {
    window.parent.postMessage({
      type: 'af:titleChanged',
      payload: { title: document.getElementById('docTitle').value }
    }, '*');
  });
})();
</script>
</body>
<!-- good luck out there -->
</html>
