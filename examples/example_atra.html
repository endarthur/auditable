<!DOCTYPE html>
<!-- auditable — a reactive computational notebook in a single HTML file -->
<!-- https://github.com/endarthur/auditable — MIT license -->
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Auditable — atra — Wasm kernels</title>
<style>
:root {
  --bg: #0a0a0a;
  --bg1: #111;
  --bg2: #1a1a1a;
  --border: #222;
  --border-hi: #333;
  --fg: #aaa;
  --fg-dim: #555;
  --fg-bright: #ccc;
  --accent: #c89b3c;
  --accent-dim: #8a6c2a;
  --err: #a33;
  --ok: #3a7;
  --mono: 'Courier New', Courier, monospace;
  --editor-font-size: 13px;
}

* { margin: 0; padding: 0; box-sizing: border-box; }

/* scrollbar */
::-webkit-scrollbar { width: 6px; height: 6px; }
::-webkit-scrollbar-track { background: var(--bg); }
::-webkit-scrollbar-thumb { background: var(--border-hi); border-radius: 0; }
::-webkit-scrollbar-thumb:hover { background: var(--fg-dim); }
textarea::-webkit-scrollbar-thumb { background: var(--border); }
@supports (scrollbar-color: auto) {
  * { scrollbar-color: var(--border-hi) var(--bg); scrollbar-width: thin; }
}

html, body {
  background: var(--bg);
  color: var(--fg);
  font-family: var(--mono);
  font-size: 13px;
  line-height: 1.5;
  min-height: 100vh;
}

/* ── TOOLBAR ── */
.toolbar {
  position: sticky;
  top: 0;
  z-index: 100;
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 6px 12px;
  background: var(--bg);
  border-bottom: 1px solid var(--border);
}

.toolbar-title {
  font-size: 11px;
  letter-spacing: 3px;
  text-transform: uppercase;
  color: var(--accent);
  opacity: 0.8;
  user-select: none;
}

.toolbar-sep {
  width: 1px;
  height: 16px;
  background: var(--border);
  margin: 0 4px;
}

.toolbar-filename {
  font-size: 12px;
  color: var(--fg-dim);
  flex: 1;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.toolbar-filename input {
  background: none;
  border: none;
  border-bottom: 1px solid transparent;
  color: var(--fg);
  font-family: var(--mono);
  font-size: 12px;
  outline: none;
  width: 200px;
}
.toolbar-filename input:focus {
  border-bottom-color: var(--accent-dim);
}

button {
  background: var(--bg2);
  border: 1px solid var(--border);
  color: var(--fg-dim);
  font-family: var(--mono);
  font-size: 10px;
  letter-spacing: 1px;
  text-transform: uppercase;
  padding: 4px 10px;
  cursor: pointer;
  transition: border-color 0.15s, color 0.15s;
}
button:hover {
  border-color: var(--border-hi);
  color: var(--fg);
}
button.accent {
  border-color: var(--accent-dim);
  color: var(--accent);
}
button.accent:hover {
  border-color: var(--accent);
}

/* ── TOOLBAR BADGES ── */
.toolbar-badges {
  display: inline-flex;
  gap: 4px;
  margin-left: 6px;
  align-items: center;
}
.toolbar-badge {
  font-size: 9px;
  letter-spacing: 0.5px;
  padding: 1px 4px;
  border-radius: 2px;
  user-select: none;
  opacity: 0.85;
}
.toolbar-badge-signed {
  color: var(--ok);
  border: 1px solid color-mix(in srgb, var(--ok) 40%, transparent);
}
.toolbar-badge-packed {
  color: var(--fg-dim);
  border: 1px solid var(--border);
}

/* ── SPLIT SAVE BUTTON ── */
.save-split {
  display: inline-flex;
  position: relative;
}
.save-split button:first-child {
  border-right: none;
  border-radius: 3px 0 0 3px;
}
.save-caret {
  border-radius: 0 3px 3px 0 !important;
  padding: 4px 4px !important;
  font-size: 10px;
}
.save-tray {
  display: none;
  position: absolute;
  right: 0;
  top: 100%;
  margin-top: 4px;
  background: var(--bg);
  border: 1px solid var(--border);
  z-index: 100;
  min-width: 120px;
}
.save-tray.open { display: flex; flex-direction: column; }
.save-tray button {
  border: none;
  border-bottom: 1px solid var(--border);
  text-align: left;
  padding: 6px 10px;
  white-space: nowrap;
  font-size: 12px;
}
.save-tray button:last-child { border-bottom: none; }
.save-tray button:hover { background: var(--bg-hi); }

/* ── TRANSPORT CONTROLS ── */
.transport {
  display: inline-flex;
  border: 1px solid var(--border);
}
.transport button {
  border: none;
  border-right: 1px solid var(--border);
  padding: 4px 8px;
}
.transport button:last-child { border-right: none; }
.transport button.autorun-on {
  background: #33aa77;
  color: #111;
}
.transport button.autorun-off {
  background: #dd4444;
  color: #111;
}

.toolbar-right {
  margin-left: auto;
  display: flex;
  align-items: center;
  gap: 8px;
}

/* ── TOOLBAR OVERFLOW MENU ── */
.toolbar-overflow {
  position: relative;
  display: inline-block;
}
.toolbar-overflow-tray {
  display: none;
  position: absolute;
  top: 100%;
  right: 0;
  background: var(--bg1);
  border: 1px solid var(--border);
  z-index: 200;
  flex-direction: column;
  min-width: 140px;
}
.toolbar-overflow-tray button {
  border: none;
  border-bottom: 1px solid var(--border);
  text-align: left;
  padding: 8px 12px;
  background: var(--bg1);
  white-space: nowrap;
}
.toolbar-overflow-tray button:last-child { border-bottom: none; }
.toolbar-overflow-tray button:hover { background: var(--bg2); color: var(--fg-bright); }
.toolbar-overflow.open .toolbar-overflow-tray { display: flex; }

/* ── BOTTOM ACTION BAR ── */
.action-bar { display: none; }

/* ── ACTION BAR TRAYS ── */
.action-add-tray,
.action-more-tray {
  display: none;
  position: absolute;
  bottom: 100%;
  background: var(--bg1);
  border: 1px solid var(--border);
  flex-direction: column;
  z-index: 200;
}
.action-add-tray { left: 0; min-width: 120px; }
.action-more-tray { right: 0; min-width: 120px; }
.action-add-tray.open,
.action-more-tray.open { display: flex; }
.action-add-tray button,
.action-more-tray button {
  min-height: 48px;
  border: none;
  border-bottom: 1px solid var(--border);
  text-align: left;
  padding: 8px 16px;
  background: var(--bg1);
  color: var(--fg);
  font-family: var(--mono);
  font-size: 12px;
  letter-spacing: 1px;
  text-transform: uppercase;
}
.action-add-tray button:last-child,
.action-more-tray button:last-child { border-bottom: none; }
.action-add-tray button:hover,
.action-more-tray button:hover { background: var(--bg2); color: var(--fg-bright); }
.action-more-tray button.active-mode { color: var(--accent); }

/* ── CELL INSERT / CONVERT BUTTONS (touch only) ── */
.cell-insert { display: none; }
.cell-convert { display: none; }

/* ── CELL TYPE PICKER ── */
.cell-type-picker {
  display: none;
  gap: 2px;
  padding: 2px 8px 4px;
}
.cell-type-picker.open { display: flex; }
.cell-type-picker button {
  font-size: 9px;
  padding: 2px 8px;
  background: var(--bg2);
  border: 1px solid var(--border);
  color: var(--fg-dim);
  font-family: var(--mono);
  letter-spacing: 1px;
  text-transform: uppercase;
}
.cell-type-picker button:hover {
  border-color: var(--accent-dim);
  color: var(--accent);
}

/* ── CELL INSERT PICKER ── */
.cell-insert-picker {
  display: none;
  gap: 2px;
  position: absolute;
  background: var(--bg1);
  border: 1px solid var(--border);
  padding: 4px;
  z-index: 200;
}
.cell-insert-picker.open { display: flex; }
.cell-insert-picker button {
  font-size: 9px;
  padding: 4px 8px;
  background: var(--bg2);
  border: 1px solid var(--border);
  color: var(--fg-dim);
  font-family: var(--mono);
  letter-spacing: 1px;
  text-transform: uppercase;
  min-height: 36px;
}
.cell-insert-picker button:hover {
  border-color: var(--accent-dim);
  color: var(--accent);
}

/* ── TOOLBAR STATUS (mobile cell count) ── */
.toolbar-status { display: none; }

/* ── NOTEBOOK ── */
.notebook {
  max-width: 860px;
  margin: 0 auto;
  padding: 16px 12px 120px;
}

/* ── CELL ── */
.cell {
  position: relative;
  margin: 6px 0;
  border-left: 2px solid transparent;
  transition: border-color 0.15s;
}
.cell:hover {
  border-left-color: var(--border-hi);
}
.cell.selected {
  border-left-color: var(--accent);
}
.cell.selected .cell-header {
  opacity: 1;
}
.cell.manual .cell-type::after {
  content: ' \00b7 manual';
  color: var(--accent-dim);
}
.cell.stale {
  border-left-color: var(--accent-dim);
}
.cell.error {
  border-left-color: var(--err);
}
.cell.fresh {
  border-left-color: var(--ok);
  transition: border-color 0.5s;
}

/* cell header — type label + controls */
.cell-header {
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 2px 8px;
  opacity: 0;
  transition: opacity 0.15s;
  user-select: none;
}
.cell:hover .cell-header,
.cell:focus-within .cell-header {
  opacity: 1;
}

.cell.collapsed .cell-code,
.cell.collapsed .cell-md-edit,
.cell.collapsed .cell-css-edit,
.cell.collapsed .cell-html-edit {
  display: none !important;
}
.cell.collapsed .cell-type::before {
  content: '\25b8 ';
}
.cell:not(.collapsed) .cell-type::before {
  content: '\25be ';
}
.cell-type {
  cursor: pointer;
  user-select: none;
  font-size: 9px;
  letter-spacing: 2px;
  text-transform: uppercase;
  color: var(--fg-dim);
}
.cell[data-type="code"] .cell-type { color: #7aabcf; }
.cell[data-type="css"]  .cell-type { color: #d4955a; }
.cell[data-type="html"] .cell-type { color: #6dbfb8; }
.cell[data-type="md"]   .cell-type { color: var(--fg-dim); }

.cell-btn {
  background: none;
  border: none;
  color: var(--fg-dim);
  font-family: var(--mono);
  font-size: 10px;
  padding: 0 4px;
  cursor: pointer;
}
.cell-btn:hover { color: var(--fg); }
.cell-btn.del:hover { color: var(--err); }

/* ── CODE CELL ── */
.cell-code {
  position: relative;
}

.editor-wrap {
  --gutter: 36px;
  position: relative;
  overflow: hidden;
}

.line-numbers {
  position: absolute;
  top: 0; left: 0; bottom: 0;
  width: var(--gutter);
  padding: 8px 4px 8px 0;
  font-family: var(--mono);
  font-size: var(--editor-font-size);
  line-height: 1.5;
  text-align: right;
  color: var(--fg-dim);
  background: var(--bg1);
  border-right: 1px solid var(--border);
  border-top: 1px solid var(--border);
  border-bottom: 1px solid var(--border);
  border-left: 1px solid var(--border);
  overflow: hidden;
  z-index: 3;
  pointer-events: none;
  white-space: pre;
  box-sizing: border-box;
}

:root.hide-line-numbers .line-numbers { display: none; }
:root.hide-line-numbers .editor-wrap { --gutter: 0px; }

.cell-code textarea {
  display: block;
  width: 100%;
  background: transparent;
  border: 1px solid var(--border);
  color: var(--fg-bright);
  caret-color: var(--fg-bright);
  font-family: var(--mono);
  font-size: var(--editor-font-size);
  line-height: 1.5;
  padding: 8px 10px 8px calc(var(--gutter) + 10px);
  resize: vertical;
  min-height: 38px;
  outline: none;
  tab-size: 2;
  white-space: pre;
  overflow-x: auto;
  position: relative;
  z-index: 2;
  -webkit-text-fill-color: transparent;
}
.cell-code textarea::selection {
  -webkit-text-fill-color: var(--fg-bright);
  background: rgba(200,155,60,0.25);
}
.cell-code textarea:focus + .highlight-layer {
  border-color: var(--border-hi);
}
.cell-code textarea:focus ~ .line-numbers {
  border-color: var(--border-hi);
}

.highlight-layer {
  position: absolute;
  top: 0; left: 0; right: 0; bottom: 0;
  background: var(--bg1);
  border: 1px solid var(--border);
  padding: 8px 10px 8px calc(var(--gutter) + 10px);
  font-family: var(--mono);
  font-size: var(--editor-font-size);
  line-height: 1.5;
  tab-size: 2;
  white-space: pre;
  overflow: hidden;
  z-index: 1;
  pointer-events: none;
  color: var(--fg-bright);
}

/* syntax tokens */
.hl-kw { color: #7a9ec7; }
.hl-str { color: var(--accent); }
.hl-num { color: #8cb878; }
.hl-cmt { color: #555; font-style: italic; }
.hl-fn { color: #c4a6d0; }
.hl-const { color: #d09870; }
.hl-op { color: #888; }
.hl-punc { color: #666; }

/* CSS syntax tokens */
.hl-atrule { color: #7aabcf; }
.hl-prop { color: #7aabcf; }
.hl-sel { color: #d4955a; }
.hl-color { color: var(--accent); }
.hl-important { color: #d4555a; font-weight: bold; }

/* HTML syntax tokens */
.hl-tag { color: #6dbfb8; }
.hl-attr { color: #7aabcf; }
.hl-expr { color: var(--accent); }

.hl-swatch {
  display: inline-block;
  width: 10px;
  height: 10px;
  border: 1px solid var(--border-hi);
  vertical-align: middle;
  margin-right: 2px;
  cursor: pointer;
  pointer-events: auto;
}

.cell-output {
  padding: 4px 10px;
  min-height: 0;
  font-size: 12px;
  color: var(--fg);
  white-space: pre-wrap;
  word-break: break-all;
}
.cell-output:empty {
  display: none;
}
.cell-output.error {
  color: var(--err);
}

.cell-output canvas {
  max-width: 100%;
  display: block;
  margin: 4px 0;
}

.cell-output table {
  border-collapse: collapse;
  font-size: 11px;
  margin: 4px 0;
}
.cell-output table th,
.cell-output table td {
  border: 1px solid var(--border);
  padding: 2px 8px;
}
.cell-output table th {
  color: var(--accent);
  font-weight: normal;
  text-transform: uppercase;
  font-size: 9px;
  letter-spacing: 1px;
}

/* ── CSS CELL ── */
.cell-css-view {
  padding: 6px 10px;
  color: var(--fg-dim);
  cursor: text;
  min-height: 24px;
  font-size: 11px;
  font-style: italic;
}
.cell-css-view:empty::before {
  content: '(empty stylesheet)';
}

.cell-css-edit textarea {
  display: block;
  width: 100%;
  background: transparent;
  border: 1px solid var(--border);
  color: var(--fg-bright);
  caret-color: var(--fg-bright);
  font-family: var(--mono);
  font-size: var(--editor-font-size);
  line-height: 1.5;
  padding: 8px 10px 8px calc(var(--gutter) + 10px);
  resize: vertical;
  min-height: 38px;
  outline: none;
  tab-size: 2;
  white-space: pre;
  overflow-x: auto;
  position: relative;
  z-index: 2;
  -webkit-text-fill-color: transparent;
}
.cell-css-edit textarea::selection {
  -webkit-text-fill-color: var(--fg-bright);
  background: rgba(200,155,60,0.25);
}
.cell-css-edit textarea:focus + .highlight-layer {
  border-color: var(--border-hi);
}
.cell-css-edit textarea:focus ~ .line-numbers {
  border-color: var(--border-hi);
}

/* ── HTML CELL ── */
.cell-html-view {
  padding: 6px 10px;
  color: var(--fg);
  cursor: text;
  min-height: 24px;
}
.cell-html-view:empty::before {
  content: '(empty html template)';
  color: var(--fg-dim);
  font-style: italic;
  font-size: 11px;
}
.cell-html-edit textarea {
  display: block;
  width: 100%;
  background: transparent;
  border: 1px solid var(--border);
  color: var(--fg-bright);
  caret-color: var(--fg-bright);
  font-family: var(--mono);
  font-size: var(--editor-font-size);
  line-height: 1.5;
  padding: 8px 10px 8px calc(var(--gutter) + 10px);
  resize: vertical;
  min-height: 38px;
  outline: none;
  tab-size: 2;
  white-space: pre;
  overflow-x: auto;
  position: relative;
  z-index: 2;
  -webkit-text-fill-color: transparent;
}
.cell-html-edit textarea::selection {
  -webkit-text-fill-color: var(--fg-bright);
  background: rgba(200,155,60,0.25);
}
.cell-html-edit textarea:focus + .highlight-layer {
  border-color: var(--border-hi);
}
.cell-html-edit textarea:focus ~ .line-numbers {
  border-color: var(--border-hi);
}

/* ── MARKDOWN CELL ── */
.cell-md-view {
  padding: 6px 10px;
  color: var(--fg);
  cursor: text;
  min-height: 24px;
}
.cell-md-view:empty::before {
  content: '(empty markdown cell)';
  color: var(--fg-dim);
  font-style: italic;
  font-size: 11px;
}
.cell-md-view h1, .cell-md-view h2, .cell-md-view h3 {
  color: var(--fg-bright);
  font-weight: normal;
  margin: 4px 0;
}
.cell-md-view h1 { font-size: 18px; letter-spacing: 2px; }
.cell-md-view h2 { font-size: 15px; letter-spacing: 1px; color: var(--accent); }
.cell-md-view h3 { font-size: 13px; }
.cell-md-view p { margin: 4px 0; }
.cell-md-view code {
  background: var(--bg2);
  padding: 1px 4px;
  font-size: 12px;
}
.cell-md-view strong { color: var(--fg-bright); }
.cell-md-view em { font-style: italic; }
.cell-md-view a { color: var(--accent); }

.cell-md-edit textarea {
  display: block;
  width: 100%;
  background: var(--bg1);
  border: 1px solid var(--border);
  color: var(--fg-bright);
  font-family: var(--mono);
  font-size: var(--editor-font-size);
  line-height: 1.5;
  padding: 8px 10px;
  resize: vertical;
  min-height: 38px;
  outline: none;
}

/* ── PRESENTATION MODE ── */
body.presenting .toolbar { display: none; }
body.presenting .cell-header { display: none; }
body.presenting .cell-code { display: none; }
body.presenting .cell-md-edit { display: none !important; }
body.presenting .cell-css-edit { display: none; }
body.presenting .cell-css-view { display: none; }
body.presenting .cell-html-edit { display: none !important; }
body.presenting .cell { border-left: none; margin: 0; }
body.presenting .cell:hover { border-left: none; }
body.presenting .insert-bar { display: none; }
body.presenting .notebook { max-width: 900px; padding-top: 40px; }
body.presenting .statusbar { display: none; }
body.presenting .present-hidden { display: none; }
body.presenting .present-exit {
  display: block;
  position: fixed;
  top: 12px;
  right: 12px;
  z-index: 200;
}
.present-exit { display: none; }

/* ── INSERT BAR (between cells) ── */
.insert-bar {
  height: 16px;
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  margin: -6px 0;
}
.insert-bar::before {
  content: '';
  position: absolute;
  left: 20px;
  right: 20px;
  top: 50%;
  height: 1px;
  background: var(--border);
  opacity: 0;
  transition: opacity 0.15s;
}
.insert-bar:hover::before { opacity: 1; }
.insert-bar .insert-btns {
  display: flex;
  gap: 4px;
  opacity: 0;
  transition: opacity 0.15s;
  position: relative;
  z-index: 10;
}
.insert-bar:hover .insert-btns { opacity: 1; }
.insert-bar .insert-btns button {
  font-size: 9px;
  padding: 1px 8px;
  background: var(--bg);
  border: 1px solid var(--border);
  color: var(--fg-dim);
}
.insert-bar .insert-btns button:hover {
  border-color: var(--accent-dim);
  color: var(--accent);
}

/* ── ADD CELL BAR ── */
.add-bar {
  display: flex;
  justify-content: center;
  gap: 8px;
  padding: 6px 0;
  opacity: 0;
  transition: opacity 0.15s;
}
.notebook:hover .add-bar,
.add-bar.visible {
  opacity: 0.5;
}
.add-bar:hover {
  opacity: 1 !important;
}

/* ── WIDGET CLASSES ── */
.cell-widget {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 2px 0;
  font-size: 12px;
  color: var(--fg-dim);
}
.cell-widget-label {
  min-width: 80px;
  font-size: 10px;
  letter-spacing: 1px;
  text-transform: uppercase;
  color: var(--fg-dim);
}
.cell-widget input[type="range"] {
  flex: 1;
  accent-color: var(--accent);
  max-width: 200px;
}
.cell-widget select {
  background: var(--bg2);
  border: 1px solid var(--border);
  color: var(--fg-bright);
  font-family: var(--mono);
  font-size: 12px;
  padding: 2px 4px;
}
.cell-widget input[type="checkbox"] {
  accent-color: var(--accent);
}
.cell-widget input[type="text"] {
  background: var(--bg2);
  border: 1px solid var(--border);
  color: var(--fg-bright);
  font-family: var(--mono);
  font-size: 12px;
  padding: 2px 6px;
  flex: 1;
  max-width: 200px;
}
.cell-widget-val {
  min-width: 40px;
  text-align: right;
  color: var(--fg-bright);
  font-size: 12px;
}

/* ── STATUS BAR ── */
.statusbar {
  position: fixed;
  bottom: 0;
  left: 0;
  right: 0;
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 4px 12px;
  background: var(--bg);
  border-top: 1px solid var(--border);
  font-size: 10px;
  color: var(--fg-dim);
  letter-spacing: 1px;
  z-index: 100;
}
.statusbar .status-size { color: var(--fg-dim); }
.statusbar .status-cells { color: var(--fg-dim); }
.statusbar .status-msg { flex: 1; text-align: right; }
.statusbar .status-msg.ok { color: var(--ok); }
.statusbar .status-msg.warn { color: var(--accent); }
.statusbar .status-msg.err { color: var(--err); }
.statusbar .status-attr { margin-left: auto; display: flex; align-items: center; gap: 6px; }
.statusbar .status-attr a {
  color: var(--fg-dim);
  text-decoration: none;
  transition: color 0.2s;
}
.statusbar .status-attr a:hover { color: var(--accent); }
.statusbar .status-attr svg { vertical-align: middle; }

/* ── EMPTY STATE ── */
.empty-state {
  text-align: center;
  padding: 80px 20px;
  color: var(--fg-dim);
}
.empty-state .logo {
  font-size: 11px;
  letter-spacing: 4px;
  text-transform: uppercase;
  color: var(--accent);
  margin-bottom: 16px;
}
.empty-state .tagline {
  font-size: 11px;
  margin-bottom: 24px;
}

.help-overlay {
  display: none;
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.85);
  z-index: 1000;
  overflow-y: auto;
  padding: 40px;
}
.help-overlay.visible { display: flex; justify-content: center; }
.help-content {
  position: relative;
  max-width: 600px;
  width: 100%;
  color: var(--fg);
  font-family: var(--mono);
  font-size: 13px;
  line-height: 1.8;
}
.help-content h2 {
  color: var(--accent);
  font-size: 14px;
  letter-spacing: 2px;
  text-transform: uppercase;
  margin: 24px 0 8px 0;
  border-bottom: 1px solid var(--border);
  padding-bottom: 4px;
}
.help-content h2:first-child { margin-top: 0; }
.help-row {
  display: flex;
  justify-content: space-between;
  padding: 2px 0;
}
.help-key {
  background: var(--bg2);
  border: 1px solid var(--border);
  border-radius: 3px;
  padding: 0 6px;
  font-size: 11px;
  color: var(--fg-bright);
  min-width: 80px;
  text-align: center;
  display: inline-block;
}
.help-desc { color: var(--fg); }
.help-close {
  color: var(--accent-dim);
  font-size: 11px;
  text-align: center;
  margin-top: 24px;
  letter-spacing: 1px;
}
.help-close-btn {
  position: absolute;
  top: 0;
  right: 0;
  background: none;
  border: 1px solid var(--border);
  color: var(--fg-dim);
  font-size: 20px;
  width: 44px;
  height: 44px;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 0;
  cursor: pointer;
  text-transform: none;
  letter-spacing: 0;
}
.help-close-btn:hover {
  border-color: var(--err);
  color: var(--err);
}

/* ── SETTINGS PANEL ── */
.settings-overlay {
  display: none;
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.5);
  z-index: 1000;
}
.settings-overlay.visible { display: block; }
.settings-panel {
  display: none;
  position: fixed;
  top: 0;
  right: 0;
  bottom: 0;
  width: 280px;
  max-width: 90vw;
  background: var(--bg1);
  border-left: 1px solid var(--border);
  padding: 20px;
  overflow-y: auto;
  z-index: 1001;
  font-family: var(--mono);
  font-size: 12px;
  color: var(--fg);
}
.settings-close {
  position: absolute;
  top: 12px;
  right: 12px;
  background: none;
  border: 1px solid var(--border);
  color: var(--fg-dim);
  font-size: 18px;
  width: 32px;
  height: 32px;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 0;
  cursor: pointer;
  text-transform: none;
  letter-spacing: 0;
}
.settings-close:hover {
  border-color: var(--err);
  color: var(--err);
}

.settings-panel h2 {
  color: var(--accent);
  font-size: 11px;
  letter-spacing: 2px;
  text-transform: uppercase;
  margin: 20px 0 10px 0;
}
.settings-panel h2:first-child { margin-top: 0; }
.settings-row {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 6px 0;
}
.settings-row label { color: var(--fg-dim); font-size: 11px; }
.settings-row select,
.settings-row input[type="range"] {
  background: var(--bg2);
  border: 1px solid var(--border);
  color: var(--fg-bright);
  font-family: var(--mono);
  font-size: 11px;
  padding: 2px 4px;
}
.settings-row input[type="range"] {
  accent-color: var(--accent);
  width: 100px;
}
.settings-val {
  min-width: 30px;
  text-align: right;
  color: var(--fg-bright);
  font-size: 11px;
}

/* ── SETTINGS DESCRIPTIONS ── */
.settings-desc {
  color: var(--fg-dim);
  font-size: 10px;
  line-height: 1.5;
  padding: 4px 0 8px;
}
.settings-desc strong {
  color: var(--fg);
}

/* ── HIDE RUN TOGGLE ── */
html.hide-run-toggle #autorunBtn,
html.hide-run-toggle #autorunBtnMobile { display: none; }

/* ── MODULE LIST (settings panel) ── */
.module-row {
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 4px 0;
  font-size: 11px;
}
.module-url {
  flex: 1;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  color: var(--fg);
}
.module-info {
  color: var(--fg-dim);
  white-space: nowrap;
  font-size: 10px;
}
.module-remove {
  background: none;
  border: none;
  color: var(--fg-dim);
  font-size: 14px;
  padding: 0 2px;
  cursor: pointer;
  line-height: 1;
  text-transform: none;
  letter-spacing: 0;
}
.module-remove:hover { color: var(--err); }
.module-total {
  padding: 4px 0;
  font-size: 10px;
  color: var(--fg-dim);
  border-top: 1px solid var(--border);
  text-align: right;
}
.module-empty {
  color: var(--fg-dim);
  font-size: 11px;
  font-style: italic;
  padding: 4px 0;
}
/* ── UPDATE PANEL ── */
.update-overlay {
  display: none;
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.5);
  z-index: 1000;
}
.update-overlay.visible { display: block; }
.update-panel {
  display: none;
  position: fixed;
  top: 0;
  right: 0;
  bottom: 0;
  width: 280px;
  max-width: 90vw;
  background: var(--bg1);
  border-left: 1px solid var(--border);
  padding: 20px;
  overflow-y: auto;
  z-index: 1001;
  font-family: var(--mono);
  font-size: 12px;
  color: var(--fg);
}
.update-panel h2 {
  color: var(--accent);
  font-size: 11px;
  letter-spacing: 2px;
  text-transform: uppercase;
  margin: 0 0 12px 0;
}
.update-panel .settings-row {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 6px 0;
}
.update-panel .settings-row label { color: var(--fg-dim); font-size: 11px; }
.update-actions {
  display: flex;
  flex-direction: column;
  gap: 6px;
  padding: 8px 0;
}
.update-actions button {
  width: 100%;
  padding: 8px 10px;
}
.update-status {
  font-size: 11px;
  padding: 8px 0;
  line-height: 1.5;
}
.update-status strong { color: var(--fg-bright); }
.update-status button {
  display: block;
  width: 100%;
  margin-top: 8px;
  padding: 8px 10px;
  border-color: var(--accent-dim);
  color: var(--accent);
}
.update-status button:hover {
  border-color: var(--accent);
}
.update-ok { color: var(--ok); }
.update-err { color: var(--err); }
.update-warn { color: var(--accent); }
.update-available { color: var(--fg); }
.update-notes {
  color: var(--fg-dim);
  font-size: 11px;
  padding: 6px 0;
  max-height: 120px;
  overflow-y: auto;
  line-height: 1.4;
}
.update-notes p { margin: 0 0 4px; }
.update-notes ul { margin: 2px 0; padding-left: 16px; }
.update-notes li { margin: 1px 0; }
.update-notes h1, .update-notes h2, .update-notes h3 { font-size: 11px; margin: 4px 0 2px; color: var(--fg); }
.update-confirm {
  display: flex;
  gap: 8px;
  padding: 6px 0;
}
.update-confirm button { width: auto; }
.update-sig {
  font-size: 11px;
}
.update-key-truncated {
  cursor: pointer;
}
.update-key-truncated:hover {
  color: var(--accent);
}
.update-key-expanded {
  word-break: break-all;
  user-select: all;
  cursor: pointer;
  color: var(--fg-bright);
}
/* ── UPDATE BUTTON IN OVERFLOW TRAY ── */
.toolbar-update-btn {
  color: var(--accent) !important;
}

.settings-about {
  margin-top: 24px;
  padding-top: 12px;
  border-top: 1px solid var(--border);
  font-size: 11px;
  color: var(--fg-dim);
  display: flex;
  flex-direction: column;
  gap: 2px;
}
.settings-about a {
  color: var(--accent);
  text-decoration: none;
}
.settings-about a:hover { text-decoration: underline; }

/* ── FIND BAR ── */
.find-bar {
  display: none;
  flex-direction: column;
  position: sticky;
  top: 33px;
  z-index: 99;
  float: right;
  max-width: 400px;
  width: 100%;
  background: var(--bg1);
  border: 1px solid var(--border);
  border-top: none;
  padding: 6px 8px;
  gap: 4px;
}
.find-row {
  display: flex;
  align-items: center;
  gap: 4px;
}
.find-replace-row {
  display: none;
  align-items: center;
  gap: 4px;
}
.find-bar.show-replace .find-replace-row { display: flex; }
.find-bar input[type="text"] {
  flex: 1;
  background: var(--bg2);
  border: 1px solid var(--border);
  color: var(--fg-bright);
  font-family: var(--mono);
  font-size: 12px;
  padding: 4px 8px;
  outline: none;
  min-width: 0;
}
.find-bar input[type="text"]:focus {
  border-color: var(--border-hi);
}
.find-count {
  font-size: 10px;
  color: var(--fg-dim);
  white-space: nowrap;
  min-width: 50px;
  text-align: center;
  letter-spacing: 1px;
}
.find-bar button {
  padding: 3px 8px;
  font-size: 10px;
  min-width: 28px;
}
.find-bar button.active {
  color: var(--accent);
  border-color: var(--accent-dim);
}
body.presenting .find-bar { display: none !important; }

/* ── SEARCH OVERLAY ── */
.search-overlay {
  position: absolute;
  top: 0; left: 0; right: 0; bottom: 0;
  padding: 8px 10px 8px calc(var(--gutter) + 10px);
  font-family: var(--mono);
  font-size: var(--editor-font-size);
  line-height: 1.5;
  tab-size: 2;
  white-space: pre;
  overflow: hidden;
  z-index: 1;
  pointer-events: none;
  color: transparent;
  border: 1px solid transparent;
}
.search-overlay-md {
  padding: 8px 10px;
}
.md-search-wrap {
  position: relative;
}
.search-match {
  background: rgba(200,155,60,0.25);
  color: transparent;
}
.search-match-current {
  background: rgba(200,155,60,0.5);
  outline: 1px solid var(--accent);
}

/* ── AUTOCOMPLETE MENU ── */
.ac-menu {
  position: absolute;
  z-index: 10;
  background: #1e1e1e;
  border: 1px solid #444;
  border-radius: 3px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.4);
  max-height: 200px;
  overflow-y: auto;
  font-family: var(--mono);
  font-size: var(--editor-font-size);
  min-width: 120px;
}
.ac-item {
  padding: 2px 8px;
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 6px;
  white-space: nowrap;
}
.ac-item.active,
.ac-item:hover {
  background: rgba(200,155,60,0.2);
}
.ac-kind {
  width: 16px;
  height: 16px;
  border-radius: 2px;
  font-size: 10px;
  text-align: center;
  line-height: 16px;
  flex-shrink: 0;
}
.ac-kind-var, .ac-kind-def { color: #5ca7e4; }
.ac-kind-fn { color: #c89b3c; }
.ac-kind-kw { color: #cc7832; }
.ac-kind-const { color: #9876aa; }
.ac-kind-prop { color: #6a8759; }
.ac-text { color: var(--fg-bright); }
.ac-detail {
  margin-left: auto;
  padding-left: 12px;
  color: var(--fg-dim);
  font-size: 11px;
}
.ac-match { font-weight: bold; }
.ac-sig-hint {
  position: absolute;
  z-index: 10;
  background: #1e1e1e;
  border: 1px solid #444;
  border-radius: 3px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.4);
  padding: 3px 8px;
  font-family: var(--mono);
  font-size: var(--editor-font-size);
  white-space: nowrap;
  display: flex;
  gap: 10px;
  align-items: baseline;
}
.ac-sig-fn { color: var(--fg-bright); }
.ac-sig-active { color: var(--accent); font-weight: bold; text-decoration: underline; }
.ac-sig-desc { color: var(--fg-dim); font-size: 11px; }
:root.light .ac-sig-hint {
  background: #eae8e3;
  border-color: #b0ab9f;
  box-shadow: 0 2px 8px rgba(0,0,0,0.15);
}
:root.light .ac-menu {
  background: #eae8e3;
  border-color: #b0ab9f;
  box-shadow: 0 2px 8px rgba(0,0,0,0.15);
}
:root.light .ac-item.active,
:root.light .ac-item:hover {
  background: rgba(153,107,31,0.15);
}

/* ── WORKSHOP PANEL ── */
.workshop-overlay {
  display: none;
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.3);
  z-index: 900;
}
.workshop-overlay.visible { display: block; }
.workshop-panel {
  position: fixed;
  top: 0;
  right: -380px;
  bottom: 0;
  width: 360px;
  max-width: 90vw;
  background: var(--bg1);
  border-left: 1px solid var(--border);
  z-index: 901;
  display: flex;
  flex-direction: column;
  font-family: var(--mono);
  font-size: 13px;
  color: var(--fg);
  transition: right 0.25s ease;
  overflow: hidden;
}
.workshop-panel.open { right: 0; }
.workshop-tab {
  position: fixed;
  right: 0;
  top: 50%;
  transform: translateY(-50%) rotate(180deg);
  writing-mode: vertical-rl;
  background: var(--bg1);
  border: 1px solid var(--border);
  border-right: none;
  color: var(--accent);
  font-family: var(--mono);
  font-size: 10px;
  letter-spacing: 2px;
  text-transform: uppercase;
  padding: 10px 5px;
  cursor: pointer;
  z-index: 902;
  transition: right 0.25s ease;
}
.workshop-tab:hover { background: var(--bg2); }
.workshop-panel.open ~ .workshop-tab { right: min(360px, 90vw); }
.workshop-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 16px 16px 12px;
  border-bottom: 1px solid var(--border);
}
.workshop-title {
  color: var(--accent);
  font-size: 11px;
  letter-spacing: 2px;
  text-transform: uppercase;
}
.workshop-close {
  background: none;
  border: 1px solid var(--border);
  color: var(--fg-dim);
  font-size: 18px;
  width: 28px; height: 28px;
  display: flex; align-items: center; justify-content: center;
  padding: 0; cursor: pointer;
  text-transform: none;
  letter-spacing: 0;
}
.workshop-close:hover { border-color: var(--err); color: var(--err); }
.workshop-body {
  flex: 1;
  overflow-y: auto;
  padding: 16px;
  line-height: 1.6;
}
.workshop-body h1, .workshop-body h2, .workshop-body h3 {
  color: var(--fg-bright);
  margin: 1em 0 0.5em;
}
.workshop-body h1:first-child, .workshop-body h2:first-child, .workshop-body h3:first-child {
  margin-top: 0;
}
.workshop-body code {
  background: var(--bg2);
  padding: 1px 4px;
  font-size: 0.9em;
}
.workshop-body strong { color: var(--accent); }
.workshop-pips {
  display: flex;
  justify-content: center;
  gap: 6px;
  padding: 8px 16px;
}
.workshop-pip {
  width: 8px; height: 8px;
  border-radius: 50%;
  background: var(--border);
  cursor: pointer;
}
.workshop-pip.done { background: var(--fg-dim); }
.workshop-pip.active { background: var(--accent); }
.workshop-nav {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 12px 16px;
  border-top: 1px solid var(--border);
}
.workshop-nav button {
  background: var(--bg2);
  border: 1px solid var(--border);
  color: var(--fg);
  font-family: var(--mono);
  font-size: 11px;
  padding: 4px 12px;
  cursor: pointer;
}
.workshop-nav button:hover { border-color: var(--accent); color: var(--accent); }
.workshop-nav button:disabled { opacity: 0.3; cursor: default; }
.workshop-nav button:disabled:hover { border-color: var(--border); color: var(--fg); }
.workshop-counter { color: var(--fg-dim); font-size: 11px; }

/* ── LIGHT THEME ── */
:root.light {
  --bg: #f5f4f0;
  --bg1: #eae8e3;
  --bg2: #dedad3;
  --border: #ccc8bf;
  --border-hi: #b0ab9f;
  --fg: #444;
  --fg-dim: #888;
  --fg-bright: #222;
  --accent: #996b1f;
  --accent-dim: #b8924a;
  --err: #c33;
  --ok: #287;
}
:root.light .cell[data-type="code"] .cell-type { color: #4a7a9e; }
:root.light .cell[data-type="css"]  .cell-type { color: #a56e33; }
:root.light .cell[data-type="html"] .cell-type { color: #3d8a83; }
:root.light ::-webkit-scrollbar-track { background: var(--bg); }
:root.light ::-webkit-scrollbar-thumb { background: var(--border-hi); }

/* ── TOUCH / HEADER MODES ── */
@media (hover: none) {
  .insert-bar { display: none; }
  .cell.selected .cell-insert { display: inline; }
  .cell.selected .cell-convert { display: inline; }
  .cell.selected .cell-header {
    gap: 2px;
  }
  .cell.selected .cell-btn {
    min-height: 36px;
    min-width: 36px;
    font-size: 14px;
    display: inline-flex;
    align-items: center;
    justify-content: center;
  }
}

/* compact header: ellipsis indicator, full controls on select */
@media (hover: none) {
  :root:not(.header-always):not(.header-hover) .cell-header > * { display: none; }
  :root:not(.header-always):not(.header-hover) .cell-header {
    opacity: 1;
    justify-content: center;
    padding: 1px 8px;
  }
  :root:not(.header-always):not(.header-hover) .cell-header::before {
    content: '\22ef';
    color: var(--fg-dim);
    font-size: 12px;
    opacity: 0.4;
  }
  :root:not(.header-always):not(.header-hover) .cell.selected .cell-header > * { display: inline; }
  :root:not(.header-always):not(.header-hover) .cell.selected .cell-header::before { display: none; }
  :root:not(.header-always):not(.header-hover) .cell.selected .cell-header {
    justify-content: flex-start;
    padding: 2px 8px;
  }
}

/* header-always: full header visible on all devices */
:root.header-always .cell-header { opacity: 0.6; }
:root.header-always .cell:hover .cell-header,
:root.header-always .cell.selected .cell-header { opacity: 1; }

/* header-compact: forced compact mode on all devices */
:root.header-compact .cell-header > * { display: none; }
:root.header-compact .cell-header {
  opacity: 1 !important;
  justify-content: center;
  padding: 1px 8px;
}
:root.header-compact .cell-header::before {
  content: '\22ef';
  color: var(--fg-dim);
  font-size: 12px;
  opacity: 0.4;
}
:root.header-compact .cell.selected .cell-header > * { display: inline; }
:root.header-compact .cell.selected .cell-header::before { display: none; }
:root.header-compact .cell.selected .cell-header {
  justify-content: flex-start;
  padding: 2px 8px;
}

/* ── RESPONSIVE ── */
@media (max-width: 640px) {
  /* slim top toolbar: filename + cell count only */
  .toolbar {
    flex-wrap: nowrap;
    gap: 4px;
    padding: 6px 8px;
  }
  .toolbar-title { display: none; }
  .toolbar-sep { display: none; }
  .toolbar .toolbar-add, .toolbar .toolbar-secondary { display: none; }
  .transport { display: none; }
  .toolbar-right { display: none; }
  .toolbar-filename { flex: 1; }
  .toolbar-filename input { width: 100%; }
  .toolbar-status {
    display: inline;
    font-size: 10px;
    color: var(--fg-dim);
    white-space: nowrap;
    letter-spacing: 1px;
  }

  /* bottom action bar replaces statusbar */
  .statusbar {
    display: block;
    padding: 0;
    height: 48px;
  }
  .statusbar .status-size,
  .statusbar .status-cells,
  .statusbar .status-msg,
  .statusbar .status-attr { display: none; }
  .action-bar {
    display: grid;
    grid-template-columns: repeat(5, 1fr);
    height: 48px;
  }
  /* wrapper divs for tray positioning must fill their grid cell */
  .action-bar > div {
    position: relative;
    display: flex;
  }
  .action-bar > div > button {
    flex: 1;
  }
  /* style only the 5 action buttons, not tray buttons */
  .action-bar > button,
  .action-bar > div > button {
    min-height: 48px;
    border: none;
    border-right: 1px solid var(--border);
    background: var(--bg);
    font-family: var(--mono);
    font-size: 16px;
    color: var(--fg);
    padding: 0;
    letter-spacing: 0;
    text-transform: none;
  }
  .action-bar > :last-child > button,
  .action-bar > button:last-child { border-right: none; }
  .action-bar > button:active,
  .action-bar > div > button:active { background: var(--bg2); }
  .action-bar > button.autorun-on,
  .action-bar > div > button.autorun-on {
    background: #33aa77;
    color: #111;
  }
  .action-bar > button.autorun-off,
  .action-bar > div > button.autorun-off {
    background: #dd4444;
    color: #111;
  }

  .find-bar { max-width: 100%; float: none; }
  .notebook { padding: 8px 6px 100px; }
  .cell-header { padding: 2px 4px; }
  .settings-close { width: 44px; height: 44px; font-size: 22px; }
  .settings-row { padding: 10px 0; }
  .settings-row select { min-height: 44px; font-size: 14px; padding: 4px 8px; }
  .settings-row input[type="range"] { height: 44px; }
  .help-overlay { padding: 20px 12px; }
  .settings-panel { width: 260px; }
}

</style>
</head>
<body>

<div class="help-overlay" id="helpOverlay">
<div class="help-content">
<button class="help-close-btn" onclick="$('#helpOverlay').classList.remove('visible')">&#x00d7;</button>
<h2>command mode</h2>
<div class="help-row"><span class="help-key">&#x2191; / k</span><span class="help-desc">select cell above</span></div>
<div class="help-row"><span class="help-key">&#x2193; / j</span><span class="help-desc">select cell below</span></div>
<div class="help-row"><span class="help-key">Enter</span><span class="help-desc">edit selected cell</span></div>
<div class="help-row"><span class="help-key">a</span><span class="help-desc">insert cell above</span></div>
<div class="help-row"><span class="help-key">b</span><span class="help-desc">insert cell below</span></div>
<div class="help-row"><span class="help-key">d d</span><span class="help-desc">delete cell</span></div>
<div class="help-row"><span class="help-key">z</span><span class="help-desc">undo delete</span></div>
<div class="help-row"><span class="help-key">c</span><span class="help-desc">copy cell</span></div>
<div class="help-row"><span class="help-key">v</span><span class="help-desc">paste cell below</span></div>
<div class="help-row"><span class="help-key">x</span><span class="help-desc">cut cell</span></div>
<div class="help-row"><span class="help-key">m</span><span class="help-desc">convert to markdown</span></div>
<div class="help-row"><span class="help-key">y</span><span class="help-desc">convert to code</span></div>
<div class="help-row"><span class="help-key">s</span><span class="help-desc">convert to css</span></div>
<div class="help-row"><span class="help-key">t</span><span class="help-desc">convert to html template</span></div>
<div class="help-row"><span class="help-key">h</span><span class="help-desc">collapse / expand cell</span></div>
<div class="help-row"><span class="help-key">l</span><span class="help-desc">toggle line numbers</span></div>
<div class="help-row"><span class="help-key">p</span><span class="help-desc">presentation mode</span></div>

<h2>edit mode</h2>
<div class="help-row"><span class="help-key">Esc</span><span class="help-desc">exit to command mode</span></div>
<div class="help-row"><span class="help-key">Ctrl+Enter</span><span class="help-desc">run cell</span></div>
<div class="help-row"><span class="help-key">Shift+Enter</span><span class="help-desc">run cell + advance</span></div>
<div class="help-row"><span class="help-key">Ctrl+/</span><span class="help-desc">toggle comment</span></div>
<div class="help-row"><span class="help-key">Tab</span><span class="help-desc">indent</span></div>
<div class="help-row"><span class="help-key">Shift+Tab</span><span class="help-desc">unindent</span></div>

<h2>global</h2>
<div class="help-row"><span class="help-key">F1</span><span class="help-desc">toggle this help</span></div>
<div class="help-row"><span class="help-key">Ctrl+S</span><span class="help-desc">save notebook</span></div>
<div class="help-row"><span class="help-key">Ctrl+F</span><span class="help-desc">find in notebook</span></div>
<div class="help-row"><span class="help-key">Ctrl+H</span><span class="help-desc">find and replace</span></div>

<h2>toolbar</h2>
<div class="help-row"><span class="help-key">&#x23f5; step</span><span class="help-desc">run selected cell</span></div>
<div class="help-row"><span class="help-key">&#x25b6;/&#x2016;</span><span class="help-desc">toggle reactive mode (autorun)</span></div>
<div class="help-row"><span class="help-key">&#x25b6;&#x25b6; run all</span><span class="help-desc">run all cells</span></div>

<h2>builtins</h2>
<div class="help-row"><span class="help-key">display()</span><span class="help-desc">show text, objects, or DOM elements</span></div>
<div class="help-row"><span class="help-key">canvas(w,h)</span><span class="help-desc">create a canvas element</span></div>
<div class="help-row"><span class="help-key">table(data)</span><span class="help-desc">render array of objects as table</span></div>
<div class="help-row"><span class="help-key">slider()</span><span class="help-desc">reactive range input</span></div>
<div class="help-row"><span class="help-key">dropdown()</span><span class="help-desc">reactive select input</span></div>
<div class="help-row"><span class="help-key">checkbox()</span><span class="help-desc">reactive boolean input</span></div>
<div class="help-row"><span class="help-key">textInput()</span><span class="help-desc">reactive text input</span></div>
<div class="help-row"><span class="help-key">load(url)</span><span class="help-desc">import ESM module (cached)</span></div>
<div class="help-row"><span class="help-key">install(url)</span><span class="help-desc">import + embed in HTML on save</span></div>
<div class="help-row"><span class="help-key">installBinary(url)</span><span class="help-desc">fetch binary asset + embed gzipped</span></div>
<div class="help-row"><span class="help-key">invalidation</span><span class="help-desc">promise that resolves before cell re-runs</span></div>
<div class="help-row"><span class="help-key">md``</span><span class="help-desc">markdown tagged template</span></div>
<div class="help-row"><span class="help-key">html``</span><span class="help-desc">HTML tagged template</span></div>
<div class="help-row"><span class="help-key">css``</span><span class="help-desc">CSS tagged template</span></div>
<div class="help-row"><span class="help-key">workshop(pages)</span><span class="help-desc">interactive side panel with pages</span></div>
<div class="help-row"><span class="help-key">notebook</span><span class="help-desc">API for cells, scope, scrollTo, focus</span></div>

<h2>directives</h2>
<div class="help-row"><span class="help-key">// %manual</span><span class="help-desc">skip cell on reactive updates</span></div>
<div class="help-row"><span class="help-key">// %norun</span><span class="help-desc">skip cell on Run All</span></div>
<div class="help-row"><span class="help-key">// %hide</span><span class="help-desc">hide cell in present mode</span></div>
<div class="help-row"><span class="help-key">// %cellName &lt;label&gt;</span><span class="help-desc">name cell in DevTools</span></div>
<div class="help-row"><span class="help-key">// %outputId &lt;id&gt;</span><span class="help-desc">set id on output div</span></div>
<div class="help-row"><span class="help-key">// %outputClass &lt;cls&gt;</span><span class="help-desc">add classes to output div</span></div>
<div class="help-row"><span class="help-key">// %goto &lt;label&gt;</span><span class="help-desc">jump to named cell after execution</span></div>
<div class="help-row"><span class="help-key">// %collapsed</span><span class="help-desc">start cell collapsed</span></div>

<div class="help-close">press F1 or Esc to close</div>
</div>
</div>

<div class="settings-overlay" id="settingsOverlay" onclick="if(event.target===this)toggleSettings()"></div>
<div class="settings-panel" id="settingsPanel">
  <button class="settings-close" onclick="toggleSettings()">&#x00d7;</button>
  <h2>theme</h2>
  <div class="settings-row">
    <label>color scheme</label>
    <select id="setTheme" onchange="applyTheme(this.value)">
      <option value="dark">dark</option>
      <option value="light">light</option>
    </select>
  </div>

  <h2>editor</h2>
  <div class="settings-row">
    <label>font size</label>
    <input type="range" id="setFontSize" min="10" max="20" value="13" oninput="applyFontSize(this.value)">
    <span class="settings-val" id="setFontSizeVal">13</span>
  </div>
  <div class="settings-row">
    <label>line numbers</label>
    <select id="setLineNumbers" onchange="applyLineNumbers(this.value)">
      <option value="on" selected>on</option>
      <option value="off">off</option>
    </select>
  </div>

  <h2>notebook</h2>
  <div class="settings-row">
    <label>max width</label>
    <select id="setWidth" onchange="applyWidth(this.value)">
      <option value="720">narrow</option>
      <option value="860" selected>default</option>
      <option value="1100">wide</option>
      <option value="100%">full</option>
    </select>
  </div>
  <div class="settings-row">
    <label>cell header</label>
    <select id="setHeader" onchange="applyHeader(this.value)">
      <option value="auto" selected>auto</option>
      <option value="always">always visible</option>
      <option value="compact">compact</option>
      <option value="hover">hover only</option>
    </select>
  </div>

  <h2>execution</h2>
  <div class="settings-row">
    <label>mode</label>
    <select id="setExecMode" onchange="applyExecMode(this.value)">
      <option value="reactive">reactive</option>
      <option value="manual">manual</option>
    </select>
  </div>
  <div class="settings-row">
    <label>run on load</label>
    <select id="setRunOnLoad" onchange="applyRunOnLoad(this.value)">
      <option value="yes">yes</option>
      <option value="no">no</option>
    </select>
  </div>
  <div class="settings-row">
    <label>show run toggle</label>
    <select id="setShowToggle" onchange="applyShowToggle(this.value)">
      <option value="yes">yes</option>
      <option value="no">no</option>
    </select>
  </div>
  <div class="settings-desc">
    <strong>reactive</strong>: cells auto-run on edit, changes propagate.<br>
    <strong>manual</strong>: only Ctrl+Enter, Shift+Enter, or Run All.
  </div>
  <div class="settings-row">
    <label>global override</label>
    <select id="setGlobalExecMode" onchange="applyGlobalExecMode(this.value)">
      <option value="">(notebook default)</option>
      <option value="reactive">always reactive</option>
      <option value="manual">always manual</option>
    </select>
  </div>
  <div class="settings-row">
    <label>global run on load</label>
    <select id="setGlobalRunOnLoad" onchange="applyGlobalRunOnLoad(this.value)">
      <option value="">(notebook default)</option>
      <option value="yes">always run</option>
      <option value="no">never run</option>
    </select>
  </div>

  <h2>modules</h2>
  <div id="moduleList"></div>
  <h2>binaries</h2>
  <div id="binaryList"></div>

  <div class="settings-about">
    <span id="aboutVersion"></span>
    <span id="aboutBuild"></span>
    <span id="aboutRuntime"></span>
    <a href="https://github.com/endarthur/auditable" target="_blank">github.com/endarthur/auditable</a>
  </div>
</div>

<div class="update-overlay" id="updateOverlay" onclick="if(event.target===this)toggleUpdate()"></div>
<div class="update-panel" id="updatePanel">
  <button class="settings-close" onclick="toggleUpdate()">&#x00d7;</button>
  <h2>update</h2>
  <div class="settings-row">
    <label>version</label>
    <span id="updateCurrentVer">v0.0.0</span>
  </div>
  <div class="settings-row">
    <label>release</label>
    <span id="updateRelease">dev</span>
  </div>
  <div class="settings-row">
    <label>signature</label>
    <span id="updateSigStatus" class="update-sig">checking...</span>
  </div>
  <div class="settings-row">
    <label>public key</label>
    <span id="updatePubKey" class="update-sig">-</span>
  </div>
  <div id="updateStatus" class="update-status"></div>
  <div class="update-actions">
    <button id="updateCheckBtn" onclick="checkForUpdate()">check for updates</button>
    <button onclick="updateFromFile()">update from file</button>
  </div>
</div>

<div class="toolbar">
  <span class="toolbar-title">auditable</span>
  <span class="toolbar-badges" id="toolbarBadges"></span>
  <span class="toolbar-sep"></span>
  <span class="toolbar-filename">
    <input type="text" id="docTitle" value="atra — Wasm kernels" spellcheck="false">
  </span>
  <span class="toolbar-status" id="toolbarStatus"></span>
  <button class="toolbar-add" onclick="addCellWithUndo('code','',S.selectedId)">+ code</button>
  <button class="toolbar-add" onclick="addCellWithUndo('md','',S.selectedId)">+ md</button>
  <button class="toolbar-secondary" onclick="addCellWithUndo('css','',S.selectedId)">+ css</button>
  <button class="toolbar-secondary" onclick="addCellWithUndo('html','',S.selectedId)">+ html</button>
  <span class="toolbar-sep"></span>
  <span class="transport">
    <button onclick="runSelectedCell()" title="run cell + advance (Shift+Enter)">&#x23f5;</button>
    <button id="autorunBtn" class="autorun-on" onclick="toggleAutorun()" title="reactive mode &#x2014; cells auto-run on edit">&#x25b6;</button>
    <button onclick="runAll()" title="run all cells">&#x25b6;&#x25b6;</button>
  </span>
  <span class="toolbar-right">
    <span class="save-split">
      <button class="accent" onclick="saveNotebook()"><span id="saveLabel">save</span></button><button class="accent save-caret" onclick="toggleSaveTray()">&#x25be;</button>
      <div class="save-tray" id="saveTray">
        <button onclick="setSaveMode('normal');saveNotebook()">save</button>
        <button onclick="setSaveMode('packed');saveNotebook()">save packed</button>
        <button onclick="exportAsTxt();toggleSaveTray()">export .txt</button>
      </div>
    </span>
    <div class="toolbar-overflow">
      <button onclick="toggleToolbarMenu()" title="more">&#x22ef;</button>
      <div class="toolbar-overflow-tray">
        <button onclick="newNotebook();toggleToolbarMenu()">new</button>
        <button onclick="collapseAll();toggleToolbarMenu()">collapse all</button>
        <button onclick="expandAll();toggleToolbarMenu()">expand all</button>
        <button onclick="$('#helpOverlay').classList.toggle('visible');toggleToolbarMenu()">help (F1)</button>
        <button onclick="toggleSettings();toggleToolbarMenu()">settings</button>
        <button class="toolbar-update-btn" onclick="toggleUpdate();toggleToolbarMenu()">update</button>
        <button onclick="togglePresent();toggleToolbarMenu()">present</button>
        <button onclick="openFind(false);toggleToolbarMenu()">find (Ctrl+F)</button>
      </div>
    </div>
  </span>
</div>

<div class="find-bar" id="findBar">
  <div class="find-row">
    <input type="text" id="findInput" placeholder="find" spellcheck="false" autocomplete="off">
    <span class="find-count" id="findCount"></span>
    <button id="findRegexBtn" title="use regex">.*</button>
    <button id="findCaseBtn" title="match case">Aa</button>
    <button id="findPrevBtn" title="previous (Shift+Enter)">&#x2191;</button>
    <button id="findNextBtn" title="next (Enter)">&#x2193;</button>
    <button id="findCloseBtn" title="close (Esc)">&#x00d7;</button>
  </div>
  <div class="find-replace-row" id="findReplaceRow">
    <input type="text" id="replaceInput" placeholder="replace" spellcheck="false" autocomplete="off">
    <button id="findReplaceBtn">replace</button>
    <button id="findReplaceAllBtn">all</button>
  </div>
</div>

<button class="present-exit" onclick="togglePresent()">&#x2715; exit</button>

<div class="notebook" id="notebook">
  <!-- cells go here -->
</div>

<div class="statusbar">
  <span class="status-size" id="statusSize"></span>
  <span class="status-cells" id="statusCells">0 cells</span>
  <span class="status-msg" id="statusMsg"></span>
  <span class="status-attr">
    <a href="https://endarthur.github.io" target="_blank">endarthur</a>
    <span>&middot;</span>
    <a href="https://gentropic.org" target="_blank">geoscientific chaos union</a>
    <span>&middot;</span>
    <a href="https://github.com/endarthur/auditable" target="_blank" title="source on GitHub"><svg width="14" height="14" viewBox="0 0 16 16" fill="currentColor"><path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"/></svg></a>
  </span>
  <div class="action-bar">
    <div>
      <div class="action-add-tray">
        <button onclick="insertAt(S.selectedId,'code');toggleAddTray()">+ code</button>
        <button onclick="insertAt(S.selectedId,'md');toggleAddTray()">+ md</button>
        <button onclick="insertAt(S.selectedId,'css');toggleAddTray()">+ css</button>
        <button onclick="insertAt(S.selectedId,'html');toggleAddTray()">+ html</button>
      </div>
      <button class="action-add" onclick="toggleAddTray()">+</button>
    </div>
    <button onclick="runSelectedCell()" title="run cell + advance">&#x23f5;</button>
    <button id="autorunBtnMobile" class="autorun-on" onclick="toggleAutorun()" title="autorun">&#x25b6;</button>
    <button onclick="runAll()" title="run all">&#x25b6;&#x25b6;</button>
    <div>
      <div class="action-more-tray">
        <button onclick="newNotebook();toggleMoreTray()">new</button>
        <button id="mobileSaveBtn" class="active-mode" onclick="setSaveMode('normal');saveNotebook();toggleMoreTray()">save</button>
        <button id="mobilePackBtn" onclick="setSaveMode('packed');saveNotebook();toggleMoreTray()">save packed</button>
        <button onclick="collapseAll();toggleMoreTray()">collapse all</button>
        <button onclick="expandAll();toggleMoreTray()">expand all</button>
        <button onclick="$('#helpOverlay').classList.toggle('visible');toggleMoreTray()">help</button>
        <button onclick="toggleSettings();toggleMoreTray()">settings</button>
        <button class="toolbar-update-btn" onclick="toggleUpdate();toggleMoreTray()">update</button>
        <button onclick="togglePresent();toggleMoreTray()">present</button>
        <button onclick="openFind(false);toggleMoreTray()">find</button>
      </div>
      <button class="action-more" onclick="toggleMoreTray()">&#x22ef;</button>
    </div>
  </div>
</div>


<!-- cell data: JSON array of {type, code, collapsed?} -->
<!--AUDITABLE-DATA
[{"type":"md","code":"# atra — WebAssembly numerical kernels\n\n[atra](ext/atra/SPEC.md) is a Fortran/Pascal hybrid that compiles to WebAssembly bytecode via tagged template literals. no toolchain, no build step — one JS file turns formulas into bytecode.\n\nthis notebook computes three **variogram models** (spherical, gaussian, exponential) and uses `call_indirect` to pass the selected model as a function reference to a grid evaluator — the hot loop runs entirely in Wasm, calling the chosen model through a function pointer."},{"type":"code","code":"const { atra } = await load(\"./ext/atra/index.js\");"},{"type":"code","code":"// three variogram models + indirect-call grid evaluator\n// compiled to WebAssembly — model selection via call_indirect\n\nconst modelName = ui.dropdown(\"model\", [\"spherical\",\"gaussian\",\"exponential\"]);\nconst range0 = ui.slider(\"range\", 60, {min:10, max:200, step:1});\nconst sill0 = ui.slider(\"sill\", 1.0, {min:0.1, max:3.0, step:0.1});\nconst nugget0 = ui.slider(\"nugget\", 0.1, {min:0.0, max:1.0, step:0.05});\nconst nPts = ui.slider(\"samples\", 30, {min:5, max:100, step:1});\nconst gridN = ui.slider(\"grid\", 120, {min:40, max:250, step:10});"},{"type":"code","code":"// compile atra kernels to Wasm\nconst mem = new WebAssembly.Memory({ initial: 4 }); // 256 KB\n\nconst wasm = atra({ memory: mem })`\n  ! ── variogram models ──\n  ! all share the same signature: (h, a, c1, c0: f64): f64\n\n  ! spherical: γ(h) = c0 + c1 * (1.5h/a - 0.5(h/a)^3)\n  function spherical(h, a, c1, c0: f64): f64\n  begin\n    if (h <= 0.0) then\n      spherical := 0.0\n    else if (h >= a) then\n      spherical := c0 + c1\n    else\n      spherical := c0 + c1 * (1.5 * h / a - 0.5 * (h / a) ** 3)\n    end if\n  end\n\n  ! gaussian: γ(h) = c0 + c1 * (1 - exp(-3(h/a)²))\n  function gaussian(h, a, c1, c0: f64): f64\n  begin\n    if (h <= 0.0) then\n      gaussian := 0.0\n    else\n      gaussian := c0 + c1 * (1.0 - exp(-3.0 * (h / a) ** 2))\n    end if\n  end\n\n  ! exponential: γ(h) = c0 + c1 * (1 - exp(-3h/a))\n  function exponential(h, a, c1, c0: f64): f64\n  begin\n    if (h <= 0.0) then\n      exponential := 0.0\n    else\n      exponential := c0 + c1 * (1.0 - exp(-3.0 * h / a))\n    end if\n  end\n\n  ! ── grid evaluator with indirect call ──\n  ! the model parameter is a function reference (table index)\n  ! call_indirect dispatches to whichever model was passed\n  subroutine eval_grid(\n    model: function(h, a, c1, c0: f64): f64,\n    samples: array f64; nSamples: i32;\n    grid: array f64; gridN: i32;\n    a, c1, c0: f64\n  )\n  var\n    ix, iy, k: i32\n    gx, gy, dx, dy, dist, gamma, w, wsum, vsum: f64\n  begin\n    for iy := 0, gridN\n      for ix := 0, gridN\n        gx := f64(ix) / f64(gridN)\n        gy := f64(iy) / f64(gridN)\n        wsum := 0.0\n        vsum := 0.0\n        for k := 0, nSamples\n          dx := gx - samples[k * 3]\n          dy := gy - samples[k * 3 + 1]\n          dist := sqrt(dx * dx + dy * dy)\n          if (dist < 1e-10) then\n            wsum := 1.0\n            vsum := samples[k * 3 + 2]\n            break\n          end if\n          gamma := model(dist, a, c1, c0)\n          if (gamma > 0.0) then\n            w := 1.0 / gamma\n          else\n            w := 1e10\n          end if\n          wsum += w\n          vsum += w * samples[k * 3 + 2]\n        end for\n        grid[iy * gridN + ix] := vsum / wsum\n      end for\n    end for\n  end\n\n  ! ── dispatch: select model by id, pass as function reference ──\n  subroutine run_model(\n    model_id: i32,\n    samples: array f64; nSamples: i32;\n    grid: array f64; gridN: i32;\n    a, c1, c0: f64\n  )\n  var model: function(h, a, c1, c0: f64): f64\n  begin\n    if (model_id == 0) then\n      model := spherical\n    else if (model_id == 1) then\n      model := gaussian\n    else\n      model := exponential\n    end if\n    call eval_grid(model, samples, nSamples, grid, gridN, a, c1, c0)\n  end\n`;\n\n// wasm.__table maps function names to their call_indirect table indices\n// { spherical: 0, gaussian: 1, exponential: 2, eval_grid: 3, run_model: 4 }"},{"type":"code","code":"// generate seeded samples + run Wasm kernel\nfunction mulberry32(a) {\n  return function() {\n    a |= 0; a = a + 0x6D2B79F5 | 0;\n    let t = Math.imul(a ^ a >>> 15, 1 | a);\n    t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;\n    return ((t ^ t >>> 14) >>> 0) / 4294967296;\n  };\n}\nconst rng = mulberry32(42);\n\n// pack samples into Wasm memory as f64 triples\nconst buf = new Float64Array(mem.buffer);\nconst samplesPtr = 0;\nfor (let i = 0; i < nPts; i++) {\n  const x = rng(), y = rng();\n  const trend = 0.5 * Math.sin(x * 4.0) * Math.cos(y * 3.0) + 0.5;\n  buf[i * 3 + 0] = x;\n  buf[i * 3 + 1] = y;\n  buf[i * 3 + 2] = 0.3 * rng() + 0.7 * trend;\n}\n\nconst gridPtr = nPts * 3 * 8; // after sample data\n\nconst t0 = performance.now();\nwasm.run_model(wasm.__table[modelName], samplesPtr, nPts, gridPtr, gridN, range0 / 200, sill0, nugget0);\nconst elapsed = (performance.now() - t0).toFixed(2);\n\n// read grid back\nconst grid = new Float64Array(mem.buffer, gridPtr, gridN * gridN);"},{"type":"code","code":"// render\nconst size = Math.min(500, window.innerWidth - 80);\nconst c = ui.canvas(size, size);\nconst ctx = c.getContext(\"2d\");\n\nfunction viridis(t) {\n  t = Math.max(0, Math.min(1, t));\n  const r = Math.round(255 * Math.max(0, Math.min(1,\n    0.267 + t * (0.004 + t * (5.294 + t * (-14.05 + t * 8.5))))));\n  const g = Math.round(255 * Math.max(0, Math.min(1,\n    0.004 + t * (1.384 + t * (0.098 + t * (-2.74 + t * 2.23))))));\n  const b = Math.round(255 * Math.max(0, Math.min(1,\n    0.329 + t * (1.44 + t * (-5.11 + t * (6.87 + t * -3.57))))));\n  return `rgb(${r},${g},${b})`;\n}\n\nlet vmin = Infinity, vmax = -Infinity;\nfor (let i = 0; i < grid.length; i++) {\n  if (grid[i] < vmin) vmin = grid[i];\n  if (grid[i] > vmax) vmax = grid[i];\n}\nconst vrange = vmax - vmin || 1;\n\nconst cellW = size / gridN;\nfor (let iy = 0; iy < gridN; iy++) {\n  for (let ix = 0; ix < gridN; ix++) {\n    const t = (grid[iy * gridN + ix] - vmin) / vrange;\n    ctx.fillStyle = viridis(t);\n    ctx.fillRect(ix * cellW, iy * cellW, cellW + 0.5, cellW + 0.5);\n  }\n}\n\n// overlay sample points\nfor (let i = 0; i < nPts; i++) {\n  const x = buf[i * 3] * size, y = buf[i * 3 + 1] * size;\n  ctx.beginPath();\n  ctx.arc(x, y, 4, 0, Math.PI * 2);\n  ctx.fillStyle = \"#fff\";\n  ctx.fill();\n  ctx.lineWidth = 1.5;\n  ctx.strokeStyle = \"#000\";\n  ctx.stroke();\n}\n\nui.display(`${modelName} \\u00b7 ${gridN}\\u00d7${gridN} grid \\u00b7 ${nPts} samples \\u00b7 Wasm kernel: ${elapsed} ms`);"},{"type":"code","code":"// variogram curve plot\nconst cvs = ui.canvas(500, 200);\nconst cx = cvs.getContext(\"2d\");\nconst w = 500, h = 200, pad = 40;\n\ncx.fillStyle = \"#181818\";\ncx.fillRect(0, 0, w, h);\n\n// axes\ncx.strokeStyle = \"#555\";\ncx.lineWidth = 1;\ncx.beginPath();\ncx.moveTo(pad, h - pad); cx.lineTo(w - 10, h - pad);\ncx.moveTo(pad, h - pad); cx.lineTo(pad, 10);\ncx.stroke();\n\ncx.fillStyle = \"#999\";\ncx.font = \"11px monospace\";\ncx.fillText(\"h\", w - 20, h - pad + 4);\ncx.fillText(\"\\u03b3(h)\", pad - 4, 14);\n\n// plot selected model curve\nconst evalModel = wasm[modelName]; // spherical, gaussian, or exponential\nconst maxH = 1.2;\nconst maxG = nugget0 + sill0 * 1.15;\ncx.strokeStyle = \"#c89b3c\";\ncx.lineWidth = 2;\ncx.beginPath();\nfor (let i = 0; i <= 200; i++) {\n  const hv = (i / 200) * maxH;\n  const gv = evalModel(hv, range0 / 200, sill0, nugget0);\n  const px = pad + (hv / maxH) * (w - pad - 10);\n  const py = (h - pad) - (gv / maxG) * (h - pad - 20);\n  if (i === 0) cx.moveTo(px, py); else cx.lineTo(px, py);\n}\ncx.stroke();\n\n// tick labels\ncx.fillStyle = \"#888\";\nfor (let i = 0; i <= 4; i++) {\n  const hv = (i / 4) * maxH;\n  const px = pad + (hv / maxH) * (w - pad - 10);\n  cx.fillText(hv.toFixed(2), px - 12, h - pad + 14);\n}\nfor (let i = 0; i <= 3; i++) {\n  const gv = (i / 3) * maxG;\n  const py = (h - pad) - (gv / maxG) * (h - pad - 20);\n  cx.fillText(gv.toFixed(2), 2, py + 4);\n}"},{"type":"md","code":"**how it works:** the `atra` tagged template compiles three variogram models and a grid evaluator to WebAssembly bytecode — no toolchain, just `atra\\`...\\``. the grid evaluator takes a **function reference** as its first parameter (`model: function(...)`), so the same Wasm subroutine handles all three models via `call_indirect`. sample data is packed into Wasm linear memory as `f64` triples, and the nested loop runs as native Wasm instructions. the resulting grid is rendered with a viridis colormap."}]
AUDITABLE-DATA-->
<!-- installed modules: base64-encoded JSON mapping URLs to {source, cellId} -->
<!--AUDITABLE-MODULES
eyIuL2V4dC9hdHJhL2luZGV4LmpzIjp7InNvdXJjZSI6Ii8vIEBhdWRpdGFibGUvYXRyYSDigJQg
QXJpdGhtZXRpYyBUUkFuc3BpbGVyXG4vLyBGb3J0cmFuL1Bhc2NhbCBoeWJyaWQg4oaSIFdlYkFz
c2VtYmx5IGJ5dGVjb2RlLiBTaW5nbGUtZmlsZSBjb21waWxlci5cblxuLy8g4pWQ4pWQ4pWQ4pWQ
4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ
4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ
4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ
4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQXG4vLyAxLiBISUdITElH
SFQgVE9LRU5JWkVSICsgQ09NUExFVElPTlMgKGZvciBhdWRpdGFibGUgc3ludGF4IGhpZ2hsaWdo
dGluZylcbi8vIOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKV
kOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKV
kOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKV
kOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKV
kOKVkOKVkFxuXG5jb25zdCBBVFJBX0tFWVdPUkRTID0gbmV3IFNldChbXG4gICdmdW5jdGlvbics
J3N1YnJvdXRpbmUnLCdiZWdpbicsJ2VuZCcsJ3ZhcicsJ2NvbnN0JywnaWYnLCd0aGVuJywnZWxz
ZScsXG4gICdmb3InLCd3aGlsZScsJ2RvJywnYnJlYWsnLCdhbmQnLCdvcicsJ25vdCcsJ21vZCcs
J2ltcG9ydCcsJ2V4cG9ydCcsXG4gICdjYWxsJywnYXJyYXknLCd0cnVlJywnZmFsc2UnLCdmcm9t
Jyxcbl0pO1xuXG5jb25zdCBBVFJBX1RZUEVTID0gbmV3IFNldChbJ2kzMicsJ2k2NCcsJ2YzMics
J2Y2NCcsJ2Y2NHgyJywnZjMyeDQnLCdpMzJ4NCcsJ2k2NHgyJ10pO1xuXG5jb25zdCBBVFJBX0JV
SUxUSU5TID0gbmV3IFNldChbXG4gICdzaW4nLCdjb3MnLCdzcXJ0JywnYWJzJywnZmxvb3InLCdj
ZWlsJywnbG4nLCdleHAnLCdwb3cnLFxuICAnbWluJywnbWF4JywndHJ1bmMnLCduZWFyZXN0Jywn
Y29weXNpZ24nLCdzZWxlY3QnLFxuICAnY2x6JywnY3R6JywncG9wY250Jywncm90bCcsJ3JvdHIn
LCdtZW1vcnlfc2l6ZScsJ21lbW9yeV9ncm93JyxcbiAgJ21lbW9yeV9jb3B5JywnbWVtb3J5X2Zp
bGwnLFxuXSk7XG5cbmNvbnN0IEFUUkFfVkVDVE9SX1RZUEVTID0gbmV3IFNldChbJ2Y2NHgyJywn
ZjMyeDQnLCdpMzJ4NCcsJ2k2NHgyJ10pO1xuXG5mdW5jdGlvbiB0b2tlbml6ZUF0cmEoY29kZSkg
e1xuICBjb25zdCB0b2tlbnMgPSBbXTtcbiAgbGV0IGkgPSAwO1xuICBjb25zdCBsZW4gPSBjb2Rl
Lmxlbmd0aDtcblxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIC8vIGxpbmUgY29tbWVudDogISB0
byBlbmQgb2YgbGluZVxuICAgIGlmIChjb2RlW2ldID09PSAnIScpIHtcbiAgICAgIGNvbnN0IHN0
YXJ0ID0gaTtcbiAgICAgIHdoaWxlIChpIDwgbGVuICYmIGNvZGVbaV0gIT09ICdcXG4nKSBpKys7
XG4gICAgICB0b2tlbnMucHVzaCh7IHR5cGU6ICdjbXQnLCB0ZXh0OiBjb2RlLnNsaWNlKHN0YXJ0
LCBpKSB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICAvLyBudW1iZXJzICh3aXRoIG9w
dGlvbmFsIHR5cGUgc3VmZml4IF9mMzIsIF9mNjQsIF9pMzIsIF9pNjQpXG4gICAgaWYgKC9cXGQv
LnRlc3QoY29kZVtpXSkgfHwgKGNvZGVbaV0gPT09ICcuJyAmJiBpICsgMSA8IGxlbiAmJiAvXFxk
Ly50ZXN0KGNvZGVbaSArIDFdKSkpIHtcbiAgICAgIGNvbnN0IHN0YXJ0ID0gaTtcbiAgICAgIHdo
aWxlIChpIDwgbGVuICYmIC9bMC05Ll0vLnRlc3QoY29kZVtpXSkpIGkrKztcbiAgICAgIGlmIChp
IDwgbGVuICYmIC9bZUVdLy50ZXN0KGNvZGVbaV0pKSB7XG4gICAgICAgIGkrKztcbiAgICAgICAg
aWYgKGkgPCBsZW4gJiYgL1srLV0vLnRlc3QoY29kZVtpXSkpIGkrKztcbiAgICAgICAgd2hpbGUg
KGkgPCBsZW4gJiYgL1xcZC8udGVzdChjb2RlW2ldKSkgaSsrO1xuICAgICAgfVxuICAgICAgLy8g
dHlwZSBzdWZmaXg6IF9mMzIsIF9mNjQsIF9pMzIsIF9pNjRcbiAgICAgIGlmIChjb2RlW2ldID09
PSAnXycgJiYgaSArIDMgPD0gbGVuICYmIC9eW2ZpXS8udGVzdChjb2RlW2kgKyAxXSkpIHtcbiAg
ICAgICAgY29uc3Qgc3VmID0gY29kZS5zbGljZShpICsgMSwgaSArIDQpO1xuICAgICAgICBpZiAo
QVRSQV9UWVBFUy5oYXMoc3VmKSkgaSArPSA0O1xuICAgICAgfVxuICAgICAgdG9rZW5zLnB1c2go
eyB0eXBlOiAnbnVtJywgdGV4dDogY29kZS5zbGljZShzdGFydCwgaSkgfSk7XG4gICAgICBjb250
aW51ZTtcbiAgICB9XG4gICAgLy8gaWRlbnRpZmllcnMgLyBrZXl3b3Jkc1xuICAgIGlmICgvW2Et
ekEtWl9dLy50ZXN0KGNvZGVbaV0pKSB7XG4gICAgICBjb25zdCBzdGFydCA9IGk7XG4gICAgICB3
aGlsZSAoaSA8IGxlbiAmJiAvW1xcdy5dLy50ZXN0KGNvZGVbaV0pKSBpKys7XG4gICAgICBjb25z
dCB3b3JkID0gY29kZS5zbGljZShzdGFydCwgaSk7XG4gICAgICBjb25zdCBsb3dlciA9IHdvcmQu
dG9Mb3dlckNhc2UoKTtcbiAgICAgIGlmIChBVFJBX0tFWVdPUkRTLmhhcyhsb3dlcikpIHtcbiAg
ICAgICAgdG9rZW5zLnB1c2goeyB0eXBlOiAna3cnLCB0ZXh0OiB3b3JkIH0pO1xuICAgICAgfSBl
bHNlIGlmIChBVFJBX1RZUEVTLmhhcyhsb3dlcikpIHtcbiAgICAgICAgLy8gdHlwZSBuYW1lcyBh
cyBidWlsdGlucyB3aGVuIGZvbGxvd2VkIGJ5IChcbiAgICAgICAgaWYgKGkgPCBsZW4gJiYgY29k
ZVtpXSA9PT0gJygnKSB7XG4gICAgICAgICAgdG9rZW5zLnB1c2goeyB0eXBlOiAnZm4nLCB0ZXh0
OiB3b3JkIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRva2Vucy5wdXNoKHsgdHlw
ZTogJ2NvbnN0JywgdGV4dDogd29yZCB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChB
VFJBX0JVSUxUSU5TLmhhcyhsb3dlcikgfHwgbG93ZXIuc3RhcnRzV2l0aCgnd2FzbS4nKSB8fFxu
ICAgICAgICAgICAgICAgICBsb3dlci5zdGFydHNXaXRoKCd2MTI4LicpIHx8IChBVFJBX1ZFQ1RP
Ul9UWVBFUy5oYXMobG93ZXIuc3BsaXQoJy4nKVswXSkgJiYgbG93ZXIuaW5jbHVkZXMoJy4nKSkp
IHtcbiAgICAgICAgdG9rZW5zLnB1c2goeyB0eXBlOiAnZm4nLCB0ZXh0OiB3b3JkIH0pO1xuICAg
ICAgfSBlbHNlIGlmIChpIDwgbGVuICYmIGNvZGVbaV0gPT09ICcoJykge1xuICAgICAgICB0b2tl
bnMucHVzaCh7IHR5cGU6ICdmbicsIHRleHQ6IHdvcmQgfSk7XG4gICAgICB9IGVsc2Uge1xuICAg
ICAgICB0b2tlbnMucHVzaCh7IHR5cGU6ICdpZCcsIHRleHQ6IHdvcmQgfSk7XG4gICAgICB9XG4g
ICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgLy8gbXVsdGktY2hhciBvcGVyYXRvcnNcbiAgICBp
ZiAoaSArIDEgPCBsZW4pIHtcbiAgICAgIGNvbnN0IHR3byA9IGNvZGVbaV0gKyBjb2RlW2kgKyAx
XTtcbiAgICAgIGlmICh0d28gPT09ICcqKicgfHwgdHdvID09PSAnOj0nIHx8IHR3byA9PT0gJys9
JyB8fCB0d28gPT09ICctPScgfHxcbiAgICAgICAgICB0d28gPT09ICcqPScgfHwgdHdvID09PSAn
Lz0nIHx8IHR3byA9PT0gJz09JyB8fCB0d28gPT09ICc8PScgfHxcbiAgICAgICAgICB0d28gPT09
ICc+PScgfHwgdHdvID09PSAnPDwnIHx8IHR3byA9PT0gJz4+Jykge1xuICAgICAgICB0b2tlbnMu
cHVzaCh7IHR5cGU6ICdvcCcsIHRleHQ6IHR3byB9KTtcbiAgICAgICAgaSArPSAyO1xuICAgICAg
ICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIC8vIC89IGlzIG5vdC1lcXVhbCAobXVzdCBjaGVj
ayBpdCdzIG5vdCAvPXNvbWV0aGluZyBhcyBkaXZpZGUtYXNzaWduIOKAlCBidXQgaW4gYXRyYSAv
PSBpcyBub3QtZXF1YWwpXG4gICAgICBpZiAoY29kZVtpXSA9PT0gJy8nICYmIGNvZGVbaSArIDFd
ID09PSAnPScpIHtcbiAgICAgICAgdG9rZW5zLnB1c2goeyB0eXBlOiAnb3AnLCB0ZXh0OiAnLz0n
IH0pO1xuICAgICAgICBpICs9IDI7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1c
biAgICAvLyBzaW5nbGUtY2hhciBvcGVyYXRvcnNcbiAgICBpZiAoJystKi88Pj0mfF5+Jy5pbmNs
dWRlcyhjb2RlW2ldKSkge1xuICAgICAgdG9rZW5zLnB1c2goeyB0eXBlOiAnb3AnLCB0ZXh0OiBj
b2RlW2ldIH0pO1xuICAgICAgaSsrO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIC8vIHB1
bmN0dWF0aW9uXG4gICAgaWYgKCcoKVtdOyw6Jy5pbmNsdWRlcyhjb2RlW2ldKSkge1xuICAgICAg
dG9rZW5zLnB1c2goeyB0eXBlOiAncHVuYycsIHRleHQ6IGNvZGVbaV0gfSk7XG4gICAgICBpKys7
XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgLy8gd2hpdGVzcGFjZSAvIG90aGVyXG4gICAg
dG9rZW5zLnB1c2goeyB0eXBlOiAnJywgdGV4dDogY29kZVtpXSB9KTtcbiAgICBpKys7XG4gIH1c
biAgcmV0dXJuIHRva2Vucztcbn1cblxuZnVuY3Rpb24gYXRyYUNvbXBsZXRpb25zKCkge1xuICBj
b25zdCBpdGVtcyA9IFtdO1xuICBmb3IgKGNvbnN0IHcgb2YgQVRSQV9LRVlXT1JEUykgaXRlbXMu
cHVzaCh7IHRleHQ6IHcsIGtpbmQ6ICdrdycgfSk7XG4gIGZvciAoY29uc3QgdyBvZiBBVFJBX1RZ
UEVTKSAgICBpdGVtcy5wdXNoKHsgdGV4dDogdywga2luZDogJ2NvbnN0JyB9KTtcbiAgZm9yIChj
b25zdCB3IG9mIEFUUkFfQlVJTFRJTlMpIGl0ZW1zLnB1c2goeyB0ZXh0OiB3LCBraW5kOiAnZm4n
IH0pO1xuICByZXR1cm4gaXRlbXM7XG59XG5cbi8vIOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKV
kOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKV
kOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKV
kOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKV
kOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkFxuLy8gMi4gQ09NUElMRVIgVE9LRU5JWkVSXG4v
LyDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDi
lZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDi
lZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDi
lZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZBc
blxuY29uc3QgVE9LID0ge1xuICBOVU06ICdudW0nLCBJRDogJ2lkJywgS1c6ICdrdycsIE9QOiAn
b3AnLCBQVU5DOiAncHVuYycsIEVPRjogJ2VvZicsXG59O1xuXG5mdW5jdGlvbiBsZXgoc291cmNl
KSB7XG4gIGNvbnN0IHRva2VucyA9IFtdO1xuICBsZXQgaSA9IDAsIGxpbmUgPSAxLCBjb2wgPSAx
O1xuICBjb25zdCBsZW4gPSBzb3VyY2UubGVuZ3RoO1xuXG4gIGZ1bmN0aW9uIGFkdigpIHsgaWYg
KHNvdXJjZVtpXSA9PT0gJ1xcbicpIHsgbGluZSsrOyBjb2wgPSAxOyB9IGVsc2UgeyBjb2wrKzsg
fSBpKys7IH1cbiAgZnVuY3Rpb24gcGVlaygpIHsgcmV0dXJuIGkgPCBsZW4gPyBzb3VyY2VbaV0g
OiAnJzsgfVxuICBmdW5jdGlvbiBwZWVrMigpIHsgcmV0dXJuIGkgKyAxIDwgbGVuID8gc291cmNl
W2ldICsgc291cmNlW2kgKyAxXSA6IHNvdXJjZVtpXSB8fCAnJzsgfVxuXG4gIHdoaWxlIChpIDwg
bGVuKSB7XG4gICAgLy8gc2tpcCB3aGl0ZXNwYWNlIGFuZCBzZW1pY29sb25zXG4gICAgaWYgKCcg
XFx0XFxyXFxuOycuaW5jbHVkZXMoc291cmNlW2ldKSkgeyBhZHYoKTsgY29udGludWU7IH1cbiAg
ICAvLyBjb21tZW50XG4gICAgaWYgKHNvdXJjZVtpXSA9PT0gJyEnKSB7XG4gICAgICB3aGlsZSAo
aSA8IGxlbiAmJiBzb3VyY2VbaV0gIT09ICdcXG4nKSBhZHYoKTtcbiAgICAgIGNvbnRpbnVlO1xu
ICAgIH1cbiAgICBjb25zdCB0bCA9IGxpbmUsIHRjID0gY29sO1xuICAgIC8vIG51bWJlclxuICAg
IGlmICgvXFxkLy50ZXN0KHNvdXJjZVtpXSkgfHwgKHNvdXJjZVtpXSA9PT0gJy4nICYmIGkgKyAx
IDwgbGVuICYmIC9cXGQvLnRlc3Qoc291cmNlW2kgKyAxXSkpKSB7XG4gICAgICBjb25zdCBzdGFy
dCA9IGk7XG4gICAgICBsZXQgaXNGbG9hdCA9IGZhbHNlO1xuICAgICAgd2hpbGUgKGkgPCBsZW4g
JiYgL1xcZC8udGVzdChzb3VyY2VbaV0pKSBhZHYoKTtcbiAgICAgIGlmIChwZWVrKCkgPT09ICcu
JyAmJiAvXFxkLy50ZXN0KHNvdXJjZVtpICsgMV0gfHwgJycpKSB7IGlzRmxvYXQgPSB0cnVlOyBh
ZHYoKTsgd2hpbGUgKGkgPCBsZW4gJiYgL1xcZC8udGVzdChzb3VyY2VbaV0pKSBhZHYoKTsgfVxu
ICAgICAgaWYgKC9bZUVdLy50ZXN0KHBlZWsoKSkpIHsgaXNGbG9hdCA9IHRydWU7IGFkdigpOyBp
ZiAoL1srLV0vLnRlc3QocGVlaygpKSkgYWR2KCk7IHdoaWxlIChpIDwgbGVuICYmIC9cXGQvLnRl
c3Qoc291cmNlW2ldKSkgYWR2KCk7IH1cbiAgICAgIGxldCB0eXBlU3VmZml4ID0gbnVsbDtcbiAg
ICAgIGlmIChwZWVrKCkgPT09ICdfJykge1xuICAgICAgICBjb25zdCBzID0gc291cmNlLnNsaWNl
KGkgKyAxLCBpICsgNCk7XG4gICAgICAgIGlmIChBVFJBX1RZUEVTLmhhcyhzKSkgeyB0eXBlU3Vm
Zml4ID0gczsgYWR2KCk7IGFkdigpOyBhZHYoKTsgYWR2KCk7IH1cbiAgICAgIH1cbiAgICAgIGNv
bnN0IHJhdyA9IHNvdXJjZS5zbGljZShzdGFydCwgaSk7XG4gICAgICB0b2tlbnMucHVzaCh7IHR5
cGU6IFRPSy5OVU0sIHZhbHVlOiByYXcsIGlzRmxvYXQsIHR5cGVTdWZmaXgsIGxpbmU6IHRsLCBj
b2w6IHRjIH0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIC8vIGlkZW50aWZpZXIgKGlu
Y2x1ZGluZyB3YXNtLnh4eClcbiAgICBpZiAoL1thLXpBLVpfXS8udGVzdChzb3VyY2VbaV0pKSB7
XG4gICAgICBjb25zdCBzdGFydCA9IGk7XG4gICAgICB3aGlsZSAoaSA8IGxlbiAmJiAvXFx3Ly50
ZXN0KHNvdXJjZVtpXSkpIGFkdigpO1xuICAgICAgLy8gaGFuZGxlIHdhc20ueHh4LCB2MTI4Lnh4
eCwgZjY0eDIueHh4LCBmMzJ4NC54eHgsIGkzMng0Lnh4eCwgaTY0eDIueHh4XG4gICAgICBjb25z
dCBpZFdvcmQgPSBzb3VyY2Uuc2xpY2Uoc3RhcnQsIGkpO1xuICAgICAgaWYgKChpZFdvcmQgPT09
ICd3YXNtJyB8fCBpZFdvcmQgPT09ICd2MTI4JyB8fCBBVFJBX1ZFQ1RPUl9UWVBFUy5oYXMoaWRX
b3JkKSkgJiYgcGVlaygpID09PSAnLicpIHtcbiAgICAgICAgYWR2KCk7IC8vIHNraXAgLlxuICAg
ICAgICB3aGlsZSAoaSA8IGxlbiAmJiAvW1xcd10vLnRlc3Qoc291cmNlW2ldKSkgYWR2KCk7XG4g
ICAgICB9XG4gICAgICBsZXQgdmFsID0gc291cmNlLnNsaWNlKHN0YXJ0LCBpKTtcbiAgICAgIC8v
IGludGVycG9sYXRpb24gbWFya2VyczogX19JTlRFUlBfTl9fXG4gICAgICBpZiAoL15fX0lOVEVS
UF9cXGQrX18kLy50ZXN0KHZhbCkpIHtcbiAgICAgICAgdG9rZW5zLnB1c2goeyB0eXBlOiBUT0su
SUQsIHZhbHVlOiB2YWwsIGludGVycDogdHJ1ZSwgbGluZTogdGwsIGNvbDogdGMgfSk7XG4gICAg
ICB9IGVsc2UgaWYgKEFUUkFfS0VZV09SRFMuaGFzKHZhbCkgfHwgQVRSQV9UWVBFUy5oYXModmFs
KSkge1xuICAgICAgICB0b2tlbnMucHVzaCh7IHR5cGU6IFRPSy5LVywgdmFsdWU6IHZhbCwgbGlu
ZTogdGwsIGNvbDogdGMgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0b2tlbnMucHVzaCh7
IHR5cGU6IFRPSy5JRCwgdmFsdWU6IHZhbCwgbGluZTogdGwsIGNvbDogdGMgfSk7XG4gICAgICB9
XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgLy8gbXVsdGktY2hhciBvcGVyYXRvcnNcbiAg
ICBjb25zdCB0dyA9IHBlZWsyKCk7XG4gICAgaWYgKHR3ID09PSAnKionIHx8IHR3ID09PSAnOj0n
IHx8IHR3ID09PSAnKz0nIHx8IHR3ID09PSAnLT0nIHx8IHR3ID09PSAnKj0nIHx8XG4gICAgICAg
IHR3ID09PSAnPT0nIHx8IHR3ID09PSAnPD0nIHx8IHR3ID09PSAnPj0nIHx8IHR3ID09PSAnPDwn
IHx8IHR3ID09PSAnPj4nKSB7XG4gICAgICB0b2tlbnMucHVzaCh7IHR5cGU6IFRPSy5PUCwgdmFs
dWU6IHR3LCBsaW5lOiB0bCwgY29sOiB0YyB9KTtcbiAgICAgIGFkdigpOyBhZHYoKTtcbiAgICAg
IGNvbnRpbnVlO1xuICAgIH1cbiAgICAvLyAvPSDigJQgdGhpcyBpcyBub3QtZXF1YWwgaW4gYXRy
YVxuICAgIGlmIChzb3VyY2VbaV0gPT09ICcvJyAmJiBzb3VyY2VbaSArIDFdID09PSAnPScpIHtc
biAgICAgIHRva2Vucy5wdXNoKHsgdHlwZTogVE9LLk9QLCB2YWx1ZTogJy89JywgbGluZTogdGws
IGNvbDogdGMgfSk7XG4gICAgICBhZHYoKTsgYWR2KCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9
XG4gICAgLy8gc2luZ2xlLWNoYXIgb3BlcmF0b3JzXG4gICAgaWYgKCcrLSovPD49JnxeficuaW5j
bHVkZXMoc291cmNlW2ldKSkge1xuICAgICAgdG9rZW5zLnB1c2goeyB0eXBlOiBUT0suT1AsIHZh
bHVlOiBzb3VyY2VbaV0sIGxpbmU6IHRsLCBjb2w6IHRjIH0pO1xuICAgICAgYWR2KCk7XG4gICAg
ICBjb250aW51ZTtcbiAgICB9XG4gICAgLy8gcHVuY3R1YXRpb25cbiAgICBpZiAoJygpW107LDon
LmluY2x1ZGVzKHNvdXJjZVtpXSkpIHtcbiAgICAgIHRva2Vucy5wdXNoKHsgdHlwZTogVE9LLlBV
TkMsIHZhbHVlOiBzb3VyY2VbaV0sIGxpbmU6IHRsLCBjb2w6IHRjIH0pO1xuICAgICAgYWR2KCk7
XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgLy8gc2tpcCB1bmtub3duXG4gICAgYWR2KCk7
XG4gIH1cbiAgdG9rZW5zLnB1c2goeyB0eXBlOiBUT0suRU9GLCB2YWx1ZTogJycsIGxpbmUsIGNv
bCB9KTtcbiAgcmV0dXJuIHRva2Vucztcbn1cblxuLy8g4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ
4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ
4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ
4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ
4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQXG4vLyAzLiBQQVJTRVJcbi8vIOKVkOKVkOKV
kOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKV
kOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKV
kOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKV
kOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkFxuXG5mdW5jdGlv
biBwYXJzZSh0b2tlbnMpIHtcbiAgbGV0IHBvcyA9IDA7XG4gIGZ1bmN0aW9uIGN1cigpIHsgcmV0
dXJuIHRva2Vuc1twb3NdOyB9XG4gIGZ1bmN0aW9uIGF0KHR5cGUsIHZhbHVlKSB7IGNvbnN0IHQg
PSBjdXIoKTsgcmV0dXJuIHQudHlwZSA9PT0gdHlwZSAmJiAodmFsdWUgPT09IHVuZGVmaW5lZCB8
fCB0LnZhbHVlID09PSB2YWx1ZSk7IH1cbiAgZnVuY3Rpb24gZWF0KHR5cGUsIHZhbHVlKSB7XG4g
ICAgY29uc3QgdCA9IGN1cigpO1xuICAgIGlmICh0LnR5cGUgIT09IHR5cGUgfHwgKHZhbHVlICE9
PSB1bmRlZmluZWQgJiYgdC52YWx1ZSAhPT0gdmFsdWUpKVxuICAgICAgdGhyb3cgbmV3IFN5bnRh
eEVycm9yKGBFeHBlY3RlZCAke3ZhbHVlIHx8IHR5cGV9IGJ1dCBnb3QgXCIke3QudmFsdWV9XCIg
YXQgJHt0LmxpbmV9OiR7dC5jb2x9YCk7XG4gICAgcG9zKys7XG4gICAgcmV0dXJuIHQ7XG4gIH1c
biAgZnVuY3Rpb24gbWF5YmUodHlwZSwgdmFsdWUpIHsgaWYgKGF0KHR5cGUsIHZhbHVlKSkgeyBw
b3MrKzsgcmV0dXJuIHRydWU7IH0gcmV0dXJuIGZhbHNlOyB9XG5cbiAgZnVuY3Rpb24gcGFyc2VQ
cm9ncmFtKCkge1xuICAgIGNvbnN0IGJvZHkgPSBbXTtcbiAgICB3aGlsZSAoIWF0KFRPSy5FT0Yp
KSB7XG4gICAgICBpZiAoYXQoVE9LLktXLCAnY29uc3QnKSAmJiAhaXNMb2NhbENvbnRleHQoKSkg
Ym9keS5wdXNoKHBhcnNlR2xvYmFsQ29uc3QoKSk7XG4gICAgICBlbHNlIGlmIChhdChUT0suS1cs
ICd2YXInKSAmJiAhaXNMb2NhbENvbnRleHQoKSkgYm9keS5wdXNoKHBhcnNlR2xvYmFsVmFyKCkp
O1xuICAgICAgZWxzZSBpZiAoYXQoVE9LLktXLCAnZnVuY3Rpb24nKSkgYm9keS5wdXNoKHBhcnNl
RnVuY3Rpb24oKSk7XG4gICAgICBlbHNlIGlmIChhdChUT0suS1csICdzdWJyb3V0aW5lJykpIGJv
ZHkucHVzaChwYXJzZVN1YnJvdXRpbmUoKSk7XG4gICAgICBlbHNlIGlmIChhdChUT0suS1csICdp
bXBvcnQnKSkgYm9keS5wdXNoKHBhcnNlSW1wb3J0KCkpO1xuICAgICAgZWxzZSBpZiAoYXQoVE9L
LktXLCAnZXhwb3J0JykpIHsgcG9zKys7IGJvZHkucHVzaChwYXJzZUZ1bmN0aW9uKHRydWUpKTsg
fVxuICAgICAgZWxzZSB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFVuZXhwZWN0ZWQgXCIke2N1cigp
LnZhbHVlfVwiIGF0ICR7Y3VyKCkubGluZX06JHtjdXIoKS5jb2x9YCk7XG4gICAgfVxuICAgIHJl
dHVybiB7IHR5cGU6ICdQcm9ncmFtJywgYm9keSB9O1xuICB9XG5cbiAgZnVuY3Rpb24gaXNMb2Nh
bENvbnRleHQoKSB7IHJldHVybiBmYWxzZTsgfSAvLyBnbG9iYWxzIG9ubHkgYXQgdG9wIGxldmVs
XG5cbiAgLy8gUGFyc2UgZnVuY3Rpb24gdHlwZSBzaWduYXR1cmU6IGZ1bmN0aW9uKHg6IGY2NCwg
eTogZjY0KTogZjY0XG4gIGZ1bmN0aW9uIHBhcnNlRnVuY1R5cGVTaWcoKSB7XG4gICAgZWF0KFRP
Sy5LVywgJ2Z1bmN0aW9uJyk7XG4gICAgZWF0KFRPSy5QVU5DLCAnKCcpO1xuICAgIGNvbnN0IHBh
cmFtcyA9IGF0KFRPSy5QVU5DLCAnKScpID8gW10gOiBwYXJzZVBhcmFtRW50cmllcygpO1xuICAg
IGVhdChUT0suUFVOQywgJyknKTtcbiAgICBsZXQgcmV0VHlwZSA9IG51bGw7XG4gICAgaWYgKG1h
eWJlKFRPSy5QVU5DLCAnOicpKSByZXRUeXBlID0gZWF0KFRPSy5LVykudmFsdWU7XG4gICAgcmV0
dXJuIHsgcGFyYW1zLCByZXRUeXBlIH07XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUdsb2JhbENv
bnN0KCkge1xuICAgIGVhdChUT0suS1csICdjb25zdCcpO1xuICAgIGNvbnN0IG5hbWUgPSBlYXQo
VE9LLklEKS52YWx1ZTtcbiAgICBlYXQoVE9LLlBVTkMsICc6Jyk7XG4gICAgY29uc3QgdnR5cGUg
PSBlYXQoVE9LLktXKS52YWx1ZTtcbiAgICBlYXQoVE9LLk9QLCAnPScpO1xuICAgIGNvbnN0IGlu
aXQgPSBwYXJzZUV4cHIoMCk7XG4gICAgcmV0dXJuIHsgdHlwZTogJ0NvbnN0RGVjbCcsIG5hbWUs
IHZ0eXBlLCBpbml0IH07XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUdsb2JhbFZhcigpIHtcbiAg
ICBlYXQoVE9LLktXLCAndmFyJyk7XG4gICAgY29uc3QgbmFtZSA9IGVhdChUT0suSUQpLnZhbHVl
O1xuICAgIGVhdChUT0suUFVOQywgJzonKTtcbiAgICBpZiAoYXQoVE9LLktXLCAnZnVuY3Rpb24n
KSkge1xuICAgICAgY29uc3QgZnVuY1NpZyA9IHBhcnNlRnVuY1R5cGVTaWcoKTtcbiAgICAgIGxl
dCBpbml0ID0gbnVsbDtcbiAgICAgIGlmIChtYXliZShUT0suT1AsICc9JykpIGluaXQgPSBwYXJz
ZUV4cHIoMCk7XG4gICAgICByZXR1cm4geyB0eXBlOiAnVmFyRGVjbCcsIG5hbWUsIHZ0eXBlOiAn
aTMyJywgZnVuY1NpZywgaW5pdCB9O1xuICAgIH1cbiAgICBjb25zdCB2dHlwZSA9IGVhdChUT0su
S1cpLnZhbHVlO1xuICAgIGxldCBpbml0ID0gbnVsbDtcbiAgICBpZiAobWF5YmUoVE9LLk9QLCAn
PScpKSBpbml0ID0gcGFyc2VFeHByKDApO1xuICAgIHJldHVybiB7IHR5cGU6ICdWYXJEZWNsJywg
bmFtZSwgdnR5cGUsIGluaXQgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlSW1wb3J0KCkge1xu
ICAgIGVhdChUT0suS1csICdpbXBvcnQnKTtcbiAgICAvLyBpbXBvcnQgZnVuY3Rpb24gbmFtZShw
YXJhbXMpOiByZXRUeXBlIGZyb20gJ21vZHVsZSdcbiAgICAvLyBpbXBvcnQgbmFtZSA9ICR7aW50
ZXJwfVxuICAgIC8vIGltcG9ydCBuYW1lKHBhcmFtcyk6IHJldFR5cGUgPSAke2ludGVycH1cbiAg
ICBpZiAoYXQoVE9LLktXLCAnZnVuY3Rpb24nKSkge1xuICAgICAgcG9zKys7XG4gICAgfVxuICAg
IGNvbnN0IG5hbWUgPSBlYXQoVE9LLklEKS52YWx1ZTtcbiAgICBsZXQgcGFyYW1zID0gW10sIHJl
dFR5cGUgPSBudWxsLCBtb2R1bGVOYW1lID0gJ2hvc3QnLCBpbnRlcnBJZHggPSBudWxsO1xuICAg
IGlmIChhdChUT0suUFVOQywgJygnKSkge1xuICAgICAgcGFyYW1zID0gcGFyc2VQYXJhbUxpc3Qo
KTtcbiAgICB9XG4gICAgaWYgKG1heWJlKFRPSy5QVU5DLCAnOicpKSB7XG4gICAgICByZXRUeXBl
ID0gZWF0KFRPSy5LVykudmFsdWU7XG4gICAgfVxuICAgIGlmIChtYXliZShUT0suT1AsICc9Jykp
IHtcbiAgICAgIC8vIGludGVycG9sYXRpb24gbWFya2VyXG4gICAgICBjb25zdCB0ID0gZWF0KFRP
Sy5JRCk7XG4gICAgICBpbnRlcnBJZHggPSB0LnZhbHVlO1xuICAgIH0gZWxzZSBpZiAobWF5YmUo
VE9LLktXLCAnZnJvbScpKSB7XG4gICAgICAvLyAnbW9kdWxlJyDigJQgd2UganVzdCByZWFkIHRo
ZSBpZGVudGlmaWVyIGFzIGEgc3RyaW5nLWxpa2UgdGhpbmdcbiAgICAgIG1vZHVsZU5hbWUgPSBl
YXQoVE9LLklEKS52YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHsgdHlwZTogJ0ltcG9ydERlY2wn
LCBuYW1lLCBwYXJhbXMsIHJldFR5cGUsIG1vZHVsZU5hbWUsIGludGVycElkeCB9O1xuICB9XG5c
biAgZnVuY3Rpb24gcGFyc2VGdW5jdGlvbihleHBvcnRlZCA9IGZhbHNlKSB7XG4gICAgZWF0KFRP
Sy5LVywgJ2Z1bmN0aW9uJyk7XG4gICAgY29uc3QgbmFtZSA9IGVhdChUT0suSUQpLnZhbHVlO1xu
ICAgIGVhdChUT0suUFVOQywgJygnKTtcbiAgICBjb25zdCBwYXJhbXMgPSBhdChUT0suUFVOQywg
JyknKSA/IFtdIDogcGFyc2VQYXJhbUVudHJpZXMoKTtcbiAgICBlYXQoVE9LLlBVTkMsICcpJyk7
XG4gICAgZWF0KFRPSy5QVU5DLCAnOicpO1xuICAgIGNvbnN0IHJldFR5cGUgPSBlYXQoVE9LLktX
KS52YWx1ZTtcbiAgICBjb25zdCBsb2NhbHMgPSBbXTtcbiAgICBpZiAoYXQoVE9LLktXLCAndmFy
JykpIHtcbiAgICAgIHBvcysrO1xuICAgICAgd2hpbGUgKCFhdChUT0suS1csICdiZWdpbicpKSB7
XG4gICAgICAgIGNvbnN0IGxuYW1lcyA9IFtlYXQoVE9LLklEKS52YWx1ZV07XG4gICAgICAgIHdo
aWxlIChtYXliZShUT0suUFVOQywgJywnKSkgbG5hbWVzLnB1c2goZWF0KFRPSy5JRCkudmFsdWUp
O1xuICAgICAgICBlYXQoVE9LLlBVTkMsICc6Jyk7XG4gICAgICAgIGlmIChhdChUT0suS1csICdm
dW5jdGlvbicpKSB7XG4gICAgICAgICAgY29uc3QgZnVuY1NpZyA9IHBhcnNlRnVuY1R5cGVTaWco
KTtcbiAgICAgICAgICBmb3IgKGNvbnN0IGxuIG9mIGxuYW1lcykgbG9jYWxzLnB1c2goeyB0eXBl
OiAnTG9jYWwnLCBuYW1lOiBsbiwgdnR5cGU6ICdpMzInLCBmdW5jU2lnIH0pO1xuICAgICAgICB9
IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IGx0ID0gZWF0KFRPSy5LVykudmFsdWU7XG4gICAgICAg
ICAgZm9yIChjb25zdCBsbiBvZiBsbmFtZXMpIGxvY2Fscy5wdXNoKHsgdHlwZTogJ0xvY2FsJywg
bmFtZTogbG4sIHZ0eXBlOiBsdCB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBl
YXQoVE9LLktXLCAnYmVnaW4nKTtcbiAgICBjb25zdCBib2R5ID0gcGFyc2VTdGF0ZW1lbnRzKCdl
bmQnKTtcbiAgICBlYXQoVE9LLktXLCAnZW5kJyk7XG4gICAgcmV0dXJuIHsgdHlwZTogJ0Z1bmN0
aW9uJywgbmFtZSwgcGFyYW1zLCByZXRUeXBlLCBsb2NhbHMsIGJvZHksIGV4cG9ydGVkIH07XG4g
IH1cblxuICBmdW5jdGlvbiBwYXJzZVN1YnJvdXRpbmUoKSB7XG4gICAgZWF0KFRPSy5LVywgJ3N1
YnJvdXRpbmUnKTtcbiAgICBjb25zdCBuYW1lID0gZWF0KFRPSy5JRCkudmFsdWU7XG4gICAgZWF0
KFRPSy5QVU5DLCAnKCcpO1xuICAgIGNvbnN0IHBhcmFtcyA9IGF0KFRPSy5QVU5DLCAnKScpID8g
W10gOiBwYXJzZVBhcmFtRW50cmllcygpO1xuICAgIGVhdChUT0suUFVOQywgJyknKTtcbiAgICBj
b25zdCBsb2NhbHMgPSBbXTtcbiAgICBpZiAoYXQoVE9LLktXLCAndmFyJykpIHtcbiAgICAgIHBv
cysrO1xuICAgICAgd2hpbGUgKCFhdChUT0suS1csICdiZWdpbicpKSB7XG4gICAgICAgIGNvbnN0
IGxuYW1lcyA9IFtlYXQoVE9LLklEKS52YWx1ZV07XG4gICAgICAgIHdoaWxlIChtYXliZShUT0su
UFVOQywgJywnKSkgbG5hbWVzLnB1c2goZWF0KFRPSy5JRCkudmFsdWUpO1xuICAgICAgICBlYXQo
VE9LLlBVTkMsICc6Jyk7XG4gICAgICAgIGlmIChhdChUT0suS1csICdmdW5jdGlvbicpKSB7XG4g
ICAgICAgICAgY29uc3QgZnVuY1NpZyA9IHBhcnNlRnVuY1R5cGVTaWcoKTtcbiAgICAgICAgICBm
b3IgKGNvbnN0IGxuIG9mIGxuYW1lcykgbG9jYWxzLnB1c2goeyB0eXBlOiAnTG9jYWwnLCBuYW1l
OiBsbiwgdnR5cGU6ICdpMzInLCBmdW5jU2lnIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAg
ICAgIGNvbnN0IGx0ID0gZWF0KFRPSy5LVykudmFsdWU7XG4gICAgICAgICAgZm9yIChjb25zdCBs
biBvZiBsbmFtZXMpIGxvY2Fscy5wdXNoKHsgdHlwZTogJ0xvY2FsJywgbmFtZTogbG4sIHZ0eXBl
OiBsdCB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBlYXQoVE9LLktXLCAnYmVn
aW4nKTtcbiAgICBjb25zdCBib2R5ID0gcGFyc2VTdGF0ZW1lbnRzKCdlbmQnKTtcbiAgICBlYXQo
VE9LLktXLCAnZW5kJyk7XG4gICAgcmV0dXJuIHsgdHlwZTogJ1N1YnJvdXRpbmUnLCBuYW1lLCBw
YXJhbXMsIGxvY2FscywgYm9keSB9O1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VQYXJhbUVudHJp
ZXMoKSB7XG4gICAgY29uc3QgcGFyYW1zID0gW107XG4gICAgd2hpbGUgKGN1cigpLnR5cGUgPT09
IFRPSy5JRCkge1xuICAgICAgLy8gQ29sbGVjdCBjb21tYS1zZXBhcmF0ZWQgbmFtZXMgdGhhdCBz
aGFyZSBhIHR5cGVcbiAgICAgIGNvbnN0IG5hbWVzID0gW2VhdChUT0suSUQpLnZhbHVlXTtcbiAg
ICAgIHdoaWxlIChhdChUT0suUFVOQywgJywnKSAmJiB0b2tlbnNbcG9zICsgMV0gJiYgdG9rZW5z
W3BvcyArIDFdLnR5cGUgPT09IFRPSy5JRCAmJlxuICAgICAgICAgICAgIHRva2Vuc1twb3MgKyAy
XSAmJiAodG9rZW5zW3BvcyArIDJdLnZhbHVlID09PSAnLCcgfHwgdG9rZW5zW3BvcyArIDJdLnZh
bHVlID09PSAnOicpKSB7XG4gICAgICAgIHBvcysrOyAvLyBza2lwICxcbiAgICAgICAgbmFtZXMu
cHVzaChlYXQoVE9LLklEKS52YWx1ZSk7XG4gICAgICB9XG4gICAgICBlYXQoVE9LLlBVTkMsICc6
Jyk7XG4gICAgICAvLyBmdW5jdGlvbiB0eXBlOiBjYWxsYmFjazogZnVuY3Rpb24oeDogZjY0KTog
ZjY0XG4gICAgICBpZiAoYXQoVE9LLktXLCAnZnVuY3Rpb24nKSkge1xuICAgICAgICBjb25zdCBm
dW5jU2lnID0gcGFyc2VGdW5jVHlwZVNpZygpO1xuICAgICAgICBmb3IgKGNvbnN0IG4gb2YgbmFt
ZXMpIHBhcmFtcy5wdXNoKHsgdHlwZTogJ1BhcmFtJywgbmFtZTogbiwgdnR5cGU6ICdpMzInLCBp
c0FycmF5OiBmYWxzZSwgYXJyYXlEaW1zOiBudWxsLCBmdW5jU2lnIH0pO1xuICAgICAgICBtYXli
ZShUT0suUFVOQywgJywnKTsgLy8gY29uc3VtZSBjb21tYSBiZXR3ZWVuIHBhcmFtIGdyb3Vwc1xu
ICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGxldCBpc0FycmF5ID0gZmFsc2UsIGFy
cmF5RGltcyA9IG51bGw7XG4gICAgICBpZiAoYXQoVE9LLktXLCAnYXJyYXknKSkge1xuICAgICAg
ICBwb3MrKztcbiAgICAgICAgaXNBcnJheSA9IHRydWU7XG4gICAgICAgIGlmIChhdChUT0suUFVO
QywgJygnKSkge1xuICAgICAgICAgIHBvcysrO1xuICAgICAgICAgIGFycmF5RGltcyA9IFtdO1xu
ICAgICAgICAgIGFycmF5RGltcy5wdXNoKHBhcnNlRXhwcigwKSk7XG4gICAgICAgICAgd2hpbGUg
KG1heWJlKFRPSy5QVU5DLCAnLCcpKSBhcnJheURpbXMucHVzaChwYXJzZUV4cHIoMCkpO1xuICAg
ICAgICAgIGVhdChUT0suUFVOQywgJyknKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29u
c3QgdnR5cGUgPSBlYXQoVE9LLktXKS52YWx1ZTtcbiAgICAgIGZvciAoY29uc3QgbiBvZiBuYW1l
cykgcGFyYW1zLnB1c2goeyB0eXBlOiAnUGFyYW0nLCBuYW1lOiBuLCB2dHlwZSwgaXNBcnJheSwg
YXJyYXlEaW1zIH0pO1xuICAgICAgbWF5YmUoVE9LLlBVTkMsICcsJyk7IC8vIGNvbnN1bWUgY29t
bWEgYmV0d2VlbiBwYXJhbSBncm91cHNcbiAgICB9XG4gICAgcmV0dXJuIHBhcmFtcztcbiAgfVxu
XG4gIGZ1bmN0aW9uIHBhcnNlUGFyYW1MaXN0KCkge1xuICAgIC8vIHNpbXBsaWZpZWQgcGFyYW0g
bGlzdCBmb3IgaW1wb3J0czogbmFtZTogdHlwZSwgLi4uXG4gICAgZWF0KFRPSy5QVU5DLCAnKCcp
O1xuICAgIGNvbnN0IHBhcmFtcyA9IFtdO1xuICAgIHdoaWxlIChjdXIoKS50eXBlID09PSBUT0su
SUQpIHtcbiAgICAgIGNvbnN0IG5hbWVzID0gW2VhdChUT0suSUQpLnZhbHVlXTtcbiAgICAgIHdo
aWxlIChhdChUT0suUFVOQywgJywnKSAmJiB0b2tlbnNbcG9zICsgMV0gJiYgdG9rZW5zW3BvcyAr
IDFdLnR5cGUgPT09IFRPSy5JRCAmJlxuICAgICAgICAgICAgIHRva2Vuc1twb3MgKyAyXSAmJiAo
dG9rZW5zW3BvcyArIDJdLnZhbHVlID09PSAnLCcgfHwgdG9rZW5zW3BvcyArIDJdLnZhbHVlID09
PSAnOicpKSB7XG4gICAgICAgIHBvcysrO1xuICAgICAgICBuYW1lcy5wdXNoKGVhdChUT0suSUQp
LnZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGVhdChUT0suUFVOQywgJzonKTtcbiAgICAgIGNvbnN0
IHZ0eXBlID0gZWF0KFRPSy5LVykudmFsdWU7XG4gICAgICBmb3IgKGNvbnN0IG4gb2YgbmFtZXMp
IHBhcmFtcy5wdXNoKHsgdHlwZTogJ1BhcmFtJywgbmFtZTogbiwgdnR5cGUsIGlzQXJyYXk6IGZh
bHNlLCBhcnJheURpbXM6IG51bGwgfSk7XG4gICAgICBtYXliZShUT0suUFVOQywgJywnKTsgLy8g
Y29uc3VtZSBjb21tYSBiZXR3ZWVuIHBhcmFtIGdyb3Vwc1xuICAgIH1cbiAgICBlYXQoVE9LLlBV
TkMsICcpJyk7XG4gICAgcmV0dXJuIHBhcmFtcztcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlU3Rh
dGVtZW50cyhlbmRLdykge1xuICAgIGNvbnN0IHN0bXRzID0gW107XG4gICAgd2hpbGUgKCFhdChU
T0suS1csIGVuZEt3KSAmJiAhYXQoVE9LLkVPRikpIHtcbiAgICAgIC8vIGFsc28gc3RvcCBhdCAn
ZWxzZScgZm9yIGlmIGJsb2Nrc1xuICAgICAgaWYgKGVuZEt3ID09PSAnZW5kJyAmJiAoYXQoVE9L
LktXLCAnZWxzZScpKSkgYnJlYWs7XG4gICAgICBzdG10cy5wdXNoKHBhcnNlU3RhdGVtZW50KCkp
O1xuICAgIH1cbiAgICByZXR1cm4gc3RtdHM7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVN0YXRl
bWVudCgpIHtcbiAgICBpZiAoYXQoVE9LLktXLCAnaWYnKSkgcmV0dXJuIHBhcnNlSWYoKTtcbiAg
ICBpZiAoYXQoVE9LLktXLCAnZm9yJykpIHJldHVybiBwYXJzZUZvcigpO1xuICAgIGlmIChhdChU
T0suS1csICd3aGlsZScpKSByZXR1cm4gcGFyc2VXaGlsZSgpO1xuICAgIGlmIChhdChUT0suS1cs
ICdkbycpKSByZXR1cm4gcGFyc2VEb1doaWxlKCk7XG4gICAgaWYgKGF0KFRPSy5LVywgJ2JyZWFr
JykpIHsgcG9zKys7IHJldHVybiB7IHR5cGU6ICdCcmVhaycgfTsgfVxuICAgIGlmIChhdChUT0su
S1csICdjYWxsJykpIHsgcG9zKys7IGNvbnN0IG5hbWUgPSBlYXQoVE9LLklEKS52YWx1ZTsgZWF0
KFRPSy5QVU5DLCAnKCcpOyBjb25zdCBhcmdzID0gcGFyc2VBcmdzKCk7IGVhdChUT0suUFVOQywg
JyknKTsgcmV0dXJuIHsgdHlwZTogJ0NhbGwnLCBuYW1lLCBhcmdzIH07IH1cblxuICAgIC8vIGFz
c2lnbm1lbnQgb3IgZXhwcmVzc2lvbiBzdGF0ZW1lbnRcbiAgICAvLyBsb29rIGFoZWFkOiBpZCA6
PSAvIGlkWy4uLl0gOj0gLyBpZCArPSBldGMuXG4gICAgaWYgKGN1cigpLnR5cGUgPT09IFRPSy5J
RCkge1xuICAgICAgY29uc3QgbmFtZSA9IGN1cigpLnZhbHVlO1xuICAgICAgLy8gY2hlY2sgZm9y
IGFycmF5IHN0b3JlOiBpZFtcbiAgICAgIGlmICh0b2tlbnNbcG9zICsgMV0gJiYgdG9rZW5zW3Bv
cyArIDFdLnZhbHVlID09PSAnWycpIHtcbiAgICAgICAgcG9zKys7XG4gICAgICAgIGVhdChUT0su
UFVOQywgJ1snKTtcbiAgICAgICAgY29uc3QgaW5kaWNlcyA9IFtwYXJzZUV4cHIoMCldO1xuICAg
ICAgICB3aGlsZSAobWF5YmUoVE9LLlBVTkMsICcsJykpIGluZGljZXMucHVzaChwYXJzZUV4cHIo
MCkpO1xuICAgICAgICBlYXQoVE9LLlBVTkMsICddJyk7XG4gICAgICAgIGlmIChhdChUT0suT1As
ICc6PScpKSB7XG4gICAgICAgICAgcG9zKys7XG4gICAgICAgICAgY29uc3QgdmFsdWUgPSBwYXJz
ZUV4cHIoMCk7XG4gICAgICAgICAgcmV0dXJuIHsgdHlwZTogJ0FycmF5U3RvcmUnLCBuYW1lLCBp
bmRpY2VzLCB2YWx1ZSB9O1xuICAgICAgICB9XG4gICAgICAgIC8vIGNvbXBvdW5kIGFzc2lnbm1l
bnQgb24gYXJyYXlcbiAgICAgICAgY29uc3QgY29wID0gY3VyKCkudmFsdWU7XG4gICAgICAgIGlm
IChjb3AgPT09ICcrPScgfHwgY29wID09PSAnLT0nIHx8IGNvcCA9PT0gJyo9JyB8fCBjb3AgPT09
ICcvPScpIHtcbiAgICAgICAgICAvLyBOb3RlOiAvPSBpcyBhbWJpZ3VvdXMg4oCUIGFzIGEgc3Rh
dGVtZW50IHN0YXJ0IGFmdGVyIGFycmF5IGFjY2VzcywgaXQncyBjb21wb3VuZCBhc3NpZ25cbiAg
ICAgICAgICBwb3MrKztcbiAgICAgICAgICBjb25zdCByaHMgPSBwYXJzZUV4cHIoMCk7XG4gICAg
ICAgICAgY29uc3Qgb3AgPSBjb3BbMF07IC8vICssIC0sICosIC9cbiAgICAgICAgICByZXR1cm4g
eyB0eXBlOiAnQXJyYXlTdG9yZScsIG5hbWUsIGluZGljZXMsIHZhbHVlOiB7XG4gICAgICAgICAg
ICB0eXBlOiAnQmluT3AnLCBvcCwgbGVmdDogeyB0eXBlOiAnQXJyYXlBY2Nlc3MnLCBuYW1lLCBp
bmRpY2VzIH0sIHJpZ2h0OiByaHNcbiAgICAgICAgICB9fTtcbiAgICAgICAgfVxuICAgICAgICB0
aHJvdyBuZXcgU3ludGF4RXJyb3IoYEV4cGVjdGVkIDo9IG9yIGNvbXBvdW5kIGFzc2lnbm1lbnQg
YWZ0ZXIgYXJyYXkgYWNjZXNzIGF0ICR7Y3VyKCkubGluZX06JHtjdXIoKS5jb2x9YCk7XG4gICAg
ICB9XG4gICAgICBpZiAodG9rZW5zW3BvcyArIDFdICYmIHRva2Vuc1twb3MgKyAxXS52YWx1ZSA9
PT0gJzo9Jykge1xuICAgICAgICBwb3MrKzsgcG9zKys7XG4gICAgICAgIGNvbnN0IHZhbHVlID0g
cGFyc2VFeHByKDApO1xuICAgICAgICByZXR1cm4geyB0eXBlOiAnQXNzaWduJywgbmFtZSwgdmFs
dWUgfTtcbiAgICAgIH1cbiAgICAgIC8vIGNvbXBvdW5kIGFzc2lnbm1lbnQ6ICs9LCAtPSwgKj1c
biAgICAgIGlmICh0b2tlbnNbcG9zICsgMV0gJiYgKHRva2Vuc1twb3MgKyAxXS52YWx1ZSA9PT0g
Jys9JyB8fCB0b2tlbnNbcG9zICsgMV0udmFsdWUgPT09ICctPScgfHwgdG9rZW5zW3BvcyArIDFd
LnZhbHVlID09PSAnKj0nKSkge1xuICAgICAgICBjb25zdCBjb3AgPSB0b2tlbnNbcG9zICsgMV0u
dmFsdWU7XG4gICAgICAgIGNvbnN0IG9wID0gY29wWzBdO1xuICAgICAgICBwb3MrKzsgcG9zKys7
XG4gICAgICAgIGNvbnN0IHJocyA9IHBhcnNlRXhwcigwKTtcbiAgICAgICAgcmV0dXJuIHsgdHlw
ZTogJ0Fzc2lnbicsIG5hbWUsIHZhbHVlOiB7IHR5cGU6ICdCaW5PcCcsIG9wLCBsZWZ0OiB7IHR5
cGU6ICdJZGVudCcsIG5hbWUgfSwgcmlnaHQ6IHJocyB9IH07XG4gICAgICB9XG4gICAgICAvLyAv
PSBjb21wb3VuZCBhc3NpZ25tZW50IChvbmx5IHdoZW4gbm90IGluIGV4cHJlc3Npb24gY29udGV4
dCDigJQgc3RhdGVtZW50IGxldmVsKVxuICAgICAgLy8gRGlzYW1iaWd1YXRpb246IGF0IHN0YXRl
bWVudCBsZXZlbCwgaWQgLz0gZXhwciBpcyBjb21wb3VuZCBkaXZpZGUtYXNzaWduXG4gICAgICAv
LyBCdXQgLz0gaXMgYWxzbyBub3QtZXF1YWwgb3BlcmF0b3IuIEF0IHN0YXRlbWVudCBsZXZlbDog
aWQgLz0gZXhwciDihpIgZGl2aWRlLWFzc2lnbi5cbiAgICAgIGlmICh0b2tlbnNbcG9zICsgMV0g
JiYgdG9rZW5zW3BvcyArIDFdLnZhbHVlID09PSAnLz0nKSB7XG4gICAgICAgIC8vIGxvb2sgZnVy
dGhlcjogaWYgdGhpcyBpcyBhIHN0YW5kYWxvbmUgc3RhdGVtZW50IChpZCAvPSBleHByKSwgdHJl
YXQgYXMgY29tcG91bmQgYXNzaWduXG4gICAgICAgIGNvbnN0IG9wID0gJy8nO1xuICAgICAgICBw
b3MrKzsgcG9zKys7XG4gICAgICAgIGNvbnN0IHJocyA9IHBhcnNlRXhwcigwKTtcbiAgICAgICAg
cmV0dXJuIHsgdHlwZTogJ0Fzc2lnbicsIG5hbWUsIHZhbHVlOiB7IHR5cGU6ICdCaW5PcCcsIG9w
LCBsZWZ0OiB7IHR5cGU6ICdJZGVudCcsIG5hbWUgfSwgcmlnaHQ6IHJocyB9IH07XG4gICAgICB9
XG4gICAgfVxuXG4gICAgLy8gZXhwcmVzc2lvbiBzdGF0ZW1lbnQgKGUuZy4sIGJhcmUgZnVuY3Rp
b24gY2FsbClcbiAgICBjb25zdCBleHByID0gcGFyc2VFeHByKDApO1xuICAgIGlmIChleHByLnR5
cGUgPT09ICdGdW5jQ2FsbCcpIHJldHVybiB7IHR5cGU6ICdDYWxsJywgbmFtZTogZXhwci5uYW1l
LCBhcmdzOiBleHByLmFyZ3MgfTtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFVuZXhwZWN0
ZWQgZXhwcmVzc2lvbiBzdGF0ZW1lbnQgYXQgJHtjdXIoKS5saW5lfToke2N1cigpLmNvbH1gKTtc
biAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlSWYoaXNFbHNlSWYpIHtcbiAgICBlYXQoVE9LLktXLCAn
aWYnKTtcbiAgICBlYXQoVE9LLlBVTkMsICcoJyk7XG4gICAgY29uc3QgY29uZCA9IHBhcnNlRXhw
cigwKTtcbiAgICBlYXQoVE9LLlBVTkMsICcpJyk7XG4gICAgZWF0KFRPSy5LVywgJ3RoZW4nKTtc
biAgICBjb25zdCBib2R5ID0gW107XG4gICAgd2hpbGUgKCFhdChUT0suS1csICdlbHNlJykgJiYg
IWF0KFRPSy5LVywgJ2VuZCcpICYmICFhdChUT0suRU9GKSkge1xuICAgICAgYm9keS5wdXNoKHBh
cnNlU3RhdGVtZW50KCkpO1xuICAgIH1cbiAgICBsZXQgZWxzZUJvZHkgPSBudWxsO1xuICAgIGlm
IChtYXliZShUT0suS1csICdlbHNlJykpIHtcbiAgICAgIGlmIChhdChUT0suS1csICdpZicpKSB7
XG4gICAgICAgIC8vIGVsc2UgaWYgY2hhaW46IGlubmVyIHBhcnNlSWYgaGFuZGxlcyBldmVyeXRo
aW5nIGluY2x1ZGluZyBlbmQgaWZcbiAgICAgICAgZWxzZUJvZHkgPSBbcGFyc2VJZih0cnVlKV07
XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbHNlQm9keSA9IFtdO1xuICAgICAgICB3aGlsZSAo
IWF0KFRPSy5LVywgJ2VuZCcpICYmICFhdChUT0suRU9GKSkge1xuICAgICAgICAgIGVsc2VCb2R5
LnB1c2gocGFyc2VTdGF0ZW1lbnQoKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAg
Ly8gT25seSBjb25zdW1lICdlbmQgaWYnIGF0IHRoZSBvdXRlcm1vc3QgaWYgKG5vdCBpbiBlbHNl
LWlmIGNoYWluKVxuICAgIGlmICghaXNFbHNlSWYgJiYgYXQoVE9LLktXLCAnZW5kJykpIHtcbiAg
ICAgIHBvcysrO1xuICAgICAgbWF5YmUoVE9LLktXLCAnaWYnKTtcbiAgICB9XG4gICAgcmV0dXJu
IHsgdHlwZTogJ0lmJywgY29uZCwgYm9keSwgZWxzZUJvZHkgfTtcbiAgfVxuXG4gIGZ1bmN0aW9u
IHBhcnNlRm9yKCkge1xuICAgIGVhdChUT0suS1csICdmb3InKTtcbiAgICBjb25zdCB2YXJOYW1l
ID0gZWF0KFRPSy5JRCkudmFsdWU7XG4gICAgZWF0KFRPSy5PUCwgJzo9Jyk7XG4gICAgY29uc3Qg
c3RhcnQgPSBwYXJzZUV4cHIoMCk7XG4gICAgZWF0KFRPSy5QVU5DLCAnLCcpO1xuICAgIGNvbnN0
IGVuZCA9IHBhcnNlRXhwcigwKTtcbiAgICBsZXQgc3RlcCA9IG51bGw7XG4gICAgaWYgKG1heWJl
KFRPSy5QVU5DLCAnLCcpKSBzdGVwID0gcGFyc2VFeHByKDApO1xuICAgIGNvbnN0IGJvZHkgPSBb
XTtcbiAgICB3aGlsZSAoIWF0KFRPSy5LVywgJ2VuZCcpICYmICFhdChUT0suRU9GKSkgYm9keS5w
dXNoKHBhcnNlU3RhdGVtZW50KCkpO1xuICAgIGVhdChUT0suS1csICdlbmQnKTtcbiAgICBlYXQo
VE9LLktXLCAnZm9yJyk7XG4gICAgcmV0dXJuIHsgdHlwZTogJ0ZvcicsIHZhck5hbWUsIHN0YXJ0
LCBlbmQsIHN0ZXAsIGJvZHkgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlV2hpbGUoKSB7XG4g
ICAgZWF0KFRPSy5LVywgJ3doaWxlJyk7XG4gICAgZWF0KFRPSy5QVU5DLCAnKCcpO1xuICAgIGNv
bnN0IGNvbmQgPSBwYXJzZUV4cHIoMCk7XG4gICAgZWF0KFRPSy5QVU5DLCAnKScpO1xuICAgIGNv
bnN0IGJvZHkgPSBbXTtcbiAgICB3aGlsZSAoIWF0KFRPSy5LVywgJ2VuZCcpICYmICFhdChUT0su
RU9GKSkgYm9keS5wdXNoKHBhcnNlU3RhdGVtZW50KCkpO1xuICAgIGVhdChUT0suS1csICdlbmQn
KTtcbiAgICBlYXQoVE9LLktXLCAnd2hpbGUnKTtcbiAgICByZXR1cm4geyB0eXBlOiAnV2hpbGUn
LCBjb25kLCBib2R5IH07XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZURvV2hpbGUoKSB7XG4gICAg
ZWF0KFRPSy5LVywgJ2RvJyk7XG4gICAgY29uc3QgYm9keSA9IFtdO1xuICAgIHdoaWxlICghYXQo
VE9LLktXLCAnd2hpbGUnKSAmJiAhYXQoVE9LLkVPRikpIGJvZHkucHVzaChwYXJzZVN0YXRlbWVu
dCgpKTtcbiAgICBlYXQoVE9LLktXLCAnd2hpbGUnKTtcbiAgICBlYXQoVE9LLlBVTkMsICcoJyk7
XG4gICAgY29uc3QgY29uZCA9IHBhcnNlRXhwcigwKTtcbiAgICBlYXQoVE9LLlBVTkMsICcpJyk7
XG4gICAgcmV0dXJuIHsgdHlwZTogJ0RvV2hpbGUnLCBjb25kLCBib2R5IH07XG4gIH1cblxuICBm
dW5jdGlvbiBwYXJzZUFyZ3MoKSB7XG4gICAgY29uc3QgYXJncyA9IFtdO1xuICAgIGlmICghYXQo
VE9LLlBVTkMsICcpJykpIHtcbiAgICAgIGFyZ3MucHVzaChwYXJzZUV4cHIoMCkpO1xuICAgICAg
d2hpbGUgKG1heWJlKFRPSy5QVU5DLCAnLCcpKSBhcmdzLnB1c2gocGFyc2VFeHByKDApKTtcbiAg
ICB9XG4gICAgcmV0dXJuIGFyZ3M7XG4gIH1cblxuICAvLyDilIDilIAgUHJhdHQgZXhwcmVzc2lv
biBwYXJzZXIg4pSA4pSAXG5cbiAgLy8gQmluZGluZyBwb3dlcnMgKGhpZ2hlciA9IHRpZ2h0ZXIp
XG4gIGZ1bmN0aW9uIGxicCh0b2spIHtcbiAgICBpZiAodG9rLnR5cGUgPT09IFRPSy5LVykge1xu
ICAgICAgaWYgKHRvay52YWx1ZSA9PT0gJ29yJykgcmV0dXJuIDI7XG4gICAgICBpZiAodG9rLnZh
bHVlID09PSAnYW5kJykgcmV0dXJuIDQ7XG4gICAgICBpZiAodG9rLnZhbHVlID09PSAnbW9kJykg
cmV0dXJuIDE4O1xuICAgIH1cbiAgICBpZiAodG9rLnR5cGUgPT09IFRPSy5PUCkge1xuICAgICAg
Y29uc3QgdiA9IHRvay52YWx1ZTtcbiAgICAgIGlmICh2ID09PSAnPT0nIHx8IHYgPT09ICcvPScg
fHwgdiA9PT0gJzwnIHx8IHYgPT09ICc+JyB8fCB2ID09PSAnPD0nIHx8IHYgPT09ICc+PScpIHJl
dHVybiA2O1xuICAgICAgaWYgKHYgPT09ICd8JykgcmV0dXJuIDg7XG4gICAgICBpZiAodiA9PT0g
J14nKSByZXR1cm4gMTA7XG4gICAgICBpZiAodiA9PT0gJyYnKSByZXR1cm4gMTI7XG4gICAgICBp
ZiAodiA9PT0gJzw8JyB8fCB2ID09PSAnPj4nKSByZXR1cm4gMTQ7XG4gICAgICBpZiAodiA9PT0g
JysnIHx8IHYgPT09ICctJykgcmV0dXJuIDE2O1xuICAgICAgaWYgKHYgPT09ICcqJyB8fCB2ID09
PSAnLycpIHJldHVybiAxODtcbiAgICAgIGlmICh2ID09PSAnKionKSByZXR1cm4gMjI7IC8vIHJp
Z2h0LWFzc29jIGhhbmRsZWQgYnkgdXNpbmcgcmJwID0gMjIgLSAxXG4gICAgfVxuICAgIHJldHVy
biAwO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VFeHByKG1pbkJwKSB7XG4gICAgbGV0IGxlZnQg
PSBwYXJzZVByZWZpeCgpO1xuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGNvbnN0IHQgPSBj
dXIoKTtcbiAgICAgIGNvbnN0IGJwID0gbGJwKHQpO1xuICAgICAgaWYgKGJwID09PSAwIHx8IGJw
IDwgbWluQnApIGJyZWFrO1xuXG4gICAgICAvLyBpZi1leHByZXNzaW9uICh0ZXJuYXJ5KTogaWYg
KGNvbmQpIHRoZW4gYSBlbHNlIGJcbiAgICAgIC8vIE5vdCBoYW5kbGVkIGhlcmUg4oCUIGl0J3Mg
YSBwcmVmaXggZm9ybVxuICAgICAgaWYgKHQudHlwZSA9PT0gVE9LLktXICYmIHQudmFsdWUgPT09
ICdvcicpIHsgcG9zKys7IGxlZnQgPSB7IHR5cGU6ICdCaW5PcCcsIG9wOiAnb3InLCBsZWZ0LCBy
aWdodDogcGFyc2VFeHByKGJwICsgMSkgfTsgY29udGludWU7IH1cbiAgICAgIGlmICh0LnR5cGUg
PT09IFRPSy5LVyAmJiB0LnZhbHVlID09PSAnYW5kJykgeyBwb3MrKzsgbGVmdCA9IHsgdHlwZTog
J0Jpbk9wJywgb3A6ICdhbmQnLCBsZWZ0LCByaWdodDogcGFyc2VFeHByKGJwICsgMSkgfTsgY29u
dGludWU7IH1cbiAgICAgIGlmICh0LnR5cGUgPT09IFRPSy5LVyAmJiB0LnZhbHVlID09PSAnbW9k
JykgeyBwb3MrKzsgbGVmdCA9IHsgdHlwZTogJ0Jpbk9wJywgb3A6ICdtb2QnLCBsZWZ0LCByaWdo
dDogcGFyc2VFeHByKGJwICsgMSkgfTsgY29udGludWU7IH1cblxuICAgICAgaWYgKHQudHlwZSA9
PT0gVE9LLk9QKSB7XG4gICAgICAgIGlmICh0LnZhbHVlID09PSAnKionKSB7XG4gICAgICAgICAg
cG9zKys7XG4gICAgICAgICAgLy8gcmlnaHQtYXNzb2NpYXRpdmU6IHVzZSBicCBpbnN0ZWFkIG9m
IGJwKzFcbiAgICAgICAgICBsZWZ0ID0geyB0eXBlOiAnQmluT3AnLCBvcDogJyoqJywgbGVmdCwg
cmlnaHQ6IHBhcnNlRXhwcihicCkgfTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxu
ICAgICAgICBwb3MrKztcbiAgICAgICAgbGVmdCA9IHsgdHlwZTogJ0Jpbk9wJywgb3A6IHQudmFs
dWUsIGxlZnQsIHJpZ2h0OiBwYXJzZUV4cHIoYnAgKyAxKSB9O1xuICAgICAgICBjb250aW51ZTtc
biAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gbGVmdDtcbiAgfVxuXG4g
IGZ1bmN0aW9uIHBhcnNlUHJlZml4KCkge1xuICAgIGNvbnN0IHQgPSBjdXIoKTtcblxuICAgIC8v
IHBhcmVudGhlc2l6ZWQgZXhwcmVzc2lvblxuICAgIGlmICh0LnR5cGUgPT09IFRPSy5QVU5DICYm
IHQudmFsdWUgPT09ICcoJykge1xuICAgICAgcG9zKys7XG4gICAgICBjb25zdCBleHByID0gcGFy
c2VFeHByKDApO1xuICAgICAgZWF0KFRPSy5QVU5DLCAnKScpO1xuICAgICAgcmV0dXJuIGV4cHI7
XG4gICAgfVxuXG4gICAgLy8gaWYtZXhwcmVzc2lvbiAodGVybmFyeSk6IGlmIChjb25kKSB0aGVu
IGEgZWxzZSBiXG4gICAgaWYgKHQudHlwZSA9PT0gVE9LLktXICYmIHQudmFsdWUgPT09ICdpZicp
IHtcbiAgICAgIHBvcysrO1xuICAgICAgZWF0KFRPSy5QVU5DLCAnKCcpO1xuICAgICAgY29uc3Qg
Y29uZCA9IHBhcnNlRXhwcigwKTtcbiAgICAgIGVhdChUT0suUFVOQywgJyknKTtcbiAgICAgIGVh
dChUT0suS1csICd0aGVuJyk7XG4gICAgICBjb25zdCB0aGVuRXhwciA9IHBhcnNlRXhwcigwKTtc
biAgICAgIGVhdChUT0suS1csICdlbHNlJyk7XG4gICAgICBjb25zdCBlbHNlRXhwciA9IHBhcnNl
RXhwcigwKTtcbiAgICAgIHJldHVybiB7IHR5cGU6ICdJZkV4cHInLCBjb25kLCB0aGVuRXhwciwg
ZWxzZUV4cHIgfTtcbiAgICB9XG5cbiAgICAvLyB1bmFyeSBtaW51c1xuICAgIGlmICh0LnR5cGUg
PT09IFRPSy5PUCAmJiB0LnZhbHVlID09PSAnLScpIHtcbiAgICAgIHBvcysrO1xuICAgICAgcmV0
dXJuIHsgdHlwZTogJ1VuYXJ5T3AnLCBvcDogJy0nLCBvcGVyYW5kOiBwYXJzZUV4cHIoMjEpIH07
XG4gICAgfVxuICAgIC8vIG5vdFxuICAgIGlmICh0LnR5cGUgPT09IFRPSy5LVyAmJiB0LnZhbHVl
ID09PSAnbm90Jykge1xuICAgICAgcG9zKys7XG4gICAgICByZXR1cm4geyB0eXBlOiAnVW5hcnlP
cCcsIG9wOiAnbm90Jywgb3BlcmFuZDogcGFyc2VFeHByKDIxKSB9O1xuICAgIH1cbiAgICAvLyBi
aXR3aXNlIG5vdFxuICAgIGlmICh0LnR5cGUgPT09IFRPSy5PUCAmJiB0LnZhbHVlID09PSAnficp
IHtcbiAgICAgIHBvcysrO1xuICAgICAgcmV0dXJuIHsgdHlwZTogJ1VuYXJ5T3AnLCBvcDogJ34n
LCBvcGVyYW5kOiBwYXJzZUV4cHIoMjEpIH07XG4gICAgfVxuICAgIC8vIG51bWJlciBsaXRlcmFs
XG4gICAgaWYgKHQudHlwZSA9PT0gVE9LLk5VTSkge1xuICAgICAgcG9zKys7XG4gICAgICByZXR1
cm4geyB0eXBlOiAnTnVtYmVyTGl0JywgdmFsdWU6IHQudmFsdWUsIGlzRmxvYXQ6IHQuaXNGbG9h
dCwgdHlwZVN1ZmZpeDogdC50eXBlU3VmZml4IH07XG4gICAgfVxuICAgIC8vIHRydWUvZmFsc2Vc
biAgICBpZiAodC50eXBlID09PSBUT0suS1cgJiYgKHQudmFsdWUgPT09ICd0cnVlJyB8fCB0LnZh
bHVlID09PSAnZmFsc2UnKSkge1xuICAgICAgcG9zKys7XG4gICAgICByZXR1cm4geyB0eXBlOiAn
TnVtYmVyTGl0JywgdmFsdWU6IHQudmFsdWUgPT09ICd0cnVlJyA/ICcxJyA6ICcwJywgaXNGbG9h
dDogZmFsc2UsIHR5cGVTdWZmaXg6ICdpMzInIH07XG4gICAgfVxuICAgIC8vIGlkZW50aWZpZXIg
4oCUIG1heSBiZSBmdW5jdGlvbiBjYWxsLCBhcnJheSBhY2Nlc3MsIG9yIHBsYWluIHZhcmlhYmxl
XG4gICAgaWYgKHQudHlwZSA9PT0gVE9LLklEKSB7XG4gICAgICBwb3MrKztcbiAgICAgIGNvbnN0
IG5hbWUgPSB0LnZhbHVlO1xuICAgICAgLy8gZnVuY3Rpb24gY2FsbDogbmFtZSguLi4pXG4gICAg
ICBpZiAoYXQoVE9LLlBVTkMsICcoJykpIHtcbiAgICAgICAgcG9zKys7XG4gICAgICAgIGNvbnN0
IGFyZ3MgPSBwYXJzZUFyZ3MoKTtcbiAgICAgICAgZWF0KFRPSy5QVU5DLCAnKScpO1xuICAgICAg
ICByZXR1cm4geyB0eXBlOiAnRnVuY0NhbGwnLCBuYW1lLCBhcmdzIH07XG4gICAgICB9XG4gICAg
ICAvLyBhcnJheSBhY2Nlc3M6IG5hbWVbLi4uXVxuICAgICAgaWYgKGF0KFRPSy5QVU5DLCAnWycp
KSB7XG4gICAgICAgIHBvcysrO1xuICAgICAgICBjb25zdCBpbmRpY2VzID0gW3BhcnNlRXhwcigw
KV07XG4gICAgICAgIHdoaWxlIChtYXliZShUT0suUFVOQywgJywnKSkgaW5kaWNlcy5wdXNoKHBh
cnNlRXhwcigwKSk7XG4gICAgICAgIGVhdChUT0suUFVOQywgJ10nKTtcbiAgICAgICAgcmV0dXJu
IHsgdHlwZTogJ0FycmF5QWNjZXNzJywgbmFtZSwgaW5kaWNlcyB9O1xuICAgICAgfVxuICAgICAg
cmV0dXJuIHsgdHlwZTogJ0lkZW50JywgbmFtZSB9O1xuICAgIH1cbiAgICAvLyB0eXBlIGNvbnZl
cnNpb24gLyB2ZWN0b3IgY29uc3RydWN0b3I6IGkzMiguLi4pLCBmNjQoLi4uKSwgZjY0eDIoYSwg
YiksIGV0Yy5cbiAgICBpZiAodC50eXBlID09PSBUT0suS1cgJiYgQVRSQV9UWVBFUy5oYXModC52
YWx1ZSkgJiYgdG9rZW5zW3BvcyArIDFdICYmIHRva2Vuc1twb3MgKyAxXS52YWx1ZSA9PT0gJygn
KSB7XG4gICAgICBwb3MrKzsgLy8gc2tpcCB0eXBlIGtleXdvcmRcbiAgICAgIHBvcysrOyAvLyBz
a2lwIChcbiAgICAgIGNvbnN0IGFyZ3MgPSBwYXJzZUFyZ3MoKTtcbiAgICAgIGVhdChUT0suUFVO
QywgJyknKTtcbiAgICAgIHJldHVybiB7IHR5cGU6ICdGdW5jQ2FsbCcsIG5hbWU6IHQudmFsdWUs
IGFyZ3MgfTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIHRv
a2VuIFwiJHt0LnZhbHVlfVwiIGF0ICR7dC5saW5lfToke3QuY29sfWApO1xuICB9XG5cbiAgcmV0
dXJuIHBhcnNlUHJvZ3JhbSgpO1xufVxuXG4vLyDilZDilZDilZDilZDilZDilZDilZDilZDilZDi
lZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDi
lZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDi
lZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDi
lZDilZDilZDilZDilZDilZDilZDilZDilZBcbi8vIDQuIENPREUgR0VORVJBVE9SIOKAlCBlbWl0
cyBXYXNtIGJpbmFyeVxuLy8g4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ
4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ
4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ
4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ
4pWQ4pWQ4pWQ4pWQ4pWQXG5cbi8vIFdhc20gb3Bjb2Rlc1xuY29uc3QgT1BfVU5SRUFDSEFCTEUg
PSAweDAwLCBPUF9OT1AgPSAweDAxLCBPUF9CTE9DSyA9IDB4MDIsIE9QX0xPT1AgPSAweDAzLFxu
ICBPUF9JRiA9IDB4MDQsIE9QX0VMU0UgPSAweDA1LCBPUF9FTkQgPSAweDBiLCBPUF9CUiA9IDB4
MGMsIE9QX0JSX0lGID0gMHgwZCxcbiAgT1BfUkVUVVJOID0gMHgwZiwgT1BfQ0FMTCA9IDB4MTAs
IE9QX0NBTExfSU5ESVJFQ1QgPSAweDExLCBPUF9TRUxFQ1QgPSAweDFiLFxuICBPUF9MT0NBTF9H
RVQgPSAweDIwLCBPUF9MT0NBTF9TRVQgPSAweDIxLCBPUF9MT0NBTF9URUUgPSAweDIyLFxuICBP
UF9HTE9CQUxfR0VUID0gMHgyMywgT1BfR0xPQkFMX1NFVCA9IDB4MjQsXG4gIE9QX0kzMl9MT0FE
ID0gMHgyOCwgT1BfSTY0X0xPQUQgPSAweDI5LCBPUF9GMzJfTE9BRCA9IDB4MmEsIE9QX0Y2NF9M
T0FEID0gMHgyYixcbiAgT1BfSTMyX1NUT1JFID0gMHgzNiwgT1BfSTY0X1NUT1JFID0gMHgzNywg
T1BfRjMyX1NUT1JFID0gMHgzOCwgT1BfRjY0X1NUT1JFID0gMHgzOSxcbiAgT1BfTUVNT1JZX1NJ
WkUgPSAweDNmLCBPUF9NRU1PUllfR1JPVyA9IDB4NDAsXG4gIE9QX0kzMl9DT05TVCA9IDB4NDEs
IE9QX0k2NF9DT05TVCA9IDB4NDIsIE9QX0YzMl9DT05TVCA9IDB4NDMsIE9QX0Y2NF9DT05TVCA9
IDB4NDQsXG4gIE9QX0kzMl9FUVogPSAweDQ1LCBPUF9JMzJfRVEgPSAweDQ2LCBPUF9JMzJfTkUg
PSAweDQ3LFxuICBPUF9JMzJfTFRfUyA9IDB4NDgsIE9QX0kzMl9MVF9VID0gMHg0OSwgT1BfSTMy
X0dUX1MgPSAweDRhLCBPUF9JMzJfR1RfVSA9IDB4NGIsXG4gIE9QX0kzMl9MRV9TID0gMHg0Yywg
T1BfSTMyX0xFX1UgPSAweDRkLCBPUF9JMzJfR0VfUyA9IDB4NGUsIE9QX0kzMl9HRV9VID0gMHg0
ZixcbiAgT1BfSTY0X0VRWiA9IDB4NTAsIE9QX0k2NF9FUSA9IDB4NTEsIE9QX0k2NF9ORSA9IDB4
NTIsXG4gIE9QX0k2NF9MVF9TID0gMHg1MywgT1BfSTY0X0xUX1UgPSAweDU0LCBPUF9JNjRfR1Rf
UyA9IDB4NTUsIE9QX0k2NF9HVF9VID0gMHg1NixcbiAgT1BfSTY0X0xFX1MgPSAweDU3LCBPUF9J
NjRfTEVfVSA9IDB4NTgsIE9QX0k2NF9HRV9TID0gMHg1OSwgT1BfSTY0X0dFX1UgPSAweDVhLFxu
ICBPUF9GMzJfRVEgPSAweDViLCBPUF9GMzJfTkUgPSAweDVjLCBPUF9GMzJfTFQgPSAweDVkLCBP
UF9GMzJfR1QgPSAweDVlLCBPUF9GMzJfTEUgPSAweDVmLCBPUF9GMzJfR0UgPSAweDYwLFxuICBP
UF9GNjRfRVEgPSAweDYxLCBPUF9GNjRfTkUgPSAweDYyLCBPUF9GNjRfTFQgPSAweDYzLCBPUF9G
NjRfR1QgPSAweDY0LCBPUF9GNjRfTEUgPSAweDY1LCBPUF9GNjRfR0UgPSAweDY2LFxuICBPUF9J
MzJfQ0xaID0gMHg2NywgT1BfSTMyX0NUWiA9IDB4NjgsIE9QX0kzMl9QT1BDTlQgPSAweDY5LFxu
ICBPUF9JMzJfQUREID0gMHg2YSwgT1BfSTMyX1NVQiA9IDB4NmIsIE9QX0kzMl9NVUwgPSAweDZj
LFxuICBPUF9JMzJfRElWX1MgPSAweDZkLCBPUF9JMzJfRElWX1UgPSAweDZlLCBPUF9JMzJfUkVN
X1MgPSAweDZmLCBPUF9JMzJfUkVNX1UgPSAweDcwLFxuICBPUF9JMzJfQU5EID0gMHg3MSwgT1Bf
STMyX09SID0gMHg3MiwgT1BfSTMyX1hPUiA9IDB4NzMsXG4gIE9QX0kzMl9TSEwgPSAweDc0LCBP
UF9JMzJfU0hSX1MgPSAweDc1LCBPUF9JMzJfU0hSX1UgPSAweDc2LFxuICBPUF9JMzJfUk9UTCA9
IDB4NzcsIE9QX0kzMl9ST1RSID0gMHg3OCxcbiAgT1BfSTY0X0NMWiA9IDB4NzksIE9QX0k2NF9D
VFogPSAweDdhLCBPUF9JNjRfUE9QQ05UID0gMHg3YixcbiAgT1BfSTY0X0FERCA9IDB4N2MsIE9Q
X0k2NF9TVUIgPSAweDdkLCBPUF9JNjRfTVVMID0gMHg3ZSxcbiAgT1BfSTY0X0RJVl9TID0gMHg3
ZiwgT1BfSTY0X0RJVl9VID0gMHg4MCwgT1BfSTY0X1JFTV9TID0gMHg4MSwgT1BfSTY0X1JFTV9V
ID0gMHg4MixcbiAgT1BfSTY0X0FORCA9IDB4ODMsIE9QX0k2NF9PUiA9IDB4ODQsIE9QX0k2NF9Y
T1IgPSAweDg1LFxuICBPUF9JNjRfU0hMID0gMHg4NiwgT1BfSTY0X1NIUl9TID0gMHg4NywgT1Bf
STY0X1NIUl9VID0gMHg4OCxcbiAgT1BfSTY0X1JPVEwgPSAweDg5LCBPUF9JNjRfUk9UUiA9IDB4
OGEsXG4gIE9QX0YzMl9BQlMgPSAweDhiLCBPUF9GMzJfTkVHID0gMHg4YywgT1BfRjMyX0NFSUwg
PSAweDhkLCBPUF9GMzJfRkxPT1IgPSAweDhlLFxuICBPUF9GMzJfVFJVTkMgPSAweDhmLCBPUF9G
MzJfTkVBUkVTVCA9IDB4OTAsIE9QX0YzMl9TUVJUID0gMHg5MSxcbiAgT1BfRjMyX0FERCA9IDB4
OTIsIE9QX0YzMl9TVUIgPSAweDkzLCBPUF9GMzJfTVVMID0gMHg5NCwgT1BfRjMyX0RJViA9IDB4
OTUsXG4gIE9QX0YzMl9NSU4gPSAweDk2LCBPUF9GMzJfTUFYID0gMHg5NywgT1BfRjMyX0NPUFlT
SUdOID0gMHg5OCxcbiAgT1BfRjY0X0FCUyA9IDB4OTksIE9QX0Y2NF9ORUcgPSAweDlhLCBPUF9G
NjRfQ0VJTCA9IDB4OWIsIE9QX0Y2NF9GTE9PUiA9IDB4OWMsXG4gIE9QX0Y2NF9UUlVOQyA9IDB4
OWQsIE9QX0Y2NF9ORUFSRVNUID0gMHg5ZSwgT1BfRjY0X1NRUlQgPSAweDlmLFxuICBPUF9GNjRf
QUREID0gMHhhMCwgT1BfRjY0X1NVQiA9IDB4YTEsIE9QX0Y2NF9NVUwgPSAweGEyLCBPUF9GNjRf
RElWID0gMHhhMyxcbiAgT1BfRjY0X01JTiA9IDB4YTQsIE9QX0Y2NF9NQVggPSAweGE1LCBPUF9G
NjRfQ09QWVNJR04gPSAweGE2LFxuICBPUF9JMzJfV1JBUF9JNjQgPSAweGE3LFxuICBPUF9JMzJf
VFJVTkNfRjMyX1MgPSAweGE4LCBPUF9JMzJfVFJVTkNfRjY0X1MgPSAweGFhLFxuICBPUF9JNjRf
RVhURU5EX0kzMl9TID0gMHhhYywgT1BfSTY0X0VYVEVORF9JMzJfVSA9IDB4YWQsXG4gIE9QX0k2
NF9UUlVOQ19GMzJfUyA9IDB4YWUsIE9QX0k2NF9UUlVOQ19GNjRfUyA9IDB4YjAsXG4gIE9QX0Yz
Ml9DT05WRVJUX0kzMl9TID0gMHhiMiwgT1BfRjMyX0NPTlZFUlRfSTY0X1MgPSAweGI0LFxuICBP
UF9GMzJfREVNT1RFX0Y2NCA9IDB4YjYsXG4gIE9QX0Y2NF9DT05WRVJUX0kzMl9TID0gMHhiNywg
T1BfRjY0X0NPTlZFUlRfSTY0X1MgPSAweGI5LFxuICBPUF9GNjRfUFJPTU9URV9GMzIgPSAweGJi
LFxuICBPUF9JMzJfUkVJTlRFUlBSRVRfRjMyID0gMHhiYywgT1BfSTY0X1JFSU5URVJQUkVUX0Y2
NCA9IDB4YmQsXG4gIE9QX0YzMl9SRUlOVEVSUFJFVF9JMzIgPSAweGJlLCBPUF9GNjRfUkVJTlRF
UlBSRVRfSTY0ID0gMHhiZixcbiAgT1BfSTMyX0VYVEVORDhfUyA9IDB4YzAsIE9QX0kzMl9FWFRF
TkQxNl9TID0gMHhjMSxcbiAgT1BfSTY0X0VYVEVORDhfUyA9IDB4YzIsIE9QX0k2NF9FWFRFTkQx
Nl9TID0gMHhjMywgT1BfSTY0X0VYVEVORDMyX1MgPSAweGM0O1xuXG4vLyBXYXNtIEZDIHByZWZp
eCBvcGNvZGVzICgweEZDIHByZWZpeClcbmNvbnN0IE9QX0ZDX1BSRUZJWCA9IDB4ZmM7XG5jb25z
dCBPUF9JMzJfVFJVTkNfU0FUX0YzMl9TID0gMCwgT1BfSTMyX1RSVU5DX1NBVF9GMzJfVSA9IDEs
XG4gIE9QX0kzMl9UUlVOQ19TQVRfRjY0X1MgPSAyLCBPUF9JMzJfVFJVTkNfU0FUX0Y2NF9VID0g
MyxcbiAgT1BfSTY0X1RSVU5DX1NBVF9GMzJfUyA9IDQsIE9QX0k2NF9UUlVOQ19TQVRfRjMyX1Ug
PSA1LFxuICBPUF9JNjRfVFJVTkNfU0FUX0Y2NF9TID0gNiwgT1BfSTY0X1RSVU5DX1NBVF9GNjRf
VSA9IDc7XG5cbi8vIFdhc20gdHlwZSBjb2Rlc1xuY29uc3QgV0FTTV9JMzIgPSAweDdmLCBXQVNN
X0k2NCA9IDB4N2UsIFdBU01fRjMyID0gMHg3ZCwgV0FTTV9GNjQgPSAweDdjO1xuY29uc3QgV0FT
TV9WMTI4ID0gMHg3YjtcbmNvbnN0IFdBU01fVk9JRCA9IDB4NDA7XG5cbi8vIFNJTUQgcHJlZml4
XG5jb25zdCBPUF9TSU1EX1BSRUZJWCA9IDB4ZmQ7XG5cbi8vIFNJTUQgb3Bjb2RlIHRhYmxlXG5j
b25zdCBTSU1EX09QUyA9IHtcbiAgLy8gc3BsYXRcbiAgJ2kzMng0LnNwbGF0JzogMHgxMSwgJ2k2
NHgyLnNwbGF0JzogMHgxMiwgJ2YzMng0LnNwbGF0JzogMHgxMywgJ2Y2NHgyLnNwbGF0JzogMHgx
NCxcbiAgLy8gZXh0cmFjdF9sYW5lXG4gICdpMzJ4NC5leHRyYWN0X2xhbmUnOiAweDFiLCAnaTY0
eDIuZXh0cmFjdF9sYW5lJzogMHgxZCwgJ2YzMng0LmV4dHJhY3RfbGFuZSc6IDB4MWYsICdmNjR4
Mi5leHRyYWN0X2xhbmUnOiAweDIxLFxuICAvLyByZXBsYWNlX2xhbmVcbiAgJ2kzMng0LnJlcGxh
Y2VfbGFuZSc6IDB4MWMsICdpNjR4Mi5yZXBsYWNlX2xhbmUnOiAweDFlLCAnZjMyeDQucmVwbGFj
ZV9sYW5lJzogMHgyMCwgJ2Y2NHgyLnJlcGxhY2VfbGFuZSc6IDB4MjIsXG4gIC8vIGFkZFxuICAn
aTMyeDQuYWRkJzogMHhhZSwgJ2k2NHgyLmFkZCc6IDB4Y2UsICdmMzJ4NC5hZGQnOiAweGU0LCAn
ZjY0eDIuYWRkJzogMHhmMCxcbiAgLy8gc3ViXG4gICdpMzJ4NC5zdWInOiAweGIxLCAnaTY0eDIu
c3ViJzogMHhkMSwgJ2YzMng0LnN1Yic6IDB4ZTUsICdmNjR4Mi5zdWInOiAweGYxLFxuICAvLyBt
dWxcbiAgJ2kzMng0Lm11bCc6IDB4YjUsICdpNjR4Mi5tdWwnOiAweGQ1LCAnZjMyeDQubXVsJzog
MHhlNiwgJ2Y2NHgyLm11bCc6IDB4ZjIsXG4gIC8vIGRpdiAoZmxvYXQgb25seSlcbiAgJ2YzMng0
LmRpdic6IDB4ZTcsICdmNjR4Mi5kaXYnOiAweGYzLFxuICAvLyBuZWdcbiAgJ2kzMng0Lm5lZyc6
IDB4YTEsICdpNjR4Mi5uZWcnOiAweGMxLCAnZjMyeDQubmVnJzogMHhlMSwgJ2Y2NHgyLm5lZyc6
IDB4ZWQsXG4gIC8vIGFicyAoZmxvYXQgb25seSlcbiAgJ2YzMng0LmFicyc6IDB4ZTAsICdmNjR4
Mi5hYnMnOiAweGVjLFxuICAvLyBzcXJ0IChmbG9hdCBvbmx5KVxuICAnZjMyeDQuc3FydCc6IDB4
ZTMsICdmNjR4Mi5zcXJ0JzogMHhlZixcbiAgLy8gbWluL21heCAoZmxvYXQgb25seSlcbiAgJ2Yz
Mng0Lm1pbic6IDB4ZTgsICdmNjR4Mi5taW4nOiAweGY0LCAnZjMyeDQubWF4JzogMHhlOSwgJ2Y2
NHgyLm1heCc6IDB4ZjUsXG4gIC8vIGNvbXBhcmlzb24g4oCUIGVxXG4gICdpMzJ4NC5lcSc6IDB4
MzcsICdpNjR4Mi5lcSc6IDB4ZDYsICdmMzJ4NC5lcSc6IDB4NDEsICdmNjR4Mi5lcSc6IDB4NDcs
XG4gIC8vIG5lXG4gICdpMzJ4NC5uZSc6IDB4MzgsICdmMzJ4NC5uZSc6IDB4NDIsICdmNjR4Mi5u
ZSc6IDB4NDgsXG4gIC8vIGx0XG4gICdpMzJ4NC5sdF9zJzogMHgzOSwgJ2k2NHgyLmx0X3MnOiAw
eGQ3LCAnZjMyeDQubHQnOiAweDQzLCAnZjY0eDIubHQnOiAweDQ5LFxuICAvLyBndFxuICAnaTMy
eDQuZ3Rfcyc6IDB4M2IsICdpNjR4Mi5ndF9zJzogMHhkOSwgJ2YzMng0Lmd0JzogMHg0NCwgJ2Y2
NHgyLmd0JzogMHg0YSxcbiAgLy8gbGVcbiAgJ2kzMng0LmxlX3MnOiAweDNkLCAnaTY0eDIubGVf
cyc6IDB4ZGIsICdmMzJ4NC5sZSc6IDB4NDUsICdmNjR4Mi5sZSc6IDB4NGIsXG4gIC8vIGdlXG4g
ICdpMzJ4NC5nZV9zJzogMHgzZiwgJ2k2NHgyLmdlX3MnOiAweGRkLCAnZjMyeDQuZ2UnOiAweDQ2
LCAnZjY0eDIuZ2UnOiAweDRjLFxuICAvLyB2MTI4IGJpdHdpc2VcbiAgJ3YxMjgubm90JzogMHg0
ZCwgJ3YxMjguYW5kJzogMHg0ZSwgJ3YxMjgub3InOiAweDUwLCAndjEyOC54b3InOiAweDUxLFxu
ICAvLyB2MTI4IG1lbW9yeVxuICAndjEyOC5sb2FkJzogMHgwMCwgJ3YxMjguc3RvcmUnOiAweDBi
LCAndjEyOC5jb25zdCc6IDB4MGMsXG59O1xuXG5mdW5jdGlvbiB3YXNtVHlwZSh0KSB7XG4gIGlm
ICh0ID09PSAnaTMyJykgcmV0dXJuIFdBU01fSTMyO1xuICBpZiAodCA9PT0gJ2k2NCcpIHJldHVy
biBXQVNNX0k2NDtcbiAgaWYgKHQgPT09ICdmMzInKSByZXR1cm4gV0FTTV9GMzI7XG4gIGlmICh0
ID09PSAnZjY0JykgcmV0dXJuIFdBU01fRjY0O1xuICBpZiAoaXNWZWN0b3IodCkpIHJldHVybiBX
QVNNX1YxMjg7XG4gIHRocm93IG5ldyBFcnJvcignVW5rbm93biB0eXBlOiAnICsgdCk7XG59XG5c
bmZ1bmN0aW9uIHR5cGVTaXplKHQpIHtcbiAgaWYgKHQgPT09ICdpMzInIHx8IHQgPT09ICdmMzIn
KSByZXR1cm4gNDtcbiAgaWYgKHQgPT09ICdpNjQnIHx8IHQgPT09ICdmNjQnKSByZXR1cm4gODtc
biAgaWYgKGlzVmVjdG9yKHQpKSByZXR1cm4gMTY7XG4gIHRocm93IG5ldyBFcnJvcignVW5rbm93
biB0eXBlOiAnICsgdCk7XG59XG5cbmZ1bmN0aW9uIGlzRmxvYXQodCkgeyByZXR1cm4gdCA9PT0g
J2YzMicgfHwgdCA9PT0gJ2Y2NCc7IH1cbmZ1bmN0aW9uIGlzSW50KHQpIHsgcmV0dXJuIHQgPT09
ICdpMzInIHx8IHQgPT09ICdpNjQnOyB9XG5mdW5jdGlvbiBpc1ZlY3Rvcih0KSB7IHJldHVybiB0
ID09PSAnZjY0eDInIHx8IHQgPT09ICdmMzJ4NCcgfHwgdCA9PT0gJ2kzMng0JyB8fCB0ID09PSAn
aTY0eDInOyB9XG5mdW5jdGlvbiB2ZWN0b3JTY2FsYXJUeXBlKHQpIHtcbiAgaWYgKHQgPT09ICdm
NjR4MicpIHJldHVybiAnZjY0JztcbiAgaWYgKHQgPT09ICdmMzJ4NCcpIHJldHVybiAnZjMyJztc
biAgaWYgKHQgPT09ICdpMzJ4NCcpIHJldHVybiAnaTMyJztcbiAgaWYgKHQgPT09ICdpNjR4Micp
IHJldHVybiAnaTY0JztcbiAgcmV0dXJuIG51bGw7XG59XG5cbi8vIOKUgOKUgCBCeXRlV3JpdGVy
IOKUgOKUgFxuXG5jbGFzcyBCeXRlV3JpdGVyIHtcbiAgY29uc3RydWN0b3IoKSB7IHRoaXMuYnVm
ID0gW107IH1cbiAgYnl0ZShiKSB7IHRoaXMuYnVmLnB1c2goYiAmIDB4ZmYpOyB9XG4gIGJ5dGVz
KGFycikgeyBmb3IgKGNvbnN0IGIgb2YgYXJyKSB0aGlzLmJ5dGUoYik7IH1cbiAgdTMyKHYpIHsg
Ly8gTEVCMTI4IHVuc2lnbmVkXG4gICAgZG8geyBsZXQgYiA9IHYgJiAweDdmOyB2ID4+Pj0gNzsg
aWYgKHYpIGIgfD0gMHg4MDsgdGhpcy5ieXRlKGIpOyB9IHdoaWxlICh2KTtcbiAgfVxuICBzMzIo
dikgeyAvLyBMRUIxMjggc2lnbmVkXG4gICAgbGV0IG1vcmUgPSB0cnVlO1xuICAgIHdoaWxlICht
b3JlKSB7XG4gICAgICBsZXQgYiA9IHYgJiAweDdmOyB2ID4+PSA3O1xuICAgICAgaWYgKCh2ID09
PSAwICYmICEoYiAmIDB4NDApKSB8fCAodiA9PT0gLTEgJiYgKGIgJiAweDQwKSkpIG1vcmUgPSBm
YWxzZTsgZWxzZSBiIHw9IDB4ODA7XG4gICAgICB0aGlzLmJ5dGUoYik7XG4gICAgfVxuICB9XG4g
IHM2NCh2KSB7IC8vIExFQjEyOCBzaWduZWQgZm9yIGk2NCAoQmlnSW50KVxuICAgIHYgPSBCaWdJ
bnQodik7XG4gICAgbGV0IG1vcmUgPSB0cnVlO1xuICAgIHdoaWxlIChtb3JlKSB7XG4gICAgICBs
ZXQgYiA9IE51bWJlcih2ICYgMHg3Zm4pOyB2ID4+PSA3bjtcbiAgICAgIGlmICgodiA9PT0gMG4g
JiYgIShiICYgMHg0MCkpIHx8ICh2ID09PSAtMW4gJiYgKGIgJiAweDQwKSkpIG1vcmUgPSBmYWxz
ZTsgZWxzZSBiIHw9IDB4ODA7XG4gICAgICB0aGlzLmJ5dGUoYik7XG4gICAgfVxuICB9XG4gIGYz
Mih2KSB7IGNvbnN0IGJ1ZiA9IG5ldyBBcnJheUJ1ZmZlcig0KTsgbmV3IERhdGFWaWV3KGJ1Ziku
c2V0RmxvYXQzMigwLCB2LCB0cnVlKTsgdGhpcy5ieXRlcyhuZXcgVWludDhBcnJheShidWYpKTsg
fVxuICBmNjQodikgeyBjb25zdCBidWYgPSBuZXcgQXJyYXlCdWZmZXIoOCk7IG5ldyBEYXRhVmll
dyhidWYpLnNldEZsb2F0NjQoMCwgdiwgdHJ1ZSk7IHRoaXMuYnl0ZXMobmV3IFVpbnQ4QXJyYXko
YnVmKSk7IH1cbiAgc3RyKHMpIHsgY29uc3QgZW5jID0gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2Rl
KHMpOyB0aGlzLnUzMihlbmMubGVuZ3RoKTsgdGhpcy5ieXRlcyhlbmMpOyB9XG4gIHNlY3Rpb24o
aWQsIGNvbnRlbnRGbikge1xuICAgIGNvbnN0IGlubmVyID0gbmV3IEJ5dGVXcml0ZXIoKTtcbiAg
ICBjb250ZW50Rm4oaW5uZXIpO1xuICAgIHRoaXMuYnl0ZShpZCk7XG4gICAgdGhpcy51MzIoaW5u
ZXIuYnVmLmxlbmd0aCk7XG4gICAgdGhpcy5ieXRlcyhpbm5lci5idWYpO1xuICB9XG4gIHRvVWlu
dDhBcnJheSgpIHsgcmV0dXJuIG5ldyBVaW50OEFycmF5KHRoaXMuYnVmKTsgfVxufVxuXG5mdW5j
dGlvbiBjb2RlZ2VuKGFzdCwgaW50ZXJwVmFsdWVzLCB1c2VySW1wb3J0cykge1xuICBjb25zdCB3
ID0gbmV3IEJ5dGVXcml0ZXIoKTtcblxuICAvLyDilIDilIAgQ29sbGVjdCBpbmZvIOKUgOKUgFxu
ICBjb25zdCBnbG9iYWxzID0gW107ICAgIC8vIHsgbmFtZSwgdnR5cGUsIG11dGFibGUsIGluaXQg
fVxuICBjb25zdCBmdW5jdGlvbnMgPSBbXTsgIC8vIEFTVCBub2Rlc1xuICBjb25zdCBpbXBvcnRz
ID0gW107ICAgIC8vIHsgbmFtZSwgbW9kdWxlTmFtZSwgcGFyYW1zLCByZXRUeXBlLCBpbnRlcnBJ
ZHggfVxuICBjb25zdCBsb2NhbEZ1bmNOYW1lcyA9IG5ldyBTZXQoKTtcblxuICBmb3IgKGNvbnN0
IG5vZGUgb2YgYXN0LmJvZHkpIHtcbiAgICBpZiAobm9kZS50eXBlID09PSAnQ29uc3REZWNsJykg
Z2xvYmFscy5wdXNoKHsgbmFtZTogbm9kZS5uYW1lLCB2dHlwZTogbm9kZS52dHlwZSwgbXV0YWJs
ZTogZmFsc2UsIGluaXQ6IG5vZGUuaW5pdCB9KTtcbiAgICBlbHNlIGlmIChub2RlLnR5cGUgPT09
ICdWYXJEZWNsJykge1xuICAgICAgY29uc3QgZyA9IHsgbmFtZTogbm9kZS5uYW1lLCB2dHlwZTog
bm9kZS52dHlwZSwgbXV0YWJsZTogdHJ1ZSwgaW5pdDogbm9kZS5pbml0IH07XG4gICAgICBpZiAo
bm9kZS5mdW5jU2lnKSBnLmZ1bmNTaWcgPSBub2RlLmZ1bmNTaWc7XG4gICAgICBnbG9iYWxzLnB1
c2goZyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gJ0Z1bmN0aW9uJyB8fCBu
b2RlLnR5cGUgPT09ICdTdWJyb3V0aW5lJykgeyBmdW5jdGlvbnMucHVzaChub2RlKTsgbG9jYWxG
dW5jTmFtZXMuYWRkKG5vZGUubmFtZSk7IH1cbiAgICBlbHNlIGlmIChub2RlLnR5cGUgPT09ICdJ
bXBvcnREZWNsJykgaW1wb3J0cy5wdXNoKG5vZGUpO1xuICB9XG5cbiAgLy8gTWF0aCBidWlsdGlu
cyB0aGF0IG5lZWQgaW1wb3J0aW5nXG4gIGNvbnN0IE1BVEhfQlVJTFRJTlMgPSB7IHNpbjogMSwg
Y29zOiAxLCBsbjogMSwgZXhwOiAxLCBwb3c6IDIsIGF0YW4yOiAyIH07XG4gIC8vIE5hdGl2ZSBi
dWlsdGlucyAobm8gaW1wb3J0IG5lZWRlZCkg4oCUIHJlc29sdmVkIHBlci10eXBlIGluIGVtaXRG
dW5jQ2FsbFxuICBjb25zdCBOQVRJVkVfQlVJTFRJTlMgPSBuZXcgU2V0KFtcbiAgICAnc3FydCcs
J2FicycsJ2Zsb29yJywnY2VpbCcsJ3RydW5jJywnbmVhcmVzdCcsJ2NvcHlzaWduJyxcbiAgICAn
bWluJywnbWF4Jywnc2VsZWN0JyxcbiAgICAnY2x6JywnY3R6JywncG9wY250Jywncm90bCcsJ3Jv
dHInLFxuICAgICdtZW1vcnlfc2l6ZScsJ21lbW9yeV9ncm93JywnbWVtb3J5X2NvcHknLCdtZW1v
cnlfZmlsbCcsXG4gICAgJ2kzMicsJ2k2NCcsJ2YzMicsJ2Y2NCcsIC8vIHR5cGUgY29udmVyc2lv
bnNcbiAgICAnZjY0eDInLCdmMzJ4NCcsJ2kzMng0JywnaTY0eDInLCAvLyB2ZWN0b3IgY29uc3Ry
dWN0b3JzXG4gIF0pO1xuXG4gIC8vIFNjYW4gYWxsIGZ1bmN0aW9uIGJvZGllcyBmb3IgdW5yZXNv
bHZlZCBjYWxsc1xuICBjb25zdCB1c2VkQ2FsbHMgPSBuZXcgU2V0KCk7XG4gIGZ1bmN0aW9uIHNj
YW5DYWxscyhzdG10cykge1xuICAgIGZvciAoY29uc3QgcyBvZiBzdG10cykge1xuICAgICAgaWYg
KHMudHlwZSA9PT0gJ0NhbGwnIHx8IHMudHlwZSA9PT0gJ0Z1bmNDYWxsJykgdXNlZENhbGxzLmFk
ZChzLm5hbWUpO1xuICAgICAgaWYgKHMudHlwZSA9PT0gJ0lmJykgeyBzY2FuQ2FsbHMocy5ib2R5
KTsgaWYgKHMuZWxzZUJvZHkpIHNjYW5DYWxscyhzLmVsc2VCb2R5KTsgfVxuICAgICAgaWYgKHMu
dHlwZSA9PT0gJ0ZvcicgfHwgcy50eXBlID09PSAnV2hpbGUnIHx8IHMudHlwZSA9PT0gJ0RvV2hp
bGUnKSBzY2FuQ2FsbHMocy5ib2R5KTtcbiAgICAgIC8vIHNjYW4gZXhwcmVzc2lvbnNcbiAgICAg
IHNjYW5FeHByQ2FsbHMocyk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHNjYW5FeHByQ2FsbHMo
bm9kZSkge1xuICAgIGlmICghbm9kZSB8fCB0eXBlb2Ygbm9kZSAhPT0gJ29iamVjdCcpIHJldHVy
bjtcbiAgICBpZiAobm9kZS50eXBlID09PSAnRnVuY0NhbGwnKSB1c2VkQ2FsbHMuYWRkKG5vZGUu
bmFtZSk7XG4gICAgLy8gKiogb3BlcmF0b3IgbWF5IG5lZWQgcG93IGltcG9ydCAoZm9yIG5vbi1z
cXJ0LCBub24tc21hbGwtaW50IGV4cG9uZW50cylcbiAgICBpZiAobm9kZS50eXBlID09PSAnQmlu
T3AnICYmIG5vZGUub3AgPT09ICcqKicpIHVzZWRDYWxscy5hZGQoJ3BvdycpO1xuICAgIGZvciAo
Y29uc3QgayBvZiBPYmplY3Qua2V5cyhub2RlKSkge1xuICAgICAgY29uc3QgdiA9IG5vZGVba107
XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2KSkgdi5mb3JFYWNoKHNjYW5FeHByQ2FsbHMpO1xu
ICAgICAgZWxzZSBpZiAodiAmJiB0eXBlb2YgdiA9PT0gJ29iamVjdCcgJiYgdi50eXBlKSBzY2Fu
RXhwckNhbGxzKHYpO1xuICAgIH1cbiAgfVxuICBmb3IgKGNvbnN0IGZuIG9mIGZ1bmN0aW9ucykg
c2NhbkNhbGxzKGZuLmJvZHkpO1xuXG4gIC8vIEF1dG8taW1wb3J0IG1hdGggYnVpbHRpbnMgdGhh
dCBhcmUgYWN0dWFsbHkgdXNlZFxuICBjb25zdCBtYXRoSW1wb3J0cyA9IFtdO1xuICBmb3IgKGNv
bnN0IG5hbWUgb2YgdXNlZENhbGxzKSB7XG4gICAgaWYgKE1BVEhfQlVJTFRJTlNbbmFtZV0gIT09
IHVuZGVmaW5lZCAmJiAhbG9jYWxGdW5jTmFtZXMuaGFzKG5hbWUpICYmICFpbXBvcnRzLmZpbmQo
aW0gPT4gaW0ubmFtZSA9PT0gbmFtZSkpIHtcbiAgICAgIGNvbnN0IG5QYXJhbXMgPSBNQVRIX0JV
SUxUSU5TW25hbWVdO1xuICAgICAgY29uc3QgcGFyYW1zID0gW107XG4gICAgICBmb3IgKGxldCBr
ID0gMDsgayA8IG5QYXJhbXM7IGsrKykgcGFyYW1zLnB1c2goeyB0eXBlOiAnUGFyYW0nLCBuYW1l
OiAneCcgKyBrLCB2dHlwZTogJ2Y2NCcsIGlzQXJyYXk6IGZhbHNlLCBhcnJheURpbXM6IG51bGwg
fSk7XG4gICAgICBtYXRoSW1wb3J0cy5wdXNoKHsgbmFtZSwgbW9kdWxlTmFtZTogJ21hdGgnLCBw
YXJhbXMsIHJldFR5cGU6ICdmNjQnLCBpbnRlcnBJZHg6IG51bGwgfSk7XG4gICAgfVxuICB9XG5c
biAgLy8gQXV0by1pbXBvcnQgZnJvbSB1c2VySW1wb3J0cyBvciBnbG9iYWxUaGlzXG4gIGNvbnN0
IGhvc3RJbXBvcnRzID0gW107XG4gIGZvciAoY29uc3QgbmFtZSBvZiB1c2VkQ2FsbHMpIHtcbiAg
ICBpZiAobG9jYWxGdW5jTmFtZXMuaGFzKG5hbWUpIHx8IE5BVElWRV9CVUlMVElOUy5oYXMobmFt
ZSkgfHwgbmFtZS5zdGFydHNXaXRoKCd3YXNtLicpIHx8XG4gICAgICAgIG5hbWUuc3RhcnRzV2l0
aCgndjEyOC4nKSB8fCBBVFJBX1ZFQ1RPUl9UWVBFUy5oYXMobmFtZS5zcGxpdCgnLicpWzBdKSB8
fFxuICAgICAgICBNQVRIX0JVSUxUSU5TW25hbWVdICE9PSB1bmRlZmluZWQgfHwgaW1wb3J0cy5m
aW5kKGltID0+IGltLm5hbWUgPT09IG5hbWUpKSBjb250aW51ZTtcbiAgICAvLyBjaGVjayB1c2Vy
SW1wb3J0cyB0aGVuIGdsb2JhbFRoaXNcbiAgICBsZXQgZm4gPSB1c2VySW1wb3J0cyAmJiB1c2Vy
SW1wb3J0c1tuYW1lXTtcbiAgICBpZiAoIWZuICYmIHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5k
ZWZpbmVkJykgZm4gPSBnbG9iYWxUaGlzW25hbWVdO1xuICAgIGlmICh0eXBlb2YgZm4gPT09ICdm
dW5jdGlvbicpIHtcbiAgICAgIGNvbnN0IG5QYXJhbXMgPSBmbi5sZW5ndGg7XG4gICAgICBjb25z
dCBwYXJhbXMgPSBbXTtcbiAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgblBhcmFtczsgaysrKSBw
YXJhbXMucHVzaCh7IHR5cGU6ICdQYXJhbScsIG5hbWU6ICd4JyArIGssIHZ0eXBlOiAnZjY0Jywg
aXNBcnJheTogZmFsc2UsIGFycmF5RGltczogbnVsbCB9KTtcbiAgICAgIGhvc3RJbXBvcnRzLnB1
c2goeyBuYW1lLCBtb2R1bGVOYW1lOiAnaG9zdCcsIHBhcmFtcywgcmV0VHlwZTogJ2Y2NCcsIGlu
dGVycElkeDogbnVsbCwganNGbjogZm4gfSk7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgYWxsSW1w
b3J0cyA9IFsuLi5tYXRoSW1wb3J0cywgLi4uaW1wb3J0cywgLi4uaG9zdEltcG9ydHNdO1xuXG4g
IC8vIEJ1aWxkIGZ1bmN0aW9uIGluZGV4IHRhYmxlOiBpbXBvcnRzIGZpcnN0LCB0aGVuIGxvY2Fs
IGZ1bmN0aW9uc1xuICBjb25zdCBmdW5jSW5kZXggPSB7fTtcbiAgbGV0IGlkeCA9IDA7XG4gIGZv
ciAoY29uc3QgaW0gb2YgYWxsSW1wb3J0cykgeyBmdW5jSW5kZXhbaW0ubmFtZV0gPSBpZHgrKzsg
fVxuICBmb3IgKGNvbnN0IGZuIG9mIGZ1bmN0aW9ucykgeyBmdW5jSW5kZXhbZm4ubmFtZV0gPSBp
ZHgrKzsgfVxuXG4gIC8vIEdsb2JhbCBpbmRleCB0YWJsZSAoKyB0cmFjayBmdW5jU2lnIGZvciBm
dW5jdGlvbi10eXBlZCBnbG9iYWxzKVxuICBjb25zdCBnbG9iYWxJbmRleCA9IHt9O1xuICBjb25z
dCBnbG9iYWxGdW5jU2lnID0ge307IC8vIG5hbWUg4oaSIGZ1bmNTaWcgZm9yIGZ1bmN0aW9uLXR5
cGVkIGdsb2JhbHNcbiAgZm9yIChsZXQgZ2kgPSAwOyBnaSA8IGdsb2JhbHMubGVuZ3RoOyBnaSsr
KSB7XG4gICAgZ2xvYmFsSW5kZXhbZ2xvYmFsc1tnaV0ubmFtZV0gPSBnaTtcbiAgICBpZiAoZ2xv
YmFsc1tnaV0uZnVuY1NpZykgZ2xvYmFsRnVuY1NpZ1tnbG9iYWxzW2dpXS5uYW1lXSA9IGdsb2Jh
bHNbZ2ldLmZ1bmNTaWc7XG4gIH1cblxuICAvLyDilIDilIAgU2NhbiBmb3IgZnVuY3Rpb24gcmVm
ZXJlbmNlcyAoYmFyZSBmdW5jdGlvbiBuYW1lcyB1c2VkIGFzIHZhbHVlcykg4pSA4pSAXG4gIGNv
bnN0IHJlZmVyZW5jZWRGdW5jcyA9IG5ldyBTZXQoKTtcbiAgZnVuY3Rpb24gc2NhbkZ1bmNSZWZz
KHN0bXRzLCBsb2NhbE5hbWVzKSB7XG4gICAgZm9yIChjb25zdCBzIG9mIHN0bXRzKSBzY2FuTm9k
ZVJlZnMocywgbG9jYWxOYW1lcyk7XG4gIH1cbiAgZnVuY3Rpb24gc2Nhbk5vZGVSZWZzKG5vZGUs
IGxvY2FsTmFtZXMpIHtcbiAgICBpZiAoIW5vZGUgfHwgdHlwZW9mIG5vZGUgIT09ICdvYmplY3Qn
KSByZXR1cm47XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gJ0lkZW50JyAmJiBmdW5jSW5kZXhbbm9k
ZS5uYW1lXSAhPT0gdW5kZWZpbmVkICYmICFsb2NhbE5hbWVzLmhhcyhub2RlLm5hbWUpICYmIGds
b2JhbEluZGV4W25vZGUubmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmVmZXJlbmNlZEZ1
bmNzLmFkZChub2RlLm5hbWUpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGsgb2YgT2JqZWN0Lmtl
eXMobm9kZSkpIHtcbiAgICAgIGNvbnN0IHYgPSBub2RlW2tdO1xuICAgICAgaWYgKEFycmF5Lmlz
QXJyYXkodikpIHYuZm9yRWFjaChjID0+IHNjYW5Ob2RlUmVmcyhjLCBsb2NhbE5hbWVzKSk7XG4g
ICAgICBlbHNlIGlmICh2ICYmIHR5cGVvZiB2ID09PSAnb2JqZWN0JyAmJiB2LnR5cGUpIHNjYW5O
b2RlUmVmcyh2LCBsb2NhbE5hbWVzKTtcbiAgICB9XG4gIH1cbiAgZm9yIChjb25zdCBmbiBvZiBm
dW5jdGlvbnMpIHtcbiAgICBjb25zdCBsb2NhbE5hbWVzID0gbmV3IFNldCgpO1xuICAgIGZvciAo
Y29uc3QgcCBvZiBmbi5wYXJhbXMpIGxvY2FsTmFtZXMuYWRkKHAubmFtZSk7XG4gICAgZm9yIChj
b25zdCBsIG9mIGZuLmxvY2FscykgbG9jYWxOYW1lcy5hZGQobC5uYW1lKTtcbiAgICBpZiAoZm4u
dHlwZSA9PT0gJ0Z1bmN0aW9uJykgbG9jYWxOYW1lcy5hZGQoZm4ubmFtZSk7IC8vIHJldHVybiB2
YXJcbiAgICBzY2FuRnVuY1JlZnMoZm4uYm9keSwgbG9jYWxOYW1lcyk7XG4gIH1cblxuICAvLyBE
ZXRlY3QgaWYgY2FsbF9pbmRpcmVjdCBpcyBuZWVkZWQgKGZ1bmN0aW9uLXR5cGVkIHBhcmFtcy9s
b2NhbHMvZ2xvYmFscyBleGlzdClcbiAgbGV0IGhhc0luZGlyZWN0Q2FsbHMgPSBPYmplY3Qua2V5
cyhnbG9iYWxGdW5jU2lnKS5sZW5ndGggPiAwO1xuICBpZiAoIWhhc0luZGlyZWN0Q2FsbHMpIHtc
biAgICBmb3IgKGNvbnN0IGZuIG9mIGZ1bmN0aW9ucykge1xuICAgICAgaWYgKGZuLnBhcmFtcy5z
b21lKHAgPT4gcC5mdW5jU2lnKSB8fCBmbi5sb2NhbHMuc29tZShsID0+IGwuZnVuY1NpZykpIHsg
aGFzSW5kaXJlY3RDYWxscyA9IHRydWU7IGJyZWFrOyB9XG4gICAgfVxuICB9XG5cbiAgLy8gQnVp
bGQgdGFibGU6IGV4cGxpY2l0bHkgcmVmZXJlbmNlZCBmdW5jcyBhbHdheXM7IGlmIGNhbGxfaW5k
aXJlY3QgdXNlZCwgYWxzbyBleHBsaWNpdCBpbXBvcnRzICsgbG9jYWwgZnVuY3Rpb25zLlxuICAv
LyBBdXRvLWltcG9ydHMgb25seSBlbnRlciB0aGUgdGFibGUgaWYgZXhwbGljaXRseSByZWZlcmVu
Y2VkIGJ5IGJhcmUgbmFtZS5cbiAgY29uc3QgYXV0b0ltcG9ydE5hbWVzID0gbmV3IFNldChbLi4u
bWF0aEltcG9ydHMubWFwKG0gPT4gbS5uYW1lKSwgLi4uaG9zdEltcG9ydHMubWFwKG0gPT4gbS5u
YW1lKV0pO1xuICBsZXQgdGFibGVGdW5jU2V0O1xuICBpZiAoaGFzSW5kaXJlY3RDYWxscykge1xu
ICAgIHRhYmxlRnVuY1NldCA9IG5ldyBTZXQoW1xuICAgICAgLi4uaW1wb3J0cy5tYXAoaW0gPT4g
aW0ubmFtZSksXG4gICAgICAuLi5mdW5jdGlvbnMubWFwKGZuID0+IGZuLm5hbWUpLFxuICAgICAg
Li4ucmVmZXJlbmNlZEZ1bmNzLFxuICAgIF0pO1xuICAgIC8vIEV4Y2x1ZGUgYXV0by1pbXBvcnRz
IHRoYXQgYXJlbid0IGV4cGxpY2l0bHkgcmVmZXJlbmNlZCBieSBiYXJlIG5hbWVcbiAgICBmb3Ig
KGNvbnN0IG5hbWUgb2YgYXV0b0ltcG9ydE5hbWVzKSB7XG4gICAgICBpZiAoIXJlZmVyZW5jZWRG
dW5jcy5oYXMobmFtZSkpIHRhYmxlRnVuY1NldC5kZWxldGUobmFtZSk7XG4gICAgfVxuICB9IGVs
c2Uge1xuICAgIHRhYmxlRnVuY1NldCA9IG5ldyBTZXQocmVmZXJlbmNlZEZ1bmNzKTtcbiAgfVxu
ICBjb25zdCB0YWJsZUZ1bmNzID0gWy4uLnRhYmxlRnVuY1NldF0uc29ydCgoYSwgYikgPT4gZnVu
Y0luZGV4W2FdIC0gZnVuY0luZGV4W2JdKTtcbiAgY29uc3QgdGFibGVTbG90ID0ge307IC8vIGZ1
bmNOYW1lIOKGkiB0YWJsZSBpbmRleFxuICBmb3IgKGxldCB0aSA9IDA7IHRpIDwgdGFibGVGdW5j
cy5sZW5ndGg7IHRpKyspIHRhYmxlU2xvdFt0YWJsZUZ1bmNzW3RpXV0gPSB0aTtcblxuICAvLyDi
lIDilIAgQnVpbGQgdHlwZSBzaWduYXR1cmVzIOKUgOKUgFxuICBmdW5jdGlvbiBwYXJhbVdhc21U
eXBlKHApIHsgcmV0dXJuIHAuaXNBcnJheSA/ICdpMzInIDogcC52dHlwZTsgfVxuICBmdW5jdGlv
biBzaWdLZXkocGFyYW1zLCByZXRUeXBlKSB7XG4gICAgcmV0dXJuIHBhcmFtcy5tYXAocCA9PiBw
YXJhbVdhc21UeXBlKHApKS5qb2luKCcsJykgKyAnOicgKyAocmV0VHlwZSB8fCAnJyk7XG4gIH1c
biAgY29uc3Qgc2lnTWFwID0gbmV3IE1hcCgpO1xuICBjb25zdCBzaWdMaXN0ID0gW107IC8vIFt7
cGFyYW1zLCByZXRUeXBlfV1cbiAgZnVuY3Rpb24gZ2V0T3JBZGRTaWcocGFyYW1zLCByZXRUeXBl
KSB7XG4gICAgY29uc3Qga2V5ID0gc2lnS2V5KHBhcmFtcywgcmV0VHlwZSk7XG4gICAgaWYgKHNp
Z01hcC5oYXMoa2V5KSkgcmV0dXJuIHNpZ01hcC5nZXQoa2V5KTtcbiAgICBjb25zdCBpZCA9IHNp
Z0xpc3QubGVuZ3RoO1xuICAgIHNpZ0xpc3QucHVzaCh7IHBhcmFtcywgcmV0VHlwZSB9KTtcbiAg
ICBzaWdNYXAuc2V0KGtleSwgaWQpO1xuICAgIHJldHVybiBpZDtcbiAgfVxuXG4gIC8vIFJlZ2lz
dGVyIGFsbCBzaWduYXR1cmVzXG4gIGNvbnN0IGltcG9ydFNpZ0lkcyA9IGFsbEltcG9ydHMubWFw
KGltID0+IGdldE9yQWRkU2lnKGltLnBhcmFtcywgaW0ucmV0VHlwZSkpO1xuICBjb25zdCBmdW5j
U2lnSWRzID0gZnVuY3Rpb25zLm1hcChmbiA9PiB7XG4gICAgY29uc3QgcmV0VHlwZSA9IGZuLnR5
cGUgPT09ICdTdWJyb3V0aW5lJyA/IG51bGwgOiBmbi5yZXRUeXBlO1xuICAgIHJldHVybiBnZXRP
ckFkZFNpZyhmbi5wYXJhbXMsIHJldFR5cGUpO1xuICB9KTtcblxuICAvLyDilIDilIAgRGV0ZXJt
aW5lIG1lbW9yeSDilIDilIBcbiAgY29uc3QgaGFzTWVtb3J5ID0gZnVuY3Rpb25zLnNvbWUoZm4g
PT4gZm4ucGFyYW1zLnNvbWUocCA9PiBwLmlzQXJyYXkpKTtcbiAgY29uc3QgaW1wb3J0TWVtb3J5
ID0gdXNlckltcG9ydHMgJiYgdXNlckltcG9ydHMuX19tZW1vcnk7XG5cbiAgLy8g4pSA4pSAIEVt
aXQgV2FzbSBiaW5hcnkg4pSA4pSAXG4gIC8vIE1hZ2ljICsgdmVyc2lvblxuICB3LmJ5dGVzKFsw
eDAwLCAweDYxLCAweDczLCAweDZkXSk7IC8vIFxcMGFzbVxuICB3LmJ5dGVzKFsweDAxLCAweDAw
LCAweDAwLCAweDAwXSk7IC8vIHZlcnNpb24gMVxuXG4gIC8vIFR5cGUgc2VjdGlvbiAoMSlcbiAg
dy5zZWN0aW9uKDEsIHMgPT4ge1xuICAgIHMudTMyKHNpZ0xpc3QubGVuZ3RoKTtcbiAgICBmb3Ig
KGNvbnN0IHNpZyBvZiBzaWdMaXN0KSB7XG4gICAgICBzLmJ5dGUoMHg2MCk7IC8vIGZ1bmMgdHlw
ZVxuICAgICAgcy51MzIoc2lnLnBhcmFtcy5sZW5ndGgpO1xuICAgICAgZm9yIChjb25zdCBwIG9m
IHNpZy5wYXJhbXMpIHMuYnl0ZSh3YXNtVHlwZShwYXJhbVdhc21UeXBlKHApKSk7XG4gICAgICBp
ZiAoc2lnLnJldFR5cGUpIHsgcy51MzIoMSk7IHMuYnl0ZSh3YXNtVHlwZShzaWcucmV0VHlwZSkp
OyB9XG4gICAgICBlbHNlIHMudTMyKDApO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gSW1wb3J0IHNl
Y3Rpb24gKDIpXG4gIGlmIChhbGxJbXBvcnRzLmxlbmd0aCA+IDAgfHwgaW1wb3J0TWVtb3J5KSB7
XG4gICAgdy5zZWN0aW9uKDIsIHMgPT4ge1xuICAgICAgcy51MzIoYWxsSW1wb3J0cy5sZW5ndGgg
KyAoaW1wb3J0TWVtb3J5ID8gMSA6IDApKTtcbiAgICAgIGZvciAobGV0IGlpID0gMDsgaWkgPCBh
bGxJbXBvcnRzLmxlbmd0aDsgaWkrKykge1xuICAgICAgICBjb25zdCBpbSA9IGFsbEltcG9ydHNb
aWldO1xuICAgICAgICBzLnN0cihpbS5tb2R1bGVOYW1lKTtcbiAgICAgICAgcy5zdHIoaW0ubmFt
ZSk7XG4gICAgICAgIHMuYnl0ZSgweDAwKTsgLy8gZnVuYyBpbXBvcnRcbiAgICAgICAgcy51MzIo
aW1wb3J0U2lnSWRzW2lpXSk7XG4gICAgICB9XG4gICAgICBpZiAoaW1wb3J0TWVtb3J5KSB7XG4g
ICAgICAgIHMuc3RyKCdlbnYnKTtcbiAgICAgICAgcy5zdHIoJ21lbW9yeScpO1xuICAgICAgICBz
LmJ5dGUoMHgwMik7IC8vIG1lbW9yeSBpbXBvcnRcbiAgICAgICAgcy5ieXRlKDB4MDApOyAvLyBu
byBtYXhcbiAgICAgICAgcy51MzIoMSk7IC8vIGluaXRpYWwgMSBwYWdlXG4gICAgICB9XG4gICAg
fSk7XG4gIH1cblxuICAvLyBGdW5jdGlvbiBzZWN0aW9uICgzKVxuICB3LnNlY3Rpb24oMywgcyA9
PiB7XG4gICAgcy51MzIoZnVuY3Rpb25zLmxlbmd0aCk7XG4gICAgZm9yIChjb25zdCBzaWdJZCBv
ZiBmdW5jU2lnSWRzKSBzLnUzMihzaWdJZCk7XG4gIH0pO1xuXG4gIC8vIFRhYmxlIHNlY3Rpb24g
KDQpIOKAlCBvbmx5IGlmIGNhbGxfaW5kaXJlY3QgaXMgdXNlZFxuICBpZiAodGFibGVGdW5jcy5s
ZW5ndGggPiAwKSB7XG4gICAgdy5zZWN0aW9uKDQsIHMgPT4ge1xuICAgICAgcy51MzIoMSk7IC8v
IG9uZSB0YWJsZVxuICAgICAgcy5ieXRlKDB4NzApOyAvLyBmdW5jcmVmXG4gICAgICBzLmJ5dGUo
MHgwMCk7IC8vIG5vIG1heFxuICAgICAgcy51MzIodGFibGVGdW5jcy5sZW5ndGgpOyAvLyBpbml0
aWFsIHNpemUgPSBudW1iZXIgb2YgcmVmZXJlbmNlZCBmdW5jdGlvbnNcbiAgICB9KTtcbiAgfVxu
XG4gIC8vIE1lbW9yeSBzZWN0aW9uICg1KSDigJQgb25seSBpZiBhcnJheXMgdXNlZCBhbmQgbm8g
aW1wb3J0ZWQgbWVtb3J5XG4gIGlmIChoYXNNZW1vcnkgJiYgIWltcG9ydE1lbW9yeSkge1xuICAg
IHcuc2VjdGlvbig1LCBzID0+IHtcbiAgICAgIHMudTMyKDEpO1xuICAgICAgcy5ieXRlKDB4MDAp
OyAvLyBubyBtYXhcbiAgICAgIHMudTMyKDEpOyAvLyBpbml0aWFsOiAxIHBhZ2UgKDY0S0IpXG4g
ICAgfSk7XG4gIH1cblxuICAvLyBHbG9iYWwgc2VjdGlvbiAoNilcbiAgaWYgKGdsb2JhbHMubGVu
Z3RoID4gMCkge1xuICAgIHcuc2VjdGlvbig2LCBzID0+IHtcbiAgICAgIHMudTMyKGdsb2JhbHMu
bGVuZ3RoKTtcbiAgICAgIGZvciAoY29uc3QgZyBvZiBnbG9iYWxzKSB7XG4gICAgICAgIHMuYnl0
ZSh3YXNtVHlwZShnLnZ0eXBlKSk7XG4gICAgICAgIHMuYnl0ZShnLm11dGFibGUgPyAweDAxIDog
MHgwMCk7XG4gICAgICAgIC8vIGluaXQgZXhwcmVzc2lvblxuICAgICAgICBlbWl0Q29uc3RFeHBy
KHMsIGcuaW5pdCwgZy52dHlwZSk7XG4gICAgICAgIHMuYnl0ZShPUF9FTkQpO1xuICAgICAgfVxu
ICAgIH0pO1xuICB9XG5cbiAgLy8gRXhwb3J0IHNlY3Rpb24gKDcpXG4gIHcuc2VjdGlvbig3LCBz
ID0+IHtcbiAgICBjb25zdCBleHBvcnRzID0gZnVuY3Rpb25zLm1hcCgoZm4sIGkpID0+ICh7IG5h
bWU6IGZuLm5hbWUsIGlkeDogYWxsSW1wb3J0cy5sZW5ndGggKyBpIH0pKTtcbiAgICBjb25zdCBt
ZW1FeHBvcnQgPSAoaGFzTWVtb3J5ICYmICFpbXBvcnRNZW1vcnkpID8gMSA6IDA7XG4gICAgcy51
MzIoZXhwb3J0cy5sZW5ndGggKyBtZW1FeHBvcnQpO1xuICAgIGZvciAoY29uc3QgZSBvZiBleHBv
cnRzKSB7XG4gICAgICBzLnN0cihlLm5hbWUpO1xuICAgICAgcy5ieXRlKDB4MDApOyAvLyBmdW5j
IGV4cG9ydFxuICAgICAgcy51MzIoZS5pZHgpO1xuICAgIH1cbiAgICBpZiAobWVtRXhwb3J0KSB7
XG4gICAgICBzLnN0cignbWVtb3J5Jyk7XG4gICAgICBzLmJ5dGUoMHgwMik7IC8vIG1lbW9yeSBl
eHBvcnRcbiAgICAgIHMudTMyKDApO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gRWxlbWVudCBzZWN0
aW9uICg5KSDigJQgcG9wdWxhdGUgdGhlIHRhYmxlIHdpdGggZnVuY3Rpb24gcmVmZXJlbmNlc1xu
ICBpZiAodGFibGVGdW5jcy5sZW5ndGggPiAwKSB7XG4gICAgdy5zZWN0aW9uKDksIHMgPT4ge1xu
ICAgICAgcy51MzIoMSk7IC8vIG9uZSBlbGVtZW50IHNlZ21lbnRcbiAgICAgIHMudTMyKDApOyAv
LyB0YWJsZSBpbmRleCAwXG4gICAgICAvLyBvZmZzZXQgZXhwcmVzc2lvbjogaTMyLmNvbnN0IDBc
biAgICAgIHMuYnl0ZShPUF9JMzJfQ09OU1QpOyBzLnMzMigwKTsgcy5ieXRlKE9QX0VORCk7XG4g
ICAgICBzLnUzMih0YWJsZUZ1bmNzLmxlbmd0aCk7XG4gICAgICBmb3IgKGNvbnN0IGZuYW1lIG9m
IHRhYmxlRnVuY3MpIHMudTMyKGZ1bmNJbmRleFtmbmFtZV0pO1xuICAgIH0pO1xuICB9XG5cbiAg
Ly8gQ29kZSBzZWN0aW9uICgxMClcbiAgdy5zZWN0aW9uKDEwLCBzID0+IHtcbiAgICBzLnUzMihm
dW5jdGlvbnMubGVuZ3RoKTtcbiAgICBmb3IgKGNvbnN0IGZuIG9mIGZ1bmN0aW9ucykge1xuICAg
ICAgY29uc3QgYm9keVdyaXRlciA9IG5ldyBCeXRlV3JpdGVyKCk7XG4gICAgICBlbWl0RnVuY3Rp
b25Cb2R5KGJvZHlXcml0ZXIsIGZuKTtcbiAgICAgIHMudTMyKGJvZHlXcml0ZXIuYnVmLmxlbmd0
aCk7XG4gICAgICBzLmJ5dGVzKGJvZHlXcml0ZXIuYnVmKTtcbiAgICB9XG4gIH0pO1xuXG4gIGNv
bnN0IGJ5dGVzID0gdy50b1VpbnQ4QXJyYXkoKTtcbiAgY29uc3QgdGFibGUgPSB0YWJsZUZ1bmNz
Lmxlbmd0aCA+IDAgPyB7IC4uLnRhYmxlU2xvdCB9IDogbnVsbDtcbiAgcmV0dXJuIHsgYnl0ZXMs
IHRhYmxlIH07XG5cbiAgLy8g4pSA4pSAIEhlbHBlcjogZW1pdCBjb25zdGFudCBpbml0IGV4cHJl
c3Npb24g4pSA4pSAXG4gIGZ1bmN0aW9uIGVtaXRDb25zdEV4cHIocywgbm9kZSwgdnR5cGUpIHtc
biAgICBpZiAoIW5vZGUpIHtcbiAgICAgIC8vIGRlZmF1bHQgemVyb1xuICAgICAgaWYgKHZ0eXBl
ID09PSAnaTMyJykgeyBzLmJ5dGUoT1BfSTMyX0NPTlNUKTsgcy5zMzIoMCk7IH1cbiAgICAgIGVs
c2UgaWYgKHZ0eXBlID09PSAnaTY0JykgeyBzLmJ5dGUoT1BfSTY0X0NPTlNUKTsgcy5zNjQoMG4p
OyB9XG4gICAgICBlbHNlIGlmICh2dHlwZSA9PT0gJ2YzMicpIHsgcy5ieXRlKE9QX0YzMl9DT05T
VCk7IHMuZjMyKDApOyB9XG4gICAgICBlbHNlIGlmICh2dHlwZSA9PT0gJ2Y2NCcpIHsgcy5ieXRl
KE9QX0Y2NF9DT05TVCk7IHMuZjY0KDApOyB9XG4gICAgICBlbHNlIGlmIChpc1ZlY3Rvcih2dHlw
ZSkpIHtcbiAgICAgICAgLy8gdjEyOC5jb25zdCB3aXRoIDE2IHplcm8gYnl0ZXNcbiAgICAgICAg
cy5ieXRlKE9QX1NJTURfUFJFRklYKTsgcy51MzIoU0lNRF9PUFNbJ3YxMjguY29uc3QnXSk7XG4g
ICAgICAgIGZvciAobGV0IHZpID0gMDsgdmkgPCAxNjsgdmkrKykgcy5ieXRlKDApO1xuICAgICAg
fVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAobm9kZS50eXBlID09PSAnTnVtYmVyTGl0
Jykge1xuICAgICAgY29uc3QgdmFsID0gcGFyc2VOdW1lcmljVmFsdWUobm9kZSwgdnR5cGUpO1xu
ICAgICAgZW1pdFR5cGVkQ29uc3QocywgdnR5cGUsIHZhbCk7XG4gICAgICByZXR1cm47XG4gICAg
fVxuICAgIGlmIChub2RlLnR5cGUgPT09ICdVbmFyeU9wJyAmJiBub2RlLm9wID09PSAnLScgJiYg
bm9kZS5vcGVyYW5kLnR5cGUgPT09ICdOdW1iZXJMaXQnKSB7XG4gICAgICBjb25zdCB2YWwgPSAt
cGFyc2VOdW1lcmljVmFsdWUobm9kZS5vcGVyYW5kLCB2dHlwZSk7XG4gICAgICBlbWl0VHlwZWRD
b25zdChzLCB2dHlwZSwgdmFsKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhyb3cgbmV3
IEVycm9yKCdHbG9iYWwgaW5pdCBtdXN0IGJlIGEgY29uc3RhbnQgZXhwcmVzc2lvbicpO1xuICB9
XG5cbiAgZnVuY3Rpb24gcGFyc2VOdW1lcmljVmFsdWUobm9kZSwgZGVmYXVsdFR5cGUpIHtcbiAg
ICBjb25zdCByYXcgPSBub2RlLnZhbHVlO1xuICAgIGlmIChyYXcuaW5jbHVkZXMoJy4nKSB8fCBy
YXcuaW5jbHVkZXMoJ2UnKSB8fCByYXcuaW5jbHVkZXMoJ0UnKSB8fCBub2RlLmlzRmxvYXQpIHJl
dHVybiBwYXJzZUZsb2F0KHJhdyk7XG4gICAgcmV0dXJuIHBhcnNlSW50KHJhdywgMTApO1xuICB9
XG5cbiAgZnVuY3Rpb24gZW1pdFR5cGVkQ29uc3QocywgdnR5cGUsIHZhbCkge1xuICAgIGlmICh2
dHlwZSA9PT0gJ2kzMicpIHsgcy5ieXRlKE9QX0kzMl9DT05TVCk7IHMuczMyKHZhbCB8IDApOyB9
XG4gICAgZWxzZSBpZiAodnR5cGUgPT09ICdpNjQnKSB7IHMuYnl0ZShPUF9JNjRfQ09OU1QpOyBz
LnM2NChCaWdJbnQodmFsKSk7IH1cbiAgICBlbHNlIGlmICh2dHlwZSA9PT0gJ2YzMicpIHsgcy5i
eXRlKE9QX0YzMl9DT05TVCk7IHMuZjMyKHZhbCk7IH1cbiAgICBlbHNlIGlmICh2dHlwZSA9PT0g
J2Y2NCcpIHsgcy5ieXRlKE9QX0Y2NF9DT05TVCk7IHMuZjY0KHZhbCk7IH1cbiAgfVxuXG4gIC8v
IOKUgOKUgCBFbWl0IGZ1bmN0aW9uIGJvZHkg4pSA4pSAXG4gIGZ1bmN0aW9uIGVtaXRGdW5jdGlv
bkJvZHkoYncsIGZuKSB7XG4gICAgY29uc3QgaXNGdW5jID0gZm4udHlwZSA9PT0gJ0Z1bmN0aW9u
JztcbiAgICBjb25zdCByZXRUeXBlID0gaXNGdW5jID8gZm4ucmV0VHlwZSA6IG51bGw7XG5cbiAg
ICAvLyBCdWlsZCBsb2NhbCBtYXA6IHBhcmFtcyArIGxvY2FscyArIHJldHVybiB2YXJcbiAgICBj
b25zdCBsb2NhbE1hcCA9IHt9OyAvLyBuYW1lIOKGkiB7IGlkeCwgdnR5cGUgfVxuICAgIGxldCBs
b2NhbElkeCA9IDA7XG4gICAgZm9yIChjb25zdCBwIG9mIGZuLnBhcmFtcykge1xuICAgICAgY29u
c3QgZW50cnkgPSB7XG4gICAgICAgIGlkeDogbG9jYWxJZHgrKyxcbiAgICAgICAgdnR5cGU6IHAu
aXNBcnJheSA/ICdpMzInIDogcC52dHlwZSwgLy8gV2FzbSB0eXBlOiBhcnJheXMgYXJlIGkzMiBw
b2ludGVyc1xuICAgICAgICBpc0FycmF5OiBwLmlzQXJyYXksXG4gICAgICAgIGFycmF5RGltczog
cC5hcnJheURpbXMsXG4gICAgICAgIGVsZW1UeXBlOiBwLmlzQXJyYXkgPyBwLnZ0eXBlIDogbnVs
bCAgLy8gZWxlbWVudCB0eXBlIGZvciBsb2FkL3N0b3JlXG4gICAgICB9O1xuICAgICAgaWYgKHAu
ZnVuY1NpZykgZW50cnkuZnVuY1NpZyA9IHAuZnVuY1NpZztcbiAgICAgIGxvY2FsTWFwW3AubmFt
ZV0gPSBlbnRyeTtcbiAgICB9XG4gICAgLy8gQWRkaXRpb25hbCBsb2NhbHMgZGVjbGFyZWRcbiAg
ICBjb25zdCBkZWNsYXJlZExvY2FscyA9IFsuLi5mbi5sb2NhbHNdO1xuICAgIGlmIChpc0Z1bmMp
IHtcbiAgICAgIC8vIGhpZGRlbiByZXR1cm4gbG9jYWwgKHVzZXMgZnVuY3Rpb24gbmFtZSlcbiAg
ICAgIGRlY2xhcmVkTG9jYWxzLnB1c2goeyBuYW1lOiAnJF9yZXR1cm4nLCB2dHlwZTogcmV0VHlw
ZSB9KTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBsb2Mgb2YgZGVjbGFyZWRMb2NhbHMpIHtcbiAg
ICAgIGNvbnN0IGVudHJ5ID0geyBpZHg6IGxvY2FsSWR4KyssIHZ0eXBlOiBsb2MudnR5cGUgfTtc
biAgICAgIGlmIChsb2MuZnVuY1NpZykgZW50cnkuZnVuY1NpZyA9IGxvYy5mdW5jU2lnO1xuICAg
ICAgbG9jYWxNYXBbbG9jLm5hbWVdID0gZW50cnk7XG4gICAgfVxuXG4gICAgLy8gRW1pdCBsb2Nh
bCBkZWNsYXJhdGlvbnMgKG9ubHkgdGhlIG5vbi1wYXJhbSBvbmVzKVxuICAgIGNvbnN0IGxvY2Fs
VHlwZXMgPSBkZWNsYXJlZExvY2Fscy5tYXAobCA9PiBsLnZ0eXBlKTtcbiAgICAvLyBDb21wcmVz
czogcnVucyBvZiBzYW1lIHR5cGVcbiAgICBjb25zdCBsb2NhbFJ1bnMgPSBbXTtcbiAgICBmb3Ig
KGNvbnN0IGx0IG9mIGxvY2FsVHlwZXMpIHtcbiAgICAgIGlmIChsb2NhbFJ1bnMubGVuZ3RoID4g
MCAmJiBsb2NhbFJ1bnNbbG9jYWxSdW5zLmxlbmd0aCAtIDFdLnR5cGUgPT09IGx0KSBsb2NhbFJ1
bnNbbG9jYWxSdW5zLmxlbmd0aCAtIDFdLmNvdW50Kys7XG4gICAgICBlbHNlIGxvY2FsUnVucy5w
dXNoKHsgY291bnQ6IDEsIHR5cGU6IGx0IH0pO1xuICAgIH1cbiAgICBidy51MzIobG9jYWxSdW5z
Lmxlbmd0aCk7XG4gICAgZm9yIChjb25zdCBydW4gb2YgbG9jYWxSdW5zKSB7XG4gICAgICBidy51
MzIocnVuLmNvdW50KTtcbiAgICAgIGJ3LmJ5dGUod2FzbVR5cGUocnVuLnR5cGUpKTtcbiAgICB9
XG5cbiAgICAvLyBTSU1EIGhlbHBlclxuICAgIGZ1bmN0aW9uIGVtaXRTaW1kKG9wKSB7IGJ3LmJ5
dGUoT1BfU0lNRF9QUkVGSVgpOyBidy51MzIob3ApOyB9XG5cbiAgICAvLyBFbWl0IGJvZHkgc3Rh
dGVtZW50c1xuICAgIGxldCBkZXB0aCA9IDA7IC8vIGN1cnJlbnQgYmxvY2sgbmVzdGluZyBkZXB0
aFxuICAgIGNvbnN0IGJyZWFrVGFyZ2V0cyA9IFtdOyAvLyBzdGFjayBvZiB7ZGVwdGh9IGZvciBl
YWNoIGVuY2xvc2luZyBsb29wJ3MgYnJlYWsgYmxvY2tcblxuICAgIGZ1bmN0aW9uIGVtaXRTdG10
cyhzdG10cykgeyBmb3IgKGNvbnN0IHMgb2Ygc3RtdHMpIGVtaXRTdG10KHMpOyB9XG5cbiAgICBm
dW5jdGlvbiBlbWl0U3RtdChzdG10KSB7XG4gICAgICBzd2l0Y2ggKHN0bXQudHlwZSkge1xuICAg
ICAgICBjYXNlICdBc3NpZ24nOiB7XG4gICAgICAgICAgY29uc3QgdGFyZ2V0ID0gc3RtdC5uYW1l
O1xuICAgICAgICAgIC8vIEFzc2lnbm1lbnQgdG8gZnVuY3Rpb24gbmFtZSA9IHNldCByZXR1cm4g
dmFyaWFibGVcbiAgICAgICAgICBpZiAoaXNGdW5jICYmIHRhcmdldCA9PT0gZm4ubmFtZSkge1xu
ICAgICAgICAgICAgZW1pdEV4cHIoc3RtdC52YWx1ZSwgcmV0VHlwZSk7XG4gICAgICAgICAgICBi
dy5ieXRlKE9QX0xPQ0FMX1NFVCk7XG4gICAgICAgICAgICBidy51MzIobG9jYWxNYXBbJyRfcmV0
dXJuJ10uaWR4KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGxvY2FsTWFwW3RhcmdldF0pIHtcbiAg
ICAgICAgICAgIGVtaXRFeHByKHN0bXQudmFsdWUsIGxvY2FsTWFwW3RhcmdldF0udnR5cGUpO1xu
ICAgICAgICAgICAgYncuYnl0ZShPUF9MT0NBTF9TRVQpO1xuICAgICAgICAgICAgYncudTMyKGxv
Y2FsTWFwW3RhcmdldF0uaWR4KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGdsb2JhbEluZGV4W3Rh
cmdldF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZW1pdEV4cHIoc3RtdC52YWx1ZSwg
Z2xvYmFsc1tnbG9iYWxJbmRleFt0YXJnZXRdXS52dHlwZSk7XG4gICAgICAgICAgICBidy5ieXRl
KE9QX0dMT0JBTF9TRVQpO1xuICAgICAgICAgICAgYncudTMyKGdsb2JhbEluZGV4W3RhcmdldF0p
O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZGVm
aW5lZCB2YXJpYWJsZTogJHt0YXJnZXR9YCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFr
O1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ0FycmF5U3RvcmUnOiB7XG4gICAgICAgICAgY29u
c3QgaW5mbyA9IGxvY2FsTWFwW3N0bXQubmFtZV07XG4gICAgICAgICAgaWYgKCFpbmZvKSB0aHJv
dyBuZXcgRXJyb3IoYFVuZGVmaW5lZCBhcnJheTogJHtzdG10Lm5hbWV9YCk7XG4gICAgICAgICAg
Y29uc3QgZWxlbVR5cGUgPSBpbmZvLmVsZW1UeXBlIHx8IGluZm8udnR5cGU7XG4gICAgICAgICAg
Ly8gY29tcHV0ZSBhZGRyZXNzXG4gICAgICAgICAgZW1pdEFycmF5QWRkcihzdG10Lm5hbWUsIHN0
bXQuaW5kaWNlcywgaW5mbywgZWxlbVR5cGUpO1xuICAgICAgICAgIC8vIGNvbXB1dGUgdmFsdWVc
biAgICAgICAgICBlbWl0RXhwcihzdG10LnZhbHVlLCBlbGVtVHlwZSk7XG4gICAgICAgICAgLy8g
c3RvcmVcbiAgICAgICAgICBlbWl0U3RvcmUoZWxlbVR5cGUpO1xuICAgICAgICAgIGJyZWFrO1xu
ICAgICAgICB9XG4gICAgICAgIGNhc2UgJ0lmJzoge1xuICAgICAgICAgIGVtaXRFeHByKHN0bXQu
Y29uZCwgJ2kzMicpO1xuICAgICAgICAgIGJ3LmJ5dGUoT1BfSUYpO1xuICAgICAgICAgIGJ3LmJ5
dGUoV0FTTV9WT0lEKTtcbiAgICAgICAgICBkZXB0aCsrO1xuICAgICAgICAgIGVtaXRTdG10cyhz
dG10LmJvZHkpO1xuICAgICAgICAgIGlmIChzdG10LmVsc2VCb2R5KSB7XG4gICAgICAgICAgICBi
dy5ieXRlKE9QX0VMU0UpO1xuICAgICAgICAgICAgZW1pdFN0bXRzKHN0bXQuZWxzZUJvZHkpO1xu
ICAgICAgICAgIH1cbiAgICAgICAgICBkZXB0aC0tO1xuICAgICAgICAgIGJ3LmJ5dGUoT1BfRU5E
KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdGb3InOiB7XG4g
ICAgICAgICAgY29uc3QgdkluZm8gPSBsb2NhbE1hcFtzdG10LnZhck5hbWVdO1xuICAgICAgICAg
IGlmICghdkluZm8pIHRocm93IG5ldyBFcnJvcihgVW5kZWZpbmVkIGxvb3AgdmFyaWFibGU6ICR7
c3RtdC52YXJOYW1lfWApO1xuICAgICAgICAgIGNvbnN0IHZ0ID0gdkluZm8udnR5cGU7XG4gICAg
ICAgICAgZW1pdEV4cHIoc3RtdC5zdGFydCwgdnQpO1xuICAgICAgICAgIGJ3LmJ5dGUoT1BfTE9D
QUxfU0VUKTtcbiAgICAgICAgICBidy51MzIodkluZm8uaWR4KTtcblxuICAgICAgICAgIGNvbnN0
IGhhc1N0ZXAgPSBzdG10LnN0ZXAgIT09IG51bGw7XG5cbiAgICAgICAgICBidy5ieXRlKE9QX0JM
T0NLKTsgYncuYnl0ZShXQVNNX1ZPSUQpOyBkZXB0aCsrO1xuICAgICAgICAgIGNvbnN0IGJyZWFr
RGVwdGggPSBkZXB0aDsgLy8gYnJlYWsgdGFyZ2V0ID0gdGhpcyBibG9ja1xuICAgICAgICAgIGJ3
LmJ5dGUoT1BfTE9PUCk7IGJ3LmJ5dGUoV0FTTV9WT0lEKTsgZGVwdGgrKztcbiAgICAgICAgICBi
cmVha1RhcmdldHMucHVzaChicmVha0RlcHRoKTtcblxuICAgICAgICAgIC8vIGNvbmRpdGlvbiBj
aGVjazogYnJfaWYgdG8gYnJlYWsgYmxvY2tcbiAgICAgICAgICBidy5ieXRlKE9QX0xPQ0FMX0dF
VCk7IGJ3LnUzMih2SW5mby5pZHgpO1xuICAgICAgICAgIGVtaXRFeHByKHN0bXQuZW5kLCB2dCk7
XG4gICAgICAgICAgaWYgKCFoYXNTdGVwKSB7XG4gICAgICAgICAgICBlbWl0Q21wKCc+PScsIHZ0
KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qgc3RlcElzTmVnTGl0ID0g
c3RtdC5zdGVwLnR5cGUgPT09ICdVbmFyeU9wJyAmJiBzdG10LnN0ZXAub3AgPT09ICctJyAmJiBz
dG10LnN0ZXAub3BlcmFuZC50eXBlID09PSAnTnVtYmVyTGl0JztcbiAgICAgICAgICAgIGNvbnN0
IHN0ZXBJc05lZ0NvbnN0ID0gc3RlcElzTmVnTGl0IHx8IChzdG10LnN0ZXAudHlwZSA9PT0gJ051
bWJlckxpdCcgJiYgcGFyc2VGbG9hdChzdG10LnN0ZXAudmFsdWUpIDwgMCk7XG4gICAgICAgICAg
ICBlbWl0Q21wKHN0ZXBJc05lZ0NvbnN0ID8gJzw9JyA6ICc+PScsIHZ0KTtcbiAgICAgICAgICB9
XG4gICAgICAgICAgYncuYnl0ZShPUF9CUl9JRik7IGJ3LnUzMihkZXB0aCAtIGJyZWFrRGVwdGgp
O1xuXG4gICAgICAgICAgZW1pdFN0bXRzKHN0bXQuYm9keSk7XG5cbiAgICAgICAgICAvLyBpbmNy
ZW1lbnRcbiAgICAgICAgICBidy5ieXRlKE9QX0xPQ0FMX0dFVCk7IGJ3LnUzMih2SW5mby5pZHgp
O1xuICAgICAgICAgIGlmIChoYXNTdGVwKSB7IGVtaXRFeHByKHN0bXQuc3RlcCwgdnQpOyB9IGVs
c2UgeyBlbWl0VHlwZWRDb25zdChidywgdnQsIDEpOyB9XG4gICAgICAgICAgZW1pdEFkZCh2dCk7
XG4gICAgICAgICAgYncuYnl0ZShPUF9MT0NBTF9TRVQpOyBidy51MzIodkluZm8uaWR4KTtcblxu
ICAgICAgICAgIGJ3LmJ5dGUoT1BfQlIpOyBidy51MzIoMCk7IC8vIGNvbnRpbnVlIHRvIGxvb3Bc
biAgICAgICAgICBkZXB0aC0tOyBidy5ieXRlKE9QX0VORCk7IC8vIGVuZCBsb29wXG4gICAgICAg
ICAgYnJlYWtUYXJnZXRzLnBvcCgpO1xuICAgICAgICAgIGRlcHRoLS07IGJ3LmJ5dGUoT1BfRU5E
KTsgLy8gZW5kIGJsb2NrXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2Fz
ZSAnV2hpbGUnOiB7XG4gICAgICAgICAgYncuYnl0ZShPUF9CTE9DSyk7IGJ3LmJ5dGUoV0FTTV9W
T0lEKTsgZGVwdGgrKztcbiAgICAgICAgICBjb25zdCBicmVha0RlcHRoID0gZGVwdGg7XG4gICAg
ICAgICAgYncuYnl0ZShPUF9MT09QKTsgYncuYnl0ZShXQVNNX1ZPSUQpOyBkZXB0aCsrO1xuICAg
ICAgICAgIGJyZWFrVGFyZ2V0cy5wdXNoKGJyZWFrRGVwdGgpO1xuXG4gICAgICAgICAgZW1pdEV4
cHIoc3RtdC5jb25kLCAnaTMyJyk7XG4gICAgICAgICAgYncuYnl0ZShPUF9JMzJfRVFaKTtcbiAg
ICAgICAgICBidy5ieXRlKE9QX0JSX0lGKTsgYncudTMyKGRlcHRoIC0gYnJlYWtEZXB0aCk7XG5c
biAgICAgICAgICBlbWl0U3RtdHMoc3RtdC5ib2R5KTtcblxuICAgICAgICAgIGJ3LmJ5dGUoT1Bf
QlIpOyBidy51MzIoMCk7IC8vIGNvbnRpbnVlIGxvb3BcbiAgICAgICAgICBkZXB0aC0tOyBidy5i
eXRlKE9QX0VORCk7IC8vIGVuZCBsb29wXG4gICAgICAgICAgYnJlYWtUYXJnZXRzLnBvcCgpO1xu
ICAgICAgICAgIGRlcHRoLS07IGJ3LmJ5dGUoT1BfRU5EKTsgLy8gZW5kIGJsb2NrXG4gICAgICAg
ICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnRG9XaGlsZSc6IHtcbiAgICAgICAg
ICBidy5ieXRlKE9QX0JMT0NLKTsgYncuYnl0ZShXQVNNX1ZPSUQpOyBkZXB0aCsrO1xuICAgICAg
ICAgIGNvbnN0IGJyZWFrRGVwdGggPSBkZXB0aDtcbiAgICAgICAgICBidy5ieXRlKE9QX0xPT1Ap
OyBidy5ieXRlKFdBU01fVk9JRCk7IGRlcHRoKys7XG4gICAgICAgICAgYnJlYWtUYXJnZXRzLnB1
c2goYnJlYWtEZXB0aCk7XG5cbiAgICAgICAgICBlbWl0U3RtdHMoc3RtdC5ib2R5KTtcblxuICAg
ICAgICAgIGVtaXRFeHByKHN0bXQuY29uZCwgJ2kzMicpO1xuICAgICAgICAgIGJ3LmJ5dGUoT1Bf
QlJfSUYpOyBidy51MzIoMCk7IC8vIGNvbnRpbnVlIGlmIHRydWVcblxuICAgICAgICAgIGRlcHRo
LS07IGJ3LmJ5dGUoT1BfRU5EKTsgLy8gZW5kIGxvb3BcbiAgICAgICAgICBicmVha1RhcmdldHMu
cG9wKCk7XG4gICAgICAgICAgZGVwdGgtLTsgYncuYnl0ZShPUF9FTkQpOyAvLyBlbmQgYmxvY2tc
biAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdCcmVhayc6IHtcbiAg
ICAgICAgICBpZiAoYnJlYWtUYXJnZXRzLmxlbmd0aCA9PT0gMCkgdGhyb3cgbmV3IEVycm9yKCdi
cmVhayBvdXRzaWRlIGxvb3AnKTtcbiAgICAgICAgICBjb25zdCB0YXJnZXREZXB0aCA9IGJyZWFr
VGFyZ2V0c1ticmVha1RhcmdldHMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgYncuYnl0ZShPUF9C
Uik7XG4gICAgICAgICAgYncudTMyKGRlcHRoIC0gdGFyZ2V0RGVwdGgpO1xuICAgICAgICAgIGJy
ZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ0NhbGwnOiB7XG4gICAgICAgICAgLy8gU0lN
RCBuYW1lc3BhY2VkIGJ1aWx0aW5zIHVzZWQgYXMgc3RhdGVtZW50cyAoZS5nLiBjYWxsIHYxMjgu
c3RvcmUoLi4uKSlcbiAgICAgICAgICBjb25zdCBjYWxsRG90SWR4ID0gc3RtdC5uYW1lLmluZGV4
T2YoJy4nKTtcbiAgICAgICAgICBpZiAoY2FsbERvdElkeCAhPT0gLTEpIHtcbiAgICAgICAgICAg
IGNvbnN0IGNhbGxQcmVmaXggPSBzdG10Lm5hbWUuc2xpY2UoMCwgY2FsbERvdElkeCk7XG4gICAg
ICAgICAgICBjb25zdCBjYWxsTWV0aG9kID0gc3RtdC5uYW1lLnNsaWNlKGNhbGxEb3RJZHggKyAx
KTtcbiAgICAgICAgICAgIGlmIChpc1ZlY3RvcihjYWxsUHJlZml4KSB8fCBjYWxsUHJlZml4ID09
PSAndjEyOCcpIHtcbiAgICAgICAgICAgICAgZW1pdFNpbWRCdWlsdGluKGNhbGxQcmVmaXgsIGNh
bGxNZXRob2QsIHN0bXQsIG51bGwpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAg
IH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gTmF0aXZlIGJ1aWx0aW5zIHVzZWQgYXMgc3Rh
dGVtZW50cyAoZS5nLiBjYWxsIG1lbW9yeV9jb3B5KC4uLikpXG4gICAgICAgICAgaWYgKE5BVElW
RV9CVUlMVElOUy5oYXMoc3RtdC5uYW1lKSkge1xuICAgICAgICAgICAgZW1pdEZ1bmNDYWxsKHN0
bXQsIG51bGwpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8v
IEluZGlyZWN0IGNhbGwgdmlhIGZ1bmN0aW9uLXR5cGVkIHZhcmlhYmxlIHVzZWQgYXMgc3RhdGVt
ZW50XG4gICAgICAgICAgY29uc3QgY2FsbExvY2FsSW5mbyA9IGxvY2FsTWFwW3N0bXQubmFtZV07
XG4gICAgICAgICAgY29uc3QgY2FsbEdTaWcgPSBnbG9iYWxGdW5jU2lnW3N0bXQubmFtZV07XG4g
ICAgICAgICAgaWYgKChjYWxsTG9jYWxJbmZvICYmIGNhbGxMb2NhbEluZm8uZnVuY1NpZykgfHwg
Y2FsbEdTaWcpIHtcbiAgICAgICAgICAgIGVtaXRGdW5jQ2FsbChzdG10LCBudWxsKTtcbiAgICAg
ICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBzdWJyb3V0aW5lIGNhbGwg
b3IgZnVuY3Rpb24gY2FsbCAocmVzdWx0IGRpc2NhcmRlZClcbiAgICAgICAgICBjb25zdCBmSWR4
ID0gZnVuY0luZGV4W3N0bXQubmFtZV07XG4gICAgICAgICAgaWYgKGZJZHggPT09IHVuZGVmaW5l
ZCkgdGhyb3cgbmV3IEVycm9yKGBVbmRlZmluZWQgZnVuY3Rpb246ICR7c3RtdC5uYW1lfWApO1xu
ICAgICAgICAgIGZvciAobGV0IGFpID0gMDsgYWkgPCBzdG10LmFyZ3MubGVuZ3RoOyBhaSsrKSB7
XG4gICAgICAgICAgICAvLyBpbmZlciBwYXJhbSB0eXBlIGZyb20gZGVjbGFyYXRpb25cbiAgICAg
ICAgICAgIGNvbnN0IHBhcmFtVHlwZSA9IGdldFBhcmFtVHlwZShzdG10Lm5hbWUsIGFpKTtcbiAg
ICAgICAgICAgIGVtaXRFeHByKHN0bXQuYXJnc1thaV0sIHBhcmFtVHlwZSk7XG4gICAgICAgICAg
fVxuICAgICAgICAgIGJ3LmJ5dGUoT1BfQ0FMTCk7XG4gICAgICAgICAgYncudTMyKGZJZHgpO1xu
ICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAg
dGhyb3cgbmV3IEVycm9yKGBVbmtub3duIHN0YXRlbWVudCB0eXBlOiAke3N0bXQudHlwZX1gKTtc
biAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRQYXJhbVR5cGUoZnVuY05hbWUsIHBh
cmFtSWR4KSB7XG4gICAgICAvLyBjaGVjayBsb2NhbCBmdW5jdGlvbnNcbiAgICAgIGNvbnN0IGZu
ID0gZnVuY3Rpb25zLmZpbmQoZiA9PiBmLm5hbWUgPT09IGZ1bmNOYW1lKTtcbiAgICAgIGlmIChm
biAmJiBmbi5wYXJhbXNbcGFyYW1JZHhdKSByZXR1cm4gZm4ucGFyYW1zW3BhcmFtSWR4XS5pc0Fy
cmF5ID8gJ2kzMicgOiBmbi5wYXJhbXNbcGFyYW1JZHhdLnZ0eXBlO1xuICAgICAgLy8gY2hlY2sg
aW1wb3J0c1xuICAgICAgY29uc3QgaW0gPSBhbGxJbXBvcnRzLmZpbmQoaSA9PiBpLm5hbWUgPT09
IGZ1bmNOYW1lKTtcbiAgICAgIGlmIChpbSAmJiBpbS5wYXJhbXNbcGFyYW1JZHhdKSByZXR1cm4g
aW0ucGFyYW1zW3BhcmFtSWR4XS52dHlwZTtcbiAgICAgIHJldHVybiAnZjY0JzsgLy8gZGVmYXVs
dFxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlc29sdmVUeXBlKG5hbWUpIHtcbiAgICAgIGlmIChs
b2NhbE1hcFtuYW1lXSkgcmV0dXJuIGxvY2FsTWFwW25hbWVdLnZ0eXBlO1xuICAgICAgaWYgKGds
b2JhbEluZGV4W25hbWVdICE9PSB1bmRlZmluZWQpIHJldHVybiBnbG9iYWxzW2dsb2JhbEluZGV4
W25hbWVdXS52dHlwZTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9u
IGluZmVyRXhwclR5cGUoZXhwcikge1xuICAgICAgc3dpdGNoIChleHByLnR5cGUpIHtcbiAgICAg
ICAgY2FzZSAnTnVtYmVyTGl0Jzoge1xuICAgICAgICAgIGlmIChleHByLnR5cGVTdWZmaXgpIHJl
dHVybiBleHByLnR5cGVTdWZmaXg7XG4gICAgICAgICAgaWYgKGV4cHIuaXNGbG9hdCB8fCBleHBy
LnZhbHVlLmluY2x1ZGVzKCcuJykgfHwgZXhwci52YWx1ZS5pbmNsdWRlcygnZScpIHx8IGV4cHIu
dmFsdWUuaW5jbHVkZXMoJ0UnKSkgcmV0dXJuICdmNjQnO1xuICAgICAgICAgIHJldHVybiAnaTMy
JztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdJZGVudCc6IHJldHVybiByZXNvbHZlVHlwZShl
eHByLm5hbWUpIHx8ICh0YWJsZVNsb3RbZXhwci5uYW1lXSAhPT0gdW5kZWZpbmVkID8gJ2kzMicg
OiBudWxsKSB8fCAnZjY0JztcbiAgICAgICAgY2FzZSAnQmluT3AnOiByZXR1cm4gaW5mZXJFeHBy
VHlwZShleHByLmxlZnQpO1xuICAgICAgICBjYXNlICdVbmFyeU9wJzogcmV0dXJuIGluZmVyRXhw
clR5cGUoZXhwci5vcGVyYW5kKTtcbiAgICAgICAgY2FzZSAnRnVuY0NhbGwnOiB7XG4gICAgICAg
ICAgLy8gdHlwZSBjb252ZXJzaW9ucyAvIHZlY3RvciBjb25zdHJ1Y3RvcnNcbiAgICAgICAgICBp
ZiAoQVRSQV9UWVBFUy5oYXMoZXhwci5uYW1lKSkgcmV0dXJuIGV4cHIubmFtZTtcbiAgICAgICAg
ICAvLyBTSU1EIG5hbWVzcGFjZWQgYnVpbHRpbnNcbiAgICAgICAgICBjb25zdCBkb3RJZHggPSBl
eHByLm5hbWUuaW5kZXhPZignLicpO1xuICAgICAgICAgIGlmIChkb3RJZHggIT09IC0xKSB7XG4g
ICAgICAgICAgICBjb25zdCBwcmVmaXggPSBleHByLm5hbWUuc2xpY2UoMCwgZG90SWR4KTtcbiAg
ICAgICAgICAgIGNvbnN0IG1ldGhvZCA9IGV4cHIubmFtZS5zbGljZShkb3RJZHggKyAxKTtcbiAg
ICAgICAgICAgIGlmIChpc1ZlY3RvcihwcmVmaXgpKSB7XG4gICAgICAgICAgICAgIC8vIGV4dHJh
Y3RfbGFuZSByZXR1cm5zIHRoZSBzY2FsYXIgdHlwZVxuICAgICAgICAgICAgICBpZiAobWV0aG9k
ID09PSAnZXh0cmFjdF9sYW5lJykgcmV0dXJuIHZlY3RvclNjYWxhclR5cGUocHJlZml4KTtcbiAg
ICAgICAgICAgICAgLy8gc3BsYXQsIHJlcGxhY2VfbGFuZSwgYWRkLCBzdWIsIG11bCwgZGl2LCBu
ZWcsIGFicywgc3FydCwgZXEsIGV0Yy4gcmV0dXJuIHRoZSB2ZWN0b3IgdHlwZVxuICAgICAgICAg
ICAgICByZXR1cm4gcHJlZml4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByZWZp
eCA9PT0gJ3YxMjgnKSB7XG4gICAgICAgICAgICAgIC8vIHYxMjguYW5kL29yL3hvci9ub3QvbG9h
ZCByZXR1cm4gdjEyOCDigJQgaW5mZXIgZnJvbSBmaXJzdCBhcmdcbiAgICAgICAgICAgICAgaWYg
KG1ldGhvZCA9PT0gJ2xvYWQnKSByZXR1cm4gaW5mZXJFeHByVHlwZShleHByLmFyZ3NbMF0pIHx8
ICdmNjR4Mic7IC8vIGRlZmF1bHQgdG8gZjY0eDJcbiAgICAgICAgICAgICAgaWYgKFsnYW5kJywn
b3InLCd4b3InLCdub3QnXS5pbmNsdWRlcyhtZXRob2QpKSByZXR1cm4gaW5mZXJFeHByVHlwZShl
eHByLmFyZ3NbMF0pO1xuICAgICAgICAgICAgICBpZiAobWV0aG9kID09PSAnc3RvcmUnKSByZXR1
cm4gJ2kzMic7IC8vIHN0b3JlIGlzIGEgc3RhdGVtZW50LCBidXQgdHlwZSBkb2Vzbid0IG1hdHRl
ciBtdWNoXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIEluZGlyZWN0
IGNhbGwgdmlhIGZ1bmN0aW9uLXR5cGVkIHZhcmlhYmxlXG4gICAgICAgICAgY29uc3QgY2FsbElu
Zm8gPSBsb2NhbE1hcFtleHByLm5hbWVdO1xuICAgICAgICAgIGlmIChjYWxsSW5mbyAmJiBjYWxs
SW5mby5mdW5jU2lnICYmIGNhbGxJbmZvLmZ1bmNTaWcucmV0VHlwZSkgcmV0dXJuIGNhbGxJbmZv
LmZ1bmNTaWcucmV0VHlwZTtcbiAgICAgICAgICBpZiAoZ2xvYmFsRnVuY1NpZ1tleHByLm5hbWVd
ICYmIGdsb2JhbEZ1bmNTaWdbZXhwci5uYW1lXS5yZXRUeXBlKSByZXR1cm4gZ2xvYmFsRnVuY1Np
Z1tleHByLm5hbWVdLnJldFR5cGU7XG4gICAgICAgICAgLy8ga25vd24gcmV0dXJuIHR5cGVzXG4g
ICAgICAgICAgY29uc3QgZm4gPSBmdW5jdGlvbnMuZmluZChmID0+IGYubmFtZSA9PT0gZXhwci5u
YW1lKTtcbiAgICAgICAgICBpZiAoZm4gJiYgZm4ucmV0VHlwZSkgcmV0dXJuIGZuLnJldFR5cGU7
XG4gICAgICAgICAgcmV0dXJuICdmNjQnO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ0FycmF5
QWNjZXNzJzoge1xuICAgICAgICAgIGNvbnN0IGluZm8gPSBsb2NhbE1hcFtleHByLm5hbWVdO1xu
ICAgICAgICAgIHJldHVybiBpbmZvID8gKGluZm8uZWxlbVR5cGUgfHwgaW5mby52dHlwZSkgOiAn
ZjY0JztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdJZkV4cHInOiByZXR1cm4gaW5mZXJFeHBy
VHlwZShleHByLnRoZW5FeHByKTtcbiAgICAgICAgZGVmYXVsdDogcmV0dXJuICdmNjQnO1xuICAg
ICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVtaXRFeHByKGV4cHIsIGV4cGVjdGVkVHlwZSkg
e1xuICAgICAgY29uc3QgYWN0dWFsVHlwZSA9IGV4cGVjdGVkVHlwZSB8fCBpbmZlckV4cHJUeXBl
KGV4cHIpO1xuXG4gICAgICBzd2l0Y2ggKGV4cHIudHlwZSkge1xuICAgICAgICBjYXNlICdOdW1i
ZXJMaXQnOiB7XG4gICAgICAgICAgY29uc3QgdCA9IGV4cGVjdGVkVHlwZSB8fCBpbmZlckV4cHJU
eXBlKGV4cHIpO1xuICAgICAgICAgIGNvbnN0IHJhdyA9IGV4cHIudmFsdWU7XG4gICAgICAgICAg
aWYgKHQgPT09ICdpMzInKSB7IGJ3LmJ5dGUoT1BfSTMyX0NPTlNUKTsgYncuczMyKHBhcnNlSW50
KHJhdywgMTApIHwgMCk7IH1cbiAgICAgICAgICBlbHNlIGlmICh0ID09PSAnaTY0JykgeyBidy5i
eXRlKE9QX0k2NF9DT05TVCk7IGJ3LnM2NChCaWdJbnQocGFyc2VJbnQocmF3LCAxMCkpKTsgfVxu
ICAgICAgICAgIGVsc2UgaWYgKHQgPT09ICdmMzInKSB7IGJ3LmJ5dGUoT1BfRjMyX0NPTlNUKTsg
YncuZjMyKHBhcnNlRmxvYXQocmF3KSk7IH1cbiAgICAgICAgICBlbHNlIHsgYncuYnl0ZShPUF9G
NjRfQ09OU1QpOyBidy5mNjQocGFyc2VGbG9hdChyYXcpKTsgfVxuICAgICAgICAgIGJyZWFrO1xu
ICAgICAgICB9XG4gICAgICAgIGNhc2UgJ0lkZW50Jzoge1xuICAgICAgICAgIGNvbnN0IG5hbWUg
PSBleHByLm5hbWU7XG4gICAgICAgICAgaWYgKGxvY2FsTWFwW25hbWVdKSB7IGJ3LmJ5dGUoT1Bf
TE9DQUxfR0VUKTsgYncudTMyKGxvY2FsTWFwW25hbWVdLmlkeCk7IH1cbiAgICAgICAgICBlbHNl
IGlmIChnbG9iYWxJbmRleFtuYW1lXSAhPT0gdW5kZWZpbmVkKSB7IGJ3LmJ5dGUoT1BfR0xPQkFM
X0dFVCk7IGJ3LnUzMihnbG9iYWxJbmRleFtuYW1lXSk7IH1cbiAgICAgICAgICBlbHNlIGlmICh0
YWJsZVNsb3RbbmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gQmFyZSBmdW5j
dGlvbiBuYW1lIOKGkiB0YWJsZSBpbmRleCAoZm9yIGNhbGxfaW5kaXJlY3QpXG4gICAgICAgICAg
ICBidy5ieXRlKE9QX0kzMl9DT05TVCk7IGJ3LnMzMih0YWJsZVNsb3RbbmFtZV0pO1xuICAgICAg
ICAgIH1cbiAgICAgICAgICBlbHNlIHRocm93IG5ldyBFcnJvcihgVW5kZWZpbmVkIHZhcmlhYmxl
OiAke25hbWV9YCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAn
QmluT3AnOiB7XG4gICAgICAgICAgY29uc3QgdCA9IGV4cGVjdGVkVHlwZSB8fCBpbmZlckV4cHJU
eXBlKGV4cHIpO1xuICAgICAgICAgIGVtaXRCaW5PcChleHByLCB0KTtcbiAgICAgICAgICBicmVh
aztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdVbmFyeU9wJzoge1xuICAgICAgICAgIGNvbnN0
IHQgPSBleHBlY3RlZFR5cGUgfHwgaW5mZXJFeHByVHlwZShleHByKTtcbiAgICAgICAgICBpZiAo
ZXhwci5vcCA9PT0gJy0nKSB7XG4gICAgICAgICAgICBpZiAodCA9PT0gJ2Y2NCcpIHsgZW1pdEV4
cHIoZXhwci5vcGVyYW5kLCB0KTsgYncuYnl0ZShPUF9GNjRfTkVHKTsgfVxuICAgICAgICAgICAg
ZWxzZSBpZiAodCA9PT0gJ2YzMicpIHsgZW1pdEV4cHIoZXhwci5vcGVyYW5kLCB0KTsgYncuYnl0
ZShPUF9GMzJfTkVHKTsgfVxuICAgICAgICAgICAgZWxzZSBpZiAodCA9PT0gJ2kzMicpIHsgYncu
Ynl0ZShPUF9JMzJfQ09OU1QpOyBidy5zMzIoMCk7IGVtaXRFeHByKGV4cHIub3BlcmFuZCwgdCk7
IGJ3LmJ5dGUoT1BfSTMyX1NVQik7IH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHQgPT09ICdpNjQn
KSB7IGJ3LmJ5dGUoT1BfSTY0X0NPTlNUKTsgYncuczY0KDBuKTsgZW1pdEV4cHIoZXhwci5vcGVy
YW5kLCB0KTsgYncuYnl0ZShPUF9JNjRfU1VCKTsgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNW
ZWN0b3IodCkpIHsgZW1pdEV4cHIoZXhwci5vcGVyYW5kLCB0KTsgZW1pdFNpbWQoU0lNRF9PUFNb
dCArICcubmVnJ10pOyB9XG4gICAgICAgICAgfSBlbHNlIGlmIChleHByLm9wID09PSAnbm90Jykg
e1xuICAgICAgICAgICAgZW1pdEV4cHIoZXhwci5vcGVyYW5kLCAnaTMyJyk7XG4gICAgICAgICAg
ICBidy5ieXRlKE9QX0kzMl9FUVopO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZXhwci5vcCA9PT0g
J34nKSB7XG4gICAgICAgICAgICBlbWl0RXhwcihleHByLm9wZXJhbmQsIHQpO1xuICAgICAgICAg
ICAgaWYgKHQgPT09ICdpMzInKSB7IGJ3LmJ5dGUoT1BfSTMyX0NPTlNUKTsgYncuczMyKC0xKTsg
YncuYnl0ZShPUF9JMzJfWE9SKTsgfVxuICAgICAgICAgICAgZWxzZSBpZiAodCA9PT0gJ2k2NCcp
IHsgYncuYnl0ZShPUF9JNjRfQ09OU1QpOyBidy5zNjQoLTFuKTsgYncuYnl0ZShPUF9JNjRfWE9S
KTsgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbWl0RXhwcihleHByLm9wZXJh
bmQsIHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAg
ICBjYXNlICdGdW5jQ2FsbCc6IHtcbiAgICAgICAgICBlbWl0RnVuY0NhbGwoZXhwciwgZXhwZWN0
ZWRUeXBlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdBcnJh
eUFjY2Vzcyc6IHtcbiAgICAgICAgICBjb25zdCBpbmZvID0gbG9jYWxNYXBbZXhwci5uYW1lXTtc
biAgICAgICAgICBpZiAoIWluZm8pIHRocm93IG5ldyBFcnJvcihgVW5kZWZpbmVkIGFycmF5OiAk
e2V4cHIubmFtZX1gKTtcbiAgICAgICAgICBjb25zdCBlbGVtVHlwZSA9IGluZm8uZWxlbVR5cGUg
fHwgaW5mby52dHlwZTtcbiAgICAgICAgICBlbWl0QXJyYXlBZGRyKGV4cHIubmFtZSwgZXhwci5p
bmRpY2VzLCBpbmZvLCBlbGVtVHlwZSk7XG4gICAgICAgICAgZW1pdExvYWQoZWxlbVR5cGUpO1xu
ICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ0lmRXhwcic6IHtcbiAg
ICAgICAgICBjb25zdCB0ID0gZXhwZWN0ZWRUeXBlIHx8IGluZmVyRXhwclR5cGUoZXhwci50aGVu
RXhwcik7XG4gICAgICAgICAgZW1pdEV4cHIoZXhwci5jb25kLCAnaTMyJyk7XG4gICAgICAgICAg
YncuYnl0ZShPUF9JRik7XG4gICAgICAgICAgYncuYnl0ZSh3YXNtVHlwZSh0KSk7XG4gICAgICAg
ICAgZW1pdEV4cHIoZXhwci50aGVuRXhwciwgdCk7XG4gICAgICAgICAgYncuYnl0ZShPUF9FTFNF
KTtcbiAgICAgICAgICBlbWl0RXhwcihleHByLmVsc2VFeHByLCB0KTtcbiAgICAgICAgICBidy5i
eXRlKE9QX0VORCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVs
dDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gZXhwcmVzc2lvbiB0eXBlOiAk
e2V4cHIudHlwZX1gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlbWl0QmluT3Ao
ZXhwciwgdCkge1xuICAgICAgY29uc3Qgb3AgPSBleHByLm9wO1xuXG4gICAgICAvLyBFeHBvbmVu
dGlhdGlvblxuICAgICAgaWYgKG9wID09PSAnKionKSB7XG4gICAgICAgIGVtaXRQb3coZXhwciwg
dCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gQ29tcGFyaXNvbiBvcGVy
YXRvcnMgcmV0dXJuIGkzMlxuICAgICAgaWYgKG9wID09PSAnPT0nIHx8IG9wID09PSAnLz0nIHx8
IG9wID09PSAnPCcgfHwgb3AgPT09ICc+JyB8fCBvcCA9PT0gJzw9JyB8fCBvcCA9PT0gJz49Jykg
e1xuICAgICAgICBjb25zdCBvcGVyYW5kVHlwZSA9IGluZmVyRXhwclR5cGUoZXhwci5sZWZ0KTtc
biAgICAgICAgZW1pdEV4cHIoZXhwci5sZWZ0LCBvcGVyYW5kVHlwZSk7XG4gICAgICAgIGVtaXRF
eHByKGV4cHIucmlnaHQsIG9wZXJhbmRUeXBlKTtcbiAgICAgICAgZW1pdENtcChvcCwgb3BlcmFu
ZFR5cGUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIExvZ2ljYWw6IGFu
ZCwgb3JcbiAgICAgIGlmIChvcCA9PT0gJ2FuZCcpIHtcbiAgICAgICAgZW1pdEV4cHIoZXhwci5s
ZWZ0LCAnaTMyJyk7XG4gICAgICAgIGVtaXRFeHByKGV4cHIucmlnaHQsICdpMzInKTtcbiAgICAg
ICAgYncuYnl0ZShPUF9JMzJfQU5EKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAg
aWYgKG9wID09PSAnb3InKSB7XG4gICAgICAgIGVtaXRFeHByKGV4cHIubGVmdCwgJ2kzMicpO1xu
ICAgICAgICBlbWl0RXhwcihleHByLnJpZ2h0LCAnaTMyJyk7XG4gICAgICAgIGJ3LmJ5dGUoT1Bf
STMyX09SKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBlbWl0RXhwcihleHBy
LmxlZnQsIHQpO1xuICAgICAgZW1pdEV4cHIoZXhwci5yaWdodCwgdCk7XG5cbiAgICAgIGlmIChv
cCA9PT0gJysnKSBlbWl0QWRkKHQpO1xuICAgICAgZWxzZSBpZiAob3AgPT09ICctJykgZW1pdFN1
Yih0KTtcbiAgICAgIGVsc2UgaWYgKG9wID09PSAnKicpIGVtaXRNdWwodCk7XG4gICAgICBlbHNl
IGlmIChvcCA9PT0gJy8nKSBlbWl0RGl2KHQpO1xuICAgICAgZWxzZSBpZiAob3AgPT09ICdtb2Qn
KSB7XG4gICAgICAgIGlmICh0ID09PSAnaTMyJykgYncuYnl0ZShPUF9JMzJfUkVNX1MpO1xuICAg
ICAgICBlbHNlIGlmICh0ID09PSAnaTY0JykgYncuYnl0ZShPUF9JNjRfUkVNX1MpO1xuICAgICAg
ICBlbHNlIHRocm93IG5ldyBFcnJvcignbW9kIHJlcXVpcmVzIGludGVnZXIgdHlwZScpO1xuICAg
ICAgfVxuICAgICAgZWxzZSBpZiAob3AgPT09ICcmJykgeyBpZiAodCA9PT0gJ2kzMicpIGJ3LmJ5
dGUoT1BfSTMyX0FORCk7IGVsc2UgYncuYnl0ZShPUF9JNjRfQU5EKTsgfVxuICAgICAgZWxzZSBp
ZiAob3AgPT09ICd8JykgeyBpZiAodCA9PT0gJ2kzMicpIGJ3LmJ5dGUoT1BfSTMyX09SKTsgZWxz
ZSBidy5ieXRlKE9QX0k2NF9PUik7IH1cbiAgICAgIGVsc2UgaWYgKG9wID09PSAnXicpIHsgaWYg
KHQgPT09ICdpMzInKSBidy5ieXRlKE9QX0kzMl9YT1IpOyBlbHNlIGJ3LmJ5dGUoT1BfSTY0X1hP
Uik7IH1cbiAgICAgIGVsc2UgaWYgKG9wID09PSAnPDwnKSB7IGlmICh0ID09PSAnaTMyJykgYncu
Ynl0ZShPUF9JMzJfU0hMKTsgZWxzZSBidy5ieXRlKE9QX0k2NF9TSEwpOyB9XG4gICAgICBlbHNl
IGlmIChvcCA9PT0gJz4+JykgeyBpZiAodCA9PT0gJ2kzMicpIGJ3LmJ5dGUoT1BfSTMyX1NIUl9T
KTsgZWxzZSBidy5ieXRlKE9QX0k2NF9TSFJfUyk7IH1cbiAgICAgIGVsc2UgdGhyb3cgbmV3IEVy
cm9yKGBVbmtub3duIG9wZXJhdG9yOiAke29wfWApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVt
aXRQb3coZXhwciwgdCkge1xuICAgICAgLy8gKiowLjUg4oaSIHNxcnRcbiAgICAgIGlmIChleHBy
LnJpZ2h0LnR5cGUgPT09ICdOdW1iZXJMaXQnICYmIChleHByLnJpZ2h0LnZhbHVlID09PSAnMC41
JyB8fCBleHByLnJpZ2h0LnZhbHVlID09PSAnLjUnKSkge1xuICAgICAgICBlbWl0RXhwcihleHBy
LmxlZnQsIHQpO1xuICAgICAgICBpZiAodCA9PT0gJ2Y2NCcpIGJ3LmJ5dGUoT1BfRjY0X1NRUlQp
O1xuICAgICAgICBlbHNlIGlmICh0ID09PSAnZjMyJykgYncuYnl0ZShPUF9GMzJfU1FSVCk7XG4g
ICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIEdlbmVyYWw6IGNhbGwgcG93IGltcG9y
dCAod29ya3MgZm9yIGFsbCBjYXNlcyBpbmNsdWRpbmcgKioyLCAqKjMpXG4gICAgICBlbWl0RXhw
cihleHByLmxlZnQsICdmNjQnKTtcbiAgICAgIGVtaXRFeHByKGV4cHIucmlnaHQsICdmNjQnKTtc
biAgICAgIGJ3LmJ5dGUoT1BfQ0FMTCk7XG4gICAgICBidy51MzIoZnVuY0luZGV4Wydwb3cnXSk7
XG4gICAgICAvLyBDb252ZXJ0IHJlc3VsdCBiYWNrIGlmIG5lZWRlZFxuICAgICAgaWYgKHQgPT09
ICdmMzInKSBidy5ieXRlKE9QX0YzMl9ERU1PVEVfRjY0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlv
biBlbWl0RnVuY0NhbGwoZXhwciwgZXhwZWN0ZWRUeXBlKSB7XG4gICAgICBjb25zdCBuYW1lID0g
ZXhwci5uYW1lO1xuXG4gICAgICAvLyBWZWN0b3IgY29uc3RydWN0b3JzOiBmNjR4MihhLCBiKSwg
ZjMyeDQoYSwgYiwgYywgZCksIGV0Yy5cbiAgICAgIGlmIChpc1ZlY3RvcihuYW1lKSkge1xuICAg
ICAgICBlbWl0VmVjdG9yQ29uc3RydWN0b3IobmFtZSwgZXhwci5hcmdzKTtcbiAgICAgICAgcmV0
dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBTY2FsYXIgdHlwZSBjb252ZXJzaW9uczogaTMyKHgp
LCBmNjQoeCksIGV0Yy5cbiAgICAgIGlmIChBVFJBX1RZUEVTLmhhcyhuYW1lKSkge1xuICAgICAg
ICBjb25zdCBmcm9tVHlwZSA9IGluZmVyRXhwclR5cGUoZXhwci5hcmdzWzBdKTtcbiAgICAgICAg
Y29uc3QgdG9UeXBlID0gbmFtZTtcbiAgICAgICAgZW1pdEV4cHIoZXhwci5hcmdzWzBdLCBmcm9t
VHlwZSk7XG4gICAgICAgIGVtaXRDb252ZXJzaW9uKGZyb21UeXBlLCB0b1R5cGUpO1xuICAgICAg
ICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFNJTUQgbmFtZXNwYWNlZCBidWlsdGluczog
ZjY0eDIuc3BsYXQsIHYxMjguYW5kLCBldGMuXG4gICAgICBjb25zdCBkb3RJZHggPSBuYW1lLmlu
ZGV4T2YoJy4nKTtcbiAgICAgIGlmIChkb3RJZHggIT09IC0xKSB7XG4gICAgICAgIGNvbnN0IHBy
ZWZpeCA9IG5hbWUuc2xpY2UoMCwgZG90SWR4KTtcbiAgICAgICAgY29uc3QgbWV0aG9kID0gbmFt
ZS5zbGljZShkb3RJZHggKyAxKTtcbiAgICAgICAgaWYgKGlzVmVjdG9yKHByZWZpeCkgfHwgcHJl
Zml4ID09PSAndjEyOCcpIHtcbiAgICAgICAgICBlbWl0U2ltZEJ1aWx0aW4ocHJlZml4LCBtZXRo
b2QsIGV4cHIsIGV4cGVjdGVkVHlwZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4g
ICAgICB9XG5cbiAgICAgIC8vIE5hdGl2ZSBidWlsdGlucyDigJQgd2l0aCB2ZWN0b3IgdHlwZSBz
dXBwb3J0XG4gICAgICBpZiAobmFtZSA9PT0gJ3NxcnQnKSB7XG4gICAgICAgIGVtaXRFeHByKGV4
cHIuYXJnc1swXSwgZXhwZWN0ZWRUeXBlKTtcbiAgICAgICAgaWYgKGlzVmVjdG9yKGV4cGVjdGVk
VHlwZSkpIHsgY29uc3Qgb3AgPSBTSU1EX09QU1tleHBlY3RlZFR5cGUgKyAnLnNxcnQnXTsgaWYg
KG9wID09PSB1bmRlZmluZWQpIHRocm93IG5ldyBFcnJvcignc3FydCBub3Qgc3VwcG9ydGVkIGZv
ciAnICsgZXhwZWN0ZWRUeXBlKTsgZW1pdFNpbWQob3ApOyB9XG4gICAgICAgIGVsc2UgaWYgKGV4
cGVjdGVkVHlwZSA9PT0gJ2YzMicpIGJ3LmJ5dGUoT1BfRjMyX1NRUlQpO1xuICAgICAgICBlbHNl
IGJ3LmJ5dGUoT1BfRjY0X1NRUlQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBp
ZiAobmFtZSA9PT0gJ2FicycpIHtcbiAgICAgICAgZW1pdEV4cHIoZXhwci5hcmdzWzBdLCBleHBl
Y3RlZFR5cGUpO1xuICAgICAgICBpZiAoaXNWZWN0b3IoZXhwZWN0ZWRUeXBlKSkgeyBjb25zdCBv
cCA9IFNJTURfT1BTW2V4cGVjdGVkVHlwZSArICcuYWJzJ107IGlmIChvcCA9PT0gdW5kZWZpbmVk
KSB0aHJvdyBuZXcgRXJyb3IoJ2FicyBub3Qgc3VwcG9ydGVkIGZvciAnICsgZXhwZWN0ZWRUeXBl
KTsgZW1pdFNpbWQob3ApOyB9XG4gICAgICAgIGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gJ2Yz
MicpIGJ3LmJ5dGUoT1BfRjMyX0FCUyk7XG4gICAgICAgIGVsc2UgYncuYnl0ZShPUF9GNjRfQUJT
KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKG5hbWUgPT09ICdmbG9vcicp
IHsgZW1pdEV4cHIoZXhwci5hcmdzWzBdLCBleHBlY3RlZFR5cGUpOyBpZiAoZXhwZWN0ZWRUeXBl
ID09PSAnZjMyJykgYncuYnl0ZShPUF9GMzJfRkxPT1IpOyBlbHNlIGJ3LmJ5dGUoT1BfRjY0X0ZM
T09SKTsgcmV0dXJuOyB9XG4gICAgICBpZiAobmFtZSA9PT0gJ2NlaWwnKSB7IGVtaXRFeHByKGV4
cHIuYXJnc1swXSwgZXhwZWN0ZWRUeXBlKTsgaWYgKGV4cGVjdGVkVHlwZSA9PT0gJ2YzMicpIGJ3
LmJ5dGUoT1BfRjMyX0NFSUwpOyBlbHNlIGJ3LmJ5dGUoT1BfRjY0X0NFSUwpOyByZXR1cm47IH1c
biAgICAgIGlmIChuYW1lID09PSAndHJ1bmMnKSB7IGVtaXRFeHByKGV4cHIuYXJnc1swXSwgZXhw
ZWN0ZWRUeXBlKTsgaWYgKGV4cGVjdGVkVHlwZSA9PT0gJ2YzMicpIGJ3LmJ5dGUoT1BfRjMyX1RS
VU5DKTsgZWxzZSBidy5ieXRlKE9QX0Y2NF9UUlVOQyk7IHJldHVybjsgfVxuICAgICAgaWYgKG5h
bWUgPT09ICduZWFyZXN0JykgeyBlbWl0RXhwcihleHByLmFyZ3NbMF0sIGV4cGVjdGVkVHlwZSk7
IGlmIChleHBlY3RlZFR5cGUgPT09ICdmMzInKSBidy5ieXRlKE9QX0YzMl9ORUFSRVNUKTsgZWxz
ZSBidy5ieXRlKE9QX0Y2NF9ORUFSRVNUKTsgcmV0dXJuOyB9XG4gICAgICBpZiAobmFtZSA9PT0g
J21pbicpIHtcbiAgICAgICAgZW1pdEV4cHIoZXhwci5hcmdzWzBdLCBleHBlY3RlZFR5cGUpOyBl
bWl0RXhwcihleHByLmFyZ3NbMV0sIGV4cGVjdGVkVHlwZSk7XG4gICAgICAgIGlmIChpc1ZlY3Rv
cihleHBlY3RlZFR5cGUpKSB7IGNvbnN0IG9wID0gU0lNRF9PUFNbZXhwZWN0ZWRUeXBlICsgJy5t
aW4nXTsgaWYgKG9wID09PSB1bmRlZmluZWQpIHRocm93IG5ldyBFcnJvcignbWluIG5vdCBzdXBw
b3J0ZWQgZm9yICcgKyBleHBlY3RlZFR5cGUpOyBlbWl0U2ltZChvcCk7IH1cbiAgICAgICAgZWxz
ZSBpZiAoZXhwZWN0ZWRUeXBlID09PSAnZjMyJykgYncuYnl0ZShPUF9GMzJfTUlOKTtcbiAgICAg
ICAgZWxzZSBidy5ieXRlKE9QX0Y2NF9NSU4pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4g
ICAgICBpZiAobmFtZSA9PT0gJ21heCcpIHtcbiAgICAgICAgZW1pdEV4cHIoZXhwci5hcmdzWzBd
LCBleHBlY3RlZFR5cGUpOyBlbWl0RXhwcihleHByLmFyZ3NbMV0sIGV4cGVjdGVkVHlwZSk7XG4g
ICAgICAgIGlmIChpc1ZlY3RvcihleHBlY3RlZFR5cGUpKSB7IGNvbnN0IG9wID0gU0lNRF9PUFNb
ZXhwZWN0ZWRUeXBlICsgJy5tYXgnXTsgaWYgKG9wID09PSB1bmRlZmluZWQpIHRocm93IG5ldyBF
cnJvcignbWF4IG5vdCBzdXBwb3J0ZWQgZm9yICcgKyBleHBlY3RlZFR5cGUpOyBlbWl0U2ltZChv
cCk7IH1cbiAgICAgICAgZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSAnZjMyJykgYncuYnl0ZShP
UF9GMzJfTUFYKTtcbiAgICAgICAgZWxzZSBidy5ieXRlKE9QX0Y2NF9NQVgpO1xuICAgICAgICBy
ZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAobmFtZSA9PT0gJ2NvcHlzaWduJykgeyBlbWl0RXhw
cihleHByLmFyZ3NbMF0sIGV4cGVjdGVkVHlwZSk7IGVtaXRFeHByKGV4cHIuYXJnc1sxXSwgZXhw
ZWN0ZWRUeXBlKTsgaWYgKGV4cGVjdGVkVHlwZSA9PT0gJ2YzMicpIGJ3LmJ5dGUoT1BfRjMyX0NP
UFlTSUdOKTsgZWxzZSBidy5ieXRlKE9QX0Y2NF9DT1BZU0lHTik7IHJldHVybjsgfVxuICAgICAg
aWYgKG5hbWUgPT09ICdzZWxlY3QnKSB7XG4gICAgICAgIC8vIHNlbGVjdChhLCBiLCBjb25kKSDi
gJQgV2FzbSBzZWxlY3QgcGlja3MgYSBpZiBjb25kIT0wLCBiIG90aGVyd2lzZVxuICAgICAgICBj
b25zdCB0ID0gZXhwZWN0ZWRUeXBlIHx8IGluZmVyRXhwclR5cGUoZXhwci5hcmdzWzBdKTtcbiAg
ICAgICAgZW1pdEV4cHIoZXhwci5hcmdzWzBdLCB0KTtcbiAgICAgICAgZW1pdEV4cHIoZXhwci5h
cmdzWzFdLCB0KTtcbiAgICAgICAgZW1pdEV4cHIoZXhwci5hcmdzWzJdLCAnaTMyJyk7XG4gICAg
ICAgIGJ3LmJ5dGUoT1BfU0VMRUNUKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAg
aWYgKG5hbWUgPT09ICdjbHonKSB7IGVtaXRFeHByKGV4cHIuYXJnc1swXSwgZXhwZWN0ZWRUeXBl
KTsgaWYgKGV4cGVjdGVkVHlwZSA9PT0gJ2k2NCcpIGJ3LmJ5dGUoT1BfSTY0X0NMWik7IGVsc2Ug
YncuYnl0ZShPUF9JMzJfQ0xaKTsgcmV0dXJuOyB9XG4gICAgICBpZiAobmFtZSA9PT0gJ2N0eicp
IHsgZW1pdEV4cHIoZXhwci5hcmdzWzBdLCBleHBlY3RlZFR5cGUpOyBpZiAoZXhwZWN0ZWRUeXBl
ID09PSAnaTY0JykgYncuYnl0ZShPUF9JNjRfQ1RaKTsgZWxzZSBidy5ieXRlKE9QX0kzMl9DVFop
OyByZXR1cm47IH1cbiAgICAgIGlmIChuYW1lID09PSAncG9wY250JykgeyBlbWl0RXhwcihleHBy
LmFyZ3NbMF0sIGV4cGVjdGVkVHlwZSk7IGlmIChleHBlY3RlZFR5cGUgPT09ICdpNjQnKSBidy5i
eXRlKE9QX0k2NF9QT1BDTlQpOyBlbHNlIGJ3LmJ5dGUoT1BfSTMyX1BPUENOVCk7IHJldHVybjsg
fVxuICAgICAgaWYgKG5hbWUgPT09ICdyb3RsJykgeyBlbWl0RXhwcihleHByLmFyZ3NbMF0sIGV4
cGVjdGVkVHlwZSk7IGVtaXRFeHByKGV4cHIuYXJnc1sxXSwgZXhwZWN0ZWRUeXBlKTsgaWYgKGV4
cGVjdGVkVHlwZSA9PT0gJ2k2NCcpIGJ3LmJ5dGUoT1BfSTY0X1JPVEwpOyBlbHNlIGJ3LmJ5dGUo
T1BfSTMyX1JPVEwpOyByZXR1cm47IH1cbiAgICAgIGlmIChuYW1lID09PSAncm90cicpIHsgZW1p
dEV4cHIoZXhwci5hcmdzWzBdLCBleHBlY3RlZFR5cGUpOyBlbWl0RXhwcihleHByLmFyZ3NbMV0s
IGV4cGVjdGVkVHlwZSk7IGlmIChleHBlY3RlZFR5cGUgPT09ICdpNjQnKSBidy5ieXRlKE9QX0k2
NF9ST1RSKTsgZWxzZSBidy5ieXRlKE9QX0kzMl9ST1RSKTsgcmV0dXJuOyB9XG4gICAgICBpZiAo
bmFtZSA9PT0gJ21lbW9yeV9zaXplJykgeyBidy5ieXRlKE9QX01FTU9SWV9TSVpFKTsgYncudTMy
KDApOyByZXR1cm47IH1cbiAgICAgIGlmIChuYW1lID09PSAnbWVtb3J5X2dyb3cnKSB7IGVtaXRF
eHByKGV4cHIuYXJnc1swXSwgJ2kzMicpOyBidy5ieXRlKE9QX01FTU9SWV9HUk9XKTsgYncudTMy
KDApOyByZXR1cm47IH1cbiAgICAgIGlmIChuYW1lID09PSAnbWVtb3J5X2NvcHknKSB7XG4gICAg
ICAgIGVtaXRFeHByKGV4cHIuYXJnc1swXSwgJ2kzMicpOyBlbWl0RXhwcihleHByLmFyZ3NbMV0s
ICdpMzInKTsgZW1pdEV4cHIoZXhwci5hcmdzWzJdLCAnaTMyJyk7XG4gICAgICAgIGJ3LmJ5dGUo
T1BfRkNfUFJFRklYKTsgYncudTMyKDEwKTsgYncudTMyKDApOyBidy51MzIoMCk7IC8vIG1lbW9y
eS5jb3B5LCBkc3RfbWVtPTAsIHNyY19tZW09MFxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4g
ICAgICBpZiAobmFtZSA9PT0gJ21lbW9yeV9maWxsJykge1xuICAgICAgICBlbWl0RXhwcihleHBy
LmFyZ3NbMF0sICdpMzInKTsgZW1pdEV4cHIoZXhwci5hcmdzWzFdLCAnaTMyJyk7IGVtaXRFeHBy
KGV4cHIuYXJnc1syXSwgJ2kzMicpO1xuICAgICAgICBidy5ieXRlKE9QX0ZDX1BSRUZJWCk7IGJ3
LnUzMigxMSk7IGJ3LnUzMigwKTsgLy8gbWVtb3J5LmZpbGwsIG1lbT0wXG4gICAgICAgIHJldHVy
bjtcbiAgICAgIH1cblxuICAgICAgLy8gd2FzbS4qIGVzY2FwZSBoYXRjaFxuICAgICAgaWYgKG5h
bWUuc3RhcnRzV2l0aCgnd2FzbS4nKSkge1xuICAgICAgICBlbWl0V2FzbUJ1aWx0aW4obmFtZS5z
bGljZSg1KSwgZXhwciwgZXhwZWN0ZWRUeXBlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxu
XG4gICAgICAvLyBJbmRpcmVjdCBjYWxsIHZpYSBmdW5jdGlvbi10eXBlZCB2YXJpYWJsZVxuICAg
ICAgY29uc3QgbG9jYWxJbmZvID0gbG9jYWxNYXBbbmFtZV07XG4gICAgICBjb25zdCBnU2lnID0g
Z2xvYmFsRnVuY1NpZ1tuYW1lXTtcbiAgICAgIGlmICgobG9jYWxJbmZvICYmIGxvY2FsSW5mby5m
dW5jU2lnKSB8fCBnU2lnKSB7XG4gICAgICAgIGNvbnN0IHNpZyA9IChsb2NhbEluZm8gJiYgbG9j
YWxJbmZvLmZ1bmNTaWcpIHx8IGdTaWc7XG4gICAgICAgIC8vIEVtaXQgYXJndW1lbnRzIHVzaW5n
IGZ1bmNTaWcgcGFyYW0gdHlwZXNcbiAgICAgICAgZm9yIChsZXQgYWkgPSAwOyBhaSA8IGV4cHIu
YXJncy5sZW5ndGg7IGFpKyspIHtcbiAgICAgICAgICBjb25zdCBwdCA9IHNpZy5wYXJhbXNbYWld
ID8gKHNpZy5wYXJhbXNbYWldLmlzQXJyYXkgPyAnaTMyJyA6IHNpZy5wYXJhbXNbYWldLnZ0eXBl
KSA6ICdmNjQnO1xuICAgICAgICAgIGVtaXRFeHByKGV4cHIuYXJnc1thaV0sIHB0KTtcbiAgICAg
ICAgfVxuICAgICAgICAvLyBQdXNoIHRoZSB0YWJsZSBpbmRleCAodGhlIHZhcmlhYmxlIHZhbHVl
KVxuICAgICAgICBpZiAobG9jYWxJbmZvKSB7IGJ3LmJ5dGUoT1BfTE9DQUxfR0VUKTsgYncudTMy
KGxvY2FsSW5mby5pZHgpOyB9XG4gICAgICAgIGVsc2UgeyBidy5ieXRlKE9QX0dMT0JBTF9HRVQp
OyBidy51MzIoZ2xvYmFsSW5kZXhbbmFtZV0pOyB9XG4gICAgICAgIC8vIGNhbGxfaW5kaXJlY3Qg
dHlwZV9pbmRleCB0YWJsZV9pbmRleFxuICAgICAgICBjb25zdCBpbmRpcmVjdFNpZ0lkID0gZ2V0
T3JBZGRTaWcoc2lnLnBhcmFtcywgc2lnLnJldFR5cGUpO1xuICAgICAgICBidy5ieXRlKE9QX0NB
TExfSU5ESVJFQ1QpO1xuICAgICAgICBidy51MzIoaW5kaXJlY3RTaWdJZCk7XG4gICAgICAgIGJ3
LnUzMigwKTsgLy8gdGFibGUgaW5kZXggMFxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAg
ICAgIC8vIFJlZ3VsYXIgZnVuY3Rpb24gY2FsbFxuICAgICAgY29uc3QgZklkeCA9IGZ1bmNJbmRl
eFtuYW1lXTtcbiAgICAgIGlmIChmSWR4ID09PSB1bmRlZmluZWQpIHRocm93IG5ldyBFcnJvcihg
VW5kZWZpbmVkIGZ1bmN0aW9uOiAke25hbWV9YCk7XG4gICAgICBmb3IgKGxldCBhaSA9IDA7IGFp
IDwgZXhwci5hcmdzLmxlbmd0aDsgYWkrKykge1xuICAgICAgICBjb25zdCBwYXJhbVR5cGUgPSBn
ZXRQYXJhbVR5cGUobmFtZSwgYWkpO1xuICAgICAgICBlbWl0RXhwcihleHByLmFyZ3NbYWldLCBw
YXJhbVR5cGUpO1xuICAgICAgfVxuICAgICAgYncuYnl0ZShPUF9DQUxMKTtcbiAgICAgIGJ3LnUz
MihmSWR4KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlbWl0V2FzbUJ1aWx0aW4ob3AsIGV4cHIs
IGV4cGVjdGVkVHlwZSkge1xuICAgICAgY29uc3QgdCA9IGV4cGVjdGVkVHlwZSB8fCAnaTMyJztc
biAgICAgIGlmIChvcCA9PT0gJ2Rpdl91JykgeyBlbWl0RXhwcihleHByLmFyZ3NbMF0sIHQpOyBl
bWl0RXhwcihleHByLmFyZ3NbMV0sIHQpOyBidy5ieXRlKHQgPT09ICdpNjQnID8gT1BfSTY0X0RJ
Vl9VIDogT1BfSTMyX0RJVl9VKTsgcmV0dXJuOyB9XG4gICAgICBpZiAob3AgPT09ICdyZW1fdScp
IHsgZW1pdEV4cHIoZXhwci5hcmdzWzBdLCB0KTsgZW1pdEV4cHIoZXhwci5hcmdzWzFdLCB0KTsg
YncuYnl0ZSh0ID09PSAnaTY0JyA/IE9QX0k2NF9SRU1fVSA6IE9QX0kzMl9SRU1fVSk7IHJldHVy
bjsgfVxuICAgICAgaWYgKG9wID09PSAnc2hyX3UnKSB7IGVtaXRFeHByKGV4cHIuYXJnc1swXSwg
dCk7IGVtaXRFeHByKGV4cHIuYXJnc1sxXSwgdCk7IGJ3LmJ5dGUodCA9PT0gJ2k2NCcgPyBPUF9J
NjRfU0hSX1UgOiBPUF9JMzJfU0hSX1UpOyByZXR1cm47IH1cbiAgICAgIGlmIChvcCA9PT0gJ2x0
X3UnKSB7IGVtaXRFeHByKGV4cHIuYXJnc1swXSwgdCk7IGVtaXRFeHByKGV4cHIuYXJnc1sxXSwg
dCk7IGJ3LmJ5dGUodCA9PT0gJ2k2NCcgPyBPUF9JNjRfTFRfVSA6IE9QX0kzMl9MVF9VKTsgcmV0
dXJuOyB9XG4gICAgICBpZiAob3AgPT09ICdndF91JykgeyBlbWl0RXhwcihleHByLmFyZ3NbMF0s
IHQpOyBlbWl0RXhwcihleHByLmFyZ3NbMV0sIHQpOyBidy5ieXRlKHQgPT09ICdpNjQnID8gT1Bf
STY0X0dUX1UgOiBPUF9JMzJfR1RfVSk7IHJldHVybjsgfVxuICAgICAgaWYgKG9wID09PSAnbGVf
dScpIHsgZW1pdEV4cHIoZXhwci5hcmdzWzBdLCB0KTsgZW1pdEV4cHIoZXhwci5hcmdzWzFdLCB0
KTsgYncuYnl0ZSh0ID09PSAnaTY0JyA/IE9QX0k2NF9MRV9VIDogT1BfSTMyX0xFX1UpOyByZXR1
cm47IH1cbiAgICAgIGlmIChvcCA9PT0gJ2dlX3UnKSB7IGVtaXRFeHByKGV4cHIuYXJnc1swXSwg
dCk7IGVtaXRFeHByKGV4cHIuYXJnc1sxXSwgdCk7IGJ3LmJ5dGUodCA9PT0gJ2k2NCcgPyBPUF9J
NjRfR0VfVSA6IE9QX0kzMl9HRV9VKTsgcmV0dXJuOyB9XG4gICAgICBpZiAob3AgPT09ICdyZWlu
dGVycHJldF9mNjQnKSB7IGVtaXRFeHByKGV4cHIuYXJnc1swXSwgJ2Y2NCcpOyBidy5ieXRlKE9Q
X0k2NF9SRUlOVEVSUFJFVF9GNjQpOyByZXR1cm47IH1cbiAgICAgIGlmIChvcCA9PT0gJ3JlaW50
ZXJwcmV0X2YzMicpIHsgZW1pdEV4cHIoZXhwci5hcmdzWzBdLCAnZjMyJyk7IGJ3LmJ5dGUoT1Bf
STMyX1JFSU5URVJQUkVUX0YzMik7IHJldHVybjsgfVxuICAgICAgaWYgKG9wID09PSAncmVpbnRl
cnByZXRfaTY0JykgeyBlbWl0RXhwcihleHByLmFyZ3NbMF0sICdpNjQnKTsgYncuYnl0ZShPUF9G
NjRfUkVJTlRFUlBSRVRfSTY0KTsgcmV0dXJuOyB9XG4gICAgICBpZiAob3AgPT09ICdyZWludGVy
cHJldF9pMzInKSB7IGVtaXRFeHByKGV4cHIuYXJnc1swXSwgJ2kzMicpOyBidy5ieXRlKE9QX0Yz
Ml9SRUlOVEVSUFJFVF9JMzIpOyByZXR1cm47IH1cbiAgICAgIGlmIChvcCA9PT0gJ2V4dGVuZDhf
cycpIHsgZW1pdEV4cHIoZXhwci5hcmdzWzBdLCB0KTsgYncuYnl0ZSh0ID09PSAnaTY0JyA/IE9Q
X0k2NF9FWFRFTkQ4X1MgOiBPUF9JMzJfRVhURU5EOF9TKTsgcmV0dXJuOyB9XG4gICAgICBpZiAo
b3AgPT09ICdleHRlbmQxNl9zJykgeyBlbWl0RXhwcihleHByLmFyZ3NbMF0sIHQpOyBidy5ieXRl
KHQgPT09ICdpNjQnID8gT1BfSTY0X0VYVEVORDE2X1MgOiBPUF9JMzJfRVhURU5EMTZfUyk7IHJl
dHVybjsgfVxuICAgICAgaWYgKG9wID09PSAndHJ1bmNfc2F0X3MnKSB7XG4gICAgICAgIGNvbnN0
IGZyb21UeXBlID0gaW5mZXJFeHByVHlwZShleHByLmFyZ3NbMF0pO1xuICAgICAgICBlbWl0RXhw
cihleHByLmFyZ3NbMF0sIGZyb21UeXBlKTtcbiAgICAgICAgYncuYnl0ZShPUF9GQ19QUkVGSVgp
O1xuICAgICAgICBpZiAodCA9PT0gJ2kzMicgJiYgZnJvbVR5cGUgPT09ICdmMzInKSBidy51MzIo
T1BfSTMyX1RSVU5DX1NBVF9GMzJfUyk7XG4gICAgICAgIGVsc2UgaWYgKHQgPT09ICdpMzInICYm
IGZyb21UeXBlID09PSAnZjY0JykgYncudTMyKE9QX0kzMl9UUlVOQ19TQVRfRjY0X1MpO1xuICAg
ICAgICBlbHNlIGlmICh0ID09PSAnaTY0JyAmJiBmcm9tVHlwZSA9PT0gJ2YzMicpIGJ3LnUzMihP
UF9JNjRfVFJVTkNfU0FUX0YzMl9TKTtcbiAgICAgICAgZWxzZSBpZiAodCA9PT0gJ2k2NCcgJiYg
ZnJvbVR5cGUgPT09ICdmNjQnKSBidy51MzIoT1BfSTY0X1RSVU5DX1NBVF9GNjRfUyk7XG4gICAg
ICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChvcCA9PT0gJ3RydW5jX3NhdF91Jykge1xu
ICAgICAgICBjb25zdCBmcm9tVHlwZSA9IGluZmVyRXhwclR5cGUoZXhwci5hcmdzWzBdKTtcbiAg
ICAgICAgZW1pdEV4cHIoZXhwci5hcmdzWzBdLCBmcm9tVHlwZSk7XG4gICAgICAgIGJ3LmJ5dGUo
T1BfRkNfUFJFRklYKTtcbiAgICAgICAgaWYgKHQgPT09ICdpMzInICYmIGZyb21UeXBlID09PSAn
ZjMyJykgYncudTMyKE9QX0kzMl9UUlVOQ19TQVRfRjMyX1UpO1xuICAgICAgICBlbHNlIGlmICh0
ID09PSAnaTMyJyAmJiBmcm9tVHlwZSA9PT0gJ2Y2NCcpIGJ3LnUzMihPUF9JMzJfVFJVTkNfU0FU
X0Y2NF9VKTtcbiAgICAgICAgZWxzZSBpZiAodCA9PT0gJ2k2NCcgJiYgZnJvbVR5cGUgPT09ICdm
MzInKSBidy51MzIoT1BfSTY0X1RSVU5DX1NBVF9GMzJfVSk7XG4gICAgICAgIGVsc2UgaWYgKHQg
PT09ICdpNjQnICYmIGZyb21UeXBlID09PSAnZjY0JykgYncudTMyKE9QX0k2NF9UUlVOQ19TQVRf
RjY0X1UpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3Io
YFVua25vd24gd2FzbSBidWlsdGluOiB3YXNtLiR7b3B9YCk7XG4gICAgfVxuXG4gICAgZnVuY3Rp
b24gZW1pdFZlY3RvckNvbnN0cnVjdG9yKHZlY1R5cGUsIGFyZ3MpIHtcbiAgICAgIGNvbnN0IHNj
YWxhciA9IHZlY3RvclNjYWxhclR5cGUodmVjVHlwZSk7XG4gICAgICBjb25zdCBsYW5lQ291bnQg
PSB2ZWNUeXBlID09PSAnZjMyeDQnIHx8IHZlY1R5cGUgPT09ICdpMzJ4NCcgPyA0IDogMjtcblxu
ICAgICAgaWYgKGFyZ3MubGVuZ3RoICE9PSBsYW5lQ291bnQpIHRocm93IG5ldyBFcnJvcihgJHt2
ZWNUeXBlfSBjb25zdHJ1Y3RvciBleHBlY3RzICR7bGFuZUNvdW50fSBhcmdzLCBnb3QgJHthcmdz
Lmxlbmd0aH1gKTtcblxuICAgICAgLy8gQ2hlY2sgaWYgYWxsIGFyZ3MgYXJlIGNvbnN0YW50IChO
dW1iZXJMaXQgb3IgbmVnYXRpdmUgTnVtYmVyTGl0KVxuICAgICAgY29uc3QgYWxsQ29uc3QgPSBh
cmdzLmV2ZXJ5KGEgPT5cbiAgICAgICAgYS50eXBlID09PSAnTnVtYmVyTGl0JyB8fFxuICAgICAg
ICAoYS50eXBlID09PSAnVW5hcnlPcCcgJiYgYS5vcCA9PT0gJy0nICYmIGEub3BlcmFuZC50eXBl
ID09PSAnTnVtYmVyTGl0JykpO1xuXG4gICAgICBpZiAoYWxsQ29uc3QpIHtcbiAgICAgICAgLy8g
RW1pdCB2MTI4LmNvbnN0IHdpdGggaW5saW5lIGJ5dGVzXG4gICAgICAgIGVtaXRTaW1kKFNJTURf
T1BTWyd2MTI4LmNvbnN0J10pO1xuICAgICAgICBjb25zdCBhYnVmID0gbmV3IEFycmF5QnVmZmVy
KDE2KTtcbiAgICAgICAgY29uc3QgdmlldyA9IG5ldyBEYXRhVmlldyhhYnVmKTtcbiAgICAgICAg
Zm9yIChsZXQgbGkgPSAwOyBsaSA8IGxhbmVDb3VudDsgbGkrKykge1xuICAgICAgICAgIGNvbnN0
IGEgPSBhcmdzW2xpXTtcbiAgICAgICAgICBjb25zdCByYXcgPSBhLnR5cGUgPT09ICdOdW1iZXJM
aXQnID8gYS52YWx1ZSA6IGEub3BlcmFuZC52YWx1ZTtcbiAgICAgICAgICBjb25zdCB2YWwgPSBh
LnR5cGUgPT09ICdVbmFyeU9wJyA/IC1wYXJzZUZsb2F0KHJhdykgOiBwYXJzZUZsb2F0KHJhdyk7
XG4gICAgICAgICAgaWYgKHNjYWxhciA9PT0gJ2Y2NCcpIHZpZXcuc2V0RmxvYXQ2NChsaSAqIDgs
IHZhbCwgdHJ1ZSk7XG4gICAgICAgICAgZWxzZSBpZiAoc2NhbGFyID09PSAnZjMyJykgdmlldy5z
ZXRGbG9hdDMyKGxpICogNCwgdmFsLCB0cnVlKTtcbiAgICAgICAgICBlbHNlIGlmIChzY2FsYXIg
PT09ICdpMzInKSB2aWV3LnNldEludDMyKGxpICogNCwgdmFsIHwgMCwgdHJ1ZSk7XG4gICAgICAg
ICAgZWxzZSBpZiAoc2NhbGFyID09PSAnaTY0Jykge1xuICAgICAgICAgICAgLy8gQmlnSW50NjQg
YXMgdHdvIGkzMnMsIGxpdHRsZS1lbmRpYW5cbiAgICAgICAgICAgIGNvbnN0IGJ2ID0gQmlnSW50
KE1hdGgudHJ1bmModmFsKSk7XG4gICAgICAgICAgICB2aWV3LnNldEludDMyKGxpICogOCwgTnVt
YmVyKGJ2ICYgMHhmZmZmZmZmZm4pLCB0cnVlKTtcbiAgICAgICAgICAgIHZpZXcuc2V0SW50MzIo
bGkgKiA4ICsgNCwgTnVtYmVyKChidiA+PiAzMm4pICYgMHhmZmZmZmZmZm4pLCB0cnVlKTtcbiAg
ICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYncuYnl0ZXMobmV3IFVpbnQ4QXJyYXkoYWJ1
ZikpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gU3BsYXQgZmlyc3QgYXJnLCB0aGVuIHJl
cGxhY2VfbGFuZSBmb3IgdGhlIHJlc3RcbiAgICAgICAgZW1pdEV4cHIoYXJnc1swXSwgc2NhbGFy
KTtcbiAgICAgICAgZW1pdFNpbWQoU0lNRF9PUFNbdmVjVHlwZSArICcuc3BsYXQnXSk7XG4gICAg
ICAgIGZvciAobGV0IGxpID0gMTsgbGkgPCBsYW5lQ291bnQ7IGxpKyspIHtcbiAgICAgICAgICBl
bWl0RXhwcihhcmdzW2xpXSwgc2NhbGFyKTtcbiAgICAgICAgICBlbWl0U2ltZChTSU1EX09QU1t2
ZWNUeXBlICsgJy5yZXBsYWNlX2xhbmUnXSk7XG4gICAgICAgICAgYncuYnl0ZShsaSk7XG4gICAg
ICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlbWl0U2ltZEJ1aWx0aW4ocHJl
Zml4LCBtZXRob2QsIGV4cHIsIGV4cGVjdGVkVHlwZSkge1xuICAgICAgLy8gZjY0eDIuc3BsYXQo
eCksIGkzMng0LnNwbGF0KHgpLCBldGMuXG4gICAgICBpZiAobWV0aG9kID09PSAnc3BsYXQnKSB7
XG4gICAgICAgIGNvbnN0IHNjYWxhciA9IHZlY3RvclNjYWxhclR5cGUocHJlZml4KTtcbiAgICAg
ICAgZW1pdEV4cHIoZXhwci5hcmdzWzBdLCBzY2FsYXIpO1xuICAgICAgICBlbWl0U2ltZChTSU1E
X09QU1twcmVmaXggKyAnLnNwbGF0J10pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAg
ICAgIC8vIGY2NHgyLmV4dHJhY3RfbGFuZSh2LCBsYW5lKVxuICAgICAgaWYgKG1ldGhvZCA9PT0g
J2V4dHJhY3RfbGFuZScpIHtcbiAgICAgICAgZW1pdEV4cHIoZXhwci5hcmdzWzBdLCBwcmVmaXgp
O1xuICAgICAgICBlbWl0U2ltZChTSU1EX09QU1twcmVmaXggKyAnLmV4dHJhY3RfbGFuZSddKTtc
biAgICAgICAgLy8gbGFuZSBtdXN0IGJlIGEgY29uc3RhbnRcbiAgICAgICAgaWYgKGV4cHIuYXJn
c1sxXS50eXBlICE9PSAnTnVtYmVyTGl0JykgdGhyb3cgbmV3IEVycm9yKCdleHRyYWN0X2xhbmUg
cmVxdWlyZXMgY29uc3RhbnQgbGFuZSBpbmRleCcpO1xuICAgICAgICBidy5ieXRlKHBhcnNlSW50
KGV4cHIuYXJnc1sxXS52YWx1ZSwgMTApKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4g
ICAgICAvLyBmNjR4Mi5yZXBsYWNlX2xhbmUodiwgbGFuZSwgeClcbiAgICAgIGlmIChtZXRob2Qg
PT09ICdyZXBsYWNlX2xhbmUnKSB7XG4gICAgICAgIGNvbnN0IHNjYWxhciA9IHZlY3RvclNjYWxh
clR5cGUocHJlZml4KTtcbiAgICAgICAgZW1pdEV4cHIoZXhwci5hcmdzWzBdLCBwcmVmaXgpOyAv
LyB2MTI4IHZhbHVlXG4gICAgICAgIGVtaXRFeHByKGV4cHIuYXJnc1syXSwgc2NhbGFyKTsgLy8g
cmVwbGFjZW1lbnQgc2NhbGFyXG4gICAgICAgIGVtaXRTaW1kKFNJTURfT1BTW3ByZWZpeCArICcu
cmVwbGFjZV9sYW5lJ10pO1xuICAgICAgICBpZiAoZXhwci5hcmdzWzFdLnR5cGUgIT09ICdOdW1i
ZXJMaXQnKSB0aHJvdyBuZXcgRXJyb3IoJ3JlcGxhY2VfbGFuZSByZXF1aXJlcyBjb25zdGFudCBs
YW5lIGluZGV4Jyk7XG4gICAgICAgIGJ3LmJ5dGUocGFyc2VJbnQoZXhwci5hcmdzWzFdLnZhbHVl
LCAxMCkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIGY2NHgyLmVxLCBm
NjR4Mi5uZSwgZjY0eDIubHQsIGY2NHgyLmd0LCBmNjR4Mi5sZSwgZjY0eDIuZ2VcbiAgICAgIGlm
IChbJ2VxJywnbmUnLCdsdCcsJ2d0JywnbGUnLCdnZScsJ2x0X3MnLCdndF9zJywnbGVfcycsJ2dl
X3MnXS5pbmNsdWRlcyhtZXRob2QpKSB7XG4gICAgICAgIGVtaXRFeHByKGV4cHIuYXJnc1swXSwg
cHJlZml4KTtcbiAgICAgICAgZW1pdEV4cHIoZXhwci5hcmdzWzFdLCBwcmVmaXgpO1xuICAgICAg
ICBjb25zdCBrZXkgPSBwcmVmaXggKyAnLicgKyBtZXRob2Q7XG4gICAgICAgIGNvbnN0IG9wID0g
U0lNRF9PUFNba2V5XTtcbiAgICAgICAgaWYgKG9wID09PSB1bmRlZmluZWQpIHRocm93IG5ldyBF
cnJvcihgVW5rbm93biBTSU1EIG9wOiAke2tleX1gKTtcbiAgICAgICAgZW1pdFNpbWQob3ApO1xu
ICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIGY2NHgyLm5lZywgZjY0eDIuYWJz
LCBmNjR4Mi5zcXJ0ICh1bmFyeSlcbiAgICAgIGlmIChbJ25lZycsJ2FicycsJ3NxcnQnXS5pbmNs
dWRlcyhtZXRob2QpKSB7XG4gICAgICAgIGVtaXRFeHByKGV4cHIuYXJnc1swXSwgcHJlZml4KTtc
biAgICAgICAgY29uc3Qga2V5ID0gcHJlZml4ICsgJy4nICsgbWV0aG9kO1xuICAgICAgICBjb25z
dCBvcCA9IFNJTURfT1BTW2tleV07XG4gICAgICAgIGlmIChvcCA9PT0gdW5kZWZpbmVkKSB0aHJv
dyBuZXcgRXJyb3IoYFVua25vd24gU0lNRCBvcDogJHtrZXl9YCk7XG4gICAgICAgIGVtaXRTaW1k
KG9wKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBmNjR4Mi5hZGQsIGY2
NHgyLnN1YiwgZjY0eDIubXVsLCBmNjR4Mi5kaXYsIGY2NHgyLm1pbiwgZjY0eDIubWF4IChiaW5h
cnkpXG4gICAgICBpZiAoWydhZGQnLCdzdWInLCdtdWwnLCdkaXYnLCdtaW4nLCdtYXgnXS5pbmNs
dWRlcyhtZXRob2QpKSB7XG4gICAgICAgIGVtaXRFeHByKGV4cHIuYXJnc1swXSwgcHJlZml4KTtc
biAgICAgICAgZW1pdEV4cHIoZXhwci5hcmdzWzFdLCBwcmVmaXgpO1xuICAgICAgICBjb25zdCBr
ZXkgPSBwcmVmaXggKyAnLicgKyBtZXRob2Q7XG4gICAgICAgIGNvbnN0IG9wID0gU0lNRF9PUFNb
a2V5XTtcbiAgICAgICAgaWYgKG9wID09PSB1bmRlZmluZWQpIHRocm93IG5ldyBFcnJvcihgVW5r
bm93biBTSU1EIG9wOiAke2tleX1gKTtcbiAgICAgICAgZW1pdFNpbWQob3ApO1xuICAgICAgICBy
ZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIHYxMjguYW5kLCB2MTI4Lm9yLCB2MTI4LnhvciAo
YmluYXJ5IGJpdHdpc2UpXG4gICAgICBpZiAocHJlZml4ID09PSAndjEyOCcgJiYgWydhbmQnLCdv
cicsJ3hvciddLmluY2x1ZGVzKG1ldGhvZCkpIHtcbiAgICAgICAgLy8gSW5mZXIgb3BlcmFuZCB0
eXBlIGZyb20gZmlyc3QgYXJnXG4gICAgICAgIGNvbnN0IHZ0ID0gaW5mZXJFeHByVHlwZShleHBy
LmFyZ3NbMF0pO1xuICAgICAgICBlbWl0RXhwcihleHByLmFyZ3NbMF0sIHZ0KTtcbiAgICAgICAg
ZW1pdEV4cHIoZXhwci5hcmdzWzFdLCB2dCk7XG4gICAgICAgIGVtaXRTaW1kKFNJTURfT1BTWyd2
MTI4LicgKyBtZXRob2RdKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyB2
MTI4Lm5vdCAodW5hcnkgYml0d2lzZSlcbiAgICAgIGlmIChwcmVmaXggPT09ICd2MTI4JyAmJiBt
ZXRob2QgPT09ICdub3QnKSB7XG4gICAgICAgIGNvbnN0IHZ0ID0gaW5mZXJFeHByVHlwZShleHBy
LmFyZ3NbMF0pO1xuICAgICAgICBlbWl0RXhwcihleHByLmFyZ3NbMF0sIHZ0KTtcbiAgICAgICAg
ZW1pdFNpbWQoU0lNRF9PUFNbJ3YxMjgubm90J10pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9
XG5cbiAgICAgIC8vIHYxMjgubG9hZChhcnIsIGkpIOKAlCBsb2FkIDE2IGJ5dGVzIGZyb20gbWVt
b3J5IGF0IGFyciArIGkgKiAxNlxuICAgICAgaWYgKHByZWZpeCA9PT0gJ3YxMjgnICYmIG1ldGhv
ZCA9PT0gJ2xvYWQnKSB7XG4gICAgICAgIC8vIENvbXB1dGUgYWRkcmVzczogYXJyICsgaSAqIDE2
XG4gICAgICAgIGVtaXRFeHByKGV4cHIuYXJnc1swXSwgJ2kzMicpOyAvLyBiYXNlIHBvaW50ZXJc
biAgICAgICAgZW1pdEV4cHIoZXhwci5hcmdzWzFdLCAnaTMyJyk7IC8vIGluZGV4XG4gICAgICAg
IGJ3LmJ5dGUoT1BfSTMyX0NPTlNUKTsgYncuczMyKDE2KTtcbiAgICAgICAgYncuYnl0ZShPUF9J
MzJfTVVMKTtcbiAgICAgICAgYncuYnl0ZShPUF9JMzJfQUREKTtcbiAgICAgICAgZW1pdFNpbWQo
U0lNRF9PUFNbJ3YxMjgubG9hZCddKTsgYncudTMyKDQpOyBidy51MzIoMCk7IC8vIGFsaWduPTE2
XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gdjEyOC5zdG9yZShhcnIsIGks
IHYpIOKAlCBzdG9yZSAxNiBieXRlcyB0byBtZW1vcnkgYXQgYXJyICsgaSAqIDE2XG4gICAgICBp
ZiAocHJlZml4ID09PSAndjEyOCcgJiYgbWV0aG9kID09PSAnc3RvcmUnKSB7XG4gICAgICAgIC8v
IENvbXB1dGUgYWRkcmVzc1xuICAgICAgICBlbWl0RXhwcihleHByLmFyZ3NbMF0sICdpMzInKTtc
biAgICAgICAgZW1pdEV4cHIoZXhwci5hcmdzWzFdLCAnaTMyJyk7XG4gICAgICAgIGJ3LmJ5dGUo
T1BfSTMyX0NPTlNUKTsgYncuczMyKDE2KTtcbiAgICAgICAgYncuYnl0ZShPUF9JMzJfTVVMKTtc
biAgICAgICAgYncuYnl0ZShPUF9JMzJfQUREKTtcbiAgICAgICAgLy8gRW1pdCB2YWx1ZVxuICAg
ICAgICBjb25zdCB2dCA9IGluZmVyRXhwclR5cGUoZXhwci5hcmdzWzJdKTtcbiAgICAgICAgZW1p
dEV4cHIoZXhwci5hcmdzWzJdLCB2dCk7XG4gICAgICAgIGVtaXRTaW1kKFNJTURfT1BTWyd2MTI4
LnN0b3JlJ10pOyBidy51MzIoNCk7IGJ3LnUzMigwKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAg
fVxuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gU0lNRCBidWlsdGluOiAke3ByZWZp
eH0uJHttZXRob2R9YCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZW1pdENvbnZlcnNpb24oZnJv
bSwgdG8pIHtcbiAgICAgIGlmIChmcm9tID09PSB0bykgcmV0dXJuO1xuICAgICAgaWYgKGZyb20g
PT09ICdpMzInICYmIHRvID09PSAnZjY0JykgYncuYnl0ZShPUF9GNjRfQ09OVkVSVF9JMzJfUyk7
XG4gICAgICBlbHNlIGlmIChmcm9tID09PSAnaTMyJyAmJiB0byA9PT0gJ2YzMicpIGJ3LmJ5dGUo
T1BfRjMyX0NPTlZFUlRfSTMyX1MpO1xuICAgICAgZWxzZSBpZiAoZnJvbSA9PT0gJ2kzMicgJiYg
dG8gPT09ICdpNjQnKSBidy5ieXRlKE9QX0k2NF9FWFRFTkRfSTMyX1MpO1xuICAgICAgZWxzZSBp
ZiAoZnJvbSA9PT0gJ2k2NCcgJiYgdG8gPT09ICdpMzInKSBidy5ieXRlKE9QX0kzMl9XUkFQX0k2
NCk7XG4gICAgICBlbHNlIGlmIChmcm9tID09PSAnaTY0JyAmJiB0byA9PT0gJ2Y2NCcpIGJ3LmJ5
dGUoT1BfRjY0X0NPTlZFUlRfSTY0X1MpO1xuICAgICAgZWxzZSBpZiAoZnJvbSA9PT0gJ2k2NCcg
JiYgdG8gPT09ICdmMzInKSBidy5ieXRlKE9QX0YzMl9DT05WRVJUX0k2NF9TKTtcbiAgICAgIGVs
c2UgaWYgKGZyb20gPT09ICdmNjQnICYmIHRvID09PSAnaTMyJykgYncuYnl0ZShPUF9JMzJfVFJV
TkNfRjY0X1MpO1xuICAgICAgZWxzZSBpZiAoZnJvbSA9PT0gJ2Y2NCcgJiYgdG8gPT09ICdpNjQn
KSBidy5ieXRlKE9QX0k2NF9UUlVOQ19GNjRfUyk7XG4gICAgICBlbHNlIGlmIChmcm9tID09PSAn
ZjY0JyAmJiB0byA9PT0gJ2YzMicpIGJ3LmJ5dGUoT1BfRjMyX0RFTU9URV9GNjQpO1xuICAgICAg
ZWxzZSBpZiAoZnJvbSA9PT0gJ2YzMicgJiYgdG8gPT09ICdmNjQnKSBidy5ieXRlKE9QX0Y2NF9Q
Uk9NT1RFX0YzMik7XG4gICAgICBlbHNlIGlmIChmcm9tID09PSAnZjMyJyAmJiB0byA9PT0gJ2kz
MicpIGJ3LmJ5dGUoT1BfSTMyX1RSVU5DX0YzMl9TKTtcbiAgICAgIGVsc2UgaWYgKGZyb20gPT09
ICdmMzInICYmIHRvID09PSAnaTY0JykgYncuYnl0ZShPUF9JNjRfVFJVTkNfRjMyX1MpO1xuICAg
ICAgZWxzZSB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBjb252ZXJ0ICR7ZnJvbX0gdG8gJHt0b31g
KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlbWl0QXJyYXlBZGRyKG5hbWUsIGluZGljZXMsIGlu
Zm8sIGVsZW1UeXBlKSB7XG4gICAgICAvLyBCYXNlIHBvaW50ZXJcbiAgICAgIGJ3LmJ5dGUoT1Bf
TE9DQUxfR0VUKTtcbiAgICAgIGJ3LnUzMihpbmZvLmlkeCk7XG5cbiAgICAgIGNvbnN0IHN6ID0g
dHlwZVNpemUoZWxlbVR5cGUpO1xuXG4gICAgICBpZiAoaW5kaWNlcy5sZW5ndGggPT09IDEpIHtc
biAgICAgICAgLy8gMUQ6IGJhc2UgKyBpICogc2l6ZW9mXG4gICAgICAgIGVtaXRFeHByKGluZGlj
ZXNbMF0sICdpMzInKTtcbiAgICAgICAgYncuYnl0ZShPUF9JMzJfQ09OU1QpOyBidy5zMzIoc3op
O1xuICAgICAgICBidy5ieXRlKE9QX0kzMl9NVUwpO1xuICAgICAgICBidy5ieXRlKE9QX0kzMl9B
REQpO1xuICAgICAgfSBlbHNlIGlmIChpbmRpY2VzLmxlbmd0aCA9PT0gMyAmJiAhaW5mby5hcnJh
eURpbXMpIHtcbiAgICAgICAgLy8gMkQgd2l0aCBleHBsaWNpdCBzdHJpZGU6IGFbaSwgc3RyaWRl
LCBqXSDihpIgYmFzZSArIChpKnN0cmlkZSArIGopICogc2l6ZW9mXG4gICAgICAgIGVtaXRFeHBy
KGluZGljZXNbMF0sICdpMzInKTtcbiAgICAgICAgZW1pdEV4cHIoaW5kaWNlc1sxXSwgJ2kzMicp
O1xuICAgICAgICBidy5ieXRlKE9QX0kzMl9NVUwpO1xuICAgICAgICBlbWl0RXhwcihpbmRpY2Vz
WzJdLCAnaTMyJyk7XG4gICAgICAgIGJ3LmJ5dGUoT1BfSTMyX0FERCk7XG4gICAgICAgIGJ3LmJ5
dGUoT1BfSTMyX0NPTlNUKTsgYncuczMyKHN6KTtcbiAgICAgICAgYncuYnl0ZShPUF9JMzJfTVVM
KTtcbiAgICAgICAgYncuYnl0ZShPUF9JMzJfQUREKTtcbiAgICAgIH0gZWxzZSBpZiAoaW5kaWNl
cy5sZW5ndGggPT09IDIgJiYgaW5mby5hcnJheURpbXMgJiYgaW5mby5hcnJheURpbXMubGVuZ3Ro
ID09PSAyKSB7XG4gICAgICAgIC8vIDJEIHdpdGggZGVjbGFyZWQgZGltczogYVtpLCBqXSDihpIg
YmFzZSArIChpKmRpbTEgKyBqKSAqIHNpemVvZlxuICAgICAgICBlbWl0RXhwcihpbmRpY2VzWzBd
LCAnaTMyJyk7XG4gICAgICAgIGVtaXRFeHByKGluZm8uYXJyYXlEaW1zWzFdLCAnaTMyJyk7XG4g
ICAgICAgIGJ3LmJ5dGUoT1BfSTMyX01VTCk7XG4gICAgICAgIGVtaXRFeHByKGluZGljZXNbMV0s
ICdpMzInKTtcbiAgICAgICAgYncuYnl0ZShPUF9JMzJfQUREKTtcbiAgICAgICAgYncuYnl0ZShP
UF9JMzJfQ09OU1QpOyBidy5zMzIoc3opO1xuICAgICAgICBidy5ieXRlKE9QX0kzMl9NVUwpO1xu
ICAgICAgICBidy5ieXRlKE9QX0kzMl9BREQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhy
b3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBhcnJheSBpbmRleCBwYXR0ZXJuIGZvciAke25hbWV9
YCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZW1pdExvYWQodCkge1xuICAgICAg
aWYgKHQgPT09ICdpMzInKSB7IGJ3LmJ5dGUoT1BfSTMyX0xPQUQpOyBidy51MzIoMik7IGJ3LnUz
MigwKTsgfSAvLyBhbGlnbj00XG4gICAgICBlbHNlIGlmICh0ID09PSAnaTY0JykgeyBidy5ieXRl
KE9QX0k2NF9MT0FEKTsgYncudTMyKDMpOyBidy51MzIoMCk7IH1cbiAgICAgIGVsc2UgaWYgKHQg
PT09ICdmMzInKSB7IGJ3LmJ5dGUoT1BfRjMyX0xPQUQpOyBidy51MzIoMik7IGJ3LnUzMigwKTsg
fVxuICAgICAgZWxzZSBpZiAodCA9PT0gJ2Y2NCcpIHsgYncuYnl0ZShPUF9GNjRfTE9BRCk7IGJ3
LnUzMigzKTsgYncudTMyKDApOyB9XG4gICAgICBlbHNlIGlmIChpc1ZlY3Rvcih0KSkgeyBlbWl0
U2ltZChTSU1EX09QU1sndjEyOC5sb2FkJ10pOyBidy51MzIoNCk7IGJ3LnUzMigwKTsgfSAvLyBh
bGlnbj0xNlxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVtaXRTdG9yZSh0KSB7XG4gICAgICBpZiAo
dCA9PT0gJ2kzMicpIHsgYncuYnl0ZShPUF9JMzJfU1RPUkUpOyBidy51MzIoMik7IGJ3LnUzMigw
KTsgfVxuICAgICAgZWxzZSBpZiAodCA9PT0gJ2k2NCcpIHsgYncuYnl0ZShPUF9JNjRfU1RPUkUp
OyBidy51MzIoMyk7IGJ3LnUzMigwKTsgfVxuICAgICAgZWxzZSBpZiAodCA9PT0gJ2YzMicpIHsg
YncuYnl0ZShPUF9GMzJfU1RPUkUpOyBidy51MzIoMik7IGJ3LnUzMigwKTsgfVxuICAgICAgZWxz
ZSBpZiAodCA9PT0gJ2Y2NCcpIHsgYncuYnl0ZShPUF9GNjRfU1RPUkUpOyBidy51MzIoMyk7IGJ3
LnUzMigwKTsgfVxuICAgICAgZWxzZSBpZiAoaXNWZWN0b3IodCkpIHsgZW1pdFNpbWQoU0lNRF9P
UFNbJ3YxMjguc3RvcmUnXSk7IGJ3LnUzMig0KTsgYncudTMyKDApOyB9IC8vIGFsaWduPTE2XG4g
ICAgfVxuXG4gICAgZnVuY3Rpb24gZW1pdENtcChvcCwgdCkge1xuICAgICAgaWYgKHQgPT09ICdm
NjQnKSB7XG4gICAgICAgIGlmIChvcCA9PT0gJz09JykgYncuYnl0ZShPUF9GNjRfRVEpO1xuICAg
ICAgICBlbHNlIGlmIChvcCA9PT0gJy89JykgYncuYnl0ZShPUF9GNjRfTkUpO1xuICAgICAgICBl
bHNlIGlmIChvcCA9PT0gJzwnKSBidy5ieXRlKE9QX0Y2NF9MVCk7XG4gICAgICAgIGVsc2UgaWYg
KG9wID09PSAnPicpIGJ3LmJ5dGUoT1BfRjY0X0dUKTtcbiAgICAgICAgZWxzZSBpZiAob3AgPT09
ICc8PScpIGJ3LmJ5dGUoT1BfRjY0X0xFKTtcbiAgICAgICAgZWxzZSBpZiAob3AgPT09ICc+PScp
IGJ3LmJ5dGUoT1BfRjY0X0dFKTtcbiAgICAgIH0gZWxzZSBpZiAodCA9PT0gJ2YzMicpIHtcbiAg
ICAgICAgaWYgKG9wID09PSAnPT0nKSBidy5ieXRlKE9QX0YzMl9FUSk7XG4gICAgICAgIGVsc2Ug
aWYgKG9wID09PSAnLz0nKSBidy5ieXRlKE9QX0YzMl9ORSk7XG4gICAgICAgIGVsc2UgaWYgKG9w
ID09PSAnPCcpIGJ3LmJ5dGUoT1BfRjMyX0xUKTtcbiAgICAgICAgZWxzZSBpZiAob3AgPT09ICc+
JykgYncuYnl0ZShPUF9GMzJfR1QpO1xuICAgICAgICBlbHNlIGlmIChvcCA9PT0gJzw9JykgYncu
Ynl0ZShPUF9GMzJfTEUpO1xuICAgICAgICBlbHNlIGlmIChvcCA9PT0gJz49JykgYncuYnl0ZShP
UF9GMzJfR0UpO1xuICAgICAgfSBlbHNlIGlmICh0ID09PSAnaTMyJykge1xuICAgICAgICBpZiAo
b3AgPT09ICc9PScpIGJ3LmJ5dGUoT1BfSTMyX0VRKTtcbiAgICAgICAgZWxzZSBpZiAob3AgPT09
ICcvPScpIGJ3LmJ5dGUoT1BfSTMyX05FKTtcbiAgICAgICAgZWxzZSBpZiAob3AgPT09ICc8Jykg
YncuYnl0ZShPUF9JMzJfTFRfUyk7XG4gICAgICAgIGVsc2UgaWYgKG9wID09PSAnPicpIGJ3LmJ5
dGUoT1BfSTMyX0dUX1MpO1xuICAgICAgICBlbHNlIGlmIChvcCA9PT0gJzw9JykgYncuYnl0ZShP
UF9JMzJfTEVfUyk7XG4gICAgICAgIGVsc2UgaWYgKG9wID09PSAnPj0nKSBidy5ieXRlKE9QX0kz
Ml9HRV9TKTtcbiAgICAgIH0gZWxzZSBpZiAodCA9PT0gJ2k2NCcpIHtcbiAgICAgICAgaWYgKG9w
ID09PSAnPT0nKSBidy5ieXRlKE9QX0k2NF9FUSk7XG4gICAgICAgIGVsc2UgaWYgKG9wID09PSAn
Lz0nKSBidy5ieXRlKE9QX0k2NF9ORSk7XG4gICAgICAgIGVsc2UgaWYgKG9wID09PSAnPCcpIGJ3
LmJ5dGUoT1BfSTY0X0xUX1MpO1xuICAgICAgICBlbHNlIGlmIChvcCA9PT0gJz4nKSBidy5ieXRl
KE9QX0k2NF9HVF9TKTtcbiAgICAgICAgZWxzZSBpZiAob3AgPT09ICc8PScpIGJ3LmJ5dGUoT1Bf
STY0X0xFX1MpO1xuICAgICAgICBlbHNlIGlmIChvcCA9PT0gJz49JykgYncuYnl0ZShPUF9JNjRf
R0VfUyk7XG4gICAgICB9IGVsc2UgaWYgKGlzVmVjdG9yKHQpKSB7XG4gICAgICAgIC8vIFZlY3Rv
ciBjb21wYXJpc29ucyDigJQgbWFwIGF0cmEgb3BzIHRvIFNJTUQgb3Bjb2RlIGtleXNcbiAgICAg
ICAgY29uc3QgaXNJbnRWZWMgPSAodCA9PT0gJ2kzMng0JyB8fCB0ID09PSAnaTY0eDInKTtcbiAg
ICAgICAgY29uc3Qgc3VmZml4ID0gaXNJbnRWZWMgPyAnX3MnIDogJyc7XG4gICAgICAgIGxldCBr
ZXk7XG4gICAgICAgIGlmIChvcCA9PT0gJz09Jykga2V5ID0gdCArICcuZXEnO1xuICAgICAgICBl
bHNlIGlmIChvcCA9PT0gJy89Jykga2V5ID0gdCArICcubmUnO1xuICAgICAgICBlbHNlIGlmIChv
cCA9PT0gJzwnKSBrZXkgPSB0ICsgKGlzSW50VmVjID8gJy5sdF9zJyA6ICcubHQnKTtcbiAgICAg
ICAgZWxzZSBpZiAob3AgPT09ICc+Jykga2V5ID0gdCArIChpc0ludFZlYyA/ICcuZ3RfcycgOiAn
Lmd0Jyk7XG4gICAgICAgIGVsc2UgaWYgKG9wID09PSAnPD0nKSBrZXkgPSB0ICsgKGlzSW50VmVj
ID8gJy5sZV9zJyA6ICcubGUnKTtcbiAgICAgICAgZWxzZSBpZiAob3AgPT09ICc+PScpIGtleSA9
IHQgKyAoaXNJbnRWZWMgPyAnLmdlX3MnIDogJy5nZScpO1xuICAgICAgICBjb25zdCBvcGNvZGUg
PSBTSU1EX09QU1trZXldO1xuICAgICAgICBpZiAob3Bjb2RlID09PSB1bmRlZmluZWQpIHRocm93
IG5ldyBFcnJvcihgQ29tcGFyaXNvbiAke29wfSBub3Qgc3VwcG9ydGVkIGZvciAke3R9YCk7XG4g
ICAgICAgIGVtaXRTaW1kKG9wY29kZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24g
ZW1pdEFkZCh0KSB7XG4gICAgICBpZiAodCA9PT0gJ2Y2NCcpIGJ3LmJ5dGUoT1BfRjY0X0FERCk7
XG4gICAgICBlbHNlIGlmICh0ID09PSAnZjMyJykgYncuYnl0ZShPUF9GMzJfQUREKTtcbiAgICAg
IGVsc2UgaWYgKHQgPT09ICdpMzInKSBidy5ieXRlKE9QX0kzMl9BREQpO1xuICAgICAgZWxzZSBp
ZiAodCA9PT0gJ2k2NCcpIGJ3LmJ5dGUoT1BfSTY0X0FERCk7XG4gICAgICBlbHNlIGlmIChpc1Zl
Y3Rvcih0KSkgZW1pdFNpbWQoU0lNRF9PUFNbdCArICcuYWRkJ10pO1xuICAgIH1cblxuICAgIGZ1
bmN0aW9uIGVtaXRTdWIodCkge1xuICAgICAgaWYgKHQgPT09ICdmNjQnKSBidy5ieXRlKE9QX0Y2
NF9TVUIpO1xuICAgICAgZWxzZSBpZiAodCA9PT0gJ2YzMicpIGJ3LmJ5dGUoT1BfRjMyX1NVQik7
XG4gICAgICBlbHNlIGlmICh0ID09PSAnaTMyJykgYncuYnl0ZShPUF9JMzJfU1VCKTtcbiAgICAg
IGVsc2UgaWYgKHQgPT09ICdpNjQnKSBidy5ieXRlKE9QX0k2NF9TVUIpO1xuICAgICAgZWxzZSBp
ZiAoaXNWZWN0b3IodCkpIGVtaXRTaW1kKFNJTURfT1BTW3QgKyAnLnN1YiddKTtcbiAgICB9XG5c
biAgICBmdW5jdGlvbiBlbWl0TXVsKHQpIHtcbiAgICAgIGlmICh0ID09PSAnZjY0JykgYncuYnl0
ZShPUF9GNjRfTVVMKTtcbiAgICAgIGVsc2UgaWYgKHQgPT09ICdmMzInKSBidy5ieXRlKE9QX0Yz
Ml9NVUwpO1xuICAgICAgZWxzZSBpZiAodCA9PT0gJ2kzMicpIGJ3LmJ5dGUoT1BfSTMyX01VTCk7
XG4gICAgICBlbHNlIGlmICh0ID09PSAnaTY0JykgYncuYnl0ZShPUF9JNjRfTVVMKTtcbiAgICAg
IGVsc2UgaWYgKGlzVmVjdG9yKHQpKSBlbWl0U2ltZChTSU1EX09QU1t0ICsgJy5tdWwnXSk7XG4g
ICAgfVxuXG4gICAgZnVuY3Rpb24gZW1pdERpdih0KSB7XG4gICAgICBpZiAodCA9PT0gJ2Y2NCcp
IGJ3LmJ5dGUoT1BfRjY0X0RJVik7XG4gICAgICBlbHNlIGlmICh0ID09PSAnZjMyJykgYncuYnl0
ZShPUF9GMzJfRElWKTtcbiAgICAgIGVsc2UgaWYgKHQgPT09ICdpMzInKSBidy5ieXRlKE9QX0kz
Ml9ESVZfUyk7XG4gICAgICBlbHNlIGlmICh0ID09PSAnaTY0JykgYncuYnl0ZShPUF9JNjRfRElW
X1MpO1xuICAgICAgZWxzZSBpZiAoaXNWZWN0b3IodCkpIHtcbiAgICAgICAgY29uc3Qgb3AgPSBT
SU1EX09QU1t0ICsgJy5kaXYnXTtcbiAgICAgICAgaWYgKCFvcCkgdGhyb3cgbmV3IEVycm9yKCdE
aXZpc2lvbiBub3Qgc3VwcG9ydGVkIGZvciAnICsgdCk7XG4gICAgICAgIGVtaXRTaW1kKG9wKTtc
biAgICAgIH1cbiAgICB9XG5cbiAgICAvLyDilIDilIAgRW1pdCBmdW5jdGlvbiBib2R5IHN0YXRl
bWVudHMg4pSA4pSAXG4gICAgZW1pdFN0bXRzKGZuLmJvZHkpO1xuXG4gICAgLy8g4pSA4pSAIEVu
ZCBvZiBmdW5jdGlvbiBib2R5OiByZXR1cm4gdmFsdWUg4pSA4pSAXG4gICAgaWYgKGlzRnVuYykg
e1xuICAgICAgYncuYnl0ZShPUF9MT0NBTF9HRVQpO1xuICAgICAgYncudTMyKGxvY2FsTWFwWyck
X3JldHVybiddLmlkeCk7XG4gICAgfVxuICAgIGJ3LmJ5dGUoT1BfRU5EKTtcbiAgfVxufVxuXG4v
LyDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDi
lZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDi
lZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDi
lZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZBc
bi8vIDUuIFRBR0dFRCBURU1QTEFURSBHTFVFICsgU0VMRi1SRUdJU1RSQVRJT05cbi8vIOKVkOKV
kOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKV
kOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKV
kOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKV
kOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkFxuXG5mdW5j
dGlvbiBjb21waWxlU291cmNlKHNvdXJjZSwgaW50ZXJwVmFsdWVzLCB1c2VySW1wb3J0cykge1xu
ICBjb25zdCB0b2tlbnMgPSBsZXgoc291cmNlKTtcbiAgY29uc3QgYXN0ID0gcGFyc2UodG9rZW5z
KTtcbiAgcmV0dXJuIGNvZGVnZW4oYXN0LCBpbnRlcnBWYWx1ZXMsIHVzZXJJbXBvcnRzKTtcbn1c
blxuZnVuY3Rpb24gaW5zdGFudGlhdGUoYnl0ZXMsIHVzZXJJbXBvcnRzLCBpbnRlcnBWYWx1ZXMp
IHtcbiAgY29uc3QgaW1wb3J0T2JqID0geyBtYXRoOiB7fSB9O1xuXG4gIC8vIE1hdGggYnVpbHRp
bnNcbiAgaW1wb3J0T2JqLm1hdGguc2luID0gTWF0aC5zaW47XG4gIGltcG9ydE9iai5tYXRoLmNv
cyA9IE1hdGguY29zO1xuICBpbXBvcnRPYmoubWF0aC5sbiA9IE1hdGgubG9nO1xuICBpbXBvcnRP
YmoubWF0aC5leHAgPSBNYXRoLmV4cDtcbiAgaW1wb3J0T2JqLm1hdGgucG93ID0gTWF0aC5wb3c7
XG4gIGltcG9ydE9iai5tYXRoLmF0YW4yID0gTWF0aC5hdGFuMjtcblxuICAvLyBIb3N0IGltcG9y
dHMgKGZyb20gdXNlckltcG9ydHMgb3IgZ2xvYmFsVGhpcylcbiAgaW1wb3J0T2JqLmhvc3QgPSB7
fTtcbiAgaWYgKHVzZXJJbXBvcnRzKSB7XG4gICAgZm9yIChjb25zdCBbaywgdl0gb2YgT2JqZWN0
LmVudHJpZXModXNlckltcG9ydHMpKSB7XG4gICAgICBpZiAoayA9PT0gJ19fbWVtb3J5JyB8fCBr
ID09PSAnbWVtb3J5JykgY29udGludWU7XG4gICAgICBpZiAodHlwZW9mIHYgPT09ICdmdW5jdGlv
bicpIGltcG9ydE9iai5ob3N0W2tdID0gdjtcbiAgICB9XG4gIH1cblxuICAvLyBJbnRlcnBvbGF0
ZWQgaW1wb3J0c1xuICBpZiAoaW50ZXJwVmFsdWVzKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkg
PCBpbnRlcnBWYWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHYgPSBpbnRlcnBWYWx1
ZXNbaV07XG4gICAgICBpZiAodHlwZW9mIHYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaW1w
b3J0T2JqLmhvc3RbJ19fSU5URVJQXycgKyBpICsgJ19fJ10gPSB2O1xuICAgICAgfVxuICAgIH1c
biAgfVxuXG4gIC8vIE1lbW9yeVxuICBpZiAodXNlckltcG9ydHMgJiYgdXNlckltcG9ydHMuX19t
ZW1vcnkpIHtcbiAgICBpZiAoIWltcG9ydE9iai5lbnYpIGltcG9ydE9iai5lbnYgPSB7fTtcbiAg
ICBpbXBvcnRPYmouZW52Lm1lbW9yeSA9IHVzZXJJbXBvcnRzLl9fbWVtb3J5O1xuICB9XG5cbiAg
Y29uc3QgbW9kID0gbmV3IFdlYkFzc2VtYmx5Lk1vZHVsZShieXRlcyk7XG4gIGNvbnN0IGluc3Rh
bmNlID0gbmV3IFdlYkFzc2VtYmx5Lkluc3RhbmNlKG1vZCwgaW1wb3J0T2JqKTtcbiAgcmV0dXJu
IGluc3RhbmNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYXRyYShzdHJpbmdzT3JPcHRzLCAuLi52
YWx1ZXMpIHtcbiAgLy8gQ3VycmllZCBmb3JtOiBhdHJhKHtpbXBvcnRzfSlgLi4uYFxuICBpZiAo
c3RyaW5nc09yT3B0cyAmJiAhQXJyYXkuaXNBcnJheShzdHJpbmdzT3JPcHRzKSAmJiB0eXBlb2Yg
c3RyaW5nc09yT3B0cyA9PT0gJ29iamVjdCcgJiYgIXN0cmluZ3NPck9wdHMucmF3KSB7XG4gICAg
Y29uc3Qgb3B0cyA9IHN0cmluZ3NPck9wdHM7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHN0cmluZ3Ms
IC4uLnZhbHMpIHtcbiAgICAgIHJldHVybiBjb21waWxlQW5kSW5zdGFudGlhdGUoc3RyaW5ncywg
dmFscywgb3B0cyk7XG4gICAgfTtcbiAgfVxuICAvLyBEaXJlY3QgZm9ybTogYXRyYWAuLi5gXG4g
IHJldHVybiBjb21waWxlQW5kSW5zdGFudGlhdGUoc3RyaW5nc09yT3B0cywgdmFsdWVzLCBudWxs
KTtcbn1cblxuZnVuY3Rpb24gY29tcGlsZUFuZEluc3RhbnRpYXRlKHN0cmluZ3MsIHZhbHVlcywg
dXNlckltcG9ydHMpIHtcbiAgLy8gTm9ybWFsaXplOiB1c2VyIHBhc3NlcyB7IG1lbW9yeSB9IGJ1
dCBpbnRlcm5hbCBjb2RlIHVzZXMgX19tZW1vcnlcbiAgaWYgKHVzZXJJbXBvcnRzICYmIHVzZXJJ
bXBvcnRzLm1lbW9yeSAmJiAhdXNlckltcG9ydHMuX19tZW1vcnkpIHtcbiAgICB1c2VySW1wb3J0
cyA9IE9iamVjdC5hc3NpZ24oe30sIHVzZXJJbXBvcnRzLCB7IF9fbWVtb3J5OiB1c2VySW1wb3J0
cy5tZW1vcnkgfSk7XG4gIH1cbiAgLy8gSm9pbiB0ZW1wbGF0ZSBzdHJpbmdzIHdpdGggaW50ZXJw
b2xhdGlvbiBtYXJrZXJzXG4gIGxldCBzb3VyY2UgPSBzdHJpbmdzWzBdO1xuICBmb3IgKGxldCBp
ID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgIC8vIEZvciBudW1lcmljIHZhbHVl
cywgaW5saW5lIHRoZW0gZGlyZWN0bHlcbiAgICBpZiAodHlwZW9mIHZhbHVlc1tpXSA9PT0gJ251
bWJlcicpIHtcbiAgICAgIHNvdXJjZSArPSBTdHJpbmcodmFsdWVzW2ldKTtcbiAgICB9IGVsc2Ug
e1xuICAgICAgc291cmNlICs9ICdfX0lOVEVSUF8nICsgaSArICdfXyc7XG4gICAgfVxuICAgIHNv
dXJjZSArPSBzdHJpbmdzW2kgKyAxXTtcbiAgfVxuXG4gIGNvbnN0IHsgYnl0ZXMsIHRhYmxlIH0g
PSBjb21waWxlU291cmNlKHNvdXJjZSwgdmFsdWVzLCB1c2VySW1wb3J0cyk7XG4gIGNvbnN0IGlu
c3RhbmNlID0gaW5zdGFudGlhdGUoYnl0ZXMsIHVzZXJJbXBvcnRzLCB2YWx1ZXMpO1xuICBjb25z
dCBleHBvcnRzID0gT2JqZWN0LmNyZWF0ZShpbnN0YW5jZS5leHBvcnRzKTtcbiAgaWYgKHRhYmxl
KSBleHBvcnRzLl9fdGFibGUgPSB0YWJsZTtcbiAgcmV0dXJuIGV4cG9ydHM7XG59XG5cbi8vIERp
cmVjdCBjb21waWxlciBhY2Nlc3NcbmF0cmEuY29tcGlsZSA9IGZ1bmN0aW9uKHNvdXJjZSkge1xu
ICByZXR1cm4gY29tcGlsZVNvdXJjZShzb3VyY2UsIG51bGwsIG51bGwpLmJ5dGVzO1xufTtcblxu
YXRyYS5wYXJzZSA9IGZ1bmN0aW9uKHNvdXJjZSkge1xuICBjb25zdCB0b2tlbnMgPSBsZXgoc291
cmNlKTtcbiAgcmV0dXJuIHBhcnNlKHRva2Vucyk7XG59O1xuXG5hdHJhLmR1bXAgPSBmdW5jdGlv
bihzb3VyY2UpIHtcbiAgY29uc3QgeyBieXRlcyB9ID0gY29tcGlsZVNvdXJjZShzb3VyY2UsIG51
bGwsIG51bGwpO1xuICByZXR1cm4gQXJyYXkuZnJvbShieXRlcykubWFwKGIgPT4gYi50b1N0cmlu
ZygxNikucGFkU3RhcnQoMiwgJzAnKSkuam9pbignICcpO1xufTtcblxuLy8g4pSA4pSAIFNlbGYt
cmVnaXN0cmF0aW9uIOKUgOKUgFxuXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcp
IHtcbiAgaWYgKCF3aW5kb3cuX3RhZ2dlZExhbmd1YWdlcykgd2luZG93Ll90YWdnZWRMYW5ndWFn
ZXMgPSB7fTtcbiAgd2luZG93Ll90YWdnZWRMYW5ndWFnZXMuYXRyYSA9IHsgdG9rZW5pemU6IHRv
a2VuaXplQXRyYSwgY29tcGxldGlvbnM6IGF0cmFDb21wbGV0aW9ucyB9O1xufVxuXG4vLyBBdHRh
Y2ggaW50ZXJuYWxzIGZvciB0ZXN0aW5nIC8gYWR2YW5jZWQgdXNlXG5hdHJhLl9sZXggPSBsZXg7
XG5hdHJhLl9wYXJzZSA9IHBhcnNlO1xuYXRyYS5fdG9rZW5pemUgPSB0b2tlbml6ZUF0cmE7XG4i
LCJjZWxsSWQiOm51bGx9fQ==
AUDITABLE-MODULES-->
<!-- notebook settings: JSON {theme, fontSize, width, ...} -->
<!--AUDITABLE-SETTINGS
{"theme":"dark","fontSize":13,"width":"860"}
AUDITABLE-SETTINGS-->

<script>
// -- state.js --

// ═══════════════════════════════════════════════════
// AUDITABLE — reactive notebook runtime
// Geoscientific Chaos Union, 2025
// ═══════════════════════════════════════════════════

const $ = s => document.querySelector(s);
const $$ = s => [...document.querySelectorAll(s)];

// ── STATE ──
const S = {
  cells: [],        // { id, type, code, el, defines, uses, output, error }
  scope: {},        // shared variable scope
  cellId: 0,        // unique cell ID counter
  editTimer: null,  // debounce timer for autorun
  autorun: true,    // reactive mode flag
  selectedId: null, // currently selected cell
  pendingD: false,  // for "dd" double-tap delete
  pendingDTimer: null,
  clipboard: null,  // copied cell data
  trash: [],        // undo stack for deleted cells
  findActive: false,
  findQuery: '',
  findCase: false,
  findRegex: false,
  findMatches: [],   // { cellId, index, length }
  findCurrent: -1,
  initialized: false, // set after loadFromEmbed/init completes
};

const JS_KEYWORDS = new Set([
  'const','let','var','function','return','if','else','for','while','do',
  'switch','case','break','continue','new','this','class','extends','import',
  'export','default','from','of','in','typeof','instanceof','void','delete',
  'throw','try','catch','finally','async','await','yield','true','false',
  'null','undefined','NaN','Infinity'
]);

const JS_BUILTINS = new Set([
  'Math','Array','Object','String','Number','Float64Array','Float32Array',
  'Int32Array','Uint8Array','Map','Set','Promise','console','JSON',
  'ui','std','load','install','print',
  'workshop','notebook','md','html','css'
]);


// -- stdlib.js --

// ── STDLIB ──
// Bundled standard library for notebook work.
// Module-level — no per-cell state needed.

// ── Provider Registry ──

const _providers = { file: null, download: null };

function registerProvider(name, fn) {
  if (name in _providers) _providers[name] = fn;
}

// ── Data ──

function csv(text, opts = {}) {
  const sep = opts.separator || ',';
  const typed = !!opts.typed;
  const lines = [];
  let i = 0;
  const len = text.length;

  while (i < len) {
    const row = [];
    while (i < len) {
      if (text[i] === '"') {
        // quoted field
        i++;
        let field = '';
        while (i < len) {
          if (text[i] === '"') {
            if (text[i + 1] === '"') { field += '"'; i += 2; }
            else { i++; break; }
          } else { field += text[i]; i++; }
        }
        row.push(field);
        if (text[i] === sep) i++;
        else if (text[i] === '\r') { i++; if (text[i] === '\n') i++; break; }
        else if (text[i] === '\n') { i++; break; }
        else if (i >= len) break;
      } else {
        // unquoted field
        let field = '';
        while (i < len && text[i] !== sep && text[i] !== '\n' && text[i] !== '\r') {
          field += text[i]; i++;
        }
        row.push(field);
        if (text[i] === sep) i++;
        else if (text[i] === '\r') { i++; if (text[i] === '\n') i++; break; }
        else if (text[i] === '\n') { i++; break; }
        else break;
      }
    }
    if (row.length > 0 && !(row.length === 1 && row[0] === '')) lines.push(row);
  }

  if (lines.length < 2) return [];
  const headers = lines[0];
  const result = [];
  for (let r = 1; r < lines.length; r++) {
    const obj = {};
    for (let c = 0; c < headers.length; c++) {
      let val = lines[r][c] !== undefined ? lines[r][c] : '';
      if (typed) {
        const num = Number(val);
        if (val !== '' && !isNaN(num)) val = num;
        else if (val === 'true') val = true;
        else if (val === 'false') val = false;
        else if (val === '') val = null;
      }
      obj[headers[c]] = val;
    }
    result.push(obj);
  }
  return result;
}

async function fetchJSON(url) {
  const resp = await fetch(url);
  if (!resp.ok) throw new Error(`fetchJSON: ${resp.status} ${resp.statusText}`);
  return resp.json();
}

// ── Math / Stats ──

function _acc(arr, fn) {
  return fn ? arr.map(fn) : arr;
}

function sum(arr, fn) {
  const vals = _acc(arr, fn);
  let s = 0;
  for (let i = 0; i < vals.length; i++) s += vals[i];
  return s;
}

function mean(arr, fn) {
  if (!arr.length) return NaN;
  return sum(arr, fn) / arr.length;
}

function median(arr, fn) {
  const vals = _acc(arr, fn).slice().sort((a, b) => a - b);
  const n = vals.length;
  if (n === 0) return NaN;
  if (n % 2 === 1) return vals[(n - 1) / 2];
  return (vals[n / 2 - 1] + vals[n / 2]) / 2;
}

function extent(arr, fn) {
  const vals = _acc(arr, fn);
  let lo = Infinity, hi = -Infinity;
  for (let i = 0; i < vals.length; i++) {
    if (vals[i] < lo) lo = vals[i];
    if (vals[i] > hi) hi = vals[i];
  }
  return [lo, hi];
}

function bin(arr, n = 10, fn) {
  const vals = _acc(arr, fn);
  const [lo, hi] = extent(vals);
  const range = hi - lo || 1;
  const step = range / n;
  const bins = [];
  for (let i = 0; i < n; i++) {
    bins.push({ x0: lo + i * step, x1: lo + (i + 1) * step, values: [] });
  }
  for (const v of vals) {
    let idx = Math.floor((v - lo) / step);
    if (idx >= n) idx = n - 1;
    if (idx < 0) idx = 0;
    bins[idx].values.push(v);
  }
  return bins;
}

function linspace(start, stop, n) {
  if (n < 2) return n === 1 ? [start] : [];
  const result = new Array(n);
  const step = (stop - start) / (n - 1);
  for (let i = 0; i < n; i++) result[i] = start + i * step;
  result[n - 1] = stop; // exact endpoint
  return result;
}

// ── Array ──

function unique(arr, fn) {
  if (!fn) return [...new Set(arr)];
  const seen = new Set();
  const result = [];
  for (const item of arr) {
    const key = fn(item);
    if (!seen.has(key)) { seen.add(key); result.push(item); }
  }
  return result;
}

function zip(...arrays) {
  const len = Math.min(...arrays.map(a => a.length));
  const result = new Array(len);
  for (let i = 0; i < len; i++) {
    result[i] = arrays.map(a => a[i]);
  }
  return result;
}

function cross(...arrays) {
  if (arrays.length === 0) return [[]];
  const [first, ...rest] = arrays;
  const sub = cross(...rest);
  const result = [];
  for (const item of first) {
    for (const tail of sub) {
      result.push([item, ...tail]);
    }
  }
  return result;
}

// ── DOM / IO ──

async function file(accept) {
  if (_providers.file) return _providers.file(accept);
  return new Promise((resolve, reject) => {
    const input = document.createElement('input');
    input.type = 'file';
    if (accept) input.accept = accept;
    input.onchange = async () => {
      const f = input.files[0];
      if (!f) { reject(new Error('no file selected')); return; }
      const text = await f.text();
      resolve({ name: f.name, text, size: f.size });
    };
    input.click();
  });
}

function download(data, filename, mimeType) {
  if (_providers.download) return _providers.download(data, filename, mimeType);
  const str = typeof data === 'string' ? data : JSON.stringify(data, null, 2);
  const mime = mimeType || (typeof data === 'string' ? 'text/plain' : 'application/json');
  const blob = new Blob([str], { type: mime });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename || 'download';
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  setTimeout(() => URL.revokeObjectURL(url), 1000);
}

function el(tag, attrs, ...children) {
  const elem = document.createElement(tag);
  if (attrs && typeof attrs === 'object' && !(attrs instanceof Node)) {
    for (const [k, v] of Object.entries(attrs)) {
      if (k === 'style' && typeof v === 'object') {
        Object.assign(elem.style, v);
      } else if (k.startsWith('on') && typeof v === 'function') {
        elem.addEventListener(k.slice(2), v);
      } else {
        elem.setAttribute(k, v);
      }
    }
  } else if (attrs != null) {
    // attrs is actually a child
    children.unshift(attrs);
  }
  for (const child of children) {
    if (child instanceof Node) elem.appendChild(child);
    else if (child != null) elem.appendChild(document.createTextNode(String(child)));
  }
  return elem;
}

async function copy(text) {
  await navigator.clipboard.writeText(text);
}

function fmt(number, opts = {}) {
  const { decimals, prefix, suffix } = opts;
  let s = decimals != null ? number.toFixed(decimals)
    : new Intl.NumberFormat(undefined, { maximumFractionDigits: 6 }).format(number);
  if (prefix) s = prefix + s;
  if (suffix) s = s + suffix;
  return s;
}

// ── Export ──

const std = {
  csv, fetchJSON,
  sum, mean, median, extent, bin, linspace,
  unique, zip, cross,
  file, download, el, copy, fmt,
};

// -- python.js --

// ── @python COMPAT HELPERS ──
// Python-familiar functions for users transitioning from Python.
// Each has a .help property showing the idiomatic JS equivalent.

function range(a, b, step) {
  let start, stop, s;
  if (b === undefined) { start = 0; stop = a; s = 1; }
  else { start = a; stop = b; s = step || 1; }
  const result = [];
  if (s > 0) { for (let i = start; i < stop; i += s) result.push(i); }
  else if (s < 0) { for (let i = start; i > stop; i += s) result.push(i); }
  return result;
}
range.help = 'JS: Array.from({length: n}, (_, i) => start + i * step)';

function enumerate(arr) {
  return arr.map((v, i) => [i, v]);
}
enumerate.help = 'JS: arr.map((v, i) => [i, v]) or arr.entries()';

function len(x) {
  if (x == null) throw new TypeError('len() of unsized object');
  if (x.size !== undefined) return x.size;
  return x.length;
}
len.help = 'JS: x.length or x.size';

function sorted(arr, key, reverse) {
  const copy = [...arr];
  if (key) copy.sort((a, b) => {
    const ka = key(a), kb = key(b);
    return ka < kb ? -1 : ka > kb ? 1 : 0;
  });
  else copy.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
  if (reverse) copy.reverse();
  return copy;
}
sorted.help = 'JS: arr.toSorted((a, b) => ...)';

function reversed(arr) {
  return [...arr].reverse();
}
reversed.help = 'JS: arr.toReversed()';

function isinstance(obj, cls) {
  return obj instanceof cls;
}
isinstance.help = 'JS: obj instanceof cls';

function type(x) {
  if (x === null) return 'null';
  if (Array.isArray(x)) return 'array';
  return typeof x;
}
type.help = 'JS: typeof x';

const python = {
  range, enumerate, len, sorted, reversed,
  isinstance, type,
};

function zenOfPython() {
  return [
    'The Zen of Python, by Tim Peters',
    '',
    'Beautiful is better than ugly.',
    'Explicit is better than implicit.',
    'Simple is better than complex.',
    'Complex is better than complicated.',
    'Flat is better than nested.',
    'Sparse is better than dense.',
    'Readability counts.',
    "Special cases aren't special enough to break the rules.",
    'Although practicality beats purity.',
    'Errors should never pass silently.',
    'Unless explicitly silenced.',
    'In the face of ambiguity, refuse the temptation to guess.',
    'There should be one-- and preferably only one --obvious way to do it.',
    "Although that way may not be obvious at first unless you're Dutch.",
    'Now is better than never.',
    'Although never is often better than *right* now.',
    "If the implementation is hard to explain, it's a bad idea.",
    'If the implementation is easy to explain, it may be a good idea.',
    "Namespaces are one honking great idea -- let's do more of those!",
  ].join('\n');
}

// -- syntax.js --

// ── SYNTAX HIGHLIGHTING ──

const CSS_NAMED_COLORS = new Set([
  'black','silver','gray','white','maroon','red','purple','fuchsia',
  'green','lime','olive','yellow','navy','blue','teal','aqua','orange'
]);

// detect curried tagged template: scan back through tokens for lang({...})`
function detectCurriedTag(tokens) {
  // last non-whitespace token must be )
  let j = tokens.length - 1;
  while (j >= 0 && tokens[j].type === '') j--;
  if (j < 0 || tokens[j].text !== ')') return null;
  // scan back to matching (
  let depth = 1;
  j--;
  while (j >= 0 && depth > 0) {
    if (tokens[j].text === ')') depth++;
    else if (tokens[j].text === '(') depth--;
    j--;
  }
  // token before ( should be the language name
  while (j >= 0 && tokens[j].type === '') j--;
  if (j < 0) return null;
  const name = tokens[j].text;
  if (window._taggedLanguages && window._taggedLanguages[name]) {
    return window._taggedLanguages[name];
  }
  return null;
}

// tokenize a tagged template literal starting at the opening backtick
function tokenizeTaggedTemplate(code, i, len, lang, tokens) {
  tokens.push({ type: 'punc', text: '`' });
  i++; // skip opening backtick
  let strBuf = '';
  while (i < len && code[i] !== '`') {
    if (code[i] === '\\') {
      strBuf += code[i] + (i + 1 < len ? code[i + 1] : '');
      i += 2;
      continue;
    }
    if (code[i] === '$' && i + 1 < len && code[i + 1] === '{') {
      if (strBuf) {
        tokens.push(...lang.tokenize(strBuf));
        strBuf = '';
      }
      tokens.push({ type: 'punc', text: '${' });
      i += 2;
      let depth = 1;
      let exprStart = i;
      while (i < len && depth > 0) {
        if (code[i] === '{') depth++;
        else if (code[i] === '}') { depth--; if (depth === 0) break; }
        else if (code[i] === '`') {
          i++;
          while (i < len && code[i] !== '`') {
            if (code[i] === '\\') i++;
            i++;
          }
        } else if (code[i] === '"' || code[i] === "'") {
          const q = code[i]; i++;
          while (i < len && code[i] !== q) {
            if (code[i] === '\\') i++;
            i++;
          }
        }
        i++;
      }
      const expr = code.slice(exprStart, i);
      if (expr) tokens.push(...tokenize(expr));
      if (i < len && code[i] === '}') {
        tokens.push({ type: 'punc', text: '}' });
        i++;
      }
      continue;
    }
    strBuf += code[i];
    i++;
  }
  if (strBuf) tokens.push(...lang.tokenize(strBuf));
  if (i < len && code[i] === '`') {
    tokens.push({ type: 'punc', text: '`' });
    i++;
  }
  return i;
}

function tokenize(code) {
  const tokens = [];
  let i = 0;
  const len = code.length;

  while (i < len) {
    // line comment
    if (code[i] === '/' && code[i+1] === '/') {
      const start = i;
      while (i < len && code[i] !== '\n') i++;
      tokens.push({ type: 'cmt', text: code.slice(start, i) });
      continue;
    }
    // block comment
    if (code[i] === '/' && code[i+1] === '*') {
      const start = i;
      i += 2;
      while (i < len && !(code[i-1] === '*' && code[i] === '/')) i++;
      if (i < len) i++;
      tokens.push({ type: 'cmt', text: code.slice(start, i) });
      continue;
    }
    // strings
    if (code[i] === '"' || code[i] === "'" || code[i] === '`') {
      // curried tagged template: lang({...})`...` — detect before treating as plain string
      if (code[i] === '`' && typeof window !== 'undefined' && window._taggedLanguages) {
        const lang = detectCurriedTag(tokens);
        if (lang) {
          i = tokenizeTaggedTemplate(code, i, len, lang, tokens);
          continue;
        }
      }
      const q = code[i];
      const start = i;
      i++;
      while (i < len && code[i] !== q) {
        if (code[i] === '\\') i++;
        i++;
      }
      if (i < len) i++;
      tokens.push({ type: 'str', text: code.slice(start, i) });
      continue;
    }
    // numbers
    if (/\d/.test(code[i]) || (code[i] === '.' && i+1 < len && /\d/.test(code[i+1]))) {
      const start = i;
      if (code[i] === '0' && (code[i+1] === 'x' || code[i+1] === 'X')) {
        i += 2;
        while (i < len && /[0-9a-fA-F_]/.test(code[i])) i++;
      } else {
        while (i < len && /[0-9._eE+-]/.test(code[i])) i++;
      }
      tokens.push({ type: 'num', text: code.slice(start, i) });
      continue;
    }
    // identifiers / keywords
    if (/[a-zA-Z_$]/.test(code[i])) {
      const start = i;
      while (i < len && /\w/.test(code[i])) i++;
      const word = code.slice(start, i);

      // tagged template literal — delegate to registered language tokenizer
      if (i < len && code[i] === '`' && typeof window !== 'undefined'
          && window._taggedLanguages && window._taggedLanguages[word]) {
        tokens.push({ type: 'fn', text: word });
        i = tokenizeTaggedTemplate(code, i, len, window._taggedLanguages[word], tokens);
        continue;
      }

      if (JS_KEYWORDS.has(word)) {
        tokens.push({ type: 'kw', text: word });
      } else if (JS_BUILTINS.has(word)) {
        tokens.push({ type: 'const', text: word });
      } else if (i < len && code[i] === '(') {
        tokens.push({ type: 'fn', text: word });
      } else {
        tokens.push({ type: 'id', text: word });
      }
      continue;
    }
    // operators
    if ('=+-*/<>!&|^~%?:'.includes(code[i])) {
      tokens.push({ type: 'op', text: code[i] });
      i++;
      continue;
    }
    // punctuation
    if ('(){}[];,.'.includes(code[i])) {
      tokens.push({ type: 'punc', text: code[i] });
      i++;
      continue;
    }
    // whitespace / other — pass through
    tokens.push({ type: '', text: code[i] });
    i++;
  }

  return tokens;
}

function highlightCode(ta, hl) {
  const code = ta.value;
  if (!code) { hl.innerHTML = '\n'; return; }

  const tokens = tokenize(code);
  let html = '';
  for (const t of tokens) {
    const escaped = t.text
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;');
    if (t.type && t.type !== 'id') {
      html += `<span class="hl-${t.type}">${escaped}</span>`;
    } else {
      html += escaped;
    }
  }
  // trailing newline so highlight layer matches textarea height
  hl.innerHTML = html + '\n';
}

// ── CSS SYNTAX HIGHLIGHTING ──

function tokenizeCss(code) {
  const tokens = [];
  let i = 0;
  const len = code.length;
  let ctx = 'sel'; // 'sel' | 'prop' | 'val'
  let depth = 0;

  while (i < len) {
    // block comment
    if (code[i] === '/' && code[i+1] === '*') {
      const start = i;
      i += 2;
      while (i < len && !(code[i-1] === '*' && code[i] === '/')) i++;
      if (i < len) i++;
      tokens.push({ type: 'cmt', text: code.slice(start, i) });
      continue;
    }
    // strings
    if (code[i] === '"' || code[i] === "'") {
      const q = code[i];
      const start = i;
      i++;
      while (i < len && code[i] !== q) {
        if (code[i] === '\\') i++;
        i++;
      }
      if (i < len) i++;
      tokens.push({ type: 'str', text: code.slice(start, i) });
      continue;
    }
    // punctuation with context transitions
    if (code[i] === '{') {
      tokens.push({ type: 'punc', text: '{' });
      depth++;
      ctx = 'prop';
      i++;
      continue;
    }
    if (code[i] === '}') {
      tokens.push({ type: 'punc', text: '}' });
      depth--;
      ctx = depth > 0 ? 'prop' : 'sel';
      i++;
      continue;
    }
    if (code[i] === ':' && ctx === 'prop') {
      tokens.push({ type: 'punc', text: ':' });
      ctx = 'val';
      i++;
      continue;
    }
    if (code[i] === ';') {
      tokens.push({ type: 'punc', text: ';' });
      ctx = 'prop';
      i++;
      continue;
    }
    if ('(),'.includes(code[i])) {
      tokens.push({ type: 'punc', text: code[i] });
      i++;
      continue;
    }
    // @-rules
    if (code[i] === '@') {
      const start = i;
      i++;
      while (i < len && /[a-zA-Z-]/.test(code[i])) i++;
      tokens.push({ type: 'atrule', text: code.slice(start, i) });
      continue;
    }
    // !important
    if (code[i] === '!' && ctx === 'val') {
      const start = i;
      i++;
      while (i < len && /[a-zA-Z]/.test(code[i])) i++;
      tokens.push({ type: 'important', text: code.slice(start, i) });
      continue;
    }
    // # — hex color in val, ID selector in sel
    if (code[i] === '#') {
      if (ctx === 'val') {
        const start = i;
        i++;
        while (i < len && /[0-9a-fA-F]/.test(code[i])) i++;
        tokens.push({ type: 'color', text: code.slice(start, i) });
      } else {
        // ID selector
        const start = i;
        i++;
        while (i < len && /[\w-]/.test(code[i])) i++;
        tokens.push({ type: 'sel', text: code.slice(start, i) });
      }
      continue;
    }
    // : in selector context = pseudo-class
    if (code[i] === ':' && ctx === 'sel') {
      const start = i;
      i++;
      if (i < len && code[i] === ':') i++; // ::
      while (i < len && /[a-zA-Z-]/.test(code[i])) i++;
      // handle pseudo with parens like :nth-child(...)
      if (i < len && code[i] === '(') {
        i++;
        let pdepth = 1;
        while (i < len && pdepth > 0) {
          if (code[i] === '(') pdepth++;
          else if (code[i] === ')') pdepth--;
          if (pdepth > 0) i++;
        }
        if (i < len) i++;
      }
      tokens.push({ type: 'sel', text: code.slice(start, i) });
      continue;
    }
    // . in selector context = class selector
    if (code[i] === '.' && ctx === 'sel') {
      const start = i;
      i++;
      while (i < len && /[\w-]/.test(code[i])) i++;
      tokens.push({ type: 'sel', text: code.slice(start, i) });
      continue;
    }
    // numbers (with units)
    if (ctx === 'val' && (/\d/.test(code[i]) || (code[i] === '.' && i+1 < len && /\d/.test(code[i+1])))) {
      const start = i;
      while (i < len && /[0-9.]/.test(code[i])) i++;
      // units
      while (i < len && /[a-zA-Z%]/.test(code[i])) i++;
      tokens.push({ type: 'num', text: code.slice(start, i) });
      continue;
    }
    // identifiers
    if (/[a-zA-Z_-]/.test(code[i])) {
      const start = i;
      while (i < len && /[\w-]/.test(code[i])) i++;
      const word = code.slice(start, i);
      // function call
      if (i < len && code[i] === '(') {
        tokens.push({ type: 'fn', text: word });
        continue;
      }
      if (ctx === 'val' && CSS_NAMED_COLORS.has(word.toLowerCase())) {
        tokens.push({ type: 'color', text: word });
      } else if (ctx === 'prop') {
        tokens.push({ type: 'prop', text: word });
      } else if (ctx === 'sel') {
        tokens.push({ type: 'sel', text: word });
      } else {
        tokens.push({ type: '', text: word });
      }
      continue;
    }
    // whitespace / other
    tokens.push({ type: '', text: code[i] });
    i++;
  }

  return tokens;
}

function resolveToHex(colorStr) {
  const d = document.createElement('div');
  d.style.color = colorStr;
  document.body.appendChild(d);
  const rgb = getComputedStyle(d).color;
  d.remove();
  const m = rgb.match(/(\d+)/g);
  if (!m || m.length < 3) return colorStr;
  return '#' + m.slice(0, 3).map(n => parseInt(n).toString(16).padStart(2, '0')).join('');
}

let _colorPicker = null;
let _pickerTarget = null; // { ta, offset, len }

function ensureColorPicker() {
  if (_colorPicker) return _colorPicker;
  _colorPicker = document.createElement('input');
  _colorPicker.type = 'color';
  _colorPicker.style.cssText = 'position:absolute;visibility:hidden;width:0;height:0;';
  document.body.appendChild(_colorPicker);
  _colorPicker.addEventListener('input', () => {
    if (!_pickerTarget) return;
    const { ta, offset, len } = _pickerTarget;
    const newColor = _colorPicker.value;
    ta.focus();
    ta.selectionStart = offset;
    ta.selectionEnd = offset + len;
    document.execCommand('insertText', false, newColor);
    ta.dispatchEvent(new Event('input'));
    // update offset for new length
    _pickerTarget.len = newColor.length;
  });
  return _colorPicker;
}

function highlightCss(ta, hl) {
  const code = ta.value;
  if (!code) { hl.innerHTML = '\n'; return; }

  const tokens = tokenizeCss(code);
  let html = '';
  let offset = 0;
  for (const t of tokens) {
    const escaped = t.text
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;');
    if (t.type === 'color') {
      const hex = resolveToHex(t.text);
      html += `<span class="hl-color"><span class="hl-swatch" style="background:${hex}" data-offset="${offset}" data-len="${t.text.length}"></span>${escaped}</span>`;
    } else if (t.type && t.type !== 'id') {
      html += `<span class="hl-${t.type}">${escaped}</span>`;
    } else {
      html += escaped;
    }
    offset += t.text.length;
  }
  hl.innerHTML = html + '\n';

  // wire swatch clicks (only add once per highlight layer)
  if (!hl._swatchWired) {
    hl._swatchWired = true;
    hl.addEventListener('click', (e) => {
      const swatch = e.target.closest('.hl-swatch');
      if (!swatch) return;
      const off = parseInt(swatch.dataset.offset);
      const len = parseInt(swatch.dataset.len);
      const picker = ensureColorPicker();
      _pickerTarget = { ta, offset: off, len };
      const hex = resolveToHex(ta.value.slice(off, off + len));
      picker.value = hex;
      picker.click();
    });
  }
}

// ── HTML SYNTAX HIGHLIGHTING ──

function tokenizeHtml(code) {
  const tokens = [];
  let i = 0;
  const len = code.length;

  while (i < len) {
    // template expression ${...}
    if (code[i] === '$' && i + 1 < len && code[i + 1] === '{') {
      const start = i;
      i += 2;
      let depth = 1;
      while (i < len && depth > 0) {
        if (code[i] === '{') depth++;
        else if (code[i] === '}') depth--;
        if (depth > 0) i++;
      }
      if (i < len) i++;
      tokens.push({ type: 'expr', text: code.slice(start, i) });
      continue;
    }
    // comment <!-- ... -->
    if (code[i] === '<' && code[i + 1] === '!' && code[i + 2] === '-' && code[i + 3] === '-') {
      const start = i;
      i += 4;
      while (i < len) {
        if (code[i] === '-' && code[i + 1] === '-' && code[i + 2] === '>') { i += 3; break; }
        i++;
      }
      tokens.push({ type: 'cmt', text: code.slice(start, i) });
      continue;
    }
    // tag
    if (code[i] === '<') {
      tokens.push({ type: 'tag', text: '<' });
      i++;
      // closing slash
      if (i < len && code[i] === '/') { tokens.push({ type: 'tag', text: '/' }); i++; }
      // tag name
      const ns = i;
      while (i < len && /[a-zA-Z0-9-]/.test(code[i])) i++;
      if (i > ns) tokens.push({ type: 'tag', text: code.slice(ns, i) });
      // attributes until >
      while (i < len && code[i] !== '>') {
        // template expression inside tag
        if (code[i] === '$' && i + 1 < len && code[i + 1] === '{') {
          const start = i;
          i += 2;
          let depth = 1;
          while (i < len && depth > 0) {
            if (code[i] === '{') depth++;
            else if (code[i] === '}') depth--;
            if (depth > 0) i++;
          }
          if (i < len) i++;
          tokens.push({ type: 'expr', text: code.slice(start, i) });
          continue;
        }
        if (/\s/.test(code[i])) { tokens.push({ type: '', text: code[i] }); i++; continue; }
        if (code[i] === '/') { tokens.push({ type: 'tag', text: '/' }); i++; continue; }
        if (code[i] === '=') { tokens.push({ type: 'punc', text: '=' }); i++; continue; }
        // quoted attribute value
        if (code[i] === '"' || code[i] === "'") {
          const q = code[i];
          const start = i;
          i++;
          while (i < len && code[i] !== q) { if (code[i] === '\\') i++; i++; }
          if (i < len) i++;
          tokens.push({ type: 'str', text: code.slice(start, i) });
          continue;
        }
        // attribute name or unquoted value
        const as = i;
        while (i < len && !/[\s=>/"']/.test(code[i])) i++;
        if (i > as) {
          let j = i;
          while (j < len && /\s/.test(code[j])) j++;
          tokens.push({ type: (j < len && code[j] === '=') ? 'attr' : 'attr', text: code.slice(as, i) });
        }
      }
      if (i < len && code[i] === '>') { tokens.push({ type: 'tag', text: '>' }); i++; }
      continue;
    }
    // plain text
    tokens.push({ type: '', text: code[i] });
    i++;
  }

  return tokens;
}

function highlightHtml(ta, hl) {
  const code = ta.value;
  if (!code) { hl.innerHTML = '\n'; return; }

  const tokens = tokenizeHtml(code);
  let html = '';
  for (const t of tokens) {
    const escaped = t.text
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;');
    if (t.type) {
      html += `<span class="hl-${t.type}">${escaped}</span>`;
    } else {
      html += escaped;
    }
  }
  hl.innerHTML = html + '\n';
}

// -- dag.js --

// ── REACTIVE DAG ──

// ── directive helpers ──

function hasDirective(code, name) {
  return new RegExp(String.raw`^\s*\/\/\s*%${name}\b`, 'm').test(code);
}

function getDirective(code, name) {
  const m = code.match(new RegExp(String.raw`^\s*\/\/\s*%${name}\s+(.+)`, 'm'));
  return m ? m[1].trim() : null;
}

const isManual    = code => hasDirective(code, 'manual');
const isHidden    = code => hasDirective(code, 'hide');
const isNorun     = code => hasDirective(code, 'norun');
const isCollapsed = code => hasDirective(code, 'collapsed');
const parseCellName    = code => getDirective(code, 'cellName');
const parseOutputId    = code => { const v = getDirective(code, 'outputId'); return v ? v.split(/\s+/)[0] : null; };
const parseOutputClass = code => getDirective(code, 'outputClass');

// ── code analysis ──

function stripCommentsAndStrings(code) {
  // single-pass: strings take precedence over comments (// inside "..." is not a comment)
  let out = '', i = 0;
  while (i < code.length) {
    // single-quoted string
    if (code[i] === "'") {
      out += '""';
      i++;
      while (i < code.length && code[i] !== "'") { if (code[i] === '\\') i++; i++; }
      i++; // skip closing quote
      continue;
    }
    // double-quoted string
    if (code[i] === '"') {
      out += '""';
      i++;
      while (i < code.length && code[i] !== '"') { if (code[i] === '\\') i++; i++; }
      i++; // skip closing quote
      continue;
    }
    // template literal: replace string parts with spaces but keep ${expr} content
    if (code[i] === '`') {
      i++;
      while (i < code.length && code[i] !== '`') {
        if (code[i] === '\\') { i += 2; continue; }
        if (code[i] === '$' && code[i + 1] === '{') {
          i += 2;
          let depth = 1;
          out += ' ';
          while (i < code.length && depth > 0) {
            if (code[i] === '{') depth++;
            else if (code[i] === '}') { depth--; if (depth === 0) break; }
            out += code[i];
            i++;
          }
          out += ' ';
          i++; // skip closing }
          continue;
        }
        i++;
      }
      i++; // skip closing backtick
      continue;
    }
    // line comment
    if (code[i] === '/' && code[i + 1] === '/') {
      while (i < code.length && code[i] !== '\n') i++;
      continue;
    }
    // block comment
    if (code[i] === '/' && code[i + 1] === '*') {
      i += 2;
      while (i < code.length && !(code[i - 1] === '*' && code[i] === '/')) i++;
      i++;
      continue;
    }
    out += code[i];
    i++;
  }
  return out;
}

function parseNames(code) {
  // extract ONLY top-level variable definitions (brace depth 0)
  const defines = new Set();

  const stripped = stripCommentsAndStrings(code);

  let depth = 0;
  let parenDepth = 0;
  let i = 0;
  while (i < stripped.length) {
    const ch = stripped[i];
    if (ch === '{') { depth++; i++; continue; }
    if (ch === '}') { depth--; i++; continue; }
    if (ch === '(') { parenDepth++; i++; continue; }
    if (ch === ')') { parenDepth--; i++; continue; }

    if (depth === 0 && parenDepth === 0) {
      // check for const/let/var
      const rest = stripped.slice(i);
      const dm = rest.match(/^(?:const|let|var)\s+(\w+)/);
      if (dm) {
        defines.add(dm[1]);
        // scan forward for comma-separated declarations: const W = 80, H = 60
        // skip initializer expressions tracking depth, grab identifiers after commas
        let j = dm[0].length;
        let d = 0, pd = 0, bd = 0;
        while (j < rest.length) {
          const ch = rest[j];
          if (ch === '{') d++;
          else if (ch === '}') d--;
          else if (ch === '(') pd++;
          else if (ch === ')') pd--;
          else if (ch === '[') bd++;
          else if (ch === ']') bd--;
          else if (ch === ';' || ch === '\n') {
            if (d === 0 && pd === 0 && bd === 0) break;
          }
          else if (ch === ',' && d === 0 && pd === 0 && bd === 0) {
            // next identifier after comma
            const after = rest.slice(j + 1).match(/^\s*(\w+)/);
            if (after) defines.add(after[1]);
          }
          j++;
        }
        i += j;
        continue;
      }
      // destructuring: const { a, b } = ... or const [ a, b ] = ...
      const destruct = rest.match(/^(?:const|let|var)\s*[\{\[]/);
      if (destruct) {
        // find the closing } or ] then extract identifiers
        const opener = rest[destruct[0].length - 1];
        const closer = opener === '{' ? '}' : ']';
        const closeIdx = rest.indexOf(closer, destruct[0].length);
        if (closeIdx > 0) {
          const inner = rest.slice(destruct[0].length, closeIdx);
          // split on commas, take last word of each part (handles renaming)
          inner.split(',').forEach(part => {
            const parts = part.trim().split(/\s*:\s*/);
            const name = (parts.length > 1 ? parts[1] : parts[0]).trim().match(/^\w+/);
            if (name) defines.add(name[0]);
          });
          i += closeIdx + 1;
          continue;
        }
      }
      // check for function declarations
      const fm = rest.match(/^function\s+(\w+)/);
      if (fm) {
        defines.add(fm[1]);
        i += fm[0].length;
        continue;
      }
    }
    i++;
  }

  return { defines };
}

function findUses(code, allDefined, selfDefined) {
  // find identifiers that reference other cells' definitions
  const uses = new Set();
  const stripped = stripCommentsAndStrings(code);
  if (!selfDefined) selfDefined = parseNames(code).defines;

  const idRe = /\b([a-zA-Z_$]\w*)\b/g;
  let m;
  while ((m = idRe.exec(stripped))) {
    if (allDefined.has(m[1]) && !selfDefined.has(m[1])) {
      uses.add(m[1]);
    }
  }
  return uses;
}

function findHtmlUses(code, allDefined) {
  const uses = new Set();
  const re = /\$\{([^}]+)\}/g;
  let m;
  while ((m = re.exec(code))) {
    const expr = m[1];
    const idRe = /\b([a-zA-Z_$]\w*)\b/g;
    let im;
    while ((im = idRe.exec(expr))) {
      if (allDefined.has(im[1])) uses.add(im[1]);
    }
  }
  return uses;
}

function buildDAG() {
  // collect all defined names globally (only re-parse changed cells)
  const allDefined = new Map(); // name -> cell id
  for (const c of S.cells) {
    if (c.type !== 'code') continue;
    if (c.code !== c._parsedCode) {
      const { defines } = parseNames(c.code);
      c.defines = defines;
      c._parsedCode = c.code;
    }
    for (const name of c.defines) {
      allDefined.set(name, c.id);
    }
  }

  // find uses for each cell (invalidate if code changed or global names changed)
  const definedNames = new Set(allDefined.keys());
  const definedKey = [...definedNames].sort().join(',');
  for (const c of S.cells) {
    if (c.type === 'code') {
      if (c.code !== c._usesCode || c._definedKey !== definedKey) {
        c.uses = findUses(c.code, definedNames, c.defines);
        c._usesCode = c.code;
        c._definedKey = definedKey;
      }
    } else if (c.type === 'html') {
      if (c.code !== c._usesCode || c._definedKey !== definedKey) {
        c.uses = findHtmlUses(c.code, definedNames);
        c._usesCode = c.code;
        c._definedKey = definedKey;
      }
    }
  }

  return allDefined;
}

function topoSort(dirtyIds) {
  // BFS from dirty cells to find all downstream dependents
  const dependents = new Map(); // varName -> Set<cellId>
  for (const c of S.cells) {
    if (!c.uses) continue;
    for (const name of c.uses) {
      if (!dependents.has(name)) dependents.set(name, new Set());
      dependents.get(name).add(c.id);
    }
  }

  const needsRun = new Set(dirtyIds);
  const queue = [...dirtyIds];
  while (queue.length) {
    const id = queue.shift();
    const cell = S.cells.find(c => c.id === id);
    if (!cell || !cell.defines) continue;
    for (const name of cell.defines) {
      const deps = dependents.get(name);
      if (!deps) continue;
      for (const depId of deps) {
        if (!needsRun.has(depId)) {
          needsRun.add(depId);
          queue.push(depId);
        }
      }
    }
  }

  // return in document order
  return S.cells.filter(c => needsRun.has(c.id)).map(c => c.id);
}

// -- exec.js --

// ── EXECUTION ENGINE ──
//
// Scope model: each cell runs inside an AsyncFunction where upstream variables
// are passed as parameters. This is pass-by-value for primitives — reassigning
// a variable in cell A (e.g. `grid = next`) does NOT propagate to cell B.
// Mutable state that needs to survive across callbacks belongs in %manual cells
// using DOM elements, objects, or closures.
//
// Cell builtins (display, canvas, slider, load, install, installBinary, etc.)
// are injected as additional parameters — listed in _injected, not in scope.
// They are NOT propagated to downstream cells.

// ── BINARY HELPERS ──

function uint8ToBase64(bytes) {
  let bin = '';
  for (let i = 0; i < bytes.length; i++) bin += String.fromCharCode(bytes[i]);
  return btoa(bin);
}

async function decodeBinary(entry) {
  const type = entry.type || 'application/octet-stream';
  const bytes = Uint8Array.from(atob(entry.source), c => c.charCodeAt(0));
  if (entry.compressed) {
    const ds = new DecompressionStream('gzip');
    const stream = new Blob([bytes]).stream().pipeThrough(ds);
    const decompressed = new Uint8Array(await new Response(stream).arrayBuffer());
    return URL.createObjectURL(new Blob([decompressed], { type }));
  }
  return URL.createObjectURL(new Blob([bytes], { type }));
}

// ── TAGGED CONTENT ──

class TaggedContent {
  constructor(type, content) { this.type = type; this.content = content; }
  toString() { return this.content; }
}

function taggedTemplate(type) {
  return (strings, ...values) => {
    let result = strings[0];
    for (let i = 0; i < values.length; i++) result += String(values[i]) + strings[i + 1];
    return new TaggedContent(type, result);
  };
}

// ── EXECUTION ──

function renderHtmlCell(cell) {
  const viewEl = cell.el.querySelector('.cell-html-view');
  const outputEl = cell.el.querySelector('.cell-output');
  if (!viewEl) return;
  if (outputEl) { outputEl.textContent = ''; outputEl.className = 'cell-output'; }

  // use only variables this cell references for stable function signatures
  const scopeKeys = cell.uses ? [...cell.uses].sort() : [];
  const scopeVals = scopeKeys.map(k => S.scope[k]);

  // cache compiled template functions per expression
  if (!cell._tplCache) cell._tplCache = {};
  const scopeSig = scopeKeys.join(',');
  if (cell._tplScopeSig !== scopeSig) {
    cell._tplCache = {};  // scope signature changed, invalidate all
    cell._tplScopeSig = scopeSig;
  }

  let rendered = cell.code.replace(/\$\{([^}]+)\}/g, (match, expr) => {
    try {
      let fn = cell._tplCache[expr];
      if (!fn) {
        fn = new Function(...scopeKeys, '"use strict"; return (' + expr + ')');
        cell._tplCache[expr] = fn;
      }
      const val = fn(...scopeVals);
      return val === undefined ? '' : String(val);
    } catch (e) {
      return '[Error: ' + e.message + ']';
    }
  });

  viewEl.innerHTML = rendered;
  cell.el.classList.remove('stale', 'error');
  cell.el.classList.add('fresh');
  setTimeout(() => cell.el.classList.remove('fresh'), 800);
}

async function execCell(cell) {
  // fire invalidation promise from previous run (cleanup resources)
  if (cell._invalidate) { cell._invalidate(); cell._invalidate = null; }

  const outputEl = cell.el.querySelector('.cell-output');
  const widgetEl = cell.el.querySelector('.cell-widgets');

  // preserve canvases before clearing output
  const prevCanvases = [...outputEl.querySelectorAll('canvas')];
  outputEl.textContent = '';
  outputEl.className = 'cell-output';
  const outClass = parseOutputClass(cell.code);
  if (outClass) outputEl.classList.add(...outClass.split(/\s+/));
  const outId = parseOutputId(cell.code);
  outputEl.id = outId || '';
  cell.el.classList.toggle('present-hidden', isHidden(cell.code));
  cell.error = null;

  // create invalidation promise for this run
  let invalidationResolve;
  const invalidation = new Promise(r => { invalidationResolve = r; });
  cell._invalidate = invalidationResolve;

  // track which widgets are used this run
  const usedWidgets = new Set();
  let canvasIdx = 0;

  // build display function for this cell
  const display = (...args) => {
    for (const arg of args) {
      if (arg instanceof Element) {
        outputEl.appendChild(arg);
      } else if (typeof arg === 'object' && arg !== null) {
        const pre = document.createElement('span');
        try { pre.textContent = JSON.stringify(arg, null, 2); }
        catch { pre.textContent = String(arg); }
        outputEl.appendChild(pre);
        outputEl.appendChild(document.createTextNode('\n'));
      } else {
        outputEl.appendChild(document.createTextNode(String(arg) + '\n'));
      }
    }
  };

  // canvas helper — reuses existing canvas if dimensions match
  const canvas = (w = 400, h = 300) => {
    const prev = prevCanvases[canvasIdx++];
    if (prev && prev.width === w && prev.height === h) {
      outputEl.appendChild(prev);
      return prev;
    }
    const c = document.createElement('canvas');
    c.width = w; c.height = h;
    c.style.background = '#000';
    outputEl.appendChild(c);
    return c;
  };

  // table helper
  const table = (data, columns) => {
    if (!data || !data.length) return;
    const cols = columns || Object.keys(data[0]);

    // detect numeric columns by scanning first 10 rows
    const isNumCol = {};
    for (const c of cols) {
      let allNum = true;
      const scanRows = data.slice(0, 10);
      for (const row of scanRows) {
        const v = row[c];
        if (v !== null && v !== undefined && typeof v !== 'number') { allNum = false; break; }
      }
      isNumCol[c] = allNum;
    }

    const t = document.createElement('table');
    const thead = document.createElement('thead');
    const hr = document.createElement('tr');
    for (const c of cols) {
      const th = document.createElement('th');
      th.textContent = c;
      th.style.textAlign = isNumCol[c] ? 'right' : 'left';
      hr.appendChild(th);
    }
    thead.appendChild(hr);
    t.appendChild(thead);
    const tbody = document.createElement('tbody');
    for (const row of data) {
      const tr = document.createElement('tr');
      for (const c of cols) {
        const td = document.createElement('td');
        const v = row[c];
        td.textContent = typeof v === 'number' ? (Number.isInteger(v) ? v : v.toFixed(4)) : String(v ?? '');
        td.style.textAlign = isNumCol[c] ? 'right' : 'left';
        tr.appendChild(td);
      }
      tbody.appendChild(tr);
    }
    t.appendChild(tbody);
    outputEl.appendChild(t);
  };

  // input widget helpers — persist state and DOM across re-runs
  if (!cell._inputs) cell._inputs = {};
  if (!cell._callbacks) cell._callbacks = {};

  const mkInput = (label, type, defaultVal, opts = {}) => {
    const key = label;
    const prev = cell._inputs[key];
    let val = prev !== undefined ? prev : defaultVal;
    usedWidgets.add(key);
    cell._callbacks[key] = { onInput: opts.onInput, onChange: opts.onChange };

    // check if widget DOM already exists
    const existing = widgetEl.querySelector(`[data-widget-key="${CSS.escape(key)}"]`);
    if (existing) {
      // update id/class in case they changed on re-run
      existing.id = opts.id || '';
      existing.className = 'cell-widget' + (opts.class ? ' ' + opts.class : '');
      // just return current value, DOM stays — callbacks already updated above
      cell._inputs[key] = type === 'slider' ? parseFloat(val)
                         : type === 'checkbox' ? !!val
                         : val;
      return cell._inputs[key];
    }

    // create new widget
    const wrap = document.createElement('div');
    wrap.dataset.widgetKey = key;
    wrap.className = 'cell-widget' + (opts.class ? ' ' + opts.class : '');
    if (opts.id) wrap.id = opts.id;

    const lbl = document.createElement('span');
    lbl.textContent = label;
    lbl.className = 'cell-widget-label';
    wrap.appendChild(lbl);

    let input;
    if (type === 'slider') {
      input = document.createElement('input');
      input.type = 'range';
      input.min = opts.min ?? 0;
      input.max = opts.max ?? 100;
      input.step = opts.step ?? 1;
      input.value = val;
      const valSpan = document.createElement('span');
      valSpan.textContent = val;
      valSpan.className = 'cell-widget-val';
      input.oninput = () => {
        const n = parseFloat(input.value);
        cell._inputs[key] = n;
        valSpan.textContent = n;
        const cb = cell._callbacks[key];
        if (cb.onInput) { cb.onInput(n); }
        else if (!cb.onChange) { clearTimeout(cell._inputTimer); cell._inputTimer = setTimeout(() => runDAG([cell.id], true), 80); }
      };
      input.onchange = () => { const cb = cell._callbacks[key]; if (cb.onChange) cb.onChange(parseFloat(input.value)); };
      wrap.appendChild(input);
      wrap.appendChild(valSpan);
    } else if (type === 'dropdown') {
      input = document.createElement('select');
      for (const o of (opts.options || [])) {
        const opt = document.createElement('option');
        opt.value = o;
        opt.textContent = o;
        if (o === val) opt.selected = true;
        input.appendChild(opt);
      }
      input.onchange = () => {
        cell._inputs[key] = input.value;
        const cb = cell._callbacks[key];
        if (cb.onInput || cb.onChange) {
          if (cb.onInput) cb.onInput(input.value);
          if (cb.onChange) cb.onChange(input.value);
        } else { runDAG([cell.id], true); }
      };
      wrap.appendChild(input);
    } else if (type === 'checkbox') {
      input = document.createElement('input');
      input.type = 'checkbox';
      input.checked = !!val;
      input.onchange = () => {
        cell._inputs[key] = input.checked;
        const cb = cell._callbacks[key];
        if (cb.onInput || cb.onChange) {
          if (cb.onInput) cb.onInput(input.checked);
          if (cb.onChange) cb.onChange(input.checked);
        } else { runDAG([cell.id], true); }
      };
      wrap.appendChild(input);
    } else if (type === 'text') {
      input = document.createElement('input');
      input.type = 'text';
      input.value = val;
      input.oninput = () => {
        cell._inputs[key] = input.value;
        const cb = cell._callbacks[key];
        if (cb.onInput) { cb.onInput(input.value); }
        else if (!cb.onChange) { clearTimeout(cell._inputTimer); cell._inputTimer = setTimeout(() => runDAG([cell.id], true), 300); }
      };
      input.onchange = () => { const cb = cell._callbacks[key]; if (cb.onChange) cb.onChange(input.value); };
      wrap.appendChild(input);
    }

    widgetEl.appendChild(wrap);
    cell._inputs[key] = type === 'slider' ? parseFloat(val)
                       : type === 'checkbox' ? !!val
                       : val;
    return cell._inputs[key];
  };

  const slider = (label, defaultVal = 50, opts = {}) => mkInput(label, 'slider', defaultVal, opts);
  const dropdown = (label, options, defaultVal, opts = {}) => mkInput(label, 'dropdown', defaultVal || options[0], { ...opts, options });
  const checkbox = (label, defaultVal = false, opts = {}) => mkInput(label, 'checkbox', defaultVal, opts);
  const textInput = (label, defaultVal = '', opts = {}) => mkInput(label, 'text', defaultVal, opts);

  // execute with scoped parameters (only what this cell uses, for stable V8 JIT)
  // filter out injected names — they're per-cell params, not scope-propagated
  const _injected = ['ui', 'std', 'load', 'install', 'installBinary', 'invalidation', 'print', 'md', 'html', 'css', 'workshop', 'notebook'];
  const scopeKeys = cell.uses ? [...cell.uses].filter(k => !_injected.includes(k)).sort() : [];
  const defNames = cell.defines ? [...cell.defines].sort().join(', ') : '';

  // import cache — shared across all cells
  if (!window._importCache) window._importCache = {};
  if (!window._installedModules) window._installedModules = {}; // url -> { source, cellId }

  const load = async (url) => {
    // virtual modules
    if (url === '@std') return std;
    if (url === '@python') return python;
    if (url === '@python/this') { display(zenOfPython()); return python; }
    if (window._importCache[url]) return window._importCache[url];

    // binary assets — return blob URL
    if (window._installedModules[url]?.binary) {
      const blobUrl = await decodeBinary(window._installedModules[url]);
      window._importCache[url] = blobUrl;
      return blobUrl;
    }

    const langsBefore = window._taggedLanguages ? Object.keys(window._taggedLanguages).length : 0;

    let mod;
    // check installed (offline) modules first
    if (window._installedModules[url]) {
      const entry = window._installedModules[url];
      let src = typeof entry === 'string' ? entry : entry.source;
      // resolve root-relative paths for legacy saved modules
      try { src = resolveModulePaths(src, url); } catch {}
      const blob = new Blob([src], { type: 'application/javascript' });
      const blobUrl = URL.createObjectURL(blob);
      mod = await import(blobUrl);
    } else {
      mod = await import(url);
    }
    window._importCache[url] = mod;

    // if the module registered new tagged languages, re-highlight all code cells
    const langsAfter = window._taggedLanguages ? Object.keys(window._taggedLanguages).length : 0;
    if (langsAfter > langsBefore) {
      for (const c of S.cells) {
        if (c.type !== 'code') continue;
        const ta = c.el.querySelector('textarea');
        const hl = c.el.querySelector('.highlight-layer');
        if (ta && hl) highlightCode(ta, hl);
      }
    }

    return mod;
  };

  // resolve root-relative paths in module source so blob URLs work
  const resolveModulePaths = (source, responseUrl) => {
    const origin = new URL(responseUrl).origin;
    return source.replace(/(from\s+["'])(\/[^"']+)(["'])/g, '$1' + origin + '$2$3')
                 .replace(/(import\s*\(["'])(\/[^"']+)(["']\))/g, '$1' + origin + '$2$3')
                 .replace(/(export\s+\*\s+from\s+["'])(\/[^"']+)(["'])/g, '$1' + origin + '$2$3')
                 .replace(/(export\s*\{[^}]*\}\s*from\s+["'])(\/[^"']+)(["'])/g, '$1' + origin + '$2$3');
  };

  const install = async (url) => {
    // normalize: add ?bundle for esm.sh if not present
    let bundleUrl = url;
    if (bundleUrl.includes('esm.sh') && !bundleUrl.includes('?bundle') && !bundleUrl.includes('&bundle')) {
      bundleUrl += (bundleUrl.includes('?') ? '&' : '?') + 'bundle';
    }
    // fetch source
    const resp = await fetch(bundleUrl);
    if (!resp.ok) throw new Error(`Failed to fetch ${bundleUrl}: ${resp.status}`);
    let source = await resp.text();
    // resolve root-relative paths to absolute so blob URLs work
    source = resolveModulePaths(source, resp.url);
    // store under original url with cell reference
    window._installedModules[url] = { source, cellId: cell.id };
    // also load it into cache
    const blob = new Blob([source], { type: 'application/javascript' });
    const blobUrl = URL.createObjectURL(blob);
    const mod = await import(blobUrl);
    window._importCache[url] = mod;
    display(`installed ${url} (${(source.length / 1024).toFixed(1)} KB)`);
    return mod;
  };

  const installBinary = async (url, opts = {}) => {
    const compress = opts.compress !== false;
    // if already installed, decode and return blob URL
    if (window._installedModules[url]?.binary) {
      return decodeBinary(window._installedModules[url]);
    }
    const resp = await fetch(url);
    if (!resp.ok) throw new Error(`Failed to fetch ${url}: ${resp.status}`);
    const contentType = resp.headers.get('content-type')?.split(';')[0] || 'application/octet-stream';
    const buf = await resp.arrayBuffer();
    const raw = new Uint8Array(buf);
    let stored, isCompressed = false;
    if (compress) {
      const cs = new CompressionStream('gzip');
      const stream = new Blob([raw]).stream().pipeThrough(cs);
      const compressed = new Uint8Array(await new Response(stream).arrayBuffer());
      stored = uint8ToBase64(compressed);
      isCompressed = true;
    } else {
      stored = uint8ToBase64(raw);
    }
    window._installedModules[url] = { source: stored, cellId: cell.id, binary: true, compressed: isCompressed, type: contentType };
    const ratio = isCompressed ? ` \u2192 ${(stored.length / 1024).toFixed(1)} KB compressed` : '';
    display(`installed binary ${url} (${(buf.byteLength / 1024).toFixed(1)} KB${ratio})`);
    return URL.createObjectURL(new Blob([raw], { type: contentType }));
  };

  // ui object — constructed per-cell (closes over cell context)
  const ui = { display, print: display, canvas, table, slider, dropdown, checkbox, textInput };

  // tagged template builtins
  const md = taggedTemplate('md');
  const html = taggedTemplate('html');
  const css = taggedTemplate('css');

  // workshop builtin — slide-out side panel with navigable pages
  const workshop = (pages, opts) => {
    const key = '__workshop__';
    usedWidgets.add(key);
    const useOverlay = !!(opts && opts.overlay);

    // persist page index across re-runs
    if (cell._inputs[key] === undefined) cell._inputs[key] = 0;
    let currentPage = cell._inputs[key];

    // get or create panel DOM
    let panel = document.getElementById('workshopPanel');
    let overlay = document.getElementById('workshopOverlay');
    if (!panel) {
      overlay = document.createElement('div');
      overlay.id = 'workshopOverlay';
      overlay.className = 'workshop-overlay';
      overlay.onclick = () => toggleWorkshop(false);
      document.body.appendChild(overlay);

      panel = document.createElement('div');
      panel.id = 'workshopPanel';
      panel.className = 'workshop-panel';
      document.body.appendChild(panel);
    }

    // side tab attached to the panel edge
    let toggleBtn = document.getElementById('workshopToggle');
    if (!toggleBtn) {
      toggleBtn = document.createElement('button');
      toggleBtn.id = 'workshopToggle';
      toggleBtn.className = 'workshop-tab';
      toggleBtn.title = 'toggle workshop panel';
      toggleBtn.textContent = 'workshop';
      document.body.appendChild(toggleBtn);
      toggleBtn.onclick = () => toggleWorkshop();
    }

    function toggleWorkshop(show) {
      const isOpen = panel.classList.contains('open');
      const shouldOpen = show !== undefined ? show : !isOpen;
      panel.classList.toggle('open', shouldOpen);
      if (useOverlay) overlay.classList.toggle('visible', shouldOpen);
    }

    function renderPage(idx) {
      idx = Math.max(0, Math.min(idx, pages.length - 1));
      currentPage = idx;
      cell._inputs[key] = idx;
      const page = pages[idx];

      panel.innerHTML = '';

      // header with close button
      const header = document.createElement('div');
      header.className = 'workshop-header';
      const title = document.createElement('span');
      title.className = 'workshop-title';
      title.textContent = page.title || `Page ${idx + 1}`;
      header.appendChild(title);
      const closeBtn = document.createElement('button');
      closeBtn.className = 'workshop-close';
      closeBtn.textContent = '\u00d7';
      closeBtn.onclick = () => toggleWorkshop(false);
      header.appendChild(closeBtn);
      panel.appendChild(header);

      // content
      const body = document.createElement('div');
      body.className = 'workshop-body';
      if (page.content instanceof Element) {
        body.appendChild(page.content);
      } else if (page.content instanceof TaggedContent) {
        if (page.content.type === 'md') {
          body.innerHTML = renderMd(page.content.content);
        } else if (page.content.type === 'css') {
          const pre = document.createElement('pre');
          pre.textContent = page.content.content;
          body.appendChild(pre);
        } else {
          body.innerHTML = page.content.content;
        }
      } else {
        body.textContent = String(page.content ?? '');
      }
      panel.appendChild(body);

      // progress pips
      const pips = document.createElement('div');
      pips.className = 'workshop-pips';
      for (let i = 0; i < pages.length; i++) {
        const pip = document.createElement('span');
        pip.className = 'workshop-pip' + (i === idx ? ' active' : '') + (i < idx ? ' done' : '');
        pip.onclick = () => navigate(i);
        pips.appendChild(pip);
      }
      panel.appendChild(pips);

      // nav buttons
      const nav = document.createElement('div');
      nav.className = 'workshop-nav';
      if (idx > 0) {
        const prev = document.createElement('button');
        prev.textContent = '\u2190 prev';
        prev.onclick = () => navigate(idx - 1);
        nav.appendChild(prev);
      }
      const spacer = document.createElement('span');
      spacer.style.flex = '1';
      nav.appendChild(spacer);
      const counter = document.createElement('span');
      counter.className = 'workshop-counter';
      counter.textContent = `${idx + 1} / ${pages.length}`;
      nav.appendChild(counter);
      if (idx < pages.length - 1) {
        const next = document.createElement('button');
        next.className = 'workshop-next';
        next.textContent = 'next \u2192';
        if (page.canAdvance && !page.canAdvance()) {
          next.disabled = true;
          next.title = 'complete the task to continue';
        }
        next.onclick = () => navigate(idx + 1);
        nav.appendChild(next);
      }
      panel.appendChild(nav);

      // fire onEnter
      if (page.onEnter) page.onEnter();
    }

    function navigate(idx) {
      const prevPage = pages[currentPage];
      if (prevPage?.onLeave) prevPage.onLeave();
      renderPage(idx);
    }

    // store re-check function for canAdvance gating
    cell._workshopRecheck = () => {
      const page = pages[currentPage];
      if (!page?.canAdvance) return;
      const nextBtn = panel.querySelector('.workshop-next');
      if (nextBtn) {
        nextBtn.disabled = !page.canAdvance();
      }
    };

    renderPage(currentPage);

    // auto-open on first creation
    if (!panel.classList.contains('open') && !cell._workshopShown) {
      toggleWorkshop(true);
      cell._workshopShown = true;
    }

    // store cleanup so deleteCell can tear down workshop DOM
    cell._workshopCleanup = () => {
      panel.remove();
      overlay.remove();
      toggleBtn.remove();
      cell._workshopRecheck = null;
    };
    // on re-run, just clear the recheck — DOM is reused by ID
    invalidation.then(() => {
      cell._workshopRecheck = null;
    });

    return { goto: navigate, toggle: toggleWorkshop, recheck: cell._workshopRecheck };
  };

  // notebook API — programmatic notebook control
  const notebook = {
    get cells() { return S.cells.map(c => ({ id: c.id, type: c.type, code: c.code })); },
    get scope() { return { ...S.scope }; },
    addCell: (type, code, afterId) => addCell(type, code, afterId),
    scrollTo: (id) => {
      const c = S.cells.find(c => c.id === id);
      if (c?.el) c.el.scrollIntoView({ behavior: 'smooth', block: 'center' });
    },
    focus: (id) => {
      const c = S.cells.find(c => c.id === id);
      if (c?.el) {
        c.el.scrollIntoView({ behavior: 'smooth', block: 'center' });
        const ta = c.el.querySelector('textarea');
        if (ta) ta.focus();
      }
    },
    collapse: (id) => {
      const c = S.cells.find(c => c.id === id);
      if (c?.el) c.el.classList.add('collapsed');
    },
    expand: (id) => {
      const c = S.cells.find(c => c.id === id);
      if (c?.el) c.el.classList.remove('collapsed');
    },
    run: (ids) => runDAG(Array.isArray(ids) ? ids : [ids], true),
  };

  // function caching — reuse compiled function if code/uses/defines unchanged
  const cacheKey = scopeKeys.join(',') + '|' + defNames + '|' + cell.code;

  try {
    let fn;
    if (cell._cacheKey === cacheKey && cell._cachedFn) {
      fn = cell._cachedFn;
    } else {
      const AsyncFunction = Object.getPrototypeOf(async function(){}).constructor;
      const cellName = parseCellName(cell.code);
      const slug = cellName ? '-' + cellName.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/(^-|-$)/g, '') : '';
      fn = new AsyncFunction(
        ...scopeKeys,
        'ui', 'std', 'load', 'install', 'installBinary', 'invalidation', 'print',
        'md', 'html', 'css', 'workshop', 'notebook',
        `"use strict";\n${cell.code}\n\n` +
        `return { ${defNames} };\n` +
        `//# sourceURL=auditable://cell-${cell.id}${slug}.js`
      );
      cell._cachedFn = fn;
      cell._cacheKey = cacheKey;
    }

    const scopeVals = scopeKeys.map(k => S.scope[k]);
    const result = await fn(...scopeVals, ui, std, load, install, installBinary, invalidation, display,
      md, html, css, workshop, notebook);

    // update scope with defined variables
    if (result && typeof result === 'object') {
      cell._lastResult = result;
      for (const [k, v] of Object.entries(result)) {
        if (v !== undefined) S.scope[k] = v;
      }
    }

    cell.el.classList.remove('stale', 'error');
    cell.el.classList.add('fresh');
    setTimeout(() => cell.el.classList.remove('fresh'), 800);

    // remove widgets no longer referenced by code
    for (const w of widgetEl.querySelectorAll('[data-widget-key]')) {
      if (!usedWidgets.has(w.dataset.widgetKey)) {
        delete cell._inputs[w.dataset.widgetKey];
        delete cell._callbacks[w.dataset.widgetKey];
        w.remove();
      }
    }

  } catch (e) {
    cell.error = e.message;
    outputEl.textContent = e.message;
    outputEl.className = 'cell-output error';
    cell.el.classList.remove('stale', 'fresh');
    cell.el.classList.add('error');
  }
}

async function runDAG(dirtyIds, force = false) {
  buildDAG();
  const isAutorun = S.autorun && !force;

  // determine which cells need execution via topo sort
  const runSet = new Set(topoSort(dirtyIds));

  if (window._dagStart) window._dagStart();

  // rebuild scope in document order, only executing cells in runSet
  S.scope = {};
  const poisoned = new Set(); // variable names defined by errored cells
  for (let i = 0; i < S.cells.length; i++) {
    const cell = S.cells[i];

    if (cell.type === 'html') {
      if (runSet.has(cell.id)) {
        // check if any used variable is poisoned
        if (cell.uses && [...cell.uses].some(n => poisoned.has(n))) {
          cell.el.classList.remove('fresh');
          cell.el.classList.add('stale');
        } else {
          renderHtmlCell(cell);
        }
      }
      continue;
    }
    if (cell.type !== 'code') continue;

    // skip norun cells (unless explicitly triggered)
    if (isNorun(cell.code) && !dirtyIds.includes(cell.id)) {
      if (cell._lastResult) {
        for (const [k, v] of Object.entries(cell._lastResult)) {
          if (v !== undefined) S.scope[k] = v;
        }
      }
      continue;
    }

    // skip manual cells unless force or explicitly triggered
    if (!force && isManual(cell.code) && !dirtyIds.includes(cell.id)) {
      if (cell._lastResult) {
        for (const [k, v] of Object.entries(cell._lastResult)) {
          if (v !== undefined) S.scope[k] = v;
        }
      }
      cell.el.classList.add('stale');
      continue;
    }

    // not in run set — restore cached results, skip execution
    if (!runSet.has(cell.id)) {
      if (cell._lastResult) {
        for (const [k, v] of Object.entries(cell._lastResult)) {
          if (v !== undefined) S.scope[k] = v;
        }
      }
      continue;
    }

    // error isolation: if any upstream dependency is poisoned, skip this cell
    if (cell.uses && cell.uses.size > 0) {
      let blocked = false;
      for (const name of cell.uses) {
        if (poisoned.has(name)) { blocked = true; break; }
      }
      if (blocked) {
        const outputEl = cell.el.querySelector('.cell-output');
        if (outputEl && !cell.error) {
          outputEl.textContent = 'blocked by upstream error';
          outputEl.className = 'cell-output error';
        }
        cell.el.classList.remove('stale', 'fresh');
        cell.el.classList.add('error');
        // poison our own defines so downstream also blocks
        if (cell.defines) for (const name of cell.defines) poisoned.add(name);
        continue;
      }
    }

    // value-equality gating: if this cell is a downstream dependent (not directly
    // dirty) and all its input values are unchanged, skip re-execution entirely
    if (!dirtyIds.includes(cell.id) && cell._lastResult && cell.uses && cell.uses.size > 0) {
      let inputsChanged = false;
      for (const name of cell.uses) {
        if (S.scope[name] !== cell._prevInputs?.[name]) { inputsChanged = true; break; }
      }
      if (!inputsChanged) {
        // inputs identical — restore previous results, skip execution
        for (const [k, v] of Object.entries(cell._lastResult)) {
          if (v !== undefined) S.scope[k] = v;
        }
        continue;
      }
    }

    if (window._beforeExec) window._beforeExec(cell);
    await execCell(cell);

    // if the cell errored, poison its defines
    if (cell.error) {
      if (cell.defines) for (const name of cell.defines) poisoned.add(name);
    }

    // snapshot input values for future equality checks
    if (cell.uses) {
      cell._prevInputs = {};
      for (const name of cell.uses) cell._prevInputs[name] = S.scope[name];
    }

    if (window._afterExec && !isAutorun) {
      const jump = window._afterExec(cell, i);
      if (jump >= 0) { i = jump - 1; continue; }
    }
  }

  updateStatus();

  // recheck workshop canAdvance gates after scope changes
  for (const c of S.cells) {
    if (c._workshopRecheck) c._workshopRecheck();
  }
}

async function runAll() {
  const ids = S.cells.filter(c => c.type === 'code' || c.type === 'html').map(c => c.id);
  if (ids.length === 0) return;
  await runDAG(ids, true);
  setMsg('ran all cells', 'ok');
}

// late import to avoid circular dependency at module load time

// -- markdown.js --

// ── MARKDOWN RENDERING (minimal) ──

function renderMd(src) {
  let html = src
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;');

  // headings
  html = html.replace(/^### (.+)$/gm, '<h3>$1</h3>');
  html = html.replace(/^## (.+)$/gm, '<h2>$1</h2>');
  html = html.replace(/^# (.+)$/gm, '<h1>$1</h1>');

  // bold/italic
  html = html.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
  html = html.replace(/\*(.+?)\*/g, '<em>$1</em>');

  // inline code
  html = html.replace(/`(.+?)`/g, '<code>$1</code>');

  // links
  html = html.replace(/\[(.+?)\]\((.+?)\)/g, '<a href="$2">$1</a>');

  // paragraphs
  html = html.replace(/\n\n/g, '</p><p>');
  if (!html.startsWith('<h') && !html.startsWith('<p')) html = '<p>' + html + '</p>';

  return html;
}

// -- cell-dom.js --

// ── CELL DOM ──

function cssSummary(code) {
  if (!code || !code.trim()) return '';
  const rules = (code.match(/[^{}]+\{/g) || []).length;
  const lines = code.split('\n').length;
  return `${rules} rule${rules !== 1 ? 's' : ''} \u00b7 ${lines} line${lines !== 1 ? 's' : ''}`;
}

function cellHeaderHTML(type, id) {
  return `<div class="cell-header">
    <span class="cell-type">${type}</span>
    <button class="cell-btn cell-convert" onclick="toggleTypePicker(${id})" title="convert type">\u21c4</button>
    <div class="cell-type-picker" data-cell-id="${id}">
      <button onclick="convertCell(${id},'code')">code</button>
      <button onclick="convertCell(${id},'md')">md</button>
      <button onclick="convertCell(${id},'css')">css</button>
      <button onclick="convertCell(${id},'html')">html</button>
    </div>
    <button class="cell-btn cell-insert" onclick="showInsertPicker(${id},'before')" title="insert above">+\u2191</button>
    <button class="cell-btn cell-insert" onclick="showInsertPicker(${id},'after')" title="insert below">+\u2193</button>
    <button class="cell-btn" onclick="moveCell(${id},-1)" title="move up">\u2191</button>
    <button class="cell-btn" onclick="moveCell(${id},1)" title="move down">\u2193</button>
    <button class="cell-btn del" onclick="deleteCellWithUndo(${id})" title="delete">\u00d7</button>
  </div>`;
}

function createCellEl(type, id) {
  const div = document.createElement('div');
  div.className = 'cell';
  div.dataset.id = id;
  div.dataset.type = type;

  if (type === 'code') {
    div.innerHTML = `
      ${cellHeaderHTML('code', id)}
      <div class="cell-code">
        <div class="editor-wrap">
          <div class="line-numbers" aria-hidden="true">1</div>
          <textarea rows="3" spellcheck="false" wrap="off" placeholder="// code"></textarea>
          <div class="highlight-layer" aria-hidden="true"></div>
        </div>
      </div>
      <div class="cell-widgets"></div>
      <div class="cell-output"></div>
    `;

    const ta = div.querySelector('textarea');
    const hl = div.querySelector('.highlight-layer');
    div.querySelector('.cell-type').addEventListener('click', () => div.classList.toggle('collapsed'));
    const ln = div.querySelector('.line-numbers');
    ta.addEventListener('input', () => { highlightCode(ta, hl); onCodeEdit(id); });
    ta.addEventListener('scroll', () => { hl.scrollTop = ta.scrollTop; hl.scrollLeft = ta.scrollLeft; ln.scrollTop = ta.scrollTop; });
    attachAutocomplete(ta, id);
    ta.addEventListener('keydown', handleTab);
    ta.addEventListener('input', autoResize);
  } else if (type === 'css') {
    div.innerHTML = `
      ${cellHeaderHTML('css', id)}
      <div class="cell-css-view"></div>
      <div class="cell-css-edit" style="display:none">
        <div class="editor-wrap">
          <div class="line-numbers" aria-hidden="true">1</div>
          <textarea rows="3" spellcheck="false" wrap="off" placeholder="/* css */"></textarea>
          <div class="highlight-layer" aria-hidden="true"></div>
        </div>
      </div>
    `;

    const cssView = div.querySelector('.cell-css-view');
    const cssEditWrap = div.querySelector('.cell-css-edit');
    const ta = div.querySelector('textarea');
    const hl = div.querySelector('.highlight-layer');
    div.querySelector('.cell-type').addEventListener('click', () => div.classList.toggle('collapsed'));

    cssView.addEventListener('click', () => {
      cssEditWrap.style.display = '';
      cssView.style.display = 'none';
      ta.focus();
      autoResize({ target: ta });
    });

    ta.addEventListener('blur', () => {
      if (S.findActive) return;
      const cell = S.cells.find(c => c.id === id);
      if (cell) {
        cell.code = ta.value;
        cssView.textContent = cssSummary(ta.value);
      }
      cssEditWrap.style.display = 'none';
      cssView.style.display = '';
    });

    const ln = div.querySelector('.line-numbers');
    ta.addEventListener('input', () => { highlightCss(ta, hl); onCssEdit(id); });
    ta.addEventListener('scroll', () => { hl.scrollTop = ta.scrollTop; hl.scrollLeft = ta.scrollLeft; ln.scrollTop = ta.scrollTop; });
    ta.addEventListener('input', autoResize);
    ta.addEventListener('keydown', handleTab);
  } else if (type === 'html') {
    div.innerHTML = `
      ${cellHeaderHTML('html', id)}
      <div class="cell-html-view"></div>
      <div class="cell-html-edit" style="display:none">
        <div class="editor-wrap">
          <div class="line-numbers" aria-hidden="true">1</div>
          <textarea rows="2" spellcheck="false" wrap="off" placeholder="<html template>"></textarea>
          <div class="highlight-layer" aria-hidden="true"></div>
        </div>
      </div>
      <div class="cell-output"></div>
    `;

    const view = div.querySelector('.cell-html-view');
    const editWrap = div.querySelector('.cell-html-edit');
    const ta = div.querySelector('.cell-html-edit textarea');
    const hl = div.querySelector('.highlight-layer');
    div.querySelector('.cell-type').addEventListener('click', () => div.classList.toggle('collapsed'));

    view.addEventListener('click', () => {
      editWrap.style.display = '';
      view.style.display = 'none';
      ta.focus();
      autoResize({ target: ta });
    });

    ta.addEventListener('blur', () => {
      if (S.findActive) return;
      const cell = S.cells.find(c => c.id === id);
      if (cell) {
        cell.code = ta.value;
        renderHtmlCell(cell);
      }
      editWrap.style.display = 'none';
      view.style.display = '';
    });

    const ln = div.querySelector('.line-numbers');
    ta.addEventListener('input', () => { highlightHtml(ta, hl); onHtmlEdit(id); });
    ta.addEventListener('scroll', () => { hl.scrollTop = ta.scrollTop; hl.scrollLeft = ta.scrollLeft; ln.scrollTop = ta.scrollTop; });
    ta.addEventListener('input', autoResize);
    ta.addEventListener('keydown', handleTab);
  } else {
    div.innerHTML = `
      ${cellHeaderHTML('md', id)}
      <div class="cell-md-view"></div>
      <div class="cell-md-edit" style="display:none">
        <textarea rows="2" spellcheck="false" placeholder="markdown"></textarea>
      </div>
    `;

    const view = div.querySelector('.cell-md-view');
    const editWrap = div.querySelector('.cell-md-edit');
    const ta = div.querySelector('.cell-md-edit textarea');
    div.querySelector('.cell-type').addEventListener('click', () => div.classList.toggle('collapsed'));

    view.addEventListener('click', () => {
      editWrap.style.display = '';
      view.style.display = 'none';
      ta.focus();
      autoResize({ target: ta });
    });

    ta.addEventListener('blur', () => {
      if (S.findActive) return;
      const cell = S.cells.find(c => c.id === id);
      if (cell) {
        cell.code = ta.value;
        view.innerHTML = renderMd(ta.value);
      }
      editWrap.style.display = 'none';
      view.style.display = '';
    });

    ta.addEventListener('input', autoResize);
    ta.addEventListener('keydown', handleTab);
  }

  return div;
}

// undoable text replacement — uses execCommand so the browser records it in the undo stack
function replaceRange(ta, from, to, text) {
  ta.focus();
  ta.selectionStart = from;
  ta.selectionEnd = to;
  document.execCommand('insertText', false, text);
}

function handleTab(e) {
  const ta = e.target;
  const start = ta.selectionStart;
  const end = ta.selectionEnd;

  if (e.key === 'Tab') {
    e.preventDefault();

    if (start === end) {
      // no selection — insert 2 spaces
      replaceRange(ta, start, end, '  ');
    } else {
      // selection — indent/unindent lines
      const val = ta.value;
      const lineStart = val.lastIndexOf('\n', start - 1) + 1;
      const lineEnd = val.indexOf('\n', end);
      const blockEnd = lineEnd === -1 ? val.length : lineEnd;
      const block = val.slice(lineStart, blockEnd);
      let newBlock;
      if (e.shiftKey) {
        newBlock = block.replace(/^  /gm, '');
      } else {
        newBlock = block.replace(/^/gm, '  ');
      }
      replaceRange(ta, lineStart, blockEnd, newBlock);
      ta.selectionStart = lineStart;
      ta.selectionEnd = lineStart + newBlock.length;
    }
    ta.dispatchEvent(new Event('input'));
    return;
  }

  // Enter — auto-indent
  if (e.key === 'Enter') {
    e.preventDefault();
    const val = ta.value;
    const before = val.slice(0, start);
    const after = val.slice(end);

    // find current line's leading whitespace
    const lineStart = before.lastIndexOf('\n') + 1;
    const line = before.slice(lineStart);
    const indent = line.match(/^(\s*)/)[1];

    // check if the character before cursor is an opener
    const charBefore = before.trimEnd().slice(-1);
    const extra = '{(['.includes(charBefore) ? '  ' : '';

    // check if the character after cursor is a matching closer
    const charAfter = after.trimStart()[0];
    const pairs = { '{': '}', '(': ')', '[': ']' };
    const needClose = extra && charAfter === pairs[charBefore];

    if (needClose) {
      // cursor between brackets: add indented line + closing line
      const insert = '\n' + indent + extra + '\n' + indent;
      replaceRange(ta, start, end, insert);
      ta.selectionStart = ta.selectionEnd = start + 1 + indent.length + extra.length;
    } else {
      const insert = '\n' + indent + extra;
      replaceRange(ta, start, end, insert);
    }
    ta.dispatchEvent(new Event('input'));
    return;
  }

  // Ctrl+X / Ctrl+C with no selection — whole-line cut/copy
  if ((e.key === 'x' || e.key === 'c') && (e.ctrlKey || e.metaKey) && !e.shiftKey && !e.altKey && start === end) {
    e.preventDefault();
    const val = ta.value;
    const lineStart = val.lastIndexOf('\n', start - 1) + 1;
    let lineEnd = val.indexOf('\n', start);
    if (lineEnd === -1) lineEnd = val.length;
    else lineEnd++; // include the newline

    const lineText = val.slice(lineStart, lineEnd);
    navigator.clipboard.writeText(lineText);

    if (e.key === 'x') {
      replaceRange(ta, lineStart, lineEnd, '');
      ta.dispatchEvent(new Event('input'));
    }
    return;
  }
}

function toggleComment(ta) {
  const val = ta.value;
  const start = ta.selectionStart;
  const end = ta.selectionEnd;

  // find affected line range
  const lineStart = val.lastIndexOf('\n', start - 1) + 1;
  let lineEnd = val.indexOf('\n', end);
  if (lineEnd === -1) lineEnd = val.length;

  const block = val.slice(lineStart, lineEnd);
  const lines = block.split('\n');

  // check if all lines are commented
  const allCommented = lines.every(l => /^\s*\/\//.test(l) || l.trim() === '');

  let newLines;
  if (allCommented) {
    // uncomment: remove first // (and one trailing space if present)
    newLines = lines.map(l => l.replace(/^(\s*)\/\/ ?/, '$1'));
  } else {
    // comment: add // at the minimum indent level
    const indents = lines.filter(l => l.trim()).map(l => l.match(/^(\s*)/)[1].length);
    const minIndent = indents.length ? Math.min(...indents) : 0;
    newLines = lines.map(l => {
      if (l.trim() === '') return l;
      return l.slice(0, minIndent) + '// ' + l.slice(minIndent);
    });
  }

  const newBlock = newLines.join('\n');
  replaceRange(ta, lineStart, lineEnd, newBlock);
  ta.selectionStart = lineStart;
  ta.selectionEnd = lineStart + newBlock.length;
  ta.dispatchEvent(new Event('input'));
}

function updateLineNumbers(ta) {
  const wrap = ta.closest('.editor-wrap');
  if (!wrap) return;
  const gutter = wrap.querySelector('.line-numbers');
  if (!gutter) return;
  const count = ta.value.split('\n').length;
  const lines = [];
  for (let i = 1; i <= count; i++) lines.push(i);
  gutter.textContent = lines.join('\n');
}

function autoResize(e) {
  const ta = e.target || e;
  ta.style.height = 'auto';
  ta.style.height = ta.scrollHeight + 'px';
  // sync highlight layer if present
  const hl = ta.parentElement && ta.parentElement.querySelector('.highlight-layer');
  if (hl) { hl.style.height = ta.style.height; }
  updateLineNumbers(ta);
}

// -- cell-ops.js --

// ── CELL OPERATIONS ──

function addCell(type, code = '', afterId = null, beforeId = null) {
  const id = S.cellId++;
  const cell = {
    id, type, code,
    defines: new Set(),
    uses: new Set(),
    error: null,
    el: createCellEl(type, id)
  };

  const nb = $('#notebook');
  if (beforeId !== null) {
    const idx = S.cells.findIndex(c => c.id === beforeId);
    if (idx >= 0) {
      S.cells.splice(idx, 0, cell);
      S.cells[idx + 1].el.before(cell.el);
    } else {
      S.cells.push(cell);
      nb.appendChild(cell.el);
    }
  } else if (afterId !== null) {
    const idx = S.cells.findIndex(c => c.id === afterId);
    if (idx >= 0) {
      S.cells.splice(idx + 1, 0, cell);
      if (idx < S.cells.length - 2) {
        S.cells[idx + 2].el.before(cell.el);
      } else {
        nb.appendChild(cell.el);
      }
    } else {
      S.cells.push(cell);
      nb.appendChild(cell.el);
    }
  } else {
    S.cells.push(cell);
    nb.appendChild(cell.el);
  }

  // set code
  const ta = cell.el.querySelector('textarea');
  if (code) {
    ta.value = code;
    autoResize({ target: ta });
    if (type === 'code') {
      const hl = cell.el.querySelector('.highlight-layer');
      if (hl) highlightCode(ta, hl);
      if (isManual(code)) cell.el.classList.add('manual');
    }
    if (type === 'md') {
      cell.el.querySelector('.cell-md-view').innerHTML = renderMd(code);
    }
  }

  // CSS cell: create <style> element in <head>
  if (type === 'css') {
    const hl = cell.el.querySelector('.highlight-layer');
    if (hl && code) highlightCss(ta, hl);
    const cssView = cell.el.querySelector('.cell-css-view');
    if (cssView && code) cssView.textContent = cssSummary(code);
    const styleEl = document.createElement('style');
    styleEl.dataset.cellId = id;
    styleEl.textContent = code;
    document.head.appendChild(styleEl);
    cell._styleEl = styleEl;
  }

  // HTML cell: render template
  if (type === 'html' && code) {
    renderHtmlCell(cell);
  }

  ta.focus();
  updateStatus();
  notifyDirty();
  return cell;
}

function deleteCell(id) {
  const idx = S.cells.findIndex(c => c.id === id);
  if (idx < 0) return;
  // fire invalidation so cell resources (timers, etc.) clean up
  if (S.cells[idx]._invalidate) { S.cells[idx]._invalidate(); S.cells[idx]._invalidate = null; }
  // tear down workshop DOM if this cell had one
  if (S.cells[idx]._workshopCleanup) { S.cells[idx]._workshopCleanup(); S.cells[idx]._workshopCleanup = null; }
  if (S.cells[idx]._styleEl) {
    S.cells[idx]._styleEl.remove();
    S.cells[idx]._styleEl = null;
  }
  S.cells[idx].el.remove();
  S.cells.splice(idx, 1);
  // re-run to clean scope
  if (S.cells.some(c => c.type === 'code' || c.type === 'html')) runAll();
  updateStatus();
  notifyDirty();
}

function convertCell(id, newType) {
  const cell = S.cells.find(c => c.id === id);
  if (!cell || cell.type === newType) return;

  const code = cell.code;

  // cleanup old type
  if (cell._styleEl) {
    cell._styleEl.remove();
    cell._styleEl = null;
  }

  // create new cell element
  const newEl = createCellEl(newType, id);
  cell.el.replaceWith(newEl);
  cell.el = newEl;
  cell.type = newType;

  // set code
  const ta = newEl.querySelector('textarea');
  ta.value = code;
  cell.code = code;
  autoResize({ target: ta });

  if (newType === 'code') {
    const hl = newEl.querySelector('.highlight-layer');
    if (hl) highlightCode(ta, hl);
  }
  if (newType === 'md') {
    newEl.querySelector('.cell-md-view').innerHTML = renderMd(code);
  }
  if (newType === 'css') {
    const hl = newEl.querySelector('.highlight-layer');
    if (hl) highlightCss(ta, hl);
    const cssView = newEl.querySelector('.cell-css-view');
    if (cssView && code) cssView.textContent = cssSummary(code);
    const styleEl = document.createElement('style');
    styleEl.dataset.cellId = id;
    styleEl.textContent = code;
    document.head.appendChild(styleEl);
    cell._styleEl = styleEl;
  }
  if (newType === 'html') {
    renderHtmlCell(cell);
  }

  selectCell(id);
  updateStatus();
  notifyDirty();
  if (S.cells.some(c => c.type === 'code' || c.type === 'html')) runAll();
}

function moveCell(id, dir) {
  const idx = S.cells.findIndex(c => c.id === id);
  const newIdx = idx + dir;
  if (newIdx < 0 || newIdx >= S.cells.length) return;

  const [cell] = S.cells.splice(idx, 1);
  S.cells.splice(newIdx, 0, cell);

  // re-order DOM
  const nb = $('#notebook');
  nb.innerHTML = '';
  for (const c of S.cells) nb.appendChild(c.el);

  // re-order CSS <style> elements in <head> to match cell order
  for (const c of S.cells) {
    if (c._styleEl) document.head.appendChild(c._styleEl);
  }

  notifyDirty();
  if (S.cells.some(c => c.type === 'code' || c.type === 'html')) runAll();
}

// -- editor.js --

// ── EDITING ──

function notifyDirty() {
  if (S.initialized && window.__AF_BRIDGE__) window.parent.postMessage({ type: 'af:dirty' }, '*');
}

function toggleAutorun() {
  S.autorun = !S.autorun;
  const btn = $('#autorunBtn');
  const btnMobile = document.getElementById('autorunBtnMobile');
  const cls = S.autorun ? 'autorun-on' : 'autorun-off';
  const text = S.autorun ? '\u25b6' : '\u2016';
  btn.textContent = text;
  btn.title = S.autorun ? 'reactive mode \u2014 cells auto-run on edit' : 'manual mode \u2014 only Run All or Ctrl+Enter';
  btn.className = cls;
  if (btnMobile) {
    btnMobile.textContent = text;
    btnMobile.className = cls;
  }
  const sel = $('#setExecMode');
  if (sel) sel.value = S.autorun ? 'reactive' : 'manual';
  setMsg(S.autorun ? 'autorun on' : 'autorun off', 'ok');
}

function onCssEdit(id) {
  const cell = S.cells.find(c => c.id === id);
  if (!cell) return;
  cell.code = cell.el.querySelector('textarea').value;
  if (cell._styleEl) cell._styleEl.textContent = cell.code;
  notifyDirty();
}

function onHtmlEdit(id) {
  const cell = S.cells.find(c => c.id === id);
  if (!cell) return;
  cell.code = cell.el.querySelector('textarea').value;
  cell.el.classList.add('stale');
  notifyDirty();

  if (S.autorun) {
    clearTimeout(S.editTimer);
    S.editTimer = setTimeout(() => runDAG([id], false), 400);
  }
}

function onCodeEdit(id) {
  const cell = S.cells.find(c => c.id === id);
  if (!cell) return;
  const ta = cell.el.querySelector('textarea');
  cell.code = ta.value;

  // update manual state
  if (isManual(cell.code)) {
    cell.el.classList.add('manual');
  } else {
    cell.el.classList.remove('manual');
  }

  cell.el.classList.add('stale');
  notifyDirty();

  if (S.autorun) {
    clearTimeout(S.editTimer);
    S.editTimer = setTimeout(() => runDAG([id], false), 400);
  }
}

// -- settings.js --

// ── SETTINGS ──

// Safe localStorage access — blob URL iframes have opaque origins where localStorage throws
function lsGet(key) { try { return localStorage.getItem(key); } catch { return null; } }
function lsSet(key, val) { try { localStorage.setItem(key, val); } catch {} }
function lsRemove(key) { try { localStorage.removeItem(key); } catch {} }

function toggleSettings() {
  const overlay = $('#settingsOverlay');
  const panel = $('#settingsPanel');
  const open = !overlay.classList.contains('visible');
  overlay.classList.toggle('visible');
  panel.style.display = open ? 'block' : 'none';
  if (open) refreshModuleList();
}

function applyTheme(theme) {
  if (theme === 'light') {
    document.documentElement.classList.add('light');
  } else {
    document.documentElement.classList.remove('light');
  }
  $('#setTheme').value = theme;
}

function applyFontSize(size) {
  size = parseInt(size);
  document.documentElement.style.setProperty('--editor-font-size', size + 'px');
  $('#setFontSize').value = size;
  $('#setFontSizeVal').textContent = size;
}

function applyWidth(w) {
  const nb = $('#notebook');
  nb.style.maxWidth = w;
  $('#setWidth').value = w;
}

function applyLineNumbers(show) {
  const on = show === true || show === 'true' || show === 'on';
  document.documentElement.classList.toggle('hide-line-numbers', !on);
  const el = $('#setLineNumbers');
  if (el) el.value = on ? 'on' : 'off';
}

function applyHeader(mode) {
  const root = document.documentElement;
  root.classList.remove('header-always', 'header-hover', 'header-compact');
  if (mode === 'always') root.classList.add('header-always');
  else if (mode === 'hover') root.classList.add('header-hover');
  else if (mode === 'compact') root.classList.add('header-compact');
  // 'auto' = no class, CSS media queries handle it
  $('#setHeader').value = mode;
}

// ── EXECUTION MODE ──

const __AUDITABLE_DEFAULT_EXEC_MODE__ = 'reactive';
const __AUDITABLE_DEFAULT_RUN_ON_LOAD__ = 'yes';

let _runOnLoad = 'yes';
let _showToggle = 'yes';

function applyExecMode(mode) {
  S.autorun = (mode === 'reactive');
  const btn = $('#autorunBtn');
  const btnMobile = document.getElementById('autorunBtnMobile');
  const cls = S.autorun ? 'autorun-on' : 'autorun-off';
  const text = S.autorun ? '\u25b6' : '\u2016';
  if (btn) { btn.textContent = text; btn.className = cls; btn.title = S.autorun ? 'reactive mode \u2014 cells auto-run on edit' : 'manual mode \u2014 only Run All or Ctrl+Enter'; }
  if (btnMobile) { btnMobile.textContent = text; btnMobile.className = cls; }
  const sel = $('#setExecMode');
  if (sel) sel.value = mode;
}

function applyRunOnLoad(val) {
  _runOnLoad = val;
  const sel = $('#setRunOnLoad');
  if (sel) sel.value = val;
}

function applyShowToggle(val) {
  _showToggle = val;
  document.documentElement.classList.toggle('hide-run-toggle', val === 'no');
  const sel = $('#setShowToggle');
  if (sel) sel.value = val;
}

function applyGlobalExecMode(val) {
  if (val) lsSet('auditable-exec-mode', val);
  else lsRemove('auditable-exec-mode');
}

function applyGlobalRunOnLoad(val) {
  if (val) lsSet('auditable-run-on-load', val);
  else lsRemove('auditable-run-on-load');
}

function resolveExecMode() {
  return lsGet('auditable-exec-mode')
    || $('#setExecMode')?.value
    || __AUDITABLE_DEFAULT_EXEC_MODE__;
}

function resolveRunOnLoad() {
  return lsGet('auditable-run-on-load')
    || _runOnLoad
    || __AUDITABLE_DEFAULT_RUN_ON_LOAD__;
}

function getSettings() {
  const s = {
    theme: document.documentElement.classList.contains('light') ? 'light' : 'dark',
    fontSize: parseInt($('#setFontSize').value),
    width: $('#setWidth').value,
    header: $('#setHeader').value,
    lineNumbers: document.documentElement.classList.contains('hide-line-numbers') ? 'off' : 'on',
    execMode: S.autorun ? 'reactive' : 'manual',
    runOnLoad: _runOnLoad,
    showToggle: _showToggle,
  };
  if (window._sizeCompare) s.sizeCompare = true;
  if (window._sizeCompareRef === 'content') s.sizeCompareRef = 'content';
  return s;
}

function applySettings(s) {
  if (!s) return;
  if (s.theme) applyTheme(s.theme);
  if (s.fontSize) applyFontSize(s.fontSize);
  if (s.width) applyWidth(s.width);
  if (s.header) applyHeader(s.header);
  if (s.lineNumbers) applyLineNumbers(s.lineNumbers);
  if (s.execMode) applyExecMode(s.execMode);
  if (s.runOnLoad) applyRunOnLoad(s.runOnLoad);
  if (s.showToggle) applyShowToggle(s.showToggle);
  // optional: size-compare.js (typeof guards for --lean builds without it)
  if (s.sizeCompare !== undefined && typeof applySizeCompare === 'function') applySizeCompare(s.sizeCompare);
  if (s.sizeCompareRef !== undefined && typeof applySizeCompareRef === 'function') applySizeCompareRef(s.sizeCompareRef);
}

function togglePresent() {
  document.body.classList.toggle('presenting');
}

// ── ABOUT ──

const __AUDITABLE_VERSION__ = '0.3.0';
const __AUDITABLE_RELEASE__ = 'dev';
const __AUDITABLE_BUILD_DATE__ = '2026-02-23';
const __AUDITABLE_BASE_SIZE__ = 250774;

(function() {
  const ver = $('#aboutVersion');
  const build = $('#aboutBuild');
  const rt = $('#aboutRuntime');
  if (ver) ver.textContent = 'auditable v' + __AUDITABLE_VERSION__;
  if (build) build.textContent = (__AUDITABLE_RELEASE__ !== 'dev' ? __AUDITABLE_RELEASE__ + ' \u00b7 ' : '') + 'built ' + __AUDITABLE_BUILD_DATE__;
  if (rt && __AUDITABLE_BASE_SIZE__ > 0) rt.textContent = 'runtime ' + (__AUDITABLE_BASE_SIZE__ / 1024).toFixed(1) + ' KB';
})();

// ── EXECUTION SETTINGS INIT ──

(function() {
  const gm = lsGet('auditable-exec-mode') || '';
  const gr = lsGet('auditable-run-on-load') || '';
  const selGm = $('#setGlobalExecMode');
  const selGr = $('#setGlobalRunOnLoad');
  if (selGm) selGm.value = gm;
  if (selGr) selGr.value = gr;
})();

// ── MODULE MANAGEMENT ──

function formatSize(bytes) {
  return (bytes / 1024).toFixed(1) + ' KB';
}

function renderEntryRow(url, entry) {
  const src = typeof entry === 'string' ? entry : entry.source;
  const cellId = typeof entry === 'string' ? null : entry.cellId;
  const isBinary = typeof entry === 'object' && entry.binary;
  const size = src ? src.length : 0;
  const displaySize = isBinary ? Math.floor(size * 3 / 4) : size;

  const row = document.createElement('div');
  row.className = 'module-row';

  const urlSpan = document.createElement('span');
  urlSpan.className = 'module-url';
  urlSpan.textContent = url;
  urlSpan.title = url;
  row.appendChild(urlSpan);

  const info = document.createElement('span');
  info.className = 'module-info';
  info.textContent = (cellId != null ? 'cell ' + cellId + '  ' : '')
    + (isBinary && entry.compressed ? 'gzipped  ' : '')
    + formatSize(displaySize);
  row.appendChild(info);

  const btn = document.createElement('button');
  btn.className = 'module-remove';
  btn.textContent = '\u00d7';
  btn.title = isBinary ? 'remove binary' : 'remove module';
  btn.onclick = () => removeModule(url);
  row.appendChild(btn);

  return { row, size };
}

function renderSection(list, urls, mods, emptyText) {
  list.innerHTML = '';
  if (urls.length === 0) {
    const empty = document.createElement('div');
    empty.className = 'module-empty';
    empty.textContent = emptyText;
    list.appendChild(empty);
    return 0;
  }
  let totalSize = 0;
  for (const url of urls) {
    const { row, size } = renderEntryRow(url, mods[url]);
    list.appendChild(row);
    totalSize += size;
  }
  const total = document.createElement('div');
  total.className = 'module-total';
  total.textContent = 'total  ' + formatSize(totalSize);
  list.appendChild(total);
  return totalSize;
}

function refreshModuleList() {
  const modList = $('#moduleList');
  const binList = $('#binaryList');
  if (!modList) return;

  const mods = window._installedModules || {};
  const modUrls = [];
  const binUrls = [];
  for (const url of Object.keys(mods)) {
    const entry = mods[url];
    if (typeof entry === 'object' && entry.binary) binUrls.push(url);
    else modUrls.push(url);
  }

  renderSection(modList, modUrls, mods, 'no modules installed');
  if (binList) renderSection(binList, binUrls, mods, 'no binaries installed');
}

function removeModule(url) {
  const entry = window._installedModules?.[url];
  const cellId = entry && typeof entry === 'object' ? entry.cellId : null;
  const kind = entry?.binary ? 'binary' : 'module';
  if (window._installedModules) delete window._installedModules[url];
  if (window._importCache) delete window._importCache[url];
  refreshModuleList();
  updateStatus();
  if (cellId != null) {
    setMsg(`removed ${kind} \u2014 cell ${cellId} will re-install it on next run`, 'warn');
  }
}

// -- update.js --

// ── UPDATE PANEL ──

function toggleUpdate() {
  const overlay = $('#updateOverlay');
  const panel = $('#updatePanel');
  const open = !overlay.classList.contains('visible');
  overlay.classList.toggle('visible');
  panel.style.display = open ? 'block' : 'none';
}

// ── SELF-UPDATE SYSTEM ──

const __AUDITABLE_PUBLIC_KEY__ = '';
const __AUDITABLE_REPO__ = 'endarthur/auditable';
const __AUDITABLE_PAGES_URL__ = 'https://endarthur.github.io/auditable';

// ── SIGNATURE EXTRACTION ──

function extractSignature(html) {
  const m = html.match(/<!--AUDITABLE-SIGNATURE\n([\s\S]*?)\nAUDITABLE-SIGNATURE-->/);
  if (!m) return null;
  try { return JSON.parse(m[1]); } catch { return null; }
}

// ── RUNTIME EXTRACTION ──

function extractRuntime(html) {
  const style = html.match(/<style>([\s\S]*?)<\/style>/);
  const script = html.match(/<script>([\s\S]*?)<\/script>/);
  if (!style || !script) return null;
  return { style: style[1], script: script[1] };
}

// ── DATA EXTRACTION ──

function extractData(html) {
  const data = html.match(/<!--AUDITABLE-DATA\n([\s\S]*?)\nAUDITABLE-DATA-->/);
  const settings = html.match(/<!--AUDITABLE-SETTINGS\n([\s\S]*?)\nAUDITABLE-SETTINGS-->/);
  const modules = html.match(/<!--AUDITABLE-MODULES\n([\s\S]*?)\nAUDITABLE-MODULES-->/);
  const title = html.match(/<title>([^<]*)<\/title>/);
  return {
    data: data ? data[0] : null,
    settings: settings ? settings[0] : null,
    modules: modules ? modules[0] : null,
    title: title ? title[1].replace(/^Auditable\s*\u2014\s*/, '') : 'untitled',
  };
}

// ── SIGNED CONTENT CONSTRUCTION ──

function buildSignedContent(style, script) {
  return 'AUDITABLE-SIGNED-CONTENT\n'
    + style + '\n'
    + 'AUDITABLE-STYLE-SCRIPT-BOUNDARY\n'
    + script;
}

// ── SIGNATURE VERIFICATION (Web Crypto) ──

async function verifySignature(html) {
  const sig = extractSignature(html);
  if (!sig) return { status: 'unsigned' };

  const pubKeyB64 = __AUDITABLE_PUBLIC_KEY__;
  if (!pubKeyB64) return { status: 'no-key', sig };

  // Check if the signature's public key matches ours
  if (sig.pub !== pubKeyB64) return { status: 'wrong-key', sig };

  const runtime = extractRuntime(html);
  if (!runtime) return { status: 'error', message: 'could not extract runtime' };

  const content = buildSignedContent(runtime.style, runtime.script);

  try {
    const pubBytes = Uint8Array.from(atob(pubKeyB64), c => c.charCodeAt(0));
    const key = await crypto.subtle.importKey(
      'raw', pubBytes, { name: 'Ed25519' }, false, ['verify']
    );
    const sigBytes = Uint8Array.from(atob(sig.sig), c => c.charCodeAt(0));
    const msgBytes = new TextEncoder().encode(content);
    const valid = await crypto.subtle.verify('Ed25519', key, sigBytes, msgBytes);
    return { status: valid ? 'valid' : 'invalid', sig };
  } catch (e) {
    if (e.name === 'NotSupportedError') {
      return { status: 'unsupported', message: 'browser does not support Ed25519 verification' };
    }
    return { status: 'error', message: e.message };
  }
}

// ── REASSEMBLE ──

function reassemble(newHtml, oldData) {
  let html = newHtml;

  // Remove any existing data/settings/modules comments (and their description comments) from the new template
  html = html.replace(/(?:<!-- [^\n]*-->\n)?<!--AUDITABLE-DATA\n[\s\S]*?\nAUDITABLE-DATA-->\n?/g, '');
  html = html.replace(/(?:<!-- [^\n]*-->\n)?<!--AUDITABLE-SETTINGS\n[\s\S]*?\nAUDITABLE-SETTINGS-->\n?/g, '');
  html = html.replace(/(?:<!-- [^\n]*-->\n)?<!--AUDITABLE-MODULES\n[\s\S]*?\nAUDITABLE-MODULES-->\n?/g, '');

  // Build data block to inject
  const parts = [];
  if (oldData.data) parts.push(oldData.data);
  if (oldData.modules) parts.push(oldData.modules);
  if (oldData.settings) parts.push(oldData.settings);
  const dataBlock = parts.length ? '\n' + parts.join('\n') + '\n' : '';

  // Inject before the signature comment or before <script>
  const sigIdx = html.indexOf('<!--AUDITABLE-SIGNATURE');
  const scriptIdx = html.indexOf('<script>');
  const insertIdx = sigIdx >= 0 ? sigIdx : scriptIdx;
  if (insertIdx >= 0) {
    html = html.slice(0, insertIdx) + dataBlock + html.slice(insertIdx);
  }

  // Update title
  if (oldData.title && oldData.title !== 'untitled') {
    html = html.replace(/<title>[^<]*<\/title>/, '<title>Auditable \u2014 ' + escHtml(oldData.title) + '</title>');
    // Also update the docTitle input value
    html = html.replace(/(<input[^>]*id="docTitle"[^>]*value=")[^"]*"/, '$1' + escHtml(oldData.title) + '"');
  }

  return html;
}

function escHtml(s) {
  return s.replace(/&/g, '&amp;').replace(/"/g, '&quot;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
}

// ── VERSION COMPARISON ──

function compareVersions(a, b) {
  // compare semver strings like "0.1.0" vs "0.2.0"
  const pa = a.replace(/^v/, '').split('.').map(Number);
  const pb = b.replace(/^v/, '').split('.').map(Number);
  for (let i = 0; i < Math.max(pa.length, pb.length); i++) {
    const na = pa[i] || 0, nb = pb[i] || 0;
    if (na < nb) return -1;
    if (na > nb) return 1;
  }
  return 0;
}

// ── TOOLBAR BADGES ──

function setBadge(id, label, cls) {
  const container = $('#toolbarBadges');
  if (!container) return;
  let el = container.querySelector('[data-badge="' + id + '"]');
  if (!label) {
    if (el) el.remove();
    return;
  }
  if (!el) {
    el = document.createElement('span');
    el.className = 'toolbar-badge toolbar-badge-' + id;
    el.setAttribute('data-badge', id);
    container.appendChild(el);
  }
  el.textContent = label;
  if (cls) el.className = 'toolbar-badge ' + cls;
}

// ── UPDATE STATUS UI ──

function setUpdateStatus(html, cls) {
  const el = $('#updateStatus');
  if (el) {
    el.innerHTML = html;
    el.className = 'update-status' + (cls ? ' update-' + cls : '');
  }
}

// ── CHECK FOR UPDATE (GitHub API) ──

async function checkForUpdate() {
  const btn = $('#updateCheckBtn');
  if (btn) btn.disabled = true;
  setUpdateStatus('checking...', '');

  try {
    // Fetch version.json from GitHub Pages (CORS-friendly)
    const vResp = await fetch(__AUDITABLE_PAGES_URL__ + '/version.json');
    if (!vResp.ok) throw new Error('version check failed: ' + vResp.status);
    const vData = await vResp.json();
    const remoteVersion = vData.version || '';
    const currentRelease = $('#updateRelease')?.textContent || 'dev';

    if (currentRelease === 'dev') {
      // Dev builds always offer the latest release
    } else if (compareVersions(currentRelease, remoteVersion) >= 0) {
      setUpdateStatus('up to date (' + currentRelease + ')', 'ok');
      if (btn) btn.disabled = false;
      return;
    }

    const notes = vData.notes || '';
    const notesHtml = notes
      ? '<div class="update-notes">' + renderMd(notes) + '</div>'
      : '';

    setUpdateStatus(
      '<strong>' + remoteVersion + '</strong> available'
      + notesHtml
      + '<button id="updateApplyBtn" onclick="applyOnlineUpdate()">update</button>',
      'available'
    );

    window._updateVersion = remoteVersion;
  } catch (e) {
    setUpdateStatus('error: ' + escHtml(e.message), 'err');
  }
  if (btn) btn.disabled = false;
}

// ── APPLY ONLINE UPDATE ──

async function applyOnlineUpdate() {
  setUpdateStatus('downloading...', '');

  try {
    // Download signed build from GitHub Pages (CORS-friendly)
    const resp = await fetch(__AUDITABLE_PAGES_URL__ + '/auditable.html');
    if (!resp.ok) throw new Error('download failed: ' + resp.status);
    const newHtml = await resp.text();
    await applyUpdate(newHtml, window._updateVersion);
  } catch (e) {
    setUpdateStatus('error: ' + escHtml(e.message), 'err');
  }
}

// ── APPLY UPDATE (verify + reassemble + download) ──

async function applyUpdate(newHtml, version) {
  setUpdateStatus('verifying signature...', '');

  const result = await verifySignature(newHtml);

  if (result.status === 'invalid') {
    setUpdateStatus('signature verification FAILED \u2014 update rejected', 'err');
    return;
  }

  const warnMessages = {
    'unsigned': 'this file is not signed',
    'no-key': 'no public key configured \u2014 cannot verify signature',
    'wrong-key': 'signed with an unknown key',
  };
  if (warnMessages[result.status]) {
    setUpdateStatus(
      'warning: ' + warnMessages[result.status]
      + '<div class="update-confirm">'
      + '<button onclick="proceedUpdate()">proceed anyway</button>'
      + '<button onclick="cancelUpdate()">cancel</button>'
      + '</div>',
      'warn'
    );
    window._pendingUpdateHtml = newHtml;
    window._pendingUpdateVersion = version;
    return;
  }

  if (result.status === 'unsupported') {
    setUpdateStatus(
      result.message
      + '<div class="update-confirm">'
      + '<button onclick="proceedUpdate()">proceed without verification</button>'
      + '<button onclick="cancelUpdate()">cancel</button>'
      + '</div>',
      'warn'
    );
    window._pendingUpdateHtml = newHtml;
    window._pendingUpdateVersion = version;
    return;
  }

  if (result.status === 'error') {
    setUpdateStatus('verification error: ' + escHtml(result.message), 'err');
    return;
  }

  // Valid signature — proceed
  finishUpdate(newHtml, version);
}

function proceedUpdate() {
  if (window._pendingUpdateHtml) {
    finishUpdate(window._pendingUpdateHtml, window._pendingUpdateVersion);
    delete window._pendingUpdateHtml;
    delete window._pendingUpdateVersion;
  }
}

function cancelUpdate() {
  delete window._pendingUpdateHtml;
  delete window._pendingUpdateVersion;
  setUpdateStatus('update cancelled', '');
}

function finishUpdate(newHtml, version) {
  setUpdateStatus('reassembling...', '');

  // Extract current document as HTML to get data comments
  const currentHtml = document.documentElement.outerHTML;
  // But the data comments are in the body innerHTML at load time; grab from live source
  const bodyHtml = document.body.innerHTML;
  const fullHtml = '<!DOCTYPE html>\n<html>' + document.head.outerHTML + '<body>' + bodyHtml + '</body></html>';

  const oldData = extractData(fullHtml);
  // Override title from live doc
  const titleInput = $('#docTitle');
  if (titleInput) oldData.title = titleInput.value || 'untitled';

  // Build fresh data comments from live state (more reliable than regex from DOM)
  if (S.cells.length) {
    const cellData = S.cells.map(c => ({
      type: c.type,
      code: c.code,
      collapsed: c.el?.classList.contains('collapsed') || undefined
    }));
    oldData.data = '<!-- cell data: JSON array of {type, code, collapsed?} -->\n<!--AUDITABLE-DATA\n' + JSON.stringify(cellData) + '\nAUDITABLE-DATA-->';
  }
  if (window._installedModules && Object.keys(window._installedModules).length) {
    oldData.modules = '<!-- installed modules: base64-encoded JSON mapping URLs to {source, cellId} -->\n<!--AUDITABLE-MODULES\n' + encodeModules(window._installedModules) + '\nAUDITABLE-MODULES-->';
  }
  oldData.settings = '<!-- notebook settings: JSON {theme, fontSize, width, ...} -->\n<!--AUDITABLE-SETTINGS\n' + JSON.stringify(getSettings()) + '\nAUDITABLE-SETTINGS-->';

  const result = reassemble(newHtml, oldData);

  // Offer as download
  const title = (titleInput ? titleInput.value : 'untitled') || 'untitled';
  const blob = new Blob([result], { type: 'text/html' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = title.replace(/[^a-zA-Z0-9_-]/g, '_') + '.html';
  a.click();
  URL.revokeObjectURL(url);

  const vLabel = version ? ' to ' + version : '';
  setUpdateStatus('updated' + vLabel + ' \u2014 saved as ' + a.download, 'ok');
  setMsg('updated' + vLabel, 'ok');
}

// ── UPDATE FROM FILE ──

function updateFromFile() {
  const input = document.createElement('input');
  input.type = 'file';
  input.accept = '.html';
  input.onchange = async () => {
    const file = input.files[0];
    if (!file) return;
    setUpdateStatus('reading file...', '');
    const text = await file.text();

    // Try to extract version from the file
    const vMatch = text.match(/__AUDITABLE_VERSION__\s*=\s*'([^']+)'/);
    const version = vMatch ? 'v' + vMatch[1] : null;

    await applyUpdate(text, version);
  };
  input.click();
}

// ── VERIFY CURRENT DOCUMENT ──

async function verifySelf() {
  const el = $('#updateSigStatus');
  if (!el) return;

  // Reconstruct from live DOM
  const styleEl = document.querySelector('style');
  const scriptEl = document.querySelector('script');
  if (!styleEl || !scriptEl) {
    el.textContent = 'error: no style/script';
    el.className = 'update-sig update-err';
    return;
  }

  const raw = document.body.innerHTML;
  const sigMatch = raw.match(/<!--AUDITABLE-SIGNATURE\n([\s\S]*?)\nAUDITABLE-SIGNATURE-->/);
  if (!sigMatch) {
    el.textContent = 'unsigned';
    el.className = 'update-sig update-warn';
    return;
  }

  let sig;
  try { sig = JSON.parse(sigMatch[1]); } catch {
    el.textContent = 'invalid signature format';
    el.className = 'update-sig update-err';
    return;
  }

  const pubKeyB64 = __AUDITABLE_PUBLIC_KEY__;
  if (!pubKeyB64) {
    el.textContent = 'no public key configured';
    el.className = 'update-sig update-warn';
    return;
  }

  if (sig.pub !== pubKeyB64) {
    el.textContent = 'signed with unknown key';
    el.className = 'update-sig update-warn';
    return;
  }

  const content = buildSignedContent(styleEl.textContent, scriptEl.textContent);

  try {
    const pubBytes = Uint8Array.from(atob(pubKeyB64), c => c.charCodeAt(0));
    const key = await crypto.subtle.importKey(
      'raw', pubBytes, { name: 'Ed25519' }, false, ['verify']
    );
    const sigBytes = Uint8Array.from(atob(sig.sig), c => c.charCodeAt(0));
    const msgBytes = new TextEncoder().encode(content);
    const valid = await crypto.subtle.verify('Ed25519', key, sigBytes, msgBytes);
    if (valid) {
      el.textContent = 'signed \u2713';
      el.className = 'update-sig update-ok';
      setBadge('signed', 'signed', 'toolbar-badge toolbar-badge-signed');
    } else {
      el.textContent = 'signature invalid';
      el.className = 'update-sig update-err';
    }
  } catch (e) {
    if (e.name === 'NotSupportedError') {
      el.textContent = 'Ed25519 not supported';
      el.className = 'update-sig update-warn';
    } else {
      el.textContent = 'error: ' + e.message;
      el.className = 'update-sig update-err';
    }
  }
}

// ── INIT ──
(function() {
  const ver = $('#updateCurrentVer');
  if (ver) ver.textContent = 'v' + __AUDITABLE_VERSION__;
  const rel = $('#updateRelease');
  if (rel) {
    rel.textContent = __AUDITABLE_RELEASE__;
    if (__AUDITABLE_RELEASE__ === 'dev') rel.className = 'update-sig update-warn';
  }
  // Show public key status
  const keyEl = $('#updatePubKey');
  if (keyEl) {
    if (__AUDITABLE_PUBLIC_KEY__) {
      keyEl.textContent = __AUDITABLE_PUBLIC_KEY__.slice(0, 8) + '...';
      keyEl.className = 'update-sig update-key-truncated';
      keyEl.onclick = () => {
        if (keyEl.classList.contains('update-key-expanded')) {
          keyEl.textContent = __AUDITABLE_PUBLIC_KEY__.slice(0, 8) + '...';
          keyEl.classList.remove('update-key-expanded');
          keyEl.classList.add('update-key-truncated');
        } else {
          keyEl.textContent = __AUDITABLE_PUBLIC_KEY__;
          keyEl.classList.remove('update-key-truncated');
          keyEl.classList.add('update-key-expanded');
        }
      };
    } else {
      keyEl.textContent = 'not configured';
      keyEl.className = 'update-sig update-warn';
    }
  }
  // Run self-verification on load
  verifySelf();
})();

// -- save.js --

// ── MODULES ENCODING ──
// base64-encode modules JSON to avoid HTML comment / String.replace issues
// (source code can contain --, $', etc.)

function encodeModules(obj) {
  const b64 = btoa(unescape(encodeURIComponent(JSON.stringify(obj))));
  return b64.replace(/.{1,76}/g, '$&\n').trimEnd();
}

function decodeModules(raw) {
  const b64 = raw.replace(/\s/g, '');
  // detect legacy format: starts with { means raw JSON (not base64)
  if (b64.startsWith('{') || b64.startsWith('%7B')) return JSON.parse(raw);
  return JSON.parse(decodeURIComponent(escape(atob(b64))));
}

// ── SAVE / LOAD ──

// save mode: 'normal' or 'packed'
let _saveMode = 'normal';

function getSaveMode() { return _saveMode; }

function toggleSaveTray() {
  const tray = $('#saveTray');
  if (tray) tray.classList.toggle('open');
}

function setSaveMode(mode) {
  _saveMode = mode;
  // update UI
  const label = $('#saveLabel');
  if (label) label.textContent = mode === 'packed' ? 'pack' : 'save';
  const tray = $('#saveTray');
  if (tray) tray.classList.remove('open');
  // update mobile buttons
  const mobSave = $('#mobileSaveBtn');
  const mobPack = $('#mobilePackBtn');
  if (mobSave) mobSave.classList.toggle('active-mode', mode === 'normal');
  if (mobPack) mobPack.classList.toggle('active-mode', mode === 'packed');
}

function buildNotebookHtml() {
  // serialize current state back to a self-contained HTML file
  const title = $('#docTitle').value || 'untitled';

  // collect cells as data
  const cellData = S.cells.map(c => ({
    type: c.type,
    code: c.code,
    collapsed: c.el.classList.contains('collapsed') || undefined
  }));

  // get the runtime and styles from current document
  const styleEl = document.querySelector('style');
  const styles = styleEl.textContent;

  // get the script
  const scriptEl = document.querySelector('script');
  const script = scriptEl.textContent;

  // read static elements from live DOM
  const helpHTML = $('#helpOverlay').outerHTML;
  const settingsOvHTML = $('#settingsOverlay').outerHTML;
  const settingsPanHTML = $('#settingsPanel').outerHTML.replace(/display:\s*block;?/, '');
  const updateOvHTML = $('#updateOverlay').outerHTML.replace(/\bvisible\b/, '').replace(/class="\s*"/, 'class=""');
  const updatePanEl = $('#updatePanel').cloneNode(true);
  updatePanEl.style.display = '';
  // reset update status and dynamic text
  const uStatus = updatePanEl.querySelector('#updateStatus');
  if (uStatus) { uStatus.innerHTML = ''; uStatus.className = 'update-status'; }
  const updatePanHTML = updatePanEl.outerHTML.replace(/display:\s*block;?/, '');
  const statusbarHTML = document.querySelector('.statusbar').outerHTML;

  // read toolbar from live DOM and patch the title value
  const toolbarEl = document.querySelector('.toolbar').cloneNode(true);
  toolbarEl.querySelector('#docTitle').value = title;
  toolbarEl.querySelector('#toolbarStatus').textContent = '';
  // reset autorun button state to match saved mode
  const autoBtn = toolbarEl.querySelector('#autorunBtn');
  const savedMode = S.autorun ? 'reactive' : 'manual';
  if (autoBtn) {
    autoBtn.className = savedMode === 'reactive' ? 'autorun-on' : 'autorun-off';
    autoBtn.textContent = savedMode === 'reactive' ? '\u25b6' : '\u2016';
  }
  // close overflow and save tray if open
  const overflow = toolbarEl.querySelector('.toolbar-overflow');
  if (overflow) overflow.classList.remove('open');
  const saveTray = toolbarEl.querySelector('#saveTray');
  if (saveTray) saveTray.classList.remove('open');
  // reset save label to default
  const saveLabel = toolbarEl.querySelector('#saveLabel');
  if (saveLabel) saveLabel.textContent = 'save';
  // clear badges (they get set dynamically on load)
  const badges = toolbarEl.querySelector('.toolbar-badges');
  if (badges) badges.innerHTML = '';
  const toolbarHTML = toolbarEl.outerHTML;

  // capture find bar and reset to default state
  const findBarEl = $('#findBar').cloneNode(true);
  findBarEl.style.display = '';
  findBarEl.classList.remove('show-replace');
  findBarEl.querySelector('#findInput').value = '';
  findBarEl.querySelector('#replaceInput').value = '';
  findBarEl.querySelector('#findCount').textContent = '';
  findBarEl.querySelector('#findCaseBtn').classList.remove('active');
  findBarEl.querySelector('#findRegexBtn').classList.remove('active');
  const findBarHTML = findBarEl.outerHTML;

  // build output HTML
  return `<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Auditable \u2014 ${esc(title)}</title>
<style>\n${styles}\n</style>
</head>
<body>

${helpHTML}

${settingsOvHTML}
${settingsPanHTML}

${updateOvHTML}
${updatePanHTML}

${toolbarHTML}

${findBarHTML}

<button class="present-exit" onclick="togglePresent()">\u2715 exit</button>

<div class="notebook" id="notebook">
</div>

${statusbarHTML}

${'<!-- cell data: JSON array of {type, code, collapsed?} -->\n<!--AUDITABLE-DATA\n' + JSON.stringify(cellData) + '\nAUDITABLE-DATA-->'}
${Object.keys(window._installedModules || {}).length ? '<!-- installed modules: base64-encoded JSON mapping URLs to {source, cellId} -->\n<!--AUDITABLE-MODULES\n' + encodeModules(window._installedModules) + '\nAUDITABLE-MODULES-->' : ''}
${'<!-- notebook settings: JSON {theme, fontSize, width, ...} -->\n<!--AUDITABLE-SETTINGS\n' + JSON.stringify(getSettings()) + '\nAUDITABLE-SETTINGS-->'}

<script>\n${script}\n<\/script>
</body>
</html>`;
}

function downloadHtml(html, title) {
  const blob = new Blob([html], { type: 'text/html' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = title.replace(/[^a-zA-Z0-9_-]/g, '_') + '.html';
  a.click();
  URL.revokeObjectURL(url);
  return a.download;
}

function saveNotebook() {
  if (_saveMode === 'packed') {
    savePackedNotebook();
    return;
  }
  const title = $('#docTitle').value || 'untitled';
  const html = buildNotebookHtml();

  // AF bridge: send serialized HTML to parent shell instead of downloading
  if (window.__AF_BRIDGE__) {
    window.parent.postMessage({ type: 'af:serialized', payload: { html } }, '*');
    setMsg('saved', 'ok');
    return;
  }

  const fn = downloadHtml(html, title);
  setMsg('saved ' + fn, 'ok');
}

async function savePackedNotebook() {
  const title = $('#docTitle').value || 'untitled';
  const html = buildNotebookHtml();

  try {
    // compress via CompressionStream
    const blob = new Blob([html]);
    const cs = new CompressionStream('gzip');
    const stream = blob.stream().pipeThrough(cs);
    const compressed = await new Response(stream).arrayBuffer();
    const b64 = btoa(String.fromCharCode(...new Uint8Array(compressed)));
    const b64Lines = b64.replace(/.{1,76}/g, '$&\n');

    const loader = `<!DOCTYPE html>
<!-- packed auditable notebook -->
<!-- the full notebook is gzip-compressed and base64-encoded in the <pre> block below. -->
<!-- on load, the script decodes and decompresses it, then replaces the page contents. -->
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Auditable \u2014 ${esc(title)}</title>
  <style>
    html { background: #1a1a1a }
    body { color: #999; font: 14px/1.5 monospace; display: flex; justify-content: center; align-items: center; height: 100vh; margin: 0 }
    #_d { display: none }
  </style>
</head>
<body>
<div id="_l">unpacking\u2026</div>

<!-- base64-encoded gzip payload (76-char lines) -->
<pre id="_d">
${b64Lines}</pre>

<script>
(async () => {
  // 1. read base64 from the hidden <pre>, strip whitespace from line wrapping
  var b64 = document.getElementById('_d').textContent.replace(/\\s/g, '');

  // 2. decode base64 to binary
  var bytes = Uint8Array.from(atob(b64), c => c.charCodeAt(0));

  // 3. decompress gzip via DecompressionStream
  var stream = new Response(new Blob([bytes])).body.pipeThrough(new DecompressionStream('gzip'));
  var html = await new Response(stream).text();

  // 4. mark as packed (so the notebook knows it was loaded from a packed save)
  html = html.replace('<head>', '<head><meta name="auditable-packed">');

  // 5. replace the current page with the full notebook
  document.open();
  document.write(html);
  document.close();
})().catch(function(e) {
  document.getElementById('_l').textContent = 'error: ' + e.message;
});
<\/script>
</body>
</html>`;


    const fn = downloadHtml(loader, title);
    const kb = (loader.length / 1024).toFixed(0);
    setMsg('packed ' + fn + ' (' + kb + ' KB)', 'ok');
  } catch (e) {
    setMsg('pack failed: ' + e.message, 'err');
  }
}

function esc(s) {
  return s.replace(/"/g, '&quot;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
}

function exportAsTxt() {
  const title = $('#docTitle').value || 'untitled';
  const html = buildNotebookHtml();

  // extract notebook data from HTML
  const dataMatch = html.match(/<!--AUDITABLE-DATA\n([\s\S]*?)\nAUDITABLE-DATA-->/);
  let cells = [];
  if (dataMatch) {
    try { cells = JSON.parse(dataMatch[1]); } catch {}
  }

  const setMatch = html.match(/<!--AUDITABLE-SETTINGS\n([\s\S]*?)\nAUDITABLE-SETTINGS-->/);
  let settings = {};
  if (setMatch) {
    try { settings = JSON.parse(setMatch[1]); } catch {}
  }

  // extract module URLs (without sources — standalone export just records URLs)
  const modMatch = html.match(/<!--AUDITABLE-MODULES\n([\s\S]*?)\nAUDITABLE-MODULES-->/);
  let moduleUrls = [];
  if (modMatch) {
    try {
      const decoded = decodeModules(modMatch[1]);
      moduleUrls = Object.keys(decoded);
    } catch {}
  }

  // build /// formatted text
  const lines = ['/// auditable'];
  if (title && title !== 'untitled') {
    lines.push('/// title: ' + title);
  }
  const defaultSettings = { theme: 'dark', fontSize: 13, width: '860' };
  if (JSON.stringify(settings) !== JSON.stringify(defaultSettings)) {
    lines.push('/// settings: ' + JSON.stringify(settings));
  }
  for (const url of moduleUrls) {
    lines.push('/// module: ' + url);
  }
  for (const cell of cells) {
    lines.push('');
    const flags = cell.collapsed ? ' collapsed' : '';
    lines.push('/// ' + cell.type + flags);
    lines.push(cell.code || '');
  }
  const txt = lines.join('\n') + '\n';

  // download
  if (window.__AF_BRIDGE__) {
    window.parent.postMessage({ type: 'af:download', payload: { data: txt, filename: title.replace(/[^a-zA-Z0-9_-]/g, '_') + '.txt', mime: 'text/plain' } }, '*');
  } else {
    const blob = new Blob([txt], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = title.replace(/[^a-zA-Z0-9_-]/g, '_') + '.txt';
    a.click();
    URL.revokeObjectURL(url);
  }
  setMsg('exported .txt', 'ok');
}

function loadFromEmbed() {
  // look for embedded cell data in HTML comments
  const raw = document.body.innerHTML;

  // restore installed modules first (before cells run)
  const modMatch = raw.match(/<!--AUDITABLE-MODULES\n([\s\S]*?)\nAUDITABLE-MODULES-->/);
  if (modMatch) {
    try {
      window._installedModules = decodeModules(modMatch[1]);
    } catch (e) {
      console.error('Failed to parse installed modules:', e);
    }
  }

  // restore settings
  const setMatch = raw.match(/<!--AUDITABLE-SETTINGS\n([\s\S]*?)\nAUDITABLE-SETTINGS-->/);
  if (setMatch) {
    try {
      applySettings(JSON.parse(setMatch[1]));
    } catch (e) {
      console.error('Failed to parse settings:', e);
    }
  }

  // apply execution mode priority chain (localStorage > notebook > build default)
  const effectiveMode = resolveExecMode();
  const effectiveRun = resolveRunOnLoad();
  if (effectiveMode === 'manual') {
    S.autorun = false;
    const btn = document.getElementById('autorunBtn');
    const btnMobile = document.getElementById('autorunBtnMobile');
    if (btn) { btn.className = 'autorun-off'; btn.textContent = '\u2016'; btn.title = 'manual mode \u2014 only Run All or Ctrl+Enter'; }
    if (btnMobile) { btnMobile.className = 'autorun-off'; btnMobile.textContent = '\u2016'; }
    const sel = document.getElementById('setExecMode');
    if (sel) sel.value = 'manual';
  }

  const match = raw.match(/<!--AUDITABLE-DATA\n([\s\S]*?)\nAUDITABLE-DATA-->/);
  if (match) {
    try {
      const data = JSON.parse(match[1]);
      for (const c of data) {
        const cell = addCell(c.type, c.code);
        if (c.collapsed || isCollapsed(c.code)) cell.el.classList.add('collapsed');
      }
      // run after load (gated on resolved runOnLoad)
      if (effectiveRun === 'yes' && S.cells.some(c => c.type === 'code')) {
        setTimeout(runAll, 50);
      }
      return true;
    } catch (e) {
      console.error('Failed to parse embedded data:', e);
    }
  }
  return false;
}

// -- ui.js --

// ── STATUS ──

function estimateContentSize() {
  let modules = 0;
  for (const v of Object.values(window._installedModules || {})) {
    modules += typeof v === 'string' ? v.length : (v.source?.length || 0);
  }
  const cells = JSON.stringify(S.cells.map(c => ({ type: c.type, code: c.code }))).length;
  return modules + cells;
}

function estimateFileSize() {
  const style = document.querySelector('style')?.textContent.length || 0;
  const script = document.querySelector('script')?.textContent.length || 0;
  return style + script + estimateContentSize() + 2000; // ~2KB HTML boilerplate
}

function updateStatus() {
  const counts = { code: 0, md: 0, css: 0, html: 0 };
  for (const c of S.cells) if (counts[c.type] !== undefined) counts[c.type]++;
  const parts = [];
  for (const [t, n] of Object.entries(counts)) if (n > 0) parts.push(`${n} ${t}`);
  const statusText = parts.join(' \u00b7 ') || '0 cells';
  const totalBytes = estimateFileSize();
  const contentBytes = estimateContentSize();
  const useContent = window._sizeCompareRef === 'content';
  const displayBytes = useContent ? contentBytes : totalBytes;
  const sizeKB = displayBytes >= 1024 ? Math.round(displayBytes / 1024) : 1;
  const sizeText = '~' + sizeKB + ' KB' + (useContent ? ' content' : '');
  $('#statusCells').textContent = statusText;
  const compare = typeof sizeCompare === 'function' ? sizeCompare(displayBytes) : '';
  const sizeEl = document.getElementById('statusSize');
  if (sizeEl) sizeEl.textContent = (compare ? sizeText + ' \u00b7 ' + compare : sizeText) + ' \u00b7 ';
  // mirror to toolbar for mobile
  const toolbarStatus = document.getElementById('toolbarStatus');
  if (toolbarStatus) toolbarStatus.textContent = (compare || sizeText) + ' \u00b7 ' + statusText;
  updateInsertBars();
}

function updateInsertBars() {
  const nb = $('#notebook');
  // remove existing insert bars
  nb.querySelectorAll('.insert-bar').forEach(b => b.remove());

  // add one before first cell and between each pair
  for (let i = 0; i <= S.cells.length; i++) {
    const bar = document.createElement('div');
    bar.className = 'insert-bar';
    const afterId = i > 0 ? S.cells[i - 1].id : null;
    bar.innerHTML = `<div class="insert-btns">
      <button onclick="insertAt(${afterId},'code')">+ code</button>
      <button onclick="insertAt(${afterId},'md')">+ md</button>
      <button onclick="insertAt(${afterId},'css')">+ css</button>
      <button onclick="insertAt(${afterId},'html')">+ html</button>
    </div>`;
    if (i < S.cells.length) {
      S.cells[i].el.before(bar);
    } else {
      nb.appendChild(bar);
    }
  }
}

function insertAt(afterId, type) {
  let cell;
  if (afterId === null && S.cells.length > 0) {
    // insert before first cell
    cell = addCellWithUndo(type, '', null, S.cells[0].id);
  } else {
    cell = addCellWithUndo(type, '', afterId);
  }
  selectCell(cell.id);
  editCell(cell.id);
}

function setMsg(msg, cls = '') {
  const el = $('#statusMsg');
  el.textContent = msg;
  el.className = 'status-msg' + (cls ? ' ' + cls : '');
  if (cls) setTimeout(() => { el.textContent = ''; el.className = 'status-msg'; }, 3000);
}

// -- find.js --

// ── FIND / REPLACE ──

function openFind(showReplace) {
  const bar = $('#findBar');
  bar.style.display = 'flex';
  S.findActive = true;
  if (showReplace) bar.classList.add('show-replace');
  else bar.classList.remove('show-replace');
  const inp = $('#findInput');
  // pre-fill from textarea selection
  const active = document.activeElement;
  if (active && active.tagName === 'TEXTAREA') {
    const sel = active.value.substring(active.selectionStart, active.selectionEnd);
    if (sel && sel.indexOf('\n') === -1) inp.value = sel;
  }
  inp.focus();
  inp.select();
  if (inp.value) findComputeMatches();
}

function closeFind() {
  const bar = $('#findBar');
  bar.style.display = '';
  bar.classList.remove('show-replace');
  S.findActive = false;
  S.findQuery = '';
  S.findMatches = [];
  S.findCurrent = -1;
  $('#findCount').textContent = '';
  // remove all overlays
  document.querySelectorAll('.search-overlay').forEach(el => el.remove());
  document.querySelectorAll('.md-search-wrap').forEach(wrap => {
    const ta = wrap.querySelector('textarea');
    if (ta) wrap.parentNode.insertBefore(ta, wrap);
    wrap.remove();
  });
}

function escapeRegex(s) {
  return s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

function findComputeMatches() {
  const query = $('#findInput').value;
  S.findQuery = query;
  S.findMatches = [];
  if (!query) {
    S.findCurrent = -1;
    findUpdateCount();
    document.querySelectorAll('.search-overlay').forEach(el => el.remove());
    document.querySelectorAll('.md-search-wrap').forEach(wrap => {
      const ta = wrap.querySelector('textarea');
      if (ta) wrap.parentNode.insertBefore(ta, wrap);
      wrap.remove();
    });
    return;
  }
  const flags = S.findCase ? 'g' : 'gi';
  const pattern = S.findRegex ? query : escapeRegex(query);
  let re;
  try { re = new RegExp(pattern, flags); }
  catch (e) {
    S.findCurrent = -1;
    $('#findCount').textContent = 'bad regex';
    return;
  }

  for (const cell of S.cells) {
    let m;
    re.lastIndex = 0;
    while ((m = re.exec(cell.code)) !== null) {
      S.findMatches.push({ cellId: cell.id, index: m.index, length: m[0].length });
      if (m[0].length === 0) re.lastIndex++;  // prevent infinite loop on zero-length match
    }
  }
  // keep findCurrent in range
  if (S.findMatches.length === 0) S.findCurrent = -1;
  else if (S.findCurrent < 0 || S.findCurrent >= S.findMatches.length) S.findCurrent = 0;
  findUpdateOverlays();
  findUpdateCount();
}

function findNext() {
  if (!S.findMatches.length) return;
  S.findCurrent = (S.findCurrent + 1) % S.findMatches.length;
  findUpdateOverlays();
  findUpdateCount();
  findScrollToMatch();
}

function findPrev() {
  if (!S.findMatches.length) return;
  S.findCurrent = (S.findCurrent - 1 + S.findMatches.length) % S.findMatches.length;
  findUpdateOverlays();
  findUpdateCount();
  findScrollToMatch();
}

function findReplace() {
  if (S.findCurrent < 0 || S.findCurrent >= S.findMatches.length) return;
  const match = S.findMatches[S.findCurrent];
  const cell = S.cells.find(c => c.id === match.cellId);
  if (!cell) return;
  const replaceVal = $('#replaceInput').value;
  if (S.findRegex) {
    const flags = S.findCase ? '' : 'i';
    try {
      const re = new RegExp(S.findQuery, flags);
      const matched = cell.code.substring(match.index, match.index + match.length);
      const replaced = matched.replace(re, replaceVal);
      cell.code = cell.code.substring(0, match.index) + replaced + cell.code.substring(match.index + match.length);
    } catch (e) { return; }
  } else {
    cell.code = cell.code.substring(0, match.index) + replaceVal + cell.code.substring(match.index + match.length);
  }
  // update textarea
  const ta = cell.el.querySelector('textarea');
  if (ta) {
    ta.value = cell.code;
    ta.dispatchEvent(new Event('input'));
  }
  findComputeMatches();
}

function findReplaceAll() {
  const query = S.findQuery;
  if (!query) return;
  const replaceVal = $('#replaceInput').value;
  const flags = S.findCase ? 'g' : 'gi';
  const pattern = S.findRegex ? query : escapeRegex(query);
  let re;
  try { re = new RegExp(pattern, flags); }
  catch (e) { return; }
  let count = 0;
  for (const cell of S.cells) {
    const before = cell.code;
    if (S.findRegex) {
      cell.code = cell.code.replace(re, (...args) => { count++; return replaceVal.replace(/\$(\d+)/g, (_, n) => args[+n] != null ? args[+n] : ''); });
    } else {
      cell.code = cell.code.replace(re, () => { count++; return replaceVal; });
    }
    if (cell.code !== before) {
      const ta = cell.el.querySelector('textarea');
      if (ta) {
        ta.value = cell.code;
        ta.dispatchEvent(new Event('input'));
      }
    }
  }
  findComputeMatches();
}

function findUpdateOverlays() {
  // remove existing overlays
  document.querySelectorAll('.search-overlay').forEach(el => el.remove());
  // unwrap md-search-wraps
  document.querySelectorAll('.md-search-wrap').forEach(wrap => {
    const ta = wrap.querySelector('textarea');
    if (ta) wrap.parentNode.insertBefore(ta, wrap);
    wrap.remove();
  });

  if (!S.findQuery || !S.findMatches.length) return;

  // group matches by cellId
  const byCell = {};
  S.findMatches.forEach((m, i) => {
    if (!byCell[m.cellId]) byCell[m.cellId] = [];
    byCell[m.cellId].push({ ...m, globalIdx: i });
  });

  for (const cellId of Object.keys(byCell)) {
    const cell = S.cells.find(c => c.id === parseInt(cellId));
    if (!cell) continue;
    const matches = byCell[cellId];
    const code = cell.code;

    // build overlay content
    let html = '';
    let pos = 0;
    for (const m of matches) {
      // text before match
      html += escHtml(code.substring(pos, m.index));
      const cls = m.globalIdx === S.findCurrent ? 'search-match search-match-current' : 'search-match';
      html += `<mark class="${cls}">${escHtml(code.substring(m.index, m.index + m.length))}</mark>`;
      pos = m.index + m.length;
    }
    html += escHtml(code.substring(pos));

    const overlay = document.createElement('div');

    if (cell.type === 'md') {
      // markdown cells: wrap textarea in md-search-wrap
      overlay.className = 'search-overlay search-overlay-md';
      overlay.innerHTML = html;
      const editWrap = cell.el.querySelector('.cell-md-edit');
      const ta = editWrap.querySelector('textarea');
      let wrap = editWrap.querySelector('.md-search-wrap');
      if (!wrap) {
        wrap = document.createElement('div');
        wrap.className = 'md-search-wrap';
        ta.parentNode.insertBefore(wrap, ta);
        wrap.appendChild(ta);
      }
      wrap.appendChild(overlay);
      wireScrollSync(ta, overlay);
    } else {
      // code, css, html cells: insert in editor-wrap
      overlay.className = 'search-overlay';
      overlay.innerHTML = html;
      let editorWrap;
      if (cell.type === 'code') editorWrap = cell.el.querySelector('.cell-code .editor-wrap');
      else if (cell.type === 'css') editorWrap = cell.el.querySelector('.cell-css-edit .editor-wrap');
      else if (cell.type === 'html') editorWrap = cell.el.querySelector('.cell-html-edit .editor-wrap');
      if (editorWrap) {
        editorWrap.appendChild(overlay);
        const ta = editorWrap.querySelector('textarea');
        if (ta) wireScrollSync(ta, overlay);
      }
    }
  }
}

function wireScrollSync(ta, overlay) {
  if (ta._searchScrollWired) return;
  ta._searchScrollWired = true;
  ta.addEventListener('scroll', () => {
    const ov = ta.closest('.editor-wrap, .md-search-wrap');
    if (!ov) return;
    const so = ov.querySelector('.search-overlay');
    if (so) {
      so.scrollTop = ta.scrollTop;
      so.scrollLeft = ta.scrollLeft;
    }
  });
}

function findUpdateCount() {
  const el = $('#findCount');
  if (!S.findQuery) { el.textContent = ''; return; }
  if (S.findMatches.length === 0) { el.textContent = 'no results'; return; }
  el.textContent = `${S.findCurrent + 1}/${S.findMatches.length}`;
}

function findScrollToMatch() {
  if (S.findCurrent < 0) return;
  const match = S.findMatches[S.findCurrent];
  if (!match) return;
  const cell = S.cells.find(c => c.id === match.cellId);
  if (!cell) return;

  // open editor for non-code cells if needed
  if (cell.type === 'css') {
    const editWrap = cell.el.querySelector('.cell-css-edit');
    const view = cell.el.querySelector('.cell-css-view');
    if (editWrap.style.display === 'none') {
      const ta = editWrap.querySelector('textarea');
      editWrap.style.display = '';
      view.style.display = 'none';
      ta.value = cell.code;
      autoResize({ target: ta });
    }
  } else if (cell.type === 'html') {
    const editWrap = cell.el.querySelector('.cell-html-edit');
    const view = cell.el.querySelector('.cell-html-view');
    if (editWrap.style.display === 'none') {
      const ta = editWrap.querySelector('textarea');
      editWrap.style.display = '';
      view.style.display = 'none';
      ta.value = cell.code;
      autoResize({ target: ta });
    }
  } else if (cell.type === 'md') {
    const editWrap = cell.el.querySelector('.cell-md-edit');
    const view = cell.el.querySelector('.cell-md-view');
    if (editWrap.style.display === 'none') {
      const ta = editWrap.querySelector('textarea');
      editWrap.style.display = '';
      view.style.display = 'none';
      ta.value = cell.code;
      autoResize({ target: ta });
    }
  }

  // uncollapse if collapsed
  cell.el.classList.remove('collapsed');

  // scroll cell into view
  cell.el.scrollIntoView({ block: 'nearest', behavior: 'smooth' });

  // scroll textarea to match line
  const ta = cell.type === 'md'
    ? cell.el.querySelector('.cell-md-edit textarea')
    : cell.type === 'css'
    ? cell.el.querySelector('.cell-css-edit textarea')
    : cell.type === 'html'
    ? cell.el.querySelector('.cell-html-edit textarea')
    : cell.el.querySelector('textarea');
  if (ta) {
    const textBefore = cell.code.substring(0, match.index);
    const lineNum = textBefore.split('\n').length - 1;
    const lineHeight = parseFloat(getComputedStyle(ta).lineHeight) || 20;
    ta.scrollTop = Math.max(0, lineNum * lineHeight - ta.clientHeight / 2);
  }
}

function escHtml(s) {
  return s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
}

// ── EVENT WIRING ──
(function () {
  const findInput = $('#findInput');
  const replaceInput = $('#replaceInput');
  if (!findInput) return;

  findInput.addEventListener('input', () => findComputeMatches());

  findInput.addEventListener('keydown', (e) => {
    if (e.key === 'Enter' && e.shiftKey) { e.preventDefault(); findPrev(); }
    else if (e.key === 'Enter') { e.preventDefault(); findNext(); }
    else if (e.key === 'Escape') { e.preventDefault(); closeFind(); }
  });

  if (replaceInput) {
    replaceInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') { e.preventDefault(); findReplace(); }
      else if (e.key === 'Escape') { e.preventDefault(); closeFind(); }
    });
  }

  const nextBtn = $('#findNextBtn');
  const prevBtn = $('#findPrevBtn');
  const replBtn = $('#findReplaceBtn');
  const replAllBtn = $('#findReplaceAllBtn');
  const caseBtn = $('#findCaseBtn');
  const regexBtn = $('#findRegexBtn');
  const closeBtn = $('#findCloseBtn');

  if (nextBtn) nextBtn.addEventListener('click', findNext);
  if (prevBtn) prevBtn.addEventListener('click', findPrev);
  if (replBtn) replBtn.addEventListener('click', findReplace);
  if (replAllBtn) replAllBtn.addEventListener('click', findReplaceAll);
  if (closeBtn) closeBtn.addEventListener('click', closeFind);
  if (caseBtn) caseBtn.addEventListener('click', () => {
    S.findCase = !S.findCase;
    caseBtn.classList.toggle('active', S.findCase);
    findComputeMatches();
  });
  if (regexBtn) regexBtn.addEventListener('click', () => {
    S.findRegex = !S.findRegex;
    regexBtn.classList.toggle('active', S.findRegex);
    findComputeMatches();
  });

  // live recompute on edit — delegation
  let recomputeTimer = null;
  document.getElementById('notebook').addEventListener('input', (e) => {
    if (!S.findActive) return;
    if (e.target.tagName !== 'TEXTAREA') return;
    clearTimeout(recomputeTimer);
    recomputeTimer = setTimeout(findComputeMatches, 150);
  });
})();

// -- complete.js --

// ── AUTOCOMPLETE ENGINE ──

// well-known property lists for dot completion on builtins
const KNOWN_PROPS = {
  Math: ['abs','acos','asin','atan','atan2','ceil','cos','exp','floor','hypot',
         'log','log2','log10','max','min','pow','random','round','sign','sin',
         'sqrt','tan','trunc','PI','E','LN2','LN10'],
  Array: ['from','isArray','of'],
  Object: ['keys','values','entries','assign','freeze','create','defineProperty','fromEntries','hasOwn'],
  JSON: ['parse','stringify'],
  console: ['log','warn','error','info','table','time','timeEnd','clear'],
  Promise: ['all','allSettled','any','race','resolve','reject'],
  Number: ['isFinite','isInteger','isNaN','parseFloat','parseInt','MAX_SAFE_INTEGER','MIN_SAFE_INTEGER','EPSILON'],
  String: ['fromCharCode','fromCodePoint','raw'],
  ui: ['display','print','canvas','table','slider','dropdown','checkbox','textInput'],
  std: ['csv','fetchJSON','sum','mean','median','extent','bin','linspace',
        'unique','zip','cross','file','download','el','copy','fmt'],
};

// common prototype methods by type
const PROTO_PROPS = {
  array: ['push','pop','shift','unshift','splice','slice','concat','join','reverse',
          'sort','map','filter','reduce','reduceRight','find','findIndex','indexOf',
          'includes','every','some','flat','flatMap','fill','forEach','at','length'],
  string: ['charAt','charCodeAt','codePointAt','concat','endsWith','includes',
           'indexOf','lastIndexOf','match','matchAll','padEnd','padStart','repeat',
           'replace','replaceAll','search','slice','split','startsWith','substring',
           'toLowerCase','toUpperCase','trim','trimEnd','trimStart','at','length'],
  number: ['toFixed','toPrecision','toString','valueOf'],
};

// ── BUILTIN HELP (injected by build.js from src/builtins.json) ──

const BUILTIN_HELP = {
  "ui.display": {
    "sig": "ui.display(...values)",
    "desc": "output values to cell"
  },
  "ui.canvas": {
    "sig": "ui.canvas(w?, h?)",
    "desc": "create/reuse canvas (default 400\u00d7300)"
  },
  "ui.table": {
    "sig": "ui.table(data, columns?)",
    "desc": "render array of objects as table"
  },
  "ui.slider": {
    "sig": "ui.slider(label, default?, {min,max,step,onInput,onChange}?)",
    "desc": "range input \u2014 reactive, or callback via onInput/onChange"
  },
  "ui.dropdown": {
    "sig": "ui.dropdown(label, options, default?, {onInput,onChange}?)",
    "desc": "select menu \u2014 reactive, or callback via onInput/onChange"
  },
  "ui.checkbox": {
    "sig": "ui.checkbox(label, default?, {onInput,onChange}?)",
    "desc": "toggle \u2014 reactive, or callback via onInput/onChange"
  },
  "ui.textInput": {
    "sig": "ui.textInput(label, default?, {onInput,onChange}?)",
    "desc": "text field \u2014 reactive, or callback via onInput/onChange"
  },
  "std.csv": {
    "sig": "std.csv(text, {separator?, typed?}?)",
    "desc": "parse CSV text to array of objects"
  },
  "std.fetchJSON": {
    "sig": "std.fetchJSON(url)",
    "desc": "fetch URL and parse JSON"
  },
  "std.sum": {
    "sig": "std.sum(arr, fn?)",
    "desc": "sum array values"
  },
  "std.mean": {
    "sig": "std.mean(arr, fn?)",
    "desc": "arithmetic mean"
  },
  "std.median": {
    "sig": "std.median(arr, fn?)",
    "desc": "median value"
  },
  "std.extent": {
    "sig": "std.extent(arr, fn?)",
    "desc": "returns [min, max]"
  },
  "std.bin": {
    "sig": "std.bin(arr, n?, fn?)",
    "desc": "histogram bins (default 10)"
  },
  "std.linspace": {
    "sig": "std.linspace(start, stop, n)",
    "desc": "evenly-spaced numbers"
  },
  "std.unique": {
    "sig": "std.unique(arr, fn?)",
    "desc": "unique values with optional key fn"
  },
  "std.zip": {
    "sig": "std.zip(...arrays)",
    "desc": "zip arrays together"
  },
  "std.cross": {
    "sig": "std.cross(...arrays)",
    "desc": "cartesian product"
  },
  "std.file": {
    "sig": "std.file(accept?)",
    "desc": "open file picker"
  },
  "std.download": {
    "sig": "std.download(data, filename, mimeType?)",
    "desc": "download data as file"
  },
  "std.el": {
    "sig": "std.el(tag, attrs?, ...children)",
    "desc": "create DOM element"
  },
  "std.copy": {
    "sig": "std.copy(text)",
    "desc": "copy text to clipboard"
  },
  "std.fmt": {
    "sig": "std.fmt(number, {decimals?, prefix?, suffix?}?)",
    "desc": "format number to string"
  },
  "print": {
    "sig": "print(...values)",
    "desc": "output values to cell (alias for ui.display)"
  },
  "load": {
    "sig": "load(url)",
    "desc": "import ES module (cached). @std, @python supported."
  },
  "install": {
    "sig": "install(url)",
    "desc": "fetch & embed module for offline"
  },
  "invalidation": {
    "sig": "invalidation",
    "desc": "promise \u2014 resolves when cell re-runs"
  },
  "atra": {
    "sig": "atra`...` or atra({imports})`...`",
    "desc": "compile Fortran/Pascal to Wasm (load ext/atra/index.js)"
  }
};

// ── FUZZY MATCHING ──

// returns { score, indices } or null if no match
// indices = positions in `text` that matched characters from `query`
function fuzzyMatch(query, text) {
  const qLen = query.length;
  const tLen = text.length;
  if (qLen === 0) return { score: 0, indices: [] };
  if (qLen > tLen) return null;

  const qLower = query.toLowerCase();
  const tLower = text.toLowerCase();

  // fast check: all query chars exist in text in order
  let qi = 0;
  for (let ti = 0; ti < tLen && qi < qLen; ti++) {
    if (qLower[qi] === tLower[ti]) qi++;
  }
  if (qi < qLen) return null;

  // find best match using a greedy approach that prefers word boundaries
  // word boundaries: start of string, after _ or $, camelCase transitions
  const indices = [];
  qi = 0;

  // first pass: try to match at word boundaries
  const boundaryIndices = [];
  let bqi = 0;
  for (let ti = 0; ti < tLen && bqi < qLen; ti++) {
    if (qLower[bqi] !== tLower[ti]) continue;
    const isBoundary = ti === 0
      || text[ti - 1] === '_' || text[ti - 1] === '$'
      || (text[ti] >= 'A' && text[ti] <= 'Z' && (ti === 0 || text[ti - 1] < 'A' || text[ti - 1] > 'Z'));
    if (isBoundary) {
      boundaryIndices.push(ti);
      bqi++;
    }
  }

  if (bqi === qLen) {
    // all chars matched at boundaries — use those indices
    indices.push(...boundaryIndices);
  } else {
    // fallback: greedy left-to-right match, prefer consecutive runs
    qi = 0;
    for (let ti = 0; ti < tLen && qi < qLen; ti++) {
      if (qLower[qi] === tLower[ti]) {
        indices.push(ti);
        qi++;
      }
    }
  }

  // score the match
  let score = 0;

  // bonus for matching at start of string
  if (indices[0] === 0) score += 10;

  // bonus for consecutive characters
  for (let i = 1; i < indices.length; i++) {
    if (indices[i] === indices[i - 1] + 1) score += 5;
  }

  // bonus for word boundary matches
  for (const idx of indices) {
    if (idx === 0) { score += 3; continue; }
    const prev = text[idx - 1];
    if (prev === '_' || prev === '$') { score += 3; continue; }
    if (text[idx] >= 'A' && text[idx] <= 'Z' && (prev < 'A' || prev > 'Z')) score += 3;
  }

  // bonus for exact case match
  for (let i = 0; i < indices.length; i++) {
    if (query[i] === text[indices[i]]) score += 1;
  }

  // penalty for spread-out matches (large gaps between indices)
  const span = indices[indices.length - 1] - indices[0];
  score -= span * 0.5;

  // slight penalty for longer names (prefer shorter completions)
  score -= tLen * 0.1;

  return { score, indices };
}

// determine cursor context: is it inside a string or comment?
function cursorContext(code, cursor) {
  let i = 0;
  while (i < cursor) {
    const ch = code[i];
    // single-line comment
    if (ch === '/' && code[i + 1] === '/') {
      const nl = code.indexOf('\n', i);
      if (nl === -1 || nl >= cursor) return 'comment';
      i = nl + 1;
      continue;
    }
    // block comment
    if (ch === '/' && code[i + 1] === '*') {
      const end = code.indexOf('*/', i + 2);
      if (end === -1 || end + 2 > cursor) return 'comment';
      i = end + 2;
      continue;
    }
    // single-quoted string
    if (ch === "'") {
      i++;
      while (i < code.length) {
        if (code[i] === '\\') { i += 2; continue; }
        if (code[i] === "'") { i++; break; }
        if (i >= cursor) return 'string';
        i++;
      }
      continue;
    }
    // double-quoted string
    if (ch === '"') {
      i++;
      while (i < code.length) {
        if (code[i] === '\\') { i += 2; continue; }
        if (code[i] === '"') { i++; break; }
        if (i >= cursor) return 'string';
        i++;
      }
      continue;
    }
    // template literal (possibly tagged)
    if (ch === '`') {
      // look back for a tag name: identifier immediately before the backtick,
      // or curried form: identifier(...) before the backtick
      let tagName = null;
      if (i > 0 && typeof window !== 'undefined' && window._taggedLanguages) {
        let te = i;
        let ts = te;
        // direct form: ident`
        while (ts > 0 && /\w/.test(code[ts - 1])) ts--;
        if (ts < te) {
          const candidate = code.slice(ts, te);
          if (window._taggedLanguages[candidate]) tagName = candidate;
        }
        // curried form: ident(...)`
        if (!tagName && code[i - 1] === ')') {
          let p = i - 2, depth = 1;
          while (p >= 0 && depth > 0) {
            if (code[p] === ')') depth++;
            else if (code[p] === '(') depth--;
            p--;
          }
          // p now points one before the (
          let ne = p + 1;
          let ns = ne;
          while (ns > 0 && /\w/.test(code[ns - 1])) ns--;
          if (ns < ne) {
            const candidate = code.slice(ns, ne);
            if (window._taggedLanguages[candidate]) tagName = candidate;
          }
        }
      }

      i++;
      let depth = 0;
      while (i < code.length) {
        if (code[i] === '\\') { i += 2; continue; }
        if (code[i] === '$' && code[i + 1] === '{') {
          depth++;
          i += 2;
          // inside ${...} — this is code context
          let braces = 1;
          while (i < code.length && braces > 0) {
            if (code[i] === '{') braces++;
            else if (code[i] === '}') { braces--; if (braces === 0) break; }
            if (i >= cursor) return 'code'; // inside template expression = code
            i++;
          }
          if (i >= cursor) return 'code';
          i++; // skip closing }
          continue;
        }
        if (code[i] === '`') { i++; break; }
        if (i >= cursor) return tagName ? { type: 'tagged', lang: tagName } : 'string';
        i++;
      }
      continue;
    }
    i++;
  }
  return 'code';
}

// extract the word being typed at cursor position
function extractPrefix(code, cursor) {
  let end = cursor;
  let start = cursor;
  while (start > 0 && /[a-zA-Z0-9_$]/.test(code[start - 1])) start--;
  return { prefix: code.slice(start, end), start };
}

// detect dot access: returns the expression before the dot, or null
function detectDot(code, cursor) {
  // cursor is right after a dot or after dot + partial word
  const before = code.slice(0, cursor);
  // match patterns like "identifier." or "identifier.par" at end
  const m = before.match(/([a-zA-Z_$][\w$]*)\.\s*([a-zA-Z_$][\w$]*)?$/);
  if (m) return { obj: m[1], prefix: m[2] || '' };
  return null;
}

function getPropsForValue(val) {
  if (val == null) return [];
  const props = new Set();
  // own properties
  const own = Object.getOwnPropertyNames(val);
  for (const p of own) {
    if (/^[a-zA-Z_$]/.test(p)) props.add(p);
  }
  // prototype chain (1 level)
  const proto = Object.getPrototypeOf(val);
  if (proto && proto !== Object.prototype) {
    try {
      const pNames = Object.getOwnPropertyNames(proto);
      for (const p of pNames) {
        if (p !== 'constructor' && /^[a-zA-Z_$]/.test(p)) props.add(p);
      }
    } catch {}
  }
  return [...props];
}

function getCompletions(code, cursor, cellId) {
  const ctx = cursorContext(code, cursor);

  // tagged template literal — delegate to extension completions
  if (ctx && typeof ctx === 'object' && ctx.type === 'tagged') {
    const lang = typeof window !== 'undefined' && window._taggedLanguages
      && window._taggedLanguages[ctx.lang];
    if (lang && lang.completions) {
      const { prefix, start } = extractPrefix(code, cursor);
      if (!prefix) return { prefix: '', items: [] };
      const extItems = lang.completions(prefix);
      // score and annotate items
      const items = [];
      for (const it of extItems) {
        const m = fuzzyMatch(prefix, it.text);
        if (m) items.push({ text: it.text, kind: it.kind || 'var', score: m.score, indices: m.indices });
      }
      items.sort((a, b) => b.score - a.score || a.text.localeCompare(b.text));
      return { prefix, items: items.slice(0, 30) };
    }
    return { prefix: '', items: [] };
  }

  if (ctx !== 'code') return { prefix: '', items: [] };

  // check for dot completion
  const dot = detectDot(code, cursor);
  if (dot) {
    const items = [];
    const prefix = dot.prefix;
    let propList = [];

    // check known builtins
    if (KNOWN_PROPS[dot.obj]) {
      propList = KNOWN_PROPS[dot.obj];
    } else if (dot.obj in S.scope) {
      // live value inspection
      const val = S.scope[dot.obj];
      if (val != null) {
        propList = getPropsForValue(val);
        // also add type-based suggestions
        if (Array.isArray(val)) propList = [...new Set([...propList, ...PROTO_PROPS.array])];
        else if (typeof val === 'string') propList = [...new Set([...propList, ...PROTO_PROPS.string])];
        else if (typeof val === 'number') propList = [...new Set([...propList, ...PROTO_PROPS.number])];
      }
    }

    for (const p of propList) {
      if (!prefix) {
        items.push({ text: p, kind: 'prop', score: 0, indices: [] });
        continue;
      }
      const m = fuzzyMatch(prefix, p);
      if (m) items.push({ text: p, kind: 'prop', score: m.score, indices: m.indices });
    }

    items.sort((a, b) => b.score - a.score || a.text.localeCompare(b.text));
    return { prefix, items: items.slice(0, 30) };
  }

  // word prefix completion
  const { prefix, start } = extractPrefix(code, cursor);
  if (!prefix) return { prefix: '', items: [] };

  const items = [];
  const seen = new Set();

  // collect candidates from all sources with their kind
  const candidates = [];

  // 1. scope variables
  for (const name of Object.keys(S.scope)) {
    if (!seen.has(name)) { seen.add(name); candidates.push({ text: name, kind: 'var' }); }
  }

  // 2. own cell defines
  const cell = S.cells.find(c => c.id === cellId);
  if (cell && cell.defines) {
    for (const name of cell.defines) {
      if (!seen.has(name)) { seen.add(name); candidates.push({ text: name, kind: 'def' }); }
    }
  }

  // 3. builtin functions (with help detail)
  for (const name of Object.keys(BUILTIN_HELP)) {
    if (!seen.has(name)) {
      seen.add(name);
      const h = BUILTIN_HELP[name];
      candidates.push({ text: name, kind: 'fn', detail: h.sig });
    }
  }

  // 4. JS builtins
  for (const name of JS_BUILTINS) {
    if (!seen.has(name)) { seen.add(name); candidates.push({ text: name, kind: 'const' }); }
  }

  // 5. JS keywords (min 2 chars to avoid noise)
  if (prefix.length >= 2) {
    for (const name of JS_KEYWORDS) {
      if (!seen.has(name)) { seen.add(name); candidates.push({ text: name, kind: 'kw' }); }
    }
  }

  // fuzzy match all candidates
  for (const c of candidates) {
    if (c.text === prefix) continue; // skip exact match (already typed)
    const m = fuzzyMatch(prefix, c.text);
    if (m) {
      const item = { text: c.text, kind: c.kind, score: m.score, indices: m.indices };
      if (c.detail) item.detail = c.detail;
      items.push(item);
    }
  }

  // sort by score descending, then alphabetical
  items.sort((a, b) => b.score - a.score || a.text.localeCompare(b.text));

  return { prefix, items: items.slice(0, 30) };
}

// ── TEXTAREA ADAPTER ──

const KIND_LABELS = { var: 'v', fn: 'f', kw: 'k', const: 'c', prop: 'p', def: 'd' };

let activeMenu = null;
let activeState = null;
let activeSigHint = null;

function dismissAutocomplete() {
  if (activeMenu) {
    activeMenu.remove();
    activeMenu = null;
    activeState = null;
  }
}

function dismissSigHint() {
  if (activeSigHint) {
    activeSigHint.remove();
    activeSigHint = null;
  }
}

// detect if cursor is inside a function call's arguments for a known builtin
function detectCallContext(code, cursor) {
  // scan backwards from cursor to find an unmatched (
  let depth = 0;
  let i = cursor - 1;
  while (i >= 0) {
    const ch = code[i];
    if (ch === ')') depth++;
    else if (ch === '(') {
      if (depth === 0) {
        // found the opening paren — extract the function name before it (including dot for ui.slider etc.)
        let end = i;
        let start = end - 1;
        while (start >= 0 && /[a-zA-Z0-9_$.]/.test(code[start])) start--;
        start++;
        const fnName = code.slice(start, end);
        if (BUILTIN_HELP[fnName]) {
          // figure out which parameter we're on by counting commas at depth 0
          let paramIdx = 0;
          let d = 0;
          for (let j = i + 1; j < cursor; j++) {
            if (code[j] === '(' || code[j] === '[' || code[j] === '{') d++;
            else if (code[j] === ')' || code[j] === ']' || code[j] === '}') d--;
            else if (code[j] === ',' && d === 0) paramIdx++;
          }
          return { fnName, parenPos: i, paramIdx };
        }
        return null;
      }
      depth--;
    }
    i--;
  }
  return null;
}

function showSigHint(ta) {
  const code = ta.value;
  const cursor = ta.selectionStart;
  if (ta.selectionStart !== ta.selectionEnd) { dismissSigHint(); return; }

  const ctx = cursorContext(code, cursor);
  if (ctx !== 'code') { dismissSigHint(); return; }

  const call = detectCallContext(code, cursor);
  if (!call) { dismissSigHint(); return; }

  const wrap = ta.closest('.editor-wrap');
  if (!wrap) { dismissSigHint(); return; }

  const help = BUILTIN_HELP[call.fnName];
  const pos = measureCursorPos(ta, call.parenPos);

  if (!activeSigHint) {
    activeSigHint = document.createElement('div');
    activeSigHint.className = 'ac-sig-hint';
    wrap.appendChild(activeSigHint);
  } else if (activeSigHint.parentElement !== wrap) {
    activeSigHint.remove();
    wrap.appendChild(activeSigHint);
  }

  // highlight current parameter in the signature
  const sigHtml = highlightParam(help.sig, call.paramIdx);
  activeSigHint.innerHTML = `<span class="ac-sig-fn">${sigHtml}</span><span class="ac-sig-desc">${esc(help.desc)}</span>`;

  const cs = getComputedStyle(ta);
  const padLeft = parseFloat(cs.paddingLeft) || 0;
  const padTop = parseFloat(cs.paddingTop) || 0;
  const lineHeight = parseFloat(cs.lineHeight) || parseFloat(cs.fontSize) * 1.5;

  const left = pos.x + padLeft - ta.scrollLeft;

  // place above the current line; pos.y is bottom of the line
  // so subtract lineHeight (to get top of line) then the hint's own height
  activeSigHint.style.left = left + 'px';
  activeSigHint.style.top = '0px'; // render off-screen first to measure
  activeSigHint.style.visibility = 'hidden';
  const hintH = activeSigHint.offsetHeight || lineHeight;
  activeSigHint.style.visibility = '';

  let top = pos.y + padTop - ta.scrollTop - lineHeight - hintH;

  // if it would go above the editor, show below the current line instead
  const wrapRect = wrap.getBoundingClientRect();
  const taRect = ta.getBoundingClientRect();
  const absTop = taRect.top + top;
  if (absTop < wrapRect.top) {
    top = pos.y + padTop - ta.scrollTop;
  }

  activeSigHint.style.top = top + 'px';
}

function highlightParam(sig, paramIdx) {
  // find the params inside parens
  const openParen = sig.indexOf('(');
  if (openParen === -1) return esc(sig);
  const closeParen = sig.lastIndexOf(')');
  if (closeParen === -1) return esc(sig);

  const before = sig.slice(0, openParen + 1);
  const params = sig.slice(openParen + 1, closeParen);
  const after = sig.slice(closeParen);

  // split on commas (respecting nested braces)
  const parts = [];
  let depth = 0;
  let start = 0;
  for (let i = 0; i < params.length; i++) {
    if (params[i] === '{' || params[i] === '(' || params[i] === '[') depth++;
    else if (params[i] === '}' || params[i] === ')' || params[i] === ']') depth--;
    else if (params[i] === ',' && depth === 0) {
      parts.push(params.slice(start, i));
      start = i + 1;
    }
  }
  parts.push(params.slice(start));

  let html = esc(before);
  for (let i = 0; i < parts.length; i++) {
    if (i > 0) html += esc(',');
    if (i === paramIdx) {
      html += '<span class="ac-sig-active">' + esc(parts[i]) + '</span>';
    } else {
      html += esc(parts[i]);
    }
  }
  html += esc(after);
  return html;
}

function measureCursorPos(ta, cursor) {
  const text = ta.value.substring(0, cursor);
  const lines = text.split('\n');
  const lineNum = lines.length - 1;
  const colText = lines[lineNum];

  // measure column offset using a hidden span
  let measurer = ta._acMeasurer;
  if (!measurer) {
    measurer = document.createElement('span');
    measurer.style.cssText = 'position:absolute;visibility:hidden;white-space:pre;pointer-events:none;';
    document.body.appendChild(measurer);
    ta._acMeasurer = measurer;
  }
  const cs = getComputedStyle(ta);
  measurer.style.font = cs.font;
  measurer.style.fontSize = cs.fontSize;
  measurer.style.fontFamily = cs.fontFamily;
  measurer.style.letterSpacing = cs.letterSpacing;
  measurer.style.tabSize = cs.tabSize;
  measurer.textContent = colText;

  const lineHeight = parseFloat(cs.lineHeight) || parseFloat(cs.fontSize) * 1.5;
  const x = measurer.offsetWidth;
  const y = (lineNum + 1) * lineHeight;

  return { x, y, lineHeight };
}

function highlightMatches(text, indices) {
  if (!indices || !indices.length) return esc(text);
  const set = new Set(indices);
  let html = '';
  let inMatch = false;
  for (let i = 0; i < text.length; i++) {
    if (set.has(i)) {
      if (!inMatch) { html += '<span class="ac-match">'; inMatch = true; }
      html += esc(text[i]);
    } else {
      if (inMatch) { html += '</span>'; inMatch = false; }
      html += esc(text[i]);
    }
  }
  if (inMatch) html += '</span>';
  return html;
}

function renderMenu(items, prefix, selectedIdx) {
  let html = '';
  const max = Math.min(items.length, 30);
  for (let i = 0; i < max; i++) {
    const it = items[i];
    const cls = i === selectedIdx ? 'ac-item active' : 'ac-item';
    const kindCls = 'ac-kind ac-kind-' + it.kind;
    const label = KIND_LABELS[it.kind] || '?';
    const textHtml = highlightMatches(it.text, it.indices);
    const detailHtml = it.detail ? `<span class="ac-detail">${esc(it.detail)}</span>` : '';
    html += `<div class="${cls}" data-index="${i}"><span class="${kindCls}">${label}</span><span class="ac-text">${textHtml}</span>${detailHtml}</div>`;
  }
  return html;
}

function esc(s) {
  return s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
}

function showMenu(ta, cellId) {
  const code = ta.value;
  const cursor = ta.selectionStart;
  if (ta.selectionStart !== ta.selectionEnd) { dismissAutocomplete(); return; }

  const result = getCompletions(code, cursor, cellId);
  if (!result.items.length) { dismissAutocomplete(); return; }

  const wrap = ta.closest('.editor-wrap');
  if (!wrap) { dismissAutocomplete(); return; }

  const pos = measureCursorPos(ta, cursor);

  if (!activeMenu) {
    activeMenu = document.createElement('div');
    activeMenu.className = 'ac-menu';
    wrap.appendChild(activeMenu);
  } else if (activeMenu.parentElement !== wrap) {
    activeMenu.remove();
    wrap.appendChild(activeMenu);
  }

  activeState = {
    items: result.items,
    prefix: result.prefix,
    selected: 0,
    ta,
    cellId,
    cursorStart: cursor - result.prefix.length
  };

  activeMenu.innerHTML = renderMenu(result.items, result.prefix, 0);

  // position: account for padding and scroll
  const cs = getComputedStyle(ta);
  const padLeft = parseFloat(cs.paddingLeft) || 0;
  const padTop = parseFloat(cs.paddingTop) || 0;

  const left = pos.x + padLeft - ta.scrollLeft;
  const top = pos.y + padTop - ta.scrollTop;

  activeMenu.style.left = left + 'px';
  activeMenu.style.top = top + 'px';

  // flip above if it would overflow viewport
  const menuRect = activeMenu.getBoundingClientRect();
  if (menuRect.bottom > window.innerHeight - 20) {
    activeMenu.style.top = (top - pos.lineHeight - activeMenu.offsetHeight) + 'px';
  }

  // mouse interaction
  activeMenu.onmousedown = (e) => {
    e.preventDefault(); // don't blur textarea
    const item = e.target.closest('.ac-item');
    if (item) {
      activeState.selected = parseInt(item.dataset.index);
      acceptCompletion();
    }
  };
}

function updateSelection(idx) {
  if (!activeMenu || !activeState) return;
  activeState.selected = idx;
  const items = activeMenu.querySelectorAll('.ac-item');
  items.forEach((el, i) => el.classList.toggle('active', i === idx));
  // scroll into view
  if (items[idx]) items[idx].scrollIntoView({ block: 'nearest' });
}

function acceptCompletion() {
  if (!activeState) return;
  const { items, selected, ta, prefix, cursorStart } = activeState;
  const item = items[selected];
  if (!item) return;

  ta.focus();
  ta.selectionStart = cursorStart;
  ta.selectionEnd = cursorStart + prefix.length;
  document.execCommand('insertText', false, item.text);

  dismissAutocomplete();
  ta.dispatchEvent(new Event('input'));
}

function attachAutocomplete(textarea, cellId) {
  // keydown handler — must be added BEFORE handleTab so stopImmediatePropagation works
  textarea.addEventListener('keydown', (e) => {
    // Ctrl+Shift+Space — manual signature hint trigger
    if (e.key === ' ' && (e.ctrlKey || e.metaKey) && e.shiftKey) {
      e.preventDefault();
      e.stopImmediatePropagation();
      dismissAutocomplete();
      showSigHint(textarea);
      return;
    }

    if (!activeMenu || !activeState) return;

    if (e.key === 'ArrowDown') {
      e.preventDefault();
      e.stopImmediatePropagation();
      const next = (activeState.selected + 1) % activeState.items.length;
      updateSelection(next);
      return;
    }
    if (e.key === 'ArrowUp') {
      e.preventDefault();
      e.stopImmediatePropagation();
      const prev = (activeState.selected - 1 + activeState.items.length) % activeState.items.length;
      updateSelection(prev);
      return;
    }
    if (e.key === 'Tab' || e.key === 'Enter') {
      e.preventDefault();
      e.stopImmediatePropagation();
      acceptCompletion();
      return;
    }
    if (e.key === 'Escape') {
      e.preventDefault();
      e.stopImmediatePropagation();
      dismissAutocomplete();
      dismissSigHint();
      return;
    }
  });

  // input handler — show/update completions + signature hints
  textarea.addEventListener('input', () => {
    // use a microtask so the value is settled
    Promise.resolve().then(() => {
      showMenu(textarea, cellId);
      // show sig hint only when autocomplete menu is not visible
      if (!activeMenu) showSigHint(textarea);
      else dismissSigHint();
    });
  });

  // dismiss on blur
  textarea.addEventListener('blur', () => {
    // delay so mousedown on menu can fire first
    setTimeout(() => { dismissAutocomplete(); dismissSigHint(); }, 150);
  });

  // dismiss on scroll (position goes stale)
  textarea.addEventListener('scroll', () => {
    dismissAutocomplete();
    dismissSigHint();
  });
}

// -- keyboard.js --

// ── KEYBOARD / SELECTION ──

function addCellWithUndo(type, code, afterId, beforeId) {
  const cell = addCell(type, code, afterId, beforeId);
  S.trash.push({ action: 'add', id: cell.id });
  return cell;
}

function deleteCellWithUndo(id) {
  const idx = S.cells.findIndex(c => c.id === id);
  if (idx < 0) return;
  const cell = S.cells[idx];
  const afterId = idx > 0 ? S.cells[idx - 1].id : null;
  const beforeId = afterId === null && idx < S.cells.length - 1 ? S.cells[idx + 1].id : null;
  S.trash.push({ action: 'delete', type: cell.type, code: cell.code, afterId, beforeId, collapsed: !!cell.el.classList.contains('collapsed') });
  deleteCell(id);
  setMsg('deleted cell (z to undo)', 'ok');
}

function undo() {
  if (!S.trash.length) { setMsg('nothing to undo', ''); return; }
  const entry = S.trash.pop();

  if (entry.action === 'add') {
    // undo add = delete the cell (without pushing to undo stack)
    deleteCell(entry.id);
    setMsg('undid add', 'ok');
  } else {
    // undo delete = restore the cell
    const { type, code, afterId, beforeId, collapsed } = entry;
    const validAfter = afterId !== null && S.cells.find(c => c.id === afterId) ? afterId : null;
    const validBefore = beforeId !== null && S.cells.find(c => c.id === beforeId) ? beforeId : null;
    const newCell = addCell(type, code, validAfter, validBefore);
    if (collapsed) newCell.el.classList.add('collapsed');
    selectCell(newCell.id);
    if ((type === 'code' || type === 'html') && S.cells.some(c => c.type === 'code' || c.type === 'html')) runAll();
    setMsg('restored cell', 'ok');
  }
}

function selectCell(id, scroll) {
  // deselect previous
  $$('.cell.selected').forEach(el => el.classList.remove('selected'));
  S.selectedId = id;
  if (id === null) return;
  const cell = S.cells.find(c => c.id === id);
  if (cell) {
    cell.el.classList.add('selected');
    if (scroll) cell.el.scrollIntoView({ block: 'nearest' });
  }
}

function getEditingCell() {
  const active = document.activeElement;
  if (active && active.tagName === 'TEXTAREA') {
    const cellEl = active.closest('.cell');
    if (cellEl) {
      const id = parseInt(cellEl.dataset.id);
      return S.cells.find(c => c.id === id) || null;
    }
  }
  return null;
}

function editCell(id) {
  const cell = S.cells.find(c => c.id === id);
  if (!cell) return;
  selectCell(id);

  if (cell.type === 'md') {
    // open md editor
    const view = cell.el.querySelector('.cell-md-view');
    const editWrap = cell.el.querySelector('.cell-md-edit');
    const ta = cell.el.querySelector('.cell-md-edit textarea');
    editWrap.style.display = '';
    view.style.display = 'none';
    ta.value = cell.code;
    ta.focus();
    autoResize({ target: ta });
  } else if (cell.type === 'css') {
    // open css editor
    const view = cell.el.querySelector('.cell-css-view');
    const editWrap = cell.el.querySelector('.cell-css-edit');
    const ta = cell.el.querySelector('.cell-css-edit textarea');
    editWrap.style.display = '';
    view.style.display = 'none';
    ta.value = cell.code;
    ta.focus();
    autoResize({ target: ta });
  } else if (cell.type === 'html') {
    // open html editor
    const view = cell.el.querySelector('.cell-html-view');
    const editWrap = cell.el.querySelector('.cell-html-edit');
    const ta = cell.el.querySelector('.cell-html-edit textarea');
    editWrap.style.display = '';
    view.style.display = 'none';
    ta.value = cell.code;
    ta.focus();
    autoResize({ target: ta });
  } else {
    cell.el.querySelector('textarea').focus();
  }
}

function exitEdit() {
  const active = document.activeElement;
  if (active && active.tagName === 'TEXTAREA') {
    active.blur();
  }
}

function runSelected() {
  if (S.selectedId === null && S.cells.length) selectCell(S.cells[0].id);
  const cell = S.cells.find(c => c.id === S.selectedId);
  if (!cell) return;
  if (cell.type === 'code') {
    cell.code = cell.el.querySelector('.cell-code textarea').value;
    runDAG([cell.id]);
  } else if (cell.type === 'html') {
    renderHtmlCell(cell);
  }
}

// ── MOBILE TRAY TOGGLES ──

function closeAllTrays() {
  document.querySelectorAll('.action-add-tray.open, .action-more-tray.open, .cell-type-picker.open, .cell-insert-picker.open').forEach(el => el.classList.remove('open'));
}

function toggleToolbarMenu() {
  const menu = document.querySelector('.toolbar-overflow');
  if (!menu) return;
  menu.classList.toggle('open');
}

function toggleAddTray() {
  const tray = document.querySelector('.action-add-tray');
  if (!tray) return;
  const wasOpen = tray.classList.contains('open');
  closeAllTrays();
  if (!wasOpen) tray.classList.add('open');
}

function toggleMoreTray() {
  const tray = document.querySelector('.action-more-tray');
  if (!tray) return;
  const wasOpen = tray.classList.contains('open');
  closeAllTrays();
  if (!wasOpen) tray.classList.add('open');
}

function showInsertPicker(id, dir) {
  closeAllTrays();
  const cell = S.cells.find(c => c.id === id);
  if (!cell) return;
  document.querySelectorAll('.cell-insert-picker').forEach(el => el.remove());
  const picker = document.createElement('div');
  picker.className = 'cell-insert-picker open';
  let afterId;
  if (dir === 'after') {
    afterId = id;
  } else {
    const idx = S.cells.findIndex(c => c.id === id);
    afterId = idx > 0 ? S.cells[idx - 1].id : null;
  }
  picker.innerHTML = ['code', 'md', 'css', 'html'].map(t =>
    `<button onclick="insertAt(${afterId !== null ? afterId : 'null'},'${t}');this.closest('.cell-insert-picker').remove()">${t}</button>`
  ).join('');
  const header = cell.el.querySelector('.cell-header');
  header.style.position = 'relative';
  picker.style.top = '100%';
  picker.style.left = dir === 'before' ? '0' : 'auto';
  picker.style.right = dir === 'after' ? '0' : 'auto';
  header.appendChild(picker);
}

function toggleTypePicker(id) {
  closeAllTrays();
  const picker = document.querySelector(`.cell-type-picker[data-cell-id="${id}"]`);
  if (picker) picker.classList.toggle('open');
}

function collapseAll() {
  S.cells.forEach(c => c.el.classList.add('collapsed'));
  setMsg('collapsed all', 'ok');
}

function expandAll() {
  S.cells.forEach(c => c.el.classList.remove('collapsed'));
  setMsg('expanded all', 'ok');
}

function newNotebook() {
  if (!confirm('Clear all cells?')) return;
  while (S.cells.length) {
    const cell = S.cells[0];
    if (cell._styleEl) { cell._styleEl.remove(); cell._styleEl = null; }
    cell.el.remove();
    S.cells.shift();
  }
  S.scope = {};
  S.selectedId = null;
  S.clipboard = null;
  S.trash = [];
  $('#docTitle').value = 'untitled';
  updateStatus();
  setMsg('new notebook', 'ok');
}

function runSelectedCell() { runSelectedAndAdvance(); }

function runSelectedAndAdvance() {
  runSelected();
  if (S.selectedId === null) return;
  // respect goto target if set
  const gotoIdx = window._lastGotoTarget;
  if (gotoIdx != null && gotoIdx >= 0 && gotoIdx < S.cells.length) {
    editCell(S.cells[gotoIdx].id);
  } else {
    const idx = S.cells.findIndex(c => c.id === S.selectedId);
    if (idx < S.cells.length - 1) {
      editCell(S.cells[idx + 1].id);
    } else {
      const newCell = addCellWithUndo('code', '', S.selectedId);
      selectCell(newCell.id);
    }
  }
}

function navigateCell(dir) {
  if (!S.cells.length) return;
  if (S.selectedId === null) {
    selectCell(S.cells[0].id, true);
    return;
  }
  const idx = S.cells.findIndex(c => c.id === S.selectedId);
  const newIdx = idx + dir;
  if (newIdx >= 0 && newIdx < S.cells.length) {
    selectCell(S.cells[newIdx].id, true);
  }
}

document.addEventListener('keydown', (e) => {
  // find bar shortcuts (must be before edit/command branches)
  if ((e.key === 'f') && (e.ctrlKey || e.metaKey) && !e.altKey) {
    e.preventDefault(); openFind(false); return;
  }
  if ((e.key === 'h') && (e.ctrlKey || e.metaKey) && !e.altKey) {
    e.preventDefault(); openFind(true); return;
  }
  if (e.key === 'Escape' && S.findActive) {
    e.preventDefault(); closeFind(); return;
  }

  const editing = getEditingCell();

  if (editing) {
    // ── EDIT MODE ──
    if (e.key === '/' && (e.ctrlKey || e.metaKey)) {
      e.preventDefault();
      toggleComment(document.activeElement);
      return;
    }
    if (e.key === 'Escape') {
      e.preventDefault();
      exitEdit();
      selectCell(editing.id);
      return;
    }
    if (e.key === 'Enter' && e.ctrlKey) {
      e.preventDefault();
      editing.code = editing.el.querySelector('textarea').value;
      if (editing.type === 'code') runDAG([editing.id], true);
      return;
    }
    if (e.key === 'Enter' && e.shiftKey) {
      e.preventDefault();
      editing.code = editing.el.querySelector('textarea').value;
      if (editing.type === 'code') runDAG([editing.id], true);
      // advance — respect goto target if set
      const gotoIdx = window._lastGotoTarget;
      if (gotoIdx != null && gotoIdx >= 0 && gotoIdx < S.cells.length) {
        editCell(S.cells[gotoIdx].id);
      } else {
        const idx = S.cells.findIndex(c => c.id === editing.id);
        if (idx < S.cells.length - 1) {
          editCell(S.cells[idx + 1].id);
        } else {
          const newCell = addCellWithUndo('code', '', editing.id);
          selectCell(newCell.id);
          editCell(newCell.id);
        }
      }
      return;
    }
  } else {
    // ── COMMAND MODE ──
    // ignore if typing in any input field (title, find bar, etc.)
    if (document.activeElement && (document.activeElement.tagName === 'INPUT' || document.activeElement.id === 'docTitle')) return;

    // let browser shortcuts through (Ctrl+J downloads, etc.)
    if (e.ctrlKey || e.metaKey || e.altKey) return;

    if (e.key === 'ArrowUp' || e.key === 'k') {
      e.preventDefault();
      navigateCell(-1);
      return;
    }
    if (e.key === 'ArrowDown' || e.key === 'j') {
      e.preventDefault();
      navigateCell(1);
      return;
    }
    if (e.key === 'Enter') {
      e.preventDefault();
      if (S.selectedId !== null) editCell(S.selectedId);
      return;
    }
    if (e.key === 'a') {
      e.preventDefault();
      const newCell = addCellWithUndo('code', '', null, S.selectedId);
      selectCell(newCell.id);
      editCell(newCell.id);
      return;
    }
    if (e.key === 'b') {
      e.preventDefault();
      const newCell = addCellWithUndo('code', '', S.selectedId);
      selectCell(newCell.id);
      editCell(newCell.id);
      return;
    }
    if (e.key === 'd') {
      e.preventDefault();
      if (S.pendingD) {
        // dd — delete
        clearTimeout(S.pendingDTimer);
        S.pendingD = false;
        if (S.selectedId !== null) {
          const idx = S.cells.findIndex(c => c.id === S.selectedId);
          const nextId = idx < S.cells.length - 1 ? S.cells[idx + 1].id
                       : idx > 0 ? S.cells[idx - 1].id : null;
          deleteCellWithUndo(S.selectedId);
          if (nextId !== null) selectCell(nextId);
        }
      } else {
        S.pendingD = true;
        S.pendingDTimer = setTimeout(() => { S.pendingD = false; }, 600);
      }
      return;
    }
    if (e.key !== 'd' && S.pendingD) { S.pendingD = false; clearTimeout(S.pendingDTimer); }
    if (e.key === 'z') {
      e.preventDefault();
      undo();
      return;
    }
    if (e.key === 'c' && S.selectedId !== null) {
      e.preventDefault();
      const cell = S.cells.find(c => c.id === S.selectedId);
      if (cell) S.clipboard = { type: cell.type, code: cell.code };
      setMsg('copied cell', 'ok');
      return;
    }
    if (e.key === 'v' && S.clipboard) {
      e.preventDefault();
      const newCell = addCellWithUndo(S.clipboard.type, S.clipboard.code, S.selectedId);
      selectCell(newCell.id);
      if (S.clipboard.type === 'code' && S.cells.some(c => c.type === 'code')) runAll();
      return;
    }
    if (e.key === 'x' && S.selectedId !== null) {
      // cut = copy + delete
      e.preventDefault();
      const cell = S.cells.find(c => c.id === S.selectedId);
      if (cell) S.clipboard = { type: cell.type, code: cell.code };
      const idx = S.cells.findIndex(c => c.id === S.selectedId);
      const nextId = idx < S.cells.length - 1 ? S.cells[idx + 1].id
                   : idx > 0 ? S.cells[idx - 1].id : null;
      deleteCellWithUndo(S.selectedId);
      if (nextId !== null) selectCell(nextId);
      setMsg('cut cell', 'ok');
      return;
    }
    if (e.key === 'h' && S.selectedId !== null) {
      e.preventDefault();
      const cell = S.cells.find(c => c.id === S.selectedId);
      if (cell) cell.el.classList.toggle('collapsed');
      return;
    }
    if (e.key === 'l') {
      e.preventDefault();
      const on = getSettings().lineNumbers === 'on';
      applyLineNumbers(!on);
      setMsg(on ? 'line numbers off' : 'line numbers on', 'ok');
      return;
    }
    if (e.key === 'p') {
      e.preventDefault();
      togglePresent();
      return;
    }
    if (e.key === 'm' && S.selectedId !== null) {
      e.preventDefault();
      convertCell(S.selectedId, 'md');
      return;
    }
    if (e.key === 'y' && S.selectedId !== null) {
      e.preventDefault();
      convertCell(S.selectedId, 'code');
      return;
    }
    if (e.key === 's' && S.selectedId !== null) {
      e.preventDefault();
      convertCell(S.selectedId, 'css');
      return;
    }
    if (e.key === 't' && S.selectedId !== null) {
      e.preventDefault();
      convertCell(S.selectedId, 'html');
      return;
    }
  }

  // global: F1 help overlay
  if (e.key === 'F1') {
    e.preventDefault();
    $('#helpOverlay').classList.toggle('visible');
    return;
  }

  // close presentation mode on Escape
  if (e.key === 'Escape' && document.body.classList.contains('presenting')) {
    togglePresent();
    e.stopImmediatePropagation();
    return;
  }

  // close settings on Escape if visible
  if (e.key === 'Escape' && $('#settingsOverlay').classList.contains('visible')) {
    toggleSettings();
    e.stopImmediatePropagation();
    return;
  }

  // close help on Escape if visible
  if (e.key === 'Escape' && $('#helpOverlay').classList.contains('visible')) {
    $('#helpOverlay').classList.remove('visible');
    e.stopImmediatePropagation();
    return;
  }

  // global: Ctrl+S / Cmd+S
  if (e.key === 's' && (e.ctrlKey || e.metaKey)) {
    e.preventDefault();
    saveNotebook();
  }
});

// click to dismiss help
$('#helpOverlay').addEventListener('click', (e) => {
  if (e.target === $('#helpOverlay')) $('#helpOverlay').classList.remove('visible');
});

// click to select + close trays
document.addEventListener('click', (e) => {
  // close action trays if clicking outside their wrapper (wrapper = parent div with tray + button)
  const addTray = document.querySelector('.action-add-tray');
  const moreTray = document.querySelector('.action-more-tray');
  if (addTray && addTray.classList.contains('open') && !addTray.parentElement.contains(e.target)) {
    addTray.classList.remove('open');
  }
  if (moreTray && moreTray.classList.contains('open') && !moreTray.parentElement.contains(e.target)) {
    moreTray.classList.remove('open');
  }
  // close cell type pickers if clicking outside
  if (!e.target.closest('.cell-type-picker') && !e.target.closest('.cell-type')) {
    document.querySelectorAll('.cell-type-picker.open').forEach(el => el.classList.remove('open'));
  }
  // close cell insert pickers if clicking outside
  if (!e.target.closest('.cell-insert-picker')) {
    document.querySelectorAll('.cell-insert-picker').forEach(el => el.remove());
  }
  // close toolbar overflow menu if clicking outside
  const tbOverflow = document.querySelector('.toolbar-overflow');
  if (tbOverflow && tbOverflow.classList.contains('open') && !tbOverflow.contains(e.target)) {
    tbOverflow.classList.remove('open');
  }
  // close save tray if clicking outside
  const saveTray = document.getElementById('saveTray');
  if (saveTray && saveTray.classList.contains('open') && !saveTray.parentElement.contains(e.target)) {
    saveTray.classList.remove('open');
  }

  const cellEl = e.target.closest('.cell');
  if (cellEl) {
    const id = parseInt(cellEl.dataset.id);
    selectCell(id);
  }
});

// late import to avoid circular dependency at module load time

// -- goto.js --

// ── GOTO ── @optional

function parseGoto(code) {
  const m = code.match(/^\s*\/\/\s*%goto\b\s*(.*)/m);
  if (!m) return null;
  return m[1].trim() || '';
}

const MAX_VISITS = 1000;
let visits = {};

window._dagStart = function() {
  visits = {};
  window._lastGotoTarget = null;
};

window._beforeExec = function(cell) {
  const target = parseGoto(cell.code);
  if (target !== null) {
    S.scope.__goto = target;
    cell.defines.add('__goto');
  } else {
    delete S.scope.__goto;
  }
};

window._afterExec = function(cell, index) {
  const gotoTarget = S.scope.__goto;
  delete S.scope.__goto;
  window._lastGotoTarget = null;

  if (!gotoTarget) return -1;

  // resolve by cellName
  const targetIdx = S.cells.findIndex(c => parseCellName(c.code) === gotoTarget);
  if (targetIdx < 0) {
    const out = cell.el.querySelector('.cell-output');
    if (out) {
      out.appendChild(document.createTextNode('\ngoto: cell \u201c' + gotoTarget + '\u201d not found'));
      out.classList.add('error');
    }
    return -1;
  }

  // loop protection
  const key = index + ':' + targetIdx;
  visits[key] = (visits[key] || 0) + 1;
  if (visits[key] > MAX_VISITS) {
    const out = cell.el.querySelector('.cell-output');
    if (out) {
      out.appendChild(document.createTextNode('\ngoto: loop limit reached (' + MAX_VISITS + ' iterations)'));
      out.classList.add('error');
    }
    return -1;
  }

  window._lastGotoTarget = targetIdx;
  return targetIdx;
};

// -- size-compare.js --

// ── SIZE COMPARISON ── @optional

const SIZE_MEDIA = [
  [4096, 'an Atari 2600 cartridge'],
  [49152, 'a ZX Spectrum tape'],
  [73728, 'Apollo AGC rope memory'],
  [81920, 'an 8\u2033 floppy (SS/SD)'],
  [262144, 'an NES cartridge'],
  [368640, 'a 5.25\u2033 floppy (DS/DD)'],
  [737280, 'a 3.5\u2033 floppy (DS/DD)'],
  [1228800, 'a 5.25\u2033 floppy (DS/HD)'],
  [1474560, 'a 3.5\u2033 floppy (DS/HD)'],
];

function sizeCompare(bytes) {
  if (!window._sizeCompare) return '';
  for (const [size, name] of SIZE_MEDIA) {
    if (bytes <= size) return 'fits on ' + name;
  }
  const n = Math.ceil(bytes / 1474560);
  return n + '\u00d7 3.5\u2033 floppies';
}

function applySizeCompare(val) {
  const on = val === true || val === 'true' || val === 'on';
  window._sizeCompare = on;
  const el = $('#setSizeCompare');
  if (el) el.value = on ? 'on' : 'off';
  updateStatus();
}

function applySizeCompareRef(val) {
  window._sizeCompareRef = val === 'content' ? 'content' : 'total';
  const el = $('#setSizeCompareRef');
  if (el) el.value = window._sizeCompareRef;
  updateStatus();
}

// inject settings rows before modules section
(function() {
  const panel = $('#settingsPanel');
  if (!panel) return;
  const headings = panel.querySelectorAll('h2');
  const modulesH2 = headings[headings.length - 1];
  if (!modulesH2) return;

  const h2 = document.createElement('h2');
  h2.textContent = 'status bar';
  modulesH2.before(h2);

  const refRow = document.createElement('div');
  refRow.className = 'settings-row';
  refRow.innerHTML = '<label>size reference</label>' +
    '<select id="setSizeCompareRef" onchange="applySizeCompareRef(this.value)">' +
    '<option value="total" selected>total file</option>' +
    '<option value="content">content only</option></select>';
  modulesH2.before(refRow);

  const row = document.createElement('div');
  row.className = 'settings-row';
  row.innerHTML = '<label>size comparison</label>' +
    '<select id="setSizeCompare" onchange="applySizeCompare(this.value)">' +
    '<option value="off">off</option><option value="on" selected>on</option></select>';
  modulesH2.before(row);

  window._sizeCompare = true;
  window._sizeCompareRef = 'total';
})();

// -- globals.js --

// ── GLOBAL BINDINGS ──
// This module wires exported functions to window.* for use by onclick/onchange
// handlers in template HTML and dynamically generated markup.
// Modules stay pure (no side effects, no window assignments).











// state
window.$ = $;
window.S = S;

// editor
window.toggleAutorun = toggleAutorun;

// settings
window.toggleSettings = toggleSettings;
window.togglePresent = togglePresent;
window.applyTheme = applyTheme;
window.applyFontSize = applyFontSize;
window.applyWidth = applyWidth;
window.applyLineNumbers = applyLineNumbers;
window.applyHeader = applyHeader;
window.applyExecMode = applyExecMode;
window.applyRunOnLoad = applyRunOnLoad;
window.applyShowToggle = applyShowToggle;
window.applyGlobalExecMode = applyGlobalExecMode;
window.applyGlobalRunOnLoad = applyGlobalRunOnLoad;

// update
window.toggleUpdate = toggleUpdate;
window.checkForUpdate = checkForUpdate;
window.applyOnlineUpdate = applyOnlineUpdate;
window.proceedUpdate = proceedUpdate;
window.cancelUpdate = cancelUpdate;
window.updateFromFile = updateFromFile;

// save
window.saveNotebook = saveNotebook;
window.savePackedNotebook = savePackedNotebook;
window.setSaveMode = setSaveMode;
window.toggleSaveTray = toggleSaveTray;
window.exportAsTxt = exportAsTxt;

// exec
window.runAll = runAll;

// ui
window.insertAt = insertAt;

// find
window.openFind = openFind;
window.closeFind = closeFind;

// stdlib
window.__auditable_registerProvider = registerProvider;

// keyboard / toolbar
window.addCellWithUndo = addCellWithUndo;
window.deleteCellWithUndo = deleteCellWithUndo;
window.runSelectedCell = runSelectedCell;
window.toggleToolbarMenu = toggleToolbarMenu;
window.toggleAddTray = toggleAddTray;
window.toggleMoreTray = toggleMoreTray;
window.showInsertPicker = showInsertPicker;
window.toggleTypePicker = toggleTypePicker;
window.collapseAll = collapseAll;
window.expandAll = expandAll;
window.newNotebook = newNotebook;

// -- init.js --

// ── INIT ──

(function init() {
  // detect packed format (meta tag injected by loader)
  const packedMeta = document.querySelector('meta[name="auditable-packed"]');
  if (packedMeta) {
    packedMeta.remove();
    setBadge('packed', 'packed', 'toolbar-badge toolbar-badge-packed');
    setSaveMode('packed');
  }

  if (!loadFromEmbed()) {
    addCell('md', '');
    addCell('code', '');
  }
  S.initialized = true;
})();

// ── AF BRIDGE ──
// When running inside AF shell (iframe), establish postMessage communication.
// No-op when running standalone (window.parent === window).
//
// Message protocol (notebook ↔ AF shell):
//   af:ready          → sent on init with { title }
//   af:serialize      ← received to trigger saveNotebook()
//   af:saved          ← received after save (shows "saved" status)
//   af:setTitle       ← received to update docTitle input
//   af:resize         ← received when iframe becomes visible (recalc textareas)
//   af:titleChanged   → sent when user edits the title
//   af:fileRequest    → sent to request file picker { id, accept }
//   af:fileResult     ← received with picked file { id, file }
//   af:download       → sent to request download { data, filename, mimeType }
//   af:dirty          → sent when notebook has unsaved changes

(function afBridge() {
  if (window.parent === window) return;
  window.__AF_BRIDGE__ = true;

  // register AF-specific providers for file/download
  registerProvider('file', (accept) => {
    return new Promise((resolve) => {
      const id = 'af_file_' + Date.now();
      function handler(e) {
        if (e.data?.type === 'af:fileResult' && e.data.payload?.id === id) {
          window.removeEventListener('message', handler);
          resolve(e.data.payload.file);
        }
      }
      window.addEventListener('message', handler);
      window.parent.postMessage({ type: 'af:fileRequest', payload: { id, accept } }, '*');
    });
  });

  registerProvider('download', (data, filename, mimeType) => {
    const str = typeof data === 'string' ? data : JSON.stringify(data, null, 2);
    const mime = mimeType || (typeof data === 'string' ? 'text/plain' : 'application/json');
    window.parent.postMessage({
      type: 'af:download',
      payload: { data: str, filename, mimeType: mime }
    }, '*');
  });

  const title = document.getElementById('docTitle')?.value || 'untitled';
  window.parent.postMessage({ type: 'af:ready', payload: { title } }, '*');

  window.addEventListener('message', (e) => {
    const msg = e.data;
    if (!msg?.type) return;
    if (msg.type === 'af:serialize') saveNotebook();
    else if (msg.type === 'af:saved') setMsg('saved', 'ok');
    else if (msg.type === 'af:setTitle') {
      const input = document.getElementById('docTitle');
      if (input && msg.payload?.title) input.value = msg.payload.title;
    } else if (msg.type === 'af:resize') {
      // recalculate textarea heights after becoming visible
      document.querySelectorAll('textarea').forEach(ta => {
        ta.style.height = 'auto';
        ta.style.height = ta.scrollHeight + 'px';
        const hl = ta.parentElement?.querySelector('.highlight-layer');
        if (hl) hl.style.height = ta.style.height;
      });
    }
  });

  document.getElementById('docTitle')?.addEventListener('input', () => {
    window.parent.postMessage({
      type: 'af:titleChanged',
      payload: { title: document.getElementById('docTitle').value }
    }, '*');
  });
})();
</script>
</body>
<!-- good luck out there -->
</html>
