<!DOCTYPE html>
<!-- auditable — a reactive computational notebook in a single HTML file -->
<!-- https://github.com/endarthur/auditable — MIT license -->
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Auditable — atra — language tour</title>
<style>
:root {
  --bg: #0a0a0a;
  --bg1: #111;
  --bg2: #1a1a1a;
  --border: #222;
  --border-hi: #333;
  --fg: #aaa;
  --fg-dim: #555;
  --fg-bright: #ccc;
  --accent: #c89b3c;
  --accent-dim: #8a6c2a;
  --err: #a33;
  --ok: #3a7;
  --mono: 'Courier New', Courier, monospace;
  --editor-font-size: 13px;
}

* { margin: 0; padding: 0; box-sizing: border-box; }

/* scrollbar */
::-webkit-scrollbar { width: 6px; height: 6px; }
::-webkit-scrollbar-track { background: var(--bg); }
::-webkit-scrollbar-thumb { background: var(--border-hi); border-radius: 0; }
::-webkit-scrollbar-thumb:hover { background: var(--fg-dim); }
textarea::-webkit-scrollbar-thumb { background: var(--border); }
@supports (scrollbar-color: auto) {
  * { scrollbar-color: var(--border-hi) var(--bg); scrollbar-width: thin; }
}

html, body {
  background: var(--bg);
  color: var(--fg);
  font-family: var(--mono);
  font-size: 13px;
  line-height: 1.5;
  min-height: 100vh;
}

/* ── TOOLBAR ── */
.toolbar {
  position: sticky;
  top: 0;
  z-index: 100;
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 6px 12px;
  background: var(--bg);
  border-bottom: 1px solid var(--border);
}

.toolbar-title {
  font-size: 11px;
  letter-spacing: 3px;
  text-transform: uppercase;
  color: var(--accent);
  opacity: 0.8;
  user-select: none;
}

.toolbar-sep {
  width: 1px;
  height: 16px;
  background: var(--border);
  margin: 0 4px;
}

.toolbar-filename {
  font-size: 12px;
  color: var(--fg-dim);
  flex: 1;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.toolbar-filename input {
  background: none;
  border: none;
  border-bottom: 1px solid transparent;
  color: var(--fg);
  font-family: var(--mono);
  font-size: 12px;
  outline: none;
  width: 200px;
}
.toolbar-filename input:focus {
  border-bottom-color: var(--accent-dim);
}

button {
  background: var(--bg2);
  border: 1px solid var(--border);
  color: var(--fg-dim);
  font-family: var(--mono);
  font-size: 10px;
  letter-spacing: 1px;
  text-transform: uppercase;
  padding: 4px 10px;
  cursor: pointer;
  transition: border-color 0.15s, color 0.15s;
}
button:hover {
  border-color: var(--border-hi);
  color: var(--fg);
}
button.accent {
  border-color: var(--accent-dim);
  color: var(--accent);
}
button.accent:hover {
  border-color: var(--accent);
}

/* ── TOOLBAR BADGES ── */
.toolbar-badges {
  display: inline-flex;
  gap: 4px;
  margin-left: 6px;
  align-items: center;
}
.toolbar-badge {
  font-size: 9px;
  letter-spacing: 0.5px;
  padding: 1px 4px;
  border-radius: 2px;
  user-select: none;
  opacity: 0.85;
}
.toolbar-badge-signed {
  color: var(--ok);
  border: 1px solid color-mix(in srgb, var(--ok) 40%, transparent);
}
.toolbar-badge-packed {
  color: var(--fg-dim);
  border: 1px solid var(--border);
}

/* ── SPLIT SAVE BUTTON ── */
.save-split {
  display: inline-flex;
  position: relative;
}
.save-split button:first-child {
  border-right: none;
  border-radius: 3px 0 0 3px;
}
.save-caret {
  border-radius: 0 3px 3px 0 !important;
  padding: 4px 4px !important;
  font-size: 10px;
}
.save-tray {
  display: none;
  position: absolute;
  right: 0;
  top: 100%;
  margin-top: 4px;
  background: var(--bg);
  border: 1px solid var(--border);
  z-index: 100;
  min-width: 120px;
}
.save-tray.open { display: flex; flex-direction: column; }
.save-tray button {
  border: none;
  border-bottom: 1px solid var(--border);
  text-align: left;
  padding: 6px 10px;
  white-space: nowrap;
  font-size: 12px;
}
.save-tray button:last-child { border-bottom: none; }
.save-tray button:hover { background: var(--bg-hi); }

/* ── TRANSPORT CONTROLS ── */
.transport {
  display: inline-flex;
  border: 1px solid var(--border);
}
.transport button {
  border: none;
  border-right: 1px solid var(--border);
  padding: 4px 8px;
}
.transport button:last-child { border-right: none; }
.transport button.autorun-on {
  background: #33aa77;
  color: #111;
}
.transport button.autorun-off {
  background: #dd4444;
  color: #111;
}

.toolbar-right {
  margin-left: auto;
  display: flex;
  align-items: center;
  gap: 8px;
}

/* ── TOOLBAR OVERFLOW MENU ── */
.toolbar-overflow {
  position: relative;
  display: inline-block;
}
.toolbar-overflow-tray {
  display: none;
  position: absolute;
  top: 100%;
  right: 0;
  background: var(--bg1);
  border: 1px solid var(--border);
  z-index: 200;
  flex-direction: column;
  min-width: 140px;
}
.toolbar-overflow-tray button {
  border: none;
  border-bottom: 1px solid var(--border);
  text-align: left;
  padding: 8px 12px;
  background: var(--bg1);
  white-space: nowrap;
}
.toolbar-overflow-tray button:last-child { border-bottom: none; }
.toolbar-overflow-tray button:hover { background: var(--bg2); color: var(--fg-bright); }
.toolbar-overflow.open .toolbar-overflow-tray { display: flex; }

/* ── BOTTOM ACTION BAR ── */
.action-bar { display: none; }

/* ── ACTION BAR TRAYS ── */
.action-add-tray,
.action-more-tray {
  display: none;
  position: absolute;
  bottom: 100%;
  background: var(--bg1);
  border: 1px solid var(--border);
  flex-direction: column;
  z-index: 200;
}
.action-add-tray { left: 0; min-width: 120px; }
.action-more-tray { right: 0; min-width: 120px; }
.action-add-tray.open,
.action-more-tray.open { display: flex; }
.action-add-tray button,
.action-more-tray button {
  min-height: 48px;
  border: none;
  border-bottom: 1px solid var(--border);
  text-align: left;
  padding: 8px 16px;
  background: var(--bg1);
  color: var(--fg);
  font-family: var(--mono);
  font-size: 12px;
  letter-spacing: 1px;
  text-transform: uppercase;
}
.action-add-tray button:last-child,
.action-more-tray button:last-child { border-bottom: none; }
.action-add-tray button:hover,
.action-more-tray button:hover { background: var(--bg2); color: var(--fg-bright); }
.action-more-tray button.active-mode { color: var(--accent); }

/* ── CELL INSERT / CONVERT BUTTONS (touch only) ── */
.cell-insert { display: none; }
.cell-convert { display: none; }

/* ── CELL TYPE PICKER ── */
.cell-type-picker {
  display: none;
  gap: 2px;
  padding: 2px 8px 4px;
}
.cell-type-picker.open { display: flex; }
.cell-type-picker button {
  font-size: 9px;
  padding: 2px 8px;
  background: var(--bg2);
  border: 1px solid var(--border);
  color: var(--fg-dim);
  font-family: var(--mono);
  letter-spacing: 1px;
  text-transform: uppercase;
}
.cell-type-picker button:hover {
  border-color: var(--accent-dim);
  color: var(--accent);
}

/* ── CELL INSERT PICKER ── */
.cell-insert-picker {
  display: none;
  gap: 2px;
  position: absolute;
  background: var(--bg1);
  border: 1px solid var(--border);
  padding: 4px;
  z-index: 200;
}
.cell-insert-picker.open { display: flex; }
.cell-insert-picker button {
  font-size: 9px;
  padding: 4px 8px;
  background: var(--bg2);
  border: 1px solid var(--border);
  color: var(--fg-dim);
  font-family: var(--mono);
  letter-spacing: 1px;
  text-transform: uppercase;
  min-height: 36px;
}
.cell-insert-picker button:hover {
  border-color: var(--accent-dim);
  color: var(--accent);
}

/* ── TOOLBAR STATUS (mobile cell count) ── */
.toolbar-status { display: none; }

/* ── NOTEBOOK ── */
.notebook {
  max-width: 860px;
  margin: 0 auto;
  padding: 16px 12px 120px;
}

/* ── CELL ── */
.cell {
  position: relative;
  margin: 6px 0;
  border-left: 2px solid transparent;
  transition: border-color 0.15s;
}
.cell:hover {
  border-left-color: var(--border-hi);
}
.cell.selected {
  border-left-color: var(--accent);
}
.cell.selected .cell-header {
  opacity: 1;
}
.cell.manual .cell-type::after {
  content: ' \00b7 manual';
  color: var(--accent-dim);
}
.cell.stale {
  border-left-color: var(--accent-dim);
}
.cell.error {
  border-left-color: var(--err);
}
.cell.fresh {
  border-left-color: var(--ok);
  transition: border-color 0.5s;
}

/* cell header — type label + controls */
.cell-header {
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 2px 8px;
  opacity: 0;
  transition: opacity 0.15s;
  user-select: none;
}
.cell:hover .cell-header,
.cell:focus-within .cell-header {
  opacity: 1;
}

.cell.collapsed .cell-code,
.cell.collapsed .cell-md-edit,
.cell.collapsed .cell-css-edit,
.cell.collapsed .cell-html-edit {
  display: none !important;
}
.cell.collapsed .cell-type::before {
  content: '\25b8 ';
}
.cell:not(.collapsed) .cell-type::before {
  content: '\25be ';
}
.cell-type {
  cursor: pointer;
  user-select: none;
  font-size: 9px;
  letter-spacing: 2px;
  text-transform: uppercase;
  color: var(--fg-dim);
}
.cell[data-type="code"] .cell-type { color: #7aabcf; }
.cell[data-type="css"]  .cell-type { color: #d4955a; }
.cell[data-type="html"] .cell-type { color: #6dbfb8; }
.cell[data-type="md"]   .cell-type { color: var(--fg-dim); }

.cell-btn {
  background: none;
  border: none;
  color: var(--fg-dim);
  font-family: var(--mono);
  font-size: 10px;
  padding: 0 4px;
  cursor: pointer;
}
.cell-btn:hover { color: var(--fg); }
.cell-btn.del:hover { color: var(--err); }

/* ── CODE CELL ── */
.cell-code {
  position: relative;
}

.editor-wrap {
  --gutter: 36px;
  position: relative;
  overflow: hidden;
}

.line-numbers {
  position: absolute;
  top: 0; left: 0; bottom: 0;
  width: var(--gutter);
  padding: 8px 4px 8px 0;
  font-family: var(--mono);
  font-size: var(--editor-font-size);
  line-height: 1.5;
  text-align: right;
  color: var(--fg-dim);
  background: var(--bg1);
  border-right: 1px solid var(--border);
  border-top: 1px solid var(--border);
  border-bottom: 1px solid var(--border);
  border-left: 1px solid var(--border);
  overflow: hidden;
  z-index: 3;
  pointer-events: none;
  white-space: pre;
  box-sizing: border-box;
}

:root.hide-line-numbers .line-numbers { display: none; }
:root.hide-line-numbers .editor-wrap { --gutter: 0px; }

.cell-code textarea {
  display: block;
  width: 100%;
  background: transparent;
  border: 1px solid var(--border);
  color: var(--fg-bright);
  caret-color: var(--fg-bright);
  font-family: var(--mono);
  font-size: var(--editor-font-size);
  line-height: 1.5;
  padding: 8px 10px 8px calc(var(--gutter) + 10px);
  resize: vertical;
  min-height: 38px;
  outline: none;
  tab-size: 2;
  white-space: pre;
  overflow-x: auto;
  position: relative;
  z-index: 2;
  -webkit-text-fill-color: transparent;
}
.cell-code textarea::selection {
  -webkit-text-fill-color: var(--fg-bright);
  background: rgba(200,155,60,0.25);
}
.cell-code textarea:focus + .highlight-layer {
  border-color: var(--border-hi);
}
.cell-code textarea:focus ~ .line-numbers {
  border-color: var(--border-hi);
}

.highlight-layer {
  position: absolute;
  top: 0; left: 0; right: 0; bottom: 0;
  background: var(--bg1);
  border: 1px solid var(--border);
  padding: 8px 10px 8px calc(var(--gutter) + 10px);
  font-family: var(--mono);
  font-size: var(--editor-font-size);
  line-height: 1.5;
  tab-size: 2;
  white-space: pre;
  overflow: hidden;
  z-index: 1;
  pointer-events: none;
  color: var(--fg-bright);
}

/* syntax tokens */
.hl-kw { color: #7a9ec7; }
.hl-str { color: var(--accent); }
.hl-num { color: #8cb878; }
.hl-cmt { color: #555; font-style: italic; }
.hl-fn { color: #c4a6d0; }
.hl-const { color: #d09870; }
.hl-op { color: #888; }
.hl-punc { color: #666; }

/* CSS syntax tokens */
.hl-atrule { color: #7aabcf; }
.hl-prop { color: #7aabcf; }
.hl-sel { color: #d4955a; }
.hl-color { color: var(--accent); }
.hl-important { color: #d4555a; font-weight: bold; }

/* HTML syntax tokens */
.hl-tag { color: #6dbfb8; }
.hl-attr { color: #7aabcf; }
.hl-expr { color: var(--accent); }

.hl-swatch {
  display: inline-block;
  width: 10px;
  height: 10px;
  border: 1px solid var(--border-hi);
  vertical-align: middle;
  margin-right: 2px;
  cursor: pointer;
  pointer-events: auto;
}

.cell-output {
  padding: 4px 10px;
  min-height: 0;
  font-size: 12px;
  color: var(--fg);
  white-space: pre-wrap;
  word-break: break-all;
}
.cell-output:empty {
  display: none;
}
.cell-output.error {
  color: var(--err);
}

.cell-output canvas {
  max-width: 100%;
  display: block;
  margin: 4px 0;
}

.cell-output table {
  border-collapse: collapse;
  font-size: 11px;
  margin: 4px 0;
}
.cell-output table th,
.cell-output table td {
  border: 1px solid var(--border);
  padding: 2px 8px;
}
.cell-output table th {
  color: var(--accent);
  font-weight: normal;
  text-transform: uppercase;
  font-size: 9px;
  letter-spacing: 1px;
}

/* ── CSS CELL ── */
.cell-css-view {
  padding: 6px 10px;
  color: var(--fg-dim);
  cursor: text;
  min-height: 24px;
  font-size: 11px;
  font-style: italic;
}
.cell-css-view:empty::before {
  content: '(empty stylesheet)';
}

.cell-css-edit textarea {
  display: block;
  width: 100%;
  background: transparent;
  border: 1px solid var(--border);
  color: var(--fg-bright);
  caret-color: var(--fg-bright);
  font-family: var(--mono);
  font-size: var(--editor-font-size);
  line-height: 1.5;
  padding: 8px 10px 8px calc(var(--gutter) + 10px);
  resize: vertical;
  min-height: 38px;
  outline: none;
  tab-size: 2;
  white-space: pre;
  overflow-x: auto;
  position: relative;
  z-index: 2;
  -webkit-text-fill-color: transparent;
}
.cell-css-edit textarea::selection {
  -webkit-text-fill-color: var(--fg-bright);
  background: rgba(200,155,60,0.25);
}
.cell-css-edit textarea:focus + .highlight-layer {
  border-color: var(--border-hi);
}
.cell-css-edit textarea:focus ~ .line-numbers {
  border-color: var(--border-hi);
}

/* ── HTML CELL ── */
.cell-html-view {
  padding: 6px 10px;
  color: var(--fg);
  cursor: text;
  min-height: 24px;
}
.cell-html-view:empty::before {
  content: '(empty html template)';
  color: var(--fg-dim);
  font-style: italic;
  font-size: 11px;
}
.cell-html-edit textarea {
  display: block;
  width: 100%;
  background: transparent;
  border: 1px solid var(--border);
  color: var(--fg-bright);
  caret-color: var(--fg-bright);
  font-family: var(--mono);
  font-size: var(--editor-font-size);
  line-height: 1.5;
  padding: 8px 10px 8px calc(var(--gutter) + 10px);
  resize: vertical;
  min-height: 38px;
  outline: none;
  tab-size: 2;
  white-space: pre;
  overflow-x: auto;
  position: relative;
  z-index: 2;
  -webkit-text-fill-color: transparent;
}
.cell-html-edit textarea::selection {
  -webkit-text-fill-color: var(--fg-bright);
  background: rgba(200,155,60,0.25);
}
.cell-html-edit textarea:focus + .highlight-layer {
  border-color: var(--border-hi);
}
.cell-html-edit textarea:focus ~ .line-numbers {
  border-color: var(--border-hi);
}

/* ── MARKDOWN CELL ── */
.cell-md-view {
  padding: 6px 10px;
  color: var(--fg);
  cursor: text;
  min-height: 24px;
}
.cell-md-view:empty::before {
  content: '(empty markdown cell)';
  color: var(--fg-dim);
  font-style: italic;
  font-size: 11px;
}
.cell-md-view h1, .cell-md-view h2, .cell-md-view h3 {
  color: var(--fg-bright);
  font-weight: normal;
  margin: 4px 0;
}
.cell-md-view h1 { font-size: 18px; letter-spacing: 2px; }
.cell-md-view h2 { font-size: 15px; letter-spacing: 1px; color: var(--accent); }
.cell-md-view h3 { font-size: 13px; }
.cell-md-view p { margin: 4px 0; }
.cell-md-view code {
  background: var(--bg2);
  padding: 1px 4px;
  font-size: 12px;
}
.cell-md-view strong { color: var(--fg-bright); }
.cell-md-view em { font-style: italic; }
.cell-md-view a { color: var(--accent); }
.cell-md-view table {
  border-collapse: collapse;
  font-size: 11px;
  margin: 4px 0;
}
.cell-md-view table th,
.cell-md-view table td {
  border: 1px solid var(--border);
  padding: 2px 8px;
}
.cell-md-view table th {
  color: var(--accent);
  font-weight: normal;
  text-transform: uppercase;
  font-size: 9px;
  letter-spacing: 1px;
}

.cell-md-edit textarea {
  display: block;
  width: 100%;
  background: var(--bg1);
  border: 1px solid var(--border);
  color: var(--fg-bright);
  font-family: var(--mono);
  font-size: var(--editor-font-size);
  line-height: 1.5;
  padding: 8px 10px;
  resize: vertical;
  min-height: 38px;
  outline: none;
}

/* ── PRESENTATION MODE ── */
body.presenting .toolbar { display: none; }
body.presenting .cell-header { display: none; }
body.presenting .cell-code { display: none; }
body.presenting .cell-md-edit { display: none !important; }
body.presenting .cell-css-edit { display: none; }
body.presenting .cell-css-view { display: none; }
body.presenting .cell-html-edit { display: none !important; }
body.presenting .cell { border-left: none; margin: 0; }
body.presenting .cell:hover { border-left: none; }
body.presenting .insert-bar { display: none; }
body.presenting .notebook { max-width: 900px; padding-top: 40px; }
body.presenting .statusbar { display: none; }
body.presenting .present-hidden { display: none; }
body.presenting .present-exit {
  display: block;
  position: fixed;
  top: 12px;
  right: 12px;
  z-index: 200;
}
.present-exit { display: none; }

/* ── INSERT BAR (between cells) ── */
.insert-bar {
  height: 16px;
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  margin: -6px 0;
}
.insert-bar::before {
  content: '';
  position: absolute;
  left: 20px;
  right: 20px;
  top: 50%;
  height: 1px;
  background: var(--border);
  opacity: 0;
  transition: opacity 0.15s;
}
.insert-bar:hover::before { opacity: 1; }
.insert-bar .insert-btns {
  display: flex;
  gap: 4px;
  opacity: 0;
  transition: opacity 0.15s;
  position: relative;
  z-index: 10;
}
.insert-bar:hover .insert-btns { opacity: 1; }
.insert-bar .insert-btns button {
  font-size: 9px;
  padding: 1px 8px;
  background: var(--bg);
  border: 1px solid var(--border);
  color: var(--fg-dim);
}
.insert-bar .insert-btns button:hover {
  border-color: var(--accent-dim);
  color: var(--accent);
}

/* ── ADD CELL BAR ── */
.add-bar {
  display: flex;
  justify-content: center;
  gap: 8px;
  padding: 6px 0;
  opacity: 0;
  transition: opacity 0.15s;
}
.notebook:hover .add-bar,
.add-bar.visible {
  opacity: 0.5;
}
.add-bar:hover {
  opacity: 1 !important;
}

/* ── WIDGET CLASSES ── */
.cell-widget {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 2px 0;
  font-size: 12px;
  color: var(--fg-dim);
}
.cell-widget-label {
  min-width: 80px;
  font-size: 10px;
  letter-spacing: 1px;
  text-transform: uppercase;
  color: var(--fg-dim);
}
.cell-widget input[type="range"] {
  flex: 1;
  accent-color: var(--accent);
  max-width: 200px;
}
.cell-widget select {
  background: var(--bg2);
  border: 1px solid var(--border);
  color: var(--fg-bright);
  font-family: var(--mono);
  font-size: 12px;
  padding: 2px 4px;
}
.cell-widget input[type="checkbox"] {
  accent-color: var(--accent);
}
.cell-widget input[type="text"] {
  background: var(--bg2);
  border: 1px solid var(--border);
  color: var(--fg-bright);
  font-family: var(--mono);
  font-size: 12px;
  padding: 2px 6px;
  flex: 1;
  max-width: 200px;
}
.cell-widget-val {
  min-width: 40px;
  text-align: right;
  color: var(--fg-bright);
  font-size: 12px;
}

/* ── STATUS BAR ── */
.statusbar {
  position: fixed;
  bottom: 0;
  left: 0;
  right: 0;
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 4px 12px;
  background: var(--bg);
  border-top: 1px solid var(--border);
  font-size: 10px;
  color: var(--fg-dim);
  letter-spacing: 1px;
  z-index: 100;
}
.statusbar .status-size { color: var(--fg-dim); }
.statusbar .status-cells { color: var(--fg-dim); }
.statusbar .status-msg { flex: 1; text-align: right; }
.statusbar .status-msg.ok { color: var(--ok); }
.statusbar .status-msg.warn { color: var(--accent); }
.statusbar .status-msg.err { color: var(--err); }
.statusbar .status-attr { margin-left: auto; display: flex; align-items: center; gap: 6px; }
.statusbar .status-attr a {
  color: var(--fg-dim);
  text-decoration: none;
  transition: color 0.2s;
}
.statusbar .status-attr a:hover { color: var(--accent); }
.statusbar .status-attr svg { vertical-align: middle; }

/* ── EMPTY STATE ── */
.empty-state {
  text-align: center;
  padding: 80px 20px;
  color: var(--fg-dim);
}
.empty-state .logo {
  font-size: 11px;
  letter-spacing: 4px;
  text-transform: uppercase;
  color: var(--accent);
  margin-bottom: 16px;
}
.empty-state .tagline {
  font-size: 11px;
  margin-bottom: 24px;
}

.help-overlay {
  display: none;
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.85);
  z-index: 1000;
  overflow-y: auto;
  padding: 40px;
}
.help-overlay.visible { display: flex; justify-content: center; }
.help-content {
  position: relative;
  max-width: 600px;
  width: 100%;
  color: var(--fg);
  font-family: var(--mono);
  font-size: 13px;
  line-height: 1.8;
}
.help-content h2 {
  color: var(--accent);
  font-size: 14px;
  letter-spacing: 2px;
  text-transform: uppercase;
  margin: 24px 0 8px 0;
  border-bottom: 1px solid var(--border);
  padding-bottom: 4px;
}
.help-content h2:first-child { margin-top: 0; }
.help-row {
  display: flex;
  justify-content: space-between;
  padding: 2px 0;
}
.help-key {
  background: var(--bg2);
  border: 1px solid var(--border);
  border-radius: 3px;
  padding: 0 6px;
  font-size: 11px;
  color: var(--fg-bright);
  min-width: 80px;
  text-align: center;
  display: inline-block;
}
.help-desc { color: var(--fg); }
.help-close {
  color: var(--accent-dim);
  font-size: 11px;
  text-align: center;
  margin-top: 24px;
  letter-spacing: 1px;
}
.help-close-btn {
  position: absolute;
  top: 0;
  right: 0;
  background: none;
  border: 1px solid var(--border);
  color: var(--fg-dim);
  font-size: 20px;
  width: 44px;
  height: 44px;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 0;
  cursor: pointer;
  text-transform: none;
  letter-spacing: 0;
}
.help-close-btn:hover {
  border-color: var(--err);
  color: var(--err);
}

/* ── SETTINGS PANEL ── */
.settings-overlay {
  display: none;
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.5);
  z-index: 1000;
}
.settings-overlay.visible { display: block; }
.settings-panel {
  display: none;
  position: fixed;
  top: 0;
  right: 0;
  bottom: 0;
  width: 280px;
  max-width: 90vw;
  background: var(--bg1);
  border-left: 1px solid var(--border);
  padding: 20px;
  overflow-y: auto;
  z-index: 1001;
  font-family: var(--mono);
  font-size: 12px;
  color: var(--fg);
}
.settings-close {
  position: absolute;
  top: 12px;
  right: 12px;
  background: none;
  border: 1px solid var(--border);
  color: var(--fg-dim);
  font-size: 18px;
  width: 32px;
  height: 32px;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 0;
  cursor: pointer;
  text-transform: none;
  letter-spacing: 0;
}
.settings-close:hover {
  border-color: var(--err);
  color: var(--err);
}

.settings-panel h2 {
  color: var(--accent);
  font-size: 11px;
  letter-spacing: 2px;
  text-transform: uppercase;
  margin: 20px 0 10px 0;
}
.settings-panel h2:first-child { margin-top: 0; }
.settings-row {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 6px 0;
}
.settings-row label { color: var(--fg-dim); font-size: 11px; }
.settings-row select,
.settings-row input[type="range"] {
  background: var(--bg2);
  border: 1px solid var(--border);
  color: var(--fg-bright);
  font-family: var(--mono);
  font-size: 11px;
  padding: 2px 4px;
}
.settings-row input[type="range"] {
  accent-color: var(--accent);
  width: 100px;
}
.settings-val {
  min-width: 30px;
  text-align: right;
  color: var(--fg-bright);
  font-size: 11px;
}

/* ── SETTINGS DESCRIPTIONS ── */
.settings-desc {
  color: var(--fg-dim);
  font-size: 10px;
  line-height: 1.5;
  padding: 4px 0 8px;
}
.settings-desc strong {
  color: var(--fg);
}

/* ── HIDE RUN TOGGLE ── */
html.hide-run-toggle #autorunBtn,
html.hide-run-toggle #autorunBtnMobile { display: none; }

/* ── MODULE LIST (settings panel) ── */
.module-row {
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 4px 0;
  font-size: 11px;
}
.module-url {
  flex: 1;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  color: var(--fg);
}
.module-info {
  color: var(--fg-dim);
  white-space: nowrap;
  font-size: 10px;
}
.module-remove {
  background: none;
  border: none;
  color: var(--fg-dim);
  font-size: 14px;
  padding: 0 2px;
  cursor: pointer;
  line-height: 1;
  text-transform: none;
  letter-spacing: 0;
}
.module-remove:hover { color: var(--err); }
.module-total {
  padding: 4px 0;
  font-size: 10px;
  color: var(--fg-dim);
  border-top: 1px solid var(--border);
  text-align: right;
}
.module-empty {
  color: var(--fg-dim);
  font-size: 11px;
  font-style: italic;
  padding: 4px 0;
}
/* ── UPDATE PANEL ── */
.update-overlay {
  display: none;
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.5);
  z-index: 1000;
}
.update-overlay.visible { display: block; }
.update-panel {
  display: none;
  position: fixed;
  top: 0;
  right: 0;
  bottom: 0;
  width: 280px;
  max-width: 90vw;
  background: var(--bg1);
  border-left: 1px solid var(--border);
  padding: 20px;
  overflow-y: auto;
  z-index: 1001;
  font-family: var(--mono);
  font-size: 12px;
  color: var(--fg);
}
.update-panel h2 {
  color: var(--accent);
  font-size: 11px;
  letter-spacing: 2px;
  text-transform: uppercase;
  margin: 0 0 12px 0;
}
.update-panel .settings-row {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 6px 0;
}
.update-panel .settings-row label { color: var(--fg-dim); font-size: 11px; }
.update-actions {
  display: flex;
  flex-direction: column;
  gap: 6px;
  padding: 8px 0;
}
.update-actions button {
  width: 100%;
  padding: 8px 10px;
}
.update-status {
  font-size: 11px;
  padding: 8px 0;
  line-height: 1.5;
}
.update-status strong { color: var(--fg-bright); }
.update-status button {
  display: block;
  width: 100%;
  margin-top: 8px;
  padding: 8px 10px;
  border-color: var(--accent-dim);
  color: var(--accent);
}
.update-status button:hover {
  border-color: var(--accent);
}
.update-ok { color: var(--ok); }
.update-err { color: var(--err); }
.update-warn { color: var(--accent); }
.update-available { color: var(--fg); }
.update-notes {
  color: var(--fg-dim);
  font-size: 11px;
  padding: 6px 0;
  max-height: 120px;
  overflow-y: auto;
  line-height: 1.4;
}
.update-notes p { margin: 0 0 4px; }
.update-notes ul { margin: 2px 0; padding-left: 16px; }
.update-notes li { margin: 1px 0; }
.update-notes h1, .update-notes h2, .update-notes h3 { font-size: 11px; margin: 4px 0 2px; color: var(--fg); }
.update-confirm {
  display: flex;
  gap: 8px;
  padding: 6px 0;
}
.update-confirm button { width: auto; }
.update-sig {
  font-size: 11px;
}
.update-key-truncated {
  cursor: pointer;
}
.update-key-truncated:hover {
  color: var(--accent);
}
.update-key-expanded {
  word-break: break-all;
  user-select: all;
  cursor: pointer;
  color: var(--fg-bright);
}
/* ── UPDATE BUTTON IN OVERFLOW TRAY ── */
.toolbar-update-btn {
  color: var(--accent) !important;
}

.settings-about {
  margin-top: 24px;
  padding-top: 12px;
  border-top: 1px solid var(--border);
  font-size: 11px;
  color: var(--fg-dim);
  display: flex;
  flex-direction: column;
  gap: 2px;
}
.settings-about a {
  color: var(--accent);
  text-decoration: none;
}
.settings-about a:hover { text-decoration: underline; }

/* ── FIND BAR ── */
.find-bar {
  display: none;
  flex-direction: column;
  position: sticky;
  top: 33px;
  z-index: 99;
  float: right;
  max-width: 400px;
  width: 100%;
  background: var(--bg1);
  border: 1px solid var(--border);
  border-top: none;
  padding: 6px 8px;
  gap: 4px;
}
.find-row {
  display: flex;
  align-items: center;
  gap: 4px;
}
.find-replace-row {
  display: none;
  align-items: center;
  gap: 4px;
}
.find-bar.show-replace .find-replace-row { display: flex; }
.find-bar input[type="text"] {
  flex: 1;
  background: var(--bg2);
  border: 1px solid var(--border);
  color: var(--fg-bright);
  font-family: var(--mono);
  font-size: 12px;
  padding: 4px 8px;
  outline: none;
  min-width: 0;
}
.find-bar input[type="text"]:focus {
  border-color: var(--border-hi);
}
.find-count {
  font-size: 10px;
  color: var(--fg-dim);
  white-space: nowrap;
  min-width: 50px;
  text-align: center;
  letter-spacing: 1px;
}
.find-bar button {
  padding: 3px 8px;
  font-size: 10px;
  min-width: 28px;
}
.find-bar button.active {
  color: var(--accent);
  border-color: var(--accent-dim);
}
body.presenting .find-bar { display: none !important; }

/* ── SEARCH OVERLAY ── */
.search-overlay {
  position: absolute;
  top: 0; left: 0; right: 0; bottom: 0;
  padding: 8px 10px 8px calc(var(--gutter) + 10px);
  font-family: var(--mono);
  font-size: var(--editor-font-size);
  line-height: 1.5;
  tab-size: 2;
  white-space: pre;
  overflow: hidden;
  z-index: 1;
  pointer-events: none;
  color: transparent;
  border: 1px solid transparent;
}
.search-overlay-md {
  padding: 8px 10px;
}
.md-search-wrap {
  position: relative;
}
.search-match {
  background: rgba(200,155,60,0.25);
  color: transparent;
}
.search-match-current {
  background: rgba(200,155,60,0.5);
  outline: 1px solid var(--accent);
}

/* ── AUTOCOMPLETE MENU ── */
.ac-menu {
  position: absolute;
  z-index: 10;
  background: #1e1e1e;
  border: 1px solid #444;
  border-radius: 3px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.4);
  max-height: 200px;
  overflow-y: auto;
  font-family: var(--mono);
  font-size: var(--editor-font-size);
  min-width: 120px;
}
.ac-item {
  padding: 2px 8px;
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 6px;
  white-space: nowrap;
}
.ac-item.active,
.ac-item:hover {
  background: rgba(200,155,60,0.2);
}
.ac-kind {
  width: 16px;
  height: 16px;
  border-radius: 2px;
  font-size: 10px;
  text-align: center;
  line-height: 16px;
  flex-shrink: 0;
}
.ac-kind-var, .ac-kind-def { color: #5ca7e4; }
.ac-kind-fn { color: #c89b3c; }
.ac-kind-kw { color: #cc7832; }
.ac-kind-const { color: #9876aa; }
.ac-kind-prop { color: #6a8759; }
.ac-text { color: var(--fg-bright); }
.ac-detail {
  margin-left: auto;
  padding-left: 12px;
  color: var(--fg-dim);
  font-size: 11px;
}
.ac-match { font-weight: bold; }
.ac-sig-hint {
  position: absolute;
  z-index: 10;
  background: #1e1e1e;
  border: 1px solid #444;
  border-radius: 3px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.4);
  padding: 3px 8px;
  font-family: var(--mono);
  font-size: var(--editor-font-size);
  white-space: nowrap;
  display: flex;
  gap: 10px;
  align-items: baseline;
}
.ac-sig-fn { color: var(--fg-bright); }
.ac-sig-active { color: var(--accent); font-weight: bold; text-decoration: underline; }
.ac-sig-desc { color: var(--fg-dim); font-size: 11px; }
:root.light .ac-sig-hint {
  background: #eae8e3;
  border-color: #b0ab9f;
  box-shadow: 0 2px 8px rgba(0,0,0,0.15);
}
:root.light .ac-menu {
  background: #eae8e3;
  border-color: #b0ab9f;
  box-shadow: 0 2px 8px rgba(0,0,0,0.15);
}
:root.light .ac-item.active,
:root.light .ac-item:hover {
  background: rgba(153,107,31,0.15);
}

/* ── WORKSHOP PANEL ── */
.workshop-overlay {
  display: none;
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.3);
  z-index: 900;
}
.workshop-overlay.visible { display: block; }
.workshop-panel {
  position: fixed;
  top: 0;
  right: -380px;
  bottom: 0;
  width: 360px;
  max-width: 90vw;
  background: var(--bg1);
  border-left: 1px solid var(--border);
  z-index: 901;
  display: flex;
  flex-direction: column;
  font-family: var(--mono);
  font-size: 13px;
  color: var(--fg);
  transition: right 0.25s ease;
  overflow: hidden;
}
.workshop-panel.open { right: 0; }
.workshop-tab {
  position: fixed;
  right: 0;
  top: 50%;
  transform: translateY(-50%) rotate(180deg);
  writing-mode: vertical-rl;
  background: var(--bg1);
  border: 1px solid var(--border);
  border-right: none;
  color: var(--accent);
  font-family: var(--mono);
  font-size: 10px;
  letter-spacing: 2px;
  text-transform: uppercase;
  padding: 10px 5px;
  cursor: pointer;
  z-index: 902;
  transition: right 0.25s ease;
}
.workshop-tab:hover { background: var(--bg2); }
.workshop-panel.open ~ .workshop-tab { right: min(360px, 90vw); }
.workshop-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 16px 16px 12px;
  border-bottom: 1px solid var(--border);
}
.workshop-title {
  color: var(--accent);
  font-size: 11px;
  letter-spacing: 2px;
  text-transform: uppercase;
}
.workshop-close {
  background: none;
  border: 1px solid var(--border);
  color: var(--fg-dim);
  font-size: 18px;
  width: 28px; height: 28px;
  display: flex; align-items: center; justify-content: center;
  padding: 0; cursor: pointer;
  text-transform: none;
  letter-spacing: 0;
}
.workshop-close:hover { border-color: var(--err); color: var(--err); }
.workshop-body {
  flex: 1;
  overflow-y: auto;
  padding: 16px;
  line-height: 1.6;
}
.workshop-body h1, .workshop-body h2, .workshop-body h3 {
  color: var(--fg-bright);
  margin: 1em 0 0.5em;
}
.workshop-body h1:first-child, .workshop-body h2:first-child, .workshop-body h3:first-child {
  margin-top: 0;
}
.workshop-body code {
  background: var(--bg2);
  padding: 1px 4px;
  font-size: 0.9em;
}
.workshop-body strong { color: var(--accent); }
.workshop-pips {
  display: flex;
  justify-content: center;
  gap: 6px;
  padding: 8px 16px;
}
.workshop-pip {
  width: 8px; height: 8px;
  border-radius: 50%;
  background: var(--border);
  cursor: pointer;
}
.workshop-pip.done { background: var(--fg-dim); }
.workshop-pip.active { background: var(--accent); }
.workshop-nav {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 12px 16px;
  border-top: 1px solid var(--border);
}
.workshop-nav button {
  background: var(--bg2);
  border: 1px solid var(--border);
  color: var(--fg);
  font-family: var(--mono);
  font-size: 11px;
  padding: 4px 12px;
  cursor: pointer;
}
.workshop-nav button:hover { border-color: var(--accent); color: var(--accent); }
.workshop-nav button:disabled { opacity: 0.3; cursor: default; }
.workshop-nav button:disabled:hover { border-color: var(--border); color: var(--fg); }
.workshop-counter { color: var(--fg-dim); font-size: 11px; }

/* ── LIGHT THEME ── */
:root.light {
  --bg: #f5f4f0;
  --bg1: #eae8e3;
  --bg2: #dedad3;
  --border: #ccc8bf;
  --border-hi: #b0ab9f;
  --fg: #444;
  --fg-dim: #888;
  --fg-bright: #222;
  --accent: #996b1f;
  --accent-dim: #b8924a;
  --err: #c33;
  --ok: #287;
}
:root.light .cell[data-type="code"] .cell-type { color: #4a7a9e; }
:root.light .cell[data-type="css"]  .cell-type { color: #a56e33; }
:root.light .cell[data-type="html"] .cell-type { color: #3d8a83; }
:root.light ::-webkit-scrollbar-track { background: var(--bg); }
:root.light ::-webkit-scrollbar-thumb { background: var(--border-hi); }

/* ── TOUCH / HEADER MODES ── */
@media (hover: none) {
  .insert-bar { display: none; }
  .cell.selected .cell-insert { display: inline; }
  .cell.selected .cell-convert { display: inline; }
  .cell.selected .cell-header {
    gap: 2px;
  }
  .cell.selected .cell-btn {
    min-height: 36px;
    min-width: 36px;
    font-size: 14px;
    display: inline-flex;
    align-items: center;
    justify-content: center;
  }
}

/* compact header: ellipsis indicator, full controls on select */
@media (hover: none) {
  :root:not(.header-always):not(.header-hover) .cell-header > * { display: none; }
  :root:not(.header-always):not(.header-hover) .cell-header {
    opacity: 1;
    justify-content: center;
    padding: 1px 8px;
  }
  :root:not(.header-always):not(.header-hover) .cell-header::before {
    content: '\22ef';
    color: var(--fg-dim);
    font-size: 12px;
    opacity: 0.4;
  }
  :root:not(.header-always):not(.header-hover) .cell.selected .cell-header > * { display: inline; }
  :root:not(.header-always):not(.header-hover) .cell.selected .cell-header::before { display: none; }
  :root:not(.header-always):not(.header-hover) .cell.selected .cell-header {
    justify-content: flex-start;
    padding: 2px 8px;
  }
}

/* header-always: full header visible on all devices */
:root.header-always .cell-header { opacity: 0.6; }
:root.header-always .cell:hover .cell-header,
:root.header-always .cell.selected .cell-header { opacity: 1; }

/* header-compact: forced compact mode on all devices */
:root.header-compact .cell-header > * { display: none; }
:root.header-compact .cell-header {
  opacity: 1 !important;
  justify-content: center;
  padding: 1px 8px;
}
:root.header-compact .cell-header::before {
  content: '\22ef';
  color: var(--fg-dim);
  font-size: 12px;
  opacity: 0.4;
}
:root.header-compact .cell.selected .cell-header > * { display: inline; }
:root.header-compact .cell.selected .cell-header::before { display: none; }
:root.header-compact .cell.selected .cell-header {
  justify-content: flex-start;
  padding: 2px 8px;
}

/* ── RESPONSIVE ── */
@media (max-width: 640px) {
  /* slim top toolbar: filename + cell count only */
  .toolbar {
    flex-wrap: nowrap;
    gap: 4px;
    padding: 6px 8px;
  }
  .toolbar-title { display: none; }
  .toolbar-sep { display: none; }
  .toolbar .toolbar-add, .toolbar .toolbar-secondary { display: none; }
  .transport { display: none; }
  .toolbar-right { display: none; }
  .toolbar-filename { flex: 1; }
  .toolbar-filename input { width: 100%; }
  .toolbar-status {
    display: inline;
    font-size: 10px;
    color: var(--fg-dim);
    white-space: nowrap;
    letter-spacing: 1px;
  }

  /* bottom action bar replaces statusbar */
  .statusbar {
    display: block;
    padding: 0;
    height: 48px;
  }
  .statusbar .status-size,
  .statusbar .status-cells,
  .statusbar .status-msg,
  .statusbar .status-attr { display: none; }
  .action-bar {
    display: grid;
    grid-template-columns: repeat(5, 1fr);
    height: 48px;
  }
  /* wrapper divs for tray positioning must fill their grid cell */
  .action-bar > div {
    position: relative;
    display: flex;
  }
  .action-bar > div > button {
    flex: 1;
  }
  /* style only the 5 action buttons, not tray buttons */
  .action-bar > button,
  .action-bar > div > button {
    min-height: 48px;
    border: none;
    border-right: 1px solid var(--border);
    background: var(--bg);
    font-family: var(--mono);
    font-size: 16px;
    color: var(--fg);
    padding: 0;
    letter-spacing: 0;
    text-transform: none;
  }
  .action-bar > :last-child > button,
  .action-bar > button:last-child { border-right: none; }
  .action-bar > button:active,
  .action-bar > div > button:active { background: var(--bg2); }
  .action-bar > button.autorun-on,
  .action-bar > div > button.autorun-on {
    background: #33aa77;
    color: #111;
  }
  .action-bar > button.autorun-off,
  .action-bar > div > button.autorun-off {
    background: #dd4444;
    color: #111;
  }

  .find-bar { max-width: 100%; float: none; }
  .notebook { padding: 8px 6px 100px; }
  .cell-header { padding: 2px 4px; }
  .settings-close { width: 44px; height: 44px; font-size: 22px; }
  .settings-row { padding: 10px 0; }
  .settings-row select { min-height: 44px; font-size: 14px; padding: 4px 8px; }
  .settings-row input[type="range"] { height: 44px; }
  .help-overlay { padding: 20px 12px; }
  .settings-panel { width: 260px; }
}

</style>
</head>
<body>

<div class="help-overlay" id="helpOverlay">
<div class="help-content">
<button class="help-close-btn" onclick="$('#helpOverlay').classList.remove('visible')">&#x00d7;</button>
<h2>command mode</h2>
<div class="help-row"><span class="help-key">&#x2191; / k</span><span class="help-desc">select cell above</span></div>
<div class="help-row"><span class="help-key">&#x2193; / j</span><span class="help-desc">select cell below</span></div>
<div class="help-row"><span class="help-key">Enter</span><span class="help-desc">edit selected cell</span></div>
<div class="help-row"><span class="help-key">a</span><span class="help-desc">insert cell above</span></div>
<div class="help-row"><span class="help-key">b</span><span class="help-desc">insert cell below</span></div>
<div class="help-row"><span class="help-key">d d</span><span class="help-desc">delete cell</span></div>
<div class="help-row"><span class="help-key">z</span><span class="help-desc">undo delete</span></div>
<div class="help-row"><span class="help-key">c</span><span class="help-desc">copy cell</span></div>
<div class="help-row"><span class="help-key">v</span><span class="help-desc">paste cell below</span></div>
<div class="help-row"><span class="help-key">x</span><span class="help-desc">cut cell</span></div>
<div class="help-row"><span class="help-key">m</span><span class="help-desc">convert to markdown</span></div>
<div class="help-row"><span class="help-key">y</span><span class="help-desc">convert to code</span></div>
<div class="help-row"><span class="help-key">s</span><span class="help-desc">convert to css</span></div>
<div class="help-row"><span class="help-key">t</span><span class="help-desc">convert to html template</span></div>
<div class="help-row"><span class="help-key">h</span><span class="help-desc">collapse / expand cell</span></div>
<div class="help-row"><span class="help-key">l</span><span class="help-desc">toggle line numbers</span></div>
<div class="help-row"><span class="help-key">p</span><span class="help-desc">presentation mode</span></div>

<h2>edit mode</h2>
<div class="help-row"><span class="help-key">Esc</span><span class="help-desc">exit to command mode</span></div>
<div class="help-row"><span class="help-key">Ctrl+Enter</span><span class="help-desc">run cell</span></div>
<div class="help-row"><span class="help-key">Shift+Enter</span><span class="help-desc">run cell + advance</span></div>
<div class="help-row"><span class="help-key">Ctrl+/</span><span class="help-desc">toggle comment</span></div>
<div class="help-row"><span class="help-key">Tab</span><span class="help-desc">indent</span></div>
<div class="help-row"><span class="help-key">Shift+Tab</span><span class="help-desc">unindent</span></div>

<h2>global</h2>
<div class="help-row"><span class="help-key">F1</span><span class="help-desc">toggle this help</span></div>
<div class="help-row"><span class="help-key">Ctrl+S</span><span class="help-desc">save notebook</span></div>
<div class="help-row"><span class="help-key">Ctrl+F</span><span class="help-desc">find in notebook</span></div>
<div class="help-row"><span class="help-key">Ctrl+H</span><span class="help-desc">find and replace</span></div>

<h2>toolbar</h2>
<div class="help-row"><span class="help-key">&#x23f5; step</span><span class="help-desc">run selected cell</span></div>
<div class="help-row"><span class="help-key">&#x25b6;/&#x2016;</span><span class="help-desc">toggle reactive mode (autorun)</span></div>
<div class="help-row"><span class="help-key">&#x25b6;&#x25b6; run all</span><span class="help-desc">run all cells</span></div>

<h2>builtins</h2>
<div class="help-row"><span class="help-key">display()</span><span class="help-desc">show text, objects, or DOM elements</span></div>
<div class="help-row"><span class="help-key">canvas(w,h)</span><span class="help-desc">create a canvas element</span></div>
<div class="help-row"><span class="help-key">table(data)</span><span class="help-desc">render array of objects as table</span></div>
<div class="help-row"><span class="help-key">slider()</span><span class="help-desc">reactive range input</span></div>
<div class="help-row"><span class="help-key">dropdown()</span><span class="help-desc">reactive select input</span></div>
<div class="help-row"><span class="help-key">checkbox()</span><span class="help-desc">reactive boolean input</span></div>
<div class="help-row"><span class="help-key">textInput()</span><span class="help-desc">reactive text input</span></div>
<div class="help-row"><span class="help-key">load(url)</span><span class="help-desc">import ESM module (cached)</span></div>
<div class="help-row"><span class="help-key">install(url)</span><span class="help-desc">import + embed in HTML on save</span></div>
<div class="help-row"><span class="help-key">installBinary(url)</span><span class="help-desc">fetch binary asset + embed gzipped</span></div>
<div class="help-row"><span class="help-key">invalidation</span><span class="help-desc">promise that resolves before cell re-runs</span></div>
<div class="help-row"><span class="help-key">md``</span><span class="help-desc">markdown tagged template</span></div>
<div class="help-row"><span class="help-key">html``</span><span class="help-desc">HTML tagged template</span></div>
<div class="help-row"><span class="help-key">css``</span><span class="help-desc">CSS tagged template</span></div>
<div class="help-row"><span class="help-key">workshop(pages)</span><span class="help-desc">interactive side panel with pages</span></div>
<div class="help-row"><span class="help-key">notebook</span><span class="help-desc">API for cells, scope, scrollTo, focus</span></div>

<h2>directives</h2>
<div class="help-row"><span class="help-key">// %manual</span><span class="help-desc">skip cell on reactive updates</span></div>
<div class="help-row"><span class="help-key">// %norun</span><span class="help-desc">skip cell on Run All</span></div>
<div class="help-row"><span class="help-key">// %hide</span><span class="help-desc">hide cell in present mode</span></div>
<div class="help-row"><span class="help-key">// %cellName &lt;label&gt;</span><span class="help-desc">name cell in DevTools</span></div>
<div class="help-row"><span class="help-key">// %outputId &lt;id&gt;</span><span class="help-desc">set id on output div</span></div>
<div class="help-row"><span class="help-key">// %outputClass &lt;cls&gt;</span><span class="help-desc">add classes to output div</span></div>
<div class="help-row"><span class="help-key">// %goto &lt;label&gt;</span><span class="help-desc">jump to named cell after execution</span></div>
<div class="help-row"><span class="help-key">// %collapsed</span><span class="help-desc">start cell collapsed</span></div>

<div class="help-close">press F1 or Esc to close</div>
</div>
</div>

<div class="settings-overlay" id="settingsOverlay" onclick="if(event.target===this)toggleSettings()"></div>
<div class="settings-panel" id="settingsPanel">
  <button class="settings-close" onclick="toggleSettings()">&#x00d7;</button>
  <h2>theme</h2>
  <div class="settings-row">
    <label>color scheme</label>
    <select id="setTheme" onchange="applyTheme(this.value)">
      <option value="dark">dark</option>
      <option value="light">light</option>
    </select>
  </div>

  <h2>editor</h2>
  <div class="settings-row">
    <label>font size</label>
    <input type="range" id="setFontSize" min="10" max="20" value="13" oninput="applyFontSize(this.value)">
    <span class="settings-val" id="setFontSizeVal">13</span>
  </div>
  <div class="settings-row">
    <label>line numbers</label>
    <select id="setLineNumbers" onchange="applyLineNumbers(this.value)">
      <option value="on" selected>on</option>
      <option value="off">off</option>
    </select>
  </div>

  <h2>notebook</h2>
  <div class="settings-row">
    <label>max width</label>
    <select id="setWidth" onchange="applyWidth(this.value)">
      <option value="720">narrow</option>
      <option value="860" selected>default</option>
      <option value="1100">wide</option>
      <option value="100%">full</option>
    </select>
  </div>
  <div class="settings-row">
    <label>cell header</label>
    <select id="setHeader" onchange="applyHeader(this.value)">
      <option value="auto" selected>auto</option>
      <option value="always">always visible</option>
      <option value="compact">compact</option>
      <option value="hover">hover only</option>
    </select>
  </div>

  <h2>execution</h2>
  <div class="settings-row">
    <label>mode</label>
    <select id="setExecMode" onchange="applyExecMode(this.value)">
      <option value="reactive">reactive</option>
      <option value="manual">manual</option>
    </select>
  </div>
  <div class="settings-row">
    <label>run on load</label>
    <select id="setRunOnLoad" onchange="applyRunOnLoad(this.value)">
      <option value="yes">yes</option>
      <option value="no">no</option>
    </select>
  </div>
  <div class="settings-row">
    <label>show run toggle</label>
    <select id="setShowToggle" onchange="applyShowToggle(this.value)">
      <option value="yes">yes</option>
      <option value="no">no</option>
    </select>
  </div>
  <div class="settings-desc">
    <strong>reactive</strong>: cells auto-run on edit, changes propagate.<br>
    <strong>manual</strong>: only Ctrl+Enter, Shift+Enter, or Run All.
  </div>
  <div class="settings-row">
    <label>global override</label>
    <select id="setGlobalExecMode" onchange="applyGlobalExecMode(this.value)">
      <option value="">(notebook default)</option>
      <option value="reactive">always reactive</option>
      <option value="manual">always manual</option>
    </select>
  </div>
  <div class="settings-row">
    <label>global run on load</label>
    <select id="setGlobalRunOnLoad" onchange="applyGlobalRunOnLoad(this.value)">
      <option value="">(notebook default)</option>
      <option value="yes">always run</option>
      <option value="no">never run</option>
    </select>
  </div>

  <h2>modules</h2>
  <div id="moduleList"></div>
  <h2>binaries</h2>
  <div id="binaryList"></div>

  <div class="settings-about">
    <span id="aboutVersion"></span>
    <span id="aboutBuild"></span>
    <span id="aboutRuntime"></span>
    <a href="https://github.com/endarthur/auditable" target="_blank">github.com/endarthur/auditable</a>
  </div>
</div>

<div class="update-overlay" id="updateOverlay" onclick="if(event.target===this)toggleUpdate()"></div>
<div class="update-panel" id="updatePanel">
  <button class="settings-close" onclick="toggleUpdate()">&#x00d7;</button>
  <h2>update</h2>
  <div class="settings-row">
    <label>version</label>
    <span id="updateCurrentVer">v0.0.0</span>
  </div>
  <div class="settings-row">
    <label>release</label>
    <span id="updateRelease">dev</span>
  </div>
  <div class="settings-row">
    <label>signature</label>
    <span id="updateSigStatus" class="update-sig">checking...</span>
  </div>
  <div class="settings-row">
    <label>public key</label>
    <span id="updatePubKey" class="update-sig">-</span>
  </div>
  <div id="updateStatus" class="update-status"></div>
  <div class="update-actions">
    <button id="updateCheckBtn" onclick="checkForUpdate()">check for updates</button>
    <button onclick="updateFromFile()">update from file</button>
  </div>
</div>

<div class="toolbar">
  <span class="toolbar-title">auditable</span>
  <span class="toolbar-badges" id="toolbarBadges"></span>
  <span class="toolbar-sep"></span>
  <span class="toolbar-filename">
    <input type="text" id="docTitle" value="atra — language tour" spellcheck="false">
  </span>
  <span class="toolbar-status" id="toolbarStatus"></span>
  <button class="toolbar-add" onclick="addCellWithUndo('code','',S.selectedId)">+ code</button>
  <button class="toolbar-add" onclick="addCellWithUndo('md','',S.selectedId)">+ md</button>
  <button class="toolbar-secondary" onclick="addCellWithUndo('css','',S.selectedId)">+ css</button>
  <button class="toolbar-secondary" onclick="addCellWithUndo('html','',S.selectedId)">+ html</button>
  <span class="toolbar-sep"></span>
  <span class="transport">
    <button onclick="runSelectedCell()" title="run cell + advance (Shift+Enter)">&#x23f5;</button>
    <button id="autorunBtn" class="autorun-on" onclick="toggleAutorun()" title="reactive mode &#x2014; cells auto-run on edit">&#x25b6;</button>
    <button onclick="runAll()" title="run all cells">&#x25b6;&#x25b6;</button>
  </span>
  <span class="toolbar-right">
    <span class="save-split">
      <button class="accent" onclick="saveNotebook()"><span id="saveLabel">save</span></button><button class="accent save-caret" onclick="toggleSaveTray()">&#x25be;</button>
      <div class="save-tray" id="saveTray">
        <button onclick="setSaveMode('normal');saveNotebook()">save</button>
        <button onclick="setSaveMode('packed');saveNotebook()">save packed</button>
        <button onclick="exportAsTxt();toggleSaveTray()">export .txt</button>
      </div>
    </span>
    <div class="toolbar-overflow">
      <button onclick="toggleToolbarMenu()" title="more">&#x22ef;</button>
      <div class="toolbar-overflow-tray">
        <button onclick="newNotebook();toggleToolbarMenu()">new</button>
        <button onclick="collapseAll();toggleToolbarMenu()">collapse all</button>
        <button onclick="expandAll();toggleToolbarMenu()">expand all</button>
        <button onclick="$('#helpOverlay').classList.toggle('visible');toggleToolbarMenu()">help (F1)</button>
        <button onclick="toggleSettings();toggleToolbarMenu()">settings</button>
        <button class="toolbar-update-btn" onclick="toggleUpdate();toggleToolbarMenu()">update</button>
        <button onclick="togglePresent();toggleToolbarMenu()">present</button>
        <button onclick="openFind(false);toggleToolbarMenu()">find (Ctrl+F)</button>
      </div>
    </div>
  </span>
</div>

<div class="find-bar" id="findBar">
  <div class="find-row">
    <input type="text" id="findInput" placeholder="find" spellcheck="false" autocomplete="off">
    <span class="find-count" id="findCount"></span>
    <button id="findRegexBtn" title="use regex">.*</button>
    <button id="findCaseBtn" title="match case">Aa</button>
    <button id="findPrevBtn" title="previous (Shift+Enter)">&#x2191;</button>
    <button id="findNextBtn" title="next (Enter)">&#x2193;</button>
    <button id="findCloseBtn" title="close (Esc)">&#x00d7;</button>
  </div>
  <div class="find-replace-row" id="findReplaceRow">
    <input type="text" id="replaceInput" placeholder="replace" spellcheck="false" autocomplete="off">
    <button id="findReplaceBtn">replace</button>
    <button id="findReplaceAllBtn">all</button>
  </div>
</div>

<button class="present-exit" onclick="togglePresent()">&#x2715; exit</button>

<div class="notebook" id="notebook">
  <!-- cells go here -->
</div>

<div class="statusbar">
  <span class="status-size" id="statusSize"></span>
  <span class="status-cells" id="statusCells">0 cells</span>
  <span class="status-msg" id="statusMsg"></span>
  <span class="status-attr">
    <a href="https://endarthur.github.io" target="_blank">endarthur</a>
    <span>&middot;</span>
    <a href="https://gentropic.org" target="_blank">geoscientific chaos union</a>
    <span>&middot;</span>
    <a href="https://github.com/endarthur/auditable" target="_blank" title="source on GitHub"><svg width="14" height="14" viewBox="0 0 16 16" fill="currentColor"><path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"/></svg></a>
  </span>
  <div class="action-bar">
    <div>
      <div class="action-add-tray">
        <button onclick="insertAt(S.selectedId,'code');toggleAddTray()">+ code</button>
        <button onclick="insertAt(S.selectedId,'md');toggleAddTray()">+ md</button>
        <button onclick="insertAt(S.selectedId,'css');toggleAddTray()">+ css</button>
        <button onclick="insertAt(S.selectedId,'html');toggleAddTray()">+ html</button>
      </div>
      <button class="action-add" onclick="toggleAddTray()">+</button>
    </div>
    <button onclick="runSelectedCell()" title="run cell + advance">&#x23f5;</button>
    <button id="autorunBtnMobile" class="autorun-on" onclick="toggleAutorun()" title="autorun">&#x25b6;</button>
    <button onclick="runAll()" title="run all">&#x25b6;&#x25b6;</button>
    <div>
      <div class="action-more-tray">
        <button onclick="newNotebook();toggleMoreTray()">new</button>
        <button id="mobileSaveBtn" class="active-mode" onclick="setSaveMode('normal');saveNotebook();toggleMoreTray()">save</button>
        <button id="mobilePackBtn" onclick="setSaveMode('packed');saveNotebook();toggleMoreTray()">save packed</button>
        <button onclick="collapseAll();toggleMoreTray()">collapse all</button>
        <button onclick="expandAll();toggleMoreTray()">expand all</button>
        <button onclick="$('#helpOverlay').classList.toggle('visible');toggleMoreTray()">help</button>
        <button onclick="toggleSettings();toggleMoreTray()">settings</button>
        <button class="toolbar-update-btn" onclick="toggleUpdate();toggleMoreTray()">update</button>
        <button onclick="togglePresent();toggleMoreTray()">present</button>
        <button onclick="openFind(false);toggleMoreTray()">find</button>
      </div>
      <button class="action-more" onclick="toggleMoreTray()">&#x22ef;</button>
    </div>
  </div>
</div>


<!-- cell data: JSON array of {type, code, collapsed?} -->
<!--AUDITABLE-DATA
[{"type":"md","code":"# atra language tour — Newton fractal\n\na [Newton fractal](https://en.wikipedia.org/wiki/Newton%27s_method) colors each pixel by which root of z\\u00b3 \\u2212 1 = 0 the Newton-Raphson method converges to. three roots in the complex plane, three colors. the algorithm exercises many atra features: **SIMD** (f64x2 for complex numbers), **dotted names**, **tailcall**, **call return()**, **if-expression**, **type conversions**, **arrays**, and **for loops**."},{"type":"code","code":"const { atra } = await load(\"./ext/atra/index.js\");\nconst maxIter = ui.slider(\"max iterations\", 40, {min: 5, max: 120, step: 1});\nconst res = ui.slider(\"resolution\", 200, {min: 50, max: 500, step: 10});"},{"type":"code","collapsed":true,"code":"// compile atra kernel — complex math via f64x2 SIMD, Newton iterator via tailcall\nconst mem = new WebAssembly.Memory({ initial: 4 });\n\nconst wasm = atra({ memory: mem })`\n  ! ── complex arithmetic via f64x2 SIMD ──\n  ! complex number = f64x2 where lane 0 = real, lane 1 = imag\n\n  ! complex multiply: (a+bi)(c+di) = (ac-bd) + (ad+bc)i\n  function cx.mul(a, b: f64x2): f64x2\n  var\n    ar, ai, br, bi: f64\n    re, im: f64\n  begin\n    ar := f64x2.extract_lane(a, 0)\n    ai := f64x2.extract_lane(a, 1)\n    br := f64x2.extract_lane(b, 0)\n    bi := f64x2.extract_lane(b, 1)\n    re := ar * br - ai * bi\n    im := ar * bi + ai * br\n    cx.mul := f64x2(re, im)\n  end\n\n  ! |z|^2 = re^2 + im^2\n  function cx.abs2(z: f64x2): f64\n  var\n    sq: f64x2\n  begin\n    sq := z * z\n    cx.abs2 := f64x2.extract_lane(sq, 0) + f64x2.extract_lane(sq, 1)\n  end\n\n  ! f(z) = z^3 - 1\n  function cx.f(z: f64x2): f64x2\n  var\n    z2, z3: f64x2\n  begin\n    z2 := cx.mul(z, z)\n    z3 := cx.mul(z2, z)\n    z3 := z3 - f64x2(1.0, 0.0)\n    cx.f := z3\n  end\n\n  ! f'(z) = 3z^2\n  function cx.df(z: f64x2): f64x2\n  var\n    z2: f64x2\n    three: f64x2\n  begin\n    z2 := cx.mul(z, z)\n    three := f64x2.splat(3.0)\n    cx.df := z2 * three\n  end\n\n  ! complex divide: a/b = a*conj(b) / |b|^2\n  function cx.div(a, b: f64x2): f64x2\n  var\n    conj_b, num: f64x2\n    denom: f64\n    dv: f64x2\n  begin\n    conj_b := f64x2(f64x2.extract_lane(b, 0), 0.0 - f64x2.extract_lane(b, 1))\n    num := cx.mul(a, conj_b)\n    denom := cx.abs2(b)\n    dv := f64x2.splat(denom)\n    cx.div := num / dv\n  end\n\n  ! ── Newton iterator with tail recursion ──\n  ! returns root id (0, 1, 2) or -1 if no convergence\n  ! takes scalar f64 parts (not f64x2) because tailcall passes via stack\n  function newton.step(zr, zi: f64, iter, maxIter: i32): i32\n  var\n    z, fz, dfz, ratio, znew: f64x2\n    nr, ni, d: f64\n    tol: f64\n  begin\n    ! guard: no convergence\n    if (iter >= maxIter) then\n      call return(0 - 1)\n    end if\n\n    z := f64x2(zr, zi)\n\n    ! Newton step: z_new = z - f(z)/f'(z)\n    fz := cx.f(z)\n    dfz := cx.df(z)\n    ratio := cx.div(fz, dfz)\n    znew := z - ratio\n\n    ! convergence check\n    tol := 1e-6\n    d := cx.abs2(znew - z)\n    if (d < tol) then\n      ! classify which root we converged to\n      ! roots of z^3-1: (1,0), (-0.5, sqrt(3)/2), (-0.5, -sqrt(3)/2)\n      nr := f64x2.extract_lane(znew, 0)\n      ni := f64x2.extract_lane(znew, 1)\n      if (nr > 0.0) then\n        call return(0)\n      else if (ni > 0.0) then\n        call return(1)\n      else\n        call return(2)\n      end if\n    end if\n\n    ! not converged — tail-recurse with updated z\n    tailcall newton.step(\n      f64x2.extract_lane(znew, 0),\n      f64x2.extract_lane(znew, 1),\n      iter + 1, maxIter\n    )\n  end\n\n  ! ── grid evaluator: for each pixel, run newton.step ──\n  subroutine newton.grid(out: array i32; w, h, maxIter: i32)\n  var\n    ix, iy: i32\n    x, y: f64\n    xmin, xmax, ymin, ymax: f64\n  begin\n    xmin := -1.5\n    xmax := 1.5\n    ymin := -1.5\n    ymax := 1.5\n    for iy := 0, h\n      for ix := 0, w\n        x := xmin + (xmax - xmin) * f64(ix) / f64(w)\n        y := ymin + (ymax - ymin) * f64(iy) / f64(h)\n        out[iy * w + ix] := newton.step(x, y, 0, maxIter)\n      end for\n    end for\n  end\n`;"},{"type":"code","code":"// run Wasm kernel and render to canvas\nconst t0 = performance.now();\nwasm.newton.grid(0, res, res, maxIter);\nconst elapsed = (performance.now() - t0).toFixed(2);\n\nconst grid = new Int32Array(mem.buffer, 0, res * res);\n\nconst size = Math.min(500, window.innerWidth - 80);\nconst c = ui.canvas(size, size);\nconst ctx = c.getContext(\"2d\");\nconst img = ctx.createImageData(res, res);\n\n// 3-color palette for 3 roots + black for non-convergence\nconst palette = [\n  [200, 155, 60],   // root 0 — amber\n  [60, 140, 200],   // root 1 — blue\n  [80, 190, 110],   // root 2 — green\n  [30, 30, 30],     // -1 — didn't converge\n];\n\nfor (let i = 0; i < res * res; i++) {\n  const rootId = grid[i];\n  const col = rootId < 0 ? palette[3] : palette[rootId];\n  img.data[i * 4 + 0] = col[0];\n  img.data[i * 4 + 1] = col[1];\n  img.data[i * 4 + 2] = col[2];\n  img.data[i * 4 + 3] = 255;\n}\n\n// scale up to canvas size\nconst tmp = new OffscreenCanvas(res, res);\nconst tctx = tmp.getContext(\"2d\");\ntctx.putImageData(img, 0, 0);\nctx.imageSmoothingEnabled = false;\nctx.drawImage(tmp, 0, 0, size, size);\n\nui.display(`${res}\\u00d7${res} \\u00b7 max ${maxIter} iterations \\u00b7 Wasm kernel: ${elapsed} ms`);"},{"type":"md","code":"**features used:**\n\n| feature | where |\n|---------|-------|\n| **f64x2 SIMD** | complex numbers packed as f64x2 \\u2014 `cx.mul`, `cx.div`, `cx.abs2`, `cx.f`, `cx.df` |\n| **dotted names** | `cx.*` and `newton.*` namespaces |\n| **tailcall** | `newton.step` tail-recurses until convergence or max iterations |\n| **call return()** | guard clause (max iter), early return on convergence with root id |\n| **if-expression style** | chained `if/else if/else` for root classification |\n| **type conversions** | `f64(ix)`, `f64(w)` \\u2014 pixel coords to floating point |\n| **arrays** | output grid of i32 root ids in linear memory |\n| **for loops** | nested pixel grid traversal in `newton.grid` |\n| **compound assignment** | `iter + 1` passed through tailcall |\n| **builtins** | `f64x2.extract_lane`, `f64x2.splat`, `f64x2()` constructor |"}]
AUDITABLE-DATA-->
<!-- installed modules: base64-encoded JSON mapping URLs to {source, cellId} -->
<!--AUDITABLE-MODULES
eyIuL2V4dC9hdHJhL2luZGV4LmpzIjp7InNvdXJjZSI6Ii8vIEBhdWRpdGFibGUvYXRyYSDigJQg
QXJpdGhtZXRpYyBUUkFuc3BpbGVyXG4vLyBGb3J0cmFuL1Bhc2NhbCBoeWJyaWQg4oaSIFdlYkFz
c2VtYmx5IGJ5dGVjb2RlLiBTaW5nbGUtZmlsZSBjb21waWxlci5cblxuLy8gLS0gaGlnaGxpZ2h0
LmpzIC0tXG5cbi8vIFN5bnRheCBoaWdobGlnaHRpbmcg4oCUIHRva2VuaXplciArIGNvbXBsZXRp
b25zIGZvciBhdWRpdGFibGUgZWRpdG9yIGludGVncmF0aW9uXG5cbmNvbnN0IEFUUkFfS0VZV09S
RFMgPSBuZXcgU2V0KFtcbiAgJ2Z1bmN0aW9uJywnc3Vicm91dGluZScsJ2JlZ2luJywnZW5kJywn
dmFyJywnY29uc3QnLCdpZicsJ3RoZW4nLCdlbHNlJyxcbiAgJ2ZvcicsJ3doaWxlJywnZG8nLCdi
cmVhaycsJ2FuZCcsJ29yJywnbm90JywnbW9kJywnaW1wb3J0JywnZXhwb3J0JyxcbiAgJ2NhbGwn
LCdhcnJheScsJ3RydWUnLCdmYWxzZScsJ2Zyb20nLCd0YWlsY2FsbCcsJ3JldHVybicsXG5dKTtc
blxuY29uc3QgQVRSQV9UWVBFUyA9IG5ldyBTZXQoWydpMzInLCdpNjQnLCdmMzInLCdmNjQnLCdm
NjR4MicsJ2YzMng0JywnaTMyeDQnLCdpNjR4MiddKTtcblxuY29uc3QgQVRSQV9CVUlMVElOUyA9
IG5ldyBTZXQoW1xuICAnc2luJywnY29zJywnc3FydCcsJ2FicycsJ2Zsb29yJywnY2VpbCcsJ2xu
JywnZXhwJywncG93JyxcbiAgJ21pbicsJ21heCcsJ3RydW5jJywnbmVhcmVzdCcsJ2NvcHlzaWdu
Jywnc2VsZWN0JyxcbiAgJ2NseicsJ2N0eicsJ3BvcGNudCcsJ3JvdGwnLCdyb3RyJywnbWVtb3J5
X3NpemUnLCdtZW1vcnlfZ3JvdycsXG4gICdtZW1vcnlfY29weScsJ21lbW9yeV9maWxsJyxcbl0p
O1xuXG5jb25zdCBBVFJBX1ZFQ1RPUl9UWVBFUyA9IG5ldyBTZXQoWydmNjR4MicsJ2YzMng0Jywn
aTMyeDQnLCdpNjR4MiddKTtcblxuZnVuY3Rpb24gdG9rZW5pemVBdHJhKGNvZGUpIHtcbiAgY29u
c3QgdG9rZW5zID0gW107XG4gIGxldCBpID0gMDtcbiAgY29uc3QgbGVuID0gY29kZS5sZW5ndGg7
XG5cbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAvLyBsaW5lIGNvbW1lbnQ6ICEgdG8gZW5kIG9m
IGxpbmVcbiAgICBpZiAoY29kZVtpXSA9PT0gJyEnKSB7XG4gICAgICBjb25zdCBzdGFydCA9IGk7
XG4gICAgICB3aGlsZSAoaSA8IGxlbiAmJiBjb2RlW2ldICE9PSAnXFxuJykgaSsrO1xuICAgICAg
dG9rZW5zLnB1c2goeyB0eXBlOiAnY210JywgdGV4dDogY29kZS5zbGljZShzdGFydCwgaSkgfSk7
XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgLy8gbnVtYmVycyAod2l0aCBvcHRpb25hbCB0
eXBlIHN1ZmZpeCBfZjMyLCBfZjY0LCBfaTMyLCBfaTY0KVxuICAgIGlmICgvXFxkLy50ZXN0KGNv
ZGVbaV0pIHx8IChjb2RlW2ldID09PSAnLicgJiYgaSArIDEgPCBsZW4gJiYgL1xcZC8udGVzdChj
b2RlW2kgKyAxXSkpKSB7XG4gICAgICBjb25zdCBzdGFydCA9IGk7XG4gICAgICB3aGlsZSAoaSA8
IGxlbiAmJiAvWzAtOS5dLy50ZXN0KGNvZGVbaV0pKSBpKys7XG4gICAgICBpZiAoaSA8IGxlbiAm
JiAvW2VFXS8udGVzdChjb2RlW2ldKSkge1xuICAgICAgICBpKys7XG4gICAgICAgIGlmIChpIDwg
bGVuICYmIC9bKy1dLy50ZXN0KGNvZGVbaV0pKSBpKys7XG4gICAgICAgIHdoaWxlIChpIDwgbGVu
ICYmIC9cXGQvLnRlc3QoY29kZVtpXSkpIGkrKztcbiAgICAgIH1cbiAgICAgIC8vIHR5cGUgc3Vm
Zml4OiBfZjMyLCBfZjY0LCBfaTMyLCBfaTY0XG4gICAgICBpZiAoY29kZVtpXSA9PT0gJ18nICYm
IGkgKyAzIDw9IGxlbiAmJiAvXltmaV0vLnRlc3QoY29kZVtpICsgMV0pKSB7XG4gICAgICAgIGNv
bnN0IHN1ZiA9IGNvZGUuc2xpY2UoaSArIDEsIGkgKyA0KTtcbiAgICAgICAgaWYgKEFUUkFfVFlQ
RVMuaGFzKHN1ZikpIGkgKz0gNDtcbiAgICAgIH1cbiAgICAgIHRva2Vucy5wdXNoKHsgdHlwZTog
J251bScsIHRleHQ6IGNvZGUuc2xpY2Uoc3RhcnQsIGkpIH0pO1xuICAgICAgY29udGludWU7XG4g
ICAgfVxuICAgIC8vIGlkZW50aWZpZXJzIC8ga2V5d29yZHNcbiAgICBpZiAoL1thLXpBLVpfXS8u
dGVzdChjb2RlW2ldKSkge1xuICAgICAgY29uc3Qgc3RhcnQgPSBpO1xuICAgICAgd2hpbGUgKGkg
PCBsZW4gJiYgL1tcXHcuXS8udGVzdChjb2RlW2ldKSkgaSsrO1xuICAgICAgY29uc3Qgd29yZCA9
IGNvZGUuc2xpY2Uoc3RhcnQsIGkpO1xuICAgICAgY29uc3QgbG93ZXIgPSB3b3JkLnRvTG93ZXJD
YXNlKCk7XG4gICAgICBpZiAoQVRSQV9LRVlXT1JEUy5oYXMobG93ZXIpKSB7XG4gICAgICAgIHRv
a2Vucy5wdXNoKHsgdHlwZTogJ2t3JywgdGV4dDogd29yZCB9KTtcbiAgICAgIH0gZWxzZSBpZiAo
QVRSQV9UWVBFUy5oYXMobG93ZXIpKSB7XG4gICAgICAgIC8vIHR5cGUgbmFtZXMgYXMgYnVpbHRp
bnMgd2hlbiBmb2xsb3dlZCBieSAoXG4gICAgICAgIGlmIChpIDwgbGVuICYmIGNvZGVbaV0gPT09
ICcoJykge1xuICAgICAgICAgIHRva2Vucy5wdXNoKHsgdHlwZTogJ2ZuJywgdGV4dDogd29yZCB9
KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0b2tlbnMucHVzaCh7IHR5cGU6ICdjb25z
dCcsIHRleHQ6IHdvcmQgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoQVRSQV9CVUlM
VElOUy5oYXMobG93ZXIpIHx8IGxvd2VyLnN0YXJ0c1dpdGgoJ3dhc20uJykgfHxcbiAgICAgICAg
ICAgICAgICAgbG93ZXIuc3RhcnRzV2l0aCgndjEyOC4nKSB8fCAoQVRSQV9WRUNUT1JfVFlQRVMu
aGFzKGxvd2VyLnNwbGl0KCcuJylbMF0pICYmIGxvd2VyLmluY2x1ZGVzKCcuJykpKSB7XG4gICAg
ICAgIHRva2Vucy5wdXNoKHsgdHlwZTogJ2ZuJywgdGV4dDogd29yZCB9KTtcbiAgICAgIH0gZWxz
ZSBpZiAoaSA8IGxlbiAmJiBjb2RlW2ldID09PSAnKCcpIHtcbiAgICAgICAgdG9rZW5zLnB1c2go
eyB0eXBlOiAnZm4nLCB0ZXh0OiB3b3JkIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdG9r
ZW5zLnB1c2goeyB0eXBlOiAnaWQnLCB0ZXh0OiB3b3JkIH0pO1xuICAgICAgfVxuICAgICAgY29u
dGludWU7XG4gICAgfVxuICAgIC8vIG11bHRpLWNoYXIgb3BlcmF0b3JzXG4gICAgaWYgKGkgKyAx
IDwgbGVuKSB7XG4gICAgICBjb25zdCB0d28gPSBjb2RlW2ldICsgY29kZVtpICsgMV07XG4gICAg
ICBpZiAodHdvID09PSAnKionIHx8IHR3byA9PT0gJzo9JyB8fCB0d28gPT09ICcrPScgfHwgdHdv
ID09PSAnLT0nIHx8XG4gICAgICAgICAgdHdvID09PSAnKj0nIHx8IHR3byA9PT0gJy89JyB8fCB0
d28gPT09ICc9PScgfHwgdHdvID09PSAnPD0nIHx8XG4gICAgICAgICAgdHdvID09PSAnPj0nIHx8
IHR3byA9PT0gJzw8JyB8fCB0d28gPT09ICc+PicpIHtcbiAgICAgICAgdG9rZW5zLnB1c2goeyB0
eXBlOiAnb3AnLCB0ZXh0OiB0d28gfSk7XG4gICAgICAgIGkgKz0gMjtcbiAgICAgICAgY29udGlu
dWU7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIHNpbmdsZS1jaGFyIG9wZXJhdG9yc1xuICAgIGlm
ICgnKy0qLzw+PSZ8Xn4nLmluY2x1ZGVzKGNvZGVbaV0pKSB7XG4gICAgICB0b2tlbnMucHVzaCh7
IHR5cGU6ICdvcCcsIHRleHQ6IGNvZGVbaV0gfSk7XG4gICAgICBpKys7XG4gICAgICBjb250aW51
ZTtcbiAgICB9XG4gICAgLy8gcHVuY3R1YXRpb25cbiAgICBpZiAoJygpW107LDonLmluY2x1ZGVz
KGNvZGVbaV0pKSB7XG4gICAgICB0b2tlbnMucHVzaCh7IHR5cGU6ICdwdW5jJywgdGV4dDogY29k
ZVtpXSB9KTtcbiAgICAgIGkrKztcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICAvLyB3aGl0
ZXNwYWNlIC8gb3RoZXJcbiAgICB0b2tlbnMucHVzaCh7IHR5cGU6ICcnLCB0ZXh0OiBjb2RlW2ld
IH0pO1xuICAgIGkrKztcbiAgfVxuICByZXR1cm4gdG9rZW5zO1xufVxuXG5mdW5jdGlvbiBhdHJh
Q29tcGxldGlvbnMoKSB7XG4gIGNvbnN0IGl0ZW1zID0gW107XG4gIGZvciAoY29uc3QgdyBvZiBB
VFJBX0tFWVdPUkRTKSBpdGVtcy5wdXNoKHsgdGV4dDogdywga2luZDogJ2t3JyB9KTtcbiAgZm9y
IChjb25zdCB3IG9mIEFUUkFfVFlQRVMpICAgIGl0ZW1zLnB1c2goeyB0ZXh0OiB3LCBraW5kOiAn
Y29uc3QnIH0pO1xuICBmb3IgKGNvbnN0IHcgb2YgQVRSQV9CVUlMVElOUykgaXRlbXMucHVzaCh7
IHRleHQ6IHcsIGtpbmQ6ICdmbicgfSk7XG4gIHJldHVybiBpdGVtcztcbn1cblxuLy8gLS0gbGV4
LmpzIC0tXG5cbi8vIExleGVyIOKAlCB0b2tlbml6ZXIgZm9yIHRoZSBwYXJzZXJcblxuXG5jb25z
dCBUT0sgPSB7XG4gIE5VTTogJ251bScsIElEOiAnaWQnLCBLVzogJ2t3JywgT1A6ICdvcCcsIFBV
TkM6ICdwdW5jJywgRU9GOiAnZW9mJyxcbn07XG5cbmZ1bmN0aW9uIGxleChzb3VyY2UpIHtcbiAg
Y29uc3QgdG9rZW5zID0gW107XG4gIGxldCBpID0gMCwgbGluZSA9IDEsIGNvbCA9IDE7XG4gIGNv
bnN0IGxlbiA9IHNvdXJjZS5sZW5ndGg7XG5cbiAgZnVuY3Rpb24gYWR2KCkgeyBpZiAoc291cmNl
W2ldID09PSAnXFxuJykgeyBsaW5lKys7IGNvbCA9IDE7IH0gZWxzZSB7IGNvbCsrOyB9IGkrKzsg
fVxuICBmdW5jdGlvbiBwZWVrKCkgeyByZXR1cm4gaSA8IGxlbiA/IHNvdXJjZVtpXSA6ICcnOyB9
XG4gIGZ1bmN0aW9uIHBlZWsyKCkgeyByZXR1cm4gaSArIDEgPCBsZW4gPyBzb3VyY2VbaV0gKyBz
b3VyY2VbaSArIDFdIDogc291cmNlW2ldIHx8ICcnOyB9XG5cbiAgd2hpbGUgKGkgPCBsZW4pIHtc
biAgICAvLyBza2lwIHdoaXRlc3BhY2UgYW5kIHNlbWljb2xvbnNcbiAgICBpZiAoJyBcXHRcXHJc
XG47Jy5pbmNsdWRlcyhzb3VyY2VbaV0pKSB7IGFkdigpOyBjb250aW51ZTsgfVxuICAgIC8vIGNv
bW1lbnRcbiAgICBpZiAoc291cmNlW2ldID09PSAnIScpIHtcbiAgICAgIHdoaWxlIChpIDwgbGVu
ICYmIHNvdXJjZVtpXSAhPT0gJ1xcbicpIGFkdigpO1xuICAgICAgY29udGludWU7XG4gICAgfVxu
ICAgIGNvbnN0IHRsID0gbGluZSwgdGMgPSBjb2w7XG4gICAgLy8gbnVtYmVyXG4gICAgaWYgKC9c
XGQvLnRlc3Qoc291cmNlW2ldKSB8fCAoc291cmNlW2ldID09PSAnLicgJiYgaSArIDEgPCBsZW4g
JiYgL1xcZC8udGVzdChzb3VyY2VbaSArIDFdKSkpIHtcbiAgICAgIGNvbnN0IHN0YXJ0ID0gaTtc
biAgICAgIGxldCBpc0Zsb2F0ID0gZmFsc2U7XG4gICAgICB3aGlsZSAoaSA8IGxlbiAmJiAvXFxk
Ly50ZXN0KHNvdXJjZVtpXSkpIGFkdigpO1xuICAgICAgaWYgKHBlZWsoKSA9PT0gJy4nICYmIC9c
XGQvLnRlc3Qoc291cmNlW2kgKyAxXSB8fCAnJykpIHsgaXNGbG9hdCA9IHRydWU7IGFkdigpOyB3
aGlsZSAoaSA8IGxlbiAmJiAvXFxkLy50ZXN0KHNvdXJjZVtpXSkpIGFkdigpOyB9XG4gICAgICBp
ZiAoL1tlRV0vLnRlc3QocGVlaygpKSkgeyBpc0Zsb2F0ID0gdHJ1ZTsgYWR2KCk7IGlmICgvWyst
XS8udGVzdChwZWVrKCkpKSBhZHYoKTsgd2hpbGUgKGkgPCBsZW4gJiYgL1xcZC8udGVzdChzb3Vy
Y2VbaV0pKSBhZHYoKTsgfVxuICAgICAgbGV0IHR5cGVTdWZmaXggPSBudWxsO1xuICAgICAgaWYg
KHBlZWsoKSA9PT0gJ18nKSB7XG4gICAgICAgIGNvbnN0IHMgPSBzb3VyY2Uuc2xpY2UoaSArIDEs
IGkgKyA0KTtcbiAgICAgICAgaWYgKEFUUkFfVFlQRVMuaGFzKHMpKSB7IHR5cGVTdWZmaXggPSBz
OyBhZHYoKTsgYWR2KCk7IGFkdigpOyBhZHYoKTsgfVxuICAgICAgfVxuICAgICAgY29uc3QgcmF3
ID0gc291cmNlLnNsaWNlKHN0YXJ0LCBpKTtcbiAgICAgIHRva2Vucy5wdXNoKHsgdHlwZTogVE9L
Lk5VTSwgdmFsdWU6IHJhdywgaXNGbG9hdCwgdHlwZVN1ZmZpeCwgbGluZTogdGwsIGNvbDogdGMg
fSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgLy8gaWRlbnRpZmllciAoZG90cyBhbGxv
d2VkIOKAlCBuYW1lc3BhY2VzIGJ5IGNvbnZlbnRpb24pXG4gICAgaWYgKC9bYS16QS1aX10vLnRl
c3Qoc291cmNlW2ldKSkge1xuICAgICAgY29uc3Qgc3RhcnQgPSBpO1xuICAgICAgd2hpbGUgKGkg
PCBsZW4gJiYgL1tcXHcuXS8udGVzdChzb3VyY2VbaV0pKSBhZHYoKTtcbiAgICAgIC8vIHRyaW0g
dHJhaWxpbmcgZG90IChlLmcuIFwibmFtZS5cIiBhdCBlbmQgb2YgaW5wdXQpXG4gICAgICB3aGls
ZSAoaSA+IHN0YXJ0ICsgMSAmJiBzb3VyY2VbaSAtIDFdID09PSAnLicpIHsgaS0tOyBjb2wtLTsg
fVxuICAgICAgbGV0IHZhbCA9IHNvdXJjZS5zbGljZShzdGFydCwgaSk7XG4gICAgICAvLyBpbnRl
cnBvbGF0aW9uIG1hcmtlcnM6IF9fSU5URVJQX05fX1xuICAgICAgaWYgKC9eX19JTlRFUlBfXFxk
K19fJC8udGVzdCh2YWwpKSB7XG4gICAgICAgIHRva2Vucy5wdXNoKHsgdHlwZTogVE9LLklELCB2
YWx1ZTogdmFsLCBpbnRlcnA6IHRydWUsIGxpbmU6IHRsLCBjb2w6IHRjIH0pO1xuICAgICAgfSBl
bHNlIGlmIChBVFJBX0tFWVdPUkRTLmhhcyh2YWwpIHx8IEFUUkFfVFlQRVMuaGFzKHZhbCkpIHtc
biAgICAgICAgdG9rZW5zLnB1c2goeyB0eXBlOiBUT0suS1csIHZhbHVlOiB2YWwsIGxpbmU6IHRs
LCBjb2w6IHRjIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdG9rZW5zLnB1c2goeyB0eXBl
OiBUT0suSUQsIHZhbHVlOiB2YWwsIGxpbmU6IHRsLCBjb2w6IHRjIH0pO1xuICAgICAgfVxuICAg
ICAgY29udGludWU7XG4gICAgfVxuICAgIC8vIG11bHRpLWNoYXIgb3BlcmF0b3JzXG4gICAgY29u
c3QgdHcgPSBwZWVrMigpO1xuICAgIGlmICh0dyA9PT0gJyoqJyB8fCB0dyA9PT0gJzo9JyB8fCB0
dyA9PT0gJys9JyB8fCB0dyA9PT0gJy09JyB8fCB0dyA9PT0gJyo9JyB8fFxuICAgICAgICB0dyA9
PT0gJz09JyB8fCB0dyA9PT0gJzw9JyB8fCB0dyA9PT0gJz49JyB8fCB0dyA9PT0gJzw8JyB8fCB0
dyA9PT0gJz4+Jykge1xuICAgICAgdG9rZW5zLnB1c2goeyB0eXBlOiBUT0suT1AsIHZhbHVlOiB0
dywgbGluZTogdGwsIGNvbDogdGMgfSk7XG4gICAgICBhZHYoKTsgYWR2KCk7XG4gICAgICBjb250
aW51ZTtcbiAgICB9XG4gICAgLy8gLz0g4oCUIHRoaXMgaXMgbm90LWVxdWFsIGluIGF0cmFcbiAg
ICBpZiAoc291cmNlW2ldID09PSAnLycgJiYgc291cmNlW2kgKyAxXSA9PT0gJz0nKSB7XG4gICAg
ICB0b2tlbnMucHVzaCh7IHR5cGU6IFRPSy5PUCwgdmFsdWU6ICcvPScsIGxpbmU6IHRsLCBjb2w6
IHRjIH0pO1xuICAgICAgYWR2KCk7IGFkdigpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAg
IC8vIHNpbmdsZS1jaGFyIG9wZXJhdG9yc1xuICAgIGlmICgnKy0qLzw+PSZ8Xn4nLmluY2x1ZGVz
KHNvdXJjZVtpXSkpIHtcbiAgICAgIHRva2Vucy5wdXNoKHsgdHlwZTogVE9LLk9QLCB2YWx1ZTog
c291cmNlW2ldLCBsaW5lOiB0bCwgY29sOiB0YyB9KTtcbiAgICAgIGFkdigpO1xuICAgICAgY29u
dGludWU7XG4gICAgfVxuICAgIC8vIHB1bmN0dWF0aW9uXG4gICAgaWYgKCcoKVtdOyw6Jy5pbmNs
dWRlcyhzb3VyY2VbaV0pKSB7XG4gICAgICB0b2tlbnMucHVzaCh7IHR5cGU6IFRPSy5QVU5DLCB2
YWx1ZTogc291cmNlW2ldLCBsaW5lOiB0bCwgY29sOiB0YyB9KTtcbiAgICAgIGFkdigpO1xuICAg
ICAgY29udGludWU7XG4gICAgfVxuICAgIC8vIHNraXAgdW5rbm93blxuICAgIGFkdigpO1xuICB9
XG4gIHRva2Vucy5wdXNoKHsgdHlwZTogVE9LLkVPRiwgdmFsdWU6ICcnLCBsaW5lLCBjb2wgfSk7
XG4gIHJldHVybiB0b2tlbnM7XG59XG5cbi8vIC0tIHBhcnNlLmpzIC0tXG5cbi8vIFBhcnNlciDi
gJQgcmVjdXJzaXZlIGRlc2NlbnQgKyBQcmF0dCBleHByZXNzaW9ucyDihpIgQVNUXG5cblxuXG5m
dW5jdGlvbiBwYXJzZSh0b2tlbnMpIHtcbiAgbGV0IHBvcyA9IDA7XG4gIGZ1bmN0aW9uIGN1cigp
IHsgcmV0dXJuIHRva2Vuc1twb3NdOyB9XG4gIGZ1bmN0aW9uIGF0KHR5cGUsIHZhbHVlKSB7IGNv
bnN0IHQgPSBjdXIoKTsgcmV0dXJuIHQudHlwZSA9PT0gdHlwZSAmJiAodmFsdWUgPT09IHVuZGVm
aW5lZCB8fCB0LnZhbHVlID09PSB2YWx1ZSk7IH1cbiAgZnVuY3Rpb24gZWF0KHR5cGUsIHZhbHVl
KSB7XG4gICAgY29uc3QgdCA9IGN1cigpO1xuICAgIGlmICh0LnR5cGUgIT09IHR5cGUgfHwgKHZh
bHVlICE9PSB1bmRlZmluZWQgJiYgdC52YWx1ZSAhPT0gdmFsdWUpKVxuICAgICAgdGhyb3cgbmV3
IFN5bnRheEVycm9yKGBFeHBlY3RlZCAke3ZhbHVlIHx8IHR5cGV9IGJ1dCBnb3QgXCIke3QudmFs
dWV9XCIgYXQgJHt0LmxpbmV9OiR7dC5jb2x9YCk7XG4gICAgcG9zKys7XG4gICAgcmV0dXJuIHQ7
XG4gIH1cbiAgZnVuY3Rpb24gbWF5YmUodHlwZSwgdmFsdWUpIHsgaWYgKGF0KHR5cGUsIHZhbHVl
KSkgeyBwb3MrKzsgcmV0dXJuIHRydWU7IH0gcmV0dXJuIGZhbHNlOyB9XG5cbiAgZnVuY3Rpb24g
cGFyc2VQcm9ncmFtKCkge1xuICAgIGNvbnN0IGJvZHkgPSBbXTtcbiAgICB3aGlsZSAoIWF0KFRP
Sy5FT0YpKSB7XG4gICAgICBpZiAoYXQoVE9LLktXLCAnY29uc3QnKSAmJiAhaXNMb2NhbENvbnRl
eHQoKSkgYm9keS5wdXNoKHBhcnNlR2xvYmFsQ29uc3QoKSk7XG4gICAgICBlbHNlIGlmIChhdChU
T0suS1csICd2YXInKSAmJiAhaXNMb2NhbENvbnRleHQoKSkgYm9keS5wdXNoKHBhcnNlR2xvYmFs
VmFyKCkpO1xuICAgICAgZWxzZSBpZiAoYXQoVE9LLktXLCAnZnVuY3Rpb24nKSkgYm9keS5wdXNo
KHBhcnNlRnVuY3Rpb24oKSk7XG4gICAgICBlbHNlIGlmIChhdChUT0suS1csICdzdWJyb3V0aW5l
JykpIGJvZHkucHVzaChwYXJzZVN1YnJvdXRpbmUoKSk7XG4gICAgICBlbHNlIGlmIChhdChUT0su
S1csICdpbXBvcnQnKSkgYm9keS5wdXNoKHBhcnNlSW1wb3J0KCkpO1xuICAgICAgZWxzZSBpZiAo
YXQoVE9LLktXLCAnZXhwb3J0JykpIHsgcG9zKys7IGJvZHkucHVzaChwYXJzZUZ1bmN0aW9uKHRy
dWUpKTsgfVxuICAgICAgZWxzZSB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFVuZXhwZWN0ZWQgXCIk
e2N1cigpLnZhbHVlfVwiIGF0ICR7Y3VyKCkubGluZX06JHtjdXIoKS5jb2x9YCk7XG4gICAgfVxu
ICAgIHJldHVybiB7IHR5cGU6ICdQcm9ncmFtJywgYm9keSB9O1xuICB9XG5cbiAgZnVuY3Rpb24g
aXNMb2NhbENvbnRleHQoKSB7IHJldHVybiBmYWxzZTsgfSAvLyBnbG9iYWxzIG9ubHkgYXQgdG9w
IGxldmVsXG5cbiAgLy8gUGFyc2UgZnVuY3Rpb24gdHlwZSBzaWduYXR1cmU6IGZ1bmN0aW9uKHg6
IGY2NCwgeTogZjY0KTogZjY0XG4gIGZ1bmN0aW9uIHBhcnNlRnVuY1R5cGVTaWcoKSB7XG4gICAg
ZWF0KFRPSy5LVywgJ2Z1bmN0aW9uJyk7XG4gICAgZWF0KFRPSy5QVU5DLCAnKCcpO1xuICAgIGNv
bnN0IHBhcmFtcyA9IGF0KFRPSy5QVU5DLCAnKScpID8gW10gOiBwYXJzZVBhcmFtRW50cmllcygp
O1xuICAgIGVhdChUT0suUFVOQywgJyknKTtcbiAgICBsZXQgcmV0VHlwZSA9IG51bGw7XG4gICAg
aWYgKG1heWJlKFRPSy5QVU5DLCAnOicpKSByZXRUeXBlID0gZWF0KFRPSy5LVykudmFsdWU7XG4g
ICAgcmV0dXJuIHsgcGFyYW1zLCByZXRUeXBlIH07XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUds
b2JhbENvbnN0KCkge1xuICAgIGVhdChUT0suS1csICdjb25zdCcpO1xuICAgIGNvbnN0IG5hbWUg
PSBlYXQoVE9LLklEKS52YWx1ZTtcbiAgICBlYXQoVE9LLlBVTkMsICc6Jyk7XG4gICAgY29uc3Qg
dnR5cGUgPSBlYXQoVE9LLktXKS52YWx1ZTtcbiAgICBlYXQoVE9LLk9QLCAnPScpO1xuICAgIGNv
bnN0IGluaXQgPSBwYXJzZUV4cHIoMCk7XG4gICAgcmV0dXJuIHsgdHlwZTogJ0NvbnN0RGVjbCcs
IG5hbWUsIHZ0eXBlLCBpbml0IH07XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUdsb2JhbFZhcigp
IHtcbiAgICBlYXQoVE9LLktXLCAndmFyJyk7XG4gICAgY29uc3QgbmFtZSA9IGVhdChUT0suSUQp
LnZhbHVlO1xuICAgIGVhdChUT0suUFVOQywgJzonKTtcbiAgICBpZiAoYXQoVE9LLktXLCAnZnVu
Y3Rpb24nKSkge1xuICAgICAgY29uc3QgZnVuY1NpZyA9IHBhcnNlRnVuY1R5cGVTaWcoKTtcbiAg
ICAgIGxldCBpbml0ID0gbnVsbDtcbiAgICAgIGlmIChtYXliZShUT0suT1AsICc9JykpIGluaXQg
PSBwYXJzZUV4cHIoMCk7XG4gICAgICByZXR1cm4geyB0eXBlOiAnVmFyRGVjbCcsIG5hbWUsIHZ0
eXBlOiAnaTMyJywgZnVuY1NpZywgaW5pdCB9O1xuICAgIH1cbiAgICBjb25zdCB2dHlwZSA9IGVh
dChUT0suS1cpLnZhbHVlO1xuICAgIGxldCBpbml0ID0gbnVsbDtcbiAgICBpZiAobWF5YmUoVE9L
Lk9QLCAnPScpKSBpbml0ID0gcGFyc2VFeHByKDApO1xuICAgIHJldHVybiB7IHR5cGU6ICdWYXJE
ZWNsJywgbmFtZSwgdnR5cGUsIGluaXQgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlSW1wb3J0
KCkge1xuICAgIGVhdChUT0suS1csICdpbXBvcnQnKTtcbiAgICAvLyBpbXBvcnQgZnVuY3Rpb24g
bmFtZShwYXJhbXMpOiByZXRUeXBlIGZyb20gJ21vZHVsZSdcbiAgICAvLyBpbXBvcnQgbmFtZSA9
ICR7aW50ZXJwfVxuICAgIC8vIGltcG9ydCBuYW1lKHBhcmFtcyk6IHJldFR5cGUgPSAke2ludGVy
cH1cbiAgICBpZiAoYXQoVE9LLktXLCAnZnVuY3Rpb24nKSkge1xuICAgICAgcG9zKys7XG4gICAg
fVxuICAgIGNvbnN0IG5hbWUgPSBlYXQoVE9LLklEKS52YWx1ZTtcbiAgICBsZXQgcGFyYW1zID0g
W10sIHJldFR5cGUgPSBudWxsLCBtb2R1bGVOYW1lID0gJ2hvc3QnLCBpbnRlcnBJZHggPSBudWxs
O1xuICAgIGlmIChhdChUT0suUFVOQywgJygnKSkge1xuICAgICAgcGFyYW1zID0gcGFyc2VQYXJh
bUxpc3QoKTtcbiAgICB9XG4gICAgaWYgKG1heWJlKFRPSy5QVU5DLCAnOicpKSB7XG4gICAgICBy
ZXRUeXBlID0gZWF0KFRPSy5LVykudmFsdWU7XG4gICAgfVxuICAgIGlmIChtYXliZShUT0suT1As
ICc9JykpIHtcbiAgICAgIC8vIGludGVycG9sYXRpb24gbWFya2VyXG4gICAgICBjb25zdCB0ID0g
ZWF0KFRPSy5JRCk7XG4gICAgICBpbnRlcnBJZHggPSB0LnZhbHVlO1xuICAgIH0gZWxzZSBpZiAo
bWF5YmUoVE9LLktXLCAnZnJvbScpKSB7XG4gICAgICAvLyAnbW9kdWxlJyDigJQgd2UganVzdCBy
ZWFkIHRoZSBpZGVudGlmaWVyIGFzIGEgc3RyaW5nLWxpa2UgdGhpbmdcbiAgICAgIG1vZHVsZU5h
bWUgPSBlYXQoVE9LLklEKS52YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHsgdHlwZTogJ0ltcG9y
dERlY2wnLCBuYW1lLCBwYXJhbXMsIHJldFR5cGUsIG1vZHVsZU5hbWUsIGludGVycElkeCB9O1xu
ICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VGdW5jdGlvbihleHBvcnRlZCA9IGZhbHNlKSB7XG4gICAg
ZWF0KFRPSy5LVywgJ2Z1bmN0aW9uJyk7XG4gICAgY29uc3QgbmFtZSA9IGVhdChUT0suSUQpLnZh
bHVlO1xuICAgIGVhdChUT0suUFVOQywgJygnKTtcbiAgICBjb25zdCBwYXJhbXMgPSBhdChUT0su
UFVOQywgJyknKSA/IFtdIDogcGFyc2VQYXJhbUVudHJpZXMoKTtcbiAgICBlYXQoVE9LLlBVTkMs
ICcpJyk7XG4gICAgZWF0KFRPSy5QVU5DLCAnOicpO1xuICAgIGNvbnN0IHJldFR5cGUgPSBlYXQo
VE9LLktXKS52YWx1ZTtcbiAgICBjb25zdCBsb2NhbHMgPSBbXTtcbiAgICBpZiAoYXQoVE9LLktX
LCAndmFyJykpIHtcbiAgICAgIHBvcysrO1xuICAgICAgd2hpbGUgKCFhdChUT0suS1csICdiZWdp
bicpKSB7XG4gICAgICAgIGNvbnN0IGxuYW1lcyA9IFtlYXQoVE9LLklEKS52YWx1ZV07XG4gICAg
ICAgIHdoaWxlIChtYXliZShUT0suUFVOQywgJywnKSkgbG5hbWVzLnB1c2goZWF0KFRPSy5JRCku
dmFsdWUpO1xuICAgICAgICBlYXQoVE9LLlBVTkMsICc6Jyk7XG4gICAgICAgIGlmIChhdChUT0su
S1csICdmdW5jdGlvbicpKSB7XG4gICAgICAgICAgY29uc3QgZnVuY1NpZyA9IHBhcnNlRnVuY1R5
cGVTaWcoKTtcbiAgICAgICAgICBmb3IgKGNvbnN0IGxuIG9mIGxuYW1lcykgbG9jYWxzLnB1c2go
eyB0eXBlOiAnTG9jYWwnLCBuYW1lOiBsbiwgdnR5cGU6ICdpMzInLCBmdW5jU2lnIH0pO1xuICAg
ICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IGx0ID0gZWF0KFRPSy5LVykudmFsdWU7XG4g
ICAgICAgICAgZm9yIChjb25zdCBsbiBvZiBsbmFtZXMpIGxvY2Fscy5wdXNoKHsgdHlwZTogJ0xv
Y2FsJywgbmFtZTogbG4sIHZ0eXBlOiBsdCB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1c
biAgICBlYXQoVE9LLktXLCAnYmVnaW4nKTtcbiAgICBjb25zdCBib2R5ID0gcGFyc2VTdGF0ZW1l
bnRzKCdlbmQnKTtcbiAgICBlYXQoVE9LLktXLCAnZW5kJyk7XG4gICAgcmV0dXJuIHsgdHlwZTog
J0Z1bmN0aW9uJywgbmFtZSwgcGFyYW1zLCByZXRUeXBlLCBsb2NhbHMsIGJvZHksIGV4cG9ydGVk
IH07XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVN1YnJvdXRpbmUoKSB7XG4gICAgZWF0KFRPSy5L
VywgJ3N1YnJvdXRpbmUnKTtcbiAgICBjb25zdCBuYW1lID0gZWF0KFRPSy5JRCkudmFsdWU7XG4g
ICAgZWF0KFRPSy5QVU5DLCAnKCcpO1xuICAgIGNvbnN0IHBhcmFtcyA9IGF0KFRPSy5QVU5DLCAn
KScpID8gW10gOiBwYXJzZVBhcmFtRW50cmllcygpO1xuICAgIGVhdChUT0suUFVOQywgJyknKTtc
biAgICBjb25zdCBsb2NhbHMgPSBbXTtcbiAgICBpZiAoYXQoVE9LLktXLCAndmFyJykpIHtcbiAg
ICAgIHBvcysrO1xuICAgICAgd2hpbGUgKCFhdChUT0suS1csICdiZWdpbicpKSB7XG4gICAgICAg
IGNvbnN0IGxuYW1lcyA9IFtlYXQoVE9LLklEKS52YWx1ZV07XG4gICAgICAgIHdoaWxlIChtYXli
ZShUT0suUFVOQywgJywnKSkgbG5hbWVzLnB1c2goZWF0KFRPSy5JRCkudmFsdWUpO1xuICAgICAg
ICBlYXQoVE9LLlBVTkMsICc6Jyk7XG4gICAgICAgIGlmIChhdChUT0suS1csICdmdW5jdGlvbicp
KSB7XG4gICAgICAgICAgY29uc3QgZnVuY1NpZyA9IHBhcnNlRnVuY1R5cGVTaWcoKTtcbiAgICAg
ICAgICBmb3IgKGNvbnN0IGxuIG9mIGxuYW1lcykgbG9jYWxzLnB1c2goeyB0eXBlOiAnTG9jYWwn
LCBuYW1lOiBsbiwgdnR5cGU6ICdpMzInLCBmdW5jU2lnIH0pO1xuICAgICAgICB9IGVsc2Uge1xu
ICAgICAgICAgIGNvbnN0IGx0ID0gZWF0KFRPSy5LVykudmFsdWU7XG4gICAgICAgICAgZm9yIChj
b25zdCBsbiBvZiBsbmFtZXMpIGxvY2Fscy5wdXNoKHsgdHlwZTogJ0xvY2FsJywgbmFtZTogbG4s
IHZ0eXBlOiBsdCB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBlYXQoVE9LLktX
LCAnYmVnaW4nKTtcbiAgICBjb25zdCBib2R5ID0gcGFyc2VTdGF0ZW1lbnRzKCdlbmQnKTtcbiAg
ICBlYXQoVE9LLktXLCAnZW5kJyk7XG4gICAgcmV0dXJuIHsgdHlwZTogJ1N1YnJvdXRpbmUnLCBu
YW1lLCBwYXJhbXMsIGxvY2FscywgYm9keSB9O1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VQYXJh
bUVudHJpZXMoKSB7XG4gICAgY29uc3QgcGFyYW1zID0gW107XG4gICAgd2hpbGUgKGN1cigpLnR5
cGUgPT09IFRPSy5JRCkge1xuICAgICAgLy8gQ29sbGVjdCBjb21tYS1zZXBhcmF0ZWQgbmFtZXMg
dGhhdCBzaGFyZSBhIHR5cGVcbiAgICAgIGNvbnN0IG5hbWVzID0gW2VhdChUT0suSUQpLnZhbHVl
XTtcbiAgICAgIHdoaWxlIChhdChUT0suUFVOQywgJywnKSAmJiB0b2tlbnNbcG9zICsgMV0gJiYg
dG9rZW5zW3BvcyArIDFdLnR5cGUgPT09IFRPSy5JRCAmJlxuICAgICAgICAgICAgIHRva2Vuc1tw
b3MgKyAyXSAmJiAodG9rZW5zW3BvcyArIDJdLnZhbHVlID09PSAnLCcgfHwgdG9rZW5zW3BvcyAr
IDJdLnZhbHVlID09PSAnOicpKSB7XG4gICAgICAgIHBvcysrOyAvLyBza2lwICxcbiAgICAgICAg
bmFtZXMucHVzaChlYXQoVE9LLklEKS52YWx1ZSk7XG4gICAgICB9XG4gICAgICBlYXQoVE9LLlBV
TkMsICc6Jyk7XG4gICAgICAvLyBmdW5jdGlvbiB0eXBlOiBjYWxsYmFjazogZnVuY3Rpb24oeDog
ZjY0KTogZjY0XG4gICAgICBpZiAoYXQoVE9LLktXLCAnZnVuY3Rpb24nKSkge1xuICAgICAgICBj
b25zdCBmdW5jU2lnID0gcGFyc2VGdW5jVHlwZVNpZygpO1xuICAgICAgICBmb3IgKGNvbnN0IG4g
b2YgbmFtZXMpIHBhcmFtcy5wdXNoKHsgdHlwZTogJ1BhcmFtJywgbmFtZTogbiwgdnR5cGU6ICdp
MzInLCBpc0FycmF5OiBmYWxzZSwgYXJyYXlEaW1zOiBudWxsLCBmdW5jU2lnIH0pO1xuICAgICAg
ICBtYXliZShUT0suUFVOQywgJywnKTsgLy8gY29uc3VtZSBjb21tYSBiZXR3ZWVuIHBhcmFtIGdy
b3Vwc1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGxldCBpc0FycmF5ID0gZmFs
c2UsIGFycmF5RGltcyA9IG51bGw7XG4gICAgICBpZiAoYXQoVE9LLktXLCAnYXJyYXknKSkge1xu
ICAgICAgICBwb3MrKztcbiAgICAgICAgaXNBcnJheSA9IHRydWU7XG4gICAgICAgIGlmIChhdChU
T0suUFVOQywgJygnKSkge1xuICAgICAgICAgIHBvcysrO1xuICAgICAgICAgIGFycmF5RGltcyA9
IFtdO1xuICAgICAgICAgIGFycmF5RGltcy5wdXNoKHBhcnNlRXhwcigwKSk7XG4gICAgICAgICAg
d2hpbGUgKG1heWJlKFRPSy5QVU5DLCAnLCcpKSBhcnJheURpbXMucHVzaChwYXJzZUV4cHIoMCkp
O1xuICAgICAgICAgIGVhdChUT0suUFVOQywgJyknKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAg
ICAgY29uc3QgdnR5cGUgPSBlYXQoVE9LLktXKS52YWx1ZTtcbiAgICAgIGZvciAoY29uc3QgbiBv
ZiBuYW1lcykgcGFyYW1zLnB1c2goeyB0eXBlOiAnUGFyYW0nLCBuYW1lOiBuLCB2dHlwZSwgaXNB
cnJheSwgYXJyYXlEaW1zIH0pO1xuICAgICAgbWF5YmUoVE9LLlBVTkMsICcsJyk7IC8vIGNvbnN1
bWUgY29tbWEgYmV0d2VlbiBwYXJhbSBncm91cHNcbiAgICB9XG4gICAgcmV0dXJuIHBhcmFtcztc
biAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlUGFyYW1MaXN0KCkge1xuICAgIC8vIHNpbXBsaWZpZWQg
cGFyYW0gbGlzdCBmb3IgaW1wb3J0czogbmFtZTogdHlwZSwgLi4uXG4gICAgZWF0KFRPSy5QVU5D
LCAnKCcpO1xuICAgIGNvbnN0IHBhcmFtcyA9IFtdO1xuICAgIHdoaWxlIChjdXIoKS50eXBlID09
PSBUT0suSUQpIHtcbiAgICAgIGNvbnN0IG5hbWVzID0gW2VhdChUT0suSUQpLnZhbHVlXTtcbiAg
ICAgIHdoaWxlIChhdChUT0suUFVOQywgJywnKSAmJiB0b2tlbnNbcG9zICsgMV0gJiYgdG9rZW5z
W3BvcyArIDFdLnR5cGUgPT09IFRPSy5JRCAmJlxuICAgICAgICAgICAgIHRva2Vuc1twb3MgKyAy
XSAmJiAodG9rZW5zW3BvcyArIDJdLnZhbHVlID09PSAnLCcgfHwgdG9rZW5zW3BvcyArIDJdLnZh
bHVlID09PSAnOicpKSB7XG4gICAgICAgIHBvcysrO1xuICAgICAgICBuYW1lcy5wdXNoKGVhdChU
T0suSUQpLnZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGVhdChUT0suUFVOQywgJzonKTtcbiAgICAg
IGNvbnN0IHZ0eXBlID0gZWF0KFRPSy5LVykudmFsdWU7XG4gICAgICBmb3IgKGNvbnN0IG4gb2Yg
bmFtZXMpIHBhcmFtcy5wdXNoKHsgdHlwZTogJ1BhcmFtJywgbmFtZTogbiwgdnR5cGUsIGlzQXJy
YXk6IGZhbHNlLCBhcnJheURpbXM6IG51bGwgfSk7XG4gICAgICBtYXliZShUT0suUFVOQywgJywn
KTsgLy8gY29uc3VtZSBjb21tYSBiZXR3ZWVuIHBhcmFtIGdyb3Vwc1xuICAgIH1cbiAgICBlYXQo
VE9LLlBVTkMsICcpJyk7XG4gICAgcmV0dXJuIHBhcmFtcztcbiAgfVxuXG4gIGZ1bmN0aW9uIHBh
cnNlU3RhdGVtZW50cyhlbmRLdykge1xuICAgIGNvbnN0IHN0bXRzID0gW107XG4gICAgd2hpbGUg
KCFhdChUT0suS1csIGVuZEt3KSAmJiAhYXQoVE9LLkVPRikpIHtcbiAgICAgIC8vIGFsc28gc3Rv
cCBhdCAnZWxzZScgZm9yIGlmIGJsb2Nrc1xuICAgICAgaWYgKGVuZEt3ID09PSAnZW5kJyAmJiBh
dChUT0suS1csICdlbHNlJykpIGJyZWFrO1xuICAgICAgc3RtdHMucHVzaChwYXJzZVN0YXRlbWVu
dCgpKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0bXRzO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VT
dGF0ZW1lbnQoKSB7XG4gICAgaWYgKGF0KFRPSy5LVywgJ2lmJykpIHJldHVybiBwYXJzZUlmKCk7
XG4gICAgaWYgKGF0KFRPSy5LVywgJ2ZvcicpKSByZXR1cm4gcGFyc2VGb3IoKTtcbiAgICBpZiAo
YXQoVE9LLktXLCAnd2hpbGUnKSkgcmV0dXJuIHBhcnNlV2hpbGUoKTtcbiAgICBpZiAoYXQoVE9L
LktXLCAnZG8nKSkgcmV0dXJuIHBhcnNlRG9XaGlsZSgpO1xuICAgIGlmIChhdChUT0suS1csICdi
cmVhaycpKSB7IHBvcysrOyByZXR1cm4geyB0eXBlOiAnQnJlYWsnIH07IH1cbiAgICBpZiAoYXQo
VE9LLktXLCAndGFpbGNhbGwnKSkgeyBwb3MrKzsgY29uc3QgbmFtZSA9IGVhdChUT0suSUQpLnZh
bHVlOyBlYXQoVE9LLlBVTkMsICcoJyk7IGNvbnN0IGFyZ3MgPSBwYXJzZUFyZ3MoKTsgZWF0KFRP
Sy5QVU5DLCAnKScpOyByZXR1cm4geyB0eXBlOiAnVGFpbENhbGwnLCBuYW1lLCBhcmdzIH07IH1c
biAgICBpZiAoYXQoVE9LLktXLCAnY2FsbCcpKSB7IHBvcysrOyBjb25zdCBuYW1lID0gYXQoVE9L
LktXLCAncmV0dXJuJykgPyAocG9zKyssICdyZXR1cm4nKSA6IGVhdChUT0suSUQpLnZhbHVlOyBl
YXQoVE9LLlBVTkMsICcoJyk7IGNvbnN0IGFyZ3MgPSBwYXJzZUFyZ3MoKTsgZWF0KFRPSy5QVU5D
LCAnKScpOyByZXR1cm4geyB0eXBlOiAnQ2FsbCcsIG5hbWUsIGFyZ3MgfTsgfVxuXG4gICAgLy8g
YXNzaWdubWVudCBvciBleHByZXNzaW9uIHN0YXRlbWVudFxuICAgIC8vIGxvb2sgYWhlYWQ6IGlk
IDo9IC8gaWRbLi4uXSA6PSAvIGlkICs9IGV0Yy5cbiAgICBpZiAoY3VyKCkudHlwZSA9PT0gVE9L
LklEKSB7XG4gICAgICBjb25zdCBuYW1lID0gY3VyKCkudmFsdWU7XG4gICAgICAvLyBjaGVjayBm
b3IgYXJyYXkgc3RvcmU6IGlkW1xuICAgICAgaWYgKHRva2Vuc1twb3MgKyAxXSAmJiB0b2tlbnNb
cG9zICsgMV0udmFsdWUgPT09ICdbJykge1xuICAgICAgICBwb3MrKztcbiAgICAgICAgZWF0KFRP
Sy5QVU5DLCAnWycpO1xuICAgICAgICBjb25zdCBpbmRpY2VzID0gW3BhcnNlRXhwcigwKV07XG4g
ICAgICAgIHdoaWxlIChtYXliZShUT0suUFVOQywgJywnKSkgaW5kaWNlcy5wdXNoKHBhcnNlRXhw
cigwKSk7XG4gICAgICAgIGVhdChUT0suUFVOQywgJ10nKTtcbiAgICAgICAgaWYgKGF0KFRPSy5P
UCwgJzo9JykpIHtcbiAgICAgICAgICBwb3MrKztcbiAgICAgICAgICBjb25zdCB2YWx1ZSA9IHBh
cnNlRXhwcigwKTtcbiAgICAgICAgICByZXR1cm4geyB0eXBlOiAnQXJyYXlTdG9yZScsIG5hbWUs
IGluZGljZXMsIHZhbHVlIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gY29tcG91bmQgYXNzaWdu
bWVudCBvbiBhcnJheVxuICAgICAgICBjb25zdCBjb3AgPSBjdXIoKS52YWx1ZTtcbiAgICAgICAg
aWYgKGNvcCA9PT0gJys9JyB8fCBjb3AgPT09ICctPScgfHwgY29wID09PSAnKj0nIHx8IGNvcCA9
PT0gJy89Jykge1xuICAgICAgICAgIC8vIE5vdGU6IC89IGlzIGFtYmlndW91cyDigJQgYXMgYSBz
dGF0ZW1lbnQgc3RhcnQgYWZ0ZXIgYXJyYXkgYWNjZXNzLCBpdCdzIGNvbXBvdW5kIGFzc2lnblxu
ICAgICAgICAgIHBvcysrO1xuICAgICAgICAgIGNvbnN0IHJocyA9IHBhcnNlRXhwcigwKTtcbiAg
ICAgICAgICBjb25zdCBvcCA9IGNvcFswXTsgLy8gKywgLSwgKiwgL1xuICAgICAgICAgIHJldHVy
biB7IHR5cGU6ICdBcnJheVN0b3JlJywgbmFtZSwgaW5kaWNlcywgdmFsdWU6IHtcbiAgICAgICAg
ICAgIHR5cGU6ICdCaW5PcCcsIG9wLCBsZWZ0OiB7IHR5cGU6ICdBcnJheUFjY2VzcycsIG5hbWUs
IGluZGljZXMgfSwgcmlnaHQ6IHJoc1xuICAgICAgICAgIH19O1xuICAgICAgICB9XG4gICAgICAg
IHRocm93IG5ldyBTeW50YXhFcnJvcihgRXhwZWN0ZWQgOj0gb3IgY29tcG91bmQgYXNzaWdubWVu
dCBhZnRlciBhcnJheSBhY2Nlc3MgYXQgJHtjdXIoKS5saW5lfToke2N1cigpLmNvbH1gKTtcbiAg
ICAgIH1cbiAgICAgIGlmICh0b2tlbnNbcG9zICsgMV0gJiYgdG9rZW5zW3BvcyArIDFdLnZhbHVl
ID09PSAnOj0nKSB7XG4gICAgICAgIHBvcysrOyBwb3MrKztcbiAgICAgICAgY29uc3QgdmFsdWUg
PSBwYXJzZUV4cHIoMCk7XG4gICAgICAgIHJldHVybiB7IHR5cGU6ICdBc3NpZ24nLCBuYW1lLCB2
YWx1ZSB9O1xuICAgICAgfVxuICAgICAgLy8gY29tcG91bmQgYXNzaWdubWVudDogKz0sIC09LCAq
PVxuICAgICAgaWYgKHRva2Vuc1twb3MgKyAxXSAmJiAodG9rZW5zW3BvcyArIDFdLnZhbHVlID09
PSAnKz0nIHx8IHRva2Vuc1twb3MgKyAxXS52YWx1ZSA9PT0gJy09JyB8fCB0b2tlbnNbcG9zICsg
MV0udmFsdWUgPT09ICcqPScpKSB7XG4gICAgICAgIGNvbnN0IGNvcCA9IHRva2Vuc1twb3MgKyAx
XS52YWx1ZTtcbiAgICAgICAgY29uc3Qgb3AgPSBjb3BbMF07XG4gICAgICAgIHBvcysrOyBwb3Mr
KztcbiAgICAgICAgY29uc3QgcmhzID0gcGFyc2VFeHByKDApO1xuICAgICAgICByZXR1cm4geyB0
eXBlOiAnQXNzaWduJywgbmFtZSwgdmFsdWU6IHsgdHlwZTogJ0Jpbk9wJywgb3AsIGxlZnQ6IHsg
dHlwZTogJ0lkZW50JywgbmFtZSB9LCByaWdodDogcmhzIH0gfTtcbiAgICAgIH1cbiAgICAgIC8v
IC89IGNvbXBvdW5kIGFzc2lnbm1lbnQgKG9ubHkgd2hlbiBub3QgaW4gZXhwcmVzc2lvbiBjb250
ZXh0IOKAlCBzdGF0ZW1lbnQgbGV2ZWwpXG4gICAgICAvLyBEaXNhbWJpZ3VhdGlvbjogYXQgc3Rh
dGVtZW50IGxldmVsLCBpZCAvPSBleHByIGlzIGNvbXBvdW5kIGRpdmlkZS1hc3NpZ25cbiAgICAg
IC8vIEJ1dCAvPSBpcyBhbHNvIG5vdC1lcXVhbCBvcGVyYXRvci4gQXQgc3RhdGVtZW50IGxldmVs
OiBpZCAvPSBleHByIOKGkiBkaXZpZGUtYXNzaWduLlxuICAgICAgaWYgKHRva2Vuc1twb3MgKyAx
XSAmJiB0b2tlbnNbcG9zICsgMV0udmFsdWUgPT09ICcvPScpIHtcbiAgICAgICAgLy8gbG9vayBm
dXJ0aGVyOiBpZiB0aGlzIGlzIGEgc3RhbmRhbG9uZSBzdGF0ZW1lbnQgKGlkIC89IGV4cHIpLCB0
cmVhdCBhcyBjb21wb3VuZCBhc3NpZ25cbiAgICAgICAgY29uc3Qgb3AgPSAnLyc7XG4gICAgICAg
IHBvcysrOyBwb3MrKztcbiAgICAgICAgY29uc3QgcmhzID0gcGFyc2VFeHByKDApO1xuICAgICAg
ICByZXR1cm4geyB0eXBlOiAnQXNzaWduJywgbmFtZSwgdmFsdWU6IHsgdHlwZTogJ0Jpbk9wJywg
b3AsIGxlZnQ6IHsgdHlwZTogJ0lkZW50JywgbmFtZSB9LCByaWdodDogcmhzIH0gfTtcbiAgICAg
IH1cbiAgICB9XG5cbiAgICAvLyBleHByZXNzaW9uIHN0YXRlbWVudCAoZS5nLiwgYmFyZSBmdW5j
dGlvbiBjYWxsKVxuICAgIGNvbnN0IGV4cHIgPSBwYXJzZUV4cHIoMCk7XG4gICAgaWYgKGV4cHIu
dHlwZSA9PT0gJ0Z1bmNDYWxsJykgcmV0dXJuIHsgdHlwZTogJ0NhbGwnLCBuYW1lOiBleHByLm5h
bWUsIGFyZ3M6IGV4cHIuYXJncyB9O1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVW5leHBl
Y3RlZCBleHByZXNzaW9uIHN0YXRlbWVudCBhdCAke2N1cigpLmxpbmV9OiR7Y3VyKCkuY29sfWAp
O1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VJZihpc0Vsc2VJZikge1xuICAgIGVhdChUT0suS1cs
ICdpZicpO1xuICAgIGVhdChUT0suUFVOQywgJygnKTtcbiAgICBjb25zdCBjb25kID0gcGFyc2VF
eHByKDApO1xuICAgIGVhdChUT0suUFVOQywgJyknKTtcbiAgICBlYXQoVE9LLktXLCAndGhlbicp
O1xuICAgIGNvbnN0IGJvZHkgPSBbXTtcbiAgICB3aGlsZSAoIWF0KFRPSy5LVywgJ2Vsc2UnKSAm
JiAhYXQoVE9LLktXLCAnZW5kJykgJiYgIWF0KFRPSy5FT0YpKSB7XG4gICAgICBib2R5LnB1c2go
cGFyc2VTdGF0ZW1lbnQoKSk7XG4gICAgfVxuICAgIGxldCBlbHNlQm9keSA9IG51bGw7XG4gICAg
aWYgKG1heWJlKFRPSy5LVywgJ2Vsc2UnKSkge1xuICAgICAgaWYgKGF0KFRPSy5LVywgJ2lmJykp
IHtcbiAgICAgICAgLy8gZWxzZSBpZiBjaGFpbjogaW5uZXIgcGFyc2VJZiBoYW5kbGVzIGV2ZXJ5
dGhpbmcgaW5jbHVkaW5nIGVuZCBpZlxuICAgICAgICBlbHNlQm9keSA9IFtwYXJzZUlmKHRydWUp
XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsc2VCb2R5ID0gW107XG4gICAgICAgIHdoaWxl
ICghYXQoVE9LLktXLCAnZW5kJykgJiYgIWF0KFRPSy5FT0YpKSB7XG4gICAgICAgICAgZWxzZUJv
ZHkucHVzaChwYXJzZVN0YXRlbWVudCgpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAg
ICAvLyBPbmx5IGNvbnN1bWUgJ2VuZCBpZicgYXQgdGhlIG91dGVybW9zdCBpZiAobm90IGluIGVs
c2UtaWYgY2hhaW4pXG4gICAgaWYgKCFpc0Vsc2VJZiAmJiBhdChUT0suS1csICdlbmQnKSkge1xu
ICAgICAgcG9zKys7XG4gICAgICBtYXliZShUT0suS1csICdpZicpO1xuICAgIH1cbiAgICByZXR1
cm4geyB0eXBlOiAnSWYnLCBjb25kLCBib2R5LCBlbHNlQm9keSB9O1xuICB9XG5cbiAgZnVuY3Rp
b24gcGFyc2VGb3IoKSB7XG4gICAgZWF0KFRPSy5LVywgJ2ZvcicpO1xuICAgIGNvbnN0IHZhck5h
bWUgPSBlYXQoVE9LLklEKS52YWx1ZTtcbiAgICBlYXQoVE9LLk9QLCAnOj0nKTtcbiAgICBjb25z
dCBzdGFydCA9IHBhcnNlRXhwcigwKTtcbiAgICBlYXQoVE9LLlBVTkMsICcsJyk7XG4gICAgY29u
c3QgZW5kID0gcGFyc2VFeHByKDApO1xuICAgIGxldCBzdGVwID0gbnVsbDtcbiAgICBpZiAobWF5
YmUoVE9LLlBVTkMsICcsJykpIHN0ZXAgPSBwYXJzZUV4cHIoMCk7XG4gICAgY29uc3QgYm9keSA9
IFtdO1xuICAgIHdoaWxlICghYXQoVE9LLktXLCAnZW5kJykgJiYgIWF0KFRPSy5FT0YpKSBib2R5
LnB1c2gocGFyc2VTdGF0ZW1lbnQoKSk7XG4gICAgZWF0KFRPSy5LVywgJ2VuZCcpO1xuICAgIGVh
dChUT0suS1csICdmb3InKTtcbiAgICByZXR1cm4geyB0eXBlOiAnRm9yJywgdmFyTmFtZSwgc3Rh
cnQsIGVuZCwgc3RlcCwgYm9keSB9O1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VXaGlsZSgpIHtc
biAgICBlYXQoVE9LLktXLCAnd2hpbGUnKTtcbiAgICBlYXQoVE9LLlBVTkMsICcoJyk7XG4gICAg
Y29uc3QgY29uZCA9IHBhcnNlRXhwcigwKTtcbiAgICBlYXQoVE9LLlBVTkMsICcpJyk7XG4gICAg
Y29uc3QgYm9keSA9IFtdO1xuICAgIHdoaWxlICghYXQoVE9LLktXLCAnZW5kJykgJiYgIWF0KFRP
Sy5FT0YpKSBib2R5LnB1c2gocGFyc2VTdGF0ZW1lbnQoKSk7XG4gICAgZWF0KFRPSy5LVywgJ2Vu
ZCcpO1xuICAgIGVhdChUT0suS1csICd3aGlsZScpO1xuICAgIHJldHVybiB7IHR5cGU6ICdXaGls
ZScsIGNvbmQsIGJvZHkgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlRG9XaGlsZSgpIHtcbiAg
ICBlYXQoVE9LLktXLCAnZG8nKTtcbiAgICBjb25zdCBib2R5ID0gW107XG4gICAgd2hpbGUgKCFh
dChUT0suS1csICd3aGlsZScpICYmICFhdChUT0suRU9GKSkgYm9keS5wdXNoKHBhcnNlU3RhdGVt
ZW50KCkpO1xuICAgIGVhdChUT0suS1csICd3aGlsZScpO1xuICAgIGVhdChUT0suUFVOQywgJygn
KTtcbiAgICBjb25zdCBjb25kID0gcGFyc2VFeHByKDApO1xuICAgIGVhdChUT0suUFVOQywgJykn
KTtcbiAgICByZXR1cm4geyB0eXBlOiAnRG9XaGlsZScsIGNvbmQsIGJvZHkgfTtcbiAgfVxuXG4g
IGZ1bmN0aW9uIHBhcnNlQXJncygpIHtcbiAgICBjb25zdCBhcmdzID0gW107XG4gICAgaWYgKCFh
dChUT0suUFVOQywgJyknKSkge1xuICAgICAgYXJncy5wdXNoKHBhcnNlRXhwcigwKSk7XG4gICAg
ICB3aGlsZSAobWF5YmUoVE9LLlBVTkMsICcsJykpIGFyZ3MucHVzaChwYXJzZUV4cHIoMCkpO1xu
ICAgIH1cbiAgICByZXR1cm4gYXJncztcbiAgfVxuXG4gIC8vIOKUgOKUgCBQcmF0dCBleHByZXNz
aW9uIHBhcnNlciDilIDilIBcblxuICAvLyBCaW5kaW5nIHBvd2VycyAoaGlnaGVyID0gdGlnaHRl
cilcbiAgZnVuY3Rpb24gbGJwKHRvaykge1xuICAgIGlmICh0b2sudHlwZSA9PT0gVE9LLktXKSB7
XG4gICAgICBpZiAodG9rLnZhbHVlID09PSAnb3InKSByZXR1cm4gMjtcbiAgICAgIGlmICh0b2su
dmFsdWUgPT09ICdhbmQnKSByZXR1cm4gNDtcbiAgICAgIGlmICh0b2sudmFsdWUgPT09ICdtb2Qn
KSByZXR1cm4gMTg7XG4gICAgfVxuICAgIGlmICh0b2sudHlwZSA9PT0gVE9LLk9QKSB7XG4gICAg
ICBjb25zdCB2ID0gdG9rLnZhbHVlO1xuICAgICAgaWYgKHYgPT09ICc9PScgfHwgdiA9PT0gJy89
JyB8fCB2ID09PSAnPCcgfHwgdiA9PT0gJz4nIHx8IHYgPT09ICc8PScgfHwgdiA9PT0gJz49Jykg
cmV0dXJuIDY7XG4gICAgICBpZiAodiA9PT0gJ3wnKSByZXR1cm4gODtcbiAgICAgIGlmICh2ID09
PSAnXicpIHJldHVybiAxMDtcbiAgICAgIGlmICh2ID09PSAnJicpIHJldHVybiAxMjtcbiAgICAg
IGlmICh2ID09PSAnPDwnIHx8IHYgPT09ICc+PicpIHJldHVybiAxNDtcbiAgICAgIGlmICh2ID09
PSAnKycgfHwgdiA9PT0gJy0nKSByZXR1cm4gMTY7XG4gICAgICBpZiAodiA9PT0gJyonIHx8IHYg
PT09ICcvJykgcmV0dXJuIDE4O1xuICAgICAgaWYgKHYgPT09ICcqKicpIHJldHVybiAyMjsgLy8g
cmlnaHQtYXNzb2MgaGFuZGxlZCBieSB1c2luZyByYnAgPSAyMiAtIDFcbiAgICB9XG4gICAgcmV0
dXJuIDA7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUV4cHIobWluQnApIHtcbiAgICBsZXQgbGVm
dCA9IHBhcnNlUHJlZml4KCk7XG5cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgY29uc3QgdCA9
IGN1cigpO1xuICAgICAgY29uc3QgYnAgPSBsYnAodCk7XG4gICAgICBpZiAoYnAgPT09IDAgfHwg
YnAgPCBtaW5CcCkgYnJlYWs7XG5cbiAgICAgIC8vIGlmLWV4cHJlc3Npb24gKHRlcm5hcnkpOiBp
ZiAoY29uZCkgdGhlbiBhIGVsc2UgYlxuICAgICAgLy8gTm90IGhhbmRsZWQgaGVyZSDigJQgaXQn
cyBhIHByZWZpeCBmb3JtXG4gICAgICBpZiAodC50eXBlID09PSBUT0suS1cgJiYgdC52YWx1ZSA9
PT0gJ29yJykgeyBwb3MrKzsgbGVmdCA9IHsgdHlwZTogJ0Jpbk9wJywgb3A6ICdvcicsIGxlZnQs
IHJpZ2h0OiBwYXJzZUV4cHIoYnAgKyAxKSB9OyBjb250aW51ZTsgfVxuICAgICAgaWYgKHQudHlw
ZSA9PT0gVE9LLktXICYmIHQudmFsdWUgPT09ICdhbmQnKSB7IHBvcysrOyBsZWZ0ID0geyB0eXBl
OiAnQmluT3AnLCBvcDogJ2FuZCcsIGxlZnQsIHJpZ2h0OiBwYXJzZUV4cHIoYnAgKyAxKSB9OyBj
b250aW51ZTsgfVxuICAgICAgaWYgKHQudHlwZSA9PT0gVE9LLktXICYmIHQudmFsdWUgPT09ICdt
b2QnKSB7IHBvcysrOyBsZWZ0ID0geyB0eXBlOiAnQmluT3AnLCBvcDogJ21vZCcsIGxlZnQsIHJp
Z2h0OiBwYXJzZUV4cHIoYnAgKyAxKSB9OyBjb250aW51ZTsgfVxuXG4gICAgICBpZiAodC50eXBl
ID09PSBUT0suT1ApIHtcbiAgICAgICAgaWYgKHQudmFsdWUgPT09ICcqKicpIHtcbiAgICAgICAg
ICBwb3MrKztcbiAgICAgICAgICAvLyByaWdodC1hc3NvY2lhdGl2ZTogdXNlIGJwIGluc3RlYWQg
b2YgYnArMVxuICAgICAgICAgIGxlZnQgPSB7IHR5cGU6ICdCaW5PcCcsIG9wOiAnKionLCBsZWZ0
LCByaWdodDogcGFyc2VFeHByKGJwKSB9O1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9
XG4gICAgICAgIHBvcysrO1xuICAgICAgICBsZWZ0ID0geyB0eXBlOiAnQmluT3AnLCBvcDogdC52
YWx1ZSwgbGVmdCwgcmlnaHQ6IHBhcnNlRXhwcihicCArIDEpIH07XG4gICAgICAgIGNvbnRpbnVl
O1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBsZWZ0O1xuICB9XG5c
biAgZnVuY3Rpb24gcGFyc2VQcmVmaXgoKSB7XG4gICAgY29uc3QgdCA9IGN1cigpO1xuXG4gICAg
Ly8gcGFyZW50aGVzaXplZCBleHByZXNzaW9uXG4gICAgaWYgKHQudHlwZSA9PT0gVE9LLlBVTkMg
JiYgdC52YWx1ZSA9PT0gJygnKSB7XG4gICAgICBwb3MrKztcbiAgICAgIGNvbnN0IGV4cHIgPSBw
YXJzZUV4cHIoMCk7XG4gICAgICBlYXQoVE9LLlBVTkMsICcpJyk7XG4gICAgICByZXR1cm4gZXhw
cjtcbiAgICB9XG5cbiAgICAvLyBpZi1leHByZXNzaW9uICh0ZXJuYXJ5KTogaWYgKGNvbmQpIHRo
ZW4gYSBlbHNlIGJcbiAgICBpZiAodC50eXBlID09PSBUT0suS1cgJiYgdC52YWx1ZSA9PT0gJ2lm
Jykge1xuICAgICAgcG9zKys7XG4gICAgICBlYXQoVE9LLlBVTkMsICcoJyk7XG4gICAgICBjb25z
dCBjb25kID0gcGFyc2VFeHByKDApO1xuICAgICAgZWF0KFRPSy5QVU5DLCAnKScpO1xuICAgICAg
ZWF0KFRPSy5LVywgJ3RoZW4nKTtcbiAgICAgIGNvbnN0IHRoZW5FeHByID0gcGFyc2VFeHByKDAp
O1xuICAgICAgZWF0KFRPSy5LVywgJ2Vsc2UnKTtcbiAgICAgIGNvbnN0IGVsc2VFeHByID0gcGFy
c2VFeHByKDApO1xuICAgICAgcmV0dXJuIHsgdHlwZTogJ0lmRXhwcicsIGNvbmQsIHRoZW5FeHBy
LCBlbHNlRXhwciB9O1xuICAgIH1cblxuICAgIC8vIHVuYXJ5IG1pbnVzXG4gICAgaWYgKHQudHlw
ZSA9PT0gVE9LLk9QICYmIHQudmFsdWUgPT09ICctJykge1xuICAgICAgcG9zKys7XG4gICAgICBy
ZXR1cm4geyB0eXBlOiAnVW5hcnlPcCcsIG9wOiAnLScsIG9wZXJhbmQ6IHBhcnNlRXhwcigyMSkg
fTtcbiAgICB9XG4gICAgLy8gbm90XG4gICAgaWYgKHQudHlwZSA9PT0gVE9LLktXICYmIHQudmFs
dWUgPT09ICdub3QnKSB7XG4gICAgICBwb3MrKztcbiAgICAgIHJldHVybiB7IHR5cGU6ICdVbmFy
eU9wJywgb3A6ICdub3QnLCBvcGVyYW5kOiBwYXJzZUV4cHIoMjEpIH07XG4gICAgfVxuICAgIC8v
IGJpdHdpc2Ugbm90XG4gICAgaWYgKHQudHlwZSA9PT0gVE9LLk9QICYmIHQudmFsdWUgPT09ICd+
Jykge1xuICAgICAgcG9zKys7XG4gICAgICByZXR1cm4geyB0eXBlOiAnVW5hcnlPcCcsIG9wOiAn
ficsIG9wZXJhbmQ6IHBhcnNlRXhwcigyMSkgfTtcbiAgICB9XG4gICAgLy8gbnVtYmVyIGxpdGVy
YWxcbiAgICBpZiAodC50eXBlID09PSBUT0suTlVNKSB7XG4gICAgICBwb3MrKztcbiAgICAgIHJl
dHVybiB7IHR5cGU6ICdOdW1iZXJMaXQnLCB2YWx1ZTogdC52YWx1ZSwgaXNGbG9hdDogdC5pc0Zs
b2F0LCB0eXBlU3VmZml4OiB0LnR5cGVTdWZmaXggfTtcbiAgICB9XG4gICAgLy8gdHJ1ZS9mYWxz
ZVxuICAgIGlmICh0LnR5cGUgPT09IFRPSy5LVyAmJiAodC52YWx1ZSA9PT0gJ3RydWUnIHx8IHQu
dmFsdWUgPT09ICdmYWxzZScpKSB7XG4gICAgICBwb3MrKztcbiAgICAgIHJldHVybiB7IHR5cGU6
ICdOdW1iZXJMaXQnLCB2YWx1ZTogdC52YWx1ZSA9PT0gJ3RydWUnID8gJzEnIDogJzAnLCBpc0Zs
b2F0OiBmYWxzZSwgdHlwZVN1ZmZpeDogJ2kzMicgfTtcbiAgICB9XG4gICAgLy8gaWRlbnRpZmll
ciDigJQgbWF5IGJlIGZ1bmN0aW9uIGNhbGwsIGFycmF5IGFjY2Vzcywgb3IgcGxhaW4gdmFyaWFi
bGVcbiAgICBpZiAodC50eXBlID09PSBUT0suSUQpIHtcbiAgICAgIHBvcysrO1xuICAgICAgY29u
c3QgbmFtZSA9IHQudmFsdWU7XG4gICAgICAvLyBmdW5jdGlvbiBjYWxsOiBuYW1lKC4uLilcbiAg
ICAgIGlmIChhdChUT0suUFVOQywgJygnKSkge1xuICAgICAgICBwb3MrKztcbiAgICAgICAgY29u
c3QgYXJncyA9IHBhcnNlQXJncygpO1xuICAgICAgICBlYXQoVE9LLlBVTkMsICcpJyk7XG4gICAg
ICAgIHJldHVybiB7IHR5cGU6ICdGdW5jQ2FsbCcsIG5hbWUsIGFyZ3MgfTtcbiAgICAgIH1cbiAg
ICAgIC8vIGFycmF5IGFjY2VzczogbmFtZVsuLi5dXG4gICAgICBpZiAoYXQoVE9LLlBVTkMsICdb
JykpIHtcbiAgICAgICAgcG9zKys7XG4gICAgICAgIGNvbnN0IGluZGljZXMgPSBbcGFyc2VFeHBy
KDApXTtcbiAgICAgICAgd2hpbGUgKG1heWJlKFRPSy5QVU5DLCAnLCcpKSBpbmRpY2VzLnB1c2go
cGFyc2VFeHByKDApKTtcbiAgICAgICAgZWF0KFRPSy5QVU5DLCAnXScpO1xuICAgICAgICByZXR1
cm4geyB0eXBlOiAnQXJyYXlBY2Nlc3MnLCBuYW1lLCBpbmRpY2VzIH07XG4gICAgICB9XG4gICAg
ICByZXR1cm4geyB0eXBlOiAnSWRlbnQnLCBuYW1lIH07XG4gICAgfVxuICAgIC8vIHR5cGUgY29u
dmVyc2lvbiAvIHZlY3RvciBjb25zdHJ1Y3RvcjogaTMyKC4uLiksIGY2NCguLi4pLCBmNjR4Mihh
LCBiKSwgZXRjLlxuICAgIGlmICh0LnR5cGUgPT09IFRPSy5LVyAmJiBBVFJBX1RZUEVTLmhhcyh0
LnZhbHVlKSAmJiB0b2tlbnNbcG9zICsgMV0gJiYgdG9rZW5zW3BvcyArIDFdLnZhbHVlID09PSAn
KCcpIHtcbiAgICAgIHBvcysrOyAvLyBza2lwIHR5cGUga2V5d29yZFxuICAgICAgcG9zKys7IC8v
IHNraXAgKFxuICAgICAgY29uc3QgYXJncyA9IHBhcnNlQXJncygpO1xuICAgICAgZWF0KFRPSy5Q
VU5DLCAnKScpO1xuICAgICAgcmV0dXJuIHsgdHlwZTogJ0Z1bmNDYWxsJywgbmFtZTogdC52YWx1
ZSwgYXJncyB9O1xuICAgIH1cbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFVuZXhwZWN0ZWQg
dG9rZW4gXCIke3QudmFsdWV9XCIgYXQgJHt0LmxpbmV9OiR7dC5jb2x9YCk7XG4gIH1cblxuICBy
ZXR1cm4gcGFyc2VQcm9ncmFtKCk7XG59XG5cbi8vIC0tIG9wY29kZXMuanMgLS1cblxuLy8gT3Bj
b2RlcyDigJQgV2FzbSBvcGNvZGUgY29uc3RhbnRzLCB0eXBlIGNvZGVzLCBhbmQgU0lNRCBvcHNc
blxuLy8gV2FzbSBvcGNvZGVzXG5jb25zdCBPUF9VTlJFQUNIQUJMRSA9IDB4MDAsIE9QX05PUCA9
IDB4MDEsIE9QX0JMT0NLID0gMHgwMiwgT1BfTE9PUCA9IDB4MDMsXG4gIE9QX0lGID0gMHgwNCwg
T1BfRUxTRSA9IDB4MDUsIE9QX0VORCA9IDB4MGIsIE9QX0JSID0gMHgwYywgT1BfQlJfSUYgPSAw
eDBkLFxuICBPUF9SRVRVUk4gPSAweDBmLCBPUF9DQUxMID0gMHgxMCwgT1BfQ0FMTF9JTkRJUkVD
VCA9IDB4MTEsXG4gIE9QX1JFVFVSTl9DQUxMID0gMHgxMiwgT1BfUkVUVVJOX0NBTExfSU5ESVJF
Q1QgPSAweDEzLCBPUF9TRUxFQ1QgPSAweDFiLFxuICBPUF9MT0NBTF9HRVQgPSAweDIwLCBPUF9M
T0NBTF9TRVQgPSAweDIxLCBPUF9MT0NBTF9URUUgPSAweDIyLFxuICBPUF9HTE9CQUxfR0VUID0g
MHgyMywgT1BfR0xPQkFMX1NFVCA9IDB4MjQsXG4gIE9QX0kzMl9MT0FEID0gMHgyOCwgT1BfSTY0
X0xPQUQgPSAweDI5LCBPUF9GMzJfTE9BRCA9IDB4MmEsIE9QX0Y2NF9MT0FEID0gMHgyYixcbiAg
T1BfSTMyX1NUT1JFID0gMHgzNiwgT1BfSTY0X1NUT1JFID0gMHgzNywgT1BfRjMyX1NUT1JFID0g
MHgzOCwgT1BfRjY0X1NUT1JFID0gMHgzOSxcbiAgT1BfTUVNT1JZX1NJWkUgPSAweDNmLCBPUF9N
RU1PUllfR1JPVyA9IDB4NDAsXG4gIE9QX0kzMl9DT05TVCA9IDB4NDEsIE9QX0k2NF9DT05TVCA9
IDB4NDIsIE9QX0YzMl9DT05TVCA9IDB4NDMsIE9QX0Y2NF9DT05TVCA9IDB4NDQsXG4gIE9QX0kz
Ml9FUVogPSAweDQ1LCBPUF9JMzJfRVEgPSAweDQ2LCBPUF9JMzJfTkUgPSAweDQ3LFxuICBPUF9J
MzJfTFRfUyA9IDB4NDgsIE9QX0kzMl9MVF9VID0gMHg0OSwgT1BfSTMyX0dUX1MgPSAweDRhLCBP
UF9JMzJfR1RfVSA9IDB4NGIsXG4gIE9QX0kzMl9MRV9TID0gMHg0YywgT1BfSTMyX0xFX1UgPSAw
eDRkLCBPUF9JMzJfR0VfUyA9IDB4NGUsIE9QX0kzMl9HRV9VID0gMHg0ZixcbiAgT1BfSTY0X0VR
WiA9IDB4NTAsIE9QX0k2NF9FUSA9IDB4NTEsIE9QX0k2NF9ORSA9IDB4NTIsXG4gIE9QX0k2NF9M
VF9TID0gMHg1MywgT1BfSTY0X0xUX1UgPSAweDU0LCBPUF9JNjRfR1RfUyA9IDB4NTUsIE9QX0k2
NF9HVF9VID0gMHg1NixcbiAgT1BfSTY0X0xFX1MgPSAweDU3LCBPUF9JNjRfTEVfVSA9IDB4NTgs
IE9QX0k2NF9HRV9TID0gMHg1OSwgT1BfSTY0X0dFX1UgPSAweDVhLFxuICBPUF9GMzJfRVEgPSAw
eDViLCBPUF9GMzJfTkUgPSAweDVjLCBPUF9GMzJfTFQgPSAweDVkLCBPUF9GMzJfR1QgPSAweDVl
LCBPUF9GMzJfTEUgPSAweDVmLCBPUF9GMzJfR0UgPSAweDYwLFxuICBPUF9GNjRfRVEgPSAweDYx
LCBPUF9GNjRfTkUgPSAweDYyLCBPUF9GNjRfTFQgPSAweDYzLCBPUF9GNjRfR1QgPSAweDY0LCBP
UF9GNjRfTEUgPSAweDY1LCBPUF9GNjRfR0UgPSAweDY2LFxuICBPUF9JMzJfQ0xaID0gMHg2Nywg
T1BfSTMyX0NUWiA9IDB4NjgsIE9QX0kzMl9QT1BDTlQgPSAweDY5LFxuICBPUF9JMzJfQUREID0g
MHg2YSwgT1BfSTMyX1NVQiA9IDB4NmIsIE9QX0kzMl9NVUwgPSAweDZjLFxuICBPUF9JMzJfRElW
X1MgPSAweDZkLCBPUF9JMzJfRElWX1UgPSAweDZlLCBPUF9JMzJfUkVNX1MgPSAweDZmLCBPUF9J
MzJfUkVNX1UgPSAweDcwLFxuICBPUF9JMzJfQU5EID0gMHg3MSwgT1BfSTMyX09SID0gMHg3Miwg
T1BfSTMyX1hPUiA9IDB4NzMsXG4gIE9QX0kzMl9TSEwgPSAweDc0LCBPUF9JMzJfU0hSX1MgPSAw
eDc1LCBPUF9JMzJfU0hSX1UgPSAweDc2LFxuICBPUF9JMzJfUk9UTCA9IDB4NzcsIE9QX0kzMl9S
T1RSID0gMHg3OCxcbiAgT1BfSTY0X0NMWiA9IDB4NzksIE9QX0k2NF9DVFogPSAweDdhLCBPUF9J
NjRfUE9QQ05UID0gMHg3YixcbiAgT1BfSTY0X0FERCA9IDB4N2MsIE9QX0k2NF9TVUIgPSAweDdk
LCBPUF9JNjRfTVVMID0gMHg3ZSxcbiAgT1BfSTY0X0RJVl9TID0gMHg3ZiwgT1BfSTY0X0RJVl9V
ID0gMHg4MCwgT1BfSTY0X1JFTV9TID0gMHg4MSwgT1BfSTY0X1JFTV9VID0gMHg4MixcbiAgT1Bf
STY0X0FORCA9IDB4ODMsIE9QX0k2NF9PUiA9IDB4ODQsIE9QX0k2NF9YT1IgPSAweDg1LFxuICBP
UF9JNjRfU0hMID0gMHg4NiwgT1BfSTY0X1NIUl9TID0gMHg4NywgT1BfSTY0X1NIUl9VID0gMHg4
OCxcbiAgT1BfSTY0X1JPVEwgPSAweDg5LCBPUF9JNjRfUk9UUiA9IDB4OGEsXG4gIE9QX0YzMl9B
QlMgPSAweDhiLCBPUF9GMzJfTkVHID0gMHg4YywgT1BfRjMyX0NFSUwgPSAweDhkLCBPUF9GMzJf
RkxPT1IgPSAweDhlLFxuICBPUF9GMzJfVFJVTkMgPSAweDhmLCBPUF9GMzJfTkVBUkVTVCA9IDB4
OTAsIE9QX0YzMl9TUVJUID0gMHg5MSxcbiAgT1BfRjMyX0FERCA9IDB4OTIsIE9QX0YzMl9TVUIg
PSAweDkzLCBPUF9GMzJfTVVMID0gMHg5NCwgT1BfRjMyX0RJViA9IDB4OTUsXG4gIE9QX0YzMl9N
SU4gPSAweDk2LCBPUF9GMzJfTUFYID0gMHg5NywgT1BfRjMyX0NPUFlTSUdOID0gMHg5OCxcbiAg
T1BfRjY0X0FCUyA9IDB4OTksIE9QX0Y2NF9ORUcgPSAweDlhLCBPUF9GNjRfQ0VJTCA9IDB4OWIs
IE9QX0Y2NF9GTE9PUiA9IDB4OWMsXG4gIE9QX0Y2NF9UUlVOQyA9IDB4OWQsIE9QX0Y2NF9ORUFS
RVNUID0gMHg5ZSwgT1BfRjY0X1NRUlQgPSAweDlmLFxuICBPUF9GNjRfQUREID0gMHhhMCwgT1Bf
RjY0X1NVQiA9IDB4YTEsIE9QX0Y2NF9NVUwgPSAweGEyLCBPUF9GNjRfRElWID0gMHhhMyxcbiAg
T1BfRjY0X01JTiA9IDB4YTQsIE9QX0Y2NF9NQVggPSAweGE1LCBPUF9GNjRfQ09QWVNJR04gPSAw
eGE2LFxuICBPUF9JMzJfV1JBUF9JNjQgPSAweGE3LFxuICBPUF9JMzJfVFJVTkNfRjMyX1MgPSAw
eGE4LCBPUF9JMzJfVFJVTkNfRjY0X1MgPSAweGFhLFxuICBPUF9JNjRfRVhURU5EX0kzMl9TID0g
MHhhYywgT1BfSTY0X0VYVEVORF9JMzJfVSA9IDB4YWQsXG4gIE9QX0k2NF9UUlVOQ19GMzJfUyA9
IDB4YWUsIE9QX0k2NF9UUlVOQ19GNjRfUyA9IDB4YjAsXG4gIE9QX0YzMl9DT05WRVJUX0kzMl9T
ID0gMHhiMiwgT1BfRjMyX0NPTlZFUlRfSTY0X1MgPSAweGI0LFxuICBPUF9GMzJfREVNT1RFX0Y2
NCA9IDB4YjYsXG4gIE9QX0Y2NF9DT05WRVJUX0kzMl9TID0gMHhiNywgT1BfRjY0X0NPTlZFUlRf
STY0X1MgPSAweGI5LFxuICBPUF9GNjRfUFJPTU9URV9GMzIgPSAweGJiLFxuICBPUF9JMzJfUkVJ
TlRFUlBSRVRfRjMyID0gMHhiYywgT1BfSTY0X1JFSU5URVJQUkVUX0Y2NCA9IDB4YmQsXG4gIE9Q
X0YzMl9SRUlOVEVSUFJFVF9JMzIgPSAweGJlLCBPUF9GNjRfUkVJTlRFUlBSRVRfSTY0ID0gMHhi
ZixcbiAgT1BfSTMyX0VYVEVORDhfUyA9IDB4YzAsIE9QX0kzMl9FWFRFTkQxNl9TID0gMHhjMSxc
biAgT1BfSTY0X0VYVEVORDhfUyA9IDB4YzIsIE9QX0k2NF9FWFRFTkQxNl9TID0gMHhjMywgT1Bf
STY0X0VYVEVORDMyX1MgPSAweGM0O1xuXG4vLyBXYXNtIEZDIHByZWZpeCBvcGNvZGVzICgweEZD
IHByZWZpeClcbmNvbnN0IE9QX0ZDX1BSRUZJWCA9IDB4ZmM7XG5jb25zdCBPUF9JMzJfVFJVTkNf
U0FUX0YzMl9TID0gMCwgT1BfSTMyX1RSVU5DX1NBVF9GMzJfVSA9IDEsXG4gIE9QX0kzMl9UUlVO
Q19TQVRfRjY0X1MgPSAyLCBPUF9JMzJfVFJVTkNfU0FUX0Y2NF9VID0gMyxcbiAgT1BfSTY0X1RS
VU5DX1NBVF9GMzJfUyA9IDQsIE9QX0k2NF9UUlVOQ19TQVRfRjMyX1UgPSA1LFxuICBPUF9JNjRf
VFJVTkNfU0FUX0Y2NF9TID0gNiwgT1BfSTY0X1RSVU5DX1NBVF9GNjRfVSA9IDc7XG5cbi8vIFdh
c20gdHlwZSBjb2Rlc1xuY29uc3QgV0FTTV9JMzIgPSAweDdmLCBXQVNNX0k2NCA9IDB4N2UsIFdB
U01fRjMyID0gMHg3ZCwgV0FTTV9GNjQgPSAweDdjO1xuY29uc3QgV0FTTV9WMTI4ID0gMHg3Yjtc
bmNvbnN0IFdBU01fVk9JRCA9IDB4NDA7XG5cbi8vIFNJTUQgcHJlZml4XG5jb25zdCBPUF9TSU1E
X1BSRUZJWCA9IDB4ZmQ7XG5cbi8vIFNJTUQgb3Bjb2RlIHRhYmxlXG5jb25zdCBTSU1EX09QUyA9
IHtcbiAgLy8gc3BsYXRcbiAgJ2kzMng0LnNwbGF0JzogMHgxMSwgJ2k2NHgyLnNwbGF0JzogMHgx
MiwgJ2YzMng0LnNwbGF0JzogMHgxMywgJ2Y2NHgyLnNwbGF0JzogMHgxNCxcbiAgLy8gZXh0cmFj
dF9sYW5lXG4gICdpMzJ4NC5leHRyYWN0X2xhbmUnOiAweDFiLCAnaTY0eDIuZXh0cmFjdF9sYW5l
JzogMHgxZCwgJ2YzMng0LmV4dHJhY3RfbGFuZSc6IDB4MWYsICdmNjR4Mi5leHRyYWN0X2xhbmUn
OiAweDIxLFxuICAvLyByZXBsYWNlX2xhbmVcbiAgJ2kzMng0LnJlcGxhY2VfbGFuZSc6IDB4MWMs
ICdpNjR4Mi5yZXBsYWNlX2xhbmUnOiAweDFlLCAnZjMyeDQucmVwbGFjZV9sYW5lJzogMHgyMCwg
J2Y2NHgyLnJlcGxhY2VfbGFuZSc6IDB4MjIsXG4gIC8vIGFkZFxuICAnaTMyeDQuYWRkJzogMHhh
ZSwgJ2k2NHgyLmFkZCc6IDB4Y2UsICdmMzJ4NC5hZGQnOiAweGU0LCAnZjY0eDIuYWRkJzogMHhm
MCxcbiAgLy8gc3ViXG4gICdpMzJ4NC5zdWInOiAweGIxLCAnaTY0eDIuc3ViJzogMHhkMSwgJ2Yz
Mng0LnN1Yic6IDB4ZTUsICdmNjR4Mi5zdWInOiAweGYxLFxuICAvLyBtdWxcbiAgJ2kzMng0Lm11
bCc6IDB4YjUsICdpNjR4Mi5tdWwnOiAweGQ1LCAnZjMyeDQubXVsJzogMHhlNiwgJ2Y2NHgyLm11
bCc6IDB4ZjIsXG4gIC8vIGRpdiAoZmxvYXQgb25seSlcbiAgJ2YzMng0LmRpdic6IDB4ZTcsICdm
NjR4Mi5kaXYnOiAweGYzLFxuICAvLyBuZWdcbiAgJ2kzMng0Lm5lZyc6IDB4YTEsICdpNjR4Mi5u
ZWcnOiAweGMxLCAnZjMyeDQubmVnJzogMHhlMSwgJ2Y2NHgyLm5lZyc6IDB4ZWQsXG4gIC8vIGFi
cyAoZmxvYXQgb25seSlcbiAgJ2YzMng0LmFicyc6IDB4ZTAsICdmNjR4Mi5hYnMnOiAweGVjLFxu
ICAvLyBzcXJ0IChmbG9hdCBvbmx5KVxuICAnZjMyeDQuc3FydCc6IDB4ZTMsICdmNjR4Mi5zcXJ0
JzogMHhlZixcbiAgLy8gbWluL21heCAoZmxvYXQgb25seSlcbiAgJ2YzMng0Lm1pbic6IDB4ZTgs
ICdmNjR4Mi5taW4nOiAweGY0LCAnZjMyeDQubWF4JzogMHhlOSwgJ2Y2NHgyLm1heCc6IDB4ZjUs
XG4gIC8vIGNvbXBhcmlzb24g4oCUIGVxXG4gICdpMzJ4NC5lcSc6IDB4MzcsICdpNjR4Mi5lcSc6
IDB4ZDYsICdmMzJ4NC5lcSc6IDB4NDEsICdmNjR4Mi5lcSc6IDB4NDcsXG4gIC8vIG5lXG4gICdp
MzJ4NC5uZSc6IDB4MzgsICdmMzJ4NC5uZSc6IDB4NDIsICdmNjR4Mi5uZSc6IDB4NDgsXG4gIC8v
IGx0XG4gICdpMzJ4NC5sdF9zJzogMHgzOSwgJ2k2NHgyLmx0X3MnOiAweGQ3LCAnZjMyeDQubHQn
OiAweDQzLCAnZjY0eDIubHQnOiAweDQ5LFxuICAvLyBndFxuICAnaTMyeDQuZ3Rfcyc6IDB4M2Is
ICdpNjR4Mi5ndF9zJzogMHhkOSwgJ2YzMng0Lmd0JzogMHg0NCwgJ2Y2NHgyLmd0JzogMHg0YSxc
biAgLy8gbGVcbiAgJ2kzMng0LmxlX3MnOiAweDNkLCAnaTY0eDIubGVfcyc6IDB4ZGIsICdmMzJ4
NC5sZSc6IDB4NDUsICdmNjR4Mi5sZSc6IDB4NGIsXG4gIC8vIGdlXG4gICdpMzJ4NC5nZV9zJzog
MHgzZiwgJ2k2NHgyLmdlX3MnOiAweGRkLCAnZjMyeDQuZ2UnOiAweDQ2LCAnZjY0eDIuZ2UnOiAw
eDRjLFxuICAvLyB2MTI4IGJpdHdpc2VcbiAgJ3YxMjgubm90JzogMHg0ZCwgJ3YxMjguYW5kJzog
MHg0ZSwgJ3YxMjgub3InOiAweDUwLCAndjEyOC54b3InOiAweDUxLFxuICAvLyB2MTI4IG1lbW9y
eVxuICAndjEyOC5sb2FkJzogMHgwMCwgJ3YxMjguc3RvcmUnOiAweDBiLCAndjEyOC5jb25zdCc6
IDB4MGMsXG59O1xuXG5mdW5jdGlvbiB3YXNtVHlwZSh0KSB7XG4gIGlmICh0ID09PSAnaTMyJykg
cmV0dXJuIFdBU01fSTMyO1xuICBpZiAodCA9PT0gJ2k2NCcpIHJldHVybiBXQVNNX0k2NDtcbiAg
aWYgKHQgPT09ICdmMzInKSByZXR1cm4gV0FTTV9GMzI7XG4gIGlmICh0ID09PSAnZjY0JykgcmV0
dXJuIFdBU01fRjY0O1xuICBpZiAoaXNWZWN0b3IodCkpIHJldHVybiBXQVNNX1YxMjg7XG4gIHRo
cm93IG5ldyBFcnJvcignVW5rbm93biB0eXBlOiAnICsgdCk7XG59XG5cbmZ1bmN0aW9uIHR5cGVT
aXplKHQpIHtcbiAgaWYgKHQgPT09ICdpMzInIHx8IHQgPT09ICdmMzInKSByZXR1cm4gNDtcbiAg
aWYgKHQgPT09ICdpNjQnIHx8IHQgPT09ICdmNjQnKSByZXR1cm4gODtcbiAgaWYgKGlzVmVjdG9y
KHQpKSByZXR1cm4gMTY7XG4gIHRocm93IG5ldyBFcnJvcignVW5rbm93biB0eXBlOiAnICsgdCk7
XG59XG5cbmZ1bmN0aW9uIGlzVmVjdG9yKHQpIHsgcmV0dXJuIHQgPT09ICdmNjR4MicgfHwgdCA9
PT0gJ2YzMng0JyB8fCB0ID09PSAnaTMyeDQnIHx8IHQgPT09ICdpNjR4Mic7IH1cbmZ1bmN0aW9u
IHZlY3RvclNjYWxhclR5cGUodCkge1xuICBpZiAodCA9PT0gJ2Y2NHgyJykgcmV0dXJuICdmNjQn
O1xuICBpZiAodCA9PT0gJ2YzMng0JykgcmV0dXJuICdmMzInO1xuICBpZiAodCA9PT0gJ2kzMng0
JykgcmV0dXJuICdpMzInO1xuICBpZiAodCA9PT0gJ2k2NHgyJykgcmV0dXJuICdpNjQnO1xuICBy
ZXR1cm4gbnVsbDtcbn1cblxuLy8gLS0gYnl0ZXdyaXRlci5qcyAtLVxuXG4vLyBCeXRlV3JpdGVy
IOKAlCBiaW5hcnkgYnVpbGRlciBmb3IgV2FzbSBvdXRwdXRcblxuY2xhc3MgQnl0ZVdyaXRlciB7
XG4gIGNvbnN0cnVjdG9yKCkgeyB0aGlzLmJ1ZiA9IFtdOyB9XG4gIGJ5dGUoYikgeyB0aGlzLmJ1
Zi5wdXNoKGIgJiAweGZmKTsgfVxuICBieXRlcyhhcnIpIHsgZm9yIChjb25zdCBiIG9mIGFycikg
dGhpcy5ieXRlKGIpOyB9XG4gIHUzMih2KSB7IC8vIExFQjEyOCB1bnNpZ25lZFxuICAgIGRvIHsg
bGV0IGIgPSB2ICYgMHg3ZjsgdiA+Pj49IDc7IGlmICh2KSBiIHw9IDB4ODA7IHRoaXMuYnl0ZShi
KTsgfSB3aGlsZSAodik7XG4gIH1cbiAgczMyKHYpIHsgLy8gTEVCMTI4IHNpZ25lZFxuICAgIGxl
dCBtb3JlID0gdHJ1ZTtcbiAgICB3aGlsZSAobW9yZSkge1xuICAgICAgbGV0IGIgPSB2ICYgMHg3
ZjsgdiA+Pj0gNztcbiAgICAgIGlmICgodiA9PT0gMCAmJiAhKGIgJiAweDQwKSkgfHwgKHYgPT09
IC0xICYmIChiICYgMHg0MCkpKSBtb3JlID0gZmFsc2U7IGVsc2UgYiB8PSAweDgwO1xuICAgICAg
dGhpcy5ieXRlKGIpO1xuICAgIH1cbiAgfVxuICBzNjQodikgeyAvLyBMRUIxMjggc2lnbmVkIGZv
ciBpNjQgKEJpZ0ludClcbiAgICB2ID0gQmlnSW50KHYpO1xuICAgIGxldCBtb3JlID0gdHJ1ZTtc
biAgICB3aGlsZSAobW9yZSkge1xuICAgICAgbGV0IGIgPSBOdW1iZXIodiAmIDB4N2ZuKTsgdiA+
Pj0gN247XG4gICAgICBpZiAoKHYgPT09IDBuICYmICEoYiAmIDB4NDApKSB8fCAodiA9PT0gLTFu
ICYmIChiICYgMHg0MCkpKSBtb3JlID0gZmFsc2U7IGVsc2UgYiB8PSAweDgwO1xuICAgICAgdGhp
cy5ieXRlKGIpO1xuICAgIH1cbiAgfVxuICBmMzIodikgeyBjb25zdCBidWYgPSBuZXcgQXJyYXlC
dWZmZXIoNCk7IG5ldyBEYXRhVmlldyhidWYpLnNldEZsb2F0MzIoMCwgdiwgdHJ1ZSk7IHRoaXMu
Ynl0ZXMobmV3IFVpbnQ4QXJyYXkoYnVmKSk7IH1cbiAgZjY0KHYpIHsgY29uc3QgYnVmID0gbmV3
IEFycmF5QnVmZmVyKDgpOyBuZXcgRGF0YVZpZXcoYnVmKS5zZXRGbG9hdDY0KDAsIHYsIHRydWUp
OyB0aGlzLmJ5dGVzKG5ldyBVaW50OEFycmF5KGJ1ZikpOyB9XG4gIHN0cihzKSB7IGNvbnN0IGVu
YyA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShzKTsgdGhpcy51MzIoZW5jLmxlbmd0aCk7IHRo
aXMuYnl0ZXMoZW5jKTsgfVxuICBzZWN0aW9uKGlkLCBjb250ZW50Rm4pIHtcbiAgICBjb25zdCBp
bm5lciA9IG5ldyBCeXRlV3JpdGVyKCk7XG4gICAgY29udGVudEZuKGlubmVyKTtcbiAgICB0aGlz
LmJ5dGUoaWQpO1xuICAgIHRoaXMudTMyKGlubmVyLmJ1Zi5sZW5ndGgpO1xuICAgIHRoaXMuYnl0
ZXMoaW5uZXIuYnVmKTtcbiAgfVxuICB0b1VpbnQ4QXJyYXkoKSB7IHJldHVybiBuZXcgVWludDhB
cnJheSh0aGlzLmJ1Zik7IH1cbn1cblxuLy8gLS0gY29kZWdlbi5qcyAtLVxuXG4vLyBDb2RlZ2Vu
IOKAlCBBU1Qg4oaSIFdhc20gYmluYXJ5XG5cblxuXG5cbmZ1bmN0aW9uIGZsYXR0ZW5JbXBvcnRz
KG9iaiwgcHJlZml4KSB7XG4gIGNvbnN0IGZsYXQgPSB7fTtcbiAgZm9yIChjb25zdCBbaywgdl0g
b2YgT2JqZWN0LmVudHJpZXMob2JqKSkge1xuICAgIGlmICghcHJlZml4ICYmIChrID09PSAnX19t
ZW1vcnknIHx8IGsgPT09ICdtZW1vcnknIHx8IGsgPT09ICdfX3RhYmxlJykpIGNvbnRpbnVlO1xu
ICAgIGNvbnN0IGtleSA9IHByZWZpeCA/IHByZWZpeCArICcuJyArIGsgOiBrO1xuICAgIGlmICh0
eXBlb2YgdiA9PT0gJ2Z1bmN0aW9uJykgZmxhdFtrZXldID0gdjtcbiAgICBlbHNlIGlmICh2ICYm
IHR5cGVvZiB2ID09PSAnb2JqZWN0JyAmJiAhQXJyYXlCdWZmZXIuaXNWaWV3KHYpKSBPYmplY3Qu
YXNzaWduKGZsYXQsIGZsYXR0ZW5JbXBvcnRzKHYsIGtleSkpO1xuICB9XG4gIHJldHVybiBmbGF0
O1xufVxuXG5mdW5jdGlvbiBjb2RlZ2VuKGFzdCwgaW50ZXJwVmFsdWVzLCB1c2VySW1wb3J0cykg
e1xuICBjb25zdCB3ID0gbmV3IEJ5dGVXcml0ZXIoKTtcblxuICAvLyDilIDilIAgQ29sbGVjdCBp
bmZvIOKUgOKUgFxuICBjb25zdCBnbG9iYWxzID0gW107ICAgIC8vIHsgbmFtZSwgdnR5cGUsIG11
dGFibGUsIGluaXQgfVxuICBjb25zdCBmdW5jdGlvbnMgPSBbXTsgIC8vIEFTVCBub2Rlc1xuICBj
b25zdCBpbXBvcnRzID0gW107ICAgIC8vIHsgbmFtZSwgbW9kdWxlTmFtZSwgcGFyYW1zLCByZXRU
eXBlLCBpbnRlcnBJZHggfVxuICBjb25zdCBsb2NhbEZ1bmNOYW1lcyA9IG5ldyBTZXQoKTtcblxu
ICBmb3IgKGNvbnN0IG5vZGUgb2YgYXN0LmJvZHkpIHtcbiAgICBpZiAobm9kZS50eXBlID09PSAn
Q29uc3REZWNsJykgZ2xvYmFscy5wdXNoKHsgbmFtZTogbm9kZS5uYW1lLCB2dHlwZTogbm9kZS52
dHlwZSwgbXV0YWJsZTogZmFsc2UsIGluaXQ6IG5vZGUuaW5pdCB9KTtcbiAgICBlbHNlIGlmIChu
b2RlLnR5cGUgPT09ICdWYXJEZWNsJykge1xuICAgICAgY29uc3QgZyA9IHsgbmFtZTogbm9kZS5u
YW1lLCB2dHlwZTogbm9kZS52dHlwZSwgbXV0YWJsZTogdHJ1ZSwgaW5pdDogbm9kZS5pbml0IH07
XG4gICAgICBpZiAobm9kZS5mdW5jU2lnKSBnLmZ1bmNTaWcgPSBub2RlLmZ1bmNTaWc7XG4gICAg
ICBnbG9iYWxzLnB1c2goZyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gJ0Z1
bmN0aW9uJyB8fCBub2RlLnR5cGUgPT09ICdTdWJyb3V0aW5lJykgeyBmdW5jdGlvbnMucHVzaChu
b2RlKTsgbG9jYWxGdW5jTmFtZXMuYWRkKG5vZGUubmFtZSk7IH1cbiAgICBlbHNlIGlmIChub2Rl
LnR5cGUgPT09ICdJbXBvcnREZWNsJykgaW1wb3J0cy5wdXNoKG5vZGUpO1xuICB9XG5cbiAgLy8g
TWF0aCBidWlsdGlucyB0aGF0IG5lZWQgaW1wb3J0aW5nXG4gIGNvbnN0IE1BVEhfQlVJTFRJTlMg
PSB7IHNpbjogMSwgY29zOiAxLCBsbjogMSwgZXhwOiAxLCBwb3c6IDIsIGF0YW4yOiAyIH07XG4g
IC8vIE5hdGl2ZSBidWlsdGlucyAobm8gaW1wb3J0IG5lZWRlZCkg4oCUIHJlc29sdmVkIHBlci10
eXBlIGluIGVtaXRGdW5jQ2FsbFxuICBjb25zdCBOQVRJVkVfQlVJTFRJTlMgPSBuZXcgU2V0KFtc
biAgICAnc3FydCcsJ2FicycsJ2Zsb29yJywnY2VpbCcsJ3RydW5jJywnbmVhcmVzdCcsJ2NvcHlz
aWduJyxcbiAgICAnbWluJywnbWF4Jywnc2VsZWN0JyxcbiAgICAnY2x6JywnY3R6JywncG9wY250
Jywncm90bCcsJ3JvdHInLFxuICAgICdtZW1vcnlfc2l6ZScsJ21lbW9yeV9ncm93JywnbWVtb3J5
X2NvcHknLCdtZW1vcnlfZmlsbCcsXG4gICAgJ2kzMicsJ2k2NCcsJ2YzMicsJ2Y2NCcsIC8vIHR5
cGUgY29udmVyc2lvbnNcbiAgICAnZjY0eDInLCdmMzJ4NCcsJ2kzMng0JywnaTY0eDInLCAvLyB2
ZWN0b3IgY29uc3RydWN0b3JzXG4gIF0pO1xuXG4gIC8vIFNjYW4gYWxsIGZ1bmN0aW9uIGJvZGll
cyBmb3IgdW5yZXNvbHZlZCBjYWxsc1xuICBjb25zdCB1c2VkQ2FsbHMgPSBuZXcgU2V0KCk7XG4g
IGZ1bmN0aW9uIHNjYW5DYWxscyhzdG10cykge1xuICAgIGZvciAoY29uc3QgcyBvZiBzdG10cykg
e1xuICAgICAgaWYgKHMudHlwZSA9PT0gJ0NhbGwnIHx8IHMudHlwZSA9PT0gJ0Z1bmNDYWxsJykg
dXNlZENhbGxzLmFkZChzLm5hbWUpO1xuICAgICAgaWYgKHMudHlwZSA9PT0gJ0lmJykgeyBzY2Fu
Q2FsbHMocy5ib2R5KTsgaWYgKHMuZWxzZUJvZHkpIHNjYW5DYWxscyhzLmVsc2VCb2R5KTsgfVxu
ICAgICAgaWYgKHMudHlwZSA9PT0gJ0ZvcicgfHwgcy50eXBlID09PSAnV2hpbGUnIHx8IHMudHlw
ZSA9PT0gJ0RvV2hpbGUnKSBzY2FuQ2FsbHMocy5ib2R5KTtcbiAgICAgIC8vIHNjYW4gZXhwcmVz
c2lvbnNcbiAgICAgIHNjYW5FeHByQ2FsbHMocyk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHNj
YW5FeHByQ2FsbHMobm9kZSkge1xuICAgIGlmICghbm9kZSB8fCB0eXBlb2Ygbm9kZSAhPT0gJ29i
amVjdCcpIHJldHVybjtcbiAgICBpZiAobm9kZS50eXBlID09PSAnRnVuY0NhbGwnKSB1c2VkQ2Fs
bHMuYWRkKG5vZGUubmFtZSk7XG4gICAgLy8gKiogb3BlcmF0b3IgbWF5IG5lZWQgcG93IGltcG9y
dCAoZm9yIG5vbi1zcXJ0LCBub24tc21hbGwtaW50IGV4cG9uZW50cylcbiAgICBpZiAobm9kZS50
eXBlID09PSAnQmluT3AnICYmIG5vZGUub3AgPT09ICcqKicpIHVzZWRDYWxscy5hZGQoJ3Bvdycp
O1xuICAgIGZvciAoY29uc3QgayBvZiBPYmplY3Qua2V5cyhub2RlKSkge1xuICAgICAgY29uc3Qg
diA9IG5vZGVba107XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2KSkgdi5mb3JFYWNoKHNjYW5F
eHByQ2FsbHMpO1xuICAgICAgZWxzZSBpZiAodiAmJiB0eXBlb2YgdiA9PT0gJ29iamVjdCcgJiYg
di50eXBlKSBzY2FuRXhwckNhbGxzKHYpO1xuICAgIH1cbiAgfVxuICBmb3IgKGNvbnN0IGZuIG9m
IGZ1bmN0aW9ucykgc2NhbkNhbGxzKGZuLmJvZHkpO1xuXG4gIC8vIEF1dG8taW1wb3J0IG1hdGgg
YnVpbHRpbnMgdGhhdCBhcmUgYWN0dWFsbHkgdXNlZFxuICBjb25zdCBtYXRoSW1wb3J0cyA9IFtd
O1xuICBmb3IgKGNvbnN0IG5hbWUgb2YgdXNlZENhbGxzKSB7XG4gICAgaWYgKE1BVEhfQlVJTFRJ
TlNbbmFtZV0gIT09IHVuZGVmaW5lZCAmJiAhbG9jYWxGdW5jTmFtZXMuaGFzKG5hbWUpICYmICFp
bXBvcnRzLmZpbmQoaW0gPT4gaW0ubmFtZSA9PT0gbmFtZSkpIHtcbiAgICAgIGNvbnN0IG5QYXJh
bXMgPSBNQVRIX0JVSUxUSU5TW25hbWVdO1xuICAgICAgY29uc3QgcGFyYW1zID0gW107XG4gICAg
ICBmb3IgKGxldCBrID0gMDsgayA8IG5QYXJhbXM7IGsrKykgcGFyYW1zLnB1c2goeyB0eXBlOiAn
UGFyYW0nLCBuYW1lOiAneCcgKyBrLCB2dHlwZTogJ2Y2NCcsIGlzQXJyYXk6IGZhbHNlLCBhcnJh
eURpbXM6IG51bGwgfSk7XG4gICAgICBtYXRoSW1wb3J0cy5wdXNoKHsgbmFtZSwgbW9kdWxlTmFt
ZTogJ21hdGgnLCBwYXJhbXMsIHJldFR5cGU6ICdmNjQnLCBpbnRlcnBJZHg6IG51bGwgfSk7XG4g
ICAgfVxuICB9XG5cbiAgLy8gQXV0by1pbXBvcnQgZnJvbSB1c2VySW1wb3J0cyBvciBnbG9iYWxU
aGlzXG4gIGNvbnN0IGZsYXRJbXBvcnRzID0gdXNlckltcG9ydHMgPyBmbGF0dGVuSW1wb3J0cyh1
c2VySW1wb3J0cykgOiB7fTtcbiAgY29uc3QgaG9zdEltcG9ydHMgPSBbXTtcbiAgZm9yIChjb25z
dCBuYW1lIG9mIHVzZWRDYWxscykge1xuICAgIGlmIChsb2NhbEZ1bmNOYW1lcy5oYXMobmFtZSkg
fHwgTkFUSVZFX0JVSUxUSU5TLmhhcyhuYW1lKSB8fCBuYW1lLnN0YXJ0c1dpdGgoJ3dhc20uJykg
fHxcbiAgICAgICAgbmFtZS5zdGFydHNXaXRoKCd2MTI4LicpIHx8IEFUUkFfVkVDVE9SX1RZUEVT
LmhhcyhuYW1lLnNwbGl0KCcuJylbMF0pIHx8XG4gICAgICAgIE1BVEhfQlVJTFRJTlNbbmFtZV0g
IT09IHVuZGVmaW5lZCB8fCBpbXBvcnRzLmZpbmQoaW0gPT4gaW0ubmFtZSA9PT0gbmFtZSkpIGNv
bnRpbnVlO1xuICAgIC8vIGNoZWNrIGZsYXR0ZW5lZCB1c2VySW1wb3J0cyB0aGVuIGdsb2JhbFRo
aXNcbiAgICBsZXQgZm4gPSBmbGF0SW1wb3J0c1tuYW1lXTtcbiAgICBpZiAoIWZuICYmIHR5cGVv
ZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJykgZm4gPSBnbG9iYWxUaGlzW25hbWVdO1xuICAg
IGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNvbnN0IG5QYXJhbXMgPSBm
bi5sZW5ndGg7XG4gICAgICBjb25zdCBwYXJhbXMgPSBbXTtcbiAgICAgIGZvciAobGV0IGsgPSAw
OyBrIDwgblBhcmFtczsgaysrKSBwYXJhbXMucHVzaCh7IHR5cGU6ICdQYXJhbScsIG5hbWU6ICd4
JyArIGssIHZ0eXBlOiAnZjY0JywgaXNBcnJheTogZmFsc2UsIGFycmF5RGltczogbnVsbCB9KTtc
biAgICAgIGhvc3RJbXBvcnRzLnB1c2goeyBuYW1lLCBtb2R1bGVOYW1lOiAnaG9zdCcsIHBhcmFt
cywgcmV0VHlwZTogJ2Y2NCcsIGludGVycElkeDogbnVsbCwganNGbjogZm4gfSk7XG4gICAgfVxu
ICB9XG5cbiAgY29uc3QgYWxsSW1wb3J0cyA9IFsuLi5tYXRoSW1wb3J0cywgLi4uaW1wb3J0cywg
Li4uaG9zdEltcG9ydHNdO1xuXG4gIC8vIEJ1aWxkIGZ1bmN0aW9uIGluZGV4IHRhYmxlOiBpbXBv
cnRzIGZpcnN0LCB0aGVuIGxvY2FsIGZ1bmN0aW9uc1xuICBjb25zdCBmdW5jSW5kZXggPSB7fTtc
biAgbGV0IGlkeCA9IDA7XG4gIGZvciAoY29uc3QgaW0gb2YgYWxsSW1wb3J0cykgeyBmdW5jSW5k
ZXhbaW0ubmFtZV0gPSBpZHgrKzsgfVxuICBmb3IgKGNvbnN0IGZuIG9mIGZ1bmN0aW9ucykgeyBm
dW5jSW5kZXhbZm4ubmFtZV0gPSBpZHgrKzsgfVxuXG4gIC8vIEdsb2JhbCBpbmRleCB0YWJsZSAo
KyB0cmFjayBmdW5jU2lnIGZvciBmdW5jdGlvbi10eXBlZCBnbG9iYWxzKVxuICBjb25zdCBnbG9i
YWxJbmRleCA9IHt9O1xuICBjb25zdCBnbG9iYWxGdW5jU2lnID0ge307IC8vIG5hbWUg4oaSIGZ1
bmNTaWcgZm9yIGZ1bmN0aW9uLXR5cGVkIGdsb2JhbHNcbiAgZm9yIChsZXQgZ2kgPSAwOyBnaSA8
IGdsb2JhbHMubGVuZ3RoOyBnaSsrKSB7XG4gICAgZ2xvYmFsSW5kZXhbZ2xvYmFsc1tnaV0ubmFt
ZV0gPSBnaTtcbiAgICBpZiAoZ2xvYmFsc1tnaV0uZnVuY1NpZykgZ2xvYmFsRnVuY1NpZ1tnbG9i
YWxzW2dpXS5uYW1lXSA9IGdsb2JhbHNbZ2ldLmZ1bmNTaWc7XG4gIH1cblxuICAvLyDilIDilIAg
U2NhbiBmb3IgZnVuY3Rpb24gcmVmZXJlbmNlcyAoYmFyZSBmdW5jdGlvbiBuYW1lcyB1c2VkIGFz
IHZhbHVlcykg4pSA4pSAXG4gIGNvbnN0IHJlZmVyZW5jZWRGdW5jcyA9IG5ldyBTZXQoKTtcbiAg
ZnVuY3Rpb24gc2NhbkZ1bmNSZWZzKHN0bXRzLCBsb2NhbE5hbWVzKSB7XG4gICAgZm9yIChjb25z
dCBzIG9mIHN0bXRzKSBzY2FuTm9kZVJlZnMocywgbG9jYWxOYW1lcyk7XG4gIH1cbiAgZnVuY3Rp
b24gc2Nhbk5vZGVSZWZzKG5vZGUsIGxvY2FsTmFtZXMpIHtcbiAgICBpZiAoIW5vZGUgfHwgdHlw
ZW9mIG5vZGUgIT09ICdvYmplY3QnKSByZXR1cm47XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gJ0lk
ZW50JyAmJiBmdW5jSW5kZXhbbm9kZS5uYW1lXSAhPT0gdW5kZWZpbmVkICYmICFsb2NhbE5hbWVz
Lmhhcyhub2RlLm5hbWUpICYmIGdsb2JhbEluZGV4W25vZGUubmFtZV0gPT09IHVuZGVmaW5lZCkg
e1xuICAgICAgcmVmZXJlbmNlZEZ1bmNzLmFkZChub2RlLm5hbWUpO1xuICAgIH1cbiAgICBmb3Ig
KGNvbnN0IGsgb2YgT2JqZWN0LmtleXMobm9kZSkpIHtcbiAgICAgIGNvbnN0IHYgPSBub2RlW2td
O1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodikpIHYuZm9yRWFjaChjID0+IHNjYW5Ob2RlUmVm
cyhjLCBsb2NhbE5hbWVzKSk7XG4gICAgICBlbHNlIGlmICh2ICYmIHR5cGVvZiB2ID09PSAnb2Jq
ZWN0JyAmJiB2LnR5cGUpIHNjYW5Ob2RlUmVmcyh2LCBsb2NhbE5hbWVzKTtcbiAgICB9XG4gIH1c
biAgZm9yIChjb25zdCBmbiBvZiBmdW5jdGlvbnMpIHtcbiAgICBjb25zdCBsb2NhbE5hbWVzID0g
bmV3IFNldCgpO1xuICAgIGZvciAoY29uc3QgcCBvZiBmbi5wYXJhbXMpIGxvY2FsTmFtZXMuYWRk
KHAubmFtZSk7XG4gICAgZm9yIChjb25zdCBsIG9mIGZuLmxvY2FscykgbG9jYWxOYW1lcy5hZGQo
bC5uYW1lKTtcbiAgICBpZiAoZm4udHlwZSA9PT0gJ0Z1bmN0aW9uJykgbG9jYWxOYW1lcy5hZGQo
Zm4ubmFtZSk7IC8vIHJldHVybiB2YXJcbiAgICBzY2FuRnVuY1JlZnMoZm4uYm9keSwgbG9jYWxO
YW1lcyk7XG4gIH1cblxuICAvLyBEZXRlY3QgaWYgY2FsbF9pbmRpcmVjdCBpcyBuZWVkZWQgKGZ1
bmN0aW9uLXR5cGVkIHBhcmFtcy9sb2NhbHMvZ2xvYmFscyBleGlzdClcbiAgbGV0IGhhc0luZGly
ZWN0Q2FsbHMgPSBPYmplY3Qua2V5cyhnbG9iYWxGdW5jU2lnKS5sZW5ndGggPiAwO1xuICBpZiAo
IWhhc0luZGlyZWN0Q2FsbHMpIHtcbiAgICBmb3IgKGNvbnN0IGZuIG9mIGZ1bmN0aW9ucykge1xu
ICAgICAgaWYgKGZuLnBhcmFtcy5zb21lKHAgPT4gcC5mdW5jU2lnKSB8fCBmbi5sb2NhbHMuc29t
ZShsID0+IGwuZnVuY1NpZykpIHsgaGFzSW5kaXJlY3RDYWxscyA9IHRydWU7IGJyZWFrOyB9XG4g
ICAgfVxuICB9XG5cbiAgLy8gQnVpbGQgdGFibGU6IGV4cGxpY2l0bHkgcmVmZXJlbmNlZCBmdW5j
cyBhbHdheXM7IGlmIGNhbGxfaW5kaXJlY3QgdXNlZCwgYWxzbyBleHBsaWNpdCBpbXBvcnRzICsg
bG9jYWwgZnVuY3Rpb25zLlxuICAvLyBBdXRvLWltcG9ydHMgb25seSBlbnRlciB0aGUgdGFibGUg
aWYgZXhwbGljaXRseSByZWZlcmVuY2VkIGJ5IGJhcmUgbmFtZS5cbiAgY29uc3QgYXV0b0ltcG9y
dE5hbWVzID0gbmV3IFNldChbLi4ubWF0aEltcG9ydHMubWFwKG0gPT4gbS5uYW1lKSwgLi4uaG9z
dEltcG9ydHMubWFwKG0gPT4gbS5uYW1lKV0pO1xuICBsZXQgdGFibGVGdW5jU2V0O1xuICBpZiAo
aGFzSW5kaXJlY3RDYWxscykge1xuICAgIHRhYmxlRnVuY1NldCA9IG5ldyBTZXQoW1xuICAgICAg
Li4uaW1wb3J0cy5tYXAoaW0gPT4gaW0ubmFtZSksXG4gICAgICAuLi5mdW5jdGlvbnMubWFwKGZu
ID0+IGZuLm5hbWUpLFxuICAgICAgLi4ucmVmZXJlbmNlZEZ1bmNzLFxuICAgIF0pO1xuICAgIC8v
IEV4Y2x1ZGUgYXV0by1pbXBvcnRzIHRoYXQgYXJlbid0IGV4cGxpY2l0bHkgcmVmZXJlbmNlZCBi
eSBiYXJlIG5hbWVcbiAgICBmb3IgKGNvbnN0IG5hbWUgb2YgYXV0b0ltcG9ydE5hbWVzKSB7XG4g
ICAgICBpZiAoIXJlZmVyZW5jZWRGdW5jcy5oYXMobmFtZSkpIHRhYmxlRnVuY1NldC5kZWxldGUo
bmFtZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRhYmxlRnVuY1NldCA9IG5ldyBTZXQocmVm
ZXJlbmNlZEZ1bmNzKTtcbiAgfVxuICBjb25zdCB0YWJsZUZ1bmNzID0gWy4uLnRhYmxlRnVuY1Nl
dF0uc29ydCgoYSwgYikgPT4gZnVuY0luZGV4W2FdIC0gZnVuY0luZGV4W2JdKTtcbiAgY29uc3Qg
dGFibGVTbG90ID0ge307IC8vIGZ1bmNOYW1lIOKGkiB0YWJsZSBpbmRleFxuICBmb3IgKGxldCB0
aSA9IDA7IHRpIDwgdGFibGVGdW5jcy5sZW5ndGg7IHRpKyspIHRhYmxlU2xvdFt0YWJsZUZ1bmNz
W3RpXV0gPSB0aTtcblxuICAvLyDilIDilIAgQnVpbGQgdHlwZSBzaWduYXR1cmVzIOKUgOKUgFxu
ICBmdW5jdGlvbiBwYXJhbVdhc21UeXBlKHApIHsgcmV0dXJuIHAuaXNBcnJheSA/ICdpMzInIDog
cC52dHlwZTsgfVxuICBmdW5jdGlvbiBzaWdLZXkocGFyYW1zLCByZXRUeXBlKSB7XG4gICAgcmV0
dXJuIHBhcmFtcy5tYXAocCA9PiBwYXJhbVdhc21UeXBlKHApKS5qb2luKCcsJykgKyAnOicgKyAo
cmV0VHlwZSB8fCAnJyk7XG4gIH1cbiAgY29uc3Qgc2lnTWFwID0gbmV3IE1hcCgpO1xuICBjb25z
dCBzaWdMaXN0ID0gW107IC8vIFt7cGFyYW1zLCByZXRUeXBlfV1cbiAgZnVuY3Rpb24gZ2V0T3JB
ZGRTaWcocGFyYW1zLCByZXRUeXBlKSB7XG4gICAgY29uc3Qga2V5ID0gc2lnS2V5KHBhcmFtcywg
cmV0VHlwZSk7XG4gICAgaWYgKHNpZ01hcC5oYXMoa2V5KSkgcmV0dXJuIHNpZ01hcC5nZXQoa2V5
KTtcbiAgICBjb25zdCBpZCA9IHNpZ0xpc3QubGVuZ3RoO1xuICAgIHNpZ0xpc3QucHVzaCh7IHBh
cmFtcywgcmV0VHlwZSB9KTtcbiAgICBzaWdNYXAuc2V0KGtleSwgaWQpO1xuICAgIHJldHVybiBp
ZDtcbiAgfVxuXG4gIC8vIFJlZ2lzdGVyIGFsbCBzaWduYXR1cmVzXG4gIGNvbnN0IGltcG9ydFNp
Z0lkcyA9IGFsbEltcG9ydHMubWFwKGltID0+IGdldE9yQWRkU2lnKGltLnBhcmFtcywgaW0ucmV0
VHlwZSkpO1xuICBjb25zdCBmdW5jU2lnSWRzID0gZnVuY3Rpb25zLm1hcChmbiA9PiB7XG4gICAg
Y29uc3QgcmV0VHlwZSA9IGZuLnR5cGUgPT09ICdTdWJyb3V0aW5lJyA/IG51bGwgOiBmbi5yZXRU
eXBlO1xuICAgIHJldHVybiBnZXRPckFkZFNpZyhmbi5wYXJhbXMsIHJldFR5cGUpO1xuICB9KTtc
blxuICAvLyDilIDilIAgRGV0ZXJtaW5lIG1lbW9yeSDilIDilIBcbiAgY29uc3QgaGFzTWVtb3J5
ID0gZnVuY3Rpb25zLnNvbWUoZm4gPT4gZm4ucGFyYW1zLnNvbWUocCA9PiBwLmlzQXJyYXkpKTtc
biAgY29uc3QgaW1wb3J0TWVtb3J5ID0gdXNlckltcG9ydHMgJiYgdXNlckltcG9ydHMuX19tZW1v
cnk7XG5cbiAgLy8g4pSA4pSAIEVtaXQgV2FzbSBiaW5hcnkg4pSA4pSAXG4gIC8vIE1hZ2ljICsg
dmVyc2lvblxuICB3LmJ5dGVzKFsweDAwLCAweDYxLCAweDczLCAweDZkXSk7IC8vIFxcMGFzbVxu
ICB3LmJ5dGVzKFsweDAxLCAweDAwLCAweDAwLCAweDAwXSk7IC8vIHZlcnNpb24gMVxuXG4gIC8v
IFR5cGUgc2VjdGlvbiAoMSlcbiAgdy5zZWN0aW9uKDEsIHMgPT4ge1xuICAgIHMudTMyKHNpZ0xp
c3QubGVuZ3RoKTtcbiAgICBmb3IgKGNvbnN0IHNpZyBvZiBzaWdMaXN0KSB7XG4gICAgICBzLmJ5
dGUoMHg2MCk7IC8vIGZ1bmMgdHlwZVxuICAgICAgcy51MzIoc2lnLnBhcmFtcy5sZW5ndGgpO1xu
ICAgICAgZm9yIChjb25zdCBwIG9mIHNpZy5wYXJhbXMpIHMuYnl0ZSh3YXNtVHlwZShwYXJhbVdh
c21UeXBlKHApKSk7XG4gICAgICBpZiAoc2lnLnJldFR5cGUpIHsgcy51MzIoMSk7IHMuYnl0ZSh3
YXNtVHlwZShzaWcucmV0VHlwZSkpOyB9XG4gICAgICBlbHNlIHMudTMyKDApO1xuICAgIH1cbiAg
fSk7XG5cbiAgLy8gSW1wb3J0IHNlY3Rpb24gKDIpXG4gIGlmIChhbGxJbXBvcnRzLmxlbmd0aCA+
IDAgfHwgaW1wb3J0TWVtb3J5KSB7XG4gICAgdy5zZWN0aW9uKDIsIHMgPT4ge1xuICAgICAgcy51
MzIoYWxsSW1wb3J0cy5sZW5ndGggKyAoaW1wb3J0TWVtb3J5ID8gMSA6IDApKTtcbiAgICAgIGZv
ciAobGV0IGlpID0gMDsgaWkgPCBhbGxJbXBvcnRzLmxlbmd0aDsgaWkrKykge1xuICAgICAgICBj
b25zdCBpbSA9IGFsbEltcG9ydHNbaWldO1xuICAgICAgICBzLnN0cihpbS5tb2R1bGVOYW1lKTtc
biAgICAgICAgcy5zdHIoaW0ubmFtZSk7XG4gICAgICAgIHMuYnl0ZSgweDAwKTsgLy8gZnVuYyBp
bXBvcnRcbiAgICAgICAgcy51MzIoaW1wb3J0U2lnSWRzW2lpXSk7XG4gICAgICB9XG4gICAgICBp
ZiAoaW1wb3J0TWVtb3J5KSB7XG4gICAgICAgIHMuc3RyKCdlbnYnKTtcbiAgICAgICAgcy5zdHIo
J21lbW9yeScpO1xuICAgICAgICBzLmJ5dGUoMHgwMik7IC8vIG1lbW9yeSBpbXBvcnRcbiAgICAg
ICAgcy5ieXRlKDB4MDApOyAvLyBubyBtYXhcbiAgICAgICAgcy51MzIoMSk7IC8vIGluaXRpYWwg
MSBwYWdlXG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvLyBGdW5jdGlvbiBzZWN0aW9uICgz
KVxuICB3LnNlY3Rpb24oMywgcyA9PiB7XG4gICAgcy51MzIoZnVuY3Rpb25zLmxlbmd0aCk7XG4g
ICAgZm9yIChjb25zdCBzaWdJZCBvZiBmdW5jU2lnSWRzKSBzLnUzMihzaWdJZCk7XG4gIH0pO1xu
XG4gIC8vIFRhYmxlIHNlY3Rpb24gKDQpIOKAlCBvbmx5IGlmIGNhbGxfaW5kaXJlY3QgaXMgdXNl
ZFxuICBpZiAodGFibGVGdW5jcy5sZW5ndGggPiAwKSB7XG4gICAgdy5zZWN0aW9uKDQsIHMgPT4g
e1xuICAgICAgcy51MzIoMSk7IC8vIG9uZSB0YWJsZVxuICAgICAgcy5ieXRlKDB4NzApOyAvLyBm
dW5jcmVmXG4gICAgICBzLmJ5dGUoMHgwMCk7IC8vIG5vIG1heFxuICAgICAgcy51MzIodGFibGVG
dW5jcy5sZW5ndGgpOyAvLyBpbml0aWFsIHNpemUgPSBudW1iZXIgb2YgcmVmZXJlbmNlZCBmdW5j
dGlvbnNcbiAgICB9KTtcbiAgfVxuXG4gIC8vIE1lbW9yeSBzZWN0aW9uICg1KSDigJQgb25seSBp
ZiBhcnJheXMgdXNlZCBhbmQgbm8gaW1wb3J0ZWQgbWVtb3J5XG4gIGlmIChoYXNNZW1vcnkgJiYg
IWltcG9ydE1lbW9yeSkge1xuICAgIHcuc2VjdGlvbig1LCBzID0+IHtcbiAgICAgIHMudTMyKDEp
O1xuICAgICAgcy5ieXRlKDB4MDApOyAvLyBubyBtYXhcbiAgICAgIHMudTMyKDEpOyAvLyBpbml0
aWFsOiAxIHBhZ2UgKDY0S0IpXG4gICAgfSk7XG4gIH1cblxuICAvLyBHbG9iYWwgc2VjdGlvbiAo
NilcbiAgaWYgKGdsb2JhbHMubGVuZ3RoID4gMCkge1xuICAgIHcuc2VjdGlvbig2LCBzID0+IHtc
biAgICAgIHMudTMyKGdsb2JhbHMubGVuZ3RoKTtcbiAgICAgIGZvciAoY29uc3QgZyBvZiBnbG9i
YWxzKSB7XG4gICAgICAgIHMuYnl0ZSh3YXNtVHlwZShnLnZ0eXBlKSk7XG4gICAgICAgIHMuYnl0
ZShnLm11dGFibGUgPyAweDAxIDogMHgwMCk7XG4gICAgICAgIC8vIGluaXQgZXhwcmVzc2lvblxu
ICAgICAgICBlbWl0Q29uc3RFeHByKHMsIGcuaW5pdCwgZy52dHlwZSk7XG4gICAgICAgIHMuYnl0
ZShPUF9FTkQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLy8gRXhwb3J0IHNlY3Rpb24g
KDcpXG4gIHcuc2VjdGlvbig3LCBzID0+IHtcbiAgICBjb25zdCBleHBvcnRzID0gZnVuY3Rpb25z
Lm1hcCgoZm4sIGkpID0+ICh7IG5hbWU6IGZuLm5hbWUsIGlkeDogYWxsSW1wb3J0cy5sZW5ndGgg
KyBpIH0pKTtcbiAgICBjb25zdCBtZW1FeHBvcnQgPSAoaGFzTWVtb3J5ICYmICFpbXBvcnRNZW1v
cnkpID8gMSA6IDA7XG4gICAgcy51MzIoZXhwb3J0cy5sZW5ndGggKyBtZW1FeHBvcnQpO1xuICAg
IGZvciAoY29uc3QgZSBvZiBleHBvcnRzKSB7XG4gICAgICBzLnN0cihlLm5hbWUpO1xuICAgICAg
cy5ieXRlKDB4MDApOyAvLyBmdW5jIGV4cG9ydFxuICAgICAgcy51MzIoZS5pZHgpO1xuICAgIH1c
biAgICBpZiAobWVtRXhwb3J0KSB7XG4gICAgICBzLnN0cignbWVtb3J5Jyk7XG4gICAgICBzLmJ5
dGUoMHgwMik7IC8vIG1lbW9yeSBleHBvcnRcbiAgICAgIHMudTMyKDApO1xuICAgIH1cbiAgfSk7
XG5cbiAgLy8gRWxlbWVudCBzZWN0aW9uICg5KSDigJQgcG9wdWxhdGUgdGhlIHRhYmxlIHdpdGgg
ZnVuY3Rpb24gcmVmZXJlbmNlc1xuICBpZiAodGFibGVGdW5jcy5sZW5ndGggPiAwKSB7XG4gICAg
dy5zZWN0aW9uKDksIHMgPT4ge1xuICAgICAgcy51MzIoMSk7IC8vIG9uZSBlbGVtZW50IHNlZ21l
bnRcbiAgICAgIHMudTMyKDApOyAvLyB0YWJsZSBpbmRleCAwXG4gICAgICAvLyBvZmZzZXQgZXhw
cmVzc2lvbjogaTMyLmNvbnN0IDBcbiAgICAgIHMuYnl0ZShPUF9JMzJfQ09OU1QpOyBzLnMzMigw
KTsgcy5ieXRlKE9QX0VORCk7XG4gICAgICBzLnUzMih0YWJsZUZ1bmNzLmxlbmd0aCk7XG4gICAg
ICBmb3IgKGNvbnN0IGZuYW1lIG9mIHRhYmxlRnVuY3MpIHMudTMyKGZ1bmNJbmRleFtmbmFtZV0p
O1xuICAgIH0pO1xuICB9XG5cbiAgLy8gQ29kZSBzZWN0aW9uICgxMClcbiAgdy5zZWN0aW9uKDEw
LCBzID0+IHtcbiAgICBzLnUzMihmdW5jdGlvbnMubGVuZ3RoKTtcbiAgICBmb3IgKGNvbnN0IGZu
IG9mIGZ1bmN0aW9ucykge1xuICAgICAgY29uc3QgYm9keVdyaXRlciA9IG5ldyBCeXRlV3JpdGVy
KCk7XG4gICAgICBlbWl0RnVuY3Rpb25Cb2R5KGJvZHlXcml0ZXIsIGZuKTtcbiAgICAgIHMudTMy
KGJvZHlXcml0ZXIuYnVmLmxlbmd0aCk7XG4gICAgICBzLmJ5dGVzKGJvZHlXcml0ZXIuYnVmKTtc
biAgICB9XG4gIH0pO1xuXG4gIGNvbnN0IGJ5dGVzID0gdy50b1VpbnQ4QXJyYXkoKTtcbiAgY29u
c3QgdGFibGUgPSB0YWJsZUZ1bmNzLmxlbmd0aCA+IDAgPyB7IC4uLnRhYmxlU2xvdCB9IDogbnVs
bDtcbiAgcmV0dXJuIHsgYnl0ZXMsIHRhYmxlIH07XG5cbiAgLy8g4pSA4pSAIEhlbHBlcjogZW1p
dCBjb25zdGFudCBpbml0IGV4cHJlc3Npb24g4pSA4pSAXG4gIGZ1bmN0aW9uIGVtaXRDb25zdEV4
cHIocywgbm9kZSwgdnR5cGUpIHtcbiAgICBpZiAoIW5vZGUpIHtcbiAgICAgIC8vIGRlZmF1bHQg
emVyb1xuICAgICAgaWYgKHZ0eXBlID09PSAnaTMyJykgeyBzLmJ5dGUoT1BfSTMyX0NPTlNUKTsg
cy5zMzIoMCk7IH1cbiAgICAgIGVsc2UgaWYgKHZ0eXBlID09PSAnaTY0JykgeyBzLmJ5dGUoT1Bf
STY0X0NPTlNUKTsgcy5zNjQoMG4pOyB9XG4gICAgICBlbHNlIGlmICh2dHlwZSA9PT0gJ2YzMicp
IHsgcy5ieXRlKE9QX0YzMl9DT05TVCk7IHMuZjMyKDApOyB9XG4gICAgICBlbHNlIGlmICh2dHlw
ZSA9PT0gJ2Y2NCcpIHsgcy5ieXRlKE9QX0Y2NF9DT05TVCk7IHMuZjY0KDApOyB9XG4gICAgICBl
bHNlIGlmIChpc1ZlY3Rvcih2dHlwZSkpIHtcbiAgICAgICAgLy8gdjEyOC5jb25zdCB3aXRoIDE2
IHplcm8gYnl0ZXNcbiAgICAgICAgcy5ieXRlKE9QX1NJTURfUFJFRklYKTsgcy51MzIoU0lNRF9P
UFNbJ3YxMjguY29uc3QnXSk7XG4gICAgICAgIGZvciAobGV0IHZpID0gMDsgdmkgPCAxNjsgdmkr
Kykgcy5ieXRlKDApO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAobm9k
ZS50eXBlID09PSAnTnVtYmVyTGl0Jykge1xuICAgICAgY29uc3QgdmFsID0gcGFyc2VOdW1lcmlj
VmFsdWUobm9kZSwgdnR5cGUpO1xuICAgICAgZW1pdFR5cGVkQ29uc3QocywgdnR5cGUsIHZhbCk7
XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChub2RlLnR5cGUgPT09ICdVbmFyeU9wJyAm
JiBub2RlLm9wID09PSAnLScgJiYgbm9kZS5vcGVyYW5kLnR5cGUgPT09ICdOdW1iZXJMaXQnKSB7
XG4gICAgICBjb25zdCB2YWwgPSAtcGFyc2VOdW1lcmljVmFsdWUobm9kZS5vcGVyYW5kLCB2dHlw
ZSk7XG4gICAgICBlbWl0VHlwZWRDb25zdChzLCB2dHlwZSwgdmFsKTtcbiAgICAgIHJldHVybjtc
biAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdHbG9iYWwgaW5pdCBtdXN0IGJlIGEgY29uc3Rh
bnQgZXhwcmVzc2lvbicpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VOdW1lcmljVmFsdWUobm9k
ZSwgZGVmYXVsdFR5cGUpIHtcbiAgICBjb25zdCByYXcgPSBub2RlLnZhbHVlO1xuICAgIGlmIChy
YXcuaW5jbHVkZXMoJy4nKSB8fCByYXcuaW5jbHVkZXMoJ2UnKSB8fCByYXcuaW5jbHVkZXMoJ0Un
KSB8fCBub2RlLmlzRmxvYXQpIHJldHVybiBwYXJzZUZsb2F0KHJhdyk7XG4gICAgcmV0dXJuIHBh
cnNlSW50KHJhdywgMTApO1xuICB9XG5cbiAgZnVuY3Rpb24gZW1pdFR5cGVkQ29uc3QocywgdnR5
cGUsIHZhbCkge1xuICAgIGlmICh2dHlwZSA9PT0gJ2kzMicpIHsgcy5ieXRlKE9QX0kzMl9DT05T
VCk7IHMuczMyKHZhbCB8IDApOyB9XG4gICAgZWxzZSBpZiAodnR5cGUgPT09ICdpNjQnKSB7IHMu
Ynl0ZShPUF9JNjRfQ09OU1QpOyBzLnM2NChCaWdJbnQodmFsKSk7IH1cbiAgICBlbHNlIGlmICh2
dHlwZSA9PT0gJ2YzMicpIHsgcy5ieXRlKE9QX0YzMl9DT05TVCk7IHMuZjMyKHZhbCk7IH1cbiAg
ICBlbHNlIGlmICh2dHlwZSA9PT0gJ2Y2NCcpIHsgcy5ieXRlKE9QX0Y2NF9DT05TVCk7IHMuZjY0
KHZhbCk7IH1cbiAgfVxuXG4gIC8vIOKUgOKUgCBFbWl0IGZ1bmN0aW9uIGJvZHkg4pSA4pSAXG4g
IGZ1bmN0aW9uIGVtaXRGdW5jdGlvbkJvZHkoYncsIGZuKSB7XG4gICAgY29uc3QgaXNGdW5jID0g
Zm4udHlwZSA9PT0gJ0Z1bmN0aW9uJztcbiAgICBjb25zdCByZXRUeXBlID0gaXNGdW5jID8gZm4u
cmV0VHlwZSA6IG51bGw7XG5cbiAgICAvLyBCdWlsZCBsb2NhbCBtYXA6IHBhcmFtcyArIGxvY2Fs
cyArIHJldHVybiB2YXJcbiAgICBjb25zdCBsb2NhbE1hcCA9IHt9OyAvLyBuYW1lIOKGkiB7IGlk
eCwgdnR5cGUgfVxuICAgIGxldCBsb2NhbElkeCA9IDA7XG4gICAgZm9yIChjb25zdCBwIG9mIGZu
LnBhcmFtcykge1xuICAgICAgY29uc3QgZW50cnkgPSB7XG4gICAgICAgIGlkeDogbG9jYWxJZHgr
KyxcbiAgICAgICAgdnR5cGU6IHAuaXNBcnJheSA/ICdpMzInIDogcC52dHlwZSwgLy8gV2FzbSB0
eXBlOiBhcnJheXMgYXJlIGkzMiBwb2ludGVyc1xuICAgICAgICBpc0FycmF5OiBwLmlzQXJyYXks
XG4gICAgICAgIGFycmF5RGltczogcC5hcnJheURpbXMsXG4gICAgICAgIGVsZW1UeXBlOiBwLmlz
QXJyYXkgPyBwLnZ0eXBlIDogbnVsbCAgLy8gZWxlbWVudCB0eXBlIGZvciBsb2FkL3N0b3JlXG4g
ICAgICB9O1xuICAgICAgaWYgKHAuZnVuY1NpZykgZW50cnkuZnVuY1NpZyA9IHAuZnVuY1NpZztc
biAgICAgIGxvY2FsTWFwW3AubmFtZV0gPSBlbnRyeTtcbiAgICB9XG4gICAgLy8gQWRkaXRpb25h
bCBsb2NhbHMgZGVjbGFyZWRcbiAgICBjb25zdCBkZWNsYXJlZExvY2FscyA9IFsuLi5mbi5sb2Nh
bHNdO1xuICAgIGlmIChpc0Z1bmMpIHtcbiAgICAgIC8vIGhpZGRlbiByZXR1cm4gbG9jYWwgKHVz
ZXMgZnVuY3Rpb24gbmFtZSlcbiAgICAgIGRlY2xhcmVkTG9jYWxzLnB1c2goeyBuYW1lOiAnJF9y
ZXR1cm4nLCB2dHlwZTogcmV0VHlwZSB9KTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBsb2Mgb2Yg
ZGVjbGFyZWRMb2NhbHMpIHtcbiAgICAgIGNvbnN0IGVudHJ5ID0geyBpZHg6IGxvY2FsSWR4Kyss
IHZ0eXBlOiBsb2MudnR5cGUgfTtcbiAgICAgIGlmIChsb2MuZnVuY1NpZykgZW50cnkuZnVuY1Np
ZyA9IGxvYy5mdW5jU2lnO1xuICAgICAgbG9jYWxNYXBbbG9jLm5hbWVdID0gZW50cnk7XG4gICAg
fVxuXG4gICAgLy8gRW1pdCBsb2NhbCBkZWNsYXJhdGlvbnMgKG9ubHkgdGhlIG5vbi1wYXJhbSBv
bmVzKVxuICAgIGNvbnN0IGxvY2FsVHlwZXMgPSBkZWNsYXJlZExvY2Fscy5tYXAobCA9PiBsLnZ0
eXBlKTtcbiAgICAvLyBDb21wcmVzczogcnVucyBvZiBzYW1lIHR5cGVcbiAgICBjb25zdCBsb2Nh
bFJ1bnMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGx0IG9mIGxvY2FsVHlwZXMpIHtcbiAgICAgIGlm
IChsb2NhbFJ1bnMubGVuZ3RoID4gMCAmJiBsb2NhbFJ1bnNbbG9jYWxSdW5zLmxlbmd0aCAtIDFd
LnR5cGUgPT09IGx0KSBsb2NhbFJ1bnNbbG9jYWxSdW5zLmxlbmd0aCAtIDFdLmNvdW50Kys7XG4g
ICAgICBlbHNlIGxvY2FsUnVucy5wdXNoKHsgY291bnQ6IDEsIHR5cGU6IGx0IH0pO1xuICAgIH1c
biAgICBidy51MzIobG9jYWxSdW5zLmxlbmd0aCk7XG4gICAgZm9yIChjb25zdCBydW4gb2YgbG9j
YWxSdW5zKSB7XG4gICAgICBidy51MzIocnVuLmNvdW50KTtcbiAgICAgIGJ3LmJ5dGUod2FzbVR5
cGUocnVuLnR5cGUpKTtcbiAgICB9XG5cbiAgICAvLyBTSU1EIGhlbHBlclxuICAgIGZ1bmN0aW9u
IGVtaXRTaW1kKG9wKSB7IGJ3LmJ5dGUoT1BfU0lNRF9QUkVGSVgpOyBidy51MzIob3ApOyB9XG5c
biAgICAvLyBFbWl0IGJvZHkgc3RhdGVtZW50c1xuICAgIGxldCBkZXB0aCA9IDA7IC8vIGN1cnJl
bnQgYmxvY2sgbmVzdGluZyBkZXB0aFxuICAgIGNvbnN0IGJyZWFrVGFyZ2V0cyA9IFtdOyAvLyBz
dGFjayBvZiB7ZGVwdGh9IGZvciBlYWNoIGVuY2xvc2luZyBsb29wJ3MgYnJlYWsgYmxvY2tcblxu
ICAgIGZ1bmN0aW9uIGVtaXRTdG10cyhzdG10cykgeyBmb3IgKGNvbnN0IHMgb2Ygc3RtdHMpIGVt
aXRTdG10KHMpOyB9XG5cbiAgICBmdW5jdGlvbiBlbWl0U3RtdChzdG10KSB7XG4gICAgICBzd2l0
Y2ggKHN0bXQudHlwZSkge1xuICAgICAgICBjYXNlICdBc3NpZ24nOiB7XG4gICAgICAgICAgY29u
c3QgdGFyZ2V0ID0gc3RtdC5uYW1lO1xuICAgICAgICAgIC8vIEFzc2lnbm1lbnQgdG8gZnVuY3Rp
b24gbmFtZSA9IHNldCByZXR1cm4gdmFyaWFibGVcbiAgICAgICAgICBpZiAoaXNGdW5jICYmIHRh
cmdldCA9PT0gZm4ubmFtZSkge1xuICAgICAgICAgICAgZW1pdEV4cHIoc3RtdC52YWx1ZSwgcmV0
VHlwZSk7XG4gICAgICAgICAgICBidy5ieXRlKE9QX0xPQ0FMX1NFVCk7XG4gICAgICAgICAgICBi
dy51MzIobG9jYWxNYXBbJyRfcmV0dXJuJ10uaWR4KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGxv
Y2FsTWFwW3RhcmdldF0pIHtcbiAgICAgICAgICAgIGVtaXRFeHByKHN0bXQudmFsdWUsIGxvY2Fs
TWFwW3RhcmdldF0udnR5cGUpO1xuICAgICAgICAgICAgYncuYnl0ZShPUF9MT0NBTF9TRVQpO1xu
ICAgICAgICAgICAgYncudTMyKGxvY2FsTWFwW3RhcmdldF0uaWR4KTtcbiAgICAgICAgICB9IGVs
c2UgaWYgKGdsb2JhbEluZGV4W3RhcmdldF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAg
ZW1pdEV4cHIoc3RtdC52YWx1ZSwgZ2xvYmFsc1tnbG9iYWxJbmRleFt0YXJnZXRdXS52dHlwZSk7
XG4gICAgICAgICAgICBidy5ieXRlKE9QX0dMT0JBTF9TRVQpO1xuICAgICAgICAgICAgYncudTMy
KGdsb2JhbEluZGV4W3RhcmdldF0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0
aHJvdyBuZXcgRXJyb3IoYFVuZGVmaW5lZCB2YXJpYWJsZTogJHt0YXJnZXR9YCk7XG4gICAgICAg
ICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ0FycmF5U3Rv
cmUnOiB7XG4gICAgICAgICAgY29uc3QgaW5mbyA9IGxvY2FsTWFwW3N0bXQubmFtZV07XG4gICAg
ICAgICAgaWYgKCFpbmZvKSB0aHJvdyBuZXcgRXJyb3IoYFVuZGVmaW5lZCBhcnJheTogJHtzdG10
Lm5hbWV9YCk7XG4gICAgICAgICAgY29uc3QgZWxlbVR5cGUgPSBpbmZvLmVsZW1UeXBlIHx8IGlu
Zm8udnR5cGU7XG4gICAgICAgICAgLy8gY29tcHV0ZSBhZGRyZXNzXG4gICAgICAgICAgZW1pdEFy
cmF5QWRkcihzdG10Lm5hbWUsIHN0bXQuaW5kaWNlcywgaW5mbywgZWxlbVR5cGUpO1xuICAgICAg
ICAgIC8vIGNvbXB1dGUgdmFsdWVcbiAgICAgICAgICBlbWl0RXhwcihzdG10LnZhbHVlLCBlbGVt
VHlwZSk7XG4gICAgICAgICAgLy8gc3RvcmVcbiAgICAgICAgICBlbWl0U3RvcmUoZWxlbVR5cGUp
O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ0lmJzoge1xuICAg
ICAgICAgIGVtaXRFeHByKHN0bXQuY29uZCwgJ2kzMicpO1xuICAgICAgICAgIGJ3LmJ5dGUoT1Bf
SUYpO1xuICAgICAgICAgIGJ3LmJ5dGUoV0FTTV9WT0lEKTtcbiAgICAgICAgICBkZXB0aCsrO1xu
ICAgICAgICAgIGVtaXRTdG10cyhzdG10LmJvZHkpO1xuICAgICAgICAgIGlmIChzdG10LmVsc2VC
b2R5KSB7XG4gICAgICAgICAgICBidy5ieXRlKE9QX0VMU0UpO1xuICAgICAgICAgICAgZW1pdFN0
bXRzKHN0bXQuZWxzZUJvZHkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZXB0aC0tO1xuICAg
ICAgICAgIGJ3LmJ5dGUoT1BfRU5EKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAg
ICAgICBjYXNlICdGb3InOiB7XG4gICAgICAgICAgY29uc3QgdkluZm8gPSBsb2NhbE1hcFtzdG10
LnZhck5hbWVdO1xuICAgICAgICAgIGlmICghdkluZm8pIHRocm93IG5ldyBFcnJvcihgVW5kZWZp
bmVkIGxvb3AgdmFyaWFibGU6ICR7c3RtdC52YXJOYW1lfWApO1xuICAgICAgICAgIGNvbnN0IHZ0
ID0gdkluZm8udnR5cGU7XG4gICAgICAgICAgZW1pdEV4cHIoc3RtdC5zdGFydCwgdnQpO1xuICAg
ICAgICAgIGJ3LmJ5dGUoT1BfTE9DQUxfU0VUKTtcbiAgICAgICAgICBidy51MzIodkluZm8uaWR4
KTtcblxuICAgICAgICAgIGNvbnN0IGhhc1N0ZXAgPSBzdG10LnN0ZXAgIT09IG51bGw7XG5cbiAg
ICAgICAgICBidy5ieXRlKE9QX0JMT0NLKTsgYncuYnl0ZShXQVNNX1ZPSUQpOyBkZXB0aCsrO1xu
ICAgICAgICAgIGNvbnN0IGJyZWFrRGVwdGggPSBkZXB0aDsgLy8gYnJlYWsgdGFyZ2V0ID0gdGhp
cyBibG9ja1xuICAgICAgICAgIGJ3LmJ5dGUoT1BfTE9PUCk7IGJ3LmJ5dGUoV0FTTV9WT0lEKTsg
ZGVwdGgrKztcbiAgICAgICAgICBicmVha1RhcmdldHMucHVzaChicmVha0RlcHRoKTtcblxuICAg
ICAgICAgIC8vIGNvbmRpdGlvbiBjaGVjazogYnJfaWYgdG8gYnJlYWsgYmxvY2tcbiAgICAgICAg
ICBidy5ieXRlKE9QX0xPQ0FMX0dFVCk7IGJ3LnUzMih2SW5mby5pZHgpO1xuICAgICAgICAgIGVt
aXRFeHByKHN0bXQuZW5kLCB2dCk7XG4gICAgICAgICAgaWYgKCFoYXNTdGVwKSB7XG4gICAgICAg
ICAgICBlbWl0Q21wKCc+PScsIHZ0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAg
Y29uc3Qgc3RlcElzTmVnTGl0ID0gc3RtdC5zdGVwLnR5cGUgPT09ICdVbmFyeU9wJyAmJiBzdG10
LnN0ZXAub3AgPT09ICctJyAmJiBzdG10LnN0ZXAub3BlcmFuZC50eXBlID09PSAnTnVtYmVyTGl0
JztcbiAgICAgICAgICAgIGNvbnN0IHN0ZXBJc05lZ0NvbnN0ID0gc3RlcElzTmVnTGl0IHx8IChz
dG10LnN0ZXAudHlwZSA9PT0gJ051bWJlckxpdCcgJiYgcGFyc2VGbG9hdChzdG10LnN0ZXAudmFs
dWUpIDwgMCk7XG4gICAgICAgICAgICBlbWl0Q21wKHN0ZXBJc05lZ0NvbnN0ID8gJzw9JyA6ICc+
PScsIHZ0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYncuYnl0ZShPUF9CUl9JRik7IGJ3LnUz
MihkZXB0aCAtIGJyZWFrRGVwdGgpO1xuXG4gICAgICAgICAgZW1pdFN0bXRzKHN0bXQuYm9keSk7
XG5cbiAgICAgICAgICAvLyBpbmNyZW1lbnRcbiAgICAgICAgICBidy5ieXRlKE9QX0xPQ0FMX0dF
VCk7IGJ3LnUzMih2SW5mby5pZHgpO1xuICAgICAgICAgIGlmIChoYXNTdGVwKSB7IGVtaXRFeHBy
KHN0bXQuc3RlcCwgdnQpOyB9IGVsc2UgeyBlbWl0VHlwZWRDb25zdChidywgdnQsIDEpOyB9XG4g
ICAgICAgICAgZW1pdEFkZCh2dCk7XG4gICAgICAgICAgYncuYnl0ZShPUF9MT0NBTF9TRVQpOyBi
dy51MzIodkluZm8uaWR4KTtcblxuICAgICAgICAgIGJ3LmJ5dGUoT1BfQlIpOyBidy51MzIoMCk7
IC8vIGNvbnRpbnVlIHRvIGxvb3BcbiAgICAgICAgICBkZXB0aC0tOyBidy5ieXRlKE9QX0VORCk7
IC8vIGVuZCBsb29wXG4gICAgICAgICAgYnJlYWtUYXJnZXRzLnBvcCgpO1xuICAgICAgICAgIGRl
cHRoLS07IGJ3LmJ5dGUoT1BfRU5EKTsgLy8gZW5kIGJsb2NrXG4gICAgICAgICAgYnJlYWs7XG4g
ICAgICAgIH1cbiAgICAgICAgY2FzZSAnV2hpbGUnOiB7XG4gICAgICAgICAgYncuYnl0ZShPUF9C
TE9DSyk7IGJ3LmJ5dGUoV0FTTV9WT0lEKTsgZGVwdGgrKztcbiAgICAgICAgICBjb25zdCBicmVh
a0RlcHRoID0gZGVwdGg7XG4gICAgICAgICAgYncuYnl0ZShPUF9MT09QKTsgYncuYnl0ZShXQVNN
X1ZPSUQpOyBkZXB0aCsrO1xuICAgICAgICAgIGJyZWFrVGFyZ2V0cy5wdXNoKGJyZWFrRGVwdGgp
O1xuXG4gICAgICAgICAgZW1pdEV4cHIoc3RtdC5jb25kLCAnaTMyJyk7XG4gICAgICAgICAgYncu
Ynl0ZShPUF9JMzJfRVFaKTtcbiAgICAgICAgICBidy5ieXRlKE9QX0JSX0lGKTsgYncudTMyKGRl
cHRoIC0gYnJlYWtEZXB0aCk7XG5cbiAgICAgICAgICBlbWl0U3RtdHMoc3RtdC5ib2R5KTtcblxu
ICAgICAgICAgIGJ3LmJ5dGUoT1BfQlIpOyBidy51MzIoMCk7IC8vIGNvbnRpbnVlIGxvb3BcbiAg
ICAgICAgICBkZXB0aC0tOyBidy5ieXRlKE9QX0VORCk7IC8vIGVuZCBsb29wXG4gICAgICAgICAg
YnJlYWtUYXJnZXRzLnBvcCgpO1xuICAgICAgICAgIGRlcHRoLS07IGJ3LmJ5dGUoT1BfRU5EKTsg
Ly8gZW5kIGJsb2NrXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAn
RG9XaGlsZSc6IHtcbiAgICAgICAgICBidy5ieXRlKE9QX0JMT0NLKTsgYncuYnl0ZShXQVNNX1ZP
SUQpOyBkZXB0aCsrO1xuICAgICAgICAgIGNvbnN0IGJyZWFrRGVwdGggPSBkZXB0aDtcbiAgICAg
ICAgICBidy5ieXRlKE9QX0xPT1ApOyBidy5ieXRlKFdBU01fVk9JRCk7IGRlcHRoKys7XG4gICAg
ICAgICAgYnJlYWtUYXJnZXRzLnB1c2goYnJlYWtEZXB0aCk7XG5cbiAgICAgICAgICBlbWl0U3Rt
dHMoc3RtdC5ib2R5KTtcblxuICAgICAgICAgIGVtaXRFeHByKHN0bXQuY29uZCwgJ2kzMicpO1xu
ICAgICAgICAgIGJ3LmJ5dGUoT1BfQlJfSUYpOyBidy51MzIoMCk7IC8vIGNvbnRpbnVlIGlmIHRy
dWVcblxuICAgICAgICAgIGRlcHRoLS07IGJ3LmJ5dGUoT1BfRU5EKTsgLy8gZW5kIGxvb3BcbiAg
ICAgICAgICBicmVha1RhcmdldHMucG9wKCk7XG4gICAgICAgICAgZGVwdGgtLTsgYncuYnl0ZShP
UF9FTkQpOyAvLyBlbmQgYmxvY2tcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAg
ICBjYXNlICdCcmVhayc6IHtcbiAgICAgICAgICBpZiAoYnJlYWtUYXJnZXRzLmxlbmd0aCA9PT0g
MCkgdGhyb3cgbmV3IEVycm9yKCdicmVhayBvdXRzaWRlIGxvb3AnKTtcbiAgICAgICAgICBjb25z
dCB0YXJnZXREZXB0aCA9IGJyZWFrVGFyZ2V0c1ticmVha1RhcmdldHMubGVuZ3RoIC0gMV07XG4g
ICAgICAgICAgYncuYnl0ZShPUF9CUik7XG4gICAgICAgICAgYncudTMyKGRlcHRoIC0gdGFyZ2V0
RGVwdGgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ0NhbGwn
OiB7XG4gICAgICAgICAgLy8gRWFybHkgcmV0dXJuOiBjYWxsIHJldHVybihleHByKSBvciBjYWxs
IHJldHVybigpXG4gICAgICAgICAgaWYgKHN0bXQubmFtZSA9PT0gJ3JldHVybicpIHtcbiAgICAg
ICAgICAgIGlmIChpc0Z1bmMpIHtcbiAgICAgICAgICAgICAgaWYgKHN0bXQuYXJncy5sZW5ndGgg
IT09IDEpIHRocm93IG5ldyBFcnJvcigncmV0dXJuKCkgaW4gYSBmdW5jdGlvbiByZXF1aXJlcyBl
eGFjdGx5IG9uZSBhcmd1bWVudCcpO1xuICAgICAgICAgICAgICBlbWl0RXhwcihzdG10LmFyZ3Nb
MF0sIHJldFR5cGUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKHN0
bXQuYXJncy5sZW5ndGggIT09IDApIHRocm93IG5ldyBFcnJvcigncmV0dXJuKCkgaW4gYSBzdWJy
b3V0aW5lIHRha2VzIG5vIGFyZ3VtZW50cycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAg
YncuYnl0ZShPUF9SRVRVUk4pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAg
ICAgICAgIC8vIFNJTUQgbmFtZXNwYWNlZCBidWlsdGlucyB1c2VkIGFzIHN0YXRlbWVudHMgKGUu
Zy4gY2FsbCB2MTI4LnN0b3JlKC4uLikpXG4gICAgICAgICAgY29uc3QgY2FsbERvdElkeCA9IHN0
bXQubmFtZS5pbmRleE9mKCcuJyk7XG4gICAgICAgICAgaWYgKGNhbGxEb3RJZHggIT09IC0xKSB7
XG4gICAgICAgICAgICBjb25zdCBjYWxsUHJlZml4ID0gc3RtdC5uYW1lLnNsaWNlKDAsIGNhbGxE
b3RJZHgpO1xuICAgICAgICAgICAgY29uc3QgY2FsbE1ldGhvZCA9IHN0bXQubmFtZS5zbGljZShj
YWxsRG90SWR4ICsgMSk7XG4gICAgICAgICAgICBpZiAoaXNWZWN0b3IoY2FsbFByZWZpeCkgfHwg
Y2FsbFByZWZpeCA9PT0gJ3YxMjgnKSB7XG4gICAgICAgICAgICAgIGVtaXRTaW1kQnVpbHRpbihj
YWxsUHJlZml4LCBjYWxsTWV0aG9kLCBzdG10LCBudWxsKTtcbiAgICAgICAgICAgICAgYnJlYWs7
XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIE5hdGl2ZSBidWlsdGlu
cyB1c2VkIGFzIHN0YXRlbWVudHMgKGUuZy4gY2FsbCBtZW1vcnlfY29weSguLi4pKVxuICAgICAg
ICAgIGlmIChOQVRJVkVfQlVJTFRJTlMuaGFzKHN0bXQubmFtZSkpIHtcbiAgICAgICAgICAgIGVt
aXRGdW5jQ2FsbChzdG10LCBudWxsKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1c
biAgICAgICAgICAvLyBJbmRpcmVjdCBjYWxsIHZpYSBmdW5jdGlvbi10eXBlZCB2YXJpYWJsZSB1
c2VkIGFzIHN0YXRlbWVudFxuICAgICAgICAgIGNvbnN0IGNhbGxMb2NhbEluZm8gPSBsb2NhbE1h
cFtzdG10Lm5hbWVdO1xuICAgICAgICAgIGNvbnN0IGNhbGxHU2lnID0gZ2xvYmFsRnVuY1NpZ1tz
dG10Lm5hbWVdO1xuICAgICAgICAgIGlmICgoY2FsbExvY2FsSW5mbyAmJiBjYWxsTG9jYWxJbmZv
LmZ1bmNTaWcpIHx8IGNhbGxHU2lnKSB7XG4gICAgICAgICAgICBlbWl0RnVuY0NhbGwoc3RtdCwg
bnVsbCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gc3Vi
cm91dGluZSBjYWxsIG9yIGZ1bmN0aW9uIGNhbGwgKHJlc3VsdCBkaXNjYXJkZWQpXG4gICAgICAg
ICAgY29uc3QgZklkeCA9IGZ1bmNJbmRleFtzdG10Lm5hbWVdO1xuICAgICAgICAgIGlmIChmSWR4
ID09PSB1bmRlZmluZWQpIHRocm93IG5ldyBFcnJvcihgVW5kZWZpbmVkIGZ1bmN0aW9uOiAke3N0
bXQubmFtZX1gKTtcbiAgICAgICAgICBmb3IgKGxldCBhaSA9IDA7IGFpIDwgc3RtdC5hcmdzLmxl
bmd0aDsgYWkrKykge1xuICAgICAgICAgICAgLy8gaW5mZXIgcGFyYW0gdHlwZSBmcm9tIGRlY2xh
cmF0aW9uXG4gICAgICAgICAgICBjb25zdCBwYXJhbVR5cGUgPSBnZXRQYXJhbVR5cGUoc3RtdC5u
YW1lLCBhaSk7XG4gICAgICAgICAgICBlbWl0RXhwcihzdG10LmFyZ3NbYWldLCBwYXJhbVR5cGUp
O1xuICAgICAgICAgIH1cbiAgICAgICAgICBidy5ieXRlKE9QX0NBTEwpO1xuICAgICAgICAgIGJ3
LnUzMihmSWR4KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdU
YWlsQ2FsbCc6IHtcbiAgICAgICAgICBjb25zdCB0Y05hbWUgPSBzdG10Lm5hbWU7XG5cbiAgICAg
ICAgICAvLyBJbmRpcmVjdCB0YWlsIGNhbGwgdmlhIGZ1bmN0aW9uLXR5cGVkIHZhcmlhYmxlXG4g
ICAgICAgICAgY29uc3QgdGNMb2NhbEluZm8gPSBsb2NhbE1hcFt0Y05hbWVdO1xuICAgICAgICAg
IGNvbnN0IHRjR1NpZyA9IGdsb2JhbEZ1bmNTaWdbdGNOYW1lXTtcbiAgICAgICAgICBpZiAoKHRj
TG9jYWxJbmZvICYmIHRjTG9jYWxJbmZvLmZ1bmNTaWcpIHx8IHRjR1NpZykge1xuICAgICAgICAg
ICAgY29uc3Qgc2lnID0gKHRjTG9jYWxJbmZvICYmIHRjTG9jYWxJbmZvLmZ1bmNTaWcpIHx8IHRj
R1NpZztcbiAgICAgICAgICAgIGNvbnN0IGNhbGxlZVJldCA9IHNpZy5yZXRUeXBlIHx8IG51bGw7
XG4gICAgICAgICAgICBpZiAoY2FsbGVlUmV0ICE9PSByZXRUeXBlKVxuICAgICAgICAgICAgICB0
aHJvdyBuZXcgRXJyb3IoYHRhaWxjYWxsIHR5cGUgbWlzbWF0Y2g6ICR7dGNOYW1lfSByZXR1cm5z
ICR7Y2FsbGVlUmV0IHx8ICd2b2lkJ30sIGN1cnJlbnQgZnVuY3Rpb24gcmV0dXJucyAke3JldFR5
cGUgfHwgJ3ZvaWQnfWApO1xuICAgICAgICAgICAgZm9yIChsZXQgYWkgPSAwOyBhaSA8IHN0bXQu
YXJncy5sZW5ndGg7IGFpKyspIHtcbiAgICAgICAgICAgICAgY29uc3QgcHQgPSBzaWcucGFyYW1z
W2FpXSA/IChzaWcucGFyYW1zW2FpXS5pc0FycmF5ID8gJ2kzMicgOiBzaWcucGFyYW1zW2FpXS52
dHlwZSkgOiAnZjY0JztcbiAgICAgICAgICAgICAgZW1pdEV4cHIoc3RtdC5hcmdzW2FpXSwgcHQp
O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRjTG9jYWxJbmZvKSB7IGJ3LmJ5dGUo
T1BfTE9DQUxfR0VUKTsgYncudTMyKHRjTG9jYWxJbmZvLmlkeCk7IH1cbiAgICAgICAgICAgIGVs
c2UgeyBidy5ieXRlKE9QX0dMT0JBTF9HRVQpOyBidy51MzIoZ2xvYmFsSW5kZXhbdGNOYW1lXSk7
IH1cbiAgICAgICAgICAgIGNvbnN0IGluZGlyZWN0U2lnSWQgPSBnZXRPckFkZFNpZyhzaWcucGFy
YW1zLCBzaWcucmV0VHlwZSk7XG4gICAgICAgICAgICBidy5ieXRlKE9QX1JFVFVSTl9DQUxMX0lO
RElSRUNUKTtcbiAgICAgICAgICAgIGJ3LnUzMihpbmRpcmVjdFNpZ0lkKTtcbiAgICAgICAgICAg
IGJ3LnUzMigwKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAg
IC8vIERpcmVjdCB0YWlsIGNhbGwg4oCUIHR5cGUgdmFsaWRhdGlvblxuICAgICAgICAgIGNvbnN0
IGNhbGxlZUZuID0gZnVuY3Rpb25zLmZpbmQoZiA9PiBmLm5hbWUgPT09IHRjTmFtZSk7XG4gICAg
ICAgICAgY29uc3QgY2FsbGVlSW0gPSAhY2FsbGVlRm4gJiYgYWxsSW1wb3J0cy5maW5kKGkgPT4g
aS5uYW1lID09PSB0Y05hbWUpO1xuICAgICAgICAgIGNvbnN0IGNhbGxlZVJldCA9IGNhbGxlZUZu
ID8gKGNhbGxlZUZuLnR5cGUgPT09ICdTdWJyb3V0aW5lJyA/IG51bGwgOiBjYWxsZWVGbi5yZXRU
eXBlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICA6IGNhbGxlZUltID8gY2FsbGVlSW0ucmV0
VHlwZSA6IG51bGw7XG4gICAgICAgICAgaWYgKGNhbGxlZVJldCAhPT0gcmV0VHlwZSlcbiAgICAg
ICAgICAgIHRocm93IG5ldyBFcnJvcihgdGFpbGNhbGwgdHlwZSBtaXNtYXRjaDogJHt0Y05hbWV9
IHJldHVybnMgJHtjYWxsZWVSZXQgfHwgJ3ZvaWQnfSwgY3VycmVudCBmdW5jdGlvbiByZXR1cm5z
ICR7cmV0VHlwZSB8fCAndm9pZCd9YCk7XG5cbiAgICAgICAgICBjb25zdCB0Y0ZJZHggPSBmdW5j
SW5kZXhbdGNOYW1lXTtcbiAgICAgICAgICBpZiAodGNGSWR4ID09PSB1bmRlZmluZWQpIHRocm93
IG5ldyBFcnJvcihgVW5kZWZpbmVkIGZ1bmN0aW9uOiAke3RjTmFtZX1gKTtcbiAgICAgICAgICBm
b3IgKGxldCBhaSA9IDA7IGFpIDwgc3RtdC5hcmdzLmxlbmd0aDsgYWkrKykge1xuICAgICAgICAg
ICAgZW1pdEV4cHIoc3RtdC5hcmdzW2FpXSwgZ2V0UGFyYW1UeXBlKHRjTmFtZSwgYWkpKTtcbiAg
ICAgICAgICB9XG4gICAgICAgICAgYncuYnl0ZShPUF9SRVRVUk5fQ0FMTCk7XG4gICAgICAgICAg
YncudTMyKHRjRklkeCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZGVm
YXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gc3RhdGVtZW50IHR5cGU6
ICR7c3RtdC50eXBlfWApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFBhcmFt
VHlwZShmdW5jTmFtZSwgcGFyYW1JZHgpIHtcbiAgICAgIC8vIGNoZWNrIGxvY2FsIGZ1bmN0aW9u
c1xuICAgICAgY29uc3QgZm4gPSBmdW5jdGlvbnMuZmluZChmID0+IGYubmFtZSA9PT0gZnVuY05h
bWUpO1xuICAgICAgaWYgKGZuICYmIGZuLnBhcmFtc1twYXJhbUlkeF0pIHJldHVybiBmbi5wYXJh
bXNbcGFyYW1JZHhdLmlzQXJyYXkgPyAnaTMyJyA6IGZuLnBhcmFtc1twYXJhbUlkeF0udnR5cGU7
XG4gICAgICAvLyBjaGVjayBpbXBvcnRzXG4gICAgICBjb25zdCBpbSA9IGFsbEltcG9ydHMuZmlu
ZChpID0+IGkubmFtZSA9PT0gZnVuY05hbWUpO1xuICAgICAgaWYgKGltICYmIGltLnBhcmFtc1tw
YXJhbUlkeF0pIHJldHVybiBpbS5wYXJhbXNbcGFyYW1JZHhdLnZ0eXBlO1xuICAgICAgcmV0dXJu
ICdmNjQnOyAvLyBkZWZhdWx0XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVzb2x2ZVR5cGUobmFt
ZSkge1xuICAgICAgaWYgKGxvY2FsTWFwW25hbWVdKSByZXR1cm4gbG9jYWxNYXBbbmFtZV0udnR5
cGU7XG4gICAgICBpZiAoZ2xvYmFsSW5kZXhbbmFtZV0gIT09IHVuZGVmaW5lZCkgcmV0dXJuIGds
b2JhbHNbZ2xvYmFsSW5kZXhbbmFtZV1dLnZ0eXBlO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAg
fVxuXG4gICAgZnVuY3Rpb24gaW5mZXJFeHByVHlwZShleHByKSB7XG4gICAgICBzd2l0Y2ggKGV4
cHIudHlwZSkge1xuICAgICAgICBjYXNlICdOdW1iZXJMaXQnOiB7XG4gICAgICAgICAgaWYgKGV4
cHIudHlwZVN1ZmZpeCkgcmV0dXJuIGV4cHIudHlwZVN1ZmZpeDtcbiAgICAgICAgICBpZiAoZXhw
ci5pc0Zsb2F0IHx8IGV4cHIudmFsdWUuaW5jbHVkZXMoJy4nKSB8fCBleHByLnZhbHVlLmluY2x1
ZGVzKCdlJykgfHwgZXhwci52YWx1ZS5pbmNsdWRlcygnRScpKSByZXR1cm4gJ2Y2NCc7XG4gICAg
ICAgICAgcmV0dXJuICdpMzInO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ0lkZW50JzogcmV0
dXJuIHJlc29sdmVUeXBlKGV4cHIubmFtZSkgfHwgKHRhYmxlU2xvdFtleHByLm5hbWVdICE9PSB1
bmRlZmluZWQgPyAnaTMyJyA6IG51bGwpIHx8ICdmNjQnO1xuICAgICAgICBjYXNlICdCaW5PcCc6
IHJldHVybiBpbmZlckV4cHJUeXBlKGV4cHIubGVmdCk7XG4gICAgICAgIGNhc2UgJ1VuYXJ5T3An
OiByZXR1cm4gaW5mZXJFeHByVHlwZShleHByLm9wZXJhbmQpO1xuICAgICAgICBjYXNlICdGdW5j
Q2FsbCc6IHtcbiAgICAgICAgICAvLyB0eXBlIGNvbnZlcnNpb25zIC8gdmVjdG9yIGNvbnN0cnVj
dG9yc1xuICAgICAgICAgIGlmIChBVFJBX1RZUEVTLmhhcyhleHByLm5hbWUpKSByZXR1cm4gZXhw
ci5uYW1lO1xuICAgICAgICAgIC8vIFNJTUQgbmFtZXNwYWNlZCBidWlsdGluc1xuICAgICAgICAg
IGNvbnN0IGRvdElkeCA9IGV4cHIubmFtZS5pbmRleE9mKCcuJyk7XG4gICAgICAgICAgaWYgKGRv
dElkeCAhPT0gLTEpIHtcbiAgICAgICAgICAgIGNvbnN0IHByZWZpeCA9IGV4cHIubmFtZS5zbGlj
ZSgwLCBkb3RJZHgpO1xuICAgICAgICAgICAgY29uc3QgbWV0aG9kID0gZXhwci5uYW1lLnNsaWNl
KGRvdElkeCArIDEpO1xuICAgICAgICAgICAgaWYgKGlzVmVjdG9yKHByZWZpeCkpIHtcbiAgICAg
ICAgICAgICAgLy8gZXh0cmFjdF9sYW5lIHJldHVybnMgdGhlIHNjYWxhciB0eXBlXG4gICAgICAg
ICAgICAgIGlmIChtZXRob2QgPT09ICdleHRyYWN0X2xhbmUnKSByZXR1cm4gdmVjdG9yU2NhbGFy
VHlwZShwcmVmaXgpO1xuICAgICAgICAgICAgICAvLyBzcGxhdCwgcmVwbGFjZV9sYW5lLCBhZGQs
IHN1YiwgbXVsLCBkaXYsIG5lZywgYWJzLCBzcXJ0LCBlcSwgZXRjLiByZXR1cm4gdGhlIHZlY3Rv
ciB0eXBlXG4gICAgICAgICAgICAgIHJldHVybiBwcmVmaXg7XG4gICAgICAgICAgICB9XG4gICAg
ICAgICAgICBpZiAocHJlZml4ID09PSAndjEyOCcpIHtcbiAgICAgICAgICAgICAgLy8gdjEyOC5h
bmQvb3IveG9yL25vdC9sb2FkIHJldHVybiB2MTI4IOKAlCBpbmZlciBmcm9tIGZpcnN0IGFyZ1xu
ICAgICAgICAgICAgICBpZiAobWV0aG9kID09PSAnbG9hZCcpIHJldHVybiBpbmZlckV4cHJUeXBl
KGV4cHIuYXJnc1swXSkgfHwgJ2Y2NHgyJzsgLy8gZGVmYXVsdCB0byBmNjR4MlxuICAgICAgICAg
ICAgICBpZiAoWydhbmQnLCdvcicsJ3hvcicsJ25vdCddLmluY2x1ZGVzKG1ldGhvZCkpIHJldHVy
biBpbmZlckV4cHJUeXBlKGV4cHIuYXJnc1swXSk7XG4gICAgICAgICAgICAgIGlmIChtZXRob2Qg
PT09ICdzdG9yZScpIHJldHVybiAnaTMyJzsgLy8gc3RvcmUgaXMgYSBzdGF0ZW1lbnQsIGJ1dCB0
eXBlIGRvZXNuJ3QgbWF0dGVyIG11Y2hcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAg
ICAgICAgLy8gSW5kaXJlY3QgY2FsbCB2aWEgZnVuY3Rpb24tdHlwZWQgdmFyaWFibGVcbiAgICAg
ICAgICBjb25zdCBjYWxsSW5mbyA9IGxvY2FsTWFwW2V4cHIubmFtZV07XG4gICAgICAgICAgaWYg
KGNhbGxJbmZvICYmIGNhbGxJbmZvLmZ1bmNTaWcgJiYgY2FsbEluZm8uZnVuY1NpZy5yZXRUeXBl
KSByZXR1cm4gY2FsbEluZm8uZnVuY1NpZy5yZXRUeXBlO1xuICAgICAgICAgIGlmIChnbG9iYWxG
dW5jU2lnW2V4cHIubmFtZV0gJiYgZ2xvYmFsRnVuY1NpZ1tleHByLm5hbWVdLnJldFR5cGUpIHJl
dHVybiBnbG9iYWxGdW5jU2lnW2V4cHIubmFtZV0ucmV0VHlwZTtcbiAgICAgICAgICAvLyBrbm93
biByZXR1cm4gdHlwZXNcbiAgICAgICAgICBjb25zdCBmbiA9IGZ1bmN0aW9ucy5maW5kKGYgPT4g
Zi5uYW1lID09PSBleHByLm5hbWUpO1xuICAgICAgICAgIGlmIChmbiAmJiBmbi5yZXRUeXBlKSBy
ZXR1cm4gZm4ucmV0VHlwZTtcbiAgICAgICAgICByZXR1cm4gJ2Y2NCc7XG4gICAgICAgIH1cbiAg
ICAgICAgY2FzZSAnQXJyYXlBY2Nlc3MnOiB7XG4gICAgICAgICAgY29uc3QgaW5mbyA9IGxvY2Fs
TWFwW2V4cHIubmFtZV07XG4gICAgICAgICAgcmV0dXJuIGluZm8gPyAoaW5mby5lbGVtVHlwZSB8
fCBpbmZvLnZ0eXBlKSA6ICdmNjQnO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ0lmRXhwcic6
IHJldHVybiBpbmZlckV4cHJUeXBlKGV4cHIudGhlbkV4cHIpO1xuICAgICAgICBkZWZhdWx0OiBy
ZXR1cm4gJ2Y2NCc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZW1pdEV4cHIoZXhw
ciwgZXhwZWN0ZWRUeXBlKSB7XG4gICAgICBjb25zdCBhY3R1YWxUeXBlID0gZXhwZWN0ZWRUeXBl
IHx8IGluZmVyRXhwclR5cGUoZXhwcik7XG5cbiAgICAgIHN3aXRjaCAoZXhwci50eXBlKSB7XG4g
ICAgICAgIGNhc2UgJ051bWJlckxpdCc6IHtcbiAgICAgICAgICBjb25zdCB0ID0gZXhwZWN0ZWRU
eXBlIHx8IGluZmVyRXhwclR5cGUoZXhwcik7XG4gICAgICAgICAgY29uc3QgcmF3ID0gZXhwci52
YWx1ZTtcbiAgICAgICAgICBpZiAodCA9PT0gJ2kzMicpIHsgYncuYnl0ZShPUF9JMzJfQ09OU1Qp
OyBidy5zMzIocGFyc2VJbnQocmF3LCAxMCkgfCAwKTsgfVxuICAgICAgICAgIGVsc2UgaWYgKHQg
PT09ICdpNjQnKSB7IGJ3LmJ5dGUoT1BfSTY0X0NPTlNUKTsgYncuczY0KEJpZ0ludChwYXJzZUlu
dChyYXcsIDEwKSkpOyB9XG4gICAgICAgICAgZWxzZSBpZiAodCA9PT0gJ2YzMicpIHsgYncuYnl0
ZShPUF9GMzJfQ09OU1QpOyBidy5mMzIocGFyc2VGbG9hdChyYXcpKTsgfVxuICAgICAgICAgIGVs
c2UgeyBidy5ieXRlKE9QX0Y2NF9DT05TVCk7IGJ3LmY2NChwYXJzZUZsb2F0KHJhdykpOyB9XG4g
ICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnSWRlbnQnOiB7XG4gICAg
ICAgICAgY29uc3QgbmFtZSA9IGV4cHIubmFtZTtcbiAgICAgICAgICBpZiAobG9jYWxNYXBbbmFt
ZV0pIHsgYncuYnl0ZShPUF9MT0NBTF9HRVQpOyBidy51MzIobG9jYWxNYXBbbmFtZV0uaWR4KTsg
fVxuICAgICAgICAgIGVsc2UgaWYgKGdsb2JhbEluZGV4W25hbWVdICE9PSB1bmRlZmluZWQpIHsg
YncuYnl0ZShPUF9HTE9CQUxfR0VUKTsgYncudTMyKGdsb2JhbEluZGV4W25hbWVdKTsgfVxuICAg
ICAgICAgIGVsc2UgaWYgKHRhYmxlU2xvdFtuYW1lXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAg
ICAgICAvLyBCYXJlIGZ1bmN0aW9uIG5hbWUg4oaSIHRhYmxlIGluZGV4IChmb3IgY2FsbF9pbmRp
cmVjdClcbiAgICAgICAgICAgIGJ3LmJ5dGUoT1BfSTMyX0NPTlNUKTsgYncuczMyKHRhYmxlU2xv
dFtuYW1lXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgdGhyb3cgbmV3IEVycm9yKGBV
bmRlZmluZWQgdmFyaWFibGU6ICR7bmFtZX1gKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAg
fVxuICAgICAgICBjYXNlICdCaW5PcCc6IHtcbiAgICAgICAgICBjb25zdCB0ID0gZXhwZWN0ZWRU
eXBlIHx8IGluZmVyRXhwclR5cGUoZXhwcik7XG4gICAgICAgICAgZW1pdEJpbk9wKGV4cHIsIHQp
O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ1VuYXJ5T3AnOiB7
XG4gICAgICAgICAgY29uc3QgdCA9IGV4cGVjdGVkVHlwZSB8fCBpbmZlckV4cHJUeXBlKGV4cHIp
O1xuICAgICAgICAgIGlmIChleHByLm9wID09PSAnLScpIHtcbiAgICAgICAgICAgIGlmICh0ID09
PSAnZjY0JykgeyBlbWl0RXhwcihleHByLm9wZXJhbmQsIHQpOyBidy5ieXRlKE9QX0Y2NF9ORUcp
OyB9XG4gICAgICAgICAgICBlbHNlIGlmICh0ID09PSAnZjMyJykgeyBlbWl0RXhwcihleHByLm9w
ZXJhbmQsIHQpOyBidy5ieXRlKE9QX0YzMl9ORUcpOyB9XG4gICAgICAgICAgICBlbHNlIGlmICh0
ID09PSAnaTMyJykgeyBidy5ieXRlKE9QX0kzMl9DT05TVCk7IGJ3LnMzMigwKTsgZW1pdEV4cHIo
ZXhwci5vcGVyYW5kLCB0KTsgYncuYnl0ZShPUF9JMzJfU1VCKTsgfVxuICAgICAgICAgICAgZWxz
ZSBpZiAodCA9PT0gJ2k2NCcpIHsgYncuYnl0ZShPUF9JNjRfQ09OU1QpOyBidy5zNjQoMG4pOyBl
bWl0RXhwcihleHByLm9wZXJhbmQsIHQpOyBidy5ieXRlKE9QX0k2NF9TVUIpOyB9XG4gICAgICAg
ICAgICBlbHNlIGlmIChpc1ZlY3Rvcih0KSkgeyBlbWl0RXhwcihleHByLm9wZXJhbmQsIHQpOyBl
bWl0U2ltZChTSU1EX09QU1t0ICsgJy5uZWcnXSk7IH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGV4
cHIub3AgPT09ICdub3QnKSB7XG4gICAgICAgICAgICBlbWl0RXhwcihleHByLm9wZXJhbmQsICdp
MzInKTtcbiAgICAgICAgICAgIGJ3LmJ5dGUoT1BfSTMyX0VRWik7XG4gICAgICAgICAgfSBlbHNl
IGlmIChleHByLm9wID09PSAnficpIHtcbiAgICAgICAgICAgIGVtaXRFeHByKGV4cHIub3BlcmFu
ZCwgdCk7XG4gICAgICAgICAgICBpZiAodCA9PT0gJ2kzMicpIHsgYncuYnl0ZShPUF9JMzJfQ09O
U1QpOyBidy5zMzIoLTEpOyBidy5ieXRlKE9QX0kzMl9YT1IpOyB9XG4gICAgICAgICAgICBlbHNl
IGlmICh0ID09PSAnaTY0JykgeyBidy5ieXRlKE9QX0k2NF9DT05TVCk7IGJ3LnM2NCgtMW4pOyBi
dy5ieXRlKE9QX0k2NF9YT1IpOyB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVt
aXRFeHByKGV4cHIub3BlcmFuZCwgdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xu
ICAgICAgICB9XG4gICAgICAgIGNhc2UgJ0Z1bmNDYWxsJzoge1xuICAgICAgICAgIGVtaXRGdW5j
Q2FsbChleHByLCBleHBlY3RlZFR5cGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4g
ICAgICAgIGNhc2UgJ0FycmF5QWNjZXNzJzoge1xuICAgICAgICAgIGNvbnN0IGluZm8gPSBsb2Nh
bE1hcFtleHByLm5hbWVdO1xuICAgICAgICAgIGlmICghaW5mbykgdGhyb3cgbmV3IEVycm9yKGBV
bmRlZmluZWQgYXJyYXk6ICR7ZXhwci5uYW1lfWApO1xuICAgICAgICAgIGNvbnN0IGVsZW1UeXBl
ID0gaW5mby5lbGVtVHlwZSB8fCBpbmZvLnZ0eXBlO1xuICAgICAgICAgIGVtaXRBcnJheUFkZHIo
ZXhwci5uYW1lLCBleHByLmluZGljZXMsIGluZm8sIGVsZW1UeXBlKTtcbiAgICAgICAgICBlbWl0
TG9hZChlbGVtVHlwZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2Fz
ZSAnSWZFeHByJzoge1xuICAgICAgICAgIGNvbnN0IHQgPSBleHBlY3RlZFR5cGUgfHwgaW5mZXJF
eHByVHlwZShleHByLnRoZW5FeHByKTtcbiAgICAgICAgICBlbWl0RXhwcihleHByLmNvbmQsICdp
MzInKTtcbiAgICAgICAgICBidy5ieXRlKE9QX0lGKTtcbiAgICAgICAgICBidy5ieXRlKHdhc21U
eXBlKHQpKTtcbiAgICAgICAgICBlbWl0RXhwcihleHByLnRoZW5FeHByLCB0KTtcbiAgICAgICAg
ICBidy5ieXRlKE9QX0VMU0UpO1xuICAgICAgICAgIGVtaXRFeHByKGV4cHIuZWxzZUV4cHIsIHQp
O1xuICAgICAgICAgIGJ3LmJ5dGUoT1BfRU5EKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAg
fVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBl
eHByZXNzaW9uIHR5cGU6ICR7ZXhwci50eXBlfWApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1
bmN0aW9uIGVtaXRCaW5PcChleHByLCB0KSB7XG4gICAgICBjb25zdCBvcCA9IGV4cHIub3A7XG5c
biAgICAgIC8vIEV4cG9uZW50aWF0aW9uXG4gICAgICBpZiAob3AgPT09ICcqKicpIHtcbiAgICAg
ICAgZW1pdFBvdyhleHByLCB0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAv
LyBDb21wYXJpc29uIG9wZXJhdG9ycyByZXR1cm4gaTMyXG4gICAgICBpZiAob3AgPT09ICc9PScg
fHwgb3AgPT09ICcvPScgfHwgb3AgPT09ICc8JyB8fCBvcCA9PT0gJz4nIHx8IG9wID09PSAnPD0n
IHx8IG9wID09PSAnPj0nKSB7XG4gICAgICAgIGNvbnN0IG9wZXJhbmRUeXBlID0gaW5mZXJFeHBy
VHlwZShleHByLmxlZnQpO1xuICAgICAgICBlbWl0RXhwcihleHByLmxlZnQsIG9wZXJhbmRUeXBl
KTtcbiAgICAgICAgZW1pdEV4cHIoZXhwci5yaWdodCwgb3BlcmFuZFR5cGUpO1xuICAgICAgICBl
bWl0Q21wKG9wLCBvcGVyYW5kVHlwZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAg
ICAgLy8gTG9naWNhbDogYW5kLCBvclxuICAgICAgaWYgKG9wID09PSAnYW5kJykge1xuICAgICAg
ICBlbWl0RXhwcihleHByLmxlZnQsICdpMzInKTtcbiAgICAgICAgZW1pdEV4cHIoZXhwci5yaWdo
dCwgJ2kzMicpO1xuICAgICAgICBidy5ieXRlKE9QX0kzMl9BTkQpO1xuICAgICAgICByZXR1cm47
XG4gICAgICB9XG4gICAgICBpZiAob3AgPT09ICdvcicpIHtcbiAgICAgICAgZW1pdEV4cHIoZXhw
ci5sZWZ0LCAnaTMyJyk7XG4gICAgICAgIGVtaXRFeHByKGV4cHIucmlnaHQsICdpMzInKTtcbiAg
ICAgICAgYncuYnl0ZShPUF9JMzJfT1IpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAg
ICAgIGVtaXRFeHByKGV4cHIubGVmdCwgdCk7XG4gICAgICBlbWl0RXhwcihleHByLnJpZ2h0LCB0
KTtcblxuICAgICAgaWYgKG9wID09PSAnKycpIGVtaXRBZGQodCk7XG4gICAgICBlbHNlIGlmIChv
cCA9PT0gJy0nKSBlbWl0U3ViKHQpO1xuICAgICAgZWxzZSBpZiAob3AgPT09ICcqJykgZW1pdE11
bCh0KTtcbiAgICAgIGVsc2UgaWYgKG9wID09PSAnLycpIGVtaXREaXYodCk7XG4gICAgICBlbHNl
IGlmIChvcCA9PT0gJ21vZCcpIHtcbiAgICAgICAgaWYgKHQgPT09ICdpMzInKSBidy5ieXRlKE9Q
X0kzMl9SRU1fUyk7XG4gICAgICAgIGVsc2UgaWYgKHQgPT09ICdpNjQnKSBidy5ieXRlKE9QX0k2
NF9SRU1fUyk7XG4gICAgICAgIGVsc2UgdGhyb3cgbmV3IEVycm9yKCdtb2QgcmVxdWlyZXMgaW50
ZWdlciB0eXBlJyk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChvcCA9PT0gJyYnKSB7IGlmICh0
ID09PSAnaTMyJykgYncuYnl0ZShPUF9JMzJfQU5EKTsgZWxzZSBidy5ieXRlKE9QX0k2NF9BTkQp
OyB9XG4gICAgICBlbHNlIGlmIChvcCA9PT0gJ3wnKSB7IGlmICh0ID09PSAnaTMyJykgYncuYnl0
ZShPUF9JMzJfT1IpOyBlbHNlIGJ3LmJ5dGUoT1BfSTY0X09SKTsgfVxuICAgICAgZWxzZSBpZiAo
b3AgPT09ICdeJykgeyBpZiAodCA9PT0gJ2kzMicpIGJ3LmJ5dGUoT1BfSTMyX1hPUik7IGVsc2Ug
YncuYnl0ZShPUF9JNjRfWE9SKTsgfVxuICAgICAgZWxzZSBpZiAob3AgPT09ICc8PCcpIHsgaWYg
KHQgPT09ICdpMzInKSBidy5ieXRlKE9QX0kzMl9TSEwpOyBlbHNlIGJ3LmJ5dGUoT1BfSTY0X1NI
TCk7IH1cbiAgICAgIGVsc2UgaWYgKG9wID09PSAnPj4nKSB7IGlmICh0ID09PSAnaTMyJykgYncu
Ynl0ZShPUF9JMzJfU0hSX1MpOyBlbHNlIGJ3LmJ5dGUoT1BfSTY0X1NIUl9TKTsgfVxuICAgICAg
ZWxzZSB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gb3BlcmF0b3I6ICR7b3B9YCk7XG4gICAgfVxu
XG4gICAgZnVuY3Rpb24gZW1pdFBvdyhleHByLCB0KSB7XG4gICAgICAvLyAqKjAuNSDihpIgc3Fy
dFxuICAgICAgaWYgKGV4cHIucmlnaHQudHlwZSA9PT0gJ051bWJlckxpdCcgJiYgKGV4cHIucmln
aHQudmFsdWUgPT09ICcwLjUnIHx8IGV4cHIucmlnaHQudmFsdWUgPT09ICcuNScpKSB7XG4gICAg
ICAgIGVtaXRFeHByKGV4cHIubGVmdCwgdCk7XG4gICAgICAgIGlmICh0ID09PSAnZjY0JykgYncu
Ynl0ZShPUF9GNjRfU1FSVCk7XG4gICAgICAgIGVsc2UgaWYgKHQgPT09ICdmMzInKSBidy5ieXRl
KE9QX0YzMl9TUVJUKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gR2VuZXJh
bDogY2FsbCBwb3cgaW1wb3J0ICh3b3JrcyBmb3IgYWxsIGNhc2VzIGluY2x1ZGluZyAqKjIsICoq
MylcbiAgICAgIGVtaXRFeHByKGV4cHIubGVmdCwgJ2Y2NCcpO1xuICAgICAgZW1pdEV4cHIoZXhw
ci5yaWdodCwgJ2Y2NCcpO1xuICAgICAgYncuYnl0ZShPUF9DQUxMKTtcbiAgICAgIGJ3LnUzMihm
dW5jSW5kZXhbJ3BvdyddKTtcbiAgICAgIC8vIENvbnZlcnQgcmVzdWx0IGJhY2sgaWYgbmVlZGVk
XG4gICAgICBpZiAodCA9PT0gJ2YzMicpIGJ3LmJ5dGUoT1BfRjMyX0RFTU9URV9GNjQpO1xuICAg
IH1cblxuICAgIGZ1bmN0aW9uIGVtaXRGdW5jQ2FsbChleHByLCBleHBlY3RlZFR5cGUpIHtcbiAg
ICAgIGNvbnN0IG5hbWUgPSBleHByLm5hbWU7XG5cbiAgICAgIC8vIFZlY3RvciBjb25zdHJ1Y3Rv
cnM6IGY2NHgyKGEsIGIpLCBmMzJ4NChhLCBiLCBjLCBkKSwgZXRjLlxuICAgICAgaWYgKGlzVmVj
dG9yKG5hbWUpKSB7XG4gICAgICAgIGVtaXRWZWN0b3JDb25zdHJ1Y3RvcihuYW1lLCBleHByLmFy
Z3MpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFNjYWxhciB0eXBlIGNv
bnZlcnNpb25zOiBpMzIoeCksIGY2NCh4KSwgZXRjLlxuICAgICAgaWYgKEFUUkFfVFlQRVMuaGFz
KG5hbWUpKSB7XG4gICAgICAgIGNvbnN0IGZyb21UeXBlID0gaW5mZXJFeHByVHlwZShleHByLmFy
Z3NbMF0pO1xuICAgICAgICBjb25zdCB0b1R5cGUgPSBuYW1lO1xuICAgICAgICBlbWl0RXhwcihl
eHByLmFyZ3NbMF0sIGZyb21UeXBlKTtcbiAgICAgICAgZW1pdENvbnZlcnNpb24oZnJvbVR5cGUs
IHRvVHlwZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gU0lNRCBuYW1l
c3BhY2VkIGJ1aWx0aW5zOiBmNjR4Mi5zcGxhdCwgdjEyOC5hbmQsIGV0Yy5cbiAgICAgIGNvbnN0
IGRvdElkeCA9IG5hbWUuaW5kZXhPZignLicpO1xuICAgICAgaWYgKGRvdElkeCAhPT0gLTEpIHtc
biAgICAgICAgY29uc3QgcHJlZml4ID0gbmFtZS5zbGljZSgwLCBkb3RJZHgpO1xuICAgICAgICBj
b25zdCBtZXRob2QgPSBuYW1lLnNsaWNlKGRvdElkeCArIDEpO1xuICAgICAgICBpZiAoaXNWZWN0
b3IocHJlZml4KSB8fCBwcmVmaXggPT09ICd2MTI4Jykge1xuICAgICAgICAgIGVtaXRTaW1kQnVp
bHRpbihwcmVmaXgsIG1ldGhvZCwgZXhwciwgZXhwZWN0ZWRUeXBlKTtcbiAgICAgICAgICByZXR1
cm47XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gTmF0aXZlIGJ1aWx0aW5zIOKAlCB3
aXRoIHZlY3RvciB0eXBlIHN1cHBvcnRcbiAgICAgIGlmIChuYW1lID09PSAnc3FydCcpIHtcbiAg
ICAgICAgZW1pdEV4cHIoZXhwci5hcmdzWzBdLCBleHBlY3RlZFR5cGUpO1xuICAgICAgICBpZiAo
aXNWZWN0b3IoZXhwZWN0ZWRUeXBlKSkgeyBjb25zdCBvcCA9IFNJTURfT1BTW2V4cGVjdGVkVHlw
ZSArICcuc3FydCddOyBpZiAob3AgPT09IHVuZGVmaW5lZCkgdGhyb3cgbmV3IEVycm9yKCdzcXJ0
IG5vdCBzdXBwb3J0ZWQgZm9yICcgKyBleHBlY3RlZFR5cGUpOyBlbWl0U2ltZChvcCk7IH1cbiAg
ICAgICAgZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSAnZjMyJykgYncuYnl0ZShPUF9GMzJfU1FS
VCk7XG4gICAgICAgIGVsc2UgYncuYnl0ZShPUF9GNjRfU1FSVCk7XG4gICAgICAgIHJldHVybjtc
biAgICAgIH1cbiAgICAgIGlmIChuYW1lID09PSAnYWJzJykge1xuICAgICAgICBlbWl0RXhwcihl
eHByLmFyZ3NbMF0sIGV4cGVjdGVkVHlwZSk7XG4gICAgICAgIGlmIChpc1ZlY3RvcihleHBlY3Rl
ZFR5cGUpKSB7IGNvbnN0IG9wID0gU0lNRF9PUFNbZXhwZWN0ZWRUeXBlICsgJy5hYnMnXTsgaWYg
KG9wID09PSB1bmRlZmluZWQpIHRocm93IG5ldyBFcnJvcignYWJzIG5vdCBzdXBwb3J0ZWQgZm9y
ICcgKyBleHBlY3RlZFR5cGUpOyBlbWl0U2ltZChvcCk7IH1cbiAgICAgICAgZWxzZSBpZiAoZXhw
ZWN0ZWRUeXBlID09PSAnZjMyJykgYncuYnl0ZShPUF9GMzJfQUJTKTtcbiAgICAgICAgZWxzZSBi
dy5ieXRlKE9QX0Y2NF9BQlMpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAo
bmFtZSA9PT0gJ2Zsb29yJykgeyBlbWl0RXhwcihleHByLmFyZ3NbMF0sIGV4cGVjdGVkVHlwZSk7
IGlmIChleHBlY3RlZFR5cGUgPT09ICdmMzInKSBidy5ieXRlKE9QX0YzMl9GTE9PUik7IGVsc2Ug
YncuYnl0ZShPUF9GNjRfRkxPT1IpOyByZXR1cm47IH1cbiAgICAgIGlmIChuYW1lID09PSAnY2Vp
bCcpIHsgZW1pdEV4cHIoZXhwci5hcmdzWzBdLCBleHBlY3RlZFR5cGUpOyBpZiAoZXhwZWN0ZWRU
eXBlID09PSAnZjMyJykgYncuYnl0ZShPUF9GMzJfQ0VJTCk7IGVsc2UgYncuYnl0ZShPUF9GNjRf
Q0VJTCk7IHJldHVybjsgfVxuICAgICAgaWYgKG5hbWUgPT09ICd0cnVuYycpIHsgZW1pdEV4cHIo
ZXhwci5hcmdzWzBdLCBleHBlY3RlZFR5cGUpOyBpZiAoZXhwZWN0ZWRUeXBlID09PSAnZjMyJykg
YncuYnl0ZShPUF9GMzJfVFJVTkMpOyBlbHNlIGJ3LmJ5dGUoT1BfRjY0X1RSVU5DKTsgcmV0dXJu
OyB9XG4gICAgICBpZiAobmFtZSA9PT0gJ25lYXJlc3QnKSB7IGVtaXRFeHByKGV4cHIuYXJnc1sw
XSwgZXhwZWN0ZWRUeXBlKTsgaWYgKGV4cGVjdGVkVHlwZSA9PT0gJ2YzMicpIGJ3LmJ5dGUoT1Bf
RjMyX05FQVJFU1QpOyBlbHNlIGJ3LmJ5dGUoT1BfRjY0X05FQVJFU1QpOyByZXR1cm47IH1cbiAg
ICAgIGlmIChuYW1lID09PSAnbWluJykge1xuICAgICAgICBlbWl0RXhwcihleHByLmFyZ3NbMF0s
IGV4cGVjdGVkVHlwZSk7IGVtaXRFeHByKGV4cHIuYXJnc1sxXSwgZXhwZWN0ZWRUeXBlKTtcbiAg
ICAgICAgaWYgKGlzVmVjdG9yKGV4cGVjdGVkVHlwZSkpIHsgY29uc3Qgb3AgPSBTSU1EX09QU1tl
eHBlY3RlZFR5cGUgKyAnLm1pbiddOyBpZiAob3AgPT09IHVuZGVmaW5lZCkgdGhyb3cgbmV3IEVy
cm9yKCdtaW4gbm90IHN1cHBvcnRlZCBmb3IgJyArIGV4cGVjdGVkVHlwZSk7IGVtaXRTaW1kKG9w
KTsgfVxuICAgICAgICBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09ICdmMzInKSBidy5ieXRlKE9Q
X0YzMl9NSU4pO1xuICAgICAgICBlbHNlIGJ3LmJ5dGUoT1BfRjY0X01JTik7XG4gICAgICAgIHJl
dHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChuYW1lID09PSAnbWF4Jykge1xuICAgICAgICBlbWl0
RXhwcihleHByLmFyZ3NbMF0sIGV4cGVjdGVkVHlwZSk7IGVtaXRFeHByKGV4cHIuYXJnc1sxXSwg
ZXhwZWN0ZWRUeXBlKTtcbiAgICAgICAgaWYgKGlzVmVjdG9yKGV4cGVjdGVkVHlwZSkpIHsgY29u
c3Qgb3AgPSBTSU1EX09QU1tleHBlY3RlZFR5cGUgKyAnLm1heCddOyBpZiAob3AgPT09IHVuZGVm
aW5lZCkgdGhyb3cgbmV3IEVycm9yKCdtYXggbm90IHN1cHBvcnRlZCBmb3IgJyArIGV4cGVjdGVk
VHlwZSk7IGVtaXRTaW1kKG9wKTsgfVxuICAgICAgICBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09
ICdmMzInKSBidy5ieXRlKE9QX0YzMl9NQVgpO1xuICAgICAgICBlbHNlIGJ3LmJ5dGUoT1BfRjY0
X01BWCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChuYW1lID09PSAnY29w
eXNpZ24nKSB7IGVtaXRFeHByKGV4cHIuYXJnc1swXSwgZXhwZWN0ZWRUeXBlKTsgZW1pdEV4cHIo
ZXhwci5hcmdzWzFdLCBleHBlY3RlZFR5cGUpOyBpZiAoZXhwZWN0ZWRUeXBlID09PSAnZjMyJykg
YncuYnl0ZShPUF9GMzJfQ09QWVNJR04pOyBlbHNlIGJ3LmJ5dGUoT1BfRjY0X0NPUFlTSUdOKTsg
cmV0dXJuOyB9XG4gICAgICBpZiAobmFtZSA9PT0gJ3NlbGVjdCcpIHtcbiAgICAgICAgLy8gc2Vs
ZWN0KGEsIGIsIGNvbmQpIOKAlCBXYXNtIHNlbGVjdCBwaWNrcyBhIGlmIGNvbmQhPTAsIGIgb3Ro
ZXJ3aXNlXG4gICAgICAgIGNvbnN0IHQgPSBleHBlY3RlZFR5cGUgfHwgaW5mZXJFeHByVHlwZShl
eHByLmFyZ3NbMF0pO1xuICAgICAgICBlbWl0RXhwcihleHByLmFyZ3NbMF0sIHQpO1xuICAgICAg
ICBlbWl0RXhwcihleHByLmFyZ3NbMV0sIHQpO1xuICAgICAgICBlbWl0RXhwcihleHByLmFyZ3Nb
Ml0sICdpMzInKTtcbiAgICAgICAgYncuYnl0ZShPUF9TRUxFQ1QpO1xuICAgICAgICByZXR1cm47
XG4gICAgICB9XG4gICAgICBpZiAobmFtZSA9PT0gJ2NseicpIHsgZW1pdEV4cHIoZXhwci5hcmdz
WzBdLCBleHBlY3RlZFR5cGUpOyBpZiAoZXhwZWN0ZWRUeXBlID09PSAnaTY0JykgYncuYnl0ZShP
UF9JNjRfQ0xaKTsgZWxzZSBidy5ieXRlKE9QX0kzMl9DTFopOyByZXR1cm47IH1cbiAgICAgIGlm
IChuYW1lID09PSAnY3R6JykgeyBlbWl0RXhwcihleHByLmFyZ3NbMF0sIGV4cGVjdGVkVHlwZSk7
IGlmIChleHBlY3RlZFR5cGUgPT09ICdpNjQnKSBidy5ieXRlKE9QX0k2NF9DVFopOyBlbHNlIGJ3
LmJ5dGUoT1BfSTMyX0NUWik7IHJldHVybjsgfVxuICAgICAgaWYgKG5hbWUgPT09ICdwb3BjbnQn
KSB7IGVtaXRFeHByKGV4cHIuYXJnc1swXSwgZXhwZWN0ZWRUeXBlKTsgaWYgKGV4cGVjdGVkVHlw
ZSA9PT0gJ2k2NCcpIGJ3LmJ5dGUoT1BfSTY0X1BPUENOVCk7IGVsc2UgYncuYnl0ZShPUF9JMzJf
UE9QQ05UKTsgcmV0dXJuOyB9XG4gICAgICBpZiAobmFtZSA9PT0gJ3JvdGwnKSB7IGVtaXRFeHBy
KGV4cHIuYXJnc1swXSwgZXhwZWN0ZWRUeXBlKTsgZW1pdEV4cHIoZXhwci5hcmdzWzFdLCBleHBl
Y3RlZFR5cGUpOyBpZiAoZXhwZWN0ZWRUeXBlID09PSAnaTY0JykgYncuYnl0ZShPUF9JNjRfUk9U
TCk7IGVsc2UgYncuYnl0ZShPUF9JMzJfUk9UTCk7IHJldHVybjsgfVxuICAgICAgaWYgKG5hbWUg
PT09ICdyb3RyJykgeyBlbWl0RXhwcihleHByLmFyZ3NbMF0sIGV4cGVjdGVkVHlwZSk7IGVtaXRF
eHByKGV4cHIuYXJnc1sxXSwgZXhwZWN0ZWRUeXBlKTsgaWYgKGV4cGVjdGVkVHlwZSA9PT0gJ2k2
NCcpIGJ3LmJ5dGUoT1BfSTY0X1JPVFIpOyBlbHNlIGJ3LmJ5dGUoT1BfSTMyX1JPVFIpOyByZXR1
cm47IH1cbiAgICAgIGlmIChuYW1lID09PSAnbWVtb3J5X3NpemUnKSB7IGJ3LmJ5dGUoT1BfTUVN
T1JZX1NJWkUpOyBidy51MzIoMCk7IHJldHVybjsgfVxuICAgICAgaWYgKG5hbWUgPT09ICdtZW1v
cnlfZ3JvdycpIHsgZW1pdEV4cHIoZXhwci5hcmdzWzBdLCAnaTMyJyk7IGJ3LmJ5dGUoT1BfTUVN
T1JZX0dST1cpOyBidy51MzIoMCk7IHJldHVybjsgfVxuICAgICAgaWYgKG5hbWUgPT09ICdtZW1v
cnlfY29weScpIHtcbiAgICAgICAgZW1pdEV4cHIoZXhwci5hcmdzWzBdLCAnaTMyJyk7IGVtaXRF
eHByKGV4cHIuYXJnc1sxXSwgJ2kzMicpOyBlbWl0RXhwcihleHByLmFyZ3NbMl0sICdpMzInKTtc
biAgICAgICAgYncuYnl0ZShPUF9GQ19QUkVGSVgpOyBidy51MzIoMTApOyBidy51MzIoMCk7IGJ3
LnUzMigwKTsgLy8gbWVtb3J5LmNvcHksIGRzdF9tZW09MCwgc3JjX21lbT0wXG4gICAgICAgIHJl
dHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChuYW1lID09PSAnbWVtb3J5X2ZpbGwnKSB7XG4gICAg
ICAgIGVtaXRFeHByKGV4cHIuYXJnc1swXSwgJ2kzMicpOyBlbWl0RXhwcihleHByLmFyZ3NbMV0s
ICdpMzInKTsgZW1pdEV4cHIoZXhwci5hcmdzWzJdLCAnaTMyJyk7XG4gICAgICAgIGJ3LmJ5dGUo
T1BfRkNfUFJFRklYKTsgYncudTMyKDExKTsgYncudTMyKDApOyAvLyBtZW1vcnkuZmlsbCwgbWVt
PTBcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyB3YXNtLiogZXNjYXBlIGhh
dGNoXG4gICAgICBpZiAobmFtZS5zdGFydHNXaXRoKCd3YXNtLicpKSB7XG4gICAgICAgIGVtaXRX
YXNtQnVpbHRpbihuYW1lLnNsaWNlKDUpLCBleHByLCBleHBlY3RlZFR5cGUpO1xuICAgICAgICBy
ZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIEluZGlyZWN0IGNhbGwgdmlhIGZ1bmN0aW9uLXR5
cGVkIHZhcmlhYmxlXG4gICAgICBjb25zdCBsb2NhbEluZm8gPSBsb2NhbE1hcFtuYW1lXTtcbiAg
ICAgIGNvbnN0IGdTaWcgPSBnbG9iYWxGdW5jU2lnW25hbWVdO1xuICAgICAgaWYgKChsb2NhbElu
Zm8gJiYgbG9jYWxJbmZvLmZ1bmNTaWcpIHx8IGdTaWcpIHtcbiAgICAgICAgY29uc3Qgc2lnID0g
KGxvY2FsSW5mbyAmJiBsb2NhbEluZm8uZnVuY1NpZykgfHwgZ1NpZztcbiAgICAgICAgLy8gRW1p
dCBhcmd1bWVudHMgdXNpbmcgZnVuY1NpZyBwYXJhbSB0eXBlc1xuICAgICAgICBmb3IgKGxldCBh
aSA9IDA7IGFpIDwgZXhwci5hcmdzLmxlbmd0aDsgYWkrKykge1xuICAgICAgICAgIGNvbnN0IHB0
ID0gc2lnLnBhcmFtc1thaV0gPyAoc2lnLnBhcmFtc1thaV0uaXNBcnJheSA/ICdpMzInIDogc2ln
LnBhcmFtc1thaV0udnR5cGUpIDogJ2Y2NCc7XG4gICAgICAgICAgZW1pdEV4cHIoZXhwci5hcmdz
W2FpXSwgcHQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFB1c2ggdGhlIHRhYmxlIGluZGV4ICh0
aGUgdmFyaWFibGUgdmFsdWUpXG4gICAgICAgIGlmIChsb2NhbEluZm8pIHsgYncuYnl0ZShPUF9M
T0NBTF9HRVQpOyBidy51MzIobG9jYWxJbmZvLmlkeCk7IH1cbiAgICAgICAgZWxzZSB7IGJ3LmJ5
dGUoT1BfR0xPQkFMX0dFVCk7IGJ3LnUzMihnbG9iYWxJbmRleFtuYW1lXSk7IH1cbiAgICAgICAg
Ly8gY2FsbF9pbmRpcmVjdCB0eXBlX2luZGV4IHRhYmxlX2luZGV4XG4gICAgICAgIGNvbnN0IGlu
ZGlyZWN0U2lnSWQgPSBnZXRPckFkZFNpZyhzaWcucGFyYW1zLCBzaWcucmV0VHlwZSk7XG4gICAg
ICAgIGJ3LmJ5dGUoT1BfQ0FMTF9JTkRJUkVDVCk7XG4gICAgICAgIGJ3LnUzMihpbmRpcmVjdFNp
Z0lkKTtcbiAgICAgICAgYncudTMyKDApOyAvLyB0YWJsZSBpbmRleCAwXG4gICAgICAgIHJldHVy
bjtcbiAgICAgIH1cblxuICAgICAgLy8gUmVndWxhciBmdW5jdGlvbiBjYWxsXG4gICAgICBjb25z
dCBmSWR4ID0gZnVuY0luZGV4W25hbWVdO1xuICAgICAgaWYgKGZJZHggPT09IHVuZGVmaW5lZCkg
dGhyb3cgbmV3IEVycm9yKGBVbmRlZmluZWQgZnVuY3Rpb246ICR7bmFtZX1gKTtcbiAgICAgIGZv
ciAobGV0IGFpID0gMDsgYWkgPCBleHByLmFyZ3MubGVuZ3RoOyBhaSsrKSB7XG4gICAgICAgIGNv
bnN0IHBhcmFtVHlwZSA9IGdldFBhcmFtVHlwZShuYW1lLCBhaSk7XG4gICAgICAgIGVtaXRFeHBy
KGV4cHIuYXJnc1thaV0sIHBhcmFtVHlwZSk7XG4gICAgICB9XG4gICAgICBidy5ieXRlKE9QX0NB
TEwpO1xuICAgICAgYncudTMyKGZJZHgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVtaXRXYXNt
QnVpbHRpbihvcCwgZXhwciwgZXhwZWN0ZWRUeXBlKSB7XG4gICAgICBjb25zdCB0ID0gZXhwZWN0
ZWRUeXBlIHx8ICdpMzInO1xuICAgICAgaWYgKG9wID09PSAnZGl2X3UnKSB7IGVtaXRFeHByKGV4
cHIuYXJnc1swXSwgdCk7IGVtaXRFeHByKGV4cHIuYXJnc1sxXSwgdCk7IGJ3LmJ5dGUodCA9PT0g
J2k2NCcgPyBPUF9JNjRfRElWX1UgOiBPUF9JMzJfRElWX1UpOyByZXR1cm47IH1cbiAgICAgIGlm
IChvcCA9PT0gJ3JlbV91JykgeyBlbWl0RXhwcihleHByLmFyZ3NbMF0sIHQpOyBlbWl0RXhwcihl
eHByLmFyZ3NbMV0sIHQpOyBidy5ieXRlKHQgPT09ICdpNjQnID8gT1BfSTY0X1JFTV9VIDogT1Bf
STMyX1JFTV9VKTsgcmV0dXJuOyB9XG4gICAgICBpZiAob3AgPT09ICdzaHJfdScpIHsgZW1pdEV4
cHIoZXhwci5hcmdzWzBdLCB0KTsgZW1pdEV4cHIoZXhwci5hcmdzWzFdLCB0KTsgYncuYnl0ZSh0
ID09PSAnaTY0JyA/IE9QX0k2NF9TSFJfVSA6IE9QX0kzMl9TSFJfVSk7IHJldHVybjsgfVxuICAg
ICAgaWYgKG9wID09PSAnbHRfdScpIHsgZW1pdEV4cHIoZXhwci5hcmdzWzBdLCB0KTsgZW1pdEV4
cHIoZXhwci5hcmdzWzFdLCB0KTsgYncuYnl0ZSh0ID09PSAnaTY0JyA/IE9QX0k2NF9MVF9VIDog
T1BfSTMyX0xUX1UpOyByZXR1cm47IH1cbiAgICAgIGlmIChvcCA9PT0gJ2d0X3UnKSB7IGVtaXRF
eHByKGV4cHIuYXJnc1swXSwgdCk7IGVtaXRFeHByKGV4cHIuYXJnc1sxXSwgdCk7IGJ3LmJ5dGUo
dCA9PT0gJ2k2NCcgPyBPUF9JNjRfR1RfVSA6IE9QX0kzMl9HVF9VKTsgcmV0dXJuOyB9XG4gICAg
ICBpZiAob3AgPT09ICdsZV91JykgeyBlbWl0RXhwcihleHByLmFyZ3NbMF0sIHQpOyBlbWl0RXhw
cihleHByLmFyZ3NbMV0sIHQpOyBidy5ieXRlKHQgPT09ICdpNjQnID8gT1BfSTY0X0xFX1UgOiBP
UF9JMzJfTEVfVSk7IHJldHVybjsgfVxuICAgICAgaWYgKG9wID09PSAnZ2VfdScpIHsgZW1pdEV4
cHIoZXhwci5hcmdzWzBdLCB0KTsgZW1pdEV4cHIoZXhwci5hcmdzWzFdLCB0KTsgYncuYnl0ZSh0
ID09PSAnaTY0JyA/IE9QX0k2NF9HRV9VIDogT1BfSTMyX0dFX1UpOyByZXR1cm47IH1cbiAgICAg
IGlmIChvcCA9PT0gJ3JlaW50ZXJwcmV0X2Y2NCcpIHsgZW1pdEV4cHIoZXhwci5hcmdzWzBdLCAn
ZjY0Jyk7IGJ3LmJ5dGUoT1BfSTY0X1JFSU5URVJQUkVUX0Y2NCk7IHJldHVybjsgfVxuICAgICAg
aWYgKG9wID09PSAncmVpbnRlcnByZXRfZjMyJykgeyBlbWl0RXhwcihleHByLmFyZ3NbMF0sICdm
MzInKTsgYncuYnl0ZShPUF9JMzJfUkVJTlRFUlBSRVRfRjMyKTsgcmV0dXJuOyB9XG4gICAgICBp
ZiAob3AgPT09ICdyZWludGVycHJldF9pNjQnKSB7IGVtaXRFeHByKGV4cHIuYXJnc1swXSwgJ2k2
NCcpOyBidy5ieXRlKE9QX0Y2NF9SRUlOVEVSUFJFVF9JNjQpOyByZXR1cm47IH1cbiAgICAgIGlm
IChvcCA9PT0gJ3JlaW50ZXJwcmV0X2kzMicpIHsgZW1pdEV4cHIoZXhwci5hcmdzWzBdLCAnaTMy
Jyk7IGJ3LmJ5dGUoT1BfRjMyX1JFSU5URVJQUkVUX0kzMik7IHJldHVybjsgfVxuICAgICAgaWYg
KG9wID09PSAnZXh0ZW5kOF9zJykgeyBlbWl0RXhwcihleHByLmFyZ3NbMF0sIHQpOyBidy5ieXRl
KHQgPT09ICdpNjQnID8gT1BfSTY0X0VYVEVORDhfUyA6IE9QX0kzMl9FWFRFTkQ4X1MpOyByZXR1
cm47IH1cbiAgICAgIGlmIChvcCA9PT0gJ2V4dGVuZDE2X3MnKSB7IGVtaXRFeHByKGV4cHIuYXJn
c1swXSwgdCk7IGJ3LmJ5dGUodCA9PT0gJ2k2NCcgPyBPUF9JNjRfRVhURU5EMTZfUyA6IE9QX0kz
Ml9FWFRFTkQxNl9TKTsgcmV0dXJuOyB9XG4gICAgICBpZiAob3AgPT09ICd0cnVuY19zYXRfcycp
IHtcbiAgICAgICAgY29uc3QgZnJvbVR5cGUgPSBpbmZlckV4cHJUeXBlKGV4cHIuYXJnc1swXSk7
XG4gICAgICAgIGVtaXRFeHByKGV4cHIuYXJnc1swXSwgZnJvbVR5cGUpO1xuICAgICAgICBidy5i
eXRlKE9QX0ZDX1BSRUZJWCk7XG4gICAgICAgIGlmICh0ID09PSAnaTMyJyAmJiBmcm9tVHlwZSA9
PT0gJ2YzMicpIGJ3LnUzMihPUF9JMzJfVFJVTkNfU0FUX0YzMl9TKTtcbiAgICAgICAgZWxzZSBp
ZiAodCA9PT0gJ2kzMicgJiYgZnJvbVR5cGUgPT09ICdmNjQnKSBidy51MzIoT1BfSTMyX1RSVU5D
X1NBVF9GNjRfUyk7XG4gICAgICAgIGVsc2UgaWYgKHQgPT09ICdpNjQnICYmIGZyb21UeXBlID09
PSAnZjMyJykgYncudTMyKE9QX0k2NF9UUlVOQ19TQVRfRjMyX1MpO1xuICAgICAgICBlbHNlIGlm
ICh0ID09PSAnaTY0JyAmJiBmcm9tVHlwZSA9PT0gJ2Y2NCcpIGJ3LnUzMihPUF9JNjRfVFJVTkNf
U0FUX0Y2NF9TKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKG9wID09PSAn
dHJ1bmNfc2F0X3UnKSB7XG4gICAgICAgIGNvbnN0IGZyb21UeXBlID0gaW5mZXJFeHByVHlwZShl
eHByLmFyZ3NbMF0pO1xuICAgICAgICBlbWl0RXhwcihleHByLmFyZ3NbMF0sIGZyb21UeXBlKTtc
biAgICAgICAgYncuYnl0ZShPUF9GQ19QUkVGSVgpO1xuICAgICAgICBpZiAodCA9PT0gJ2kzMicg
JiYgZnJvbVR5cGUgPT09ICdmMzInKSBidy51MzIoT1BfSTMyX1RSVU5DX1NBVF9GMzJfVSk7XG4g
ICAgICAgIGVsc2UgaWYgKHQgPT09ICdpMzInICYmIGZyb21UeXBlID09PSAnZjY0JykgYncudTMy
KE9QX0kzMl9UUlVOQ19TQVRfRjY0X1UpO1xuICAgICAgICBlbHNlIGlmICh0ID09PSAnaTY0JyAm
JiBmcm9tVHlwZSA9PT0gJ2YzMicpIGJ3LnUzMihPUF9JNjRfVFJVTkNfU0FUX0YzMl9VKTtcbiAg
ICAgICAgZWxzZSBpZiAodCA9PT0gJ2k2NCcgJiYgZnJvbVR5cGUgPT09ICdmNjQnKSBidy51MzIo
T1BfSTY0X1RSVU5DX1NBVF9GNjRfVSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAg
IHRocm93IG5ldyBFcnJvcihgVW5rbm93biB3YXNtIGJ1aWx0aW46IHdhc20uJHtvcH1gKTtcbiAg
ICB9XG5cbiAgICBmdW5jdGlvbiBlbWl0VmVjdG9yQ29uc3RydWN0b3IodmVjVHlwZSwgYXJncykg
e1xuICAgICAgY29uc3Qgc2NhbGFyID0gdmVjdG9yU2NhbGFyVHlwZSh2ZWNUeXBlKTtcbiAgICAg
IGNvbnN0IGxhbmVDb3VudCA9IHZlY1R5cGUgPT09ICdmMzJ4NCcgfHwgdmVjVHlwZSA9PT0gJ2kz
Mng0JyA/IDQgOiAyO1xuXG4gICAgICBpZiAoYXJncy5sZW5ndGggIT09IGxhbmVDb3VudCkgdGhy
b3cgbmV3IEVycm9yKGAke3ZlY1R5cGV9IGNvbnN0cnVjdG9yIGV4cGVjdHMgJHtsYW5lQ291bnR9
IGFyZ3MsIGdvdCAke2FyZ3MubGVuZ3RofWApO1xuXG4gICAgICAvLyBDaGVjayBpZiBhbGwgYXJn
cyBhcmUgY29uc3RhbnQgKE51bWJlckxpdCBvciBuZWdhdGl2ZSBOdW1iZXJMaXQpXG4gICAgICBj
b25zdCBhbGxDb25zdCA9IGFyZ3MuZXZlcnkoYSA9PlxuICAgICAgICBhLnR5cGUgPT09ICdOdW1i
ZXJMaXQnIHx8XG4gICAgICAgIChhLnR5cGUgPT09ICdVbmFyeU9wJyAmJiBhLm9wID09PSAnLScg
JiYgYS5vcGVyYW5kLnR5cGUgPT09ICdOdW1iZXJMaXQnKSk7XG5cbiAgICAgIGlmIChhbGxDb25z
dCkge1xuICAgICAgICAvLyBFbWl0IHYxMjguY29uc3Qgd2l0aCBpbmxpbmUgYnl0ZXNcbiAgICAg
ICAgZW1pdFNpbWQoU0lNRF9PUFNbJ3YxMjguY29uc3QnXSk7XG4gICAgICAgIGNvbnN0IGFidWYg
PSBuZXcgQXJyYXlCdWZmZXIoMTYpO1xuICAgICAgICBjb25zdCB2aWV3ID0gbmV3IERhdGFWaWV3
KGFidWYpO1xuICAgICAgICBmb3IgKGxldCBsaSA9IDA7IGxpIDwgbGFuZUNvdW50OyBsaSsrKSB7
XG4gICAgICAgICAgY29uc3QgYSA9IGFyZ3NbbGldO1xuICAgICAgICAgIGNvbnN0IHJhdyA9IGEu
dHlwZSA9PT0gJ051bWJlckxpdCcgPyBhLnZhbHVlIDogYS5vcGVyYW5kLnZhbHVlO1xuICAgICAg
ICAgIGNvbnN0IHZhbCA9IGEudHlwZSA9PT0gJ1VuYXJ5T3AnID8gLXBhcnNlRmxvYXQocmF3KSA6
IHBhcnNlRmxvYXQocmF3KTtcbiAgICAgICAgICBpZiAoc2NhbGFyID09PSAnZjY0Jykgdmlldy5z
ZXRGbG9hdDY0KGxpICogOCwgdmFsLCB0cnVlKTtcbiAgICAgICAgICBlbHNlIGlmIChzY2FsYXIg
PT09ICdmMzInKSB2aWV3LnNldEZsb2F0MzIobGkgKiA0LCB2YWwsIHRydWUpO1xuICAgICAgICAg
IGVsc2UgaWYgKHNjYWxhciA9PT0gJ2kzMicpIHZpZXcuc2V0SW50MzIobGkgKiA0LCB2YWwgfCAw
LCB0cnVlKTtcbiAgICAgICAgICBlbHNlIGlmIChzY2FsYXIgPT09ICdpNjQnKSB7XG4gICAgICAg
ICAgICAvLyBCaWdJbnQ2NCBhcyB0d28gaTMycywgbGl0dGxlLWVuZGlhblxuICAgICAgICAgICAg
Y29uc3QgYnYgPSBCaWdJbnQoTWF0aC50cnVuYyh2YWwpKTtcbiAgICAgICAgICAgIHZpZXcuc2V0
SW50MzIobGkgKiA4LCBOdW1iZXIoYnYgJiAweGZmZmZmZmZmbiksIHRydWUpO1xuICAgICAgICAg
ICAgdmlldy5zZXRJbnQzMihsaSAqIDggKyA0LCBOdW1iZXIoKGJ2ID4+IDMybikgJiAweGZmZmZm
ZmZmbiksIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBidy5ieXRlcyhu
ZXcgVWludDhBcnJheShhYnVmKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBTcGxhdCBm
aXJzdCBhcmcsIHRoZW4gcmVwbGFjZV9sYW5lIGZvciB0aGUgcmVzdFxuICAgICAgICBlbWl0RXhw
cihhcmdzWzBdLCBzY2FsYXIpO1xuICAgICAgICBlbWl0U2ltZChTSU1EX09QU1t2ZWNUeXBlICsg
Jy5zcGxhdCddKTtcbiAgICAgICAgZm9yIChsZXQgbGkgPSAxOyBsaSA8IGxhbmVDb3VudDsgbGkr
Kykge1xuICAgICAgICAgIGVtaXRFeHByKGFyZ3NbbGldLCBzY2FsYXIpO1xuICAgICAgICAgIGVt
aXRTaW1kKFNJTURfT1BTW3ZlY1R5cGUgKyAnLnJlcGxhY2VfbGFuZSddKTtcbiAgICAgICAgICBi
dy5ieXRlKGxpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVt
aXRTaW1kQnVpbHRpbihwcmVmaXgsIG1ldGhvZCwgZXhwciwgZXhwZWN0ZWRUeXBlKSB7XG4gICAg
ICAvLyBmNjR4Mi5zcGxhdCh4KSwgaTMyeDQuc3BsYXQoeCksIGV0Yy5cbiAgICAgIGlmIChtZXRo
b2QgPT09ICdzcGxhdCcpIHtcbiAgICAgICAgY29uc3Qgc2NhbGFyID0gdmVjdG9yU2NhbGFyVHlw
ZShwcmVmaXgpO1xuICAgICAgICBlbWl0RXhwcihleHByLmFyZ3NbMF0sIHNjYWxhcik7XG4gICAg
ICAgIGVtaXRTaW1kKFNJTURfT1BTW3ByZWZpeCArICcuc3BsYXQnXSk7XG4gICAgICAgIHJldHVy
bjtcbiAgICAgIH1cblxuICAgICAgLy8gZjY0eDIuZXh0cmFjdF9sYW5lKHYsIGxhbmUpXG4gICAg
ICBpZiAobWV0aG9kID09PSAnZXh0cmFjdF9sYW5lJykge1xuICAgICAgICBlbWl0RXhwcihleHBy
LmFyZ3NbMF0sIHByZWZpeCk7XG4gICAgICAgIGVtaXRTaW1kKFNJTURfT1BTW3ByZWZpeCArICcu
ZXh0cmFjdF9sYW5lJ10pO1xuICAgICAgICAvLyBsYW5lIG11c3QgYmUgYSBjb25zdGFudFxuICAg
ICAgICBpZiAoZXhwci5hcmdzWzFdLnR5cGUgIT09ICdOdW1iZXJMaXQnKSB0aHJvdyBuZXcgRXJy
b3IoJ2V4dHJhY3RfbGFuZSByZXF1aXJlcyBjb25zdGFudCBsYW5lIGluZGV4Jyk7XG4gICAgICAg
IGJ3LmJ5dGUocGFyc2VJbnQoZXhwci5hcmdzWzFdLnZhbHVlLCAxMCkpO1xuICAgICAgICByZXR1
cm47XG4gICAgICB9XG5cbiAgICAgIC8vIGY2NHgyLnJlcGxhY2VfbGFuZSh2LCBsYW5lLCB4KVxu
ICAgICAgaWYgKG1ldGhvZCA9PT0gJ3JlcGxhY2VfbGFuZScpIHtcbiAgICAgICAgY29uc3Qgc2Nh
bGFyID0gdmVjdG9yU2NhbGFyVHlwZShwcmVmaXgpO1xuICAgICAgICBlbWl0RXhwcihleHByLmFy
Z3NbMF0sIHByZWZpeCk7IC8vIHYxMjggdmFsdWVcbiAgICAgICAgZW1pdEV4cHIoZXhwci5hcmdz
WzJdLCBzY2FsYXIpOyAvLyByZXBsYWNlbWVudCBzY2FsYXJcbiAgICAgICAgZW1pdFNpbWQoU0lN
RF9PUFNbcHJlZml4ICsgJy5yZXBsYWNlX2xhbmUnXSk7XG4gICAgICAgIGlmIChleHByLmFyZ3Nb
MV0udHlwZSAhPT0gJ051bWJlckxpdCcpIHRocm93IG5ldyBFcnJvcigncmVwbGFjZV9sYW5lIHJl
cXVpcmVzIGNvbnN0YW50IGxhbmUgaW5kZXgnKTtcbiAgICAgICAgYncuYnl0ZShwYXJzZUludChl
eHByLmFyZ3NbMV0udmFsdWUsIDEwKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAg
ICAgLy8gZjY0eDIuZXEsIGY2NHgyLm5lLCBmNjR4Mi5sdCwgZjY0eDIuZ3QsIGY2NHgyLmxlLCBm
NjR4Mi5nZVxuICAgICAgaWYgKFsnZXEnLCduZScsJ2x0JywnZ3QnLCdsZScsJ2dlJywnbHRfcycs
J2d0X3MnLCdsZV9zJywnZ2VfcyddLmluY2x1ZGVzKG1ldGhvZCkpIHtcbiAgICAgICAgZW1pdEV4
cHIoZXhwci5hcmdzWzBdLCBwcmVmaXgpO1xuICAgICAgICBlbWl0RXhwcihleHByLmFyZ3NbMV0s
IHByZWZpeCk7XG4gICAgICAgIGNvbnN0IGtleSA9IHByZWZpeCArICcuJyArIG1ldGhvZDtcbiAg
ICAgICAgY29uc3Qgb3AgPSBTSU1EX09QU1trZXldO1xuICAgICAgICBpZiAob3AgPT09IHVuZGVm
aW5lZCkgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIFNJTUQgb3A6ICR7a2V5fWApO1xuICAgICAg
ICBlbWl0U2ltZChvcCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gZjY0
eDIubmVnLCBmNjR4Mi5hYnMsIGY2NHgyLnNxcnQgKHVuYXJ5KVxuICAgICAgaWYgKFsnbmVnJywn
YWJzJywnc3FydCddLmluY2x1ZGVzKG1ldGhvZCkpIHtcbiAgICAgICAgZW1pdEV4cHIoZXhwci5h
cmdzWzBdLCBwcmVmaXgpO1xuICAgICAgICBjb25zdCBrZXkgPSBwcmVmaXggKyAnLicgKyBtZXRo
b2Q7XG4gICAgICAgIGNvbnN0IG9wID0gU0lNRF9PUFNba2V5XTtcbiAgICAgICAgaWYgKG9wID09
PSB1bmRlZmluZWQpIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBTSU1EIG9wOiAke2tleX1gKTtc
biAgICAgICAgZW1pdFNpbWQob3ApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAg
IC8vIGY2NHgyLmFkZCwgZjY0eDIuc3ViLCBmNjR4Mi5tdWwsIGY2NHgyLmRpdiwgZjY0eDIubWlu
LCBmNjR4Mi5tYXggKGJpbmFyeSlcbiAgICAgIGlmIChbJ2FkZCcsJ3N1YicsJ211bCcsJ2Rpdics
J21pbicsJ21heCddLmluY2x1ZGVzKG1ldGhvZCkpIHtcbiAgICAgICAgZW1pdEV4cHIoZXhwci5h
cmdzWzBdLCBwcmVmaXgpO1xuICAgICAgICBlbWl0RXhwcihleHByLmFyZ3NbMV0sIHByZWZpeCk7
XG4gICAgICAgIGNvbnN0IGtleSA9IHByZWZpeCArICcuJyArIG1ldGhvZDtcbiAgICAgICAgY29u
c3Qgb3AgPSBTSU1EX09QU1trZXldO1xuICAgICAgICBpZiAob3AgPT09IHVuZGVmaW5lZCkgdGhy
b3cgbmV3IEVycm9yKGBVbmtub3duIFNJTUQgb3A6ICR7a2V5fWApO1xuICAgICAgICBlbWl0U2lt
ZChvcCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gdjEyOC5hbmQsIHYx
Mjgub3IsIHYxMjgueG9yIChiaW5hcnkgYml0d2lzZSlcbiAgICAgIGlmIChwcmVmaXggPT09ICd2
MTI4JyAmJiBbJ2FuZCcsJ29yJywneG9yJ10uaW5jbHVkZXMobWV0aG9kKSkge1xuICAgICAgICAv
LyBJbmZlciBvcGVyYW5kIHR5cGUgZnJvbSBmaXJzdCBhcmdcbiAgICAgICAgY29uc3QgdnQgPSBp
bmZlckV4cHJUeXBlKGV4cHIuYXJnc1swXSk7XG4gICAgICAgIGVtaXRFeHByKGV4cHIuYXJnc1sw
XSwgdnQpO1xuICAgICAgICBlbWl0RXhwcihleHByLmFyZ3NbMV0sIHZ0KTtcbiAgICAgICAgZW1p
dFNpbWQoU0lNRF9PUFNbJ3YxMjguJyArIG1ldGhvZF0pO1xuICAgICAgICByZXR1cm47XG4gICAg
ICB9XG5cbiAgICAgIC8vIHYxMjgubm90ICh1bmFyeSBiaXR3aXNlKVxuICAgICAgaWYgKHByZWZp
eCA9PT0gJ3YxMjgnICYmIG1ldGhvZCA9PT0gJ25vdCcpIHtcbiAgICAgICAgY29uc3QgdnQgPSBp
bmZlckV4cHJUeXBlKGV4cHIuYXJnc1swXSk7XG4gICAgICAgIGVtaXRFeHByKGV4cHIuYXJnc1sw
XSwgdnQpO1xuICAgICAgICBlbWl0U2ltZChTSU1EX09QU1sndjEyOC5ub3QnXSk7XG4gICAgICAg
IHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gdjEyOC5sb2FkKGFyciwgaSkg4oCUIGxvYWQg
MTYgYnl0ZXMgZnJvbSBtZW1vcnkgYXQgYXJyICsgaSAqIDE2XG4gICAgICBpZiAocHJlZml4ID09
PSAndjEyOCcgJiYgbWV0aG9kID09PSAnbG9hZCcpIHtcbiAgICAgICAgLy8gQ29tcHV0ZSBhZGRy
ZXNzOiBhcnIgKyBpICogMTZcbiAgICAgICAgZW1pdEV4cHIoZXhwci5hcmdzWzBdLCAnaTMyJyk7
IC8vIGJhc2UgcG9pbnRlclxuICAgICAgICBlbWl0RXhwcihleHByLmFyZ3NbMV0sICdpMzInKTsg
Ly8gaW5kZXhcbiAgICAgICAgYncuYnl0ZShPUF9JMzJfQ09OU1QpOyBidy5zMzIoMTYpO1xuICAg
ICAgICBidy5ieXRlKE9QX0kzMl9NVUwpO1xuICAgICAgICBidy5ieXRlKE9QX0kzMl9BREQpO1xu
ICAgICAgICBlbWl0U2ltZChTSU1EX09QU1sndjEyOC5sb2FkJ10pOyBidy51MzIoNCk7IGJ3LnUz
MigwKTsgLy8gYWxpZ249MTZcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyB2
MTI4LnN0b3JlKGFyciwgaSwgdikg4oCUIHN0b3JlIDE2IGJ5dGVzIHRvIG1lbW9yeSBhdCBhcnIg
KyBpICogMTZcbiAgICAgIGlmIChwcmVmaXggPT09ICd2MTI4JyAmJiBtZXRob2QgPT09ICdzdG9y
ZScpIHtcbiAgICAgICAgLy8gQ29tcHV0ZSBhZGRyZXNzXG4gICAgICAgIGVtaXRFeHByKGV4cHIu
YXJnc1swXSwgJ2kzMicpO1xuICAgICAgICBlbWl0RXhwcihleHByLmFyZ3NbMV0sICdpMzInKTtc
biAgICAgICAgYncuYnl0ZShPUF9JMzJfQ09OU1QpOyBidy5zMzIoMTYpO1xuICAgICAgICBidy5i
eXRlKE9QX0kzMl9NVUwpO1xuICAgICAgICBidy5ieXRlKE9QX0kzMl9BREQpO1xuICAgICAgICAv
LyBFbWl0IHZhbHVlXG4gICAgICAgIGNvbnN0IHZ0ID0gaW5mZXJFeHByVHlwZShleHByLmFyZ3Nb
Ml0pO1xuICAgICAgICBlbWl0RXhwcihleHByLmFyZ3NbMl0sIHZ0KTtcbiAgICAgICAgZW1pdFNp
bWQoU0lNRF9PUFNbJ3YxMjguc3RvcmUnXSk7IGJ3LnUzMig0KTsgYncudTMyKDApO1xuICAgICAg
ICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBTSU1E
IGJ1aWx0aW46ICR7cHJlZml4fS4ke21ldGhvZH1gKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBl
bWl0Q29udmVyc2lvbihmcm9tLCB0bykge1xuICAgICAgaWYgKGZyb20gPT09IHRvKSByZXR1cm47
XG4gICAgICBpZiAoZnJvbSA9PT0gJ2kzMicgJiYgdG8gPT09ICdmNjQnKSBidy5ieXRlKE9QX0Y2
NF9DT05WRVJUX0kzMl9TKTtcbiAgICAgIGVsc2UgaWYgKGZyb20gPT09ICdpMzInICYmIHRvID09
PSAnZjMyJykgYncuYnl0ZShPUF9GMzJfQ09OVkVSVF9JMzJfUyk7XG4gICAgICBlbHNlIGlmIChm
cm9tID09PSAnaTMyJyAmJiB0byA9PT0gJ2k2NCcpIGJ3LmJ5dGUoT1BfSTY0X0VYVEVORF9JMzJf
Uyk7XG4gICAgICBlbHNlIGlmIChmcm9tID09PSAnaTY0JyAmJiB0byA9PT0gJ2kzMicpIGJ3LmJ5
dGUoT1BfSTMyX1dSQVBfSTY0KTtcbiAgICAgIGVsc2UgaWYgKGZyb20gPT09ICdpNjQnICYmIHRv
ID09PSAnZjY0JykgYncuYnl0ZShPUF9GNjRfQ09OVkVSVF9JNjRfUyk7XG4gICAgICBlbHNlIGlm
IChmcm9tID09PSAnaTY0JyAmJiB0byA9PT0gJ2YzMicpIGJ3LmJ5dGUoT1BfRjMyX0NPTlZFUlRf
STY0X1MpO1xuICAgICAgZWxzZSBpZiAoZnJvbSA9PT0gJ2Y2NCcgJiYgdG8gPT09ICdpMzInKSBi
dy5ieXRlKE9QX0kzMl9UUlVOQ19GNjRfUyk7XG4gICAgICBlbHNlIGlmIChmcm9tID09PSAnZjY0
JyAmJiB0byA9PT0gJ2k2NCcpIGJ3LmJ5dGUoT1BfSTY0X1RSVU5DX0Y2NF9TKTtcbiAgICAgIGVs
c2UgaWYgKGZyb20gPT09ICdmNjQnICYmIHRvID09PSAnZjMyJykgYncuYnl0ZShPUF9GMzJfREVN
T1RFX0Y2NCk7XG4gICAgICBlbHNlIGlmIChmcm9tID09PSAnZjMyJyAmJiB0byA9PT0gJ2Y2NCcp
IGJ3LmJ5dGUoT1BfRjY0X1BST01PVEVfRjMyKTtcbiAgICAgIGVsc2UgaWYgKGZyb20gPT09ICdm
MzInICYmIHRvID09PSAnaTMyJykgYncuYnl0ZShPUF9JMzJfVFJVTkNfRjMyX1MpO1xuICAgICAg
ZWxzZSBpZiAoZnJvbSA9PT0gJ2YzMicgJiYgdG8gPT09ICdpNjQnKSBidy5ieXRlKE9QX0k2NF9U
UlVOQ19GMzJfUyk7XG4gICAgICBlbHNlIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGNvbnZlcnQg
JHtmcm9tfSB0byAke3RvfWApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVtaXRBcnJheUFkZHIo
bmFtZSwgaW5kaWNlcywgaW5mbywgZWxlbVR5cGUpIHtcbiAgICAgIC8vIEJhc2UgcG9pbnRlclxu
ICAgICAgYncuYnl0ZShPUF9MT0NBTF9HRVQpO1xuICAgICAgYncudTMyKGluZm8uaWR4KTtcblxu
ICAgICAgY29uc3Qgc3ogPSB0eXBlU2l6ZShlbGVtVHlwZSk7XG5cbiAgICAgIGlmIChpbmRpY2Vz
Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAvLyAxRDogYmFzZSArIGkgKiBzaXplb2ZcbiAgICAg
ICAgZW1pdEV4cHIoaW5kaWNlc1swXSwgJ2kzMicpO1xuICAgICAgICBidy5ieXRlKE9QX0kzMl9D
T05TVCk7IGJ3LnMzMihzeik7XG4gICAgICAgIGJ3LmJ5dGUoT1BfSTMyX01VTCk7XG4gICAgICAg
IGJ3LmJ5dGUoT1BfSTMyX0FERCk7XG4gICAgICB9IGVsc2UgaWYgKGluZGljZXMubGVuZ3RoID09
PSAzICYmICFpbmZvLmFycmF5RGltcykge1xuICAgICAgICAvLyAyRCB3aXRoIGV4cGxpY2l0IHN0
cmlkZTogYVtpLCBzdHJpZGUsIGpdIOKGkiBiYXNlICsgKGkqc3RyaWRlICsgaikgKiBzaXplb2Zc
biAgICAgICAgZW1pdEV4cHIoaW5kaWNlc1swXSwgJ2kzMicpO1xuICAgICAgICBlbWl0RXhwcihp
bmRpY2VzWzFdLCAnaTMyJyk7XG4gICAgICAgIGJ3LmJ5dGUoT1BfSTMyX01VTCk7XG4gICAgICAg
IGVtaXRFeHByKGluZGljZXNbMl0sICdpMzInKTtcbiAgICAgICAgYncuYnl0ZShPUF9JMzJfQURE
KTtcbiAgICAgICAgYncuYnl0ZShPUF9JMzJfQ09OU1QpOyBidy5zMzIoc3opO1xuICAgICAgICBi
dy5ieXRlKE9QX0kzMl9NVUwpO1xuICAgICAgICBidy5ieXRlKE9QX0kzMl9BREQpO1xuICAgICAg
fSBlbHNlIGlmIChpbmRpY2VzLmxlbmd0aCA9PT0gMiAmJiBpbmZvLmFycmF5RGltcyAmJiBpbmZv
LmFycmF5RGltcy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgLy8gMkQgd2l0aCBkZWNsYXJlZCBk
aW1zOiBhW2ksIGpdIOKGkiBiYXNlICsgKGkqZGltMSArIGopICogc2l6ZW9mXG4gICAgICAgIGVt
aXRFeHByKGluZGljZXNbMF0sICdpMzInKTtcbiAgICAgICAgZW1pdEV4cHIoaW5mby5hcnJheURp
bXNbMV0sICdpMzInKTtcbiAgICAgICAgYncuYnl0ZShPUF9JMzJfTVVMKTtcbiAgICAgICAgZW1p
dEV4cHIoaW5kaWNlc1sxXSwgJ2kzMicpO1xuICAgICAgICBidy5ieXRlKE9QX0kzMl9BREQpO1xu
ICAgICAgICBidy5ieXRlKE9QX0kzMl9DT05TVCk7IGJ3LnMzMihzeik7XG4gICAgICAgIGJ3LmJ5
dGUoT1BfSTMyX01VTCk7XG4gICAgICAgIGJ3LmJ5dGUoT1BfSTMyX0FERCk7XG4gICAgICB9IGVs
c2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGFycmF5IGluZGV4IHBh
dHRlcm4gZm9yICR7bmFtZX1gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlbWl0
TG9hZCh0KSB7XG4gICAgICBpZiAodCA9PT0gJ2kzMicpIHsgYncuYnl0ZShPUF9JMzJfTE9BRCk7
IGJ3LnUzMigyKTsgYncudTMyKDApOyB9IC8vIGFsaWduPTRcbiAgICAgIGVsc2UgaWYgKHQgPT09
ICdpNjQnKSB7IGJ3LmJ5dGUoT1BfSTY0X0xPQUQpOyBidy51MzIoMyk7IGJ3LnUzMigwKTsgfVxu
ICAgICAgZWxzZSBpZiAodCA9PT0gJ2YzMicpIHsgYncuYnl0ZShPUF9GMzJfTE9BRCk7IGJ3LnUz
MigyKTsgYncudTMyKDApOyB9XG4gICAgICBlbHNlIGlmICh0ID09PSAnZjY0JykgeyBidy5ieXRl
KE9QX0Y2NF9MT0FEKTsgYncudTMyKDMpOyBidy51MzIoMCk7IH1cbiAgICAgIGVsc2UgaWYgKGlz
VmVjdG9yKHQpKSB7IGVtaXRTaW1kKFNJTURfT1BTWyd2MTI4LmxvYWQnXSk7IGJ3LnUzMig0KTsg
YncudTMyKDApOyB9IC8vIGFsaWduPTE2XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZW1pdFN0b3Jl
KHQpIHtcbiAgICAgIGlmICh0ID09PSAnaTMyJykgeyBidy5ieXRlKE9QX0kzMl9TVE9SRSk7IGJ3
LnUzMigyKTsgYncudTMyKDApOyB9XG4gICAgICBlbHNlIGlmICh0ID09PSAnaTY0JykgeyBidy5i
eXRlKE9QX0k2NF9TVE9SRSk7IGJ3LnUzMigzKTsgYncudTMyKDApOyB9XG4gICAgICBlbHNlIGlm
ICh0ID09PSAnZjMyJykgeyBidy5ieXRlKE9QX0YzMl9TVE9SRSk7IGJ3LnUzMigyKTsgYncudTMy
KDApOyB9XG4gICAgICBlbHNlIGlmICh0ID09PSAnZjY0JykgeyBidy5ieXRlKE9QX0Y2NF9TVE9S
RSk7IGJ3LnUzMigzKTsgYncudTMyKDApOyB9XG4gICAgICBlbHNlIGlmIChpc1ZlY3Rvcih0KSkg
eyBlbWl0U2ltZChTSU1EX09QU1sndjEyOC5zdG9yZSddKTsgYncudTMyKDQpOyBidy51MzIoMCk7
IH0gLy8gYWxpZ249MTZcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlbWl0Q21wKG9wLCB0KSB7XG4g
ICAgICBpZiAodCA9PT0gJ2Y2NCcpIHtcbiAgICAgICAgaWYgKG9wID09PSAnPT0nKSBidy5ieXRl
KE9QX0Y2NF9FUSk7XG4gICAgICAgIGVsc2UgaWYgKG9wID09PSAnLz0nKSBidy5ieXRlKE9QX0Y2
NF9ORSk7XG4gICAgICAgIGVsc2UgaWYgKG9wID09PSAnPCcpIGJ3LmJ5dGUoT1BfRjY0X0xUKTtc
biAgICAgICAgZWxzZSBpZiAob3AgPT09ICc+JykgYncuYnl0ZShPUF9GNjRfR1QpO1xuICAgICAg
ICBlbHNlIGlmIChvcCA9PT0gJzw9JykgYncuYnl0ZShPUF9GNjRfTEUpO1xuICAgICAgICBlbHNl
IGlmIChvcCA9PT0gJz49JykgYncuYnl0ZShPUF9GNjRfR0UpO1xuICAgICAgfSBlbHNlIGlmICh0
ID09PSAnZjMyJykge1xuICAgICAgICBpZiAob3AgPT09ICc9PScpIGJ3LmJ5dGUoT1BfRjMyX0VR
KTtcbiAgICAgICAgZWxzZSBpZiAob3AgPT09ICcvPScpIGJ3LmJ5dGUoT1BfRjMyX05FKTtcbiAg
ICAgICAgZWxzZSBpZiAob3AgPT09ICc8JykgYncuYnl0ZShPUF9GMzJfTFQpO1xuICAgICAgICBl
bHNlIGlmIChvcCA9PT0gJz4nKSBidy5ieXRlKE9QX0YzMl9HVCk7XG4gICAgICAgIGVsc2UgaWYg
KG9wID09PSAnPD0nKSBidy5ieXRlKE9QX0YzMl9MRSk7XG4gICAgICAgIGVsc2UgaWYgKG9wID09
PSAnPj0nKSBidy5ieXRlKE9QX0YzMl9HRSk7XG4gICAgICB9IGVsc2UgaWYgKHQgPT09ICdpMzIn
KSB7XG4gICAgICAgIGlmIChvcCA9PT0gJz09JykgYncuYnl0ZShPUF9JMzJfRVEpO1xuICAgICAg
ICBlbHNlIGlmIChvcCA9PT0gJy89JykgYncuYnl0ZShPUF9JMzJfTkUpO1xuICAgICAgICBlbHNl
IGlmIChvcCA9PT0gJzwnKSBidy5ieXRlKE9QX0kzMl9MVF9TKTtcbiAgICAgICAgZWxzZSBpZiAo
b3AgPT09ICc+JykgYncuYnl0ZShPUF9JMzJfR1RfUyk7XG4gICAgICAgIGVsc2UgaWYgKG9wID09
PSAnPD0nKSBidy5ieXRlKE9QX0kzMl9MRV9TKTtcbiAgICAgICAgZWxzZSBpZiAob3AgPT09ICc+
PScpIGJ3LmJ5dGUoT1BfSTMyX0dFX1MpO1xuICAgICAgfSBlbHNlIGlmICh0ID09PSAnaTY0Jykg
e1xuICAgICAgICBpZiAob3AgPT09ICc9PScpIGJ3LmJ5dGUoT1BfSTY0X0VRKTtcbiAgICAgICAg
ZWxzZSBpZiAob3AgPT09ICcvPScpIGJ3LmJ5dGUoT1BfSTY0X05FKTtcbiAgICAgICAgZWxzZSBp
ZiAob3AgPT09ICc8JykgYncuYnl0ZShPUF9JNjRfTFRfUyk7XG4gICAgICAgIGVsc2UgaWYgKG9w
ID09PSAnPicpIGJ3LmJ5dGUoT1BfSTY0X0dUX1MpO1xuICAgICAgICBlbHNlIGlmIChvcCA9PT0g
Jzw9JykgYncuYnl0ZShPUF9JNjRfTEVfUyk7XG4gICAgICAgIGVsc2UgaWYgKG9wID09PSAnPj0n
KSBidy5ieXRlKE9QX0k2NF9HRV9TKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNWZWN0b3IodCkpIHtc
biAgICAgICAgLy8gVmVjdG9yIGNvbXBhcmlzb25zIOKAlCBtYXAgYXRyYSBvcHMgdG8gU0lNRCBv
cGNvZGUga2V5c1xuICAgICAgICBjb25zdCBpc0ludFZlYyA9ICh0ID09PSAnaTMyeDQnIHx8IHQg
PT09ICdpNjR4MicpO1xuICAgICAgICBjb25zdCBzdWZmaXggPSBpc0ludFZlYyA/ICdfcycgOiAn
JztcbiAgICAgICAgbGV0IGtleTtcbiAgICAgICAgaWYgKG9wID09PSAnPT0nKSBrZXkgPSB0ICsg
Jy5lcSc7XG4gICAgICAgIGVsc2UgaWYgKG9wID09PSAnLz0nKSBrZXkgPSB0ICsgJy5uZSc7XG4g
ICAgICAgIGVsc2UgaWYgKG9wID09PSAnPCcpIGtleSA9IHQgKyAoaXNJbnRWZWMgPyAnLmx0X3Mn
IDogJy5sdCcpO1xuICAgICAgICBlbHNlIGlmIChvcCA9PT0gJz4nKSBrZXkgPSB0ICsgKGlzSW50
VmVjID8gJy5ndF9zJyA6ICcuZ3QnKTtcbiAgICAgICAgZWxzZSBpZiAob3AgPT09ICc8PScpIGtl
eSA9IHQgKyAoaXNJbnRWZWMgPyAnLmxlX3MnIDogJy5sZScpO1xuICAgICAgICBlbHNlIGlmIChv
cCA9PT0gJz49Jykga2V5ID0gdCArIChpc0ludFZlYyA/ICcuZ2VfcycgOiAnLmdlJyk7XG4gICAg
ICAgIGNvbnN0IG9wY29kZSA9IFNJTURfT1BTW2tleV07XG4gICAgICAgIGlmIChvcGNvZGUgPT09
IHVuZGVmaW5lZCkgdGhyb3cgbmV3IEVycm9yKGBDb21wYXJpc29uICR7b3B9IG5vdCBzdXBwb3J0
ZWQgZm9yICR7dH1gKTtcbiAgICAgICAgZW1pdFNpbWQob3Bjb2RlKTtcbiAgICAgIH1cbiAgICB9
XG5cbiAgICBmdW5jdGlvbiBlbWl0QWRkKHQpIHtcbiAgICAgIGlmICh0ID09PSAnZjY0JykgYncu
Ynl0ZShPUF9GNjRfQUREKTtcbiAgICAgIGVsc2UgaWYgKHQgPT09ICdmMzInKSBidy5ieXRlKE9Q
X0YzMl9BREQpO1xuICAgICAgZWxzZSBpZiAodCA9PT0gJ2kzMicpIGJ3LmJ5dGUoT1BfSTMyX0FE
RCk7XG4gICAgICBlbHNlIGlmICh0ID09PSAnaTY0JykgYncuYnl0ZShPUF9JNjRfQUREKTtcbiAg
ICAgIGVsc2UgaWYgKGlzVmVjdG9yKHQpKSBlbWl0U2ltZChTSU1EX09QU1t0ICsgJy5hZGQnXSk7
XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZW1pdFN1Yih0KSB7XG4gICAgICBpZiAodCA9PT0gJ2Y2
NCcpIGJ3LmJ5dGUoT1BfRjY0X1NVQik7XG4gICAgICBlbHNlIGlmICh0ID09PSAnZjMyJykgYncu
Ynl0ZShPUF9GMzJfU1VCKTtcbiAgICAgIGVsc2UgaWYgKHQgPT09ICdpMzInKSBidy5ieXRlKE9Q
X0kzMl9TVUIpO1xuICAgICAgZWxzZSBpZiAodCA9PT0gJ2k2NCcpIGJ3LmJ5dGUoT1BfSTY0X1NV
Qik7XG4gICAgICBlbHNlIGlmIChpc1ZlY3Rvcih0KSkgZW1pdFNpbWQoU0lNRF9PUFNbdCArICcu
c3ViJ10pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVtaXRNdWwodCkge1xuICAgICAgaWYgKHQg
PT09ICdmNjQnKSBidy5ieXRlKE9QX0Y2NF9NVUwpO1xuICAgICAgZWxzZSBpZiAodCA9PT0gJ2Yz
MicpIGJ3LmJ5dGUoT1BfRjMyX01VTCk7XG4gICAgICBlbHNlIGlmICh0ID09PSAnaTMyJykgYncu
Ynl0ZShPUF9JMzJfTVVMKTtcbiAgICAgIGVsc2UgaWYgKHQgPT09ICdpNjQnKSBidy5ieXRlKE9Q
X0k2NF9NVUwpO1xuICAgICAgZWxzZSBpZiAoaXNWZWN0b3IodCkpIGVtaXRTaW1kKFNJTURfT1BT
W3QgKyAnLm11bCddKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlbWl0RGl2KHQpIHtcbiAgICAg
IGlmICh0ID09PSAnZjY0JykgYncuYnl0ZShPUF9GNjRfRElWKTtcbiAgICAgIGVsc2UgaWYgKHQg
PT09ICdmMzInKSBidy5ieXRlKE9QX0YzMl9ESVYpO1xuICAgICAgZWxzZSBpZiAodCA9PT0gJ2kz
MicpIGJ3LmJ5dGUoT1BfSTMyX0RJVl9TKTtcbiAgICAgIGVsc2UgaWYgKHQgPT09ICdpNjQnKSBi
dy5ieXRlKE9QX0k2NF9ESVZfUyk7XG4gICAgICBlbHNlIGlmIChpc1ZlY3Rvcih0KSkge1xuICAg
ICAgICBjb25zdCBvcCA9IFNJTURfT1BTW3QgKyAnLmRpdiddO1xuICAgICAgICBpZiAoIW9wKSB0
aHJvdyBuZXcgRXJyb3IoJ0RpdmlzaW9uIG5vdCBzdXBwb3J0ZWQgZm9yICcgKyB0KTtcbiAgICAg
ICAgZW1pdFNpbWQob3ApO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIOKUgOKUgCBFbWl0IGZ1
bmN0aW9uIGJvZHkgc3RhdGVtZW50cyDilIDilIBcbiAgICBlbWl0U3RtdHMoZm4uYm9keSk7XG5c
biAgICAvLyDilIDilIAgRW5kIG9mIGZ1bmN0aW9uIGJvZHk6IHJldHVybiB2YWx1ZSDilIDilIBc
biAgICBpZiAoaXNGdW5jKSB7XG4gICAgICBidy5ieXRlKE9QX0xPQ0FMX0dFVCk7XG4gICAgICBi
dy51MzIobG9jYWxNYXBbJyRfcmV0dXJuJ10uaWR4KTtcbiAgICB9XG4gICAgYncuYnl0ZShPUF9F
TkQpO1xuICB9XG59XG5cbi8vIC0tIGF0cmEuanMgLS1cblxuLy8gUHVibGljIEFQSSDigJQgdGFn
Z2VkIHRlbXBsYXRlLCAuY29tcGlsZSwgLnBhcnNlLCAuZHVtcCwgLnJ1biwgc2VsZi1yZWdpc3Ry
YXRpb25cblxuXG5cblxuXG5mdW5jdGlvbiBjb21waWxlU291cmNlKHNvdXJjZSwgaW50ZXJwVmFs
dWVzLCB1c2VySW1wb3J0cykge1xuICBjb25zdCB0b2tlbnMgPSBsZXgoc291cmNlKTtcbiAgY29u
c3QgYXN0ID0gcGFyc2UodG9rZW5zKTtcbiAgcmV0dXJuIGNvZGVnZW4oYXN0LCBpbnRlcnBWYWx1
ZXMsIHVzZXJJbXBvcnRzKTtcbn1cblxuZnVuY3Rpb24gaW5zdGFudGlhdGUoYnl0ZXMsIHVzZXJJ
bXBvcnRzLCBpbnRlcnBWYWx1ZXMpIHtcbiAgY29uc3QgaW1wb3J0T2JqID0ge1xuICAgIG1hdGg6
IHsgc2luOiBNYXRoLnNpbiwgY29zOiBNYXRoLmNvcywgbG46IE1hdGgubG9nLCBleHA6IE1hdGgu
ZXhwLCBwb3c6IE1hdGgucG93LCBhdGFuMjogTWF0aC5hdGFuMiB9LFxuICAgIGhvc3Q6IHt9LFxu
ICB9O1xuICBpZiAodXNlckltcG9ydHMpIHtcbiAgICBjb25zdCBmbGF0ID0gZmxhdHRlbkltcG9y
dHModXNlckltcG9ydHMpO1xuICAgIGZvciAoY29uc3QgW2ssIHZdIG9mIE9iamVjdC5lbnRyaWVz
KGZsYXQpKSBpbXBvcnRPYmouaG9zdFtrXSA9IHY7XG4gIH1cblxuICAvLyBJbnRlcnBvbGF0ZWQg
aW1wb3J0c1xuICBpZiAoaW50ZXJwVmFsdWVzKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBp
bnRlcnBWYWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHYgPSBpbnRlcnBWYWx1ZXNb
aV07XG4gICAgICBpZiAodHlwZW9mIHYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaW1wb3J0
T2JqLmhvc3RbJ19fSU5URVJQXycgKyBpICsgJ19fJ10gPSB2O1xuICAgICAgfVxuICAgIH1cbiAg
fVxuXG4gIC8vIE1lbW9yeVxuICBpZiAodXNlckltcG9ydHMgJiYgdXNlckltcG9ydHMuX19tZW1v
cnkpIHtcbiAgICBpZiAoIWltcG9ydE9iai5lbnYpIGltcG9ydE9iai5lbnYgPSB7fTtcbiAgICBp
bXBvcnRPYmouZW52Lm1lbW9yeSA9IHVzZXJJbXBvcnRzLl9fbWVtb3J5O1xuICB9XG5cbiAgY29u
c3QgbW9kID0gbmV3IFdlYkFzc2VtYmx5Lk1vZHVsZShieXRlcyk7XG4gIGNvbnN0IGluc3RhbmNl
ID0gbmV3IFdlYkFzc2VtYmx5Lkluc3RhbmNlKG1vZCwgaW1wb3J0T2JqKTtcbiAgcmV0dXJuIGlu
c3RhbmNlO1xufVxuXG5mdW5jdGlvbiB3cmFwRXhwb3J0cyhpbnN0YW5jZSwgdGFibGUpIHtcbiAg
Y29uc3QgZXhwb3J0cyA9IE9iamVjdC5jcmVhdGUoaW5zdGFuY2UuZXhwb3J0cyk7XG4gIGlmICh0
YWJsZSkgZXhwb3J0cy5fX3RhYmxlID0gdGFibGU7XG4gIC8vIE5lc3QgZG90dGVkIGV4cG9ydCBu
YW1lczogXCJwaHlzaWNzLmdyYXZpdHlcIiDihpIgZXhwb3J0cy5waHlzaWNzLmdyYXZpdHlcbiAg
Zm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoaW5zdGFuY2UuZXhwb3J0cykpIHtcbiAgICBp
ZiAoa2V5LmluY2x1ZGVzKCcuJykpIHtcbiAgICAgIGNvbnN0IHBhcnRzID0ga2V5LnNwbGl0KCcu
Jyk7XG4gICAgICBsZXQgb2JqID0gZXhwb3J0cztcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwg
cGFydHMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIGlmICghb2JqW3BhcnRzW2ldXSB8fCB0
eXBlb2Ygb2JqW3BhcnRzW2ldXSAhPT0gJ29iamVjdCcpIG9ialtwYXJ0c1tpXV0gPSB7fTtcbiAg
ICAgICAgb2JqID0gb2JqW3BhcnRzW2ldXTtcbiAgICAgIH1cbiAgICAgIG9ialtwYXJ0c1twYXJ0
cy5sZW5ndGggLSAxXV0gPSBpbnN0YW5jZS5leHBvcnRzW2tleV07XG4gICAgfVxuICB9XG4gIHJl
dHVybiBleHBvcnRzO1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVNZW1vcnlJbXBvcnQodXNlcklt
cG9ydHMpIHtcbiAgaWYgKHVzZXJJbXBvcnRzICYmIHVzZXJJbXBvcnRzLm1lbW9yeSAmJiAhdXNl
ckltcG9ydHMuX19tZW1vcnkpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgdXNlcklt
cG9ydHMsIHsgX19tZW1vcnk6IHVzZXJJbXBvcnRzLm1lbW9yeSB9KTtcbiAgfVxuICByZXR1cm4g
dXNlckltcG9ydHM7XG59XG5cbmZ1bmN0aW9uIGNvbXBpbGVBbmRJbnN0YW50aWF0ZShzdHJpbmdz
LCB2YWx1ZXMsIHVzZXJJbXBvcnRzKSB7XG4gIHVzZXJJbXBvcnRzID0gbm9ybWFsaXplTWVtb3J5
SW1wb3J0KHVzZXJJbXBvcnRzKTtcbiAgLy8gSm9pbiB0ZW1wbGF0ZSBzdHJpbmdzIHdpdGggaW50
ZXJwb2xhdGlvbiBtYXJrZXJzXG4gIGxldCBzb3VyY2UgPSBzdHJpbmdzWzBdO1xuICBmb3IgKGxl
dCBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgIC8vIEZvciBudW1lcmljIHZh
bHVlcywgaW5saW5lIHRoZW0gZGlyZWN0bHlcbiAgICBpZiAodHlwZW9mIHZhbHVlc1tpXSA9PT0g
J251bWJlcicpIHtcbiAgICAgIHNvdXJjZSArPSBTdHJpbmcodmFsdWVzW2ldKTtcbiAgICB9IGVs
c2Uge1xuICAgICAgc291cmNlICs9ICdfX0lOVEVSUF8nICsgaSArICdfXyc7XG4gICAgfVxuICAg
IHNvdXJjZSArPSBzdHJpbmdzW2kgKyAxXTtcbiAgfVxuXG4gIGNvbnN0IHsgYnl0ZXMsIHRhYmxl
IH0gPSBjb21waWxlU291cmNlKHNvdXJjZSwgdmFsdWVzLCB1c2VySW1wb3J0cyk7XG4gIGNvbnN0
IGluc3RhbmNlID0gaW5zdGFudGlhdGUoYnl0ZXMsIHVzZXJJbXBvcnRzLCB2YWx1ZXMpO1xuICBy
ZXR1cm4gd3JhcEV4cG9ydHMoaW5zdGFuY2UsIHRhYmxlKTtcbn1cblxuZnVuY3Rpb24gYXRyYShz
dHJpbmdzT3JPcHRzLCAuLi52YWx1ZXMpIHtcbiAgLy8gQ3VycmllZCBmb3JtOiBhdHJhKHtpbXBv
cnRzfSlgLi4uYFxuICBpZiAoc3RyaW5nc09yT3B0cyAmJiAhQXJyYXkuaXNBcnJheShzdHJpbmdz
T3JPcHRzKSAmJiB0eXBlb2Ygc3RyaW5nc09yT3B0cyA9PT0gJ29iamVjdCcgJiYgIXN0cmluZ3NP
ck9wdHMucmF3KSB7XG4gICAgY29uc3Qgb3B0cyA9IHN0cmluZ3NPck9wdHM7XG4gICAgcmV0dXJu
IGZ1bmN0aW9uKHN0cmluZ3MsIC4uLnZhbHMpIHtcbiAgICAgIHJldHVybiBjb21waWxlQW5kSW5z
dGFudGlhdGUoc3RyaW5ncywgdmFscywgb3B0cyk7XG4gICAgfTtcbiAgfVxuICAvLyBEaXJlY3Qg
Zm9ybTogYXRyYWAuLi5gXG4gIHJldHVybiBjb21waWxlQW5kSW5zdGFudGlhdGUoc3RyaW5nc09y
T3B0cywgdmFsdWVzLCBudWxsKTtcbn1cblxuLy8gRGlyZWN0IGNvbXBpbGVyIGFjY2Vzc1xuYXRy
YS5jb21waWxlID0gZnVuY3Rpb24oc291cmNlKSB7XG4gIHJldHVybiBjb21waWxlU291cmNlKHNv
dXJjZSwgbnVsbCwgbnVsbCkuYnl0ZXM7XG59O1xuXG5hdHJhLnBhcnNlID0gZnVuY3Rpb24oc291
cmNlKSB7XG4gIGNvbnN0IHRva2VucyA9IGxleChzb3VyY2UpO1xuICByZXR1cm4gcGFyc2UodG9r
ZW5zKTtcbn07XG5cbmF0cmEuZHVtcCA9IGZ1bmN0aW9uKHNvdXJjZSkge1xuICBjb25zdCB7IGJ5
dGVzIH0gPSBjb21waWxlU291cmNlKHNvdXJjZSwgbnVsbCwgbnVsbCk7XG4gIHJldHVybiBBcnJh
eS5mcm9tKGJ5dGVzKS5tYXAoYiA9PiBiLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKS5q
b2luKCcgJyk7XG59O1xuXG5hdHJhLnJ1biA9IGZ1bmN0aW9uKHNvdXJjZSwgdXNlckltcG9ydHMp
IHtcbiAgdXNlckltcG9ydHMgPSBub3JtYWxpemVNZW1vcnlJbXBvcnQodXNlckltcG9ydHMpO1xu
ICBjb25zdCB7IGJ5dGVzLCB0YWJsZSB9ID0gY29tcGlsZVNvdXJjZShzb3VyY2UsIG51bGwsIHVz
ZXJJbXBvcnRzKTtcbiAgY29uc3QgaW5zdGFuY2UgPSBpbnN0YW50aWF0ZShieXRlcywgdXNlcklt
cG9ydHMsIG51bGwpO1xuICByZXR1cm4gd3JhcEV4cG9ydHMoaW5zdGFuY2UsIHRhYmxlKTtcbn07
XG5cbi8vIOKUgOKUgCBTZWxmLXJlZ2lzdHJhdGlvbiDilIDilIBcblxuaWYgKHR5cGVvZiB3aW5k
b3cgIT09ICd1bmRlZmluZWQnKSB7XG4gIGlmICghd2luZG93Ll90YWdnZWRMYW5ndWFnZXMpIHdp
bmRvdy5fdGFnZ2VkTGFuZ3VhZ2VzID0ge307XG4gIHdpbmRvdy5fdGFnZ2VkTGFuZ3VhZ2VzLmF0
cmEgPSB7IHRva2VuaXplOiB0b2tlbml6ZUF0cmEsIGNvbXBsZXRpb25zOiBhdHJhQ29tcGxldGlv
bnMgfTtcbn1cblxuLy8gQXR0YWNoIGludGVybmFscyBmb3IgdGVzdGluZyAvIGFkdmFuY2VkIHVz
ZVxuYXRyYS5fbGV4ID0gbGV4O1xuYXRyYS5fcGFyc2UgPSBwYXJzZTtcbmF0cmEuX3Rva2VuaXpl
ID0gdG9rZW5pemVBdHJhO1xuXG5leHBvcnQgeyBhdHJhIH07XG4iLCJjZWxsSWQiOm51bGx9fQ==
AUDITABLE-MODULES-->
<!-- notebook settings: JSON {theme, fontSize, width, ...} -->
<!--AUDITABLE-SETTINGS
{"theme":"dark","fontSize":13,"width":"860"}
AUDITABLE-SETTINGS-->

<script>
// -- state.js --

// ═══════════════════════════════════════════════════
// AUDITABLE — reactive notebook runtime
// Geoscientific Chaos Union, 2025
// ═══════════════════════════════════════════════════

const $ = s => document.querySelector(s);
const $$ = s => [...document.querySelectorAll(s)];

// ── STATE ──
const S = {
  cells: [],        // { id, type, code, el, defines, uses, output, error }
  scope: {},        // shared variable scope
  cellId: 0,        // unique cell ID counter
  editTimer: null,  // debounce timer for autorun
  autorun: true,    // reactive mode flag
  selectedId: null, // currently selected cell
  pendingD: false,  // for "dd" double-tap delete
  pendingDTimer: null,
  clipboard: null,  // copied cell data
  trash: [],        // undo stack for deleted cells
  findActive: false,
  findQuery: '',
  findCase: false,
  findRegex: false,
  findMatches: [],   // { cellId, index, length }
  findCurrent: -1,
  initialized: false, // set after loadFromEmbed/init completes
};

const JS_KEYWORDS = new Set([
  'const','let','var','function','return','if','else','for','while','do',
  'switch','case','break','continue','new','this','class','extends','import',
  'export','default','from','of','in','typeof','instanceof','void','delete',
  'throw','try','catch','finally','async','await','yield','true','false',
  'null','undefined','NaN','Infinity'
]);

const JS_BUILTINS = new Set([
  'Math','Array','Object','String','Number','Float64Array','Float32Array',
  'Int32Array','Uint8Array','Map','Set','Promise','console','JSON',
  'ui','std','load','install','print',
  'workshop','notebook','md','html','css'
]);


// -- stdlib.js --

// ── STDLIB ──
// Bundled standard library for notebook work.
// Module-level — no per-cell state needed.

// ── Provider Registry ──

const _providers = { file: null, download: null };

function registerProvider(name, fn) {
  if (name in _providers) _providers[name] = fn;
}

// ── Data ──

function csv(text, opts = {}) {
  const sep = opts.separator || ',';
  const typed = !!opts.typed;
  const lines = [];
  let i = 0;
  const len = text.length;

  while (i < len) {
    const row = [];
    while (i < len) {
      if (text[i] === '"') {
        // quoted field
        i++;
        let field = '';
        while (i < len) {
          if (text[i] === '"') {
            if (text[i + 1] === '"') { field += '"'; i += 2; }
            else { i++; break; }
          } else { field += text[i]; i++; }
        }
        row.push(field);
        if (text[i] === sep) i++;
        else if (text[i] === '\r') { i++; if (text[i] === '\n') i++; break; }
        else if (text[i] === '\n') { i++; break; }
        else if (i >= len) break;
      } else {
        // unquoted field
        let field = '';
        while (i < len && text[i] !== sep && text[i] !== '\n' && text[i] !== '\r') {
          field += text[i]; i++;
        }
        row.push(field);
        if (text[i] === sep) i++;
        else if (text[i] === '\r') { i++; if (text[i] === '\n') i++; break; }
        else if (text[i] === '\n') { i++; break; }
        else break;
      }
    }
    if (row.length > 0 && !(row.length === 1 && row[0] === '')) lines.push(row);
  }

  if (lines.length < 2) return [];
  const headers = lines[0];
  const result = [];
  for (let r = 1; r < lines.length; r++) {
    const obj = {};
    for (let c = 0; c < headers.length; c++) {
      let val = lines[r][c] !== undefined ? lines[r][c] : '';
      if (typed) {
        const num = Number(val);
        if (val !== '' && !isNaN(num)) val = num;
        else if (val === 'true') val = true;
        else if (val === 'false') val = false;
        else if (val === '') val = null;
      }
      obj[headers[c]] = val;
    }
    result.push(obj);
  }
  return result;
}

async function fetchJSON(url) {
  const resp = await fetch(url);
  if (!resp.ok) throw new Error(`fetchJSON: ${resp.status} ${resp.statusText}`);
  return resp.json();
}

// ── Math / Stats ──

function _acc(arr, fn) {
  return fn ? arr.map(fn) : arr;
}

function sum(arr, fn) {
  const vals = _acc(arr, fn);
  let s = 0;
  for (let i = 0; i < vals.length; i++) s += vals[i];
  return s;
}

function mean(arr, fn) {
  if (!arr.length) return NaN;
  return sum(arr, fn) / arr.length;
}

function median(arr, fn) {
  const vals = _acc(arr, fn).slice().sort((a, b) => a - b);
  const n = vals.length;
  if (n === 0) return NaN;
  if (n % 2 === 1) return vals[(n - 1) / 2];
  return (vals[n / 2 - 1] + vals[n / 2]) / 2;
}

function extent(arr, fn) {
  const vals = _acc(arr, fn);
  let lo = Infinity, hi = -Infinity;
  for (let i = 0; i < vals.length; i++) {
    if (vals[i] < lo) lo = vals[i];
    if (vals[i] > hi) hi = vals[i];
  }
  return [lo, hi];
}

function bin(arr, n = 10, fn) {
  const vals = _acc(arr, fn);
  const [lo, hi] = extent(vals);
  const range = hi - lo || 1;
  const step = range / n;
  const bins = [];
  for (let i = 0; i < n; i++) {
    bins.push({ x0: lo + i * step, x1: lo + (i + 1) * step, values: [] });
  }
  for (const v of vals) {
    let idx = Math.floor((v - lo) / step);
    if (idx >= n) idx = n - 1;
    if (idx < 0) idx = 0;
    bins[idx].values.push(v);
  }
  return bins;
}

function linspace(start, stop, n) {
  if (n < 2) return n === 1 ? [start] : [];
  const result = new Array(n);
  const step = (stop - start) / (n - 1);
  for (let i = 0; i < n; i++) result[i] = start + i * step;
  result[n - 1] = stop; // exact endpoint
  return result;
}

// ── Array ──

function unique(arr, fn) {
  if (!fn) return [...new Set(arr)];
  const seen = new Set();
  const result = [];
  for (const item of arr) {
    const key = fn(item);
    if (!seen.has(key)) { seen.add(key); result.push(item); }
  }
  return result;
}

function zip(...arrays) {
  const len = Math.min(...arrays.map(a => a.length));
  const result = new Array(len);
  for (let i = 0; i < len; i++) {
    result[i] = arrays.map(a => a[i]);
  }
  return result;
}

function cross(...arrays) {
  if (arrays.length === 0) return [[]];
  const [first, ...rest] = arrays;
  const sub = cross(...rest);
  const result = [];
  for (const item of first) {
    for (const tail of sub) {
      result.push([item, ...tail]);
    }
  }
  return result;
}

// ── DOM / IO ──

async function file(accept) {
  if (_providers.file) return _providers.file(accept);
  return new Promise((resolve, reject) => {
    const input = document.createElement('input');
    input.type = 'file';
    if (accept) input.accept = accept;
    input.onchange = async () => {
      const f = input.files[0];
      if (!f) { reject(new Error('no file selected')); return; }
      const text = await f.text();
      resolve({ name: f.name, text, size: f.size });
    };
    input.click();
  });
}

function download(data, filename, mimeType) {
  if (_providers.download) return _providers.download(data, filename, mimeType);
  const str = typeof data === 'string' ? data : JSON.stringify(data, null, 2);
  const mime = mimeType || (typeof data === 'string' ? 'text/plain' : 'application/json');
  const blob = new Blob([str], { type: mime });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename || 'download';
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  setTimeout(() => URL.revokeObjectURL(url), 1000);
}

function el(tag, attrs, ...children) {
  const elem = document.createElement(tag);
  if (attrs && typeof attrs === 'object' && !(attrs instanceof Node)) {
    for (const [k, v] of Object.entries(attrs)) {
      if (k === 'style' && typeof v === 'object') {
        Object.assign(elem.style, v);
      } else if (k.startsWith('on') && typeof v === 'function') {
        elem.addEventListener(k.slice(2), v);
      } else {
        elem.setAttribute(k, v);
      }
    }
  } else if (attrs != null) {
    // attrs is actually a child
    children.unshift(attrs);
  }
  for (const child of children) {
    if (child instanceof Node) elem.appendChild(child);
    else if (child != null) elem.appendChild(document.createTextNode(String(child)));
  }
  return elem;
}

async function copy(text) {
  await navigator.clipboard.writeText(text);
}

function fmt(number, opts = {}) {
  const { decimals, prefix, suffix } = opts;
  let s = decimals != null ? number.toFixed(decimals)
    : new Intl.NumberFormat(undefined, { maximumFractionDigits: 6 }).format(number);
  if (prefix) s = prefix + s;
  if (suffix) s = s + suffix;
  return s;
}

// ── Export ──

const std = {
  csv, fetchJSON,
  sum, mean, median, extent, bin, linspace,
  unique, zip, cross,
  file, download, el, copy, fmt,
};

// -- python.js --

// ── @python COMPAT HELPERS ──
// Python-familiar functions for users transitioning from Python.
// Each has a .help property showing the idiomatic JS equivalent.

function range(a, b, step) {
  let start, stop, s;
  if (b === undefined) { start = 0; stop = a; s = 1; }
  else { start = a; stop = b; s = step || 1; }
  const result = [];
  if (s > 0) { for (let i = start; i < stop; i += s) result.push(i); }
  else if (s < 0) { for (let i = start; i > stop; i += s) result.push(i); }
  return result;
}
range.help = 'JS: Array.from({length: n}, (_, i) => start + i * step)';

function enumerate(arr) {
  return arr.map((v, i) => [i, v]);
}
enumerate.help = 'JS: arr.map((v, i) => [i, v]) or arr.entries()';

function len(x) {
  if (x == null) throw new TypeError('len() of unsized object');
  if (x.size !== undefined) return x.size;
  return x.length;
}
len.help = 'JS: x.length or x.size';

function sorted(arr, key, reverse) {
  const copy = [...arr];
  if (key) copy.sort((a, b) => {
    const ka = key(a), kb = key(b);
    return ka < kb ? -1 : ka > kb ? 1 : 0;
  });
  else copy.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
  if (reverse) copy.reverse();
  return copy;
}
sorted.help = 'JS: arr.toSorted((a, b) => ...)';

function reversed(arr) {
  return [...arr].reverse();
}
reversed.help = 'JS: arr.toReversed()';

function isinstance(obj, cls) {
  return obj instanceof cls;
}
isinstance.help = 'JS: obj instanceof cls';

function type(x) {
  if (x === null) return 'null';
  if (Array.isArray(x)) return 'array';
  return typeof x;
}
type.help = 'JS: typeof x';

const python = {
  range, enumerate, len, sorted, reversed,
  isinstance, type,
};

function zenOfPython() {
  return [
    'The Zen of Python, by Tim Peters',
    '',
    'Beautiful is better than ugly.',
    'Explicit is better than implicit.',
    'Simple is better than complex.',
    'Complex is better than complicated.',
    'Flat is better than nested.',
    'Sparse is better than dense.',
    'Readability counts.',
    "Special cases aren't special enough to break the rules.",
    'Although practicality beats purity.',
    'Errors should never pass silently.',
    'Unless explicitly silenced.',
    'In the face of ambiguity, refuse the temptation to guess.',
    'There should be one-- and preferably only one --obvious way to do it.',
    "Although that way may not be obvious at first unless you're Dutch.",
    'Now is better than never.',
    'Although never is often better than *right* now.',
    "If the implementation is hard to explain, it's a bad idea.",
    'If the implementation is easy to explain, it may be a good idea.',
    "Namespaces are one honking great idea -- let's do more of those!",
  ].join('\n');
}

// -- syntax.js --

// ── SYNTAX HIGHLIGHTING ──

const CSS_NAMED_COLORS = new Set([
  'black','silver','gray','white','maroon','red','purple','fuchsia',
  'green','lime','olive','yellow','navy','blue','teal','aqua','orange'
]);

// detect curried tagged template: scan back through tokens for lang({...})`
function detectCurriedTag(tokens) {
  // last non-whitespace token must be )
  let j = tokens.length - 1;
  while (j >= 0 && tokens[j].type === '') j--;
  if (j < 0 || tokens[j].text !== ')') return null;
  // scan back to matching (
  let depth = 1;
  j--;
  while (j >= 0 && depth > 0) {
    if (tokens[j].text === ')') depth++;
    else if (tokens[j].text === '(') depth--;
    j--;
  }
  // token before ( should be the language name
  while (j >= 0 && tokens[j].type === '') j--;
  if (j < 0) return null;
  const name = tokens[j].text;
  if (window._taggedLanguages && window._taggedLanguages[name]) {
    return window._taggedLanguages[name];
  }
  return null;
}

// tokenize a tagged template literal starting at the opening backtick
function tokenizeTaggedTemplate(code, i, len, lang, tokens) {
  tokens.push({ type: 'punc', text: '`' });
  i++; // skip opening backtick
  let strBuf = '';
  while (i < len && code[i] !== '`') {
    if (code[i] === '\\') {
      strBuf += code[i] + (i + 1 < len ? code[i + 1] : '');
      i += 2;
      continue;
    }
    if (code[i] === '$' && i + 1 < len && code[i + 1] === '{') {
      if (strBuf) {
        tokens.push(...lang.tokenize(strBuf));
        strBuf = '';
      }
      tokens.push({ type: 'punc', text: '${' });
      i += 2;
      let depth = 1;
      let exprStart = i;
      while (i < len && depth > 0) {
        if (code[i] === '{') depth++;
        else if (code[i] === '}') { depth--; if (depth === 0) break; }
        else if (code[i] === '`') {
          i++;
          while (i < len && code[i] !== '`') {
            if (code[i] === '\\') i++;
            i++;
          }
        } else if (code[i] === '"' || code[i] === "'") {
          const q = code[i]; i++;
          while (i < len && code[i] !== q) {
            if (code[i] === '\\') i++;
            i++;
          }
        }
        i++;
      }
      const expr = code.slice(exprStart, i);
      if (expr) tokens.push(...tokenize(expr));
      if (i < len && code[i] === '}') {
        tokens.push({ type: 'punc', text: '}' });
        i++;
      }
      continue;
    }
    strBuf += code[i];
    i++;
  }
  if (strBuf) tokens.push(...lang.tokenize(strBuf));
  if (i < len && code[i] === '`') {
    tokens.push({ type: 'punc', text: '`' });
    i++;
  }
  return i;
}

function tokenize(code) {
  const tokens = [];
  let i = 0;
  const len = code.length;

  while (i < len) {
    // line comment
    if (code[i] === '/' && code[i+1] === '/') {
      const start = i;
      while (i < len && code[i] !== '\n') i++;
      tokens.push({ type: 'cmt', text: code.slice(start, i) });
      continue;
    }
    // block comment
    if (code[i] === '/' && code[i+1] === '*') {
      const start = i;
      i += 2;
      while (i < len && !(code[i-1] === '*' && code[i] === '/')) i++;
      if (i < len) i++;
      tokens.push({ type: 'cmt', text: code.slice(start, i) });
      continue;
    }
    // strings
    if (code[i] === '"' || code[i] === "'" || code[i] === '`') {
      // curried tagged template: lang({...})`...` — detect before treating as plain string
      if (code[i] === '`' && typeof window !== 'undefined' && window._taggedLanguages) {
        const lang = detectCurriedTag(tokens);
        if (lang) {
          i = tokenizeTaggedTemplate(code, i, len, lang, tokens);
          continue;
        }
      }
      const q = code[i];
      const start = i;
      i++;
      while (i < len && code[i] !== q) {
        if (code[i] === '\\') i++;
        i++;
      }
      if (i < len) i++;
      tokens.push({ type: 'str', text: code.slice(start, i) });
      continue;
    }
    // numbers
    if (/\d/.test(code[i]) || (code[i] === '.' && i+1 < len && /\d/.test(code[i+1]))) {
      const start = i;
      if (code[i] === '0' && (code[i+1] === 'x' || code[i+1] === 'X')) {
        i += 2;
        while (i < len && /[0-9a-fA-F_]/.test(code[i])) i++;
      } else {
        while (i < len && /[0-9._eE+-]/.test(code[i])) i++;
      }
      tokens.push({ type: 'num', text: code.slice(start, i) });
      continue;
    }
    // identifiers / keywords
    if (/[a-zA-Z_$]/.test(code[i])) {
      const start = i;
      while (i < len && /\w/.test(code[i])) i++;
      const word = code.slice(start, i);

      // tagged template literal — delegate to registered language tokenizer
      if (i < len && code[i] === '`' && typeof window !== 'undefined'
          && window._taggedLanguages && window._taggedLanguages[word]) {
        tokens.push({ type: 'fn', text: word });
        i = tokenizeTaggedTemplate(code, i, len, window._taggedLanguages[word], tokens);
        continue;
      }

      if (JS_KEYWORDS.has(word)) {
        tokens.push({ type: 'kw', text: word });
      } else if (JS_BUILTINS.has(word)) {
        tokens.push({ type: 'const', text: word });
      } else if (i < len && code[i] === '(') {
        tokens.push({ type: 'fn', text: word });
      } else {
        tokens.push({ type: 'id', text: word });
      }
      continue;
    }
    // operators
    if ('=+-*/<>!&|^~%?:'.includes(code[i])) {
      tokens.push({ type: 'op', text: code[i] });
      i++;
      continue;
    }
    // punctuation
    if ('(){}[];,.'.includes(code[i])) {
      tokens.push({ type: 'punc', text: code[i] });
      i++;
      continue;
    }
    // whitespace / other — pass through
    tokens.push({ type: '', text: code[i] });
    i++;
  }

  return tokens;
}

function highlightCode(ta, hl) {
  const code = ta.value;
  if (!code) { hl.innerHTML = '\n'; return; }

  const tokens = tokenize(code);
  let html = '';
  for (const t of tokens) {
    const escaped = t.text
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;');
    if (t.type && t.type !== 'id') {
      html += `<span class="hl-${t.type}">${escaped}</span>`;
    } else {
      html += escaped;
    }
  }
  // trailing newline so highlight layer matches textarea height
  hl.innerHTML = html + '\n';
}

// ── CSS SYNTAX HIGHLIGHTING ──

function tokenizeCss(code) {
  const tokens = [];
  let i = 0;
  const len = code.length;
  let ctx = 'sel'; // 'sel' | 'prop' | 'val'
  let depth = 0;

  while (i < len) {
    // block comment
    if (code[i] === '/' && code[i+1] === '*') {
      const start = i;
      i += 2;
      while (i < len && !(code[i-1] === '*' && code[i] === '/')) i++;
      if (i < len) i++;
      tokens.push({ type: 'cmt', text: code.slice(start, i) });
      continue;
    }
    // strings
    if (code[i] === '"' || code[i] === "'") {
      const q = code[i];
      const start = i;
      i++;
      while (i < len && code[i] !== q) {
        if (code[i] === '\\') i++;
        i++;
      }
      if (i < len) i++;
      tokens.push({ type: 'str', text: code.slice(start, i) });
      continue;
    }
    // punctuation with context transitions
    if (code[i] === '{') {
      tokens.push({ type: 'punc', text: '{' });
      depth++;
      ctx = 'prop';
      i++;
      continue;
    }
    if (code[i] === '}') {
      tokens.push({ type: 'punc', text: '}' });
      depth--;
      ctx = depth > 0 ? 'prop' : 'sel';
      i++;
      continue;
    }
    if (code[i] === ':' && ctx === 'prop') {
      tokens.push({ type: 'punc', text: ':' });
      ctx = 'val';
      i++;
      continue;
    }
    if (code[i] === ';') {
      tokens.push({ type: 'punc', text: ';' });
      ctx = 'prop';
      i++;
      continue;
    }
    if ('(),'.includes(code[i])) {
      tokens.push({ type: 'punc', text: code[i] });
      i++;
      continue;
    }
    // @-rules
    if (code[i] === '@') {
      const start = i;
      i++;
      while (i < len && /[a-zA-Z-]/.test(code[i])) i++;
      tokens.push({ type: 'atrule', text: code.slice(start, i) });
      continue;
    }
    // !important
    if (code[i] === '!' && ctx === 'val') {
      const start = i;
      i++;
      while (i < len && /[a-zA-Z]/.test(code[i])) i++;
      tokens.push({ type: 'important', text: code.slice(start, i) });
      continue;
    }
    // # — hex color in val, ID selector in sel
    if (code[i] === '#') {
      if (ctx === 'val') {
        const start = i;
        i++;
        while (i < len && /[0-9a-fA-F]/.test(code[i])) i++;
        tokens.push({ type: 'color', text: code.slice(start, i) });
      } else {
        // ID selector
        const start = i;
        i++;
        while (i < len && /[\w-]/.test(code[i])) i++;
        tokens.push({ type: 'sel', text: code.slice(start, i) });
      }
      continue;
    }
    // : in selector context = pseudo-class
    if (code[i] === ':' && ctx === 'sel') {
      const start = i;
      i++;
      if (i < len && code[i] === ':') i++; // ::
      while (i < len && /[a-zA-Z-]/.test(code[i])) i++;
      // handle pseudo with parens like :nth-child(...)
      if (i < len && code[i] === '(') {
        i++;
        let pdepth = 1;
        while (i < len && pdepth > 0) {
          if (code[i] === '(') pdepth++;
          else if (code[i] === ')') pdepth--;
          if (pdepth > 0) i++;
        }
        if (i < len) i++;
      }
      tokens.push({ type: 'sel', text: code.slice(start, i) });
      continue;
    }
    // . in selector context = class selector
    if (code[i] === '.' && ctx === 'sel') {
      const start = i;
      i++;
      while (i < len && /[\w-]/.test(code[i])) i++;
      tokens.push({ type: 'sel', text: code.slice(start, i) });
      continue;
    }
    // numbers (with units)
    if (ctx === 'val' && (/\d/.test(code[i]) || (code[i] === '.' && i+1 < len && /\d/.test(code[i+1])))) {
      const start = i;
      while (i < len && /[0-9.]/.test(code[i])) i++;
      // units
      while (i < len && /[a-zA-Z%]/.test(code[i])) i++;
      tokens.push({ type: 'num', text: code.slice(start, i) });
      continue;
    }
    // identifiers
    if (/[a-zA-Z_-]/.test(code[i])) {
      const start = i;
      while (i < len && /[\w-]/.test(code[i])) i++;
      const word = code.slice(start, i);
      // function call
      if (i < len && code[i] === '(') {
        tokens.push({ type: 'fn', text: word });
        continue;
      }
      if (ctx === 'val' && CSS_NAMED_COLORS.has(word.toLowerCase())) {
        tokens.push({ type: 'color', text: word });
      } else if (ctx === 'prop') {
        tokens.push({ type: 'prop', text: word });
      } else if (ctx === 'sel') {
        tokens.push({ type: 'sel', text: word });
      } else {
        tokens.push({ type: '', text: word });
      }
      continue;
    }
    // whitespace / other
    tokens.push({ type: '', text: code[i] });
    i++;
  }

  return tokens;
}

function resolveToHex(colorStr) {
  const d = document.createElement('div');
  d.style.color = colorStr;
  document.body.appendChild(d);
  const rgb = getComputedStyle(d).color;
  d.remove();
  const m = rgb.match(/(\d+)/g);
  if (!m || m.length < 3) return colorStr;
  return '#' + m.slice(0, 3).map(n => parseInt(n).toString(16).padStart(2, '0')).join('');
}

let _colorPicker = null;
let _pickerTarget = null; // { ta, offset, len }

function ensureColorPicker() {
  if (_colorPicker) return _colorPicker;
  _colorPicker = document.createElement('input');
  _colorPicker.type = 'color';
  _colorPicker.style.cssText = 'position:absolute;visibility:hidden;width:0;height:0;';
  document.body.appendChild(_colorPicker);
  _colorPicker.addEventListener('input', () => {
    if (!_pickerTarget) return;
    const { ta, offset, len } = _pickerTarget;
    const newColor = _colorPicker.value;
    ta.focus();
    ta.selectionStart = offset;
    ta.selectionEnd = offset + len;
    document.execCommand('insertText', false, newColor);
    ta.dispatchEvent(new Event('input'));
    // update offset for new length
    _pickerTarget.len = newColor.length;
  });
  return _colorPicker;
}

function highlightCss(ta, hl) {
  const code = ta.value;
  if (!code) { hl.innerHTML = '\n'; return; }

  const tokens = tokenizeCss(code);
  let html = '';
  let offset = 0;
  for (const t of tokens) {
    const escaped = t.text
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;');
    if (t.type === 'color') {
      const hex = resolveToHex(t.text);
      html += `<span class="hl-color"><span class="hl-swatch" style="background:${hex}" data-offset="${offset}" data-len="${t.text.length}"></span>${escaped}</span>`;
    } else if (t.type && t.type !== 'id') {
      html += `<span class="hl-${t.type}">${escaped}</span>`;
    } else {
      html += escaped;
    }
    offset += t.text.length;
  }
  hl.innerHTML = html + '\n';

  // wire swatch clicks (only add once per highlight layer)
  if (!hl._swatchWired) {
    hl._swatchWired = true;
    hl.addEventListener('click', (e) => {
      const swatch = e.target.closest('.hl-swatch');
      if (!swatch) return;
      const off = parseInt(swatch.dataset.offset);
      const len = parseInt(swatch.dataset.len);
      const picker = ensureColorPicker();
      _pickerTarget = { ta, offset: off, len };
      const hex = resolveToHex(ta.value.slice(off, off + len));
      picker.value = hex;
      picker.click();
    });
  }
}

// ── HTML SYNTAX HIGHLIGHTING ──

function tokenizeHtml(code) {
  const tokens = [];
  let i = 0;
  const len = code.length;

  while (i < len) {
    // template expression ${...}
    if (code[i] === '$' && i + 1 < len && code[i + 1] === '{') {
      const start = i;
      i += 2;
      let depth = 1;
      while (i < len && depth > 0) {
        if (code[i] === '{') depth++;
        else if (code[i] === '}') depth--;
        if (depth > 0) i++;
      }
      if (i < len) i++;
      tokens.push({ type: 'expr', text: code.slice(start, i) });
      continue;
    }
    // comment <!-- ... -->
    if (code[i] === '<' && code[i + 1] === '!' && code[i + 2] === '-' && code[i + 3] === '-') {
      const start = i;
      i += 4;
      while (i < len) {
        if (code[i] === '-' && code[i + 1] === '-' && code[i + 2] === '>') { i += 3; break; }
        i++;
      }
      tokens.push({ type: 'cmt', text: code.slice(start, i) });
      continue;
    }
    // tag
    if (code[i] === '<') {
      tokens.push({ type: 'tag', text: '<' });
      i++;
      // closing slash
      if (i < len && code[i] === '/') { tokens.push({ type: 'tag', text: '/' }); i++; }
      // tag name
      const ns = i;
      while (i < len && /[a-zA-Z0-9-]/.test(code[i])) i++;
      if (i > ns) tokens.push({ type: 'tag', text: code.slice(ns, i) });
      // attributes until >
      while (i < len && code[i] !== '>') {
        // template expression inside tag
        if (code[i] === '$' && i + 1 < len && code[i + 1] === '{') {
          const start = i;
          i += 2;
          let depth = 1;
          while (i < len && depth > 0) {
            if (code[i] === '{') depth++;
            else if (code[i] === '}') depth--;
            if (depth > 0) i++;
          }
          if (i < len) i++;
          tokens.push({ type: 'expr', text: code.slice(start, i) });
          continue;
        }
        if (/\s/.test(code[i])) { tokens.push({ type: '', text: code[i] }); i++; continue; }
        if (code[i] === '/') { tokens.push({ type: 'tag', text: '/' }); i++; continue; }
        if (code[i] === '=') { tokens.push({ type: 'punc', text: '=' }); i++; continue; }
        // quoted attribute value
        if (code[i] === '"' || code[i] === "'") {
          const q = code[i];
          const start = i;
          i++;
          while (i < len && code[i] !== q) { if (code[i] === '\\') i++; i++; }
          if (i < len) i++;
          tokens.push({ type: 'str', text: code.slice(start, i) });
          continue;
        }
        // attribute name or unquoted value
        const as = i;
        while (i < len && !/[\s=>/"']/.test(code[i])) i++;
        if (i > as) {
          let j = i;
          while (j < len && /\s/.test(code[j])) j++;
          tokens.push({ type: (j < len && code[j] === '=') ? 'attr' : 'attr', text: code.slice(as, i) });
        }
      }
      if (i < len && code[i] === '>') { tokens.push({ type: 'tag', text: '>' }); i++; }
      continue;
    }
    // plain text
    tokens.push({ type: '', text: code[i] });
    i++;
  }

  return tokens;
}

function highlightHtml(ta, hl) {
  const code = ta.value;
  if (!code) { hl.innerHTML = '\n'; return; }

  const tokens = tokenizeHtml(code);
  let html = '';
  for (const t of tokens) {
    const escaped = t.text
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;');
    if (t.type) {
      html += `<span class="hl-${t.type}">${escaped}</span>`;
    } else {
      html += escaped;
    }
  }
  hl.innerHTML = html + '\n';
}

// -- dag.js --

// ── REACTIVE DAG ──

// ── directive helpers ──

function hasDirective(code, name) {
  return new RegExp(String.raw`^\s*\/\/\s*%${name}\b`, 'm').test(code);
}

function getDirective(code, name) {
  const m = code.match(new RegExp(String.raw`^\s*\/\/\s*%${name}\s+(.+)`, 'm'));
  return m ? m[1].trim() : null;
}

const isManual    = code => hasDirective(code, 'manual');
const isHidden    = code => hasDirective(code, 'hide');
const isNorun     = code => hasDirective(code, 'norun');
const isCollapsed = code => hasDirective(code, 'collapsed');
const parseCellName    = code => getDirective(code, 'cellName');
const parseOutputId    = code => { const v = getDirective(code, 'outputId'); return v ? v.split(/\s+/)[0] : null; };
const parseOutputClass = code => getDirective(code, 'outputClass');

// ── code analysis ──

function stripCommentsAndStrings(code) {
  // single-pass: strings take precedence over comments (// inside "..." is not a comment)
  let out = '', i = 0;
  while (i < code.length) {
    // single-quoted string
    if (code[i] === "'") {
      out += '""';
      i++;
      while (i < code.length && code[i] !== "'") { if (code[i] === '\\') i++; i++; }
      i++; // skip closing quote
      continue;
    }
    // double-quoted string
    if (code[i] === '"') {
      out += '""';
      i++;
      while (i < code.length && code[i] !== '"') { if (code[i] === '\\') i++; i++; }
      i++; // skip closing quote
      continue;
    }
    // template literal: replace string parts with spaces but keep ${expr} content
    if (code[i] === '`') {
      i++;
      while (i < code.length && code[i] !== '`') {
        if (code[i] === '\\') { i += 2; continue; }
        if (code[i] === '$' && code[i + 1] === '{') {
          i += 2;
          let depth = 1;
          out += ' ';
          while (i < code.length && depth > 0) {
            if (code[i] === '{') depth++;
            else if (code[i] === '}') { depth--; if (depth === 0) break; }
            out += code[i];
            i++;
          }
          out += ' ';
          i++; // skip closing }
          continue;
        }
        i++;
      }
      i++; // skip closing backtick
      continue;
    }
    // line comment
    if (code[i] === '/' && code[i + 1] === '/') {
      while (i < code.length && code[i] !== '\n') i++;
      continue;
    }
    // block comment
    if (code[i] === '/' && code[i + 1] === '*') {
      i += 2;
      while (i < code.length && !(code[i - 1] === '*' && code[i] === '/')) i++;
      i++;
      continue;
    }
    out += code[i];
    i++;
  }
  return out;
}

function parseNames(code) {
  // extract ONLY top-level variable definitions (brace depth 0)
  const defines = new Set();

  const stripped = stripCommentsAndStrings(code);

  let depth = 0;
  let parenDepth = 0;
  let i = 0;
  while (i < stripped.length) {
    const ch = stripped[i];
    if (ch === '{') { depth++; i++; continue; }
    if (ch === '}') { depth--; i++; continue; }
    if (ch === '(') { parenDepth++; i++; continue; }
    if (ch === ')') { parenDepth--; i++; continue; }

    if (depth === 0 && parenDepth === 0) {
      // check for const/let/var
      const rest = stripped.slice(i);
      const dm = rest.match(/^(?:const|let|var)\s+(\w+)/);
      if (dm) {
        defines.add(dm[1]);
        // scan forward for comma-separated declarations: const W = 80, H = 60
        // skip initializer expressions tracking depth, grab identifiers after commas
        let j = dm[0].length;
        let d = 0, pd = 0, bd = 0;
        while (j < rest.length) {
          const ch = rest[j];
          if (ch === '{') d++;
          else if (ch === '}') d--;
          else if (ch === '(') pd++;
          else if (ch === ')') pd--;
          else if (ch === '[') bd++;
          else if (ch === ']') bd--;
          else if (ch === ';' || ch === '\n') {
            if (d === 0 && pd === 0 && bd === 0) break;
          }
          else if (ch === ',' && d === 0 && pd === 0 && bd === 0) {
            // next identifier after comma
            const after = rest.slice(j + 1).match(/^\s*(\w+)/);
            if (after) defines.add(after[1]);
          }
          j++;
        }
        i += j;
        continue;
      }
      // destructuring: const { a, b } = ... or const [ a, b ] = ...
      const destruct = rest.match(/^(?:const|let|var)\s*[\{\[]/);
      if (destruct) {
        // find the closing } or ] then extract identifiers
        const opener = rest[destruct[0].length - 1];
        const closer = opener === '{' ? '}' : ']';
        const closeIdx = rest.indexOf(closer, destruct[0].length);
        if (closeIdx > 0) {
          const inner = rest.slice(destruct[0].length, closeIdx);
          // split on commas, take last word of each part (handles renaming)
          inner.split(',').forEach(part => {
            const parts = part.trim().split(/\s*:\s*/);
            const name = (parts.length > 1 ? parts[1] : parts[0]).trim().match(/^\w+/);
            if (name) defines.add(name[0]);
          });
          i += closeIdx + 1;
          continue;
        }
      }
      // check for function declarations
      const fm = rest.match(/^function\s+(\w+)/);
      if (fm) {
        defines.add(fm[1]);
        i += fm[0].length;
        continue;
      }
    }
    i++;
  }

  return { defines };
}

function findUses(code, allDefined, selfDefined) {
  // find identifiers that reference other cells' definitions
  const uses = new Set();
  const stripped = stripCommentsAndStrings(code);
  if (!selfDefined) selfDefined = parseNames(code).defines;

  const idRe = /\b([a-zA-Z_$]\w*)\b/g;
  let m;
  while ((m = idRe.exec(stripped))) {
    if (allDefined.has(m[1]) && !selfDefined.has(m[1])) {
      uses.add(m[1]);
    }
  }
  return uses;
}

function findHtmlUses(code, allDefined) {
  const uses = new Set();
  const re = /\$\{([^}]+)\}/g;
  let m;
  while ((m = re.exec(code))) {
    const expr = m[1];
    const idRe = /\b([a-zA-Z_$]\w*)\b/g;
    let im;
    while ((im = idRe.exec(expr))) {
      if (allDefined.has(im[1])) uses.add(im[1]);
    }
  }
  return uses;
}

function buildDAG() {
  // collect all defined names globally (only re-parse changed cells)
  const allDefined = new Map(); // name -> cell id
  for (const c of S.cells) {
    if (c.type !== 'code') continue;
    if (c.code !== c._parsedCode) {
      const { defines } = parseNames(c.code);
      c.defines = defines;
      c._parsedCode = c.code;
    }
    for (const name of c.defines) {
      allDefined.set(name, c.id);
    }
  }

  // find uses for each cell (invalidate if code changed or global names changed)
  const definedNames = new Set(allDefined.keys());
  const definedKey = [...definedNames].sort().join(',');
  for (const c of S.cells) {
    if (c.type === 'code') {
      if (c.code !== c._usesCode || c._definedKey !== definedKey) {
        c.uses = findUses(c.code, definedNames, c.defines);
        c._usesCode = c.code;
        c._definedKey = definedKey;
      }
    } else if (c.type === 'html') {
      if (c.code !== c._usesCode || c._definedKey !== definedKey) {
        c.uses = findHtmlUses(c.code, definedNames);
        c._usesCode = c.code;
        c._definedKey = definedKey;
      }
    }
  }

  return allDefined;
}

function topoSort(dirtyIds) {
  // BFS from dirty cells to find all downstream dependents
  const dependents = new Map(); // varName -> Set<cellId>
  for (const c of S.cells) {
    if (!c.uses) continue;
    for (const name of c.uses) {
      if (!dependents.has(name)) dependents.set(name, new Set());
      dependents.get(name).add(c.id);
    }
  }

  const needsRun = new Set(dirtyIds);
  const queue = [...dirtyIds];
  while (queue.length) {
    const id = queue.shift();
    const cell = S.cells.find(c => c.id === id);
    if (!cell || !cell.defines) continue;
    for (const name of cell.defines) {
      const deps = dependents.get(name);
      if (!deps) continue;
      for (const depId of deps) {
        if (!needsRun.has(depId)) {
          needsRun.add(depId);
          queue.push(depId);
        }
      }
    }
  }

  // return in document order
  return S.cells.filter(c => needsRun.has(c.id)).map(c => c.id);
}

// -- exec.js --

// ── EXECUTION ENGINE ──
//
// Scope model: each cell runs inside an AsyncFunction where upstream variables
// are passed as parameters. This is pass-by-value for primitives — reassigning
// a variable in cell A (e.g. `grid = next`) does NOT propagate to cell B.
// Mutable state that needs to survive across callbacks belongs in %manual cells
// using DOM elements, objects, or closures.
//
// Cell builtins (display, canvas, slider, load, install, installBinary, etc.)
// are injected as additional parameters — listed in _injected, not in scope.
// They are NOT propagated to downstream cells.

// ── BINARY HELPERS ──

function uint8ToBase64(bytes) {
  let bin = '';
  for (let i = 0; i < bytes.length; i++) bin += String.fromCharCode(bytes[i]);
  return btoa(bin);
}

async function decodeBinary(entry) {
  const type = entry.type || 'application/octet-stream';
  const bytes = Uint8Array.from(atob(entry.source), c => c.charCodeAt(0));
  if (entry.compressed) {
    const ds = new DecompressionStream('gzip');
    const stream = new Blob([bytes]).stream().pipeThrough(ds);
    const decompressed = new Uint8Array(await new Response(stream).arrayBuffer());
    return URL.createObjectURL(new Blob([decompressed], { type }));
  }
  return URL.createObjectURL(new Blob([bytes], { type }));
}

// ── TAGGED CONTENT ──

class TaggedContent {
  constructor(type, content) { this.type = type; this.content = content; }
  toString() { return this.content; }
}

function taggedTemplate(type) {
  return (strings, ...values) => {
    let result = strings[0];
    for (let i = 0; i < values.length; i++) result += String(values[i]) + strings[i + 1];
    return new TaggedContent(type, result);
  };
}

// ── EXECUTION ──

function renderHtmlCell(cell) {
  const viewEl = cell.el.querySelector('.cell-html-view');
  const outputEl = cell.el.querySelector('.cell-output');
  if (!viewEl) return;
  if (outputEl) { outputEl.textContent = ''; outputEl.className = 'cell-output'; }

  // use only variables this cell references for stable function signatures
  const scopeKeys = cell.uses ? [...cell.uses].sort() : [];
  const scopeVals = scopeKeys.map(k => S.scope[k]);

  // cache compiled template functions per expression
  if (!cell._tplCache) cell._tplCache = {};
  const scopeSig = scopeKeys.join(',');
  if (cell._tplScopeSig !== scopeSig) {
    cell._tplCache = {};  // scope signature changed, invalidate all
    cell._tplScopeSig = scopeSig;
  }

  let rendered = cell.code.replace(/\$\{([^}]+)\}/g, (match, expr) => {
    try {
      let fn = cell._tplCache[expr];
      if (!fn) {
        fn = new Function(...scopeKeys, '"use strict"; return (' + expr + ')');
        cell._tplCache[expr] = fn;
      }
      const val = fn(...scopeVals);
      return val === undefined ? '' : String(val);
    } catch (e) {
      return '[Error: ' + e.message + ']';
    }
  });

  viewEl.innerHTML = rendered;
  cell.el.classList.remove('stale', 'error');
  cell.el.classList.add('fresh');
  setTimeout(() => cell.el.classList.remove('fresh'), 800);
}

async function execCell(cell) {
  // fire invalidation promise from previous run (cleanup resources)
  if (cell._invalidate) { cell._invalidate(); cell._invalidate = null; }

  const outputEl = cell.el.querySelector('.cell-output');
  const widgetEl = cell.el.querySelector('.cell-widgets');

  // preserve canvases before clearing output
  const prevCanvases = [...outputEl.querySelectorAll('canvas')];
  outputEl.textContent = '';
  outputEl.className = 'cell-output';
  const outClass = parseOutputClass(cell.code);
  if (outClass) outputEl.classList.add(...outClass.split(/\s+/));
  const outId = parseOutputId(cell.code);
  outputEl.id = outId || '';
  cell.el.classList.toggle('present-hidden', isHidden(cell.code));
  cell.error = null;

  // create invalidation promise for this run
  let invalidationResolve;
  const invalidation = new Promise(r => { invalidationResolve = r; });
  cell._invalidate = invalidationResolve;

  // track which widgets are used this run
  const usedWidgets = new Set();
  let canvasIdx = 0;

  // build display function for this cell
  const display = (...args) => {
    for (const arg of args) {
      if (arg instanceof Element) {
        outputEl.appendChild(arg);
      } else if (typeof arg === 'object' && arg !== null) {
        const pre = document.createElement('span');
        try { pre.textContent = JSON.stringify(arg, null, 2); }
        catch { pre.textContent = String(arg); }
        outputEl.appendChild(pre);
        outputEl.appendChild(document.createTextNode('\n'));
      } else {
        outputEl.appendChild(document.createTextNode(String(arg) + '\n'));
      }
    }
  };

  // canvas helper — reuses existing canvas if dimensions match
  const canvas = (w = 400, h = 300) => {
    const prev = prevCanvases[canvasIdx++];
    if (prev && prev.width === w && prev.height === h) {
      outputEl.appendChild(prev);
      return prev;
    }
    const c = document.createElement('canvas');
    c.width = w; c.height = h;
    c.style.background = '#000';
    outputEl.appendChild(c);
    return c;
  };

  // table helper
  const table = (data, columns) => {
    if (!data || !data.length) return;
    const cols = columns || Object.keys(data[0]);

    // detect numeric columns by scanning first 10 rows
    const isNumCol = {};
    for (const c of cols) {
      let allNum = true;
      const scanRows = data.slice(0, 10);
      for (const row of scanRows) {
        const v = row[c];
        if (v !== null && v !== undefined && typeof v !== 'number') { allNum = false; break; }
      }
      isNumCol[c] = allNum;
    }

    const t = document.createElement('table');
    const thead = document.createElement('thead');
    const hr = document.createElement('tr');
    for (const c of cols) {
      const th = document.createElement('th');
      th.textContent = c;
      th.style.textAlign = isNumCol[c] ? 'right' : 'left';
      hr.appendChild(th);
    }
    thead.appendChild(hr);
    t.appendChild(thead);
    const tbody = document.createElement('tbody');
    for (const row of data) {
      const tr = document.createElement('tr');
      for (const c of cols) {
        const td = document.createElement('td');
        const v = row[c];
        td.textContent = typeof v === 'number' ? (Number.isInteger(v) ? v : v.toFixed(4)) : String(v ?? '');
        td.style.textAlign = isNumCol[c] ? 'right' : 'left';
        tr.appendChild(td);
      }
      tbody.appendChild(tr);
    }
    t.appendChild(tbody);
    outputEl.appendChild(t);
  };

  // input widget helpers — persist state and DOM across re-runs
  if (!cell._inputs) cell._inputs = {};
  if (!cell._callbacks) cell._callbacks = {};

  const mkInput = (label, type, defaultVal, opts = {}) => {
    const key = label;
    const prev = cell._inputs[key];
    let val = prev !== undefined ? prev : defaultVal;
    usedWidgets.add(key);
    cell._callbacks[key] = { onInput: opts.onInput, onChange: opts.onChange };

    // check if widget DOM already exists
    const existing = widgetEl.querySelector(`[data-widget-key="${CSS.escape(key)}"]`);
    if (existing) {
      // update id/class in case they changed on re-run
      existing.id = opts.id || '';
      existing.className = 'cell-widget' + (opts.class ? ' ' + opts.class : '');
      // just return current value, DOM stays — callbacks already updated above
      cell._inputs[key] = type === 'slider' ? parseFloat(val)
                         : type === 'checkbox' ? !!val
                         : val;
      return cell._inputs[key];
    }

    // create new widget
    const wrap = document.createElement('div');
    wrap.dataset.widgetKey = key;
    wrap.className = 'cell-widget' + (opts.class ? ' ' + opts.class : '');
    if (opts.id) wrap.id = opts.id;

    const lbl = document.createElement('span');
    lbl.textContent = label;
    lbl.className = 'cell-widget-label';
    wrap.appendChild(lbl);

    let input;
    if (type === 'slider') {
      input = document.createElement('input');
      input.type = 'range';
      input.min = opts.min ?? 0;
      input.max = opts.max ?? 100;
      input.step = opts.step ?? 1;
      input.value = val;
      const valSpan = document.createElement('span');
      valSpan.textContent = val;
      valSpan.className = 'cell-widget-val';
      input.oninput = () => {
        const n = parseFloat(input.value);
        cell._inputs[key] = n;
        valSpan.textContent = n;
        const cb = cell._callbacks[key];
        if (cb.onInput) { cb.onInput(n); }
        else if (!cb.onChange) { clearTimeout(cell._inputTimer); cell._inputTimer = setTimeout(() => runDAG([cell.id], true), 80); }
      };
      input.onchange = () => { const cb = cell._callbacks[key]; if (cb.onChange) cb.onChange(parseFloat(input.value)); };
      wrap.appendChild(input);
      wrap.appendChild(valSpan);
    } else if (type === 'dropdown') {
      input = document.createElement('select');
      for (const o of (opts.options || [])) {
        const opt = document.createElement('option');
        opt.value = o;
        opt.textContent = o;
        if (o === val) opt.selected = true;
        input.appendChild(opt);
      }
      input.onchange = () => {
        cell._inputs[key] = input.value;
        const cb = cell._callbacks[key];
        if (cb.onInput || cb.onChange) {
          if (cb.onInput) cb.onInput(input.value);
          if (cb.onChange) cb.onChange(input.value);
        } else { runDAG([cell.id], true); }
      };
      wrap.appendChild(input);
    } else if (type === 'checkbox') {
      input = document.createElement('input');
      input.type = 'checkbox';
      input.checked = !!val;
      input.onchange = () => {
        cell._inputs[key] = input.checked;
        const cb = cell._callbacks[key];
        if (cb.onInput || cb.onChange) {
          if (cb.onInput) cb.onInput(input.checked);
          if (cb.onChange) cb.onChange(input.checked);
        } else { runDAG([cell.id], true); }
      };
      wrap.appendChild(input);
    } else if (type === 'text') {
      input = document.createElement('input');
      input.type = 'text';
      input.value = val;
      input.oninput = () => {
        cell._inputs[key] = input.value;
        const cb = cell._callbacks[key];
        if (cb.onInput) { cb.onInput(input.value); }
        else if (!cb.onChange) { clearTimeout(cell._inputTimer); cell._inputTimer = setTimeout(() => runDAG([cell.id], true), 300); }
      };
      input.onchange = () => { const cb = cell._callbacks[key]; if (cb.onChange) cb.onChange(input.value); };
      wrap.appendChild(input);
    }

    widgetEl.appendChild(wrap);
    cell._inputs[key] = type === 'slider' ? parseFloat(val)
                       : type === 'checkbox' ? !!val
                       : val;
    return cell._inputs[key];
  };

  const slider = (label, defaultVal = 50, opts = {}) => mkInput(label, 'slider', defaultVal, opts);
  const dropdown = (label, options, defaultVal, opts = {}) => mkInput(label, 'dropdown', defaultVal || options[0], { ...opts, options });
  const checkbox = (label, defaultVal = false, opts = {}) => mkInput(label, 'checkbox', defaultVal, opts);
  const textInput = (label, defaultVal = '', opts = {}) => mkInput(label, 'text', defaultVal, opts);

  // execute with scoped parameters (only what this cell uses, for stable V8 JIT)
  // filter out injected names — they're per-cell params, not scope-propagated
  const _injected = ['ui', 'std', 'load', 'install', 'installBinary', 'invalidation', 'print', 'md', 'html', 'css', 'workshop', 'notebook'];
  const scopeKeys = cell.uses ? [...cell.uses].filter(k => !_injected.includes(k)).sort() : [];
  const defNames = cell.defines ? [...cell.defines].sort().join(', ') : '';

  // import cache — shared across all cells
  if (!window._importCache) window._importCache = {};
  if (!window._installedModules) window._installedModules = {}; // url -> { source, cellId }

  const load = async (url) => {
    // virtual modules
    if (url === '@std') return std;
    if (url === '@python') return python;
    if (url === '@python/this') { display(zenOfPython()); return python; }
    if (window._importCache[url]) return window._importCache[url];

    // binary assets — return blob URL
    if (window._installedModules[url]?.binary) {
      const blobUrl = await decodeBinary(window._installedModules[url]);
      window._importCache[url] = blobUrl;
      return blobUrl;
    }

    const langsBefore = window._taggedLanguages ? Object.keys(window._taggedLanguages).length : 0;

    let mod;
    // check installed (offline) modules first
    if (window._installedModules[url]) {
      const entry = window._installedModules[url];
      let src = typeof entry === 'string' ? entry : entry.source;
      // resolve root-relative paths for legacy saved modules
      try { src = resolveModulePaths(src, url); } catch {}
      const blob = new Blob([src], { type: 'application/javascript' });
      const blobUrl = URL.createObjectURL(blob);
      mod = await import(blobUrl);
    } else {
      mod = await import(url);
    }
    window._importCache[url] = mod;

    // if the module registered new tagged languages, re-highlight all code cells
    const langsAfter = window._taggedLanguages ? Object.keys(window._taggedLanguages).length : 0;
    if (langsAfter > langsBefore) {
      for (const c of S.cells) {
        if (c.type !== 'code') continue;
        const ta = c.el.querySelector('textarea');
        const hl = c.el.querySelector('.highlight-layer');
        if (ta && hl) highlightCode(ta, hl);
      }
    }

    return mod;
  };

  // resolve root-relative paths in module source so blob URLs work
  const resolveModulePaths = (source, responseUrl) => {
    const origin = new URL(responseUrl).origin;
    return source.replace(/(from\s+["'])(\/[^"']+)(["'])/g, '$1' + origin + '$2$3')
                 .replace(/(import\s*\(["'])(\/[^"']+)(["']\))/g, '$1' + origin + '$2$3')
                 .replace(/(export\s+\*\s+from\s+["'])(\/[^"']+)(["'])/g, '$1' + origin + '$2$3')
                 .replace(/(export\s*\{[^}]*\}\s*from\s+["'])(\/[^"']+)(["'])/g, '$1' + origin + '$2$3');
  };

  const install = async (url) => {
    // normalize: add ?bundle for esm.sh if not present
    let bundleUrl = url;
    if (bundleUrl.includes('esm.sh') && !bundleUrl.includes('?bundle') && !bundleUrl.includes('&bundle')) {
      bundleUrl += (bundleUrl.includes('?') ? '&' : '?') + 'bundle';
    }
    // fetch source
    const resp = await fetch(bundleUrl);
    if (!resp.ok) throw new Error(`Failed to fetch ${bundleUrl}: ${resp.status}`);
    let source = await resp.text();
    // resolve root-relative paths to absolute so blob URLs work
    source = resolveModulePaths(source, resp.url);
    // store under original url with cell reference
    window._installedModules[url] = { source, cellId: cell.id };
    // also load it into cache
    const blob = new Blob([source], { type: 'application/javascript' });
    const blobUrl = URL.createObjectURL(blob);
    const mod = await import(blobUrl);
    window._importCache[url] = mod;
    display(`installed ${url} (${(source.length / 1024).toFixed(1)} KB)`);
    return mod;
  };

  const installBinary = async (url, opts = {}) => {
    const compress = opts.compress !== false;
    // if already installed, decode and return blob URL
    if (window._installedModules[url]?.binary) {
      return decodeBinary(window._installedModules[url]);
    }
    const resp = await fetch(url);
    if (!resp.ok) throw new Error(`Failed to fetch ${url}: ${resp.status}`);
    const contentType = resp.headers.get('content-type')?.split(';')[0] || 'application/octet-stream';
    const buf = await resp.arrayBuffer();
    const raw = new Uint8Array(buf);
    let stored, isCompressed = false;
    if (compress) {
      const cs = new CompressionStream('gzip');
      const stream = new Blob([raw]).stream().pipeThrough(cs);
      const compressed = new Uint8Array(await new Response(stream).arrayBuffer());
      stored = uint8ToBase64(compressed);
      isCompressed = true;
    } else {
      stored = uint8ToBase64(raw);
    }
    window._installedModules[url] = { source: stored, cellId: cell.id, binary: true, compressed: isCompressed, type: contentType };
    const ratio = isCompressed ? ` \u2192 ${(stored.length / 1024).toFixed(1)} KB compressed` : '';
    display(`installed binary ${url} (${(buf.byteLength / 1024).toFixed(1)} KB${ratio})`);
    return URL.createObjectURL(new Blob([raw], { type: contentType }));
  };

  // ui object — constructed per-cell (closes over cell context)
  const ui = { display, print: display, canvas, table, slider, dropdown, checkbox, textInput };

  // tagged template builtins
  const md = taggedTemplate('md');
  const html = taggedTemplate('html');
  const css = taggedTemplate('css');

  // workshop builtin — slide-out side panel with navigable pages
  const workshop = (pages, opts) => {
    const key = '__workshop__';
    usedWidgets.add(key);
    const useOverlay = !!(opts && opts.overlay);

    // persist page index across re-runs
    if (cell._inputs[key] === undefined) cell._inputs[key] = 0;
    let currentPage = cell._inputs[key];

    // get or create panel DOM
    let panel = document.getElementById('workshopPanel');
    let overlay = document.getElementById('workshopOverlay');
    if (!panel) {
      overlay = document.createElement('div');
      overlay.id = 'workshopOverlay';
      overlay.className = 'workshop-overlay';
      overlay.onclick = () => toggleWorkshop(false);
      document.body.appendChild(overlay);

      panel = document.createElement('div');
      panel.id = 'workshopPanel';
      panel.className = 'workshop-panel';
      document.body.appendChild(panel);
    }

    // side tab attached to the panel edge
    let toggleBtn = document.getElementById('workshopToggle');
    if (!toggleBtn) {
      toggleBtn = document.createElement('button');
      toggleBtn.id = 'workshopToggle';
      toggleBtn.className = 'workshop-tab';
      toggleBtn.title = 'toggle workshop panel';
      toggleBtn.textContent = 'workshop';
      document.body.appendChild(toggleBtn);
      toggleBtn.onclick = () => toggleWorkshop();
    }

    function toggleWorkshop(show) {
      const isOpen = panel.classList.contains('open');
      const shouldOpen = show !== undefined ? show : !isOpen;
      panel.classList.toggle('open', shouldOpen);
      if (useOverlay) overlay.classList.toggle('visible', shouldOpen);
    }

    function renderPage(idx) {
      idx = Math.max(0, Math.min(idx, pages.length - 1));
      currentPage = idx;
      cell._inputs[key] = idx;
      const page = pages[idx];

      panel.innerHTML = '';

      // header with close button
      const header = document.createElement('div');
      header.className = 'workshop-header';
      const title = document.createElement('span');
      title.className = 'workshop-title';
      title.textContent = page.title || `Page ${idx + 1}`;
      header.appendChild(title);
      const closeBtn = document.createElement('button');
      closeBtn.className = 'workshop-close';
      closeBtn.textContent = '\u00d7';
      closeBtn.onclick = () => toggleWorkshop(false);
      header.appendChild(closeBtn);
      panel.appendChild(header);

      // content
      const body = document.createElement('div');
      body.className = 'workshop-body';
      if (page.content instanceof Element) {
        body.appendChild(page.content);
      } else if (page.content instanceof TaggedContent) {
        if (page.content.type === 'md') {
          body.innerHTML = renderMd(page.content.content);
        } else if (page.content.type === 'css') {
          const pre = document.createElement('pre');
          pre.textContent = page.content.content;
          body.appendChild(pre);
        } else {
          body.innerHTML = page.content.content;
        }
      } else {
        body.textContent = String(page.content ?? '');
      }
      panel.appendChild(body);

      // progress pips
      const pips = document.createElement('div');
      pips.className = 'workshop-pips';
      for (let i = 0; i < pages.length; i++) {
        const pip = document.createElement('span');
        pip.className = 'workshop-pip' + (i === idx ? ' active' : '') + (i < idx ? ' done' : '');
        pip.onclick = () => navigate(i);
        pips.appendChild(pip);
      }
      panel.appendChild(pips);

      // nav buttons
      const nav = document.createElement('div');
      nav.className = 'workshop-nav';
      if (idx > 0) {
        const prev = document.createElement('button');
        prev.textContent = '\u2190 prev';
        prev.onclick = () => navigate(idx - 1);
        nav.appendChild(prev);
      }
      const spacer = document.createElement('span');
      spacer.style.flex = '1';
      nav.appendChild(spacer);
      const counter = document.createElement('span');
      counter.className = 'workshop-counter';
      counter.textContent = `${idx + 1} / ${pages.length}`;
      nav.appendChild(counter);
      if (idx < pages.length - 1) {
        const next = document.createElement('button');
        next.className = 'workshop-next';
        next.textContent = 'next \u2192';
        if (page.canAdvance && !page.canAdvance()) {
          next.disabled = true;
          next.title = 'complete the task to continue';
        }
        next.onclick = () => navigate(idx + 1);
        nav.appendChild(next);
      }
      panel.appendChild(nav);

      // fire onEnter
      if (page.onEnter) page.onEnter();
    }

    function navigate(idx) {
      const prevPage = pages[currentPage];
      if (prevPage?.onLeave) prevPage.onLeave();
      renderPage(idx);
    }

    // store re-check function for canAdvance gating
    cell._workshopRecheck = () => {
      const page = pages[currentPage];
      if (!page?.canAdvance) return;
      const nextBtn = panel.querySelector('.workshop-next');
      if (nextBtn) {
        nextBtn.disabled = !page.canAdvance();
      }
    };

    renderPage(currentPage);

    // auto-open on first creation
    if (!panel.classList.contains('open') && !cell._workshopShown) {
      toggleWorkshop(true);
      cell._workshopShown = true;
    }

    // store cleanup so deleteCell can tear down workshop DOM
    cell._workshopCleanup = () => {
      panel.remove();
      overlay.remove();
      toggleBtn.remove();
      cell._workshopRecheck = null;
    };
    // on re-run, just clear the recheck — DOM is reused by ID
    invalidation.then(() => {
      cell._workshopRecheck = null;
    });

    return { goto: navigate, toggle: toggleWorkshop, recheck: cell._workshopRecheck };
  };

  // notebook API — programmatic notebook control
  const notebook = {
    get cells() { return S.cells.map(c => ({ id: c.id, type: c.type, code: c.code })); },
    get scope() { return { ...S.scope }; },
    addCell: (type, code, afterId) => addCell(type, code, afterId),
    scrollTo: (id) => {
      const c = S.cells.find(c => c.id === id);
      if (c?.el) c.el.scrollIntoView({ behavior: 'smooth', block: 'center' });
    },
    focus: (id) => {
      const c = S.cells.find(c => c.id === id);
      if (c?.el) {
        c.el.scrollIntoView({ behavior: 'smooth', block: 'center' });
        const ta = c.el.querySelector('textarea');
        if (ta) ta.focus();
      }
    },
    collapse: (id) => {
      const c = S.cells.find(c => c.id === id);
      if (c?.el) c.el.classList.add('collapsed');
    },
    expand: (id) => {
      const c = S.cells.find(c => c.id === id);
      if (c?.el) c.el.classList.remove('collapsed');
    },
    run: (ids) => runDAG(Array.isArray(ids) ? ids : [ids], true),
  };

  // function caching — reuse compiled function if code/uses/defines unchanged
  const cacheKey = scopeKeys.join(',') + '|' + defNames + '|' + cell.code;

  try {
    let fn;
    if (cell._cacheKey === cacheKey && cell._cachedFn) {
      fn = cell._cachedFn;
    } else {
      const AsyncFunction = Object.getPrototypeOf(async function(){}).constructor;
      const cellName = parseCellName(cell.code);
      const slug = cellName ? '-' + cellName.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/(^-|-$)/g, '') : '';
      fn = new AsyncFunction(
        ...scopeKeys,
        'ui', 'std', 'load', 'install', 'installBinary', 'invalidation', 'print',
        'md', 'html', 'css', 'workshop', 'notebook',
        `"use strict";\n${cell.code}\n\n` +
        `return { ${defNames} };\n` +
        `//# sourceURL=auditable://cell-${cell.id}${slug}.js`
      );
      cell._cachedFn = fn;
      cell._cacheKey = cacheKey;
    }

    const scopeVals = scopeKeys.map(k => S.scope[k]);
    const result = await fn(...scopeVals, ui, std, load, install, installBinary, invalidation, display,
      md, html, css, workshop, notebook);

    // update scope with defined variables
    if (result && typeof result === 'object') {
      cell._lastResult = result;
      for (const [k, v] of Object.entries(result)) {
        if (v !== undefined) S.scope[k] = v;
      }
    }

    cell.el.classList.remove('stale', 'error');
    cell.el.classList.add('fresh');
    setTimeout(() => cell.el.classList.remove('fresh'), 800);

    // remove widgets no longer referenced by code
    for (const w of widgetEl.querySelectorAll('[data-widget-key]')) {
      if (!usedWidgets.has(w.dataset.widgetKey)) {
        delete cell._inputs[w.dataset.widgetKey];
        delete cell._callbacks[w.dataset.widgetKey];
        w.remove();
      }
    }

  } catch (e) {
    cell.error = e.message;
    outputEl.textContent = e.message;
    outputEl.className = 'cell-output error';
    cell.el.classList.remove('stale', 'fresh');
    cell.el.classList.add('error');
  }
}

async function runDAG(dirtyIds, force = false) {
  buildDAG();
  const isAutorun = S.autorun && !force;

  // determine which cells need execution via topo sort
  const runSet = new Set(topoSort(dirtyIds));

  if (window._dagStart) window._dagStart();

  // rebuild scope in document order, only executing cells in runSet
  S.scope = {};
  const poisoned = new Set(); // variable names defined by errored cells
  for (let i = 0; i < S.cells.length; i++) {
    const cell = S.cells[i];

    if (cell.type === 'html') {
      if (runSet.has(cell.id)) {
        // check if any used variable is poisoned
        if (cell.uses && [...cell.uses].some(n => poisoned.has(n))) {
          cell.el.classList.remove('fresh');
          cell.el.classList.add('stale');
        } else {
          renderHtmlCell(cell);
        }
      }
      continue;
    }
    if (cell.type !== 'code') continue;

    // skip norun cells (unless explicitly triggered)
    if (isNorun(cell.code) && !dirtyIds.includes(cell.id)) {
      if (cell._lastResult) {
        for (const [k, v] of Object.entries(cell._lastResult)) {
          if (v !== undefined) S.scope[k] = v;
        }
      }
      continue;
    }

    // skip manual cells unless force or explicitly triggered
    if (!force && isManual(cell.code) && !dirtyIds.includes(cell.id)) {
      if (cell._lastResult) {
        for (const [k, v] of Object.entries(cell._lastResult)) {
          if (v !== undefined) S.scope[k] = v;
        }
      }
      cell.el.classList.add('stale');
      continue;
    }

    // not in run set — restore cached results, skip execution
    if (!runSet.has(cell.id)) {
      if (cell._lastResult) {
        for (const [k, v] of Object.entries(cell._lastResult)) {
          if (v !== undefined) S.scope[k] = v;
        }
      }
      continue;
    }

    // error isolation: if any upstream dependency is poisoned, skip this cell
    if (cell.uses && cell.uses.size > 0) {
      let blocked = false;
      for (const name of cell.uses) {
        if (poisoned.has(name)) { blocked = true; break; }
      }
      if (blocked) {
        const outputEl = cell.el.querySelector('.cell-output');
        if (outputEl && !cell.error) {
          outputEl.textContent = 'blocked by upstream error';
          outputEl.className = 'cell-output error';
        }
        cell.el.classList.remove('stale', 'fresh');
        cell.el.classList.add('error');
        // poison our own defines so downstream also blocks
        if (cell.defines) for (const name of cell.defines) poisoned.add(name);
        continue;
      }
    }

    // value-equality gating: if this cell is a downstream dependent (not directly
    // dirty) and all its input values are unchanged, skip re-execution entirely
    if (!dirtyIds.includes(cell.id) && cell._lastResult && cell.uses && cell.uses.size > 0) {
      let inputsChanged = false;
      for (const name of cell.uses) {
        if (S.scope[name] !== cell._prevInputs?.[name]) { inputsChanged = true; break; }
      }
      if (!inputsChanged) {
        // inputs identical — restore previous results, skip execution
        for (const [k, v] of Object.entries(cell._lastResult)) {
          if (v !== undefined) S.scope[k] = v;
        }
        continue;
      }
    }

    if (window._beforeExec) window._beforeExec(cell);
    await execCell(cell);

    // if the cell errored, poison its defines
    if (cell.error) {
      if (cell.defines) for (const name of cell.defines) poisoned.add(name);
    }

    // snapshot input values for future equality checks
    if (cell.uses) {
      cell._prevInputs = {};
      for (const name of cell.uses) cell._prevInputs[name] = S.scope[name];
    }

    if (window._afterExec && !isAutorun) {
      const jump = window._afterExec(cell, i);
      if (jump >= 0) { i = jump - 1; continue; }
    }
  }

  updateStatus();

  // recheck workshop canAdvance gates after scope changes
  for (const c of S.cells) {
    if (c._workshopRecheck) c._workshopRecheck();
  }
}

async function runAll() {
  const ids = S.cells.filter(c => c.type === 'code' || c.type === 'html').map(c => c.id);
  if (ids.length === 0) return;
  await runDAG(ids, true);
  setMsg('ran all cells', 'ok');
}

// late import to avoid circular dependency at module load time

// -- markdown.js --

// ── MARKDOWN RENDERING (minimal) ──

function renderMd(src) {
  let html = src
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;');

  // headings
  html = html.replace(/^### (.+)$/gm, '<h3>$1</h3>');
  html = html.replace(/^## (.+)$/gm, '<h2>$1</h2>');
  html = html.replace(/^# (.+)$/gm, '<h1>$1</h1>');

  // bold/italic
  html = html.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
  html = html.replace(/\*(.+?)\*/g, '<em>$1</em>');

  // inline code
  html = html.replace(/`(.+?)`/g, '<code>$1</code>');

  // links
  html = html.replace(/\[(.+?)\]\((.+?)\)/g, '<a href="$2">$1</a>');

  // tables — detect pipe-delimited blocks before paragraph wrapping
  html = html.replace(
    /((?:^\|.+\|[ \t]*$\n?)+)/gm,
    (block) => {
      const rows = block.trim().split('\n').map(r =>
        r.trim().replace(/^\|/, '').replace(/\|$/, '').split('|').map(c => c.trim())
      );
      if (rows.length < 2) return block;
      // check for separator row (--- or :--- etc)
      const sep = rows[1];
      if (!sep.every(c => /^:?-{1,}:?$/.test(c))) return block;
      const hdr = rows[0];
      const body = rows.slice(2);
      let t = '<table><thead><tr>' +
        hdr.map(c => `<th>${c}</th>`).join('') +
        '</tr></thead><tbody>';
      for (const row of body) {
        t += '<tr>' + row.map(c => `<td>${c}</td>`).join('') + '</tr>';
      }
      t += '</tbody></table>';
      return t;
    }
  );

  // paragraphs
  html = html.replace(/\n\n/g, '</p><p>');
  if (!html.startsWith('<h') && !html.startsWith('<p') && !html.startsWith('<table')) html = '<p>' + html + '</p>';

  return html;
}

// -- cell-dom.js --

// ── CELL DOM ──

function cssSummary(code) {
  if (!code || !code.trim()) return '';
  const rules = (code.match(/[^{}]+\{/g) || []).length;
  const lines = code.split('\n').length;
  return `${rules} rule${rules !== 1 ? 's' : ''} \u00b7 ${lines} line${lines !== 1 ? 's' : ''}`;
}

function cellHeaderHTML(type, id) {
  return `<div class="cell-header">
    <span class="cell-type">${type}</span>
    <button class="cell-btn cell-convert" onclick="toggleTypePicker(${id})" title="convert type">\u21c4</button>
    <div class="cell-type-picker" data-cell-id="${id}">
      <button onclick="convertCell(${id},'code')">code</button>
      <button onclick="convertCell(${id},'md')">md</button>
      <button onclick="convertCell(${id},'css')">css</button>
      <button onclick="convertCell(${id},'html')">html</button>
    </div>
    <button class="cell-btn cell-insert" onclick="showInsertPicker(${id},'before')" title="insert above">+\u2191</button>
    <button class="cell-btn cell-insert" onclick="showInsertPicker(${id},'after')" title="insert below">+\u2193</button>
    <button class="cell-btn" onclick="moveCell(${id},-1)" title="move up">\u2191</button>
    <button class="cell-btn" onclick="moveCell(${id},1)" title="move down">\u2193</button>
    <button class="cell-btn del" onclick="deleteCellWithUndo(${id})" title="delete">\u00d7</button>
  </div>`;
}

function createCellEl(type, id) {
  const div = document.createElement('div');
  div.className = 'cell';
  div.dataset.id = id;
  div.dataset.type = type;

  if (type === 'code') {
    div.innerHTML = `
      ${cellHeaderHTML('code', id)}
      <div class="cell-code">
        <div class="editor-wrap">
          <div class="line-numbers" aria-hidden="true">1</div>
          <textarea rows="3" spellcheck="false" wrap="off" placeholder="// code"></textarea>
          <div class="highlight-layer" aria-hidden="true"></div>
        </div>
      </div>
      <div class="cell-widgets"></div>
      <div class="cell-output"></div>
    `;

    const ta = div.querySelector('textarea');
    const hl = div.querySelector('.highlight-layer');
    div.querySelector('.cell-type').addEventListener('click', () => div.classList.toggle('collapsed'));
    const ln = div.querySelector('.line-numbers');
    ta.addEventListener('input', () => { highlightCode(ta, hl); onCodeEdit(id); });
    ta.addEventListener('scroll', () => { hl.scrollTop = ta.scrollTop; hl.scrollLeft = ta.scrollLeft; ln.scrollTop = ta.scrollTop; });
    attachAutocomplete(ta, id);
    ta.addEventListener('keydown', handleTab);
    ta.addEventListener('input', autoResize);
  } else if (type === 'css') {
    div.innerHTML = `
      ${cellHeaderHTML('css', id)}
      <div class="cell-css-view"></div>
      <div class="cell-css-edit" style="display:none">
        <div class="editor-wrap">
          <div class="line-numbers" aria-hidden="true">1</div>
          <textarea rows="3" spellcheck="false" wrap="off" placeholder="/* css */"></textarea>
          <div class="highlight-layer" aria-hidden="true"></div>
        </div>
      </div>
    `;

    const cssView = div.querySelector('.cell-css-view');
    const cssEditWrap = div.querySelector('.cell-css-edit');
    const ta = div.querySelector('textarea');
    const hl = div.querySelector('.highlight-layer');
    div.querySelector('.cell-type').addEventListener('click', () => div.classList.toggle('collapsed'));

    cssView.addEventListener('click', () => {
      cssEditWrap.style.display = '';
      cssView.style.display = 'none';
      ta.focus();
      autoResize({ target: ta });
    });

    ta.addEventListener('blur', () => {
      if (S.findActive) return;
      const cell = S.cells.find(c => c.id === id);
      if (cell) {
        cell.code = ta.value;
        cssView.textContent = cssSummary(ta.value);
      }
      cssEditWrap.style.display = 'none';
      cssView.style.display = '';
    });

    const ln = div.querySelector('.line-numbers');
    ta.addEventListener('input', () => { highlightCss(ta, hl); onCssEdit(id); });
    ta.addEventListener('scroll', () => { hl.scrollTop = ta.scrollTop; hl.scrollLeft = ta.scrollLeft; ln.scrollTop = ta.scrollTop; });
    ta.addEventListener('input', autoResize);
    ta.addEventListener('keydown', handleTab);
  } else if (type === 'html') {
    div.innerHTML = `
      ${cellHeaderHTML('html', id)}
      <div class="cell-html-view"></div>
      <div class="cell-html-edit" style="display:none">
        <div class="editor-wrap">
          <div class="line-numbers" aria-hidden="true">1</div>
          <textarea rows="2" spellcheck="false" wrap="off" placeholder="<html template>"></textarea>
          <div class="highlight-layer" aria-hidden="true"></div>
        </div>
      </div>
      <div class="cell-output"></div>
    `;

    const view = div.querySelector('.cell-html-view');
    const editWrap = div.querySelector('.cell-html-edit');
    const ta = div.querySelector('.cell-html-edit textarea');
    const hl = div.querySelector('.highlight-layer');
    div.querySelector('.cell-type').addEventListener('click', () => div.classList.toggle('collapsed'));

    view.addEventListener('click', () => {
      editWrap.style.display = '';
      view.style.display = 'none';
      ta.focus();
      autoResize({ target: ta });
    });

    ta.addEventListener('blur', () => {
      if (S.findActive) return;
      const cell = S.cells.find(c => c.id === id);
      if (cell) {
        cell.code = ta.value;
        renderHtmlCell(cell);
      }
      editWrap.style.display = 'none';
      view.style.display = '';
    });

    const ln = div.querySelector('.line-numbers');
    ta.addEventListener('input', () => { highlightHtml(ta, hl); onHtmlEdit(id); });
    ta.addEventListener('scroll', () => { hl.scrollTop = ta.scrollTop; hl.scrollLeft = ta.scrollLeft; ln.scrollTop = ta.scrollTop; });
    ta.addEventListener('input', autoResize);
    ta.addEventListener('keydown', handleTab);
  } else {
    div.innerHTML = `
      ${cellHeaderHTML('md', id)}
      <div class="cell-md-view"></div>
      <div class="cell-md-edit" style="display:none">
        <textarea rows="2" spellcheck="false" placeholder="markdown"></textarea>
      </div>
    `;

    const view = div.querySelector('.cell-md-view');
    const editWrap = div.querySelector('.cell-md-edit');
    const ta = div.querySelector('.cell-md-edit textarea');
    div.querySelector('.cell-type').addEventListener('click', () => div.classList.toggle('collapsed'));

    view.addEventListener('click', () => {
      editWrap.style.display = '';
      view.style.display = 'none';
      ta.focus();
      autoResize({ target: ta });
    });

    ta.addEventListener('blur', () => {
      if (S.findActive) return;
      const cell = S.cells.find(c => c.id === id);
      if (cell) {
        cell.code = ta.value;
        view.innerHTML = renderMd(ta.value);
      }
      editWrap.style.display = 'none';
      view.style.display = '';
    });

    ta.addEventListener('input', autoResize);
    ta.addEventListener('keydown', handleTab);
  }

  return div;
}

// undoable text replacement — uses execCommand so the browser records it in the undo stack
function replaceRange(ta, from, to, text) {
  ta.focus();
  ta.selectionStart = from;
  ta.selectionEnd = to;
  document.execCommand('insertText', false, text);
}

function handleTab(e) {
  const ta = e.target;
  const start = ta.selectionStart;
  const end = ta.selectionEnd;

  if (e.key === 'Tab') {
    e.preventDefault();

    if (start === end) {
      // no selection — insert 2 spaces
      replaceRange(ta, start, end, '  ');
    } else {
      // selection — indent/unindent lines
      const val = ta.value;
      const lineStart = val.lastIndexOf('\n', start - 1) + 1;
      const lineEnd = val.indexOf('\n', end);
      const blockEnd = lineEnd === -1 ? val.length : lineEnd;
      const block = val.slice(lineStart, blockEnd);
      let newBlock;
      if (e.shiftKey) {
        newBlock = block.replace(/^  /gm, '');
      } else {
        newBlock = block.replace(/^/gm, '  ');
      }
      replaceRange(ta, lineStart, blockEnd, newBlock);
      ta.selectionStart = lineStart;
      ta.selectionEnd = lineStart + newBlock.length;
    }
    ta.dispatchEvent(new Event('input'));
    return;
  }

  // Enter — auto-indent
  if (e.key === 'Enter') {
    e.preventDefault();
    const val = ta.value;
    const before = val.slice(0, start);
    const after = val.slice(end);

    // find current line's leading whitespace
    const lineStart = before.lastIndexOf('\n') + 1;
    const line = before.slice(lineStart);
    const indent = line.match(/^(\s*)/)[1];

    // check if the character before cursor is an opener
    const charBefore = before.trimEnd().slice(-1);
    const extra = '{(['.includes(charBefore) ? '  ' : '';

    // check if the character after cursor is a matching closer
    const charAfter = after.trimStart()[0];
    const pairs = { '{': '}', '(': ')', '[': ']' };
    const needClose = extra && charAfter === pairs[charBefore];

    if (needClose) {
      // cursor between brackets: add indented line + closing line
      const insert = '\n' + indent + extra + '\n' + indent;
      replaceRange(ta, start, end, insert);
      ta.selectionStart = ta.selectionEnd = start + 1 + indent.length + extra.length;
    } else {
      const insert = '\n' + indent + extra;
      replaceRange(ta, start, end, insert);
    }
    ta.dispatchEvent(new Event('input'));
    return;
  }

  // Ctrl+X / Ctrl+C with no selection — whole-line cut/copy
  if ((e.key === 'x' || e.key === 'c') && (e.ctrlKey || e.metaKey) && !e.shiftKey && !e.altKey && start === end) {
    e.preventDefault();
    const val = ta.value;
    const lineStart = val.lastIndexOf('\n', start - 1) + 1;
    let lineEnd = val.indexOf('\n', start);
    if (lineEnd === -1) lineEnd = val.length;
    else lineEnd++; // include the newline

    const lineText = val.slice(lineStart, lineEnd);
    navigator.clipboard.writeText(lineText);

    if (e.key === 'x') {
      replaceRange(ta, lineStart, lineEnd, '');
      ta.dispatchEvent(new Event('input'));
    }
    return;
  }
}

function toggleComment(ta) {
  const val = ta.value;
  const start = ta.selectionStart;
  const end = ta.selectionEnd;

  // find affected line range
  const lineStart = val.lastIndexOf('\n', start - 1) + 1;
  let lineEnd = val.indexOf('\n', end);
  if (lineEnd === -1) lineEnd = val.length;

  const block = val.slice(lineStart, lineEnd);
  const lines = block.split('\n');

  // check if all lines are commented
  const allCommented = lines.every(l => /^\s*\/\//.test(l) || l.trim() === '');

  let newLines;
  if (allCommented) {
    // uncomment: remove first // (and one trailing space if present)
    newLines = lines.map(l => l.replace(/^(\s*)\/\/ ?/, '$1'));
  } else {
    // comment: add // at the minimum indent level
    const indents = lines.filter(l => l.trim()).map(l => l.match(/^(\s*)/)[1].length);
    const minIndent = indents.length ? Math.min(...indents) : 0;
    newLines = lines.map(l => {
      if (l.trim() === '') return l;
      return l.slice(0, minIndent) + '// ' + l.slice(minIndent);
    });
  }

  const newBlock = newLines.join('\n');
  replaceRange(ta, lineStart, lineEnd, newBlock);
  ta.selectionStart = lineStart;
  ta.selectionEnd = lineStart + newBlock.length;
  ta.dispatchEvent(new Event('input'));
}

function updateLineNumbers(ta) {
  const wrap = ta.closest('.editor-wrap');
  if (!wrap) return;
  const gutter = wrap.querySelector('.line-numbers');
  if (!gutter) return;
  const count = ta.value.split('\n').length;
  const lines = [];
  for (let i = 1; i <= count; i++) lines.push(i);
  gutter.textContent = lines.join('\n');
}

function autoResize(e) {
  const ta = e.target || e;
  ta.style.height = 'auto';
  ta.style.height = ta.scrollHeight + 'px';
  // sync highlight layer if present
  const hl = ta.parentElement && ta.parentElement.querySelector('.highlight-layer');
  if (hl) { hl.style.height = ta.style.height; }
  updateLineNumbers(ta);
}

// -- cell-ops.js --

// ── CELL OPERATIONS ──

function addCell(type, code = '', afterId = null, beforeId = null) {
  const id = S.cellId++;
  const cell = {
    id, type, code,
    defines: new Set(),
    uses: new Set(),
    error: null,
    el: createCellEl(type, id)
  };

  const nb = $('#notebook');
  if (beforeId !== null) {
    const idx = S.cells.findIndex(c => c.id === beforeId);
    if (idx >= 0) {
      S.cells.splice(idx, 0, cell);
      S.cells[idx + 1].el.before(cell.el);
    } else {
      S.cells.push(cell);
      nb.appendChild(cell.el);
    }
  } else if (afterId !== null) {
    const idx = S.cells.findIndex(c => c.id === afterId);
    if (idx >= 0) {
      S.cells.splice(idx + 1, 0, cell);
      if (idx < S.cells.length - 2) {
        S.cells[idx + 2].el.before(cell.el);
      } else {
        nb.appendChild(cell.el);
      }
    } else {
      S.cells.push(cell);
      nb.appendChild(cell.el);
    }
  } else {
    S.cells.push(cell);
    nb.appendChild(cell.el);
  }

  // set code
  const ta = cell.el.querySelector('textarea');
  if (code) {
    ta.value = code;
    autoResize({ target: ta });
    if (type === 'code') {
      const hl = cell.el.querySelector('.highlight-layer');
      if (hl) highlightCode(ta, hl);
      if (isManual(code)) cell.el.classList.add('manual');
    }
    if (type === 'md') {
      cell.el.querySelector('.cell-md-view').innerHTML = renderMd(code);
    }
  }

  // CSS cell: create <style> element in <head>
  if (type === 'css') {
    const hl = cell.el.querySelector('.highlight-layer');
    if (hl && code) highlightCss(ta, hl);
    const cssView = cell.el.querySelector('.cell-css-view');
    if (cssView && code) cssView.textContent = cssSummary(code);
    const styleEl = document.createElement('style');
    styleEl.dataset.cellId = id;
    styleEl.textContent = code;
    document.head.appendChild(styleEl);
    cell._styleEl = styleEl;
  }

  // HTML cell: render template
  if (type === 'html' && code) {
    renderHtmlCell(cell);
  }

  ta.focus();
  updateStatus();
  notifyDirty();
  return cell;
}

function deleteCell(id) {
  const idx = S.cells.findIndex(c => c.id === id);
  if (idx < 0) return;
  // fire invalidation so cell resources (timers, etc.) clean up
  if (S.cells[idx]._invalidate) { S.cells[idx]._invalidate(); S.cells[idx]._invalidate = null; }
  // tear down workshop DOM if this cell had one
  if (S.cells[idx]._workshopCleanup) { S.cells[idx]._workshopCleanup(); S.cells[idx]._workshopCleanup = null; }
  if (S.cells[idx]._styleEl) {
    S.cells[idx]._styleEl.remove();
    S.cells[idx]._styleEl = null;
  }
  S.cells[idx].el.remove();
  S.cells.splice(idx, 1);
  // re-run to clean scope
  if (S.cells.some(c => c.type === 'code' || c.type === 'html')) runAll();
  updateStatus();
  notifyDirty();
}

function convertCell(id, newType) {
  const cell = S.cells.find(c => c.id === id);
  if (!cell || cell.type === newType) return;

  const code = cell.code;

  // cleanup old type
  if (cell._styleEl) {
    cell._styleEl.remove();
    cell._styleEl = null;
  }

  // create new cell element
  const newEl = createCellEl(newType, id);
  cell.el.replaceWith(newEl);
  cell.el = newEl;
  cell.type = newType;

  // set code
  const ta = newEl.querySelector('textarea');
  ta.value = code;
  cell.code = code;
  autoResize({ target: ta });

  if (newType === 'code') {
    const hl = newEl.querySelector('.highlight-layer');
    if (hl) highlightCode(ta, hl);
  }
  if (newType === 'md') {
    newEl.querySelector('.cell-md-view').innerHTML = renderMd(code);
  }
  if (newType === 'css') {
    const hl = newEl.querySelector('.highlight-layer');
    if (hl) highlightCss(ta, hl);
    const cssView = newEl.querySelector('.cell-css-view');
    if (cssView && code) cssView.textContent = cssSummary(code);
    const styleEl = document.createElement('style');
    styleEl.dataset.cellId = id;
    styleEl.textContent = code;
    document.head.appendChild(styleEl);
    cell._styleEl = styleEl;
  }
  if (newType === 'html') {
    renderHtmlCell(cell);
  }

  selectCell(id);
  updateStatus();
  notifyDirty();
  if (S.cells.some(c => c.type === 'code' || c.type === 'html')) runAll();
}

function moveCell(id, dir) {
  const idx = S.cells.findIndex(c => c.id === id);
  const newIdx = idx + dir;
  if (newIdx < 0 || newIdx >= S.cells.length) return;

  const [cell] = S.cells.splice(idx, 1);
  S.cells.splice(newIdx, 0, cell);

  // re-order DOM
  const nb = $('#notebook');
  nb.innerHTML = '';
  for (const c of S.cells) nb.appendChild(c.el);

  // re-order CSS <style> elements in <head> to match cell order
  for (const c of S.cells) {
    if (c._styleEl) document.head.appendChild(c._styleEl);
  }

  notifyDirty();
  if (S.cells.some(c => c.type === 'code' || c.type === 'html')) runAll();
}

// -- editor.js --

// ── EDITING ──

function notifyDirty() {
  if (S.initialized && window.__AF_BRIDGE__) window.parent.postMessage({ type: 'af:dirty' }, '*');
}

function toggleAutorun() {
  S.autorun = !S.autorun;
  const btn = $('#autorunBtn');
  const btnMobile = document.getElementById('autorunBtnMobile');
  const cls = S.autorun ? 'autorun-on' : 'autorun-off';
  const text = S.autorun ? '\u25b6' : '\u2016';
  btn.textContent = text;
  btn.title = S.autorun ? 'reactive mode \u2014 cells auto-run on edit' : 'manual mode \u2014 only Run All or Ctrl+Enter';
  btn.className = cls;
  if (btnMobile) {
    btnMobile.textContent = text;
    btnMobile.className = cls;
  }
  const sel = $('#setExecMode');
  if (sel) sel.value = S.autorun ? 'reactive' : 'manual';
  setMsg(S.autorun ? 'autorun on' : 'autorun off', 'ok');
}

function onCssEdit(id) {
  const cell = S.cells.find(c => c.id === id);
  if (!cell) return;
  cell.code = cell.el.querySelector('textarea').value;
  if (cell._styleEl) cell._styleEl.textContent = cell.code;
  notifyDirty();
}

function onHtmlEdit(id) {
  const cell = S.cells.find(c => c.id === id);
  if (!cell) return;
  cell.code = cell.el.querySelector('textarea').value;
  cell.el.classList.add('stale');
  notifyDirty();

  if (S.autorun) {
    clearTimeout(S.editTimer);
    S.editTimer = setTimeout(() => runDAG([id], false), 400);
  }
}

function onCodeEdit(id) {
  const cell = S.cells.find(c => c.id === id);
  if (!cell) return;
  const ta = cell.el.querySelector('textarea');
  cell.code = ta.value;

  // update manual state
  if (isManual(cell.code)) {
    cell.el.classList.add('manual');
  } else {
    cell.el.classList.remove('manual');
  }

  cell.el.classList.add('stale');
  notifyDirty();

  if (S.autorun) {
    clearTimeout(S.editTimer);
    S.editTimer = setTimeout(() => runDAG([id], false), 400);
  }
}

// -- settings.js --

// ── SETTINGS ──

// Safe localStorage access — blob URL iframes have opaque origins where localStorage throws
function lsGet(key) { try { return localStorage.getItem(key); } catch { return null; } }
function lsSet(key, val) { try { localStorage.setItem(key, val); } catch {} }
function lsRemove(key) { try { localStorage.removeItem(key); } catch {} }

function toggleSettings() {
  const overlay = $('#settingsOverlay');
  const panel = $('#settingsPanel');
  const open = !overlay.classList.contains('visible');
  overlay.classList.toggle('visible');
  panel.style.display = open ? 'block' : 'none';
  if (open) refreshModuleList();
}

function applyTheme(theme) {
  if (theme === 'light') {
    document.documentElement.classList.add('light');
  } else {
    document.documentElement.classList.remove('light');
  }
  $('#setTheme').value = theme;
}

function applyFontSize(size) {
  size = parseInt(size);
  document.documentElement.style.setProperty('--editor-font-size', size + 'px');
  $('#setFontSize').value = size;
  $('#setFontSizeVal').textContent = size;
}

function applyWidth(w) {
  const nb = $('#notebook');
  nb.style.maxWidth = w;
  $('#setWidth').value = w;
}

function applyLineNumbers(show) {
  const on = show === true || show === 'true' || show === 'on';
  document.documentElement.classList.toggle('hide-line-numbers', !on);
  const el = $('#setLineNumbers');
  if (el) el.value = on ? 'on' : 'off';
}

function applyHeader(mode) {
  const root = document.documentElement;
  root.classList.remove('header-always', 'header-hover', 'header-compact');
  if (mode === 'always') root.classList.add('header-always');
  else if (mode === 'hover') root.classList.add('header-hover');
  else if (mode === 'compact') root.classList.add('header-compact');
  // 'auto' = no class, CSS media queries handle it
  $('#setHeader').value = mode;
}

// ── EXECUTION MODE ──

const __AUDITABLE_DEFAULT_EXEC_MODE__ = 'reactive';
const __AUDITABLE_DEFAULT_RUN_ON_LOAD__ = 'yes';

let _runOnLoad = 'yes';
let _showToggle = 'yes';

function applyExecMode(mode) {
  S.autorun = (mode === 'reactive');
  const btn = $('#autorunBtn');
  const btnMobile = document.getElementById('autorunBtnMobile');
  const cls = S.autorun ? 'autorun-on' : 'autorun-off';
  const text = S.autorun ? '\u25b6' : '\u2016';
  if (btn) { btn.textContent = text; btn.className = cls; btn.title = S.autorun ? 'reactive mode \u2014 cells auto-run on edit' : 'manual mode \u2014 only Run All or Ctrl+Enter'; }
  if (btnMobile) { btnMobile.textContent = text; btnMobile.className = cls; }
  const sel = $('#setExecMode');
  if (sel) sel.value = mode;
}

function applyRunOnLoad(val) {
  _runOnLoad = val;
  const sel = $('#setRunOnLoad');
  if (sel) sel.value = val;
}

function applyShowToggle(val) {
  _showToggle = val;
  document.documentElement.classList.toggle('hide-run-toggle', val === 'no');
  const sel = $('#setShowToggle');
  if (sel) sel.value = val;
}

function applyGlobalExecMode(val) {
  if (val) lsSet('auditable-exec-mode', val);
  else lsRemove('auditable-exec-mode');
}

function applyGlobalRunOnLoad(val) {
  if (val) lsSet('auditable-run-on-load', val);
  else lsRemove('auditable-run-on-load');
}

function resolveExecMode() {
  return lsGet('auditable-exec-mode')
    || $('#setExecMode')?.value
    || __AUDITABLE_DEFAULT_EXEC_MODE__;
}

function resolveRunOnLoad() {
  return lsGet('auditable-run-on-load')
    || _runOnLoad
    || __AUDITABLE_DEFAULT_RUN_ON_LOAD__;
}

function getSettings() {
  const s = {
    theme: document.documentElement.classList.contains('light') ? 'light' : 'dark',
    fontSize: parseInt($('#setFontSize').value),
    width: $('#setWidth').value,
    header: $('#setHeader').value,
    lineNumbers: document.documentElement.classList.contains('hide-line-numbers') ? 'off' : 'on',
    execMode: S.autorun ? 'reactive' : 'manual',
    runOnLoad: _runOnLoad,
    showToggle: _showToggle,
  };
  if (window._sizeCompare) s.sizeCompare = true;
  if (window._sizeCompareRef === 'content') s.sizeCompareRef = 'content';
  return s;
}

function applySettings(s) {
  if (!s) return;
  if (s.theme) applyTheme(s.theme);
  if (s.fontSize) applyFontSize(s.fontSize);
  if (s.width) applyWidth(s.width);
  if (s.header) applyHeader(s.header);
  if (s.lineNumbers) applyLineNumbers(s.lineNumbers);
  if (s.execMode) applyExecMode(s.execMode);
  if (s.runOnLoad) applyRunOnLoad(s.runOnLoad);
  if (s.showToggle) applyShowToggle(s.showToggle);
  // optional: size-compare.js (typeof guards for --lean builds without it)
  if (s.sizeCompare !== undefined && typeof applySizeCompare === 'function') applySizeCompare(s.sizeCompare);
  if (s.sizeCompareRef !== undefined && typeof applySizeCompareRef === 'function') applySizeCompareRef(s.sizeCompareRef);
}

function togglePresent() {
  document.body.classList.toggle('presenting');
}

// ── ABOUT ──

const __AUDITABLE_VERSION__ = '0.3.0';
const __AUDITABLE_RELEASE__ = 'dev';
const __AUDITABLE_BUILD_DATE__ = '2026-02-24';
const __AUDITABLE_BASE_SIZE__ = 251968;

(function() {
  const ver = $('#aboutVersion');
  const build = $('#aboutBuild');
  const rt = $('#aboutRuntime');
  if (ver) ver.textContent = 'auditable v' + __AUDITABLE_VERSION__;
  if (build) build.textContent = (__AUDITABLE_RELEASE__ !== 'dev' ? __AUDITABLE_RELEASE__ + ' \u00b7 ' : '') + 'built ' + __AUDITABLE_BUILD_DATE__;
  if (rt && __AUDITABLE_BASE_SIZE__ > 0) rt.textContent = 'runtime ' + (__AUDITABLE_BASE_SIZE__ / 1024).toFixed(1) + ' KB';
})();

// ── EXECUTION SETTINGS INIT ──

(function() {
  const gm = lsGet('auditable-exec-mode') || '';
  const gr = lsGet('auditable-run-on-load') || '';
  const selGm = $('#setGlobalExecMode');
  const selGr = $('#setGlobalRunOnLoad');
  if (selGm) selGm.value = gm;
  if (selGr) selGr.value = gr;
})();

// ── MODULE MANAGEMENT ──

function formatSize(bytes) {
  return (bytes / 1024).toFixed(1) + ' KB';
}

function renderEntryRow(url, entry) {
  const src = typeof entry === 'string' ? entry : entry.source;
  const cellId = typeof entry === 'string' ? null : entry.cellId;
  const isBinary = typeof entry === 'object' && entry.binary;
  const size = src ? src.length : 0;
  const displaySize = isBinary ? Math.floor(size * 3 / 4) : size;

  const row = document.createElement('div');
  row.className = 'module-row';

  const urlSpan = document.createElement('span');
  urlSpan.className = 'module-url';
  urlSpan.textContent = url;
  urlSpan.title = url;
  row.appendChild(urlSpan);

  const info = document.createElement('span');
  info.className = 'module-info';
  info.textContent = (cellId != null ? 'cell ' + cellId + '  ' : '')
    + (isBinary && entry.compressed ? 'gzipped  ' : '')
    + formatSize(displaySize);
  row.appendChild(info);

  const btn = document.createElement('button');
  btn.className = 'module-remove';
  btn.textContent = '\u00d7';
  btn.title = isBinary ? 'remove binary' : 'remove module';
  btn.onclick = () => removeModule(url);
  row.appendChild(btn);

  return { row, size };
}

function renderSection(list, urls, mods, emptyText) {
  list.innerHTML = '';
  if (urls.length === 0) {
    const empty = document.createElement('div');
    empty.className = 'module-empty';
    empty.textContent = emptyText;
    list.appendChild(empty);
    return 0;
  }
  let totalSize = 0;
  for (const url of urls) {
    const { row, size } = renderEntryRow(url, mods[url]);
    list.appendChild(row);
    totalSize += size;
  }
  const total = document.createElement('div');
  total.className = 'module-total';
  total.textContent = 'total  ' + formatSize(totalSize);
  list.appendChild(total);
  return totalSize;
}

function refreshModuleList() {
  const modList = $('#moduleList');
  const binList = $('#binaryList');
  if (!modList) return;

  const mods = window._installedModules || {};
  const modUrls = [];
  const binUrls = [];
  for (const url of Object.keys(mods)) {
    const entry = mods[url];
    if (typeof entry === 'object' && entry.binary) binUrls.push(url);
    else modUrls.push(url);
  }

  renderSection(modList, modUrls, mods, 'no modules installed');
  if (binList) renderSection(binList, binUrls, mods, 'no binaries installed');
}

function removeModule(url) {
  const entry = window._installedModules?.[url];
  const cellId = entry && typeof entry === 'object' ? entry.cellId : null;
  const kind = entry?.binary ? 'binary' : 'module';
  if (window._installedModules) delete window._installedModules[url];
  if (window._importCache) delete window._importCache[url];
  refreshModuleList();
  updateStatus();
  if (cellId != null) {
    setMsg(`removed ${kind} \u2014 cell ${cellId} will re-install it on next run`, 'warn');
  }
}

// -- update.js --

// ── UPDATE PANEL ──

function toggleUpdate() {
  const overlay = $('#updateOverlay');
  const panel = $('#updatePanel');
  const open = !overlay.classList.contains('visible');
  overlay.classList.toggle('visible');
  panel.style.display = open ? 'block' : 'none';
}

// ── SELF-UPDATE SYSTEM ──

const __AUDITABLE_PUBLIC_KEY__ = '';
const __AUDITABLE_REPO__ = 'endarthur/auditable';
const __AUDITABLE_PAGES_URL__ = 'https://endarthur.github.io/auditable';

// ── SIGNATURE EXTRACTION ──

function extractSignature(html) {
  const m = html.match(/<!--AUDITABLE-SIGNATURE\n([\s\S]*?)\nAUDITABLE-SIGNATURE-->/);
  if (!m) return null;
  try { return JSON.parse(m[1]); } catch { return null; }
}

// ── RUNTIME EXTRACTION ──

function extractRuntime(html) {
  const style = html.match(/<style>([\s\S]*?)<\/style>/);
  const script = html.match(/<script>([\s\S]*?)<\/script>/);
  if (!style || !script) return null;
  return { style: style[1], script: script[1] };
}

// ── DATA EXTRACTION ──

function extractData(html) {
  const data = html.match(/<!--AUDITABLE-DATA\n([\s\S]*?)\nAUDITABLE-DATA-->/);
  const settings = html.match(/<!--AUDITABLE-SETTINGS\n([\s\S]*?)\nAUDITABLE-SETTINGS-->/);
  const modules = html.match(/<!--AUDITABLE-MODULES\n([\s\S]*?)\nAUDITABLE-MODULES-->/);
  const title = html.match(/<title>([^<]*)<\/title>/);
  return {
    data: data ? data[0] : null,
    settings: settings ? settings[0] : null,
    modules: modules ? modules[0] : null,
    title: title ? title[1].replace(/^Auditable\s*\u2014\s*/, '') : 'untitled',
  };
}

// ── SIGNED CONTENT CONSTRUCTION ──

function buildSignedContent(style, script) {
  return 'AUDITABLE-SIGNED-CONTENT\n'
    + style + '\n'
    + 'AUDITABLE-STYLE-SCRIPT-BOUNDARY\n'
    + script;
}

// ── SIGNATURE VERIFICATION (Web Crypto) ──

async function verifySignature(html) {
  const sig = extractSignature(html);
  if (!sig) return { status: 'unsigned' };

  const pubKeyB64 = __AUDITABLE_PUBLIC_KEY__;
  if (!pubKeyB64) return { status: 'no-key', sig };

  // Check if the signature's public key matches ours
  if (sig.pub !== pubKeyB64) return { status: 'wrong-key', sig };

  const runtime = extractRuntime(html);
  if (!runtime) return { status: 'error', message: 'could not extract runtime' };

  const content = buildSignedContent(runtime.style, runtime.script);

  try {
    const pubBytes = Uint8Array.from(atob(pubKeyB64), c => c.charCodeAt(0));
    const key = await crypto.subtle.importKey(
      'raw', pubBytes, { name: 'Ed25519' }, false, ['verify']
    );
    const sigBytes = Uint8Array.from(atob(sig.sig), c => c.charCodeAt(0));
    const msgBytes = new TextEncoder().encode(content);
    const valid = await crypto.subtle.verify('Ed25519', key, sigBytes, msgBytes);
    return { status: valid ? 'valid' : 'invalid', sig };
  } catch (e) {
    if (e.name === 'NotSupportedError') {
      return { status: 'unsupported', message: 'browser does not support Ed25519 verification' };
    }
    return { status: 'error', message: e.message };
  }
}

// ── REASSEMBLE ──

function reassemble(newHtml, oldData) {
  let html = newHtml;

  // Remove any existing data/settings/modules comments (and their description comments) from the new template
  html = html.replace(/(?:<!-- [^\n]*-->\n)?<!--AUDITABLE-DATA\n[\s\S]*?\nAUDITABLE-DATA-->\n?/g, '');
  html = html.replace(/(?:<!-- [^\n]*-->\n)?<!--AUDITABLE-SETTINGS\n[\s\S]*?\nAUDITABLE-SETTINGS-->\n?/g, '');
  html = html.replace(/(?:<!-- [^\n]*-->\n)?<!--AUDITABLE-MODULES\n[\s\S]*?\nAUDITABLE-MODULES-->\n?/g, '');

  // Build data block to inject
  const parts = [];
  if (oldData.data) parts.push(oldData.data);
  if (oldData.modules) parts.push(oldData.modules);
  if (oldData.settings) parts.push(oldData.settings);
  const dataBlock = parts.length ? '\n' + parts.join('\n') + '\n' : '';

  // Inject before the signature comment or before <script>
  const sigIdx = html.indexOf('<!--AUDITABLE-SIGNATURE');
  const scriptIdx = html.indexOf('<script>');
  const insertIdx = sigIdx >= 0 ? sigIdx : scriptIdx;
  if (insertIdx >= 0) {
    html = html.slice(0, insertIdx) + dataBlock + html.slice(insertIdx);
  }

  // Update title
  if (oldData.title && oldData.title !== 'untitled') {
    html = html.replace(/<title>[^<]*<\/title>/, '<title>Auditable \u2014 ' + escHtml(oldData.title) + '</title>');
    // Also update the docTitle input value
    html = html.replace(/(<input[^>]*id="docTitle"[^>]*value=")[^"]*"/, '$1' + escHtml(oldData.title) + '"');
  }

  return html;
}

function escHtml(s) {
  return s.replace(/&/g, '&amp;').replace(/"/g, '&quot;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
}

// ── VERSION COMPARISON ──

function compareVersions(a, b) {
  // compare semver strings like "0.1.0" vs "0.2.0"
  const pa = a.replace(/^v/, '').split('.').map(Number);
  const pb = b.replace(/^v/, '').split('.').map(Number);
  for (let i = 0; i < Math.max(pa.length, pb.length); i++) {
    const na = pa[i] || 0, nb = pb[i] || 0;
    if (na < nb) return -1;
    if (na > nb) return 1;
  }
  return 0;
}

// ── TOOLBAR BADGES ──

function setBadge(id, label, cls) {
  const container = $('#toolbarBadges');
  if (!container) return;
  let el = container.querySelector('[data-badge="' + id + '"]');
  if (!label) {
    if (el) el.remove();
    return;
  }
  if (!el) {
    el = document.createElement('span');
    el.className = 'toolbar-badge toolbar-badge-' + id;
    el.setAttribute('data-badge', id);
    container.appendChild(el);
  }
  el.textContent = label;
  if (cls) el.className = 'toolbar-badge ' + cls;
}

// ── UPDATE STATUS UI ──

function setUpdateStatus(html, cls) {
  const el = $('#updateStatus');
  if (el) {
    el.innerHTML = html;
    el.className = 'update-status' + (cls ? ' update-' + cls : '');
  }
}

// ── CHECK FOR UPDATE (GitHub API) ──

async function checkForUpdate() {
  const btn = $('#updateCheckBtn');
  if (btn) btn.disabled = true;
  setUpdateStatus('checking...', '');

  try {
    // Fetch version.json from GitHub Pages (CORS-friendly)
    const vResp = await fetch(__AUDITABLE_PAGES_URL__ + '/version.json');
    if (!vResp.ok) throw new Error('version check failed: ' + vResp.status);
    const vData = await vResp.json();
    const remoteVersion = vData.version || '';
    const currentRelease = $('#updateRelease')?.textContent || 'dev';

    if (currentRelease === 'dev') {
      // Dev builds always offer the latest release
    } else if (compareVersions(currentRelease, remoteVersion) >= 0) {
      setUpdateStatus('up to date (' + currentRelease + ')', 'ok');
      if (btn) btn.disabled = false;
      return;
    }

    const notes = vData.notes || '';
    const notesHtml = notes
      ? '<div class="update-notes">' + renderMd(notes) + '</div>'
      : '';

    setUpdateStatus(
      '<strong>' + remoteVersion + '</strong> available'
      + notesHtml
      + '<button id="updateApplyBtn" onclick="applyOnlineUpdate()">update</button>',
      'available'
    );

    window._updateVersion = remoteVersion;
  } catch (e) {
    setUpdateStatus('error: ' + escHtml(e.message), 'err');
  }
  if (btn) btn.disabled = false;
}

// ── APPLY ONLINE UPDATE ──

async function applyOnlineUpdate() {
  setUpdateStatus('downloading...', '');

  try {
    // Download signed build from GitHub Pages (CORS-friendly)
    const resp = await fetch(__AUDITABLE_PAGES_URL__ + '/auditable.html');
    if (!resp.ok) throw new Error('download failed: ' + resp.status);
    const newHtml = await resp.text();
    await applyUpdate(newHtml, window._updateVersion);
  } catch (e) {
    setUpdateStatus('error: ' + escHtml(e.message), 'err');
  }
}

// ── APPLY UPDATE (verify + reassemble + download) ──

async function applyUpdate(newHtml, version) {
  setUpdateStatus('verifying signature...', '');

  const result = await verifySignature(newHtml);

  if (result.status === 'invalid') {
    setUpdateStatus('signature verification FAILED \u2014 update rejected', 'err');
    return;
  }

  const warnMessages = {
    'unsigned': 'this file is not signed',
    'no-key': 'no public key configured \u2014 cannot verify signature',
    'wrong-key': 'signed with an unknown key',
  };
  if (warnMessages[result.status]) {
    setUpdateStatus(
      'warning: ' + warnMessages[result.status]
      + '<div class="update-confirm">'
      + '<button onclick="proceedUpdate()">proceed anyway</button>'
      + '<button onclick="cancelUpdate()">cancel</button>'
      + '</div>',
      'warn'
    );
    window._pendingUpdateHtml = newHtml;
    window._pendingUpdateVersion = version;
    return;
  }

  if (result.status === 'unsupported') {
    setUpdateStatus(
      result.message
      + '<div class="update-confirm">'
      + '<button onclick="proceedUpdate()">proceed without verification</button>'
      + '<button onclick="cancelUpdate()">cancel</button>'
      + '</div>',
      'warn'
    );
    window._pendingUpdateHtml = newHtml;
    window._pendingUpdateVersion = version;
    return;
  }

  if (result.status === 'error') {
    setUpdateStatus('verification error: ' + escHtml(result.message), 'err');
    return;
  }

  // Valid signature — proceed
  finishUpdate(newHtml, version);
}

function proceedUpdate() {
  if (window._pendingUpdateHtml) {
    finishUpdate(window._pendingUpdateHtml, window._pendingUpdateVersion);
    delete window._pendingUpdateHtml;
    delete window._pendingUpdateVersion;
  }
}

function cancelUpdate() {
  delete window._pendingUpdateHtml;
  delete window._pendingUpdateVersion;
  setUpdateStatus('update cancelled', '');
}

function finishUpdate(newHtml, version) {
  setUpdateStatus('reassembling...', '');

  // Extract current document as HTML to get data comments
  const currentHtml = document.documentElement.outerHTML;
  // But the data comments are in the body innerHTML at load time; grab from live source
  const bodyHtml = document.body.innerHTML;
  const fullHtml = '<!DOCTYPE html>\n<html>' + document.head.outerHTML + '<body>' + bodyHtml + '</body></html>';

  const oldData = extractData(fullHtml);
  // Override title from live doc
  const titleInput = $('#docTitle');
  if (titleInput) oldData.title = titleInput.value || 'untitled';

  // Build fresh data comments from live state (more reliable than regex from DOM)
  if (S.cells.length) {
    const cellData = S.cells.map(c => ({
      type: c.type,
      code: c.code,
      collapsed: c.el?.classList.contains('collapsed') || undefined
    }));
    oldData.data = '<!-- cell data: JSON array of {type, code, collapsed?} -->\n<!--AUDITABLE-DATA\n' + JSON.stringify(cellData) + '\nAUDITABLE-DATA-->';
  }
  if (window._installedModules && Object.keys(window._installedModules).length) {
    oldData.modules = '<!-- installed modules: base64-encoded JSON mapping URLs to {source, cellId} -->\n<!--AUDITABLE-MODULES\n' + encodeModules(window._installedModules) + '\nAUDITABLE-MODULES-->';
  }
  oldData.settings = '<!-- notebook settings: JSON {theme, fontSize, width, ...} -->\n<!--AUDITABLE-SETTINGS\n' + JSON.stringify(getSettings()) + '\nAUDITABLE-SETTINGS-->';

  const result = reassemble(newHtml, oldData);

  // Offer as download
  const title = (titleInput ? titleInput.value : 'untitled') || 'untitled';
  const blob = new Blob([result], { type: 'text/html' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = title.replace(/[^a-zA-Z0-9_-]/g, '_') + '.html';
  a.click();
  URL.revokeObjectURL(url);

  const vLabel = version ? ' to ' + version : '';
  setUpdateStatus('updated' + vLabel + ' \u2014 saved as ' + a.download, 'ok');
  setMsg('updated' + vLabel, 'ok');
}

// ── UPDATE FROM FILE ──

function updateFromFile() {
  const input = document.createElement('input');
  input.type = 'file';
  input.accept = '.html';
  input.onchange = async () => {
    const file = input.files[0];
    if (!file) return;
    setUpdateStatus('reading file...', '');
    const text = await file.text();

    // Try to extract version from the file
    const vMatch = text.match(/__AUDITABLE_VERSION__\s*=\s*'([^']+)'/);
    const version = vMatch ? 'v' + vMatch[1] : null;

    await applyUpdate(text, version);
  };
  input.click();
}

// ── VERIFY CURRENT DOCUMENT ──

async function verifySelf() {
  const el = $('#updateSigStatus');
  if (!el) return;

  // Reconstruct from live DOM
  const styleEl = document.querySelector('style');
  const scriptEl = document.querySelector('script');
  if (!styleEl || !scriptEl) {
    el.textContent = 'error: no style/script';
    el.className = 'update-sig update-err';
    return;
  }

  const raw = document.body.innerHTML;
  const sigMatch = raw.match(/<!--AUDITABLE-SIGNATURE\n([\s\S]*?)\nAUDITABLE-SIGNATURE-->/);
  if (!sigMatch) {
    el.textContent = 'unsigned';
    el.className = 'update-sig update-warn';
    return;
  }

  let sig;
  try { sig = JSON.parse(sigMatch[1]); } catch {
    el.textContent = 'invalid signature format';
    el.className = 'update-sig update-err';
    return;
  }

  const pubKeyB64 = __AUDITABLE_PUBLIC_KEY__;
  if (!pubKeyB64) {
    el.textContent = 'no public key configured';
    el.className = 'update-sig update-warn';
    return;
  }

  if (sig.pub !== pubKeyB64) {
    el.textContent = 'signed with unknown key';
    el.className = 'update-sig update-warn';
    return;
  }

  const content = buildSignedContent(styleEl.textContent, scriptEl.textContent);

  try {
    const pubBytes = Uint8Array.from(atob(pubKeyB64), c => c.charCodeAt(0));
    const key = await crypto.subtle.importKey(
      'raw', pubBytes, { name: 'Ed25519' }, false, ['verify']
    );
    const sigBytes = Uint8Array.from(atob(sig.sig), c => c.charCodeAt(0));
    const msgBytes = new TextEncoder().encode(content);
    const valid = await crypto.subtle.verify('Ed25519', key, sigBytes, msgBytes);
    if (valid) {
      el.textContent = 'signed \u2713';
      el.className = 'update-sig update-ok';
      setBadge('signed', 'signed', 'toolbar-badge toolbar-badge-signed');
    } else {
      el.textContent = 'signature invalid';
      el.className = 'update-sig update-err';
    }
  } catch (e) {
    if (e.name === 'NotSupportedError') {
      el.textContent = 'Ed25519 not supported';
      el.className = 'update-sig update-warn';
    } else {
      el.textContent = 'error: ' + e.message;
      el.className = 'update-sig update-err';
    }
  }
}

// ── INIT ──
(function() {
  const ver = $('#updateCurrentVer');
  if (ver) ver.textContent = 'v' + __AUDITABLE_VERSION__;
  const rel = $('#updateRelease');
  if (rel) {
    rel.textContent = __AUDITABLE_RELEASE__;
    if (__AUDITABLE_RELEASE__ === 'dev') rel.className = 'update-sig update-warn';
  }
  // Show public key status
  const keyEl = $('#updatePubKey');
  if (keyEl) {
    if (__AUDITABLE_PUBLIC_KEY__) {
      keyEl.textContent = __AUDITABLE_PUBLIC_KEY__.slice(0, 8) + '...';
      keyEl.className = 'update-sig update-key-truncated';
      keyEl.onclick = () => {
        if (keyEl.classList.contains('update-key-expanded')) {
          keyEl.textContent = __AUDITABLE_PUBLIC_KEY__.slice(0, 8) + '...';
          keyEl.classList.remove('update-key-expanded');
          keyEl.classList.add('update-key-truncated');
        } else {
          keyEl.textContent = __AUDITABLE_PUBLIC_KEY__;
          keyEl.classList.remove('update-key-truncated');
          keyEl.classList.add('update-key-expanded');
        }
      };
    } else {
      keyEl.textContent = 'not configured';
      keyEl.className = 'update-sig update-warn';
    }
  }
  // Run self-verification on load
  verifySelf();
})();

// -- save.js --

// ── MODULES ENCODING ──
// base64-encode modules JSON to avoid HTML comment / String.replace issues
// (source code can contain --, $', etc.)

function encodeModules(obj) {
  const b64 = btoa(unescape(encodeURIComponent(JSON.stringify(obj))));
  return b64.replace(/.{1,76}/g, '$&\n').trimEnd();
}

function decodeModules(raw) {
  const b64 = raw.replace(/\s/g, '');
  // detect legacy format: starts with { means raw JSON (not base64)
  if (b64.startsWith('{') || b64.startsWith('%7B')) return JSON.parse(raw);
  return JSON.parse(decodeURIComponent(escape(atob(b64))));
}

// ── SAVE / LOAD ──

// save mode: 'normal' or 'packed'
let _saveMode = 'normal';

function getSaveMode() { return _saveMode; }

function toggleSaveTray() {
  const tray = $('#saveTray');
  if (tray) tray.classList.toggle('open');
}

function setSaveMode(mode) {
  _saveMode = mode;
  // update UI
  const label = $('#saveLabel');
  if (label) label.textContent = mode === 'packed' ? 'pack' : 'save';
  const tray = $('#saveTray');
  if (tray) tray.classList.remove('open');
  // update mobile buttons
  const mobSave = $('#mobileSaveBtn');
  const mobPack = $('#mobilePackBtn');
  if (mobSave) mobSave.classList.toggle('active-mode', mode === 'normal');
  if (mobPack) mobPack.classList.toggle('active-mode', mode === 'packed');
}

function buildNotebookHtml() {
  // serialize current state back to a self-contained HTML file
  const title = $('#docTitle').value || 'untitled';

  // collect cells as data
  const cellData = S.cells.map(c => ({
    type: c.type,
    code: c.code,
    collapsed: c.el.classList.contains('collapsed') || undefined
  }));

  // get the runtime and styles from current document
  const styleEl = document.querySelector('style');
  const styles = styleEl.textContent;

  // get the script
  const scriptEl = document.querySelector('script');
  const script = scriptEl.textContent;

  // read static elements from live DOM
  const helpHTML = $('#helpOverlay').outerHTML;
  const settingsOvHTML = $('#settingsOverlay').outerHTML;
  const settingsPanHTML = $('#settingsPanel').outerHTML.replace(/display:\s*block;?/, '');
  const updateOvHTML = $('#updateOverlay').outerHTML.replace(/\bvisible\b/, '').replace(/class="\s*"/, 'class=""');
  const updatePanEl = $('#updatePanel').cloneNode(true);
  updatePanEl.style.display = '';
  // reset update status and dynamic text
  const uStatus = updatePanEl.querySelector('#updateStatus');
  if (uStatus) { uStatus.innerHTML = ''; uStatus.className = 'update-status'; }
  const updatePanHTML = updatePanEl.outerHTML.replace(/display:\s*block;?/, '');
  const statusbarHTML = document.querySelector('.statusbar').outerHTML;

  // read toolbar from live DOM and patch the title value
  const toolbarEl = document.querySelector('.toolbar').cloneNode(true);
  toolbarEl.querySelector('#docTitle').value = title;
  toolbarEl.querySelector('#toolbarStatus').textContent = '';
  // reset autorun button state to match saved mode
  const autoBtn = toolbarEl.querySelector('#autorunBtn');
  const savedMode = S.autorun ? 'reactive' : 'manual';
  if (autoBtn) {
    autoBtn.className = savedMode === 'reactive' ? 'autorun-on' : 'autorun-off';
    autoBtn.textContent = savedMode === 'reactive' ? '\u25b6' : '\u2016';
  }
  // close overflow and save tray if open
  const overflow = toolbarEl.querySelector('.toolbar-overflow');
  if (overflow) overflow.classList.remove('open');
  const saveTray = toolbarEl.querySelector('#saveTray');
  if (saveTray) saveTray.classList.remove('open');
  // reset save label to default
  const saveLabel = toolbarEl.querySelector('#saveLabel');
  if (saveLabel) saveLabel.textContent = 'save';
  // clear badges (they get set dynamically on load)
  const badges = toolbarEl.querySelector('.toolbar-badges');
  if (badges) badges.innerHTML = '';
  const toolbarHTML = toolbarEl.outerHTML;

  // capture find bar and reset to default state
  const findBarEl = $('#findBar').cloneNode(true);
  findBarEl.style.display = '';
  findBarEl.classList.remove('show-replace');
  findBarEl.querySelector('#findInput').value = '';
  findBarEl.querySelector('#replaceInput').value = '';
  findBarEl.querySelector('#findCount').textContent = '';
  findBarEl.querySelector('#findCaseBtn').classList.remove('active');
  findBarEl.querySelector('#findRegexBtn').classList.remove('active');
  const findBarHTML = findBarEl.outerHTML;

  // build output HTML
  return `<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Auditable \u2014 ${esc(title)}</title>
<style>\n${styles}\n</style>
</head>
<body>

${helpHTML}

${settingsOvHTML}
${settingsPanHTML}

${updateOvHTML}
${updatePanHTML}

${toolbarHTML}

${findBarHTML}

<button class="present-exit" onclick="togglePresent()">\u2715 exit</button>

<div class="notebook" id="notebook">
</div>

${statusbarHTML}

${'<!-- cell data: JSON array of {type, code, collapsed?} -->\n<!--AUDITABLE-DATA\n' + JSON.stringify(cellData) + '\nAUDITABLE-DATA-->'}
${Object.keys(window._installedModules || {}).length ? '<!-- installed modules: base64-encoded JSON mapping URLs to {source, cellId} -->\n<!--AUDITABLE-MODULES\n' + encodeModules(window._installedModules) + '\nAUDITABLE-MODULES-->' : ''}
${'<!-- notebook settings: JSON {theme, fontSize, width, ...} -->\n<!--AUDITABLE-SETTINGS\n' + JSON.stringify(getSettings()) + '\nAUDITABLE-SETTINGS-->'}

<script>\n${script}\n<\/script>
</body>
</html>`;
}

function downloadHtml(html, title) {
  const blob = new Blob([html], { type: 'text/html' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = title.replace(/[^a-zA-Z0-9_-]/g, '_') + '.html';
  a.click();
  URL.revokeObjectURL(url);
  return a.download;
}

function saveNotebook() {
  if (_saveMode === 'packed') {
    savePackedNotebook();
    return;
  }
  const title = $('#docTitle').value || 'untitled';
  const html = buildNotebookHtml();

  // AF bridge: send serialized HTML to parent shell instead of downloading
  if (window.__AF_BRIDGE__) {
    window.parent.postMessage({ type: 'af:serialized', payload: { html } }, '*');
    setMsg('saved', 'ok');
    return;
  }

  const fn = downloadHtml(html, title);
  setMsg('saved ' + fn, 'ok');
}

async function savePackedNotebook() {
  const title = $('#docTitle').value || 'untitled';
  const html = buildNotebookHtml();

  try {
    // compress via CompressionStream
    const blob = new Blob([html]);
    const cs = new CompressionStream('gzip');
    const stream = blob.stream().pipeThrough(cs);
    const compressed = await new Response(stream).arrayBuffer();
    const b64 = btoa(String.fromCharCode(...new Uint8Array(compressed)));
    const b64Lines = b64.replace(/.{1,76}/g, '$&\n');

    const loader = `<!DOCTYPE html>
<!-- packed auditable notebook -->
<!-- the full notebook is gzip-compressed and base64-encoded in the <pre> block below. -->
<!-- on load, the script decodes and decompresses it, then replaces the page contents. -->
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Auditable \u2014 ${esc(title)}</title>
  <style>
    html { background: #1a1a1a }
    body { color: #999; font: 14px/1.5 monospace; display: flex; justify-content: center; align-items: center; height: 100vh; margin: 0 }
    #_d { display: none }
  </style>
</head>
<body>
<div id="_l">unpacking\u2026</div>

<!-- base64-encoded gzip payload (76-char lines) -->
<pre id="_d">
${b64Lines}</pre>

<script>
(async () => {
  // 1. read base64 from the hidden <pre>, strip whitespace from line wrapping
  var b64 = document.getElementById('_d').textContent.replace(/\\s/g, '');

  // 2. decode base64 to binary
  var bytes = Uint8Array.from(atob(b64), c => c.charCodeAt(0));

  // 3. decompress gzip via DecompressionStream
  var stream = new Response(new Blob([bytes])).body.pipeThrough(new DecompressionStream('gzip'));
  var html = await new Response(stream).text();

  // 4. mark as packed (so the notebook knows it was loaded from a packed save)
  html = html.replace('<head>', '<head><meta name="auditable-packed">');

  // 5. replace the current page with the full notebook
  document.open();
  document.write(html);
  document.close();
})().catch(function(e) {
  document.getElementById('_l').textContent = 'error: ' + e.message;
});
<\/script>
</body>
</html>`;


    const fn = downloadHtml(loader, title);
    const kb = (loader.length / 1024).toFixed(0);
    setMsg('packed ' + fn + ' (' + kb + ' KB)', 'ok');
  } catch (e) {
    setMsg('pack failed: ' + e.message, 'err');
  }
}

function esc(s) {
  return s.replace(/"/g, '&quot;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
}

function exportAsTxt() {
  const title = $('#docTitle').value || 'untitled';
  const html = buildNotebookHtml();

  // extract notebook data from HTML
  const dataMatch = html.match(/<!--AUDITABLE-DATA\n([\s\S]*?)\nAUDITABLE-DATA-->/);
  let cells = [];
  if (dataMatch) {
    try { cells = JSON.parse(dataMatch[1]); } catch {}
  }

  const setMatch = html.match(/<!--AUDITABLE-SETTINGS\n([\s\S]*?)\nAUDITABLE-SETTINGS-->/);
  let settings = {};
  if (setMatch) {
    try { settings = JSON.parse(setMatch[1]); } catch {}
  }

  // extract module URLs (without sources — standalone export just records URLs)
  const modMatch = html.match(/<!--AUDITABLE-MODULES\n([\s\S]*?)\nAUDITABLE-MODULES-->/);
  let moduleUrls = [];
  if (modMatch) {
    try {
      const decoded = decodeModules(modMatch[1]);
      moduleUrls = Object.keys(decoded);
    } catch {}
  }

  // build /// formatted text
  const lines = ['/// auditable'];
  if (title && title !== 'untitled') {
    lines.push('/// title: ' + title);
  }
  const defaultSettings = { theme: 'dark', fontSize: 13, width: '860' };
  if (JSON.stringify(settings) !== JSON.stringify(defaultSettings)) {
    lines.push('/// settings: ' + JSON.stringify(settings));
  }
  for (const url of moduleUrls) {
    lines.push('/// module: ' + url);
  }
  for (const cell of cells) {
    lines.push('');
    const flags = cell.collapsed ? ' collapsed' : '';
    lines.push('/// ' + cell.type + flags);
    lines.push(cell.code || '');
  }
  const txt = lines.join('\n') + '\n';

  // download
  if (window.__AF_BRIDGE__) {
    window.parent.postMessage({ type: 'af:download', payload: { data: txt, filename: title.replace(/[^a-zA-Z0-9_-]/g, '_') + '.txt', mime: 'text/plain' } }, '*');
  } else {
    const blob = new Blob([txt], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = title.replace(/[^a-zA-Z0-9_-]/g, '_') + '.txt';
    a.click();
    URL.revokeObjectURL(url);
  }
  setMsg('exported .txt', 'ok');
}

function loadFromEmbed() {
  // look for embedded cell data in HTML comments
  const raw = document.body.innerHTML;

  // restore installed modules first (before cells run)
  const modMatch = raw.match(/<!--AUDITABLE-MODULES\n([\s\S]*?)\nAUDITABLE-MODULES-->/);
  if (modMatch) {
    try {
      window._installedModules = decodeModules(modMatch[1]);
    } catch (e) {
      console.error('Failed to parse installed modules:', e);
    }
  }

  // restore settings
  const setMatch = raw.match(/<!--AUDITABLE-SETTINGS\n([\s\S]*?)\nAUDITABLE-SETTINGS-->/);
  if (setMatch) {
    try {
      applySettings(JSON.parse(setMatch[1]));
    } catch (e) {
      console.error('Failed to parse settings:', e);
    }
  }

  // apply execution mode priority chain (localStorage > notebook > build default)
  const effectiveMode = resolveExecMode();
  const effectiveRun = resolveRunOnLoad();
  if (effectiveMode === 'manual') {
    S.autorun = false;
    const btn = document.getElementById('autorunBtn');
    const btnMobile = document.getElementById('autorunBtnMobile');
    if (btn) { btn.className = 'autorun-off'; btn.textContent = '\u2016'; btn.title = 'manual mode \u2014 only Run All or Ctrl+Enter'; }
    if (btnMobile) { btnMobile.className = 'autorun-off'; btnMobile.textContent = '\u2016'; }
    const sel = document.getElementById('setExecMode');
    if (sel) sel.value = 'manual';
  }

  const match = raw.match(/<!--AUDITABLE-DATA\n([\s\S]*?)\nAUDITABLE-DATA-->/);
  if (match) {
    try {
      const data = JSON.parse(match[1]);
      for (const c of data) {
        const cell = addCell(c.type, c.code);
        if (c.collapsed || isCollapsed(c.code)) cell.el.classList.add('collapsed');
      }
      // run after load (gated on resolved runOnLoad)
      if (effectiveRun === 'yes' && S.cells.some(c => c.type === 'code')) {
        setTimeout(runAll, 50);
      }
      return true;
    } catch (e) {
      console.error('Failed to parse embedded data:', e);
    }
  }
  return false;
}

// -- ui.js --

// ── STATUS ──

function estimateContentSize() {
  let modules = 0;
  for (const v of Object.values(window._installedModules || {})) {
    modules += typeof v === 'string' ? v.length : (v.source?.length || 0);
  }
  const cells = JSON.stringify(S.cells.map(c => ({ type: c.type, code: c.code }))).length;
  return modules + cells;
}

function estimateFileSize() {
  const style = document.querySelector('style')?.textContent.length || 0;
  const script = document.querySelector('script')?.textContent.length || 0;
  return style + script + estimateContentSize() + 2000; // ~2KB HTML boilerplate
}

function updateStatus() {
  const counts = { code: 0, md: 0, css: 0, html: 0 };
  for (const c of S.cells) if (counts[c.type] !== undefined) counts[c.type]++;
  const parts = [];
  for (const [t, n] of Object.entries(counts)) if (n > 0) parts.push(`${n} ${t}`);
  const statusText = parts.join(' \u00b7 ') || '0 cells';
  const totalBytes = estimateFileSize();
  const contentBytes = estimateContentSize();
  const useContent = window._sizeCompareRef === 'content';
  const displayBytes = useContent ? contentBytes : totalBytes;
  const sizeKB = displayBytes >= 1024 ? Math.round(displayBytes / 1024) : 1;
  const sizeText = '~' + sizeKB + ' KB' + (useContent ? ' content' : '');
  $('#statusCells').textContent = statusText;
  const compare = typeof sizeCompare === 'function' ? sizeCompare(displayBytes) : '';
  const sizeEl = document.getElementById('statusSize');
  if (sizeEl) sizeEl.textContent = (compare ? sizeText + ' \u00b7 ' + compare : sizeText) + ' \u00b7 ';
  // mirror to toolbar for mobile
  const toolbarStatus = document.getElementById('toolbarStatus');
  if (toolbarStatus) toolbarStatus.textContent = (compare || sizeText) + ' \u00b7 ' + statusText;
  updateInsertBars();
}

function updateInsertBars() {
  const nb = $('#notebook');
  // remove existing insert bars
  nb.querySelectorAll('.insert-bar').forEach(b => b.remove());

  // add one before first cell and between each pair
  for (let i = 0; i <= S.cells.length; i++) {
    const bar = document.createElement('div');
    bar.className = 'insert-bar';
    const afterId = i > 0 ? S.cells[i - 1].id : null;
    bar.innerHTML = `<div class="insert-btns">
      <button onclick="insertAt(${afterId},'code')">+ code</button>
      <button onclick="insertAt(${afterId},'md')">+ md</button>
      <button onclick="insertAt(${afterId},'css')">+ css</button>
      <button onclick="insertAt(${afterId},'html')">+ html</button>
    </div>`;
    if (i < S.cells.length) {
      S.cells[i].el.before(bar);
    } else {
      nb.appendChild(bar);
    }
  }
}

function insertAt(afterId, type) {
  let cell;
  if (afterId === null && S.cells.length > 0) {
    // insert before first cell
    cell = addCellWithUndo(type, '', null, S.cells[0].id);
  } else {
    cell = addCellWithUndo(type, '', afterId);
  }
  selectCell(cell.id);
  editCell(cell.id);
}

function setMsg(msg, cls = '') {
  const el = $('#statusMsg');
  el.textContent = msg;
  el.className = 'status-msg' + (cls ? ' ' + cls : '');
  if (cls) setTimeout(() => { el.textContent = ''; el.className = 'status-msg'; }, 3000);
}

// -- find.js --

// ── FIND / REPLACE ──

function openFind(showReplace) {
  const bar = $('#findBar');
  bar.style.display = 'flex';
  S.findActive = true;
  if (showReplace) bar.classList.add('show-replace');
  else bar.classList.remove('show-replace');
  const inp = $('#findInput');
  // pre-fill from textarea selection
  const active = document.activeElement;
  if (active && active.tagName === 'TEXTAREA') {
    const sel = active.value.substring(active.selectionStart, active.selectionEnd);
    if (sel && sel.indexOf('\n') === -1) inp.value = sel;
  }
  inp.focus();
  inp.select();
  if (inp.value) findComputeMatches();
}

function closeFind() {
  const bar = $('#findBar');
  bar.style.display = '';
  bar.classList.remove('show-replace');
  S.findActive = false;
  S.findQuery = '';
  S.findMatches = [];
  S.findCurrent = -1;
  $('#findCount').textContent = '';
  // remove all overlays
  document.querySelectorAll('.search-overlay').forEach(el => el.remove());
  document.querySelectorAll('.md-search-wrap').forEach(wrap => {
    const ta = wrap.querySelector('textarea');
    if (ta) wrap.parentNode.insertBefore(ta, wrap);
    wrap.remove();
  });
}

function escapeRegex(s) {
  return s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

function findComputeMatches() {
  const query = $('#findInput').value;
  S.findQuery = query;
  S.findMatches = [];
  if (!query) {
    S.findCurrent = -1;
    findUpdateCount();
    document.querySelectorAll('.search-overlay').forEach(el => el.remove());
    document.querySelectorAll('.md-search-wrap').forEach(wrap => {
      const ta = wrap.querySelector('textarea');
      if (ta) wrap.parentNode.insertBefore(ta, wrap);
      wrap.remove();
    });
    return;
  }
  const flags = S.findCase ? 'g' : 'gi';
  const pattern = S.findRegex ? query : escapeRegex(query);
  let re;
  try { re = new RegExp(pattern, flags); }
  catch (e) {
    S.findCurrent = -1;
    $('#findCount').textContent = 'bad regex';
    return;
  }

  for (const cell of S.cells) {
    let m;
    re.lastIndex = 0;
    while ((m = re.exec(cell.code)) !== null) {
      S.findMatches.push({ cellId: cell.id, index: m.index, length: m[0].length });
      if (m[0].length === 0) re.lastIndex++;  // prevent infinite loop on zero-length match
    }
  }
  // keep findCurrent in range
  if (S.findMatches.length === 0) S.findCurrent = -1;
  else if (S.findCurrent < 0 || S.findCurrent >= S.findMatches.length) S.findCurrent = 0;
  findUpdateOverlays();
  findUpdateCount();
}

function findNext() {
  if (!S.findMatches.length) return;
  S.findCurrent = (S.findCurrent + 1) % S.findMatches.length;
  findUpdateOverlays();
  findUpdateCount();
  findScrollToMatch();
}

function findPrev() {
  if (!S.findMatches.length) return;
  S.findCurrent = (S.findCurrent - 1 + S.findMatches.length) % S.findMatches.length;
  findUpdateOverlays();
  findUpdateCount();
  findScrollToMatch();
}

function findReplace() {
  if (S.findCurrent < 0 || S.findCurrent >= S.findMatches.length) return;
  const match = S.findMatches[S.findCurrent];
  const cell = S.cells.find(c => c.id === match.cellId);
  if (!cell) return;
  const replaceVal = $('#replaceInput').value;
  if (S.findRegex) {
    const flags = S.findCase ? '' : 'i';
    try {
      const re = new RegExp(S.findQuery, flags);
      const matched = cell.code.substring(match.index, match.index + match.length);
      const replaced = matched.replace(re, replaceVal);
      cell.code = cell.code.substring(0, match.index) + replaced + cell.code.substring(match.index + match.length);
    } catch (e) { return; }
  } else {
    cell.code = cell.code.substring(0, match.index) + replaceVal + cell.code.substring(match.index + match.length);
  }
  // update textarea
  const ta = cell.el.querySelector('textarea');
  if (ta) {
    ta.value = cell.code;
    ta.dispatchEvent(new Event('input'));
  }
  findComputeMatches();
}

function findReplaceAll() {
  const query = S.findQuery;
  if (!query) return;
  const replaceVal = $('#replaceInput').value;
  const flags = S.findCase ? 'g' : 'gi';
  const pattern = S.findRegex ? query : escapeRegex(query);
  let re;
  try { re = new RegExp(pattern, flags); }
  catch (e) { return; }
  let count = 0;
  for (const cell of S.cells) {
    const before = cell.code;
    if (S.findRegex) {
      cell.code = cell.code.replace(re, (...args) => { count++; return replaceVal.replace(/\$(\d+)/g, (_, n) => args[+n] != null ? args[+n] : ''); });
    } else {
      cell.code = cell.code.replace(re, () => { count++; return replaceVal; });
    }
    if (cell.code !== before) {
      const ta = cell.el.querySelector('textarea');
      if (ta) {
        ta.value = cell.code;
        ta.dispatchEvent(new Event('input'));
      }
    }
  }
  findComputeMatches();
}

function findUpdateOverlays() {
  // remove existing overlays
  document.querySelectorAll('.search-overlay').forEach(el => el.remove());
  // unwrap md-search-wraps
  document.querySelectorAll('.md-search-wrap').forEach(wrap => {
    const ta = wrap.querySelector('textarea');
    if (ta) wrap.parentNode.insertBefore(ta, wrap);
    wrap.remove();
  });

  if (!S.findQuery || !S.findMatches.length) return;

  // group matches by cellId
  const byCell = {};
  S.findMatches.forEach((m, i) => {
    if (!byCell[m.cellId]) byCell[m.cellId] = [];
    byCell[m.cellId].push({ ...m, globalIdx: i });
  });

  for (const cellId of Object.keys(byCell)) {
    const cell = S.cells.find(c => c.id === parseInt(cellId));
    if (!cell) continue;
    const matches = byCell[cellId];
    const code = cell.code;

    // build overlay content
    let html = '';
    let pos = 0;
    for (const m of matches) {
      // text before match
      html += escHtml(code.substring(pos, m.index));
      const cls = m.globalIdx === S.findCurrent ? 'search-match search-match-current' : 'search-match';
      html += `<mark class="${cls}">${escHtml(code.substring(m.index, m.index + m.length))}</mark>`;
      pos = m.index + m.length;
    }
    html += escHtml(code.substring(pos));

    const overlay = document.createElement('div');

    if (cell.type === 'md') {
      // markdown cells: wrap textarea in md-search-wrap
      overlay.className = 'search-overlay search-overlay-md';
      overlay.innerHTML = html;
      const editWrap = cell.el.querySelector('.cell-md-edit');
      const ta = editWrap.querySelector('textarea');
      let wrap = editWrap.querySelector('.md-search-wrap');
      if (!wrap) {
        wrap = document.createElement('div');
        wrap.className = 'md-search-wrap';
        ta.parentNode.insertBefore(wrap, ta);
        wrap.appendChild(ta);
      }
      wrap.appendChild(overlay);
      wireScrollSync(ta, overlay);
    } else {
      // code, css, html cells: insert in editor-wrap
      overlay.className = 'search-overlay';
      overlay.innerHTML = html;
      let editorWrap;
      if (cell.type === 'code') editorWrap = cell.el.querySelector('.cell-code .editor-wrap');
      else if (cell.type === 'css') editorWrap = cell.el.querySelector('.cell-css-edit .editor-wrap');
      else if (cell.type === 'html') editorWrap = cell.el.querySelector('.cell-html-edit .editor-wrap');
      if (editorWrap) {
        editorWrap.appendChild(overlay);
        const ta = editorWrap.querySelector('textarea');
        if (ta) wireScrollSync(ta, overlay);
      }
    }
  }
}

function wireScrollSync(ta, overlay) {
  if (ta._searchScrollWired) return;
  ta._searchScrollWired = true;
  ta.addEventListener('scroll', () => {
    const ov = ta.closest('.editor-wrap, .md-search-wrap');
    if (!ov) return;
    const so = ov.querySelector('.search-overlay');
    if (so) {
      so.scrollTop = ta.scrollTop;
      so.scrollLeft = ta.scrollLeft;
    }
  });
}

function findUpdateCount() {
  const el = $('#findCount');
  if (!S.findQuery) { el.textContent = ''; return; }
  if (S.findMatches.length === 0) { el.textContent = 'no results'; return; }
  el.textContent = `${S.findCurrent + 1}/${S.findMatches.length}`;
}

function findScrollToMatch() {
  if (S.findCurrent < 0) return;
  const match = S.findMatches[S.findCurrent];
  if (!match) return;
  const cell = S.cells.find(c => c.id === match.cellId);
  if (!cell) return;

  // open editor for non-code cells if needed
  if (cell.type === 'css') {
    const editWrap = cell.el.querySelector('.cell-css-edit');
    const view = cell.el.querySelector('.cell-css-view');
    if (editWrap.style.display === 'none') {
      const ta = editWrap.querySelector('textarea');
      editWrap.style.display = '';
      view.style.display = 'none';
      ta.value = cell.code;
      autoResize({ target: ta });
    }
  } else if (cell.type === 'html') {
    const editWrap = cell.el.querySelector('.cell-html-edit');
    const view = cell.el.querySelector('.cell-html-view');
    if (editWrap.style.display === 'none') {
      const ta = editWrap.querySelector('textarea');
      editWrap.style.display = '';
      view.style.display = 'none';
      ta.value = cell.code;
      autoResize({ target: ta });
    }
  } else if (cell.type === 'md') {
    const editWrap = cell.el.querySelector('.cell-md-edit');
    const view = cell.el.querySelector('.cell-md-view');
    if (editWrap.style.display === 'none') {
      const ta = editWrap.querySelector('textarea');
      editWrap.style.display = '';
      view.style.display = 'none';
      ta.value = cell.code;
      autoResize({ target: ta });
    }
  }

  // uncollapse if collapsed
  cell.el.classList.remove('collapsed');

  // scroll cell into view
  cell.el.scrollIntoView({ block: 'nearest', behavior: 'smooth' });

  // scroll textarea to match line
  const ta = cell.type === 'md'
    ? cell.el.querySelector('.cell-md-edit textarea')
    : cell.type === 'css'
    ? cell.el.querySelector('.cell-css-edit textarea')
    : cell.type === 'html'
    ? cell.el.querySelector('.cell-html-edit textarea')
    : cell.el.querySelector('textarea');
  if (ta) {
    const textBefore = cell.code.substring(0, match.index);
    const lineNum = textBefore.split('\n').length - 1;
    const lineHeight = parseFloat(getComputedStyle(ta).lineHeight) || 20;
    ta.scrollTop = Math.max(0, lineNum * lineHeight - ta.clientHeight / 2);
  }
}

function escHtml(s) {
  return s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
}

// ── EVENT WIRING ──
(function () {
  const findInput = $('#findInput');
  const replaceInput = $('#replaceInput');
  if (!findInput) return;

  findInput.addEventListener('input', () => findComputeMatches());

  findInput.addEventListener('keydown', (e) => {
    if (e.key === 'Enter' && e.shiftKey) { e.preventDefault(); findPrev(); }
    else if (e.key === 'Enter') { e.preventDefault(); findNext(); }
    else if (e.key === 'Escape') { e.preventDefault(); closeFind(); }
  });

  if (replaceInput) {
    replaceInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') { e.preventDefault(); findReplace(); }
      else if (e.key === 'Escape') { e.preventDefault(); closeFind(); }
    });
  }

  const nextBtn = $('#findNextBtn');
  const prevBtn = $('#findPrevBtn');
  const replBtn = $('#findReplaceBtn');
  const replAllBtn = $('#findReplaceAllBtn');
  const caseBtn = $('#findCaseBtn');
  const regexBtn = $('#findRegexBtn');
  const closeBtn = $('#findCloseBtn');

  if (nextBtn) nextBtn.addEventListener('click', findNext);
  if (prevBtn) prevBtn.addEventListener('click', findPrev);
  if (replBtn) replBtn.addEventListener('click', findReplace);
  if (replAllBtn) replAllBtn.addEventListener('click', findReplaceAll);
  if (closeBtn) closeBtn.addEventListener('click', closeFind);
  if (caseBtn) caseBtn.addEventListener('click', () => {
    S.findCase = !S.findCase;
    caseBtn.classList.toggle('active', S.findCase);
    findComputeMatches();
  });
  if (regexBtn) regexBtn.addEventListener('click', () => {
    S.findRegex = !S.findRegex;
    regexBtn.classList.toggle('active', S.findRegex);
    findComputeMatches();
  });

  // live recompute on edit — delegation
  let recomputeTimer = null;
  document.getElementById('notebook').addEventListener('input', (e) => {
    if (!S.findActive) return;
    if (e.target.tagName !== 'TEXTAREA') return;
    clearTimeout(recomputeTimer);
    recomputeTimer = setTimeout(findComputeMatches, 150);
  });
})();

// -- complete.js --

// ── AUTOCOMPLETE ENGINE ──

// well-known property lists for dot completion on builtins
const KNOWN_PROPS = {
  Math: ['abs','acos','asin','atan','atan2','ceil','cos','exp','floor','hypot',
         'log','log2','log10','max','min','pow','random','round','sign','sin',
         'sqrt','tan','trunc','PI','E','LN2','LN10'],
  Array: ['from','isArray','of'],
  Object: ['keys','values','entries','assign','freeze','create','defineProperty','fromEntries','hasOwn'],
  JSON: ['parse','stringify'],
  console: ['log','warn','error','info','table','time','timeEnd','clear'],
  Promise: ['all','allSettled','any','race','resolve','reject'],
  Number: ['isFinite','isInteger','isNaN','parseFloat','parseInt','MAX_SAFE_INTEGER','MIN_SAFE_INTEGER','EPSILON'],
  String: ['fromCharCode','fromCodePoint','raw'],
  ui: ['display','print','canvas','table','slider','dropdown','checkbox','textInput'],
  std: ['csv','fetchJSON','sum','mean','median','extent','bin','linspace',
        'unique','zip','cross','file','download','el','copy','fmt'],
};

// common prototype methods by type
const PROTO_PROPS = {
  array: ['push','pop','shift','unshift','splice','slice','concat','join','reverse',
          'sort','map','filter','reduce','reduceRight','find','findIndex','indexOf',
          'includes','every','some','flat','flatMap','fill','forEach','at','length'],
  string: ['charAt','charCodeAt','codePointAt','concat','endsWith','includes',
           'indexOf','lastIndexOf','match','matchAll','padEnd','padStart','repeat',
           'replace','replaceAll','search','slice','split','startsWith','substring',
           'toLowerCase','toUpperCase','trim','trimEnd','trimStart','at','length'],
  number: ['toFixed','toPrecision','toString','valueOf'],
};

// ── BUILTIN HELP (injected by build.js from src/builtins.json) ──

const BUILTIN_HELP = {
  "ui.display": {
    "sig": "ui.display(...values)",
    "desc": "output values to cell"
  },
  "ui.canvas": {
    "sig": "ui.canvas(w?, h?)",
    "desc": "create/reuse canvas (default 400\u00d7300)"
  },
  "ui.table": {
    "sig": "ui.table(data, columns?)",
    "desc": "render array of objects as table"
  },
  "ui.slider": {
    "sig": "ui.slider(label, default?, {min,max,step,onInput,onChange}?)",
    "desc": "range input \u2014 reactive, or callback via onInput/onChange"
  },
  "ui.dropdown": {
    "sig": "ui.dropdown(label, options, default?, {onInput,onChange}?)",
    "desc": "select menu \u2014 reactive, or callback via onInput/onChange"
  },
  "ui.checkbox": {
    "sig": "ui.checkbox(label, default?, {onInput,onChange}?)",
    "desc": "toggle \u2014 reactive, or callback via onInput/onChange"
  },
  "ui.textInput": {
    "sig": "ui.textInput(label, default?, {onInput,onChange}?)",
    "desc": "text field \u2014 reactive, or callback via onInput/onChange"
  },
  "std.csv": {
    "sig": "std.csv(text, {separator?, typed?}?)",
    "desc": "parse CSV text to array of objects"
  },
  "std.fetchJSON": {
    "sig": "std.fetchJSON(url)",
    "desc": "fetch URL and parse JSON"
  },
  "std.sum": {
    "sig": "std.sum(arr, fn?)",
    "desc": "sum array values"
  },
  "std.mean": {
    "sig": "std.mean(arr, fn?)",
    "desc": "arithmetic mean"
  },
  "std.median": {
    "sig": "std.median(arr, fn?)",
    "desc": "median value"
  },
  "std.extent": {
    "sig": "std.extent(arr, fn?)",
    "desc": "returns [min, max]"
  },
  "std.bin": {
    "sig": "std.bin(arr, n?, fn?)",
    "desc": "histogram bins (default 10)"
  },
  "std.linspace": {
    "sig": "std.linspace(start, stop, n)",
    "desc": "evenly-spaced numbers"
  },
  "std.unique": {
    "sig": "std.unique(arr, fn?)",
    "desc": "unique values with optional key fn"
  },
  "std.zip": {
    "sig": "std.zip(...arrays)",
    "desc": "zip arrays together"
  },
  "std.cross": {
    "sig": "std.cross(...arrays)",
    "desc": "cartesian product"
  },
  "std.file": {
    "sig": "std.file(accept?)",
    "desc": "open file picker"
  },
  "std.download": {
    "sig": "std.download(data, filename, mimeType?)",
    "desc": "download data as file"
  },
  "std.el": {
    "sig": "std.el(tag, attrs?, ...children)",
    "desc": "create DOM element"
  },
  "std.copy": {
    "sig": "std.copy(text)",
    "desc": "copy text to clipboard"
  },
  "std.fmt": {
    "sig": "std.fmt(number, {decimals?, prefix?, suffix?}?)",
    "desc": "format number to string"
  },
  "print": {
    "sig": "print(...values)",
    "desc": "output values to cell (alias for ui.display)"
  },
  "load": {
    "sig": "load(url)",
    "desc": "import ES module (cached). @std, @python supported."
  },
  "install": {
    "sig": "install(url)",
    "desc": "fetch & embed module for offline"
  },
  "invalidation": {
    "sig": "invalidation",
    "desc": "promise \u2014 resolves when cell re-runs"
  },
  "atra": {
    "sig": "atra`...` or atra({imports})`...`",
    "desc": "compile Fortran/Pascal to Wasm (load ext/atra/index.js)"
  }
};

// ── FUZZY MATCHING ──

// returns { score, indices } or null if no match
// indices = positions in `text` that matched characters from `query`
function fuzzyMatch(query, text) {
  const qLen = query.length;
  const tLen = text.length;
  if (qLen === 0) return { score: 0, indices: [] };
  if (qLen > tLen) return null;

  const qLower = query.toLowerCase();
  const tLower = text.toLowerCase();

  // fast check: all query chars exist in text in order
  let qi = 0;
  for (let ti = 0; ti < tLen && qi < qLen; ti++) {
    if (qLower[qi] === tLower[ti]) qi++;
  }
  if (qi < qLen) return null;

  // find best match using a greedy approach that prefers word boundaries
  // word boundaries: start of string, after _ or $, camelCase transitions
  const indices = [];
  qi = 0;

  // first pass: try to match at word boundaries
  const boundaryIndices = [];
  let bqi = 0;
  for (let ti = 0; ti < tLen && bqi < qLen; ti++) {
    if (qLower[bqi] !== tLower[ti]) continue;
    const isBoundary = ti === 0
      || text[ti - 1] === '_' || text[ti - 1] === '$'
      || (text[ti] >= 'A' && text[ti] <= 'Z' && (ti === 0 || text[ti - 1] < 'A' || text[ti - 1] > 'Z'));
    if (isBoundary) {
      boundaryIndices.push(ti);
      bqi++;
    }
  }

  if (bqi === qLen) {
    // all chars matched at boundaries — use those indices
    indices.push(...boundaryIndices);
  } else {
    // fallback: greedy left-to-right match, prefer consecutive runs
    qi = 0;
    for (let ti = 0; ti < tLen && qi < qLen; ti++) {
      if (qLower[qi] === tLower[ti]) {
        indices.push(ti);
        qi++;
      }
    }
  }

  // score the match
  let score = 0;

  // bonus for matching at start of string
  if (indices[0] === 0) score += 10;

  // bonus for consecutive characters
  for (let i = 1; i < indices.length; i++) {
    if (indices[i] === indices[i - 1] + 1) score += 5;
  }

  // bonus for word boundary matches
  for (const idx of indices) {
    if (idx === 0) { score += 3; continue; }
    const prev = text[idx - 1];
    if (prev === '_' || prev === '$') { score += 3; continue; }
    if (text[idx] >= 'A' && text[idx] <= 'Z' && (prev < 'A' || prev > 'Z')) score += 3;
  }

  // bonus for exact case match
  for (let i = 0; i < indices.length; i++) {
    if (query[i] === text[indices[i]]) score += 1;
  }

  // penalty for spread-out matches (large gaps between indices)
  const span = indices[indices.length - 1] - indices[0];
  score -= span * 0.5;

  // slight penalty for longer names (prefer shorter completions)
  score -= tLen * 0.1;

  return { score, indices };
}

// determine cursor context: is it inside a string or comment?
function cursorContext(code, cursor) {
  let i = 0;
  while (i < cursor) {
    const ch = code[i];
    // single-line comment
    if (ch === '/' && code[i + 1] === '/') {
      const nl = code.indexOf('\n', i);
      if (nl === -1 || nl >= cursor) return 'comment';
      i = nl + 1;
      continue;
    }
    // block comment
    if (ch === '/' && code[i + 1] === '*') {
      const end = code.indexOf('*/', i + 2);
      if (end === -1 || end + 2 > cursor) return 'comment';
      i = end + 2;
      continue;
    }
    // single-quoted string
    if (ch === "'") {
      i++;
      while (i < code.length) {
        if (code[i] === '\\') { i += 2; continue; }
        if (code[i] === "'") { i++; break; }
        if (i >= cursor) return 'string';
        i++;
      }
      continue;
    }
    // double-quoted string
    if (ch === '"') {
      i++;
      while (i < code.length) {
        if (code[i] === '\\') { i += 2; continue; }
        if (code[i] === '"') { i++; break; }
        if (i >= cursor) return 'string';
        i++;
      }
      continue;
    }
    // template literal (possibly tagged)
    if (ch === '`') {
      // look back for a tag name: identifier immediately before the backtick,
      // or curried form: identifier(...) before the backtick
      let tagName = null;
      if (i > 0 && typeof window !== 'undefined' && window._taggedLanguages) {
        let te = i;
        let ts = te;
        // direct form: ident`
        while (ts > 0 && /\w/.test(code[ts - 1])) ts--;
        if (ts < te) {
          const candidate = code.slice(ts, te);
          if (window._taggedLanguages[candidate]) tagName = candidate;
        }
        // curried form: ident(...)`
        if (!tagName && code[i - 1] === ')') {
          let p = i - 2, depth = 1;
          while (p >= 0 && depth > 0) {
            if (code[p] === ')') depth++;
            else if (code[p] === '(') depth--;
            p--;
          }
          // p now points one before the (
          let ne = p + 1;
          let ns = ne;
          while (ns > 0 && /\w/.test(code[ns - 1])) ns--;
          if (ns < ne) {
            const candidate = code.slice(ns, ne);
            if (window._taggedLanguages[candidate]) tagName = candidate;
          }
        }
      }

      i++;
      let depth = 0;
      while (i < code.length) {
        if (code[i] === '\\') { i += 2; continue; }
        if (code[i] === '$' && code[i + 1] === '{') {
          depth++;
          i += 2;
          // inside ${...} — this is code context
          let braces = 1;
          while (i < code.length && braces > 0) {
            if (code[i] === '{') braces++;
            else if (code[i] === '}') { braces--; if (braces === 0) break; }
            if (i >= cursor) return 'code'; // inside template expression = code
            i++;
          }
          if (i >= cursor) return 'code';
          i++; // skip closing }
          continue;
        }
        if (code[i] === '`') { i++; break; }
        if (i >= cursor) return tagName ? { type: 'tagged', lang: tagName } : 'string';
        i++;
      }
      continue;
    }
    i++;
  }
  return 'code';
}

// extract the word being typed at cursor position
function extractPrefix(code, cursor) {
  let end = cursor;
  let start = cursor;
  while (start > 0 && /[a-zA-Z0-9_$]/.test(code[start - 1])) start--;
  return { prefix: code.slice(start, end), start };
}

// detect dot access: returns the expression before the dot, or null
function detectDot(code, cursor) {
  // cursor is right after a dot or after dot + partial word
  const before = code.slice(0, cursor);
  // match patterns like "identifier." or "identifier.par" at end
  const m = before.match(/([a-zA-Z_$][\w$]*)\.\s*([a-zA-Z_$][\w$]*)?$/);
  if (m) return { obj: m[1], prefix: m[2] || '' };
  return null;
}

function getPropsForValue(val) {
  if (val == null) return [];
  const props = new Set();
  // own properties
  const own = Object.getOwnPropertyNames(val);
  for (const p of own) {
    if (/^[a-zA-Z_$]/.test(p)) props.add(p);
  }
  // prototype chain (1 level)
  const proto = Object.getPrototypeOf(val);
  if (proto && proto !== Object.prototype) {
    try {
      const pNames = Object.getOwnPropertyNames(proto);
      for (const p of pNames) {
        if (p !== 'constructor' && /^[a-zA-Z_$]/.test(p)) props.add(p);
      }
    } catch {}
  }
  return [...props];
}

function getCompletions(code, cursor, cellId) {
  const ctx = cursorContext(code, cursor);

  // tagged template literal — delegate to extension completions
  if (ctx && typeof ctx === 'object' && ctx.type === 'tagged') {
    const lang = typeof window !== 'undefined' && window._taggedLanguages
      && window._taggedLanguages[ctx.lang];
    if (lang && lang.completions) {
      const { prefix, start } = extractPrefix(code, cursor);
      if (!prefix) return { prefix: '', items: [] };
      const extItems = lang.completions(prefix);
      // score and annotate items
      const items = [];
      for (const it of extItems) {
        const m = fuzzyMatch(prefix, it.text);
        if (m) items.push({ text: it.text, kind: it.kind || 'var', score: m.score, indices: m.indices });
      }
      items.sort((a, b) => b.score - a.score || a.text.localeCompare(b.text));
      return { prefix, items: items.slice(0, 30) };
    }
    return { prefix: '', items: [] };
  }

  if (ctx !== 'code') return { prefix: '', items: [] };

  // check for dot completion
  const dot = detectDot(code, cursor);
  if (dot) {
    const items = [];
    const prefix = dot.prefix;
    let propList = [];

    // check known builtins
    if (KNOWN_PROPS[dot.obj]) {
      propList = KNOWN_PROPS[dot.obj];
    } else if (dot.obj in S.scope) {
      // live value inspection
      const val = S.scope[dot.obj];
      if (val != null) {
        propList = getPropsForValue(val);
        // also add type-based suggestions
        if (Array.isArray(val)) propList = [...new Set([...propList, ...PROTO_PROPS.array])];
        else if (typeof val === 'string') propList = [...new Set([...propList, ...PROTO_PROPS.string])];
        else if (typeof val === 'number') propList = [...new Set([...propList, ...PROTO_PROPS.number])];
      }
    }

    for (const p of propList) {
      if (!prefix) {
        items.push({ text: p, kind: 'prop', score: 0, indices: [] });
        continue;
      }
      const m = fuzzyMatch(prefix, p);
      if (m) items.push({ text: p, kind: 'prop', score: m.score, indices: m.indices });
    }

    items.sort((a, b) => b.score - a.score || a.text.localeCompare(b.text));
    return { prefix, items: items.slice(0, 30) };
  }

  // word prefix completion
  const { prefix, start } = extractPrefix(code, cursor);
  if (!prefix) return { prefix: '', items: [] };

  const items = [];
  const seen = new Set();

  // collect candidates from all sources with their kind
  const candidates = [];

  // 1. scope variables
  for (const name of Object.keys(S.scope)) {
    if (!seen.has(name)) { seen.add(name); candidates.push({ text: name, kind: 'var' }); }
  }

  // 2. own cell defines
  const cell = S.cells.find(c => c.id === cellId);
  if (cell && cell.defines) {
    for (const name of cell.defines) {
      if (!seen.has(name)) { seen.add(name); candidates.push({ text: name, kind: 'def' }); }
    }
  }

  // 3. builtin functions (with help detail)
  for (const name of Object.keys(BUILTIN_HELP)) {
    if (!seen.has(name)) {
      seen.add(name);
      const h = BUILTIN_HELP[name];
      candidates.push({ text: name, kind: 'fn', detail: h.sig });
    }
  }

  // 4. JS builtins
  for (const name of JS_BUILTINS) {
    if (!seen.has(name)) { seen.add(name); candidates.push({ text: name, kind: 'const' }); }
  }

  // 5. JS keywords (min 2 chars to avoid noise)
  if (prefix.length >= 2) {
    for (const name of JS_KEYWORDS) {
      if (!seen.has(name)) { seen.add(name); candidates.push({ text: name, kind: 'kw' }); }
    }
  }

  // fuzzy match all candidates
  for (const c of candidates) {
    if (c.text === prefix) continue; // skip exact match (already typed)
    const m = fuzzyMatch(prefix, c.text);
    if (m) {
      const item = { text: c.text, kind: c.kind, score: m.score, indices: m.indices };
      if (c.detail) item.detail = c.detail;
      items.push(item);
    }
  }

  // sort by score descending, then alphabetical
  items.sort((a, b) => b.score - a.score || a.text.localeCompare(b.text));

  return { prefix, items: items.slice(0, 30) };
}

// ── TEXTAREA ADAPTER ──

const KIND_LABELS = { var: 'v', fn: 'f', kw: 'k', const: 'c', prop: 'p', def: 'd' };

let activeMenu = null;
let activeState = null;
let activeSigHint = null;

function dismissAutocomplete() {
  if (activeMenu) {
    activeMenu.remove();
    activeMenu = null;
    activeState = null;
  }
}

function dismissSigHint() {
  if (activeSigHint) {
    activeSigHint.remove();
    activeSigHint = null;
  }
}

// detect if cursor is inside a function call's arguments for a known builtin
function detectCallContext(code, cursor) {
  // scan backwards from cursor to find an unmatched (
  let depth = 0;
  let i = cursor - 1;
  while (i >= 0) {
    const ch = code[i];
    if (ch === ')') depth++;
    else if (ch === '(') {
      if (depth === 0) {
        // found the opening paren — extract the function name before it (including dot for ui.slider etc.)
        let end = i;
        let start = end - 1;
        while (start >= 0 && /[a-zA-Z0-9_$.]/.test(code[start])) start--;
        start++;
        const fnName = code.slice(start, end);
        if (BUILTIN_HELP[fnName]) {
          // figure out which parameter we're on by counting commas at depth 0
          let paramIdx = 0;
          let d = 0;
          for (let j = i + 1; j < cursor; j++) {
            if (code[j] === '(' || code[j] === '[' || code[j] === '{') d++;
            else if (code[j] === ')' || code[j] === ']' || code[j] === '}') d--;
            else if (code[j] === ',' && d === 0) paramIdx++;
          }
          return { fnName, parenPos: i, paramIdx };
        }
        return null;
      }
      depth--;
    }
    i--;
  }
  return null;
}

function showSigHint(ta) {
  const code = ta.value;
  const cursor = ta.selectionStart;
  if (ta.selectionStart !== ta.selectionEnd) { dismissSigHint(); return; }

  const ctx = cursorContext(code, cursor);
  if (ctx !== 'code') { dismissSigHint(); return; }

  const call = detectCallContext(code, cursor);
  if (!call) { dismissSigHint(); return; }

  const wrap = ta.closest('.editor-wrap');
  if (!wrap) { dismissSigHint(); return; }

  const help = BUILTIN_HELP[call.fnName];
  const pos = measureCursorPos(ta, call.parenPos);

  if (!activeSigHint) {
    activeSigHint = document.createElement('div');
    activeSigHint.className = 'ac-sig-hint';
    wrap.appendChild(activeSigHint);
  } else if (activeSigHint.parentElement !== wrap) {
    activeSigHint.remove();
    wrap.appendChild(activeSigHint);
  }

  // highlight current parameter in the signature
  const sigHtml = highlightParam(help.sig, call.paramIdx);
  activeSigHint.innerHTML = `<span class="ac-sig-fn">${sigHtml}</span><span class="ac-sig-desc">${esc(help.desc)}</span>`;

  const cs = getComputedStyle(ta);
  const padLeft = parseFloat(cs.paddingLeft) || 0;
  const padTop = parseFloat(cs.paddingTop) || 0;
  const lineHeight = parseFloat(cs.lineHeight) || parseFloat(cs.fontSize) * 1.5;

  const left = pos.x + padLeft - ta.scrollLeft;

  // place above the current line; pos.y is bottom of the line
  // so subtract lineHeight (to get top of line) then the hint's own height
  activeSigHint.style.left = left + 'px';
  activeSigHint.style.top = '0px'; // render off-screen first to measure
  activeSigHint.style.visibility = 'hidden';
  const hintH = activeSigHint.offsetHeight || lineHeight;
  activeSigHint.style.visibility = '';

  let top = pos.y + padTop - ta.scrollTop - lineHeight - hintH;

  // if it would go above the editor, show below the current line instead
  const wrapRect = wrap.getBoundingClientRect();
  const taRect = ta.getBoundingClientRect();
  const absTop = taRect.top + top;
  if (absTop < wrapRect.top) {
    top = pos.y + padTop - ta.scrollTop;
  }

  activeSigHint.style.top = top + 'px';
}

function highlightParam(sig, paramIdx) {
  // find the params inside parens
  const openParen = sig.indexOf('(');
  if (openParen === -1) return esc(sig);
  const closeParen = sig.lastIndexOf(')');
  if (closeParen === -1) return esc(sig);

  const before = sig.slice(0, openParen + 1);
  const params = sig.slice(openParen + 1, closeParen);
  const after = sig.slice(closeParen);

  // split on commas (respecting nested braces)
  const parts = [];
  let depth = 0;
  let start = 0;
  for (let i = 0; i < params.length; i++) {
    if (params[i] === '{' || params[i] === '(' || params[i] === '[') depth++;
    else if (params[i] === '}' || params[i] === ')' || params[i] === ']') depth--;
    else if (params[i] === ',' && depth === 0) {
      parts.push(params.slice(start, i));
      start = i + 1;
    }
  }
  parts.push(params.slice(start));

  let html = esc(before);
  for (let i = 0; i < parts.length; i++) {
    if (i > 0) html += esc(',');
    if (i === paramIdx) {
      html += '<span class="ac-sig-active">' + esc(parts[i]) + '</span>';
    } else {
      html += esc(parts[i]);
    }
  }
  html += esc(after);
  return html;
}

function measureCursorPos(ta, cursor) {
  const text = ta.value.substring(0, cursor);
  const lines = text.split('\n');
  const lineNum = lines.length - 1;
  const colText = lines[lineNum];

  // measure column offset using a hidden span
  let measurer = ta._acMeasurer;
  if (!measurer) {
    measurer = document.createElement('span');
    measurer.style.cssText = 'position:absolute;visibility:hidden;white-space:pre;pointer-events:none;';
    document.body.appendChild(measurer);
    ta._acMeasurer = measurer;
  }
  const cs = getComputedStyle(ta);
  measurer.style.font = cs.font;
  measurer.style.fontSize = cs.fontSize;
  measurer.style.fontFamily = cs.fontFamily;
  measurer.style.letterSpacing = cs.letterSpacing;
  measurer.style.tabSize = cs.tabSize;
  measurer.textContent = colText;

  const lineHeight = parseFloat(cs.lineHeight) || parseFloat(cs.fontSize) * 1.5;
  const x = measurer.offsetWidth;
  const y = (lineNum + 1) * lineHeight;

  return { x, y, lineHeight };
}

function highlightMatches(text, indices) {
  if (!indices || !indices.length) return esc(text);
  const set = new Set(indices);
  let html = '';
  let inMatch = false;
  for (let i = 0; i < text.length; i++) {
    if (set.has(i)) {
      if (!inMatch) { html += '<span class="ac-match">'; inMatch = true; }
      html += esc(text[i]);
    } else {
      if (inMatch) { html += '</span>'; inMatch = false; }
      html += esc(text[i]);
    }
  }
  if (inMatch) html += '</span>';
  return html;
}

function renderMenu(items, prefix, selectedIdx) {
  let html = '';
  const max = Math.min(items.length, 30);
  for (let i = 0; i < max; i++) {
    const it = items[i];
    const cls = i === selectedIdx ? 'ac-item active' : 'ac-item';
    const kindCls = 'ac-kind ac-kind-' + it.kind;
    const label = KIND_LABELS[it.kind] || '?';
    const textHtml = highlightMatches(it.text, it.indices);
    const detailHtml = it.detail ? `<span class="ac-detail">${esc(it.detail)}</span>` : '';
    html += `<div class="${cls}" data-index="${i}"><span class="${kindCls}">${label}</span><span class="ac-text">${textHtml}</span>${detailHtml}</div>`;
  }
  return html;
}

function esc(s) {
  return s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
}

function showMenu(ta, cellId) {
  const code = ta.value;
  const cursor = ta.selectionStart;
  if (ta.selectionStart !== ta.selectionEnd) { dismissAutocomplete(); return; }

  const result = getCompletions(code, cursor, cellId);
  if (!result.items.length) { dismissAutocomplete(); return; }

  const wrap = ta.closest('.editor-wrap');
  if (!wrap) { dismissAutocomplete(); return; }

  const pos = measureCursorPos(ta, cursor);

  if (!activeMenu) {
    activeMenu = document.createElement('div');
    activeMenu.className = 'ac-menu';
    wrap.appendChild(activeMenu);
  } else if (activeMenu.parentElement !== wrap) {
    activeMenu.remove();
    wrap.appendChild(activeMenu);
  }

  activeState = {
    items: result.items,
    prefix: result.prefix,
    selected: 0,
    ta,
    cellId,
    cursorStart: cursor - result.prefix.length
  };

  activeMenu.innerHTML = renderMenu(result.items, result.prefix, 0);

  // position: account for padding and scroll
  const cs = getComputedStyle(ta);
  const padLeft = parseFloat(cs.paddingLeft) || 0;
  const padTop = parseFloat(cs.paddingTop) || 0;

  const left = pos.x + padLeft - ta.scrollLeft;
  const top = pos.y + padTop - ta.scrollTop;

  activeMenu.style.left = left + 'px';
  activeMenu.style.top = top + 'px';

  // flip above if it would overflow viewport
  const menuRect = activeMenu.getBoundingClientRect();
  if (menuRect.bottom > window.innerHeight - 20) {
    activeMenu.style.top = (top - pos.lineHeight - activeMenu.offsetHeight) + 'px';
  }

  // mouse interaction
  activeMenu.onmousedown = (e) => {
    e.preventDefault(); // don't blur textarea
    const item = e.target.closest('.ac-item');
    if (item) {
      activeState.selected = parseInt(item.dataset.index);
      acceptCompletion();
    }
  };
}

function updateSelection(idx) {
  if (!activeMenu || !activeState) return;
  activeState.selected = idx;
  const items = activeMenu.querySelectorAll('.ac-item');
  items.forEach((el, i) => el.classList.toggle('active', i === idx));
  // scroll into view
  if (items[idx]) items[idx].scrollIntoView({ block: 'nearest' });
}

function acceptCompletion() {
  if (!activeState) return;
  const { items, selected, ta, prefix, cursorStart } = activeState;
  const item = items[selected];
  if (!item) return;

  ta.focus();
  ta.selectionStart = cursorStart;
  ta.selectionEnd = cursorStart + prefix.length;
  document.execCommand('insertText', false, item.text);

  dismissAutocomplete();
  ta.dispatchEvent(new Event('input'));
}

function attachAutocomplete(textarea, cellId) {
  // keydown handler — must be added BEFORE handleTab so stopImmediatePropagation works
  textarea.addEventListener('keydown', (e) => {
    // Ctrl+Shift+Space — manual signature hint trigger
    if (e.key === ' ' && (e.ctrlKey || e.metaKey) && e.shiftKey) {
      e.preventDefault();
      e.stopImmediatePropagation();
      dismissAutocomplete();
      showSigHint(textarea);
      return;
    }

    if (!activeMenu || !activeState) return;

    if (e.key === 'ArrowDown') {
      e.preventDefault();
      e.stopImmediatePropagation();
      const next = (activeState.selected + 1) % activeState.items.length;
      updateSelection(next);
      return;
    }
    if (e.key === 'ArrowUp') {
      e.preventDefault();
      e.stopImmediatePropagation();
      const prev = (activeState.selected - 1 + activeState.items.length) % activeState.items.length;
      updateSelection(prev);
      return;
    }
    if (e.key === 'Tab' || e.key === 'Enter') {
      e.preventDefault();
      e.stopImmediatePropagation();
      acceptCompletion();
      return;
    }
    if (e.key === 'Escape') {
      e.preventDefault();
      e.stopImmediatePropagation();
      dismissAutocomplete();
      dismissSigHint();
      return;
    }
  });

  // input handler — show/update completions + signature hints
  textarea.addEventListener('input', () => {
    // use a microtask so the value is settled
    Promise.resolve().then(() => {
      showMenu(textarea, cellId);
      // show sig hint only when autocomplete menu is not visible
      if (!activeMenu) showSigHint(textarea);
      else dismissSigHint();
    });
  });

  // dismiss on blur
  textarea.addEventListener('blur', () => {
    // delay so mousedown on menu can fire first
    setTimeout(() => { dismissAutocomplete(); dismissSigHint(); }, 150);
  });

  // dismiss on scroll (position goes stale)
  textarea.addEventListener('scroll', () => {
    dismissAutocomplete();
    dismissSigHint();
  });
}

// -- keyboard.js --

// ── KEYBOARD / SELECTION ──

function addCellWithUndo(type, code, afterId, beforeId) {
  const cell = addCell(type, code, afterId, beforeId);
  S.trash.push({ action: 'add', id: cell.id });
  return cell;
}

function deleteCellWithUndo(id) {
  const idx = S.cells.findIndex(c => c.id === id);
  if (idx < 0) return;
  const cell = S.cells[idx];
  const afterId = idx > 0 ? S.cells[idx - 1].id : null;
  const beforeId = afterId === null && idx < S.cells.length - 1 ? S.cells[idx + 1].id : null;
  S.trash.push({ action: 'delete', type: cell.type, code: cell.code, afterId, beforeId, collapsed: !!cell.el.classList.contains('collapsed') });
  deleteCell(id);
  setMsg('deleted cell (z to undo)', 'ok');
}

function undo() {
  if (!S.trash.length) { setMsg('nothing to undo', ''); return; }
  const entry = S.trash.pop();

  if (entry.action === 'add') {
    // undo add = delete the cell (without pushing to undo stack)
    deleteCell(entry.id);
    setMsg('undid add', 'ok');
  } else {
    // undo delete = restore the cell
    const { type, code, afterId, beforeId, collapsed } = entry;
    const validAfter = afterId !== null && S.cells.find(c => c.id === afterId) ? afterId : null;
    const validBefore = beforeId !== null && S.cells.find(c => c.id === beforeId) ? beforeId : null;
    const newCell = addCell(type, code, validAfter, validBefore);
    if (collapsed) newCell.el.classList.add('collapsed');
    selectCell(newCell.id);
    if ((type === 'code' || type === 'html') && S.cells.some(c => c.type === 'code' || c.type === 'html')) runAll();
    setMsg('restored cell', 'ok');
  }
}

function selectCell(id, scroll) {
  // deselect previous
  $$('.cell.selected').forEach(el => el.classList.remove('selected'));
  S.selectedId = id;
  if (id === null) return;
  const cell = S.cells.find(c => c.id === id);
  if (cell) {
    cell.el.classList.add('selected');
    if (scroll) cell.el.scrollIntoView({ block: 'nearest' });
  }
}

function getEditingCell() {
  const active = document.activeElement;
  if (active && active.tagName === 'TEXTAREA') {
    const cellEl = active.closest('.cell');
    if (cellEl) {
      const id = parseInt(cellEl.dataset.id);
      return S.cells.find(c => c.id === id) || null;
    }
  }
  return null;
}

function editCell(id) {
  const cell = S.cells.find(c => c.id === id);
  if (!cell) return;
  selectCell(id);

  if (cell.type === 'md') {
    // open md editor
    const view = cell.el.querySelector('.cell-md-view');
    const editWrap = cell.el.querySelector('.cell-md-edit');
    const ta = cell.el.querySelector('.cell-md-edit textarea');
    editWrap.style.display = '';
    view.style.display = 'none';
    ta.value = cell.code;
    ta.focus();
    autoResize({ target: ta });
  } else if (cell.type === 'css') {
    // open css editor
    const view = cell.el.querySelector('.cell-css-view');
    const editWrap = cell.el.querySelector('.cell-css-edit');
    const ta = cell.el.querySelector('.cell-css-edit textarea');
    editWrap.style.display = '';
    view.style.display = 'none';
    ta.value = cell.code;
    ta.focus();
    autoResize({ target: ta });
  } else if (cell.type === 'html') {
    // open html editor
    const view = cell.el.querySelector('.cell-html-view');
    const editWrap = cell.el.querySelector('.cell-html-edit');
    const ta = cell.el.querySelector('.cell-html-edit textarea');
    editWrap.style.display = '';
    view.style.display = 'none';
    ta.value = cell.code;
    ta.focus();
    autoResize({ target: ta });
  } else {
    cell.el.querySelector('textarea').focus();
  }
}

function exitEdit() {
  const active = document.activeElement;
  if (active && active.tagName === 'TEXTAREA') {
    active.blur();
  }
}

function runSelected() {
  if (S.selectedId === null && S.cells.length) selectCell(S.cells[0].id);
  const cell = S.cells.find(c => c.id === S.selectedId);
  if (!cell) return;
  if (cell.type === 'code') {
    cell.code = cell.el.querySelector('.cell-code textarea').value;
    runDAG([cell.id]);
  } else if (cell.type === 'html') {
    renderHtmlCell(cell);
  }
}

// ── MOBILE TRAY TOGGLES ──

function closeAllTrays() {
  document.querySelectorAll('.action-add-tray.open, .action-more-tray.open, .cell-type-picker.open, .cell-insert-picker.open').forEach(el => el.classList.remove('open'));
}

function toggleToolbarMenu() {
  const menu = document.querySelector('.toolbar-overflow');
  if (!menu) return;
  menu.classList.toggle('open');
}

function toggleAddTray() {
  const tray = document.querySelector('.action-add-tray');
  if (!tray) return;
  const wasOpen = tray.classList.contains('open');
  closeAllTrays();
  if (!wasOpen) tray.classList.add('open');
}

function toggleMoreTray() {
  const tray = document.querySelector('.action-more-tray');
  if (!tray) return;
  const wasOpen = tray.classList.contains('open');
  closeAllTrays();
  if (!wasOpen) tray.classList.add('open');
}

function showInsertPicker(id, dir) {
  closeAllTrays();
  const cell = S.cells.find(c => c.id === id);
  if (!cell) return;
  document.querySelectorAll('.cell-insert-picker').forEach(el => el.remove());
  const picker = document.createElement('div');
  picker.className = 'cell-insert-picker open';
  let afterId;
  if (dir === 'after') {
    afterId = id;
  } else {
    const idx = S.cells.findIndex(c => c.id === id);
    afterId = idx > 0 ? S.cells[idx - 1].id : null;
  }
  picker.innerHTML = ['code', 'md', 'css', 'html'].map(t =>
    `<button onclick="insertAt(${afterId !== null ? afterId : 'null'},'${t}');this.closest('.cell-insert-picker').remove()">${t}</button>`
  ).join('');
  const header = cell.el.querySelector('.cell-header');
  header.style.position = 'relative';
  picker.style.top = '100%';
  picker.style.left = dir === 'before' ? '0' : 'auto';
  picker.style.right = dir === 'after' ? '0' : 'auto';
  header.appendChild(picker);
}

function toggleTypePicker(id) {
  closeAllTrays();
  const picker = document.querySelector(`.cell-type-picker[data-cell-id="${id}"]`);
  if (picker) picker.classList.toggle('open');
}

function collapseAll() {
  S.cells.forEach(c => c.el.classList.add('collapsed'));
  setMsg('collapsed all', 'ok');
}

function expandAll() {
  S.cells.forEach(c => c.el.classList.remove('collapsed'));
  setMsg('expanded all', 'ok');
}

function newNotebook() {
  if (!confirm('Clear all cells?')) return;
  while (S.cells.length) {
    const cell = S.cells[0];
    if (cell._styleEl) { cell._styleEl.remove(); cell._styleEl = null; }
    cell.el.remove();
    S.cells.shift();
  }
  S.scope = {};
  S.selectedId = null;
  S.clipboard = null;
  S.trash = [];
  $('#docTitle').value = 'untitled';
  updateStatus();
  setMsg('new notebook', 'ok');
}

function runSelectedCell() { runSelectedAndAdvance(); }

function runSelectedAndAdvance() {
  runSelected();
  if (S.selectedId === null) return;
  // respect goto target if set
  const gotoIdx = window._lastGotoTarget;
  if (gotoIdx != null && gotoIdx >= 0 && gotoIdx < S.cells.length) {
    editCell(S.cells[gotoIdx].id);
  } else {
    const idx = S.cells.findIndex(c => c.id === S.selectedId);
    if (idx < S.cells.length - 1) {
      editCell(S.cells[idx + 1].id);
    } else {
      const newCell = addCellWithUndo('code', '', S.selectedId);
      selectCell(newCell.id);
    }
  }
}

function navigateCell(dir) {
  if (!S.cells.length) return;
  if (S.selectedId === null) {
    selectCell(S.cells[0].id, true);
    return;
  }
  const idx = S.cells.findIndex(c => c.id === S.selectedId);
  const newIdx = idx + dir;
  if (newIdx >= 0 && newIdx < S.cells.length) {
    selectCell(S.cells[newIdx].id, true);
  }
}

document.addEventListener('keydown', (e) => {
  // find bar shortcuts (must be before edit/command branches)
  if ((e.key === 'f') && (e.ctrlKey || e.metaKey) && !e.altKey) {
    e.preventDefault(); openFind(false); return;
  }
  if ((e.key === 'h') && (e.ctrlKey || e.metaKey) && !e.altKey) {
    e.preventDefault(); openFind(true); return;
  }
  if (e.key === 'Escape' && S.findActive) {
    e.preventDefault(); closeFind(); return;
  }

  const editing = getEditingCell();

  if (editing) {
    // ── EDIT MODE ──
    if (e.key === '/' && (e.ctrlKey || e.metaKey)) {
      e.preventDefault();
      toggleComment(document.activeElement);
      return;
    }
    if (e.key === 'Escape') {
      e.preventDefault();
      exitEdit();
      selectCell(editing.id);
      return;
    }
    if (e.key === 'Enter' && e.ctrlKey) {
      e.preventDefault();
      editing.code = editing.el.querySelector('textarea').value;
      if (editing.type === 'code') runDAG([editing.id], true);
      return;
    }
    if (e.key === 'Enter' && e.shiftKey) {
      e.preventDefault();
      editing.code = editing.el.querySelector('textarea').value;
      if (editing.type === 'code') runDAG([editing.id], true);
      // advance — respect goto target if set
      const gotoIdx = window._lastGotoTarget;
      if (gotoIdx != null && gotoIdx >= 0 && gotoIdx < S.cells.length) {
        editCell(S.cells[gotoIdx].id);
      } else {
        const idx = S.cells.findIndex(c => c.id === editing.id);
        if (idx < S.cells.length - 1) {
          editCell(S.cells[idx + 1].id);
        } else {
          const newCell = addCellWithUndo('code', '', editing.id);
          selectCell(newCell.id);
          editCell(newCell.id);
        }
      }
      return;
    }
  } else {
    // ── COMMAND MODE ──
    // ignore if typing in any input field (title, find bar, etc.)
    if (document.activeElement && (document.activeElement.tagName === 'INPUT' || document.activeElement.id === 'docTitle')) return;

    // let browser shortcuts through (Ctrl+J downloads, etc.)
    if (e.ctrlKey || e.metaKey || e.altKey) return;

    if (e.key === 'ArrowUp' || e.key === 'k') {
      e.preventDefault();
      navigateCell(-1);
      return;
    }
    if (e.key === 'ArrowDown' || e.key === 'j') {
      e.preventDefault();
      navigateCell(1);
      return;
    }
    if (e.key === 'Enter') {
      e.preventDefault();
      if (S.selectedId !== null) editCell(S.selectedId);
      return;
    }
    if (e.key === 'a') {
      e.preventDefault();
      const newCell = addCellWithUndo('code', '', null, S.selectedId);
      selectCell(newCell.id);
      editCell(newCell.id);
      return;
    }
    if (e.key === 'b') {
      e.preventDefault();
      const newCell = addCellWithUndo('code', '', S.selectedId);
      selectCell(newCell.id);
      editCell(newCell.id);
      return;
    }
    if (e.key === 'd') {
      e.preventDefault();
      if (S.pendingD) {
        // dd — delete
        clearTimeout(S.pendingDTimer);
        S.pendingD = false;
        if (S.selectedId !== null) {
          const idx = S.cells.findIndex(c => c.id === S.selectedId);
          const nextId = idx < S.cells.length - 1 ? S.cells[idx + 1].id
                       : idx > 0 ? S.cells[idx - 1].id : null;
          deleteCellWithUndo(S.selectedId);
          if (nextId !== null) selectCell(nextId);
        }
      } else {
        S.pendingD = true;
        S.pendingDTimer = setTimeout(() => { S.pendingD = false; }, 600);
      }
      return;
    }
    if (e.key !== 'd' && S.pendingD) { S.pendingD = false; clearTimeout(S.pendingDTimer); }
    if (e.key === 'z') {
      e.preventDefault();
      undo();
      return;
    }
    if (e.key === 'c' && S.selectedId !== null) {
      e.preventDefault();
      const cell = S.cells.find(c => c.id === S.selectedId);
      if (cell) S.clipboard = { type: cell.type, code: cell.code };
      setMsg('copied cell', 'ok');
      return;
    }
    if (e.key === 'v' && S.clipboard) {
      e.preventDefault();
      const newCell = addCellWithUndo(S.clipboard.type, S.clipboard.code, S.selectedId);
      selectCell(newCell.id);
      if (S.clipboard.type === 'code' && S.cells.some(c => c.type === 'code')) runAll();
      return;
    }
    if (e.key === 'x' && S.selectedId !== null) {
      // cut = copy + delete
      e.preventDefault();
      const cell = S.cells.find(c => c.id === S.selectedId);
      if (cell) S.clipboard = { type: cell.type, code: cell.code };
      const idx = S.cells.findIndex(c => c.id === S.selectedId);
      const nextId = idx < S.cells.length - 1 ? S.cells[idx + 1].id
                   : idx > 0 ? S.cells[idx - 1].id : null;
      deleteCellWithUndo(S.selectedId);
      if (nextId !== null) selectCell(nextId);
      setMsg('cut cell', 'ok');
      return;
    }
    if (e.key === 'h' && S.selectedId !== null) {
      e.preventDefault();
      const cell = S.cells.find(c => c.id === S.selectedId);
      if (cell) cell.el.classList.toggle('collapsed');
      return;
    }
    if (e.key === 'l') {
      e.preventDefault();
      const on = getSettings().lineNumbers === 'on';
      applyLineNumbers(!on);
      setMsg(on ? 'line numbers off' : 'line numbers on', 'ok');
      return;
    }
    if (e.key === 'p') {
      e.preventDefault();
      togglePresent();
      return;
    }
    if (e.key === 'm' && S.selectedId !== null) {
      e.preventDefault();
      convertCell(S.selectedId, 'md');
      return;
    }
    if (e.key === 'y' && S.selectedId !== null) {
      e.preventDefault();
      convertCell(S.selectedId, 'code');
      return;
    }
    if (e.key === 's' && S.selectedId !== null) {
      e.preventDefault();
      convertCell(S.selectedId, 'css');
      return;
    }
    if (e.key === 't' && S.selectedId !== null) {
      e.preventDefault();
      convertCell(S.selectedId, 'html');
      return;
    }
  }

  // global: F1 help overlay
  if (e.key === 'F1') {
    e.preventDefault();
    $('#helpOverlay').classList.toggle('visible');
    return;
  }

  // close presentation mode on Escape
  if (e.key === 'Escape' && document.body.classList.contains('presenting')) {
    togglePresent();
    e.stopImmediatePropagation();
    return;
  }

  // close settings on Escape if visible
  if (e.key === 'Escape' && $('#settingsOverlay').classList.contains('visible')) {
    toggleSettings();
    e.stopImmediatePropagation();
    return;
  }

  // close help on Escape if visible
  if (e.key === 'Escape' && $('#helpOverlay').classList.contains('visible')) {
    $('#helpOverlay').classList.remove('visible');
    e.stopImmediatePropagation();
    return;
  }

  // global: Ctrl+S / Cmd+S
  if (e.key === 's' && (e.ctrlKey || e.metaKey)) {
    e.preventDefault();
    saveNotebook();
  }
});

// click to dismiss help
$('#helpOverlay').addEventListener('click', (e) => {
  if (e.target === $('#helpOverlay')) $('#helpOverlay').classList.remove('visible');
});

// click to select + close trays
document.addEventListener('click', (e) => {
  // close action trays if clicking outside their wrapper (wrapper = parent div with tray + button)
  const addTray = document.querySelector('.action-add-tray');
  const moreTray = document.querySelector('.action-more-tray');
  if (addTray && addTray.classList.contains('open') && !addTray.parentElement.contains(e.target)) {
    addTray.classList.remove('open');
  }
  if (moreTray && moreTray.classList.contains('open') && !moreTray.parentElement.contains(e.target)) {
    moreTray.classList.remove('open');
  }
  // close cell type pickers if clicking outside
  if (!e.target.closest('.cell-type-picker') && !e.target.closest('.cell-type')) {
    document.querySelectorAll('.cell-type-picker.open').forEach(el => el.classList.remove('open'));
  }
  // close cell insert pickers if clicking outside
  if (!e.target.closest('.cell-insert-picker')) {
    document.querySelectorAll('.cell-insert-picker').forEach(el => el.remove());
  }
  // close toolbar overflow menu if clicking outside
  const tbOverflow = document.querySelector('.toolbar-overflow');
  if (tbOverflow && tbOverflow.classList.contains('open') && !tbOverflow.contains(e.target)) {
    tbOverflow.classList.remove('open');
  }
  // close save tray if clicking outside
  const saveTray = document.getElementById('saveTray');
  if (saveTray && saveTray.classList.contains('open') && !saveTray.parentElement.contains(e.target)) {
    saveTray.classList.remove('open');
  }

  const cellEl = e.target.closest('.cell');
  if (cellEl) {
    const id = parseInt(cellEl.dataset.id);
    selectCell(id);
  }
});

// late import to avoid circular dependency at module load time

// -- goto.js --

// ── GOTO ── @optional

function parseGoto(code) {
  const m = code.match(/^\s*\/\/\s*%goto\b\s*(.*)/m);
  if (!m) return null;
  return m[1].trim() || '';
}

const MAX_VISITS = 1000;
let visits = {};

window._dagStart = function() {
  visits = {};
  window._lastGotoTarget = null;
};

window._beforeExec = function(cell) {
  const target = parseGoto(cell.code);
  if (target !== null) {
    S.scope.__goto = target;
    cell.defines.add('__goto');
  } else {
    delete S.scope.__goto;
  }
};

window._afterExec = function(cell, index) {
  const gotoTarget = S.scope.__goto;
  delete S.scope.__goto;
  window._lastGotoTarget = null;

  if (!gotoTarget) return -1;

  // resolve by cellName
  const targetIdx = S.cells.findIndex(c => parseCellName(c.code) === gotoTarget);
  if (targetIdx < 0) {
    const out = cell.el.querySelector('.cell-output');
    if (out) {
      out.appendChild(document.createTextNode('\ngoto: cell \u201c' + gotoTarget + '\u201d not found'));
      out.classList.add('error');
    }
    return -1;
  }

  // loop protection
  const key = index + ':' + targetIdx;
  visits[key] = (visits[key] || 0) + 1;
  if (visits[key] > MAX_VISITS) {
    const out = cell.el.querySelector('.cell-output');
    if (out) {
      out.appendChild(document.createTextNode('\ngoto: loop limit reached (' + MAX_VISITS + ' iterations)'));
      out.classList.add('error');
    }
    return -1;
  }

  window._lastGotoTarget = targetIdx;
  return targetIdx;
};

// -- size-compare.js --

// ── SIZE COMPARISON ── @optional

const SIZE_MEDIA = [
  [4096, 'an Atari 2600 cartridge'],
  [49152, 'a ZX Spectrum tape'],
  [73728, 'Apollo AGC rope memory'],
  [81920, 'an 8\u2033 floppy (SS/SD)'],
  [262144, 'an NES cartridge'],
  [368640, 'a 5.25\u2033 floppy (DS/DD)'],
  [737280, 'a 3.5\u2033 floppy (DS/DD)'],
  [1228800, 'a 5.25\u2033 floppy (DS/HD)'],
  [1474560, 'a 3.5\u2033 floppy (DS/HD)'],
];

function sizeCompare(bytes) {
  if (!window._sizeCompare) return '';
  for (const [size, name] of SIZE_MEDIA) {
    if (bytes <= size) return 'fits on ' + name;
  }
  const n = Math.ceil(bytes / 1474560);
  return n + '\u00d7 3.5\u2033 floppies';
}

function applySizeCompare(val) {
  const on = val === true || val === 'true' || val === 'on';
  window._sizeCompare = on;
  const el = $('#setSizeCompare');
  if (el) el.value = on ? 'on' : 'off';
  updateStatus();
}

function applySizeCompareRef(val) {
  window._sizeCompareRef = val === 'content' ? 'content' : 'total';
  const el = $('#setSizeCompareRef');
  if (el) el.value = window._sizeCompareRef;
  updateStatus();
}

// inject settings rows before modules section
(function() {
  const panel = $('#settingsPanel');
  if (!panel) return;
  const headings = panel.querySelectorAll('h2');
  const modulesH2 = headings[headings.length - 1];
  if (!modulesH2) return;

  const h2 = document.createElement('h2');
  h2.textContent = 'status bar';
  modulesH2.before(h2);

  const refRow = document.createElement('div');
  refRow.className = 'settings-row';
  refRow.innerHTML = '<label>size reference</label>' +
    '<select id="setSizeCompareRef" onchange="applySizeCompareRef(this.value)">' +
    '<option value="total" selected>total file</option>' +
    '<option value="content">content only</option></select>';
  modulesH2.before(refRow);

  const row = document.createElement('div');
  row.className = 'settings-row';
  row.innerHTML = '<label>size comparison</label>' +
    '<select id="setSizeCompare" onchange="applySizeCompare(this.value)">' +
    '<option value="off">off</option><option value="on" selected>on</option></select>';
  modulesH2.before(row);

  window._sizeCompare = true;
  window._sizeCompareRef = 'total';
})();

// -- globals.js --

// ── GLOBAL BINDINGS ──
// This module wires exported functions to window.* for use by onclick/onchange
// handlers in template HTML and dynamically generated markup.
// Modules stay pure (no side effects, no window assignments).











// state
window.$ = $;
window.S = S;

// editor
window.toggleAutorun = toggleAutorun;

// settings
window.toggleSettings = toggleSettings;
window.togglePresent = togglePresent;
window.applyTheme = applyTheme;
window.applyFontSize = applyFontSize;
window.applyWidth = applyWidth;
window.applyLineNumbers = applyLineNumbers;
window.applyHeader = applyHeader;
window.applyExecMode = applyExecMode;
window.applyRunOnLoad = applyRunOnLoad;
window.applyShowToggle = applyShowToggle;
window.applyGlobalExecMode = applyGlobalExecMode;
window.applyGlobalRunOnLoad = applyGlobalRunOnLoad;

// update
window.toggleUpdate = toggleUpdate;
window.checkForUpdate = checkForUpdate;
window.applyOnlineUpdate = applyOnlineUpdate;
window.proceedUpdate = proceedUpdate;
window.cancelUpdate = cancelUpdate;
window.updateFromFile = updateFromFile;

// save
window.saveNotebook = saveNotebook;
window.savePackedNotebook = savePackedNotebook;
window.setSaveMode = setSaveMode;
window.toggleSaveTray = toggleSaveTray;
window.exportAsTxt = exportAsTxt;

// exec
window.runAll = runAll;

// ui
window.insertAt = insertAt;

// find
window.openFind = openFind;
window.closeFind = closeFind;

// stdlib
window.__auditable_registerProvider = registerProvider;

// keyboard / toolbar
window.addCellWithUndo = addCellWithUndo;
window.deleteCellWithUndo = deleteCellWithUndo;
window.runSelectedCell = runSelectedCell;
window.toggleToolbarMenu = toggleToolbarMenu;
window.toggleAddTray = toggleAddTray;
window.toggleMoreTray = toggleMoreTray;
window.showInsertPicker = showInsertPicker;
window.toggleTypePicker = toggleTypePicker;
window.collapseAll = collapseAll;
window.expandAll = expandAll;
window.newNotebook = newNotebook;

// -- init.js --

// ── INIT ──

(function init() {
  // detect packed format (meta tag injected by loader)
  const packedMeta = document.querySelector('meta[name="auditable-packed"]');
  if (packedMeta) {
    packedMeta.remove();
    setBadge('packed', 'packed', 'toolbar-badge toolbar-badge-packed');
    setSaveMode('packed');
  }

  if (!loadFromEmbed()) {
    addCell('md', '');
    addCell('code', '');
  }
  S.initialized = true;
})();

// ── AF BRIDGE ──
// When running inside AF shell (iframe), establish postMessage communication.
// No-op when running standalone (window.parent === window).
//
// Message protocol (notebook ↔ AF shell):
//   af:ready          → sent on init with { title }
//   af:serialize      ← received to trigger saveNotebook()
//   af:saved          ← received after save (shows "saved" status)
//   af:setTitle       ← received to update docTitle input
//   af:resize         ← received when iframe becomes visible (recalc textareas)
//   af:titleChanged   → sent when user edits the title
//   af:fileRequest    → sent to request file picker { id, accept }
//   af:fileResult     ← received with picked file { id, file }
//   af:download       → sent to request download { data, filename, mimeType }
//   af:dirty          → sent when notebook has unsaved changes

(function afBridge() {
  if (window.parent === window) return;
  window.__AF_BRIDGE__ = true;

  // register AF-specific providers for file/download
  registerProvider('file', (accept) => {
    return new Promise((resolve) => {
      const id = 'af_file_' + Date.now();
      function handler(e) {
        if (e.data?.type === 'af:fileResult' && e.data.payload?.id === id) {
          window.removeEventListener('message', handler);
          resolve(e.data.payload.file);
        }
      }
      window.addEventListener('message', handler);
      window.parent.postMessage({ type: 'af:fileRequest', payload: { id, accept } }, '*');
    });
  });

  registerProvider('download', (data, filename, mimeType) => {
    const str = typeof data === 'string' ? data : JSON.stringify(data, null, 2);
    const mime = mimeType || (typeof data === 'string' ? 'text/plain' : 'application/json');
    window.parent.postMessage({
      type: 'af:download',
      payload: { data: str, filename, mimeType: mime }
    }, '*');
  });

  const title = document.getElementById('docTitle')?.value || 'untitled';
  window.parent.postMessage({ type: 'af:ready', payload: { title } }, '*');

  window.addEventListener('message', (e) => {
    const msg = e.data;
    if (!msg?.type) return;
    if (msg.type === 'af:serialize') saveNotebook();
    else if (msg.type === 'af:saved') setMsg('saved', 'ok');
    else if (msg.type === 'af:setTitle') {
      const input = document.getElementById('docTitle');
      if (input && msg.payload?.title) input.value = msg.payload.title;
    } else if (msg.type === 'af:resize') {
      // recalculate textarea heights after becoming visible
      document.querySelectorAll('textarea').forEach(ta => {
        ta.style.height = 'auto';
        ta.style.height = ta.scrollHeight + 'px';
        const hl = ta.parentElement?.querySelector('.highlight-layer');
        if (hl) hl.style.height = ta.style.height;
      });
    }
  });

  document.getElementById('docTitle')?.addEventListener('input', () => {
    window.parent.postMessage({
      type: 'af:titleChanged',
      payload: { title: document.getElementById('docTitle').value }
    }, '*');
  });
})();
</script>
</body>
<!-- good luck out there -->
</html>
