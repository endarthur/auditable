<!DOCTYPE html>
<!-- auditable — a reactive computational notebook in a single HTML file -->
<!-- https://github.com/endarthur/auditable — MIT license -->
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Auditable — atra — language tour</title>
<style>
:root {
  --bg: #0a0a0a;
  --bg1: #111;
  --bg2: #1a1a1a;
  --border: #222;
  --border-hi: #333;
  --fg: #aaa;
  --fg-dim: #555;
  --fg-bright: #ccc;
  --accent: #c89b3c;
  --accent-dim: #8a6c2a;
  --err: #a33;
  --ok: #3a7;
  --mono: 'Courier New', Courier, monospace;
  --editor-font-size: 13px;
}

* { margin: 0; padding: 0; box-sizing: border-box; }

/* scrollbar */
::-webkit-scrollbar { width: 6px; height: 6px; }
::-webkit-scrollbar-track { background: var(--bg); }
::-webkit-scrollbar-thumb { background: var(--border-hi); border-radius: 0; }
::-webkit-scrollbar-thumb:hover { background: var(--fg-dim); }
textarea::-webkit-scrollbar-thumb { background: var(--border); }
@supports (scrollbar-color: auto) {
  * { scrollbar-color: var(--border-hi) var(--bg); scrollbar-width: thin; }
}

html, body {
  background: var(--bg);
  color: var(--fg);
  font-family: var(--mono);
  font-size: 13px;
  line-height: 1.5;
  min-height: 100vh;
}

/* ── TOOLBAR ── */
.toolbar {
  position: sticky;
  top: 0;
  z-index: 100;
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 6px 12px;
  background: var(--bg);
  border-bottom: 1px solid var(--border);
}

.toolbar-title {
  font-size: 11px;
  letter-spacing: 3px;
  text-transform: uppercase;
  color: var(--accent);
  opacity: 0.8;
  user-select: none;
}

.toolbar-sep {
  width: 1px;
  height: 16px;
  background: var(--border);
  margin: 0 4px;
}

.toolbar-filename {
  font-size: 12px;
  color: var(--fg-dim);
  flex: 1;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.toolbar-filename input {
  background: none;
  border: none;
  border-bottom: 1px solid transparent;
  color: var(--fg);
  font-family: var(--mono);
  font-size: 12px;
  outline: none;
  width: 200px;
}
.toolbar-filename input:focus {
  border-bottom-color: var(--accent-dim);
}

button {
  background: var(--bg2);
  border: 1px solid var(--border);
  color: var(--fg-dim);
  font-family: var(--mono);
  font-size: 10px;
  letter-spacing: 1px;
  text-transform: uppercase;
  padding: 4px 10px;
  cursor: pointer;
  transition: border-color 0.15s, color 0.15s;
}
button:hover {
  border-color: var(--border-hi);
  color: var(--fg);
}
button.accent {
  border-color: var(--accent-dim);
  color: var(--accent);
}
button.accent:hover {
  border-color: var(--accent);
}

/* ── TOOLBAR BADGES ── */
.toolbar-badges {
  display: inline-flex;
  gap: 4px;
  margin-left: 6px;
  align-items: center;
}
.toolbar-badge {
  font-size: 9px;
  letter-spacing: 0.5px;
  padding: 1px 4px;
  border-radius: 2px;
  user-select: none;
  opacity: 0.85;
}
.toolbar-badge-signed {
  color: var(--ok);
  border: 1px solid color-mix(in srgb, var(--ok) 40%, transparent);
}
.toolbar-badge-packed {
  color: var(--fg-dim);
  border: 1px solid var(--border);
}

/* ── SPLIT SAVE BUTTON ── */
.save-split {
  display: inline-flex;
  position: relative;
}
.save-split button:first-child {
  border-right: none;
  border-radius: 3px 0 0 3px;
}
.save-caret {
  border-radius: 0 3px 3px 0 !important;
  padding: 4px 4px !important;
  font-size: 10px;
}
.save-tray {
  display: none;
  position: absolute;
  right: 0;
  top: 100%;
  margin-top: 4px;
  background: var(--bg);
  border: 1px solid var(--border);
  z-index: 100;
  min-width: 120px;
}
.save-tray.open { display: flex; flex-direction: column; }
.save-tray button {
  border: none;
  border-bottom: 1px solid var(--border);
  text-align: left;
  padding: 6px 10px;
  white-space: nowrap;
  font-size: 12px;
}
.save-tray button:last-child { border-bottom: none; }
.save-tray button:hover { background: var(--bg-hi); }

/* ── TRANSPORT CONTROLS ── */
.transport {
  display: inline-flex;
  border: 1px solid var(--border);
}
.transport button {
  border: none;
  border-right: 1px solid var(--border);
  padding: 4px 8px;
}
.transport button:last-child { border-right: none; }
.transport button.autorun-on {
  background: #33aa77;
  color: #111;
}
.transport button.autorun-off {
  background: #dd4444;
  color: #111;
}

.toolbar-right {
  margin-left: auto;
  display: flex;
  align-items: center;
  gap: 8px;
}

/* ── TOOLBAR OVERFLOW MENU ── */
.toolbar-overflow {
  position: relative;
  display: inline-block;
}
.toolbar-overflow-tray {
  display: none;
  position: absolute;
  top: 100%;
  right: 0;
  background: var(--bg1);
  border: 1px solid var(--border);
  z-index: 200;
  flex-direction: column;
  min-width: 140px;
}
.toolbar-overflow-tray button {
  border: none;
  border-bottom: 1px solid var(--border);
  text-align: left;
  padding: 8px 12px;
  background: var(--bg1);
  white-space: nowrap;
}
.toolbar-overflow-tray button:last-child { border-bottom: none; }
.toolbar-overflow-tray button:hover { background: var(--bg2); color: var(--fg-bright); }
.toolbar-overflow.open .toolbar-overflow-tray { display: flex; }

/* ── BOTTOM ACTION BAR ── */
.action-bar { display: none; }

/* ── ACTION BAR TRAYS ── */
.action-add-tray,
.action-more-tray {
  display: none;
  position: absolute;
  bottom: 100%;
  background: var(--bg1);
  border: 1px solid var(--border);
  flex-direction: column;
  z-index: 200;
}
.action-add-tray { left: 0; min-width: 120px; }
.action-more-tray { right: 0; min-width: 120px; }
.action-add-tray.open,
.action-more-tray.open { display: flex; }
.action-add-tray button,
.action-more-tray button {
  min-height: 48px;
  border: none;
  border-bottom: 1px solid var(--border);
  text-align: left;
  padding: 8px 16px;
  background: var(--bg1);
  color: var(--fg);
  font-family: var(--mono);
  font-size: 12px;
  letter-spacing: 1px;
  text-transform: uppercase;
}
.action-add-tray button:last-child,
.action-more-tray button:last-child { border-bottom: none; }
.action-add-tray button:hover,
.action-more-tray button:hover { background: var(--bg2); color: var(--fg-bright); }
.action-more-tray button.active-mode { color: var(--accent); }

/* ── CELL INSERT / CONVERT BUTTONS (touch only) ── */
.cell-insert { display: none; }
.cell-convert { display: none; }

/* ── CELL TYPE PICKER ── */
.cell-type-picker {
  display: none;
  gap: 2px;
  padding: 2px 8px 4px;
}
.cell-type-picker.open { display: flex; }
.cell-type-picker button {
  font-size: 9px;
  padding: 2px 8px;
  background: var(--bg2);
  border: 1px solid var(--border);
  color: var(--fg-dim);
  font-family: var(--mono);
  letter-spacing: 1px;
  text-transform: uppercase;
}
.cell-type-picker button:hover {
  border-color: var(--accent-dim);
  color: var(--accent);
}

/* ── CELL INSERT PICKER ── */
.cell-insert-picker {
  display: none;
  gap: 2px;
  position: absolute;
  background: var(--bg1);
  border: 1px solid var(--border);
  padding: 4px;
  z-index: 200;
}
.cell-insert-picker.open { display: flex; }
.cell-insert-picker button {
  font-size: 9px;
  padding: 4px 8px;
  background: var(--bg2);
  border: 1px solid var(--border);
  color: var(--fg-dim);
  font-family: var(--mono);
  letter-spacing: 1px;
  text-transform: uppercase;
  min-height: 36px;
}
.cell-insert-picker button:hover {
  border-color: var(--accent-dim);
  color: var(--accent);
}

/* ── TOOLBAR STATUS (mobile cell count) ── */
.toolbar-status { display: none; }

/* ── NOTEBOOK ── */
.notebook {
  max-width: 860px;
  margin: 0 auto;
  padding: 16px 12px 120px;
}

/* ── CELL ── */
.cell {
  position: relative;
  margin: 6px 0;
  border-left: 2px solid transparent;
  transition: border-color 0.15s;
}
.cell:hover {
  border-left-color: var(--border-hi);
}
.cell.selected {
  border-left-color: var(--accent);
}
.cell.selected .cell-header {
  opacity: 1;
}
.cell.manual .cell-type::after {
  content: ' \00b7 manual';
  color: var(--accent-dim);
}
.cell.stale {
  border-left-color: var(--accent-dim);
}
.cell.error {
  border-left-color: var(--err);
}
.cell.fresh {
  border-left-color: var(--ok);
  transition: border-color 0.5s;
}

/* cell header — type label + controls */
.cell-header {
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 2px 8px;
  opacity: 0;
  transition: opacity 0.15s;
  user-select: none;
}
.cell:hover .cell-header,
.cell:focus-within .cell-header {
  opacity: 1;
}

.cell.collapsed .cell-code,
.cell.collapsed .cell-md-edit,
.cell.collapsed .cell-css-edit,
.cell.collapsed .cell-html-edit {
  display: none !important;
}
.cell.collapsed .cell-type::before {
  content: '\25b8 ';
}
.cell:not(.collapsed) .cell-type::before {
  content: '\25be ';
}
.cell-type {
  cursor: pointer;
  user-select: none;
  font-size: 9px;
  letter-spacing: 2px;
  text-transform: uppercase;
  color: var(--fg-dim);
}
.cell[data-type="code"] .cell-type { color: #7aabcf; }
.cell[data-type="css"]  .cell-type { color: #d4955a; }
.cell[data-type="html"] .cell-type { color: #6dbfb8; }
.cell[data-type="md"]   .cell-type { color: var(--fg-dim); }

.cell-btn {
  background: none;
  border: none;
  color: var(--fg-dim);
  font-family: var(--mono);
  font-size: 10px;
  padding: 0 4px;
  cursor: pointer;
}
.cell-btn:hover { color: var(--fg); }
.cell-btn.del:hover { color: var(--err); }

/* ── CODE CELL ── */
.cell-code {
  position: relative;
}

.editor-wrap {
  --gutter: 36px;
  position: relative;
  overflow: hidden;
}

.line-numbers {
  position: absolute;
  top: 0; left: 0; bottom: 0;
  width: var(--gutter);
  padding: 8px 4px 8px 0;
  font-family: var(--mono);
  font-size: var(--editor-font-size);
  line-height: 1.5;
  text-align: right;
  color: var(--fg-dim);
  background: var(--bg1);
  border-right: 1px solid var(--border);
  border-top: 1px solid var(--border);
  border-bottom: 1px solid var(--border);
  border-left: 1px solid var(--border);
  overflow: hidden;
  z-index: 3;
  pointer-events: none;
  white-space: pre;
  box-sizing: border-box;
}

:root.hide-line-numbers .line-numbers { display: none; }
:root.hide-line-numbers .editor-wrap { --gutter: 0px; }

.cell-code textarea {
  display: block;
  width: 100%;
  background: transparent;
  border: 1px solid var(--border);
  color: var(--fg-bright);
  caret-color: var(--fg-bright);
  font-family: var(--mono);
  font-size: var(--editor-font-size);
  line-height: 1.5;
  padding: 8px 10px 8px calc(var(--gutter) + 10px);
  resize: vertical;
  min-height: 38px;
  outline: none;
  tab-size: 2;
  white-space: pre;
  overflow-x: auto;
  position: relative;
  z-index: 2;
  -webkit-text-fill-color: transparent;
}
.cell-code textarea::selection {
  -webkit-text-fill-color: var(--fg-bright);
  background: rgba(200,155,60,0.25);
}
.cell-code textarea:focus + .highlight-layer {
  border-color: var(--border-hi);
}
.cell-code textarea:focus ~ .line-numbers {
  border-color: var(--border-hi);
}

.highlight-layer {
  position: absolute;
  top: 0; left: 0; right: 0; bottom: 0;
  background: var(--bg1);
  border: 1px solid var(--border);
  padding: 8px 10px 8px calc(var(--gutter) + 10px);
  font-family: var(--mono);
  font-size: var(--editor-font-size);
  line-height: 1.5;
  tab-size: 2;
  white-space: pre;
  overflow: hidden;
  z-index: 1;
  pointer-events: none;
  color: var(--fg-bright);
}

/* syntax tokens */
.hl-kw { color: #7a9ec7; }
.hl-str { color: var(--accent); }
.hl-num { color: #8cb878; }
.hl-cmt { color: #555; font-style: italic; }
.hl-fn { color: #c4a6d0; }
.hl-const { color: #d09870; }
.hl-op { color: #888; }
.hl-punc { color: #666; }

/* CSS syntax tokens */
.hl-atrule { color: #7aabcf; }
.hl-prop { color: #7aabcf; }
.hl-sel { color: #d4955a; }
.hl-color { color: var(--accent); }
.hl-important { color: #d4555a; font-weight: bold; }

/* HTML syntax tokens */
.hl-tag { color: #6dbfb8; }
.hl-attr { color: #7aabcf; }
.hl-expr { color: var(--accent); }

.hl-swatch {
  display: inline-block;
  width: 10px;
  height: 10px;
  border: 1px solid var(--border-hi);
  vertical-align: middle;
  margin-right: 2px;
  cursor: pointer;
  pointer-events: auto;
}

.cell-output {
  padding: 4px 10px;
  min-height: 0;
  font-size: 12px;
  color: var(--fg);
  white-space: pre-wrap;
  word-break: break-all;
}
.cell-output:empty {
  display: none;
}
.cell-output.error {
  color: var(--err);
}

.cell-output canvas {
  max-width: 100%;
  display: block;
  margin: 4px 0;
}

.cell-output table {
  border-collapse: collapse;
  font-size: 11px;
  margin: 4px 0;
}
.cell-output table th,
.cell-output table td {
  border: 1px solid var(--border);
  padding: 2px 8px;
}
.cell-output table th {
  color: var(--accent);
  font-weight: normal;
  text-transform: uppercase;
  font-size: 9px;
  letter-spacing: 1px;
}

/* ── CSS CELL ── */
.cell-css-view {
  padding: 6px 10px;
  color: var(--fg-dim);
  cursor: text;
  min-height: 24px;
  font-size: 11px;
  font-style: italic;
}
.cell-css-view:empty::before {
  content: '(empty stylesheet)';
}

.cell-css-edit textarea {
  display: block;
  width: 100%;
  background: transparent;
  border: 1px solid var(--border);
  color: var(--fg-bright);
  caret-color: var(--fg-bright);
  font-family: var(--mono);
  font-size: var(--editor-font-size);
  line-height: 1.5;
  padding: 8px 10px 8px calc(var(--gutter) + 10px);
  resize: vertical;
  min-height: 38px;
  outline: none;
  tab-size: 2;
  white-space: pre;
  overflow-x: auto;
  position: relative;
  z-index: 2;
  -webkit-text-fill-color: transparent;
}
.cell-css-edit textarea::selection {
  -webkit-text-fill-color: var(--fg-bright);
  background: rgba(200,155,60,0.25);
}
.cell-css-edit textarea:focus + .highlight-layer {
  border-color: var(--border-hi);
}
.cell-css-edit textarea:focus ~ .line-numbers {
  border-color: var(--border-hi);
}

/* ── HTML CELL ── */
.cell-html-view {
  padding: 6px 10px;
  color: var(--fg);
  cursor: text;
  min-height: 24px;
}
.cell-html-view:empty::before {
  content: '(empty html template)';
  color: var(--fg-dim);
  font-style: italic;
  font-size: 11px;
}
.cell-html-edit textarea {
  display: block;
  width: 100%;
  background: transparent;
  border: 1px solid var(--border);
  color: var(--fg-bright);
  caret-color: var(--fg-bright);
  font-family: var(--mono);
  font-size: var(--editor-font-size);
  line-height: 1.5;
  padding: 8px 10px 8px calc(var(--gutter) + 10px);
  resize: vertical;
  min-height: 38px;
  outline: none;
  tab-size: 2;
  white-space: pre;
  overflow-x: auto;
  position: relative;
  z-index: 2;
  -webkit-text-fill-color: transparent;
}
.cell-html-edit textarea::selection {
  -webkit-text-fill-color: var(--fg-bright);
  background: rgba(200,155,60,0.25);
}
.cell-html-edit textarea:focus + .highlight-layer {
  border-color: var(--border-hi);
}
.cell-html-edit textarea:focus ~ .line-numbers {
  border-color: var(--border-hi);
}

/* ── MARKDOWN CELL ── */
.cell-md-view {
  padding: 6px 10px;
  color: var(--fg);
  cursor: text;
  min-height: 24px;
}
.cell-md-view:empty::before {
  content: '(empty markdown cell)';
  color: var(--fg-dim);
  font-style: italic;
  font-size: 11px;
}
.cell-md-view h1, .cell-md-view h2, .cell-md-view h3 {
  color: var(--fg-bright);
  font-weight: normal;
  margin: 4px 0;
}
.cell-md-view h1 { font-size: 18px; letter-spacing: 2px; }
.cell-md-view h2 { font-size: 15px; letter-spacing: 1px; color: var(--accent); }
.cell-md-view h3 { font-size: 13px; }
.cell-md-view p { margin: 4px 0; }
.cell-md-view code {
  background: var(--bg2);
  padding: 1px 4px;
  font-size: 12px;
}
.cell-md-view strong { color: var(--fg-bright); }
.cell-md-view em { font-style: italic; }
.cell-md-view a { color: var(--accent); }
.cell-md-view table {
  border-collapse: collapse;
  font-size: 11px;
  margin: 4px 0;
}
.cell-md-view table th,
.cell-md-view table td {
  border: 1px solid var(--border);
  padding: 2px 8px;
}
.cell-md-view table th {
  color: var(--accent);
  font-weight: normal;
  text-transform: uppercase;
  font-size: 9px;
  letter-spacing: 1px;
}

.cell-md-edit textarea {
  display: block;
  width: 100%;
  background: var(--bg1);
  border: 1px solid var(--border);
  color: var(--fg-bright);
  font-family: var(--mono);
  font-size: var(--editor-font-size);
  line-height: 1.5;
  padding: 8px 10px;
  resize: vertical;
  min-height: 38px;
  outline: none;
}

/* ── PRESENTATION MODE ── */
body.presenting .toolbar { display: none; }
body.presenting .cell-header { display: none; }
body.presenting .cell-code { display: none; }
body.presenting .cell-md-edit { display: none !important; }
body.presenting .cell-css-edit { display: none; }
body.presenting .cell-css-view { display: none; }
body.presenting .cell-html-edit { display: none !important; }
body.presenting .cell { border-left: none; margin: 0; }
body.presenting .cell:hover { border-left: none; }
body.presenting .insert-bar { display: none; }
body.presenting .notebook { max-width: 900px; padding-top: 40px; }
body.presenting .statusbar { display: none; }
body.presenting .present-hidden { display: none; }
body.presenting .present-exit {
  display: block;
  position: fixed;
  top: 12px;
  right: 12px;
  z-index: 200;
}
.present-exit { display: none; }

/* ── INSERT BAR (between cells) ── */
.insert-bar {
  height: 16px;
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  margin: -6px 0;
}
.insert-bar::before {
  content: '';
  position: absolute;
  left: 20px;
  right: 20px;
  top: 50%;
  height: 1px;
  background: var(--border);
  opacity: 0;
  transition: opacity 0.15s;
}
.insert-bar:hover::before { opacity: 1; }
.insert-bar .insert-btns {
  display: flex;
  gap: 4px;
  opacity: 0;
  transition: opacity 0.15s;
  position: relative;
  z-index: 10;
}
.insert-bar:hover .insert-btns { opacity: 1; }
.insert-bar .insert-btns button {
  font-size: 9px;
  padding: 1px 8px;
  background: var(--bg);
  border: 1px solid var(--border);
  color: var(--fg-dim);
}
.insert-bar .insert-btns button:hover {
  border-color: var(--accent-dim);
  color: var(--accent);
}

/* ── ADD CELL BAR ── */
.add-bar {
  display: flex;
  justify-content: center;
  gap: 8px;
  padding: 6px 0;
  opacity: 0;
  transition: opacity 0.15s;
}
.notebook:hover .add-bar,
.add-bar.visible {
  opacity: 0.5;
}
.add-bar:hover {
  opacity: 1 !important;
}

/* ── WIDGET CLASSES ── */
.cell-widget {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 2px 0;
  font-size: 12px;
  color: var(--fg-dim);
}
.cell-widget-label {
  min-width: 80px;
  font-size: 10px;
  letter-spacing: 1px;
  text-transform: uppercase;
  color: var(--fg-dim);
}
.cell-widget input[type="range"] {
  flex: 1;
  accent-color: var(--accent);
  max-width: 200px;
}
.cell-widget select {
  background: var(--bg2);
  border: 1px solid var(--border);
  color: var(--fg-bright);
  font-family: var(--mono);
  font-size: 12px;
  padding: 2px 4px;
}
.cell-widget input[type="checkbox"] {
  accent-color: var(--accent);
}
.cell-widget input[type="text"] {
  background: var(--bg2);
  border: 1px solid var(--border);
  color: var(--fg-bright);
  font-family: var(--mono);
  font-size: 12px;
  padding: 2px 6px;
  flex: 1;
  max-width: 200px;
}
.cell-widget-val {
  min-width: 40px;
  text-align: right;
  color: var(--fg-bright);
  font-size: 12px;
}

/* ── STATUS BAR ── */
.statusbar {
  position: fixed;
  bottom: 0;
  left: 0;
  right: 0;
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 4px 12px;
  background: var(--bg);
  border-top: 1px solid var(--border);
  font-size: 10px;
  color: var(--fg-dim);
  letter-spacing: 1px;
  z-index: 100;
}
.statusbar .status-size { color: var(--fg-dim); }
.statusbar .status-cells { color: var(--fg-dim); }
.statusbar .status-msg { flex: 1; text-align: right; }
.statusbar .status-msg.ok { color: var(--ok); }
.statusbar .status-msg.warn { color: var(--accent); }
.statusbar .status-msg.err { color: var(--err); }
.statusbar .status-attr { margin-left: auto; display: flex; align-items: center; gap: 6px; }
.statusbar .status-attr a {
  color: var(--fg-dim);
  text-decoration: none;
  transition: color 0.2s;
}
.statusbar .status-attr a:hover { color: var(--accent); }
.statusbar .status-attr svg { vertical-align: middle; }

/* ── EMPTY STATE ── */
.empty-state {
  text-align: center;
  padding: 80px 20px;
  color: var(--fg-dim);
}
.empty-state .logo {
  font-size: 11px;
  letter-spacing: 4px;
  text-transform: uppercase;
  color: var(--accent);
  margin-bottom: 16px;
}
.empty-state .tagline {
  font-size: 11px;
  margin-bottom: 24px;
}

.help-overlay {
  display: none;
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.85);
  z-index: 1000;
  overflow-y: auto;
  padding: 40px;
}
.help-overlay.visible { display: flex; justify-content: center; }
.help-content {
  position: relative;
  max-width: 600px;
  width: 100%;
  color: var(--fg);
  font-family: var(--mono);
  font-size: 13px;
  line-height: 1.8;
}
.help-content h2 {
  color: var(--accent);
  font-size: 14px;
  letter-spacing: 2px;
  text-transform: uppercase;
  margin: 24px 0 8px 0;
  border-bottom: 1px solid var(--border);
  padding-bottom: 4px;
}
.help-content h2:first-child { margin-top: 0; }
.help-row {
  display: flex;
  justify-content: space-between;
  padding: 2px 0;
}
.help-key {
  background: var(--bg2);
  border: 1px solid var(--border);
  border-radius: 3px;
  padding: 0 6px;
  font-size: 11px;
  color: var(--fg-bright);
  min-width: 80px;
  text-align: center;
  display: inline-block;
}
.help-desc { color: var(--fg); }
.help-close {
  color: var(--accent-dim);
  font-size: 11px;
  text-align: center;
  margin-top: 24px;
  letter-spacing: 1px;
}
.help-close-btn {
  position: absolute;
  top: 0;
  right: 0;
  background: none;
  border: 1px solid var(--border);
  color: var(--fg-dim);
  font-size: 20px;
  width: 44px;
  height: 44px;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 0;
  cursor: pointer;
  text-transform: none;
  letter-spacing: 0;
}
.help-close-btn:hover {
  border-color: var(--err);
  color: var(--err);
}

/* ── SETTINGS PANEL ── */
.settings-overlay {
  display: none;
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.5);
  z-index: 1000;
}
.settings-overlay.visible { display: block; }
.settings-panel {
  display: none;
  position: fixed;
  top: 0;
  right: 0;
  bottom: 0;
  width: 280px;
  max-width: 90vw;
  background: var(--bg1);
  border-left: 1px solid var(--border);
  padding: 20px;
  overflow-y: auto;
  z-index: 1001;
  font-family: var(--mono);
  font-size: 12px;
  color: var(--fg);
}
.settings-close {
  position: absolute;
  top: 12px;
  right: 12px;
  background: none;
  border: 1px solid var(--border);
  color: var(--fg-dim);
  font-size: 18px;
  width: 32px;
  height: 32px;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 0;
  cursor: pointer;
  text-transform: none;
  letter-spacing: 0;
}
.settings-close:hover {
  border-color: var(--err);
  color: var(--err);
}

.settings-panel h2 {
  color: var(--accent);
  font-size: 11px;
  letter-spacing: 2px;
  text-transform: uppercase;
  margin: 20px 0 10px 0;
}
.settings-panel h2:first-child { margin-top: 0; }
.settings-row {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 6px 0;
}
.settings-row label { color: var(--fg-dim); font-size: 11px; }
.settings-row select,
.settings-row input[type="range"] {
  background: var(--bg2);
  border: 1px solid var(--border);
  color: var(--fg-bright);
  font-family: var(--mono);
  font-size: 11px;
  padding: 2px 4px;
}
.settings-row input[type="range"] {
  accent-color: var(--accent);
  width: 100px;
}
.settings-val {
  min-width: 30px;
  text-align: right;
  color: var(--fg-bright);
  font-size: 11px;
}

/* ── SETTINGS DESCRIPTIONS ── */
.settings-desc {
  color: var(--fg-dim);
  font-size: 10px;
  line-height: 1.5;
  padding: 4px 0 8px;
}
.settings-desc strong {
  color: var(--fg);
}

/* ── HIDE RUN TOGGLE ── */
html.hide-run-toggle #autorunBtn,
html.hide-run-toggle #autorunBtnMobile { display: none; }

/* ── MODULE LIST (settings panel) ── */
.module-row {
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 4px 0;
  font-size: 11px;
}
.module-url {
  flex: 1;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  color: var(--fg);
}
.module-info {
  color: var(--fg-dim);
  white-space: nowrap;
  font-size: 10px;
}
.module-remove {
  background: none;
  border: none;
  color: var(--fg-dim);
  font-size: 14px;
  padding: 0 2px;
  cursor: pointer;
  line-height: 1;
  text-transform: none;
  letter-spacing: 0;
}
.module-remove:hover { color: var(--err); }
.module-total {
  padding: 4px 0;
  font-size: 10px;
  color: var(--fg-dim);
  border-top: 1px solid var(--border);
  text-align: right;
}
.module-empty {
  color: var(--fg-dim);
  font-size: 11px;
  font-style: italic;
  padding: 4px 0;
}
/* ── UPDATE PANEL ── */
.update-overlay {
  display: none;
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.5);
  z-index: 1000;
}
.update-overlay.visible { display: block; }
.update-panel {
  display: none;
  position: fixed;
  top: 0;
  right: 0;
  bottom: 0;
  width: 280px;
  max-width: 90vw;
  background: var(--bg1);
  border-left: 1px solid var(--border);
  padding: 20px;
  overflow-y: auto;
  z-index: 1001;
  font-family: var(--mono);
  font-size: 12px;
  color: var(--fg);
}
.update-panel h2 {
  color: var(--accent);
  font-size: 11px;
  letter-spacing: 2px;
  text-transform: uppercase;
  margin: 0 0 12px 0;
}
.update-panel .settings-row {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 6px 0;
}
.update-panel .settings-row label { color: var(--fg-dim); font-size: 11px; }
.update-actions {
  display: flex;
  flex-direction: column;
  gap: 6px;
  padding: 8px 0;
}
.update-actions button {
  width: 100%;
  padding: 8px 10px;
}
.update-status {
  font-size: 11px;
  padding: 8px 0;
  line-height: 1.5;
}
.update-status strong { color: var(--fg-bright); }
.update-status button {
  display: block;
  width: 100%;
  margin-top: 8px;
  padding: 8px 10px;
  border-color: var(--accent-dim);
  color: var(--accent);
}
.update-status button:hover {
  border-color: var(--accent);
}
.update-ok { color: var(--ok); }
.update-err { color: var(--err); }
.update-warn { color: var(--accent); }
.update-available { color: var(--fg); }
.update-notes {
  color: var(--fg-dim);
  font-size: 11px;
  padding: 6px 0;
  max-height: 120px;
  overflow-y: auto;
  line-height: 1.4;
}
.update-notes p { margin: 0 0 4px; }
.update-notes ul { margin: 2px 0; padding-left: 16px; }
.update-notes li { margin: 1px 0; }
.update-notes h1, .update-notes h2, .update-notes h3 { font-size: 11px; margin: 4px 0 2px; color: var(--fg); }
.update-confirm {
  display: flex;
  gap: 8px;
  padding: 6px 0;
}
.update-confirm button { width: auto; }
.update-sig {
  font-size: 11px;
}
.update-key-truncated {
  cursor: pointer;
}
.update-key-truncated:hover {
  color: var(--accent);
}
.update-key-expanded {
  word-break: break-all;
  user-select: all;
  cursor: pointer;
  color: var(--fg-bright);
}
/* ── UPDATE BUTTON IN OVERFLOW TRAY ── */
.toolbar-update-btn {
  color: var(--accent) !important;
}

.settings-about {
  margin-top: 24px;
  padding-top: 12px;
  border-top: 1px solid var(--border);
  font-size: 11px;
  color: var(--fg-dim);
  display: flex;
  flex-direction: column;
  gap: 2px;
}
.settings-about a {
  color: var(--accent);
  text-decoration: none;
}
.settings-about a:hover { text-decoration: underline; }

/* ── FIND BAR ── */
.find-bar {
  display: none;
  flex-direction: column;
  position: sticky;
  top: 33px;
  z-index: 99;
  float: right;
  max-width: 400px;
  width: 100%;
  background: var(--bg1);
  border: 1px solid var(--border);
  border-top: none;
  padding: 6px 8px;
  gap: 4px;
}
.find-row {
  display: flex;
  align-items: center;
  gap: 4px;
}
.find-replace-row {
  display: none;
  align-items: center;
  gap: 4px;
}
.find-bar.show-replace .find-replace-row { display: flex; }
.find-bar input[type="text"] {
  flex: 1;
  background: var(--bg2);
  border: 1px solid var(--border);
  color: var(--fg-bright);
  font-family: var(--mono);
  font-size: 12px;
  padding: 4px 8px;
  outline: none;
  min-width: 0;
}
.find-bar input[type="text"]:focus {
  border-color: var(--border-hi);
}
.find-count {
  font-size: 10px;
  color: var(--fg-dim);
  white-space: nowrap;
  min-width: 50px;
  text-align: center;
  letter-spacing: 1px;
}
.find-bar button {
  padding: 3px 8px;
  font-size: 10px;
  min-width: 28px;
}
.find-bar button.active {
  color: var(--accent);
  border-color: var(--accent-dim);
}
body.presenting .find-bar { display: none !important; }

/* ── SEARCH OVERLAY ── */
.search-overlay {
  position: absolute;
  top: 0; left: 0; right: 0; bottom: 0;
  padding: 8px 10px 8px calc(var(--gutter) + 10px);
  font-family: var(--mono);
  font-size: var(--editor-font-size);
  line-height: 1.5;
  tab-size: 2;
  white-space: pre;
  overflow: hidden;
  z-index: 1;
  pointer-events: none;
  color: transparent;
  border: 1px solid transparent;
}
.search-overlay-md {
  padding: 8px 10px;
}
.md-search-wrap {
  position: relative;
}
.search-match {
  background: rgba(200,155,60,0.25);
  color: transparent;
}
.search-match-current {
  background: rgba(200,155,60,0.5);
  outline: 1px solid var(--accent);
}

/* ── AUTOCOMPLETE MENU ── */
.ac-menu {
  position: absolute;
  z-index: 10;
  background: #1e1e1e;
  border: 1px solid #444;
  border-radius: 3px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.4);
  max-height: 200px;
  overflow-y: auto;
  font-family: var(--mono);
  font-size: var(--editor-font-size);
  min-width: 120px;
}
.ac-item {
  padding: 2px 8px;
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 6px;
  white-space: nowrap;
}
.ac-item.active,
.ac-item:hover {
  background: rgba(200,155,60,0.2);
}
.ac-kind {
  width: 16px;
  height: 16px;
  border-radius: 2px;
  font-size: 10px;
  text-align: center;
  line-height: 16px;
  flex-shrink: 0;
}
.ac-kind-var, .ac-kind-def { color: #5ca7e4; }
.ac-kind-fn { color: #c89b3c; }
.ac-kind-kw { color: #cc7832; }
.ac-kind-const { color: #9876aa; }
.ac-kind-prop { color: #6a8759; }
.ac-text { color: var(--fg-bright); }
.ac-detail {
  margin-left: auto;
  padding-left: 12px;
  color: var(--fg-dim);
  font-size: 11px;
}
.ac-match { font-weight: bold; }
.ac-sig-hint {
  position: absolute;
  z-index: 10;
  background: #1e1e1e;
  border: 1px solid #444;
  border-radius: 3px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.4);
  padding: 3px 8px;
  font-family: var(--mono);
  font-size: var(--editor-font-size);
  white-space: nowrap;
  display: flex;
  gap: 10px;
  align-items: baseline;
}
.ac-sig-fn { color: var(--fg-bright); }
.ac-sig-active { color: var(--accent); font-weight: bold; text-decoration: underline; }
.ac-sig-desc { color: var(--fg-dim); font-size: 11px; }
:root.light .ac-sig-hint {
  background: #eae8e3;
  border-color: #b0ab9f;
  box-shadow: 0 2px 8px rgba(0,0,0,0.15);
}
:root.light .ac-menu {
  background: #eae8e3;
  border-color: #b0ab9f;
  box-shadow: 0 2px 8px rgba(0,0,0,0.15);
}
:root.light .ac-item.active,
:root.light .ac-item:hover {
  background: rgba(153,107,31,0.15);
}

/* ── WORKSHOP PANEL ── */
.workshop-overlay {
  display: none;
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.3);
  z-index: 900;
}
.workshop-overlay.visible { display: block; }
.workshop-panel {
  position: fixed;
  top: 0;
  right: -380px;
  bottom: 0;
  width: 360px;
  max-width: 90vw;
  background: var(--bg1);
  border-left: 1px solid var(--border);
  z-index: 901;
  display: flex;
  flex-direction: column;
  font-family: var(--mono);
  font-size: 13px;
  color: var(--fg);
  transition: right 0.25s ease;
  overflow: hidden;
}
.workshop-panel.open { right: 0; }
.workshop-tab {
  position: fixed;
  right: 0;
  top: 50%;
  transform: translateY(-50%) rotate(180deg);
  writing-mode: vertical-rl;
  background: var(--bg1);
  border: 1px solid var(--border);
  border-right: none;
  color: var(--accent);
  font-family: var(--mono);
  font-size: 10px;
  letter-spacing: 2px;
  text-transform: uppercase;
  padding: 10px 5px;
  cursor: pointer;
  z-index: 902;
  transition: right 0.25s ease;
}
.workshop-tab:hover { background: var(--bg2); }
.workshop-panel.open ~ .workshop-tab { right: min(360px, 90vw); }
.workshop-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 16px 16px 12px;
  border-bottom: 1px solid var(--border);
}
.workshop-title {
  color: var(--accent);
  font-size: 11px;
  letter-spacing: 2px;
  text-transform: uppercase;
}
.workshop-close {
  background: none;
  border: 1px solid var(--border);
  color: var(--fg-dim);
  font-size: 18px;
  width: 28px; height: 28px;
  display: flex; align-items: center; justify-content: center;
  padding: 0; cursor: pointer;
  text-transform: none;
  letter-spacing: 0;
}
.workshop-close:hover { border-color: var(--err); color: var(--err); }
.workshop-body {
  flex: 1;
  overflow-y: auto;
  padding: 16px;
  line-height: 1.6;
}
.workshop-body h1, .workshop-body h2, .workshop-body h3 {
  color: var(--fg-bright);
  margin: 1em 0 0.5em;
}
.workshop-body h1:first-child, .workshop-body h2:first-child, .workshop-body h3:first-child {
  margin-top: 0;
}
.workshop-body code {
  background: var(--bg2);
  padding: 1px 4px;
  font-size: 0.9em;
}
.workshop-body strong { color: var(--accent); }
.workshop-pips {
  display: flex;
  justify-content: center;
  gap: 6px;
  padding: 8px 16px;
}
.workshop-pip {
  width: 8px; height: 8px;
  border-radius: 50%;
  background: var(--border);
  cursor: pointer;
}
.workshop-pip.done { background: var(--fg-dim); }
.workshop-pip.active { background: var(--accent); }
.workshop-nav {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 12px 16px;
  border-top: 1px solid var(--border);
}
.workshop-nav button {
  background: var(--bg2);
  border: 1px solid var(--border);
  color: var(--fg);
  font-family: var(--mono);
  font-size: 11px;
  padding: 4px 12px;
  cursor: pointer;
}
.workshop-nav button:hover { border-color: var(--accent); color: var(--accent); }
.workshop-nav button:disabled { opacity: 0.3; cursor: default; }
.workshop-nav button:disabled:hover { border-color: var(--border); color: var(--fg); }
.workshop-counter { color: var(--fg-dim); font-size: 11px; }

/* ── LIGHT THEME ── */
:root.light {
  --bg: #f5f4f0;
  --bg1: #eae8e3;
  --bg2: #dedad3;
  --border: #ccc8bf;
  --border-hi: #b0ab9f;
  --fg: #444;
  --fg-dim: #888;
  --fg-bright: #222;
  --accent: #996b1f;
  --accent-dim: #b8924a;
  --err: #c33;
  --ok: #287;
}
:root.light .cell[data-type="code"] .cell-type { color: #4a7a9e; }
:root.light .cell[data-type="css"]  .cell-type { color: #a56e33; }
:root.light .cell[data-type="html"] .cell-type { color: #3d8a83; }
:root.light ::-webkit-scrollbar-track { background: var(--bg); }
:root.light ::-webkit-scrollbar-thumb { background: var(--border-hi); }

/* ── TOUCH / HEADER MODES ── */
@media (hover: none) {
  .insert-bar { display: none; }
  .cell.selected .cell-insert { display: inline; }
  .cell.selected .cell-convert { display: inline; }
  .cell.selected .cell-header {
    gap: 2px;
  }
  .cell.selected .cell-btn {
    min-height: 36px;
    min-width: 36px;
    font-size: 14px;
    display: inline-flex;
    align-items: center;
    justify-content: center;
  }
}

/* compact header: ellipsis indicator, full controls on select */
@media (hover: none) {
  :root:not(.header-always):not(.header-hover) .cell-header > * { display: none; }
  :root:not(.header-always):not(.header-hover) .cell-header {
    opacity: 1;
    justify-content: center;
    padding: 1px 8px;
  }
  :root:not(.header-always):not(.header-hover) .cell-header::before {
    content: '\22ef';
    color: var(--fg-dim);
    font-size: 12px;
    opacity: 0.4;
  }
  :root:not(.header-always):not(.header-hover) .cell.selected .cell-header > * { display: inline; }
  :root:not(.header-always):not(.header-hover) .cell.selected .cell-header::before { display: none; }
  :root:not(.header-always):not(.header-hover) .cell.selected .cell-header {
    justify-content: flex-start;
    padding: 2px 8px;
  }
}

/* header-always: full header visible on all devices */
:root.header-always .cell-header { opacity: 0.6; }
:root.header-always .cell:hover .cell-header,
:root.header-always .cell.selected .cell-header { opacity: 1; }

/* header-compact: forced compact mode on all devices */
:root.header-compact .cell-header > * { display: none; }
:root.header-compact .cell-header {
  opacity: 1 !important;
  justify-content: center;
  padding: 1px 8px;
}
:root.header-compact .cell-header::before {
  content: '\22ef';
  color: var(--fg-dim);
  font-size: 12px;
  opacity: 0.4;
}
:root.header-compact .cell.selected .cell-header > * { display: inline; }
:root.header-compact .cell.selected .cell-header::before { display: none; }
:root.header-compact .cell.selected .cell-header {
  justify-content: flex-start;
  padding: 2px 8px;
}

/* ── RESPONSIVE ── */
@media (max-width: 640px) {
  /* slim top toolbar: filename + cell count only */
  .toolbar {
    flex-wrap: nowrap;
    gap: 4px;
    padding: 6px 8px;
  }
  .toolbar-title { display: none; }
  .toolbar-sep { display: none; }
  .toolbar .toolbar-add, .toolbar .toolbar-secondary { display: none; }
  .transport { display: none; }
  .toolbar-right { display: none; }
  .toolbar-filename { flex: 1; }
  .toolbar-filename input { width: 100%; }
  .toolbar-status {
    display: inline;
    font-size: 10px;
    color: var(--fg-dim);
    white-space: nowrap;
    letter-spacing: 1px;
  }

  /* bottom action bar replaces statusbar */
  .statusbar {
    display: block;
    padding: 0;
    height: 48px;
  }
  .statusbar .status-size,
  .statusbar .status-cells,
  .statusbar .status-msg,
  .statusbar .status-attr { display: none; }
  .action-bar {
    display: grid;
    grid-template-columns: repeat(5, 1fr);
    height: 48px;
  }
  /* wrapper divs for tray positioning must fill their grid cell */
  .action-bar > div {
    position: relative;
    display: flex;
  }
  .action-bar > div > button {
    flex: 1;
  }
  /* style only the 5 action buttons, not tray buttons */
  .action-bar > button,
  .action-bar > div > button {
    min-height: 48px;
    border: none;
    border-right: 1px solid var(--border);
    background: var(--bg);
    font-family: var(--mono);
    font-size: 16px;
    color: var(--fg);
    padding: 0;
    letter-spacing: 0;
    text-transform: none;
  }
  .action-bar > :last-child > button,
  .action-bar > button:last-child { border-right: none; }
  .action-bar > button:active,
  .action-bar > div > button:active { background: var(--bg2); }
  .action-bar > button.autorun-on,
  .action-bar > div > button.autorun-on {
    background: #33aa77;
    color: #111;
  }
  .action-bar > button.autorun-off,
  .action-bar > div > button.autorun-off {
    background: #dd4444;
    color: #111;
  }

  .find-bar { max-width: 100%; float: none; }
  .notebook { padding: 8px 6px 100px; }
  .cell-header { padding: 2px 4px; }
  .settings-close { width: 44px; height: 44px; font-size: 22px; }
  .settings-row { padding: 10px 0; }
  .settings-row select { min-height: 44px; font-size: 14px; padding: 4px 8px; }
  .settings-row input[type="range"] { height: 44px; }
  .help-overlay { padding: 20px 12px; }
  .settings-panel { width: 260px; }
}

</style>
</head>
<body>

<div class="help-overlay" id="helpOverlay">
<div class="help-content">
<button class="help-close-btn" onclick="$('#helpOverlay').classList.remove('visible')">&#x00d7;</button>
<h2>command mode</h2>
<div class="help-row"><span class="help-key">&#x2191; / k</span><span class="help-desc">select cell above</span></div>
<div class="help-row"><span class="help-key">&#x2193; / j</span><span class="help-desc">select cell below</span></div>
<div class="help-row"><span class="help-key">Enter</span><span class="help-desc">edit selected cell</span></div>
<div class="help-row"><span class="help-key">a</span><span class="help-desc">insert cell above</span></div>
<div class="help-row"><span class="help-key">b</span><span class="help-desc">insert cell below</span></div>
<div class="help-row"><span class="help-key">d d</span><span class="help-desc">delete cell</span></div>
<div class="help-row"><span class="help-key">z</span><span class="help-desc">undo delete</span></div>
<div class="help-row"><span class="help-key">c</span><span class="help-desc">copy cell</span></div>
<div class="help-row"><span class="help-key">v</span><span class="help-desc">paste cell below</span></div>
<div class="help-row"><span class="help-key">x</span><span class="help-desc">cut cell</span></div>
<div class="help-row"><span class="help-key">m</span><span class="help-desc">convert to markdown</span></div>
<div class="help-row"><span class="help-key">y</span><span class="help-desc">convert to code</span></div>
<div class="help-row"><span class="help-key">s</span><span class="help-desc">convert to css</span></div>
<div class="help-row"><span class="help-key">t</span><span class="help-desc">convert to html template</span></div>
<div class="help-row"><span class="help-key">h</span><span class="help-desc">collapse / expand cell</span></div>
<div class="help-row"><span class="help-key">l</span><span class="help-desc">toggle line numbers</span></div>
<div class="help-row"><span class="help-key">p</span><span class="help-desc">presentation mode</span></div>

<h2>edit mode</h2>
<div class="help-row"><span class="help-key">Esc</span><span class="help-desc">exit to command mode</span></div>
<div class="help-row"><span class="help-key">Ctrl+Enter</span><span class="help-desc">run cell</span></div>
<div class="help-row"><span class="help-key">Shift+Enter</span><span class="help-desc">run cell + advance</span></div>
<div class="help-row"><span class="help-key">Ctrl+/</span><span class="help-desc">toggle comment</span></div>
<div class="help-row"><span class="help-key">Tab</span><span class="help-desc">indent</span></div>
<div class="help-row"><span class="help-key">Shift+Tab</span><span class="help-desc">unindent</span></div>

<h2>global</h2>
<div class="help-row"><span class="help-key">F1</span><span class="help-desc">toggle this help</span></div>
<div class="help-row"><span class="help-key">Ctrl+S</span><span class="help-desc">save notebook</span></div>
<div class="help-row"><span class="help-key">Ctrl+F</span><span class="help-desc">find in notebook</span></div>
<div class="help-row"><span class="help-key">Ctrl+H</span><span class="help-desc">find and replace</span></div>

<h2>toolbar</h2>
<div class="help-row"><span class="help-key">&#x23f5; step</span><span class="help-desc">run selected cell</span></div>
<div class="help-row"><span class="help-key">&#x25b6;/&#x2016;</span><span class="help-desc">toggle reactive mode (autorun)</span></div>
<div class="help-row"><span class="help-key">&#x25b6;&#x25b6; run all</span><span class="help-desc">run all cells</span></div>

<h2>builtins</h2>
<div class="help-row"><span class="help-key">display()</span><span class="help-desc">show text, objects, or DOM elements</span></div>
<div class="help-row"><span class="help-key">canvas(w,h)</span><span class="help-desc">create a canvas element</span></div>
<div class="help-row"><span class="help-key">table(data)</span><span class="help-desc">render array of objects as table</span></div>
<div class="help-row"><span class="help-key">slider()</span><span class="help-desc">reactive range input</span></div>
<div class="help-row"><span class="help-key">dropdown()</span><span class="help-desc">reactive select input</span></div>
<div class="help-row"><span class="help-key">checkbox()</span><span class="help-desc">reactive boolean input</span></div>
<div class="help-row"><span class="help-key">textInput()</span><span class="help-desc">reactive text input</span></div>
<div class="help-row"><span class="help-key">load(url)</span><span class="help-desc">import ESM module (cached)</span></div>
<div class="help-row"><span class="help-key">install(url)</span><span class="help-desc">import + embed in HTML on save</span></div>
<div class="help-row"><span class="help-key">installBinary(url)</span><span class="help-desc">fetch binary asset + embed gzipped</span></div>
<div class="help-row"><span class="help-key">invalidation</span><span class="help-desc">promise that resolves before cell re-runs</span></div>
<div class="help-row"><span class="help-key">md``</span><span class="help-desc">markdown tagged template</span></div>
<div class="help-row"><span class="help-key">html``</span><span class="help-desc">HTML tagged template</span></div>
<div class="help-row"><span class="help-key">css``</span><span class="help-desc">CSS tagged template</span></div>
<div class="help-row"><span class="help-key">workshop(pages)</span><span class="help-desc">interactive side panel with pages</span></div>
<div class="help-row"><span class="help-key">notebook</span><span class="help-desc">API for cells, scope, scrollTo, focus</span></div>

<h2>directives</h2>
<div class="help-row"><span class="help-key">// %manual</span><span class="help-desc">skip cell on reactive updates</span></div>
<div class="help-row"><span class="help-key">// %norun</span><span class="help-desc">skip cell on Run All</span></div>
<div class="help-row"><span class="help-key">// %hide</span><span class="help-desc">hide cell in present mode</span></div>
<div class="help-row"><span class="help-key">// %cellName &lt;label&gt;</span><span class="help-desc">name cell in DevTools</span></div>
<div class="help-row"><span class="help-key">// %outputId &lt;id&gt;</span><span class="help-desc">set id on output div</span></div>
<div class="help-row"><span class="help-key">// %outputClass &lt;cls&gt;</span><span class="help-desc">add classes to output div</span></div>
<div class="help-row"><span class="help-key">// %goto &lt;label&gt;</span><span class="help-desc">jump to named cell after execution</span></div>
<div class="help-row"><span class="help-key">// %collapsed</span><span class="help-desc">start cell collapsed</span></div>

<div class="help-close">press F1 or Esc to close</div>
</div>
</div>

<div class="settings-overlay" id="settingsOverlay" onclick="if(event.target===this)toggleSettings()"></div>
<div class="settings-panel" id="settingsPanel">
  <button class="settings-close" onclick="toggleSettings()">&#x00d7;</button>
  <h2>theme</h2>
  <div class="settings-row">
    <label>color scheme</label>
    <select id="setTheme" onchange="applyTheme(this.value)">
      <option value="dark">dark</option>
      <option value="light">light</option>
    </select>
  </div>

  <h2>editor</h2>
  <div class="settings-row">
    <label>font size</label>
    <input type="range" id="setFontSize" min="10" max="20" value="13" oninput="applyFontSize(this.value)">
    <span class="settings-val" id="setFontSizeVal">13</span>
  </div>
  <div class="settings-row">
    <label>line numbers</label>
    <select id="setLineNumbers" onchange="applyLineNumbers(this.value)">
      <option value="on" selected>on</option>
      <option value="off">off</option>
    </select>
  </div>

  <h2>notebook</h2>
  <div class="settings-row">
    <label>max width</label>
    <select id="setWidth" onchange="applyWidth(this.value)">
      <option value="720">narrow</option>
      <option value="860" selected>default</option>
      <option value="1100">wide</option>
      <option value="100%">full</option>
    </select>
  </div>
  <div class="settings-row">
    <label>cell header</label>
    <select id="setHeader" onchange="applyHeader(this.value)">
      <option value="auto" selected>auto</option>
      <option value="always">always visible</option>
      <option value="compact">compact</option>
      <option value="hover">hover only</option>
    </select>
  </div>

  <h2>execution</h2>
  <div class="settings-row">
    <label>mode</label>
    <select id="setExecMode" onchange="applyExecMode(this.value)">
      <option value="reactive">reactive</option>
      <option value="manual">manual</option>
    </select>
  </div>
  <div class="settings-row">
    <label>run on load</label>
    <select id="setRunOnLoad" onchange="applyRunOnLoad(this.value)">
      <option value="yes">yes</option>
      <option value="no">no</option>
    </select>
  </div>
  <div class="settings-row">
    <label>show run toggle</label>
    <select id="setShowToggle" onchange="applyShowToggle(this.value)">
      <option value="yes">yes</option>
      <option value="no">no</option>
    </select>
  </div>
  <div class="settings-desc">
    <strong>reactive</strong>: cells auto-run on edit, changes propagate.<br>
    <strong>manual</strong>: only Ctrl+Enter, Shift+Enter, or Run All.
  </div>
  <div class="settings-row">
    <label>global override</label>
    <select id="setGlobalExecMode" onchange="applyGlobalExecMode(this.value)">
      <option value="">(notebook default)</option>
      <option value="reactive">always reactive</option>
      <option value="manual">always manual</option>
    </select>
  </div>
  <div class="settings-row">
    <label>global run on load</label>
    <select id="setGlobalRunOnLoad" onchange="applyGlobalRunOnLoad(this.value)">
      <option value="">(notebook default)</option>
      <option value="yes">always run</option>
      <option value="no">never run</option>
    </select>
  </div>

  <h2>modules</h2>
  <div id="moduleList"></div>
  <h2>binaries</h2>
  <div id="binaryList"></div>

  <div class="settings-about">
    <span id="aboutVersion"></span>
    <span id="aboutBuild"></span>
    <span id="aboutRuntime"></span>
    <a href="https://github.com/endarthur/auditable" target="_blank">github.com/endarthur/auditable</a>
  </div>
</div>

<div class="update-overlay" id="updateOverlay" onclick="if(event.target===this)toggleUpdate()"></div>
<div class="update-panel" id="updatePanel">
  <button class="settings-close" onclick="toggleUpdate()">&#x00d7;</button>
  <h2>update</h2>
  <div class="settings-row">
    <label>version</label>
    <span id="updateCurrentVer">v0.0.0</span>
  </div>
  <div class="settings-row">
    <label>release</label>
    <span id="updateRelease">dev</span>
  </div>
  <div class="settings-row">
    <label>signature</label>
    <span id="updateSigStatus" class="update-sig">checking...</span>
  </div>
  <div class="settings-row">
    <label>public key</label>
    <span id="updatePubKey" class="update-sig">-</span>
  </div>
  <div id="updateStatus" class="update-status"></div>
  <div class="update-actions">
    <button id="updateCheckBtn" onclick="checkForUpdate()">check for updates</button>
    <button onclick="updateFromFile()">update from file</button>
  </div>
</div>

<div class="toolbar">
  <span class="toolbar-title">auditable</span>
  <span class="toolbar-badges" id="toolbarBadges"></span>
  <span class="toolbar-sep"></span>
  <span class="toolbar-filename">
    <input type="text" id="docTitle" value="atra — language tour" spellcheck="false">
  </span>
  <span class="toolbar-status" id="toolbarStatus"></span>
  <button class="toolbar-add" onclick="addCellWithUndo('code','',S.selectedId)">+ code</button>
  <button class="toolbar-add" onclick="addCellWithUndo('md','',S.selectedId)">+ md</button>
  <button class="toolbar-secondary" onclick="addCellWithUndo('css','',S.selectedId)">+ css</button>
  <button class="toolbar-secondary" onclick="addCellWithUndo('html','',S.selectedId)">+ html</button>
  <span class="toolbar-sep"></span>
  <span class="transport">
    <button onclick="runSelectedCell()" title="run cell + advance (Shift+Enter)">&#x23f5;</button>
    <button id="autorunBtn" class="autorun-on" onclick="toggleAutorun()" title="reactive mode &#x2014; cells auto-run on edit">&#x25b6;</button>
    <button onclick="runAll()" title="run all cells">&#x25b6;&#x25b6;</button>
  </span>
  <span class="toolbar-right">
    <span class="save-split">
      <button class="accent" onclick="saveNotebook()"><span id="saveLabel">save</span></button><button class="accent save-caret" onclick="toggleSaveTray()">&#x25be;</button>
      <div class="save-tray" id="saveTray">
        <button onclick="setSaveMode('normal');saveNotebook()">save</button>
        <button onclick="setSaveMode('packed');saveNotebook()">save packed</button>
        <button onclick="exportAsTxt();toggleSaveTray()">export .txt</button>
      </div>
    </span>
    <div class="toolbar-overflow">
      <button onclick="toggleToolbarMenu()" title="more">&#x22ef;</button>
      <div class="toolbar-overflow-tray">
        <button onclick="newNotebook();toggleToolbarMenu()">new</button>
        <button onclick="collapseAll();toggleToolbarMenu()">collapse all</button>
        <button onclick="expandAll();toggleToolbarMenu()">expand all</button>
        <button onclick="$('#helpOverlay').classList.toggle('visible');toggleToolbarMenu()">help (F1)</button>
        <button onclick="toggleSettings();toggleToolbarMenu()">settings</button>
        <button class="toolbar-update-btn" onclick="toggleUpdate();toggleToolbarMenu()">update</button>
        <button onclick="togglePresent();toggleToolbarMenu()">present</button>
        <button onclick="openFind(false);toggleToolbarMenu()">find (Ctrl+F)</button>
      </div>
    </div>
  </span>
</div>

<div class="find-bar" id="findBar">
  <div class="find-row">
    <input type="text" id="findInput" placeholder="find" spellcheck="false" autocomplete="off">
    <span class="find-count" id="findCount"></span>
    <button id="findRegexBtn" title="use regex">.*</button>
    <button id="findCaseBtn" title="match case">Aa</button>
    <button id="findPrevBtn" title="previous (Shift+Enter)">&#x2191;</button>
    <button id="findNextBtn" title="next (Enter)">&#x2193;</button>
    <button id="findCloseBtn" title="close (Esc)">&#x00d7;</button>
  </div>
  <div class="find-replace-row" id="findReplaceRow">
    <input type="text" id="replaceInput" placeholder="replace" spellcheck="false" autocomplete="off">
    <button id="findReplaceBtn">replace</button>
    <button id="findReplaceAllBtn">all</button>
  </div>
</div>

<button class="present-exit" onclick="togglePresent()">&#x2715; exit</button>

<div class="notebook" id="notebook">
  <!-- cells go here -->
</div>

<div class="statusbar">
  <span class="status-size" id="statusSize"></span>
  <span class="status-cells" id="statusCells">0 cells</span>
  <span class="status-msg" id="statusMsg"></span>
  <span class="status-attr">
    <a href="https://endarthur.github.io" target="_blank">endarthur</a>
    <span>&middot;</span>
    <a href="https://gentropic.org" target="_blank">geoscientific chaos union</a>
    <span>&middot;</span>
    <a href="https://github.com/endarthur/auditable" target="_blank" title="source on GitHub"><svg width="14" height="14" viewBox="0 0 16 16" fill="currentColor"><path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"/></svg></a>
  </span>
  <div class="action-bar">
    <div>
      <div class="action-add-tray">
        <button onclick="insertAt(S.selectedId,'code');toggleAddTray()">+ code</button>
        <button onclick="insertAt(S.selectedId,'md');toggleAddTray()">+ md</button>
        <button onclick="insertAt(S.selectedId,'css');toggleAddTray()">+ css</button>
        <button onclick="insertAt(S.selectedId,'html');toggleAddTray()">+ html</button>
      </div>
      <button class="action-add" onclick="toggleAddTray()">+</button>
    </div>
    <button onclick="runSelectedCell()" title="run cell + advance">&#x23f5;</button>
    <button id="autorunBtnMobile" class="autorun-on" onclick="toggleAutorun()" title="autorun">&#x25b6;</button>
    <button onclick="runAll()" title="run all">&#x25b6;&#x25b6;</button>
    <div>
      <div class="action-more-tray">
        <button onclick="newNotebook();toggleMoreTray()">new</button>
        <button id="mobileSaveBtn" class="active-mode" onclick="setSaveMode('normal');saveNotebook();toggleMoreTray()">save</button>
        <button id="mobilePackBtn" onclick="setSaveMode('packed');saveNotebook();toggleMoreTray()">save packed</button>
        <button onclick="collapseAll();toggleMoreTray()">collapse all</button>
        <button onclick="expandAll();toggleMoreTray()">expand all</button>
        <button onclick="$('#helpOverlay').classList.toggle('visible');toggleMoreTray()">help</button>
        <button onclick="toggleSettings();toggleMoreTray()">settings</button>
        <button class="toolbar-update-btn" onclick="toggleUpdate();toggleMoreTray()">update</button>
        <button onclick="togglePresent();toggleMoreTray()">present</button>
        <button onclick="openFind(false);toggleMoreTray()">find</button>
      </div>
      <button class="action-more" onclick="toggleMoreTray()">&#x22ef;</button>
    </div>
  </div>
</div>


<!-- cell data: JSON array of {type, code, collapsed?} -->
<!--AUDITABLE-DATA
[{"type":"md","code":"# atra language tour — Newton fractal\n\na [Newton fractal](https://en.wikipedia.org/wiki/Newton%27s_method) colors each pixel by which root of z\\u00b3 \\u2212 1 = 0 the Newton-Raphson method converges to. three roots in the complex plane, three colors. the algorithm exercises many atra features: **SIMD** (f64x2 for complex numbers), **dotted names**, **tailcall**, **call return()**, **if-expression**, **type conversions**, **arrays**, and **for loops**."},{"type":"code","code":"const { atra } = await load(\"./ext/atra/index.js\");\nconst maxIter = ui.slider(\"max iterations\", 40, {min: 5, max: 120, step: 1});\nconst res = ui.slider(\"resolution\", 200, {min: 50, max: 500, step: 10});"},{"type":"code","collapsed":true,"code":"// compile atra kernel — complex math via f64x2 SIMD, Newton iterator via tailcall\nconst mem = new WebAssembly.Memory({ initial: 4 });\n\nconst wasm = atra({ memory: mem })`\n  ! ── complex arithmetic via f64x2 SIMD ──\n  ! complex number = f64x2 where lane 0 = real, lane 1 = imag\n\n  ! complex multiply: (a+bi)(c+di) = (ac-bd) + (ad+bc)i\n  function cx.mul(a, b: f64x2): f64x2\n  var\n    ar, ai, br, bi: f64\n    re, im: f64\n  begin\n    ar := f64x2.extract_lane(a, 0)\n    ai := f64x2.extract_lane(a, 1)\n    br := f64x2.extract_lane(b, 0)\n    bi := f64x2.extract_lane(b, 1)\n    re := ar * br - ai * bi\n    im := ar * bi + ai * br\n    cx.mul := f64x2(re, im)\n  end\n\n  ! |z|^2 = re^2 + im^2\n  function cx.abs2(z: f64x2): f64\n  var\n    sq: f64x2\n  begin\n    sq := z * z\n    cx.abs2 := f64x2.extract_lane(sq, 0) + f64x2.extract_lane(sq, 1)\n  end\n\n  ! f(z) = z^3 - 1\n  function cx.f(z: f64x2): f64x2\n  var\n    z2, z3: f64x2\n  begin\n    z2 := cx.mul(z, z)\n    z3 := cx.mul(z2, z)\n    z3 := z3 - f64x2(1.0, 0.0)\n    cx.f := z3\n  end\n\n  ! f'(z) = 3z^2\n  function cx.df(z: f64x2): f64x2\n  var\n    z2: f64x2\n    three: f64x2\n  begin\n    z2 := cx.mul(z, z)\n    three := f64x2.splat(3.0)\n    cx.df := z2 * three\n  end\n\n  ! complex divide: a/b = a*conj(b) / |b|^2\n  function cx.div(a, b: f64x2): f64x2\n  var\n    conj_b, num: f64x2\n    denom: f64\n    dv: f64x2\n  begin\n    conj_b := f64x2(f64x2.extract_lane(b, 0), 0.0 - f64x2.extract_lane(b, 1))\n    num := cx.mul(a, conj_b)\n    denom := cx.abs2(b)\n    dv := f64x2.splat(denom)\n    cx.div := num / dv\n  end\n\n  ! ── Newton iterator with tail recursion ──\n  ! returns root id (0, 1, 2) or -1 if no convergence\n  ! takes scalar f64 parts (not f64x2) because tailcall passes via stack\n  function newton.step(zr, zi: f64, iter, maxIter: i32): i32\n  var\n    z, fz, dfz, ratio, znew: f64x2\n    nr, ni, d: f64\n    tol: f64\n  begin\n    ! guard: no convergence\n    if (iter >= maxIter) then\n      call return(0 - 1)\n    end if\n\n    z := f64x2(zr, zi)\n\n    ! Newton step: z_new = z - f(z)/f'(z)\n    fz := cx.f(z)\n    dfz := cx.df(z)\n    ratio := cx.div(fz, dfz)\n    znew := z - ratio\n\n    ! convergence check\n    tol := 1e-6\n    d := cx.abs2(znew - z)\n    if (d < tol) then\n      ! classify which root we converged to\n      ! roots of z^3-1: (1,0), (-0.5, sqrt(3)/2), (-0.5, -sqrt(3)/2)\n      nr := f64x2.extract_lane(znew, 0)\n      ni := f64x2.extract_lane(znew, 1)\n      if (nr > 0.0) then\n        call return(0)\n      else if (ni > 0.0) then\n        call return(1)\n      else\n        call return(2)\n      end if\n    end if\n\n    ! not converged — tail-recurse with updated z\n    tailcall newton.step(\n      f64x2.extract_lane(znew, 0),\n      f64x2.extract_lane(znew, 1),\n      iter + 1, maxIter\n    )\n  end\n\n  ! ── grid evaluator: for each pixel, run newton.step ──\n  subroutine newton.grid(out: array i32; w, h, maxIter: i32)\n  var\n    ix, iy: i32\n    x, y: f64\n    xmin, xmax, ymin, ymax: f64\n  begin\n    xmin := -1.5\n    xmax := 1.5\n    ymin := -1.5\n    ymax := 1.5\n    for iy := 0, h\n      for ix := 0, w\n        x := xmin + (xmax - xmin) * f64(ix) / f64(w)\n        y := ymin + (ymax - ymin) * f64(iy) / f64(h)\n        out[iy * w + ix] := newton.step(x, y, 0, maxIter)\n      end for\n    end for\n  end\n`;"},{"type":"code","code":"// run Wasm kernel and render to canvas\nconst t0 = performance.now();\nwasm.newton.grid(0, res, res, maxIter);\nconst elapsed = (performance.now() - t0).toFixed(2);\n\nconst grid = new Int32Array(mem.buffer, 0, res * res);\n\nconst size = Math.min(500, window.innerWidth - 80);\nconst c = ui.canvas(size, size);\nconst ctx = c.getContext(\"2d\");\nconst img = ctx.createImageData(res, res);\n\n// 3-color palette for 3 roots + black for non-convergence\nconst palette = [\n  [200, 155, 60],   // root 0 — amber\n  [60, 140, 200],   // root 1 — blue\n  [80, 190, 110],   // root 2 — green\n  [30, 30, 30],     // -1 — didn't converge\n];\n\nfor (let i = 0; i < res * res; i++) {\n  const rootId = grid[i];\n  const col = rootId < 0 ? palette[3] : palette[rootId];\n  img.data[i * 4 + 0] = col[0];\n  img.data[i * 4 + 1] = col[1];\n  img.data[i * 4 + 2] = col[2];\n  img.data[i * 4 + 3] = 255;\n}\n\n// scale up to canvas size\nconst tmp = new OffscreenCanvas(res, res);\nconst tctx = tmp.getContext(\"2d\");\ntctx.putImageData(img, 0, 0);\nctx.imageSmoothingEnabled = false;\nctx.drawImage(tmp, 0, 0, size, size);\n\nui.display(`${res}\\u00d7${res} \\u00b7 max ${maxIter} iterations \\u00b7 Wasm kernel: ${elapsed} ms`);"},{"type":"md","code":"**features used:**\n\n| feature | where |\n|---------|-------|\n| **f64x2 SIMD** | complex numbers packed as f64x2 \\u2014 `cx.mul`, `cx.div`, `cx.abs2`, `cx.f`, `cx.df` |\n| **dotted names** | `cx.*` and `newton.*` namespaces |\n| **tailcall** | `newton.step` tail-recurses until convergence or max iterations |\n| **call return()** | guard clause (max iter), early return on convergence with root id |\n| **if-expression style** | chained `if/else if/else` for root classification |\n| **type conversions** | `f64(ix)`, `f64(w)` \\u2014 pixel coords to floating point |\n| **arrays** | output grid of i32 root ids in linear memory |\n| **for loops** | nested pixel grid traversal in `newton.grid` |\n| **compound assignment** | `iter + 1` passed through tailcall |\n| **builtins** | `f64x2.extract_lane`, `f64x2.splat`, `f64x2()` constructor |"}]
AUDITABLE-DATA-->
<!-- installed modules: base64-encoded JSON mapping URLs to {source, cellId} -->
<!--AUDITABLE-MODULES
eyIuL2V4dC9hdHJhL2luZGV4LmpzIjp7InNvdXJjZSI6Ii8vIEBhdWRpdGFibGUvYXRyYSDigJQg
QXJpdGhtZXRpYyBUUkFuc3BpbGVyXG4vLyBGb3J0cmFuL1Bhc2NhbCBoeWJyaWQg4oaSIFdlYkFz
c2VtYmx5IGJ5dGVjb2RlLiBTaW5nbGUtZmlsZSBjb21waWxlci5cblxuLy8g4pWQ4pWQ4pWQ4pWQ
4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ
4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ
4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ
4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQXG4vLyAxLiBISUdITElH
SFQgVE9LRU5JWkVSICsgQ09NUExFVElPTlMgKGZvciBhdWRpdGFibGUgc3ludGF4IGhpZ2hsaWdo
dGluZylcbi8vIOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKV
kOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKV
kOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKV
kOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKV
kOKVkOKVkFxuXG5jb25zdCBBVFJBX0tFWVdPUkRTID0gbmV3IFNldChbXG4gICdmdW5jdGlvbics
J3N1YnJvdXRpbmUnLCdiZWdpbicsJ2VuZCcsJ3ZhcicsJ2NvbnN0JywnaWYnLCd0aGVuJywnZWxz
ZScsXG4gICdmb3InLCd3aGlsZScsJ2RvJywnYnJlYWsnLCdhbmQnLCdvcicsJ25vdCcsJ21vZCcs
J2ltcG9ydCcsJ2V4cG9ydCcsXG4gICdjYWxsJywnYXJyYXknLCd0cnVlJywnZmFsc2UnLCdmcm9t
JywndGFpbGNhbGwnLCdyZXR1cm4nLFxuXSk7XG5cbmNvbnN0IEFUUkFfVFlQRVMgPSBuZXcgU2V0
KFsnaTMyJywnaTY0JywnZjMyJywnZjY0JywnZjY0eDInLCdmMzJ4NCcsJ2kzMng0JywnaTY0eDIn
XSk7XG5cbmNvbnN0IEFUUkFfQlVJTFRJTlMgPSBuZXcgU2V0KFtcbiAgJ3NpbicsJ2NvcycsJ3Nx
cnQnLCdhYnMnLCdmbG9vcicsJ2NlaWwnLCdsbicsJ2V4cCcsJ3BvdycsXG4gICdtaW4nLCdtYXgn
LCd0cnVuYycsJ25lYXJlc3QnLCdjb3B5c2lnbicsJ3NlbGVjdCcsXG4gICdjbHonLCdjdHonLCdw
b3BjbnQnLCdyb3RsJywncm90cicsJ21lbW9yeV9zaXplJywnbWVtb3J5X2dyb3cnLFxuICAnbWVt
b3J5X2NvcHknLCdtZW1vcnlfZmlsbCcsXG5dKTtcblxuY29uc3QgQVRSQV9WRUNUT1JfVFlQRVMg
PSBuZXcgU2V0KFsnZjY0eDInLCdmMzJ4NCcsJ2kzMng0JywnaTY0eDInXSk7XG5cbmZ1bmN0aW9u
IHRva2VuaXplQXRyYShjb2RlKSB7XG4gIGNvbnN0IHRva2VucyA9IFtdO1xuICBsZXQgaSA9IDA7
XG4gIGNvbnN0IGxlbiA9IGNvZGUubGVuZ3RoO1xuXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAg
Ly8gbGluZSBjb21tZW50OiAhIHRvIGVuZCBvZiBsaW5lXG4gICAgaWYgKGNvZGVbaV0gPT09ICch
Jykge1xuICAgICAgY29uc3Qgc3RhcnQgPSBpO1xuICAgICAgd2hpbGUgKGkgPCBsZW4gJiYgY29k
ZVtpXSAhPT0gJ1xcbicpIGkrKztcbiAgICAgIHRva2Vucy5wdXNoKHsgdHlwZTogJ2NtdCcsIHRl
eHQ6IGNvZGUuc2xpY2Uoc3RhcnQsIGkpIH0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAg
IC8vIG51bWJlcnMgKHdpdGggb3B0aW9uYWwgdHlwZSBzdWZmaXggX2YzMiwgX2Y2NCwgX2kzMiwg
X2k2NClcbiAgICBpZiAoL1xcZC8udGVzdChjb2RlW2ldKSB8fCAoY29kZVtpXSA9PT0gJy4nICYm
IGkgKyAxIDwgbGVuICYmIC9cXGQvLnRlc3QoY29kZVtpICsgMV0pKSkge1xuICAgICAgY29uc3Qg
c3RhcnQgPSBpO1xuICAgICAgd2hpbGUgKGkgPCBsZW4gJiYgL1swLTkuXS8udGVzdChjb2RlW2ld
KSkgaSsrO1xuICAgICAgaWYgKGkgPCBsZW4gJiYgL1tlRV0vLnRlc3QoY29kZVtpXSkpIHtcbiAg
ICAgICAgaSsrO1xuICAgICAgICBpZiAoaSA8IGxlbiAmJiAvWystXS8udGVzdChjb2RlW2ldKSkg
aSsrO1xuICAgICAgICB3aGlsZSAoaSA8IGxlbiAmJiAvXFxkLy50ZXN0KGNvZGVbaV0pKSBpKys7
XG4gICAgICB9XG4gICAgICAvLyB0eXBlIHN1ZmZpeDogX2YzMiwgX2Y2NCwgX2kzMiwgX2k2NFxu
ICAgICAgaWYgKGNvZGVbaV0gPT09ICdfJyAmJiBpICsgMyA8PSBsZW4gJiYgL15bZmldLy50ZXN0
KGNvZGVbaSArIDFdKSkge1xuICAgICAgICBjb25zdCBzdWYgPSBjb2RlLnNsaWNlKGkgKyAxLCBp
ICsgNCk7XG4gICAgICAgIGlmIChBVFJBX1RZUEVTLmhhcyhzdWYpKSBpICs9IDQ7XG4gICAgICB9
XG4gICAgICB0b2tlbnMucHVzaCh7IHR5cGU6ICdudW0nLCB0ZXh0OiBjb2RlLnNsaWNlKHN0YXJ0
LCBpKSB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICAvLyBpZGVudGlmaWVycyAvIGtl
eXdvcmRzXG4gICAgaWYgKC9bYS16QS1aX10vLnRlc3QoY29kZVtpXSkpIHtcbiAgICAgIGNvbnN0
IHN0YXJ0ID0gaTtcbiAgICAgIHdoaWxlIChpIDwgbGVuICYmIC9bXFx3Ll0vLnRlc3QoY29kZVtp
XSkpIGkrKztcbiAgICAgIGNvbnN0IHdvcmQgPSBjb2RlLnNsaWNlKHN0YXJ0LCBpKTtcbiAgICAg
IGNvbnN0IGxvd2VyID0gd29yZC50b0xvd2VyQ2FzZSgpO1xuICAgICAgaWYgKEFUUkFfS0VZV09S
RFMuaGFzKGxvd2VyKSkge1xuICAgICAgICB0b2tlbnMucHVzaCh7IHR5cGU6ICdrdycsIHRleHQ6
IHdvcmQgfSk7XG4gICAgICB9IGVsc2UgaWYgKEFUUkFfVFlQRVMuaGFzKGxvd2VyKSkge1xuICAg
ICAgICAvLyB0eXBlIG5hbWVzIGFzIGJ1aWx0aW5zIHdoZW4gZm9sbG93ZWQgYnkgKFxuICAgICAg
ICBpZiAoaSA8IGxlbiAmJiBjb2RlW2ldID09PSAnKCcpIHtcbiAgICAgICAgICB0b2tlbnMucHVz
aCh7IHR5cGU6ICdmbicsIHRleHQ6IHdvcmQgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAg
ICAgdG9rZW5zLnB1c2goeyB0eXBlOiAnY29uc3QnLCB0ZXh0OiB3b3JkIH0pO1xuICAgICAgICB9
XG4gICAgICB9IGVsc2UgaWYgKEFUUkFfQlVJTFRJTlMuaGFzKGxvd2VyKSB8fCBsb3dlci5zdGFy
dHNXaXRoKCd3YXNtLicpIHx8XG4gICAgICAgICAgICAgICAgIGxvd2VyLnN0YXJ0c1dpdGgoJ3Yx
MjguJykgfHwgKEFUUkFfVkVDVE9SX1RZUEVTLmhhcyhsb3dlci5zcGxpdCgnLicpWzBdKSAmJiBs
b3dlci5pbmNsdWRlcygnLicpKSkge1xuICAgICAgICB0b2tlbnMucHVzaCh7IHR5cGU6ICdmbics
IHRleHQ6IHdvcmQgfSk7XG4gICAgICB9IGVsc2UgaWYgKGkgPCBsZW4gJiYgY29kZVtpXSA9PT0g
JygnKSB7XG4gICAgICAgIHRva2Vucy5wdXNoKHsgdHlwZTogJ2ZuJywgdGV4dDogd29yZCB9KTtc
biAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRva2Vucy5wdXNoKHsgdHlwZTogJ2lkJywgdGV4dDog
d29yZCB9KTtcbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICAvLyBtdWx0aS1j
aGFyIG9wZXJhdG9yc1xuICAgIGlmIChpICsgMSA8IGxlbikge1xuICAgICAgY29uc3QgdHdvID0g
Y29kZVtpXSArIGNvZGVbaSArIDFdO1xuICAgICAgaWYgKHR3byA9PT0gJyoqJyB8fCB0d28gPT09
ICc6PScgfHwgdHdvID09PSAnKz0nIHx8IHR3byA9PT0gJy09JyB8fFxuICAgICAgICAgIHR3byA9
PT0gJyo9JyB8fCB0d28gPT09ICcvPScgfHwgdHdvID09PSAnPT0nIHx8IHR3byA9PT0gJzw9JyB8
fFxuICAgICAgICAgIHR3byA9PT0gJz49JyB8fCB0d28gPT09ICc8PCcgfHwgdHdvID09PSAnPj4n
KSB7XG4gICAgICAgIHRva2Vucy5wdXNoKHsgdHlwZTogJ29wJywgdGV4dDogdHdvIH0pO1xuICAg
ICAgICBpICs9IDI7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgLy8gLz0gaXMg
bm90LWVxdWFsIChtdXN0IGNoZWNrIGl0J3Mgbm90IC89c29tZXRoaW5nIGFzIGRpdmlkZS1hc3Np
Z24g4oCUIGJ1dCBpbiBhdHJhIC89IGlzIG5vdC1lcXVhbClcbiAgICAgIGlmIChjb2RlW2ldID09
PSAnLycgJiYgY29kZVtpICsgMV0gPT09ICc9Jykge1xuICAgICAgICB0b2tlbnMucHVzaCh7IHR5
cGU6ICdvcCcsIHRleHQ6ICcvPScgfSk7XG4gICAgICAgIGkgKz0gMjtcbiAgICAgICAgY29udGlu
dWU7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIHNpbmdsZS1jaGFyIG9wZXJhdG9yc1xuICAgIGlm
ICgnKy0qLzw+PSZ8Xn4nLmluY2x1ZGVzKGNvZGVbaV0pKSB7XG4gICAgICB0b2tlbnMucHVzaCh7
IHR5cGU6ICdvcCcsIHRleHQ6IGNvZGVbaV0gfSk7XG4gICAgICBpKys7XG4gICAgICBjb250aW51
ZTtcbiAgICB9XG4gICAgLy8gcHVuY3R1YXRpb25cbiAgICBpZiAoJygpW107LDonLmluY2x1ZGVz
KGNvZGVbaV0pKSB7XG4gICAgICB0b2tlbnMucHVzaCh7IHR5cGU6ICdwdW5jJywgdGV4dDogY29k
ZVtpXSB9KTtcbiAgICAgIGkrKztcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICAvLyB3aGl0
ZXNwYWNlIC8gb3RoZXJcbiAgICB0b2tlbnMucHVzaCh7IHR5cGU6ICcnLCB0ZXh0OiBjb2RlW2ld
IH0pO1xuICAgIGkrKztcbiAgfVxuICByZXR1cm4gdG9rZW5zO1xufVxuXG5mdW5jdGlvbiBhdHJh
Q29tcGxldGlvbnMoKSB7XG4gIGNvbnN0IGl0ZW1zID0gW107XG4gIGZvciAoY29uc3QgdyBvZiBB
VFJBX0tFWVdPUkRTKSBpdGVtcy5wdXNoKHsgdGV4dDogdywga2luZDogJ2t3JyB9KTtcbiAgZm9y
IChjb25zdCB3IG9mIEFUUkFfVFlQRVMpICAgIGl0ZW1zLnB1c2goeyB0ZXh0OiB3LCBraW5kOiAn
Y29uc3QnIH0pO1xuICBmb3IgKGNvbnN0IHcgb2YgQVRSQV9CVUlMVElOUykgaXRlbXMucHVzaCh7
IHRleHQ6IHcsIGtpbmQ6ICdmbicgfSk7XG4gIHJldHVybiBpdGVtcztcbn1cblxuLy8g4pWQ4pWQ
4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ
4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ
4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ
4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQXG4vLyAyLiBD
T01QSUxFUiBUT0tFTklaRVJcbi8vIOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKV
kOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKV
kOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKV
kOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKV
kOKVkOKVkOKVkOKVkOKVkOKVkFxuXG5jb25zdCBUT0sgPSB7XG4gIE5VTTogJ251bScsIElEOiAn
aWQnLCBLVzogJ2t3JywgT1A6ICdvcCcsIFBVTkM6ICdwdW5jJywgRU9GOiAnZW9mJyxcbn07XG5c
bmZ1bmN0aW9uIGxleChzb3VyY2UpIHtcbiAgY29uc3QgdG9rZW5zID0gW107XG4gIGxldCBpID0g
MCwgbGluZSA9IDEsIGNvbCA9IDE7XG4gIGNvbnN0IGxlbiA9IHNvdXJjZS5sZW5ndGg7XG5cbiAg
ZnVuY3Rpb24gYWR2KCkgeyBpZiAoc291cmNlW2ldID09PSAnXFxuJykgeyBsaW5lKys7IGNvbCA9
IDE7IH0gZWxzZSB7IGNvbCsrOyB9IGkrKzsgfVxuICBmdW5jdGlvbiBwZWVrKCkgeyByZXR1cm4g
aSA8IGxlbiA/IHNvdXJjZVtpXSA6ICcnOyB9XG4gIGZ1bmN0aW9uIHBlZWsyKCkgeyByZXR1cm4g
aSArIDEgPCBsZW4gPyBzb3VyY2VbaV0gKyBzb3VyY2VbaSArIDFdIDogc291cmNlW2ldIHx8ICcn
OyB9XG5cbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAvLyBza2lwIHdoaXRlc3BhY2UgYW5kIHNl
bWljb2xvbnNcbiAgICBpZiAoJyBcXHRcXHJcXG47Jy5pbmNsdWRlcyhzb3VyY2VbaV0pKSB7IGFk
digpOyBjb250aW51ZTsgfVxuICAgIC8vIGNvbW1lbnRcbiAgICBpZiAoc291cmNlW2ldID09PSAn
IScpIHtcbiAgICAgIHdoaWxlIChpIDwgbGVuICYmIHNvdXJjZVtpXSAhPT0gJ1xcbicpIGFkdigp
O1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IHRsID0gbGluZSwgdGMgPSBjb2w7
XG4gICAgLy8gbnVtYmVyXG4gICAgaWYgKC9cXGQvLnRlc3Qoc291cmNlW2ldKSB8fCAoc291cmNl
W2ldID09PSAnLicgJiYgaSArIDEgPCBsZW4gJiYgL1xcZC8udGVzdChzb3VyY2VbaSArIDFdKSkp
IHtcbiAgICAgIGNvbnN0IHN0YXJ0ID0gaTtcbiAgICAgIGxldCBpc0Zsb2F0ID0gZmFsc2U7XG4g
ICAgICB3aGlsZSAoaSA8IGxlbiAmJiAvXFxkLy50ZXN0KHNvdXJjZVtpXSkpIGFkdigpO1xuICAg
ICAgaWYgKHBlZWsoKSA9PT0gJy4nICYmIC9cXGQvLnRlc3Qoc291cmNlW2kgKyAxXSB8fCAnJykp
IHsgaXNGbG9hdCA9IHRydWU7IGFkdigpOyB3aGlsZSAoaSA8IGxlbiAmJiAvXFxkLy50ZXN0KHNv
dXJjZVtpXSkpIGFkdigpOyB9XG4gICAgICBpZiAoL1tlRV0vLnRlc3QocGVlaygpKSkgeyBpc0Zs
b2F0ID0gdHJ1ZTsgYWR2KCk7IGlmICgvWystXS8udGVzdChwZWVrKCkpKSBhZHYoKTsgd2hpbGUg
KGkgPCBsZW4gJiYgL1xcZC8udGVzdChzb3VyY2VbaV0pKSBhZHYoKTsgfVxuICAgICAgbGV0IHR5
cGVTdWZmaXggPSBudWxsO1xuICAgICAgaWYgKHBlZWsoKSA9PT0gJ18nKSB7XG4gICAgICAgIGNv
bnN0IHMgPSBzb3VyY2Uuc2xpY2UoaSArIDEsIGkgKyA0KTtcbiAgICAgICAgaWYgKEFUUkFfVFlQ
RVMuaGFzKHMpKSB7IHR5cGVTdWZmaXggPSBzOyBhZHYoKTsgYWR2KCk7IGFkdigpOyBhZHYoKTsg
fVxuICAgICAgfVxuICAgICAgY29uc3QgcmF3ID0gc291cmNlLnNsaWNlKHN0YXJ0LCBpKTtcbiAg
ICAgIHRva2Vucy5wdXNoKHsgdHlwZTogVE9LLk5VTSwgdmFsdWU6IHJhdywgaXNGbG9hdCwgdHlw
ZVN1ZmZpeCwgbGluZTogdGwsIGNvbDogdGMgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4g
ICAgLy8gaWRlbnRpZmllciAoZG90cyBhbGxvd2VkIOKAlCBuYW1lc3BhY2VzIGJ5IGNvbnZlbnRp
b24pXG4gICAgaWYgKC9bYS16QS1aX10vLnRlc3Qoc291cmNlW2ldKSkge1xuICAgICAgY29uc3Qg
c3RhcnQgPSBpO1xuICAgICAgd2hpbGUgKGkgPCBsZW4gJiYgL1tcXHcuXS8udGVzdChzb3VyY2Vb
aV0pKSBhZHYoKTtcbiAgICAgIC8vIHRyaW0gdHJhaWxpbmcgZG90IChlLmcuIFwibmFtZS5cIiBh
dCBlbmQgb2YgaW5wdXQpXG4gICAgICB3aGlsZSAoaSA+IHN0YXJ0ICsgMSAmJiBzb3VyY2VbaSAt
IDFdID09PSAnLicpIHsgaS0tOyBjb2wtLTsgfVxuICAgICAgbGV0IHZhbCA9IHNvdXJjZS5zbGlj
ZShzdGFydCwgaSk7XG4gICAgICAvLyBpbnRlcnBvbGF0aW9uIG1hcmtlcnM6IF9fSU5URVJQX05f
X1xuICAgICAgaWYgKC9eX19JTlRFUlBfXFxkK19fJC8udGVzdCh2YWwpKSB7XG4gICAgICAgIHRv
a2Vucy5wdXNoKHsgdHlwZTogVE9LLklELCB2YWx1ZTogdmFsLCBpbnRlcnA6IHRydWUsIGxpbmU6
IHRsLCBjb2w6IHRjIH0pO1xuICAgICAgfSBlbHNlIGlmIChBVFJBX0tFWVdPUkRTLmhhcyh2YWwp
IHx8IEFUUkFfVFlQRVMuaGFzKHZhbCkpIHtcbiAgICAgICAgdG9rZW5zLnB1c2goeyB0eXBlOiBU
T0suS1csIHZhbHVlOiB2YWwsIGxpbmU6IHRsLCBjb2w6IHRjIH0pO1xuICAgICAgfSBlbHNlIHtc
biAgICAgICAgdG9rZW5zLnB1c2goeyB0eXBlOiBUT0suSUQsIHZhbHVlOiB2YWwsIGxpbmU6IHRs
LCBjb2w6IHRjIH0pO1xuICAgICAgfVxuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIC8vIG11
bHRpLWNoYXIgb3BlcmF0b3JzXG4gICAgY29uc3QgdHcgPSBwZWVrMigpO1xuICAgIGlmICh0dyA9
PT0gJyoqJyB8fCB0dyA9PT0gJzo9JyB8fCB0dyA9PT0gJys9JyB8fCB0dyA9PT0gJy09JyB8fCB0
dyA9PT0gJyo9JyB8fFxuICAgICAgICB0dyA9PT0gJz09JyB8fCB0dyA9PT0gJzw9JyB8fCB0dyA9
PT0gJz49JyB8fCB0dyA9PT0gJzw8JyB8fCB0dyA9PT0gJz4+Jykge1xuICAgICAgdG9rZW5zLnB1
c2goeyB0eXBlOiBUT0suT1AsIHZhbHVlOiB0dywgbGluZTogdGwsIGNvbDogdGMgfSk7XG4gICAg
ICBhZHYoKTsgYWR2KCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgLy8gLz0g4oCUIHRo
aXMgaXMgbm90LWVxdWFsIGluIGF0cmFcbiAgICBpZiAoc291cmNlW2ldID09PSAnLycgJiYgc291
cmNlW2kgKyAxXSA9PT0gJz0nKSB7XG4gICAgICB0b2tlbnMucHVzaCh7IHR5cGU6IFRPSy5PUCwg
dmFsdWU6ICcvPScsIGxpbmU6IHRsLCBjb2w6IHRjIH0pO1xuICAgICAgYWR2KCk7IGFkdigpO1xu
ICAgICAgY29udGludWU7XG4gICAgfVxuICAgIC8vIHNpbmdsZS1jaGFyIG9wZXJhdG9yc1xuICAg
IGlmICgnKy0qLzw+PSZ8Xn4nLmluY2x1ZGVzKHNvdXJjZVtpXSkpIHtcbiAgICAgIHRva2Vucy5w
dXNoKHsgdHlwZTogVE9LLk9QLCB2YWx1ZTogc291cmNlW2ldLCBsaW5lOiB0bCwgY29sOiB0YyB9
KTtcbiAgICAgIGFkdigpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIC8vIHB1bmN0dWF0
aW9uXG4gICAgaWYgKCcoKVtdOyw6Jy5pbmNsdWRlcyhzb3VyY2VbaV0pKSB7XG4gICAgICB0b2tl
bnMucHVzaCh7IHR5cGU6IFRPSy5QVU5DLCB2YWx1ZTogc291cmNlW2ldLCBsaW5lOiB0bCwgY29s
OiB0YyB9KTtcbiAgICAgIGFkdigpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIC8vIHNr
aXAgdW5rbm93blxuICAgIGFkdigpO1xuICB9XG4gIHRva2Vucy5wdXNoKHsgdHlwZTogVE9LLkVP
RiwgdmFsdWU6ICcnLCBsaW5lLCBjb2wgfSk7XG4gIHJldHVybiB0b2tlbnM7XG59XG5cbi8vIOKV
kOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKV
kOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKV
kOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKV
kOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkFxuLy8g
My4gUEFSU0VSXG4vLyDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDi
lZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDi
lZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDi
lZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDi
lZDilZDilZDilZBcblxuZnVuY3Rpb24gcGFyc2UodG9rZW5zKSB7XG4gIGxldCBwb3MgPSAwO1xu
ICBmdW5jdGlvbiBjdXIoKSB7IHJldHVybiB0b2tlbnNbcG9zXTsgfVxuICBmdW5jdGlvbiBhdCh0
eXBlLCB2YWx1ZSkgeyBjb25zdCB0ID0gY3VyKCk7IHJldHVybiB0LnR5cGUgPT09IHR5cGUgJiYg
KHZhbHVlID09PSB1bmRlZmluZWQgfHwgdC52YWx1ZSA9PT0gdmFsdWUpOyB9XG4gIGZ1bmN0aW9u
IGVhdCh0eXBlLCB2YWx1ZSkge1xuICAgIGNvbnN0IHQgPSBjdXIoKTtcbiAgICBpZiAodC50eXBl
ICE9PSB0eXBlIHx8ICh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHQudmFsdWUgIT09IHZhbHVlKSlc
biAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgRXhwZWN0ZWQgJHt2YWx1ZSB8fCB0eXBlfSBi
dXQgZ290IFwiJHt0LnZhbHVlfVwiIGF0ICR7dC5saW5lfToke3QuY29sfWApO1xuICAgIHBvcysr
O1xuICAgIHJldHVybiB0O1xuICB9XG4gIGZ1bmN0aW9uIG1heWJlKHR5cGUsIHZhbHVlKSB7IGlm
IChhdCh0eXBlLCB2YWx1ZSkpIHsgcG9zKys7IHJldHVybiB0cnVlOyB9IHJldHVybiBmYWxzZTsg
fVxuXG4gIGZ1bmN0aW9uIHBhcnNlUHJvZ3JhbSgpIHtcbiAgICBjb25zdCBib2R5ID0gW107XG4g
ICAgd2hpbGUgKCFhdChUT0suRU9GKSkge1xuICAgICAgaWYgKGF0KFRPSy5LVywgJ2NvbnN0Jykg
JiYgIWlzTG9jYWxDb250ZXh0KCkpIGJvZHkucHVzaChwYXJzZUdsb2JhbENvbnN0KCkpO1xuICAg
ICAgZWxzZSBpZiAoYXQoVE9LLktXLCAndmFyJykgJiYgIWlzTG9jYWxDb250ZXh0KCkpIGJvZHku
cHVzaChwYXJzZUdsb2JhbFZhcigpKTtcbiAgICAgIGVsc2UgaWYgKGF0KFRPSy5LVywgJ2Z1bmN0
aW9uJykpIGJvZHkucHVzaChwYXJzZUZ1bmN0aW9uKCkpO1xuICAgICAgZWxzZSBpZiAoYXQoVE9L
LktXLCAnc3Vicm91dGluZScpKSBib2R5LnB1c2gocGFyc2VTdWJyb3V0aW5lKCkpO1xuICAgICAg
ZWxzZSBpZiAoYXQoVE9LLktXLCAnaW1wb3J0JykpIGJvZHkucHVzaChwYXJzZUltcG9ydCgpKTtc
biAgICAgIGVsc2UgaWYgKGF0KFRPSy5LVywgJ2V4cG9ydCcpKSB7IHBvcysrOyBib2R5LnB1c2go
cGFyc2VGdW5jdGlvbih0cnVlKSk7IH1cbiAgICAgIGVsc2UgdGhyb3cgbmV3IFN5bnRheEVycm9y
KGBVbmV4cGVjdGVkIFwiJHtjdXIoKS52YWx1ZX1cIiBhdCAke2N1cigpLmxpbmV9OiR7Y3VyKCku
Y29sfWApO1xuICAgIH1cbiAgICByZXR1cm4geyB0eXBlOiAnUHJvZ3JhbScsIGJvZHkgfTtcbiAg
fVxuXG4gIGZ1bmN0aW9uIGlzTG9jYWxDb250ZXh0KCkgeyByZXR1cm4gZmFsc2U7IH0gLy8gZ2xv
YmFscyBvbmx5IGF0IHRvcCBsZXZlbFxuXG4gIC8vIFBhcnNlIGZ1bmN0aW9uIHR5cGUgc2lnbmF0
dXJlOiBmdW5jdGlvbih4OiBmNjQsIHk6IGY2NCk6IGY2NFxuICBmdW5jdGlvbiBwYXJzZUZ1bmNU
eXBlU2lnKCkge1xuICAgIGVhdChUT0suS1csICdmdW5jdGlvbicpO1xuICAgIGVhdChUT0suUFVO
QywgJygnKTtcbiAgICBjb25zdCBwYXJhbXMgPSBhdChUT0suUFVOQywgJyknKSA/IFtdIDogcGFy
c2VQYXJhbUVudHJpZXMoKTtcbiAgICBlYXQoVE9LLlBVTkMsICcpJyk7XG4gICAgbGV0IHJldFR5
cGUgPSBudWxsO1xuICAgIGlmIChtYXliZShUT0suUFVOQywgJzonKSkgcmV0VHlwZSA9IGVhdChU
T0suS1cpLnZhbHVlO1xuICAgIHJldHVybiB7IHBhcmFtcywgcmV0VHlwZSB9O1xuICB9XG5cbiAg
ZnVuY3Rpb24gcGFyc2VHbG9iYWxDb25zdCgpIHtcbiAgICBlYXQoVE9LLktXLCAnY29uc3QnKTtc
biAgICBjb25zdCBuYW1lID0gZWF0KFRPSy5JRCkudmFsdWU7XG4gICAgZWF0KFRPSy5QVU5DLCAn
OicpO1xuICAgIGNvbnN0IHZ0eXBlID0gZWF0KFRPSy5LVykudmFsdWU7XG4gICAgZWF0KFRPSy5P
UCwgJz0nKTtcbiAgICBjb25zdCBpbml0ID0gcGFyc2VFeHByKDApO1xuICAgIHJldHVybiB7IHR5
cGU6ICdDb25zdERlY2wnLCBuYW1lLCB2dHlwZSwgaW5pdCB9O1xuICB9XG5cbiAgZnVuY3Rpb24g
cGFyc2VHbG9iYWxWYXIoKSB7XG4gICAgZWF0KFRPSy5LVywgJ3ZhcicpO1xuICAgIGNvbnN0IG5h
bWUgPSBlYXQoVE9LLklEKS52YWx1ZTtcbiAgICBlYXQoVE9LLlBVTkMsICc6Jyk7XG4gICAgaWYg
KGF0KFRPSy5LVywgJ2Z1bmN0aW9uJykpIHtcbiAgICAgIGNvbnN0IGZ1bmNTaWcgPSBwYXJzZUZ1
bmNUeXBlU2lnKCk7XG4gICAgICBsZXQgaW5pdCA9IG51bGw7XG4gICAgICBpZiAobWF5YmUoVE9L
Lk9QLCAnPScpKSBpbml0ID0gcGFyc2VFeHByKDApO1xuICAgICAgcmV0dXJuIHsgdHlwZTogJ1Zh
ckRlY2wnLCBuYW1lLCB2dHlwZTogJ2kzMicsIGZ1bmNTaWcsIGluaXQgfTtcbiAgICB9XG4gICAg
Y29uc3QgdnR5cGUgPSBlYXQoVE9LLktXKS52YWx1ZTtcbiAgICBsZXQgaW5pdCA9IG51bGw7XG4g
ICAgaWYgKG1heWJlKFRPSy5PUCwgJz0nKSkgaW5pdCA9IHBhcnNlRXhwcigwKTtcbiAgICByZXR1
cm4geyB0eXBlOiAnVmFyRGVjbCcsIG5hbWUsIHZ0eXBlLCBpbml0IH07XG4gIH1cblxuICBmdW5j
dGlvbiBwYXJzZUltcG9ydCgpIHtcbiAgICBlYXQoVE9LLktXLCAnaW1wb3J0Jyk7XG4gICAgLy8g
aW1wb3J0IGZ1bmN0aW9uIG5hbWUocGFyYW1zKTogcmV0VHlwZSBmcm9tICdtb2R1bGUnXG4gICAg
Ly8gaW1wb3J0IG5hbWUgPSAke2ludGVycH1cbiAgICAvLyBpbXBvcnQgbmFtZShwYXJhbXMpOiBy
ZXRUeXBlID0gJHtpbnRlcnB9XG4gICAgaWYgKGF0KFRPSy5LVywgJ2Z1bmN0aW9uJykpIHtcbiAg
ICAgIHBvcysrO1xuICAgIH1cbiAgICBjb25zdCBuYW1lID0gZWF0KFRPSy5JRCkudmFsdWU7XG4g
ICAgbGV0IHBhcmFtcyA9IFtdLCByZXRUeXBlID0gbnVsbCwgbW9kdWxlTmFtZSA9ICdob3N0Jywg
aW50ZXJwSWR4ID0gbnVsbDtcbiAgICBpZiAoYXQoVE9LLlBVTkMsICcoJykpIHtcbiAgICAgIHBh
cmFtcyA9IHBhcnNlUGFyYW1MaXN0KCk7XG4gICAgfVxuICAgIGlmIChtYXliZShUT0suUFVOQywg
JzonKSkge1xuICAgICAgcmV0VHlwZSA9IGVhdChUT0suS1cpLnZhbHVlO1xuICAgIH1cbiAgICBp
ZiAobWF5YmUoVE9LLk9QLCAnPScpKSB7XG4gICAgICAvLyBpbnRlcnBvbGF0aW9uIG1hcmtlclxu
ICAgICAgY29uc3QgdCA9IGVhdChUT0suSUQpO1xuICAgICAgaW50ZXJwSWR4ID0gdC52YWx1ZTtc
biAgICB9IGVsc2UgaWYgKG1heWJlKFRPSy5LVywgJ2Zyb20nKSkge1xuICAgICAgLy8gJ21vZHVs
ZScg4oCUIHdlIGp1c3QgcmVhZCB0aGUgaWRlbnRpZmllciBhcyBhIHN0cmluZy1saWtlIHRoaW5n
XG4gICAgICBtb2R1bGVOYW1lID0gZWF0KFRPSy5JRCkudmFsdWU7XG4gICAgfVxuICAgIHJldHVy
biB7IHR5cGU6ICdJbXBvcnREZWNsJywgbmFtZSwgcGFyYW1zLCByZXRUeXBlLCBtb2R1bGVOYW1l
LCBpbnRlcnBJZHggfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlRnVuY3Rpb24oZXhwb3J0ZWQg
PSBmYWxzZSkge1xuICAgIGVhdChUT0suS1csICdmdW5jdGlvbicpO1xuICAgIGNvbnN0IG5hbWUg
PSBlYXQoVE9LLklEKS52YWx1ZTtcbiAgICBlYXQoVE9LLlBVTkMsICcoJyk7XG4gICAgY29uc3Qg
cGFyYW1zID0gYXQoVE9LLlBVTkMsICcpJykgPyBbXSA6IHBhcnNlUGFyYW1FbnRyaWVzKCk7XG4g
ICAgZWF0KFRPSy5QVU5DLCAnKScpO1xuICAgIGVhdChUT0suUFVOQywgJzonKTtcbiAgICBjb25z
dCByZXRUeXBlID0gZWF0KFRPSy5LVykudmFsdWU7XG4gICAgY29uc3QgbG9jYWxzID0gW107XG4g
ICAgaWYgKGF0KFRPSy5LVywgJ3ZhcicpKSB7XG4gICAgICBwb3MrKztcbiAgICAgIHdoaWxlICgh
YXQoVE9LLktXLCAnYmVnaW4nKSkge1xuICAgICAgICBjb25zdCBsbmFtZXMgPSBbZWF0KFRPSy5J
RCkudmFsdWVdO1xuICAgICAgICB3aGlsZSAobWF5YmUoVE9LLlBVTkMsICcsJykpIGxuYW1lcy5w
dXNoKGVhdChUT0suSUQpLnZhbHVlKTtcbiAgICAgICAgZWF0KFRPSy5QVU5DLCAnOicpO1xuICAg
ICAgICBpZiAoYXQoVE9LLktXLCAnZnVuY3Rpb24nKSkge1xuICAgICAgICAgIGNvbnN0IGZ1bmNT
aWcgPSBwYXJzZUZ1bmNUeXBlU2lnKCk7XG4gICAgICAgICAgZm9yIChjb25zdCBsbiBvZiBsbmFt
ZXMpIGxvY2Fscy5wdXNoKHsgdHlwZTogJ0xvY2FsJywgbmFtZTogbG4sIHZ0eXBlOiAnaTMyJywg
ZnVuY1NpZyB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBsdCA9IGVhdChU
T0suS1cpLnZhbHVlO1xuICAgICAgICAgIGZvciAoY29uc3QgbG4gb2YgbG5hbWVzKSBsb2NhbHMu
cHVzaCh7IHR5cGU6ICdMb2NhbCcsIG5hbWU6IGxuLCB2dHlwZTogbHQgfSk7XG4gICAgICAgIH1c
biAgICAgIH1cbiAgICB9XG4gICAgZWF0KFRPSy5LVywgJ2JlZ2luJyk7XG4gICAgY29uc3QgYm9k
eSA9IHBhcnNlU3RhdGVtZW50cygnZW5kJyk7XG4gICAgZWF0KFRPSy5LVywgJ2VuZCcpO1xuICAg
IHJldHVybiB7IHR5cGU6ICdGdW5jdGlvbicsIG5hbWUsIHBhcmFtcywgcmV0VHlwZSwgbG9jYWxz
LCBib2R5LCBleHBvcnRlZCB9O1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VTdWJyb3V0aW5lKCkg
e1xuICAgIGVhdChUT0suS1csICdzdWJyb3V0aW5lJyk7XG4gICAgY29uc3QgbmFtZSA9IGVhdChU
T0suSUQpLnZhbHVlO1xuICAgIGVhdChUT0suUFVOQywgJygnKTtcbiAgICBjb25zdCBwYXJhbXMg
PSBhdChUT0suUFVOQywgJyknKSA/IFtdIDogcGFyc2VQYXJhbUVudHJpZXMoKTtcbiAgICBlYXQo
VE9LLlBVTkMsICcpJyk7XG4gICAgY29uc3QgbG9jYWxzID0gW107XG4gICAgaWYgKGF0KFRPSy5L
VywgJ3ZhcicpKSB7XG4gICAgICBwb3MrKztcbiAgICAgIHdoaWxlICghYXQoVE9LLktXLCAnYmVn
aW4nKSkge1xuICAgICAgICBjb25zdCBsbmFtZXMgPSBbZWF0KFRPSy5JRCkudmFsdWVdO1xuICAg
ICAgICB3aGlsZSAobWF5YmUoVE9LLlBVTkMsICcsJykpIGxuYW1lcy5wdXNoKGVhdChUT0suSUQp
LnZhbHVlKTtcbiAgICAgICAgZWF0KFRPSy5QVU5DLCAnOicpO1xuICAgICAgICBpZiAoYXQoVE9L
LktXLCAnZnVuY3Rpb24nKSkge1xuICAgICAgICAgIGNvbnN0IGZ1bmNTaWcgPSBwYXJzZUZ1bmNU
eXBlU2lnKCk7XG4gICAgICAgICAgZm9yIChjb25zdCBsbiBvZiBsbmFtZXMpIGxvY2Fscy5wdXNo
KHsgdHlwZTogJ0xvY2FsJywgbmFtZTogbG4sIHZ0eXBlOiAnaTMyJywgZnVuY1NpZyB9KTtcbiAg
ICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBsdCA9IGVhdChUT0suS1cpLnZhbHVlO1xu
ICAgICAgICAgIGZvciAoY29uc3QgbG4gb2YgbG5hbWVzKSBsb2NhbHMucHVzaCh7IHR5cGU6ICdM
b2NhbCcsIG5hbWU6IGxuLCB2dHlwZTogbHQgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9
XG4gICAgZWF0KFRPSy5LVywgJ2JlZ2luJyk7XG4gICAgY29uc3QgYm9keSA9IHBhcnNlU3RhdGVt
ZW50cygnZW5kJyk7XG4gICAgZWF0KFRPSy5LVywgJ2VuZCcpO1xuICAgIHJldHVybiB7IHR5cGU6
ICdTdWJyb3V0aW5lJywgbmFtZSwgcGFyYW1zLCBsb2NhbHMsIGJvZHkgfTtcbiAgfVxuXG4gIGZ1
bmN0aW9uIHBhcnNlUGFyYW1FbnRyaWVzKCkge1xuICAgIGNvbnN0IHBhcmFtcyA9IFtdO1xuICAg
IHdoaWxlIChjdXIoKS50eXBlID09PSBUT0suSUQpIHtcbiAgICAgIC8vIENvbGxlY3QgY29tbWEt
c2VwYXJhdGVkIG5hbWVzIHRoYXQgc2hhcmUgYSB0eXBlXG4gICAgICBjb25zdCBuYW1lcyA9IFtl
YXQoVE9LLklEKS52YWx1ZV07XG4gICAgICB3aGlsZSAoYXQoVE9LLlBVTkMsICcsJykgJiYgdG9r
ZW5zW3BvcyArIDFdICYmIHRva2Vuc1twb3MgKyAxXS50eXBlID09PSBUT0suSUQgJiZcbiAgICAg
ICAgICAgICB0b2tlbnNbcG9zICsgMl0gJiYgKHRva2Vuc1twb3MgKyAyXS52YWx1ZSA9PT0gJywn
IHx8IHRva2Vuc1twb3MgKyAyXS52YWx1ZSA9PT0gJzonKSkge1xuICAgICAgICBwb3MrKzsgLy8g
c2tpcCAsXG4gICAgICAgIG5hbWVzLnB1c2goZWF0KFRPSy5JRCkudmFsdWUpO1xuICAgICAgfVxu
ICAgICAgZWF0KFRPSy5QVU5DLCAnOicpO1xuICAgICAgLy8gZnVuY3Rpb24gdHlwZTogY2FsbGJh
Y2s6IGZ1bmN0aW9uKHg6IGY2NCk6IGY2NFxuICAgICAgaWYgKGF0KFRPSy5LVywgJ2Z1bmN0aW9u
JykpIHtcbiAgICAgICAgY29uc3QgZnVuY1NpZyA9IHBhcnNlRnVuY1R5cGVTaWcoKTtcbiAgICAg
ICAgZm9yIChjb25zdCBuIG9mIG5hbWVzKSBwYXJhbXMucHVzaCh7IHR5cGU6ICdQYXJhbScsIG5h
bWU6IG4sIHZ0eXBlOiAnaTMyJywgaXNBcnJheTogZmFsc2UsIGFycmF5RGltczogbnVsbCwgZnVu
Y1NpZyB9KTtcbiAgICAgICAgbWF5YmUoVE9LLlBVTkMsICcsJyk7IC8vIGNvbnN1bWUgY29tbWEg
YmV0d2VlbiBwYXJhbSBncm91cHNcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBs
ZXQgaXNBcnJheSA9IGZhbHNlLCBhcnJheURpbXMgPSBudWxsO1xuICAgICAgaWYgKGF0KFRPSy5L
VywgJ2FycmF5JykpIHtcbiAgICAgICAgcG9zKys7XG4gICAgICAgIGlzQXJyYXkgPSB0cnVlO1xu
ICAgICAgICBpZiAoYXQoVE9LLlBVTkMsICcoJykpIHtcbiAgICAgICAgICBwb3MrKztcbiAgICAg
ICAgICBhcnJheURpbXMgPSBbXTtcbiAgICAgICAgICBhcnJheURpbXMucHVzaChwYXJzZUV4cHIo
MCkpO1xuICAgICAgICAgIHdoaWxlIChtYXliZShUT0suUFVOQywgJywnKSkgYXJyYXlEaW1zLnB1
c2gocGFyc2VFeHByKDApKTtcbiAgICAgICAgICBlYXQoVE9LLlBVTkMsICcpJyk7XG4gICAgICAg
IH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IHZ0eXBlID0gZWF0KFRPSy5LVykudmFsdWU7XG4gICAg
ICBmb3IgKGNvbnN0IG4gb2YgbmFtZXMpIHBhcmFtcy5wdXNoKHsgdHlwZTogJ1BhcmFtJywgbmFt
ZTogbiwgdnR5cGUsIGlzQXJyYXksIGFycmF5RGltcyB9KTtcbiAgICAgIG1heWJlKFRPSy5QVU5D
LCAnLCcpOyAvLyBjb25zdW1lIGNvbW1hIGJldHdlZW4gcGFyYW0gZ3JvdXBzXG4gICAgfVxuICAg
IHJldHVybiBwYXJhbXM7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVBhcmFtTGlzdCgpIHtcbiAg
ICAvLyBzaW1wbGlmaWVkIHBhcmFtIGxpc3QgZm9yIGltcG9ydHM6IG5hbWU6IHR5cGUsIC4uLlxu
ICAgIGVhdChUT0suUFVOQywgJygnKTtcbiAgICBjb25zdCBwYXJhbXMgPSBbXTtcbiAgICB3aGls
ZSAoY3VyKCkudHlwZSA9PT0gVE9LLklEKSB7XG4gICAgICBjb25zdCBuYW1lcyA9IFtlYXQoVE9L
LklEKS52YWx1ZV07XG4gICAgICB3aGlsZSAoYXQoVE9LLlBVTkMsICcsJykgJiYgdG9rZW5zW3Bv
cyArIDFdICYmIHRva2Vuc1twb3MgKyAxXS50eXBlID09PSBUT0suSUQgJiZcbiAgICAgICAgICAg
ICB0b2tlbnNbcG9zICsgMl0gJiYgKHRva2Vuc1twb3MgKyAyXS52YWx1ZSA9PT0gJywnIHx8IHRv
a2Vuc1twb3MgKyAyXS52YWx1ZSA9PT0gJzonKSkge1xuICAgICAgICBwb3MrKztcbiAgICAgICAg
bmFtZXMucHVzaChlYXQoVE9LLklEKS52YWx1ZSk7XG4gICAgICB9XG4gICAgICBlYXQoVE9LLlBV
TkMsICc6Jyk7XG4gICAgICBjb25zdCB2dHlwZSA9IGVhdChUT0suS1cpLnZhbHVlO1xuICAgICAg
Zm9yIChjb25zdCBuIG9mIG5hbWVzKSBwYXJhbXMucHVzaCh7IHR5cGU6ICdQYXJhbScsIG5hbWU6
IG4sIHZ0eXBlLCBpc0FycmF5OiBmYWxzZSwgYXJyYXlEaW1zOiBudWxsIH0pO1xuICAgICAgbWF5
YmUoVE9LLlBVTkMsICcsJyk7IC8vIGNvbnN1bWUgY29tbWEgYmV0d2VlbiBwYXJhbSBncm91cHNc
biAgICB9XG4gICAgZWF0KFRPSy5QVU5DLCAnKScpO1xuICAgIHJldHVybiBwYXJhbXM7XG4gIH1c
blxuICBmdW5jdGlvbiBwYXJzZVN0YXRlbWVudHMoZW5kS3cpIHtcbiAgICBjb25zdCBzdG10cyA9
IFtdO1xuICAgIHdoaWxlICghYXQoVE9LLktXLCBlbmRLdykgJiYgIWF0KFRPSy5FT0YpKSB7XG4g
ICAgICAvLyBhbHNvIHN0b3AgYXQgJ2Vsc2UnIGZvciBpZiBibG9ja3NcbiAgICAgIGlmIChlbmRL
dyA9PT0gJ2VuZCcgJiYgKGF0KFRPSy5LVywgJ2Vsc2UnKSkpIGJyZWFrO1xuICAgICAgc3RtdHMu
cHVzaChwYXJzZVN0YXRlbWVudCgpKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0bXRzO1xuICB9XG5c
biAgZnVuY3Rpb24gcGFyc2VTdGF0ZW1lbnQoKSB7XG4gICAgaWYgKGF0KFRPSy5LVywgJ2lmJykp
IHJldHVybiBwYXJzZUlmKCk7XG4gICAgaWYgKGF0KFRPSy5LVywgJ2ZvcicpKSByZXR1cm4gcGFy
c2VGb3IoKTtcbiAgICBpZiAoYXQoVE9LLktXLCAnd2hpbGUnKSkgcmV0dXJuIHBhcnNlV2hpbGUo
KTtcbiAgICBpZiAoYXQoVE9LLktXLCAnZG8nKSkgcmV0dXJuIHBhcnNlRG9XaGlsZSgpO1xuICAg
IGlmIChhdChUT0suS1csICdicmVhaycpKSB7IHBvcysrOyByZXR1cm4geyB0eXBlOiAnQnJlYWsn
IH07IH1cbiAgICBpZiAoYXQoVE9LLktXLCAndGFpbGNhbGwnKSkgeyBwb3MrKzsgY29uc3QgbmFt
ZSA9IGVhdChUT0suSUQpLnZhbHVlOyBlYXQoVE9LLlBVTkMsICcoJyk7IGNvbnN0IGFyZ3MgPSBw
YXJzZUFyZ3MoKTsgZWF0KFRPSy5QVU5DLCAnKScpOyByZXR1cm4geyB0eXBlOiAnVGFpbENhbGwn
LCBuYW1lLCBhcmdzIH07IH1cbiAgICBpZiAoYXQoVE9LLktXLCAnY2FsbCcpKSB7IHBvcysrOyBj
b25zdCBuYW1lID0gYXQoVE9LLktXLCAncmV0dXJuJykgPyAocG9zKyssICdyZXR1cm4nKSA6IGVh
dChUT0suSUQpLnZhbHVlOyBlYXQoVE9LLlBVTkMsICcoJyk7IGNvbnN0IGFyZ3MgPSBwYXJzZUFy
Z3MoKTsgZWF0KFRPSy5QVU5DLCAnKScpOyByZXR1cm4geyB0eXBlOiAnQ2FsbCcsIG5hbWUsIGFy
Z3MgfTsgfVxuXG4gICAgLy8gYXNzaWdubWVudCBvciBleHByZXNzaW9uIHN0YXRlbWVudFxuICAg
IC8vIGxvb2sgYWhlYWQ6IGlkIDo9IC8gaWRbLi4uXSA6PSAvIGlkICs9IGV0Yy5cbiAgICBpZiAo
Y3VyKCkudHlwZSA9PT0gVE9LLklEKSB7XG4gICAgICBjb25zdCBuYW1lID0gY3VyKCkudmFsdWU7
XG4gICAgICAvLyBjaGVjayBmb3IgYXJyYXkgc3RvcmU6IGlkW1xuICAgICAgaWYgKHRva2Vuc1tw
b3MgKyAxXSAmJiB0b2tlbnNbcG9zICsgMV0udmFsdWUgPT09ICdbJykge1xuICAgICAgICBwb3Mr
KztcbiAgICAgICAgZWF0KFRPSy5QVU5DLCAnWycpO1xuICAgICAgICBjb25zdCBpbmRpY2VzID0g
W3BhcnNlRXhwcigwKV07XG4gICAgICAgIHdoaWxlIChtYXliZShUT0suUFVOQywgJywnKSkgaW5k
aWNlcy5wdXNoKHBhcnNlRXhwcigwKSk7XG4gICAgICAgIGVhdChUT0suUFVOQywgJ10nKTtcbiAg
ICAgICAgaWYgKGF0KFRPSy5PUCwgJzo9JykpIHtcbiAgICAgICAgICBwb3MrKztcbiAgICAgICAg
ICBjb25zdCB2YWx1ZSA9IHBhcnNlRXhwcigwKTtcbiAgICAgICAgICByZXR1cm4geyB0eXBlOiAn
QXJyYXlTdG9yZScsIG5hbWUsIGluZGljZXMsIHZhbHVlIH07XG4gICAgICAgIH1cbiAgICAgICAg
Ly8gY29tcG91bmQgYXNzaWdubWVudCBvbiBhcnJheVxuICAgICAgICBjb25zdCBjb3AgPSBjdXIo
KS52YWx1ZTtcbiAgICAgICAgaWYgKGNvcCA9PT0gJys9JyB8fCBjb3AgPT09ICctPScgfHwgY29w
ID09PSAnKj0nIHx8IGNvcCA9PT0gJy89Jykge1xuICAgICAgICAgIC8vIE5vdGU6IC89IGlzIGFt
YmlndW91cyDigJQgYXMgYSBzdGF0ZW1lbnQgc3RhcnQgYWZ0ZXIgYXJyYXkgYWNjZXNzLCBpdCdz
IGNvbXBvdW5kIGFzc2lnblxuICAgICAgICAgIHBvcysrO1xuICAgICAgICAgIGNvbnN0IHJocyA9
IHBhcnNlRXhwcigwKTtcbiAgICAgICAgICBjb25zdCBvcCA9IGNvcFswXTsgLy8gKywgLSwgKiwg
L1xuICAgICAgICAgIHJldHVybiB7IHR5cGU6ICdBcnJheVN0b3JlJywgbmFtZSwgaW5kaWNlcywg
dmFsdWU6IHtcbiAgICAgICAgICAgIHR5cGU6ICdCaW5PcCcsIG9wLCBsZWZ0OiB7IHR5cGU6ICdB
cnJheUFjY2VzcycsIG5hbWUsIGluZGljZXMgfSwgcmlnaHQ6IHJoc1xuICAgICAgICAgIH19O1xu
ICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgRXhwZWN0ZWQgOj0gb3Ig
Y29tcG91bmQgYXNzaWdubWVudCBhZnRlciBhcnJheSBhY2Nlc3MgYXQgJHtjdXIoKS5saW5lfTok
e2N1cigpLmNvbH1gKTtcbiAgICAgIH1cbiAgICAgIGlmICh0b2tlbnNbcG9zICsgMV0gJiYgdG9r
ZW5zW3BvcyArIDFdLnZhbHVlID09PSAnOj0nKSB7XG4gICAgICAgIHBvcysrOyBwb3MrKztcbiAg
ICAgICAgY29uc3QgdmFsdWUgPSBwYXJzZUV4cHIoMCk7XG4gICAgICAgIHJldHVybiB7IHR5cGU6
ICdBc3NpZ24nLCBuYW1lLCB2YWx1ZSB9O1xuICAgICAgfVxuICAgICAgLy8gY29tcG91bmQgYXNz
aWdubWVudDogKz0sIC09LCAqPVxuICAgICAgaWYgKHRva2Vuc1twb3MgKyAxXSAmJiAodG9rZW5z
W3BvcyArIDFdLnZhbHVlID09PSAnKz0nIHx8IHRva2Vuc1twb3MgKyAxXS52YWx1ZSA9PT0gJy09
JyB8fCB0b2tlbnNbcG9zICsgMV0udmFsdWUgPT09ICcqPScpKSB7XG4gICAgICAgIGNvbnN0IGNv
cCA9IHRva2Vuc1twb3MgKyAxXS52YWx1ZTtcbiAgICAgICAgY29uc3Qgb3AgPSBjb3BbMF07XG4g
ICAgICAgIHBvcysrOyBwb3MrKztcbiAgICAgICAgY29uc3QgcmhzID0gcGFyc2VFeHByKDApO1xu
ICAgICAgICByZXR1cm4geyB0eXBlOiAnQXNzaWduJywgbmFtZSwgdmFsdWU6IHsgdHlwZTogJ0Jp
bk9wJywgb3AsIGxlZnQ6IHsgdHlwZTogJ0lkZW50JywgbmFtZSB9LCByaWdodDogcmhzIH0gfTtc
biAgICAgIH1cbiAgICAgIC8vIC89IGNvbXBvdW5kIGFzc2lnbm1lbnQgKG9ubHkgd2hlbiBub3Qg
aW4gZXhwcmVzc2lvbiBjb250ZXh0IOKAlCBzdGF0ZW1lbnQgbGV2ZWwpXG4gICAgICAvLyBEaXNh
bWJpZ3VhdGlvbjogYXQgc3RhdGVtZW50IGxldmVsLCBpZCAvPSBleHByIGlzIGNvbXBvdW5kIGRp
dmlkZS1hc3NpZ25cbiAgICAgIC8vIEJ1dCAvPSBpcyBhbHNvIG5vdC1lcXVhbCBvcGVyYXRvci4g
QXQgc3RhdGVtZW50IGxldmVsOiBpZCAvPSBleHByIOKGkiBkaXZpZGUtYXNzaWduLlxuICAgICAg
aWYgKHRva2Vuc1twb3MgKyAxXSAmJiB0b2tlbnNbcG9zICsgMV0udmFsdWUgPT09ICcvPScpIHtc
biAgICAgICAgLy8gbG9vayBmdXJ0aGVyOiBpZiB0aGlzIGlzIGEgc3RhbmRhbG9uZSBzdGF0ZW1l
bnQgKGlkIC89IGV4cHIpLCB0cmVhdCBhcyBjb21wb3VuZCBhc3NpZ25cbiAgICAgICAgY29uc3Qg
b3AgPSAnLyc7XG4gICAgICAgIHBvcysrOyBwb3MrKztcbiAgICAgICAgY29uc3QgcmhzID0gcGFy
c2VFeHByKDApO1xuICAgICAgICByZXR1cm4geyB0eXBlOiAnQXNzaWduJywgbmFtZSwgdmFsdWU6
IHsgdHlwZTogJ0Jpbk9wJywgb3AsIGxlZnQ6IHsgdHlwZTogJ0lkZW50JywgbmFtZSB9LCByaWdo
dDogcmhzIH0gfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBleHByZXNzaW9uIHN0YXRlbWVu
dCAoZS5nLiwgYmFyZSBmdW5jdGlvbiBjYWxsKVxuICAgIGNvbnN0IGV4cHIgPSBwYXJzZUV4cHIo
MCk7XG4gICAgaWYgKGV4cHIudHlwZSA9PT0gJ0Z1bmNDYWxsJykgcmV0dXJuIHsgdHlwZTogJ0Nh
bGwnLCBuYW1lOiBleHByLm5hbWUsIGFyZ3M6IGV4cHIuYXJncyB9O1xuICAgIHRocm93IG5ldyBT
eW50YXhFcnJvcihgVW5leHBlY3RlZCBleHByZXNzaW9uIHN0YXRlbWVudCBhdCAke2N1cigpLmxp
bmV9OiR7Y3VyKCkuY29sfWApO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VJZihpc0Vsc2VJZikg
e1xuICAgIGVhdChUT0suS1csICdpZicpO1xuICAgIGVhdChUT0suUFVOQywgJygnKTtcbiAgICBj
b25zdCBjb25kID0gcGFyc2VFeHByKDApO1xuICAgIGVhdChUT0suUFVOQywgJyknKTtcbiAgICBl
YXQoVE9LLktXLCAndGhlbicpO1xuICAgIGNvbnN0IGJvZHkgPSBbXTtcbiAgICB3aGlsZSAoIWF0
KFRPSy5LVywgJ2Vsc2UnKSAmJiAhYXQoVE9LLktXLCAnZW5kJykgJiYgIWF0KFRPSy5FT0YpKSB7
XG4gICAgICBib2R5LnB1c2gocGFyc2VTdGF0ZW1lbnQoKSk7XG4gICAgfVxuICAgIGxldCBlbHNl
Qm9keSA9IG51bGw7XG4gICAgaWYgKG1heWJlKFRPSy5LVywgJ2Vsc2UnKSkge1xuICAgICAgaWYg
KGF0KFRPSy5LVywgJ2lmJykpIHtcbiAgICAgICAgLy8gZWxzZSBpZiBjaGFpbjogaW5uZXIgcGFy
c2VJZiBoYW5kbGVzIGV2ZXJ5dGhpbmcgaW5jbHVkaW5nIGVuZCBpZlxuICAgICAgICBlbHNlQm9k
eSA9IFtwYXJzZUlmKHRydWUpXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsc2VCb2R5ID0g
W107XG4gICAgICAgIHdoaWxlICghYXQoVE9LLktXLCAnZW5kJykgJiYgIWF0KFRPSy5FT0YpKSB7
XG4gICAgICAgICAgZWxzZUJvZHkucHVzaChwYXJzZVN0YXRlbWVudCgpKTtcbiAgICAgICAgfVxu
ICAgICAgfVxuICAgIH1cbiAgICAvLyBPbmx5IGNvbnN1bWUgJ2VuZCBpZicgYXQgdGhlIG91dGVy
bW9zdCBpZiAobm90IGluIGVsc2UtaWYgY2hhaW4pXG4gICAgaWYgKCFpc0Vsc2VJZiAmJiBhdChU
T0suS1csICdlbmQnKSkge1xuICAgICAgcG9zKys7XG4gICAgICBtYXliZShUT0suS1csICdpZicp
O1xuICAgIH1cbiAgICByZXR1cm4geyB0eXBlOiAnSWYnLCBjb25kLCBib2R5LCBlbHNlQm9keSB9
O1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VGb3IoKSB7XG4gICAgZWF0KFRPSy5LVywgJ2Zvcicp
O1xuICAgIGNvbnN0IHZhck5hbWUgPSBlYXQoVE9LLklEKS52YWx1ZTtcbiAgICBlYXQoVE9LLk9Q
LCAnOj0nKTtcbiAgICBjb25zdCBzdGFydCA9IHBhcnNlRXhwcigwKTtcbiAgICBlYXQoVE9LLlBV
TkMsICcsJyk7XG4gICAgY29uc3QgZW5kID0gcGFyc2VFeHByKDApO1xuICAgIGxldCBzdGVwID0g
bnVsbDtcbiAgICBpZiAobWF5YmUoVE9LLlBVTkMsICcsJykpIHN0ZXAgPSBwYXJzZUV4cHIoMCk7
XG4gICAgY29uc3QgYm9keSA9IFtdO1xuICAgIHdoaWxlICghYXQoVE9LLktXLCAnZW5kJykgJiYg
IWF0KFRPSy5FT0YpKSBib2R5LnB1c2gocGFyc2VTdGF0ZW1lbnQoKSk7XG4gICAgZWF0KFRPSy5L
VywgJ2VuZCcpO1xuICAgIGVhdChUT0suS1csICdmb3InKTtcbiAgICByZXR1cm4geyB0eXBlOiAn
Rm9yJywgdmFyTmFtZSwgc3RhcnQsIGVuZCwgc3RlcCwgYm9keSB9O1xuICB9XG5cbiAgZnVuY3Rp
b24gcGFyc2VXaGlsZSgpIHtcbiAgICBlYXQoVE9LLktXLCAnd2hpbGUnKTtcbiAgICBlYXQoVE9L
LlBVTkMsICcoJyk7XG4gICAgY29uc3QgY29uZCA9IHBhcnNlRXhwcigwKTtcbiAgICBlYXQoVE9L
LlBVTkMsICcpJyk7XG4gICAgY29uc3QgYm9keSA9IFtdO1xuICAgIHdoaWxlICghYXQoVE9LLktX
LCAnZW5kJykgJiYgIWF0KFRPSy5FT0YpKSBib2R5LnB1c2gocGFyc2VTdGF0ZW1lbnQoKSk7XG4g
ICAgZWF0KFRPSy5LVywgJ2VuZCcpO1xuICAgIGVhdChUT0suS1csICd3aGlsZScpO1xuICAgIHJl
dHVybiB7IHR5cGU6ICdXaGlsZScsIGNvbmQsIGJvZHkgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBh
cnNlRG9XaGlsZSgpIHtcbiAgICBlYXQoVE9LLktXLCAnZG8nKTtcbiAgICBjb25zdCBib2R5ID0g
W107XG4gICAgd2hpbGUgKCFhdChUT0suS1csICd3aGlsZScpICYmICFhdChUT0suRU9GKSkgYm9k
eS5wdXNoKHBhcnNlU3RhdGVtZW50KCkpO1xuICAgIGVhdChUT0suS1csICd3aGlsZScpO1xuICAg
IGVhdChUT0suUFVOQywgJygnKTtcbiAgICBjb25zdCBjb25kID0gcGFyc2VFeHByKDApO1xuICAg
IGVhdChUT0suUFVOQywgJyknKTtcbiAgICByZXR1cm4geyB0eXBlOiAnRG9XaGlsZScsIGNvbmQs
IGJvZHkgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlQXJncygpIHtcbiAgICBjb25zdCBhcmdz
ID0gW107XG4gICAgaWYgKCFhdChUT0suUFVOQywgJyknKSkge1xuICAgICAgYXJncy5wdXNoKHBh
cnNlRXhwcigwKSk7XG4gICAgICB3aGlsZSAobWF5YmUoVE9LLlBVTkMsICcsJykpIGFyZ3MucHVz
aChwYXJzZUV4cHIoMCkpO1xuICAgIH1cbiAgICByZXR1cm4gYXJncztcbiAgfVxuXG4gIC8vIOKU
gOKUgCBQcmF0dCBleHByZXNzaW9uIHBhcnNlciDilIDilIBcblxuICAvLyBCaW5kaW5nIHBvd2Vy
cyAoaGlnaGVyID0gdGlnaHRlcilcbiAgZnVuY3Rpb24gbGJwKHRvaykge1xuICAgIGlmICh0b2su
dHlwZSA9PT0gVE9LLktXKSB7XG4gICAgICBpZiAodG9rLnZhbHVlID09PSAnb3InKSByZXR1cm4g
MjtcbiAgICAgIGlmICh0b2sudmFsdWUgPT09ICdhbmQnKSByZXR1cm4gNDtcbiAgICAgIGlmICh0
b2sudmFsdWUgPT09ICdtb2QnKSByZXR1cm4gMTg7XG4gICAgfVxuICAgIGlmICh0b2sudHlwZSA9
PT0gVE9LLk9QKSB7XG4gICAgICBjb25zdCB2ID0gdG9rLnZhbHVlO1xuICAgICAgaWYgKHYgPT09
ICc9PScgfHwgdiA9PT0gJy89JyB8fCB2ID09PSAnPCcgfHwgdiA9PT0gJz4nIHx8IHYgPT09ICc8
PScgfHwgdiA9PT0gJz49JykgcmV0dXJuIDY7XG4gICAgICBpZiAodiA9PT0gJ3wnKSByZXR1cm4g
ODtcbiAgICAgIGlmICh2ID09PSAnXicpIHJldHVybiAxMDtcbiAgICAgIGlmICh2ID09PSAnJicp
IHJldHVybiAxMjtcbiAgICAgIGlmICh2ID09PSAnPDwnIHx8IHYgPT09ICc+PicpIHJldHVybiAx
NDtcbiAgICAgIGlmICh2ID09PSAnKycgfHwgdiA9PT0gJy0nKSByZXR1cm4gMTY7XG4gICAgICBp
ZiAodiA9PT0gJyonIHx8IHYgPT09ICcvJykgcmV0dXJuIDE4O1xuICAgICAgaWYgKHYgPT09ICcq
KicpIHJldHVybiAyMjsgLy8gcmlnaHQtYXNzb2MgaGFuZGxlZCBieSB1c2luZyByYnAgPSAyMiAt
IDFcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUV4cHIobWlu
QnApIHtcbiAgICBsZXQgbGVmdCA9IHBhcnNlUHJlZml4KCk7XG5cbiAgICB3aGlsZSAodHJ1ZSkg
e1xuICAgICAgY29uc3QgdCA9IGN1cigpO1xuICAgICAgY29uc3QgYnAgPSBsYnAodCk7XG4gICAg
ICBpZiAoYnAgPT09IDAgfHwgYnAgPCBtaW5CcCkgYnJlYWs7XG5cbiAgICAgIC8vIGlmLWV4cHJl
c3Npb24gKHRlcm5hcnkpOiBpZiAoY29uZCkgdGhlbiBhIGVsc2UgYlxuICAgICAgLy8gTm90IGhh
bmRsZWQgaGVyZSDigJQgaXQncyBhIHByZWZpeCBmb3JtXG4gICAgICBpZiAodC50eXBlID09PSBU
T0suS1cgJiYgdC52YWx1ZSA9PT0gJ29yJykgeyBwb3MrKzsgbGVmdCA9IHsgdHlwZTogJ0Jpbk9w
Jywgb3A6ICdvcicsIGxlZnQsIHJpZ2h0OiBwYXJzZUV4cHIoYnAgKyAxKSB9OyBjb250aW51ZTsg
fVxuICAgICAgaWYgKHQudHlwZSA9PT0gVE9LLktXICYmIHQudmFsdWUgPT09ICdhbmQnKSB7IHBv
cysrOyBsZWZ0ID0geyB0eXBlOiAnQmluT3AnLCBvcDogJ2FuZCcsIGxlZnQsIHJpZ2h0OiBwYXJz
ZUV4cHIoYnAgKyAxKSB9OyBjb250aW51ZTsgfVxuICAgICAgaWYgKHQudHlwZSA9PT0gVE9LLktX
ICYmIHQudmFsdWUgPT09ICdtb2QnKSB7IHBvcysrOyBsZWZ0ID0geyB0eXBlOiAnQmluT3AnLCBv
cDogJ21vZCcsIGxlZnQsIHJpZ2h0OiBwYXJzZUV4cHIoYnAgKyAxKSB9OyBjb250aW51ZTsgfVxu
XG4gICAgICBpZiAodC50eXBlID09PSBUT0suT1ApIHtcbiAgICAgICAgaWYgKHQudmFsdWUgPT09
ICcqKicpIHtcbiAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAvLyByaWdodC1hc3NvY2lhdGl2
ZTogdXNlIGJwIGluc3RlYWQgb2YgYnArMVxuICAgICAgICAgIGxlZnQgPSB7IHR5cGU6ICdCaW5P
cCcsIG9wOiAnKionLCBsZWZ0LCByaWdodDogcGFyc2VFeHByKGJwKSB9O1xuICAgICAgICAgIGNv
bnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHBvcysrO1xuICAgICAgICBsZWZ0ID0geyB0eXBl
OiAnQmluT3AnLCBvcDogdC52YWx1ZSwgbGVmdCwgcmlnaHQ6IHBhcnNlRXhwcihicCArIDEpIH07
XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJl
dHVybiBsZWZ0O1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VQcmVmaXgoKSB7XG4gICAgY29uc3Qg
dCA9IGN1cigpO1xuXG4gICAgLy8gcGFyZW50aGVzaXplZCBleHByZXNzaW9uXG4gICAgaWYgKHQu
dHlwZSA9PT0gVE9LLlBVTkMgJiYgdC52YWx1ZSA9PT0gJygnKSB7XG4gICAgICBwb3MrKztcbiAg
ICAgIGNvbnN0IGV4cHIgPSBwYXJzZUV4cHIoMCk7XG4gICAgICBlYXQoVE9LLlBVTkMsICcpJyk7
XG4gICAgICByZXR1cm4gZXhwcjtcbiAgICB9XG5cbiAgICAvLyBpZi1leHByZXNzaW9uICh0ZXJu
YXJ5KTogaWYgKGNvbmQpIHRoZW4gYSBlbHNlIGJcbiAgICBpZiAodC50eXBlID09PSBUT0suS1cg
JiYgdC52YWx1ZSA9PT0gJ2lmJykge1xuICAgICAgcG9zKys7XG4gICAgICBlYXQoVE9LLlBVTkMs
ICcoJyk7XG4gICAgICBjb25zdCBjb25kID0gcGFyc2VFeHByKDApO1xuICAgICAgZWF0KFRPSy5Q
VU5DLCAnKScpO1xuICAgICAgZWF0KFRPSy5LVywgJ3RoZW4nKTtcbiAgICAgIGNvbnN0IHRoZW5F
eHByID0gcGFyc2VFeHByKDApO1xuICAgICAgZWF0KFRPSy5LVywgJ2Vsc2UnKTtcbiAgICAgIGNv
bnN0IGVsc2VFeHByID0gcGFyc2VFeHByKDApO1xuICAgICAgcmV0dXJuIHsgdHlwZTogJ0lmRXhw
cicsIGNvbmQsIHRoZW5FeHByLCBlbHNlRXhwciB9O1xuICAgIH1cblxuICAgIC8vIHVuYXJ5IG1p
bnVzXG4gICAgaWYgKHQudHlwZSA9PT0gVE9LLk9QICYmIHQudmFsdWUgPT09ICctJykge1xuICAg
ICAgcG9zKys7XG4gICAgICByZXR1cm4geyB0eXBlOiAnVW5hcnlPcCcsIG9wOiAnLScsIG9wZXJh
bmQ6IHBhcnNlRXhwcigyMSkgfTtcbiAgICB9XG4gICAgLy8gbm90XG4gICAgaWYgKHQudHlwZSA9
PT0gVE9LLktXICYmIHQudmFsdWUgPT09ICdub3QnKSB7XG4gICAgICBwb3MrKztcbiAgICAgIHJl
dHVybiB7IHR5cGU6ICdVbmFyeU9wJywgb3A6ICdub3QnLCBvcGVyYW5kOiBwYXJzZUV4cHIoMjEp
IH07XG4gICAgfVxuICAgIC8vIGJpdHdpc2Ugbm90XG4gICAgaWYgKHQudHlwZSA9PT0gVE9LLk9Q
ICYmIHQudmFsdWUgPT09ICd+Jykge1xuICAgICAgcG9zKys7XG4gICAgICByZXR1cm4geyB0eXBl
OiAnVW5hcnlPcCcsIG9wOiAnficsIG9wZXJhbmQ6IHBhcnNlRXhwcigyMSkgfTtcbiAgICB9XG4g
ICAgLy8gbnVtYmVyIGxpdGVyYWxcbiAgICBpZiAodC50eXBlID09PSBUT0suTlVNKSB7XG4gICAg
ICBwb3MrKztcbiAgICAgIHJldHVybiB7IHR5cGU6ICdOdW1iZXJMaXQnLCB2YWx1ZTogdC52YWx1
ZSwgaXNGbG9hdDogdC5pc0Zsb2F0LCB0eXBlU3VmZml4OiB0LnR5cGVTdWZmaXggfTtcbiAgICB9
XG4gICAgLy8gdHJ1ZS9mYWxzZVxuICAgIGlmICh0LnR5cGUgPT09IFRPSy5LVyAmJiAodC52YWx1
ZSA9PT0gJ3RydWUnIHx8IHQudmFsdWUgPT09ICdmYWxzZScpKSB7XG4gICAgICBwb3MrKztcbiAg
ICAgIHJldHVybiB7IHR5cGU6ICdOdW1iZXJMaXQnLCB2YWx1ZTogdC52YWx1ZSA9PT0gJ3RydWUn
ID8gJzEnIDogJzAnLCBpc0Zsb2F0OiBmYWxzZSwgdHlwZVN1ZmZpeDogJ2kzMicgfTtcbiAgICB9
XG4gICAgLy8gaWRlbnRpZmllciDigJQgbWF5IGJlIGZ1bmN0aW9uIGNhbGwsIGFycmF5IGFjY2Vz
cywgb3IgcGxhaW4gdmFyaWFibGVcbiAgICBpZiAodC50eXBlID09PSBUT0suSUQpIHtcbiAgICAg
IHBvcysrO1xuICAgICAgY29uc3QgbmFtZSA9IHQudmFsdWU7XG4gICAgICAvLyBmdW5jdGlvbiBj
YWxsOiBuYW1lKC4uLilcbiAgICAgIGlmIChhdChUT0suUFVOQywgJygnKSkge1xuICAgICAgICBw
b3MrKztcbiAgICAgICAgY29uc3QgYXJncyA9IHBhcnNlQXJncygpO1xuICAgICAgICBlYXQoVE9L
LlBVTkMsICcpJyk7XG4gICAgICAgIHJldHVybiB7IHR5cGU6ICdGdW5jQ2FsbCcsIG5hbWUsIGFy
Z3MgfTtcbiAgICAgIH1cbiAgICAgIC8vIGFycmF5IGFjY2VzczogbmFtZVsuLi5dXG4gICAgICBp
ZiAoYXQoVE9LLlBVTkMsICdbJykpIHtcbiAgICAgICAgcG9zKys7XG4gICAgICAgIGNvbnN0IGlu
ZGljZXMgPSBbcGFyc2VFeHByKDApXTtcbiAgICAgICAgd2hpbGUgKG1heWJlKFRPSy5QVU5DLCAn
LCcpKSBpbmRpY2VzLnB1c2gocGFyc2VFeHByKDApKTtcbiAgICAgICAgZWF0KFRPSy5QVU5DLCAn
XScpO1xuICAgICAgICByZXR1cm4geyB0eXBlOiAnQXJyYXlBY2Nlc3MnLCBuYW1lLCBpbmRpY2Vz
IH07XG4gICAgICB9XG4gICAgICByZXR1cm4geyB0eXBlOiAnSWRlbnQnLCBuYW1lIH07XG4gICAg
fVxuICAgIC8vIHR5cGUgY29udmVyc2lvbiAvIHZlY3RvciBjb25zdHJ1Y3RvcjogaTMyKC4uLiks
IGY2NCguLi4pLCBmNjR4MihhLCBiKSwgZXRjLlxuICAgIGlmICh0LnR5cGUgPT09IFRPSy5LVyAm
JiBBVFJBX1RZUEVTLmhhcyh0LnZhbHVlKSAmJiB0b2tlbnNbcG9zICsgMV0gJiYgdG9rZW5zW3Bv
cyArIDFdLnZhbHVlID09PSAnKCcpIHtcbiAgICAgIHBvcysrOyAvLyBza2lwIHR5cGUga2V5d29y
ZFxuICAgICAgcG9zKys7IC8vIHNraXAgKFxuICAgICAgY29uc3QgYXJncyA9IHBhcnNlQXJncygp
O1xuICAgICAgZWF0KFRPSy5QVU5DLCAnKScpO1xuICAgICAgcmV0dXJuIHsgdHlwZTogJ0Z1bmND
YWxsJywgbmFtZTogdC52YWx1ZSwgYXJncyB9O1xuICAgIH1cbiAgICB0aHJvdyBuZXcgU3ludGF4
RXJyb3IoYFVuZXhwZWN0ZWQgdG9rZW4gXCIke3QudmFsdWV9XCIgYXQgJHt0LmxpbmV9OiR7dC5j
b2x9YCk7XG4gIH1cblxuICByZXR1cm4gcGFyc2VQcm9ncmFtKCk7XG59XG5cbi8vIOKVkOKVkOKV
kOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKV
kOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKV
kOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKV
kOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkFxuLy8gNC4gQ09E
RSBHRU5FUkFUT1Ig4oCUIGVtaXRzIFdhc20gYmluYXJ5XG4vLyDilZDilZDilZDilZDilZDilZDi
lZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDi
lZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDi
lZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDi
lZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZBcblxuLy8gV2FzbSBvcGNvZGVzXG5j
b25zdCBPUF9VTlJFQUNIQUJMRSA9IDB4MDAsIE9QX05PUCA9IDB4MDEsIE9QX0JMT0NLID0gMHgw
MiwgT1BfTE9PUCA9IDB4MDMsXG4gIE9QX0lGID0gMHgwNCwgT1BfRUxTRSA9IDB4MDUsIE9QX0VO
RCA9IDB4MGIsIE9QX0JSID0gMHgwYywgT1BfQlJfSUYgPSAweDBkLFxuICBPUF9SRVRVUk4gPSAw
eDBmLCBPUF9DQUxMID0gMHgxMCwgT1BfQ0FMTF9JTkRJUkVDVCA9IDB4MTEsXG4gIE9QX1JFVFVS
Tl9DQUxMID0gMHgxMiwgT1BfUkVUVVJOX0NBTExfSU5ESVJFQ1QgPSAweDEzLCBPUF9TRUxFQ1Qg
PSAweDFiLFxuICBPUF9MT0NBTF9HRVQgPSAweDIwLCBPUF9MT0NBTF9TRVQgPSAweDIxLCBPUF9M
T0NBTF9URUUgPSAweDIyLFxuICBPUF9HTE9CQUxfR0VUID0gMHgyMywgT1BfR0xPQkFMX1NFVCA9
IDB4MjQsXG4gIE9QX0kzMl9MT0FEID0gMHgyOCwgT1BfSTY0X0xPQUQgPSAweDI5LCBPUF9GMzJf
TE9BRCA9IDB4MmEsIE9QX0Y2NF9MT0FEID0gMHgyYixcbiAgT1BfSTMyX1NUT1JFID0gMHgzNiwg
T1BfSTY0X1NUT1JFID0gMHgzNywgT1BfRjMyX1NUT1JFID0gMHgzOCwgT1BfRjY0X1NUT1JFID0g
MHgzOSxcbiAgT1BfTUVNT1JZX1NJWkUgPSAweDNmLCBPUF9NRU1PUllfR1JPVyA9IDB4NDAsXG4g
IE9QX0kzMl9DT05TVCA9IDB4NDEsIE9QX0k2NF9DT05TVCA9IDB4NDIsIE9QX0YzMl9DT05TVCA9
IDB4NDMsIE9QX0Y2NF9DT05TVCA9IDB4NDQsXG4gIE9QX0kzMl9FUVogPSAweDQ1LCBPUF9JMzJf
RVEgPSAweDQ2LCBPUF9JMzJfTkUgPSAweDQ3LFxuICBPUF9JMzJfTFRfUyA9IDB4NDgsIE9QX0kz
Ml9MVF9VID0gMHg0OSwgT1BfSTMyX0dUX1MgPSAweDRhLCBPUF9JMzJfR1RfVSA9IDB4NGIsXG4g
IE9QX0kzMl9MRV9TID0gMHg0YywgT1BfSTMyX0xFX1UgPSAweDRkLCBPUF9JMzJfR0VfUyA9IDB4
NGUsIE9QX0kzMl9HRV9VID0gMHg0ZixcbiAgT1BfSTY0X0VRWiA9IDB4NTAsIE9QX0k2NF9FUSA9
IDB4NTEsIE9QX0k2NF9ORSA9IDB4NTIsXG4gIE9QX0k2NF9MVF9TID0gMHg1MywgT1BfSTY0X0xU
X1UgPSAweDU0LCBPUF9JNjRfR1RfUyA9IDB4NTUsIE9QX0k2NF9HVF9VID0gMHg1NixcbiAgT1Bf
STY0X0xFX1MgPSAweDU3LCBPUF9JNjRfTEVfVSA9IDB4NTgsIE9QX0k2NF9HRV9TID0gMHg1OSwg
T1BfSTY0X0dFX1UgPSAweDVhLFxuICBPUF9GMzJfRVEgPSAweDViLCBPUF9GMzJfTkUgPSAweDVj
LCBPUF9GMzJfTFQgPSAweDVkLCBPUF9GMzJfR1QgPSAweDVlLCBPUF9GMzJfTEUgPSAweDVmLCBP
UF9GMzJfR0UgPSAweDYwLFxuICBPUF9GNjRfRVEgPSAweDYxLCBPUF9GNjRfTkUgPSAweDYyLCBP
UF9GNjRfTFQgPSAweDYzLCBPUF9GNjRfR1QgPSAweDY0LCBPUF9GNjRfTEUgPSAweDY1LCBPUF9G
NjRfR0UgPSAweDY2LFxuICBPUF9JMzJfQ0xaID0gMHg2NywgT1BfSTMyX0NUWiA9IDB4NjgsIE9Q
X0kzMl9QT1BDTlQgPSAweDY5LFxuICBPUF9JMzJfQUREID0gMHg2YSwgT1BfSTMyX1NVQiA9IDB4
NmIsIE9QX0kzMl9NVUwgPSAweDZjLFxuICBPUF9JMzJfRElWX1MgPSAweDZkLCBPUF9JMzJfRElW
X1UgPSAweDZlLCBPUF9JMzJfUkVNX1MgPSAweDZmLCBPUF9JMzJfUkVNX1UgPSAweDcwLFxuICBP
UF9JMzJfQU5EID0gMHg3MSwgT1BfSTMyX09SID0gMHg3MiwgT1BfSTMyX1hPUiA9IDB4NzMsXG4g
IE9QX0kzMl9TSEwgPSAweDc0LCBPUF9JMzJfU0hSX1MgPSAweDc1LCBPUF9JMzJfU0hSX1UgPSAw
eDc2LFxuICBPUF9JMzJfUk9UTCA9IDB4NzcsIE9QX0kzMl9ST1RSID0gMHg3OCxcbiAgT1BfSTY0
X0NMWiA9IDB4NzksIE9QX0k2NF9DVFogPSAweDdhLCBPUF9JNjRfUE9QQ05UID0gMHg3YixcbiAg
T1BfSTY0X0FERCA9IDB4N2MsIE9QX0k2NF9TVUIgPSAweDdkLCBPUF9JNjRfTVVMID0gMHg3ZSxc
biAgT1BfSTY0X0RJVl9TID0gMHg3ZiwgT1BfSTY0X0RJVl9VID0gMHg4MCwgT1BfSTY0X1JFTV9T
ID0gMHg4MSwgT1BfSTY0X1JFTV9VID0gMHg4MixcbiAgT1BfSTY0X0FORCA9IDB4ODMsIE9QX0k2
NF9PUiA9IDB4ODQsIE9QX0k2NF9YT1IgPSAweDg1LFxuICBPUF9JNjRfU0hMID0gMHg4NiwgT1Bf
STY0X1NIUl9TID0gMHg4NywgT1BfSTY0X1NIUl9VID0gMHg4OCxcbiAgT1BfSTY0X1JPVEwgPSAw
eDg5LCBPUF9JNjRfUk9UUiA9IDB4OGEsXG4gIE9QX0YzMl9BQlMgPSAweDhiLCBPUF9GMzJfTkVH
ID0gMHg4YywgT1BfRjMyX0NFSUwgPSAweDhkLCBPUF9GMzJfRkxPT1IgPSAweDhlLFxuICBPUF9G
MzJfVFJVTkMgPSAweDhmLCBPUF9GMzJfTkVBUkVTVCA9IDB4OTAsIE9QX0YzMl9TUVJUID0gMHg5
MSxcbiAgT1BfRjMyX0FERCA9IDB4OTIsIE9QX0YzMl9TVUIgPSAweDkzLCBPUF9GMzJfTVVMID0g
MHg5NCwgT1BfRjMyX0RJViA9IDB4OTUsXG4gIE9QX0YzMl9NSU4gPSAweDk2LCBPUF9GMzJfTUFY
ID0gMHg5NywgT1BfRjMyX0NPUFlTSUdOID0gMHg5OCxcbiAgT1BfRjY0X0FCUyA9IDB4OTksIE9Q
X0Y2NF9ORUcgPSAweDlhLCBPUF9GNjRfQ0VJTCA9IDB4OWIsIE9QX0Y2NF9GTE9PUiA9IDB4OWMs
XG4gIE9QX0Y2NF9UUlVOQyA9IDB4OWQsIE9QX0Y2NF9ORUFSRVNUID0gMHg5ZSwgT1BfRjY0X1NR
UlQgPSAweDlmLFxuICBPUF9GNjRfQUREID0gMHhhMCwgT1BfRjY0X1NVQiA9IDB4YTEsIE9QX0Y2
NF9NVUwgPSAweGEyLCBPUF9GNjRfRElWID0gMHhhMyxcbiAgT1BfRjY0X01JTiA9IDB4YTQsIE9Q
X0Y2NF9NQVggPSAweGE1LCBPUF9GNjRfQ09QWVNJR04gPSAweGE2LFxuICBPUF9JMzJfV1JBUF9J
NjQgPSAweGE3LFxuICBPUF9JMzJfVFJVTkNfRjMyX1MgPSAweGE4LCBPUF9JMzJfVFJVTkNfRjY0
X1MgPSAweGFhLFxuICBPUF9JNjRfRVhURU5EX0kzMl9TID0gMHhhYywgT1BfSTY0X0VYVEVORF9J
MzJfVSA9IDB4YWQsXG4gIE9QX0k2NF9UUlVOQ19GMzJfUyA9IDB4YWUsIE9QX0k2NF9UUlVOQ19G
NjRfUyA9IDB4YjAsXG4gIE9QX0YzMl9DT05WRVJUX0kzMl9TID0gMHhiMiwgT1BfRjMyX0NPTlZF
UlRfSTY0X1MgPSAweGI0LFxuICBPUF9GMzJfREVNT1RFX0Y2NCA9IDB4YjYsXG4gIE9QX0Y2NF9D
T05WRVJUX0kzMl9TID0gMHhiNywgT1BfRjY0X0NPTlZFUlRfSTY0X1MgPSAweGI5LFxuICBPUF9G
NjRfUFJPTU9URV9GMzIgPSAweGJiLFxuICBPUF9JMzJfUkVJTlRFUlBSRVRfRjMyID0gMHhiYywg
T1BfSTY0X1JFSU5URVJQUkVUX0Y2NCA9IDB4YmQsXG4gIE9QX0YzMl9SRUlOVEVSUFJFVF9JMzIg
PSAweGJlLCBPUF9GNjRfUkVJTlRFUlBSRVRfSTY0ID0gMHhiZixcbiAgT1BfSTMyX0VYVEVORDhf
UyA9IDB4YzAsIE9QX0kzMl9FWFRFTkQxNl9TID0gMHhjMSxcbiAgT1BfSTY0X0VYVEVORDhfUyA9
IDB4YzIsIE9QX0k2NF9FWFRFTkQxNl9TID0gMHhjMywgT1BfSTY0X0VYVEVORDMyX1MgPSAweGM0
O1xuXG4vLyBXYXNtIEZDIHByZWZpeCBvcGNvZGVzICgweEZDIHByZWZpeClcbmNvbnN0IE9QX0ZD
X1BSRUZJWCA9IDB4ZmM7XG5jb25zdCBPUF9JMzJfVFJVTkNfU0FUX0YzMl9TID0gMCwgT1BfSTMy
X1RSVU5DX1NBVF9GMzJfVSA9IDEsXG4gIE9QX0kzMl9UUlVOQ19TQVRfRjY0X1MgPSAyLCBPUF9J
MzJfVFJVTkNfU0FUX0Y2NF9VID0gMyxcbiAgT1BfSTY0X1RSVU5DX1NBVF9GMzJfUyA9IDQsIE9Q
X0k2NF9UUlVOQ19TQVRfRjMyX1UgPSA1LFxuICBPUF9JNjRfVFJVTkNfU0FUX0Y2NF9TID0gNiwg
T1BfSTY0X1RSVU5DX1NBVF9GNjRfVSA9IDc7XG5cbi8vIFdhc20gdHlwZSBjb2Rlc1xuY29uc3Qg
V0FTTV9JMzIgPSAweDdmLCBXQVNNX0k2NCA9IDB4N2UsIFdBU01fRjMyID0gMHg3ZCwgV0FTTV9G
NjQgPSAweDdjO1xuY29uc3QgV0FTTV9WMTI4ID0gMHg3YjtcbmNvbnN0IFdBU01fVk9JRCA9IDB4
NDA7XG5cbi8vIFNJTUQgcHJlZml4XG5jb25zdCBPUF9TSU1EX1BSRUZJWCA9IDB4ZmQ7XG5cbi8v
IFNJTUQgb3Bjb2RlIHRhYmxlXG5jb25zdCBTSU1EX09QUyA9IHtcbiAgLy8gc3BsYXRcbiAgJ2kz
Mng0LnNwbGF0JzogMHgxMSwgJ2k2NHgyLnNwbGF0JzogMHgxMiwgJ2YzMng0LnNwbGF0JzogMHgx
MywgJ2Y2NHgyLnNwbGF0JzogMHgxNCxcbiAgLy8gZXh0cmFjdF9sYW5lXG4gICdpMzJ4NC5leHRy
YWN0X2xhbmUnOiAweDFiLCAnaTY0eDIuZXh0cmFjdF9sYW5lJzogMHgxZCwgJ2YzMng0LmV4dHJh
Y3RfbGFuZSc6IDB4MWYsICdmNjR4Mi5leHRyYWN0X2xhbmUnOiAweDIxLFxuICAvLyByZXBsYWNl
X2xhbmVcbiAgJ2kzMng0LnJlcGxhY2VfbGFuZSc6IDB4MWMsICdpNjR4Mi5yZXBsYWNlX2xhbmUn
OiAweDFlLCAnZjMyeDQucmVwbGFjZV9sYW5lJzogMHgyMCwgJ2Y2NHgyLnJlcGxhY2VfbGFuZSc6
IDB4MjIsXG4gIC8vIGFkZFxuICAnaTMyeDQuYWRkJzogMHhhZSwgJ2k2NHgyLmFkZCc6IDB4Y2Us
ICdmMzJ4NC5hZGQnOiAweGU0LCAnZjY0eDIuYWRkJzogMHhmMCxcbiAgLy8gc3ViXG4gICdpMzJ4
NC5zdWInOiAweGIxLCAnaTY0eDIuc3ViJzogMHhkMSwgJ2YzMng0LnN1Yic6IDB4ZTUsICdmNjR4
Mi5zdWInOiAweGYxLFxuICAvLyBtdWxcbiAgJ2kzMng0Lm11bCc6IDB4YjUsICdpNjR4Mi5tdWwn
OiAweGQ1LCAnZjMyeDQubXVsJzogMHhlNiwgJ2Y2NHgyLm11bCc6IDB4ZjIsXG4gIC8vIGRpdiAo
ZmxvYXQgb25seSlcbiAgJ2YzMng0LmRpdic6IDB4ZTcsICdmNjR4Mi5kaXYnOiAweGYzLFxuICAv
LyBuZWdcbiAgJ2kzMng0Lm5lZyc6IDB4YTEsICdpNjR4Mi5uZWcnOiAweGMxLCAnZjMyeDQubmVn
JzogMHhlMSwgJ2Y2NHgyLm5lZyc6IDB4ZWQsXG4gIC8vIGFicyAoZmxvYXQgb25seSlcbiAgJ2Yz
Mng0LmFicyc6IDB4ZTAsICdmNjR4Mi5hYnMnOiAweGVjLFxuICAvLyBzcXJ0IChmbG9hdCBvbmx5
KVxuICAnZjMyeDQuc3FydCc6IDB4ZTMsICdmNjR4Mi5zcXJ0JzogMHhlZixcbiAgLy8gbWluL21h
eCAoZmxvYXQgb25seSlcbiAgJ2YzMng0Lm1pbic6IDB4ZTgsICdmNjR4Mi5taW4nOiAweGY0LCAn
ZjMyeDQubWF4JzogMHhlOSwgJ2Y2NHgyLm1heCc6IDB4ZjUsXG4gIC8vIGNvbXBhcmlzb24g4oCU
IGVxXG4gICdpMzJ4NC5lcSc6IDB4MzcsICdpNjR4Mi5lcSc6IDB4ZDYsICdmMzJ4NC5lcSc6IDB4
NDEsICdmNjR4Mi5lcSc6IDB4NDcsXG4gIC8vIG5lXG4gICdpMzJ4NC5uZSc6IDB4MzgsICdmMzJ4
NC5uZSc6IDB4NDIsICdmNjR4Mi5uZSc6IDB4NDgsXG4gIC8vIGx0XG4gICdpMzJ4NC5sdF9zJzog
MHgzOSwgJ2k2NHgyLmx0X3MnOiAweGQ3LCAnZjMyeDQubHQnOiAweDQzLCAnZjY0eDIubHQnOiAw
eDQ5LFxuICAvLyBndFxuICAnaTMyeDQuZ3Rfcyc6IDB4M2IsICdpNjR4Mi5ndF9zJzogMHhkOSwg
J2YzMng0Lmd0JzogMHg0NCwgJ2Y2NHgyLmd0JzogMHg0YSxcbiAgLy8gbGVcbiAgJ2kzMng0Lmxl
X3MnOiAweDNkLCAnaTY0eDIubGVfcyc6IDB4ZGIsICdmMzJ4NC5sZSc6IDB4NDUsICdmNjR4Mi5s
ZSc6IDB4NGIsXG4gIC8vIGdlXG4gICdpMzJ4NC5nZV9zJzogMHgzZiwgJ2k2NHgyLmdlX3MnOiAw
eGRkLCAnZjMyeDQuZ2UnOiAweDQ2LCAnZjY0eDIuZ2UnOiAweDRjLFxuICAvLyB2MTI4IGJpdHdp
c2VcbiAgJ3YxMjgubm90JzogMHg0ZCwgJ3YxMjguYW5kJzogMHg0ZSwgJ3YxMjgub3InOiAweDUw
LCAndjEyOC54b3InOiAweDUxLFxuICAvLyB2MTI4IG1lbW9yeVxuICAndjEyOC5sb2FkJzogMHgw
MCwgJ3YxMjguc3RvcmUnOiAweDBiLCAndjEyOC5jb25zdCc6IDB4MGMsXG59O1xuXG5mdW5jdGlv
biB3YXNtVHlwZSh0KSB7XG4gIGlmICh0ID09PSAnaTMyJykgcmV0dXJuIFdBU01fSTMyO1xuICBp
ZiAodCA9PT0gJ2k2NCcpIHJldHVybiBXQVNNX0k2NDtcbiAgaWYgKHQgPT09ICdmMzInKSByZXR1
cm4gV0FTTV9GMzI7XG4gIGlmICh0ID09PSAnZjY0JykgcmV0dXJuIFdBU01fRjY0O1xuICBpZiAo
aXNWZWN0b3IodCkpIHJldHVybiBXQVNNX1YxMjg7XG4gIHRocm93IG5ldyBFcnJvcignVW5rbm93
biB0eXBlOiAnICsgdCk7XG59XG5cbmZ1bmN0aW9uIHR5cGVTaXplKHQpIHtcbiAgaWYgKHQgPT09
ICdpMzInIHx8IHQgPT09ICdmMzInKSByZXR1cm4gNDtcbiAgaWYgKHQgPT09ICdpNjQnIHx8IHQg
PT09ICdmNjQnKSByZXR1cm4gODtcbiAgaWYgKGlzVmVjdG9yKHQpKSByZXR1cm4gMTY7XG4gIHRo
cm93IG5ldyBFcnJvcignVW5rbm93biB0eXBlOiAnICsgdCk7XG59XG5cbmZ1bmN0aW9uIGlzRmxv
YXQodCkgeyByZXR1cm4gdCA9PT0gJ2YzMicgfHwgdCA9PT0gJ2Y2NCc7IH1cbmZ1bmN0aW9uIGlz
SW50KHQpIHsgcmV0dXJuIHQgPT09ICdpMzInIHx8IHQgPT09ICdpNjQnOyB9XG5mdW5jdGlvbiBp
c1ZlY3Rvcih0KSB7IHJldHVybiB0ID09PSAnZjY0eDInIHx8IHQgPT09ICdmMzJ4NCcgfHwgdCA9
PT0gJ2kzMng0JyB8fCB0ID09PSAnaTY0eDInOyB9XG5mdW5jdGlvbiB2ZWN0b3JTY2FsYXJUeXBl
KHQpIHtcbiAgaWYgKHQgPT09ICdmNjR4MicpIHJldHVybiAnZjY0JztcbiAgaWYgKHQgPT09ICdm
MzJ4NCcpIHJldHVybiAnZjMyJztcbiAgaWYgKHQgPT09ICdpMzJ4NCcpIHJldHVybiAnaTMyJztc
biAgaWYgKHQgPT09ICdpNjR4MicpIHJldHVybiAnaTY0JztcbiAgcmV0dXJuIG51bGw7XG59XG5c
bi8vIOKUgOKUgCBCeXRlV3JpdGVyIOKUgOKUgFxuXG5jbGFzcyBCeXRlV3JpdGVyIHtcbiAgY29u
c3RydWN0b3IoKSB7IHRoaXMuYnVmID0gW107IH1cbiAgYnl0ZShiKSB7IHRoaXMuYnVmLnB1c2go
YiAmIDB4ZmYpOyB9XG4gIGJ5dGVzKGFycikgeyBmb3IgKGNvbnN0IGIgb2YgYXJyKSB0aGlzLmJ5
dGUoYik7IH1cbiAgdTMyKHYpIHsgLy8gTEVCMTI4IHVuc2lnbmVkXG4gICAgZG8geyBsZXQgYiA9
IHYgJiAweDdmOyB2ID4+Pj0gNzsgaWYgKHYpIGIgfD0gMHg4MDsgdGhpcy5ieXRlKGIpOyB9IHdo
aWxlICh2KTtcbiAgfVxuICBzMzIodikgeyAvLyBMRUIxMjggc2lnbmVkXG4gICAgbGV0IG1vcmUg
PSB0cnVlO1xuICAgIHdoaWxlIChtb3JlKSB7XG4gICAgICBsZXQgYiA9IHYgJiAweDdmOyB2ID4+
PSA3O1xuICAgICAgaWYgKCh2ID09PSAwICYmICEoYiAmIDB4NDApKSB8fCAodiA9PT0gLTEgJiYg
KGIgJiAweDQwKSkpIG1vcmUgPSBmYWxzZTsgZWxzZSBiIHw9IDB4ODA7XG4gICAgICB0aGlzLmJ5
dGUoYik7XG4gICAgfVxuICB9XG4gIHM2NCh2KSB7IC8vIExFQjEyOCBzaWduZWQgZm9yIGk2NCAo
QmlnSW50KVxuICAgIHYgPSBCaWdJbnQodik7XG4gICAgbGV0IG1vcmUgPSB0cnVlO1xuICAgIHdo
aWxlIChtb3JlKSB7XG4gICAgICBsZXQgYiA9IE51bWJlcih2ICYgMHg3Zm4pOyB2ID4+PSA3bjtc
biAgICAgIGlmICgodiA9PT0gMG4gJiYgIShiICYgMHg0MCkpIHx8ICh2ID09PSAtMW4gJiYgKGIg
JiAweDQwKSkpIG1vcmUgPSBmYWxzZTsgZWxzZSBiIHw9IDB4ODA7XG4gICAgICB0aGlzLmJ5dGUo
Yik7XG4gICAgfVxuICB9XG4gIGYzMih2KSB7IGNvbnN0IGJ1ZiA9IG5ldyBBcnJheUJ1ZmZlcig0
KTsgbmV3IERhdGFWaWV3KGJ1Zikuc2V0RmxvYXQzMigwLCB2LCB0cnVlKTsgdGhpcy5ieXRlcyhu
ZXcgVWludDhBcnJheShidWYpKTsgfVxuICBmNjQodikgeyBjb25zdCBidWYgPSBuZXcgQXJyYXlC
dWZmZXIoOCk7IG5ldyBEYXRhVmlldyhidWYpLnNldEZsb2F0NjQoMCwgdiwgdHJ1ZSk7IHRoaXMu
Ynl0ZXMobmV3IFVpbnQ4QXJyYXkoYnVmKSk7IH1cbiAgc3RyKHMpIHsgY29uc3QgZW5jID0gbmV3
IFRleHRFbmNvZGVyKCkuZW5jb2RlKHMpOyB0aGlzLnUzMihlbmMubGVuZ3RoKTsgdGhpcy5ieXRl
cyhlbmMpOyB9XG4gIHNlY3Rpb24oaWQsIGNvbnRlbnRGbikge1xuICAgIGNvbnN0IGlubmVyID0g
bmV3IEJ5dGVXcml0ZXIoKTtcbiAgICBjb250ZW50Rm4oaW5uZXIpO1xuICAgIHRoaXMuYnl0ZShp
ZCk7XG4gICAgdGhpcy51MzIoaW5uZXIuYnVmLmxlbmd0aCk7XG4gICAgdGhpcy5ieXRlcyhpbm5l
ci5idWYpO1xuICB9XG4gIHRvVWludDhBcnJheSgpIHsgcmV0dXJuIG5ldyBVaW50OEFycmF5KHRo
aXMuYnVmKTsgfVxufVxuXG5mdW5jdGlvbiBjb2RlZ2VuKGFzdCwgaW50ZXJwVmFsdWVzLCB1c2Vy
SW1wb3J0cykge1xuICBjb25zdCB3ID0gbmV3IEJ5dGVXcml0ZXIoKTtcblxuICAvLyDilIDilIAg
Q29sbGVjdCBpbmZvIOKUgOKUgFxuICBjb25zdCBnbG9iYWxzID0gW107ICAgIC8vIHsgbmFtZSwg
dnR5cGUsIG11dGFibGUsIGluaXQgfVxuICBjb25zdCBmdW5jdGlvbnMgPSBbXTsgIC8vIEFTVCBu
b2Rlc1xuICBjb25zdCBpbXBvcnRzID0gW107ICAgIC8vIHsgbmFtZSwgbW9kdWxlTmFtZSwgcGFy
YW1zLCByZXRUeXBlLCBpbnRlcnBJZHggfVxuICBjb25zdCBsb2NhbEZ1bmNOYW1lcyA9IG5ldyBT
ZXQoKTtcblxuICBmb3IgKGNvbnN0IG5vZGUgb2YgYXN0LmJvZHkpIHtcbiAgICBpZiAobm9kZS50
eXBlID09PSAnQ29uc3REZWNsJykgZ2xvYmFscy5wdXNoKHsgbmFtZTogbm9kZS5uYW1lLCB2dHlw
ZTogbm9kZS52dHlwZSwgbXV0YWJsZTogZmFsc2UsIGluaXQ6IG5vZGUuaW5pdCB9KTtcbiAgICBl
bHNlIGlmIChub2RlLnR5cGUgPT09ICdWYXJEZWNsJykge1xuICAgICAgY29uc3QgZyA9IHsgbmFt
ZTogbm9kZS5uYW1lLCB2dHlwZTogbm9kZS52dHlwZSwgbXV0YWJsZTogdHJ1ZSwgaW5pdDogbm9k
ZS5pbml0IH07XG4gICAgICBpZiAobm9kZS5mdW5jU2lnKSBnLmZ1bmNTaWcgPSBub2RlLmZ1bmNT
aWc7XG4gICAgICBnbG9iYWxzLnB1c2goZyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vZGUudHlw
ZSA9PT0gJ0Z1bmN0aW9uJyB8fCBub2RlLnR5cGUgPT09ICdTdWJyb3V0aW5lJykgeyBmdW5jdGlv
bnMucHVzaChub2RlKTsgbG9jYWxGdW5jTmFtZXMuYWRkKG5vZGUubmFtZSk7IH1cbiAgICBlbHNl
IGlmIChub2RlLnR5cGUgPT09ICdJbXBvcnREZWNsJykgaW1wb3J0cy5wdXNoKG5vZGUpO1xuICB9
XG5cbiAgLy8gTWF0aCBidWlsdGlucyB0aGF0IG5lZWQgaW1wb3J0aW5nXG4gIGNvbnN0IE1BVEhf
QlVJTFRJTlMgPSB7IHNpbjogMSwgY29zOiAxLCBsbjogMSwgZXhwOiAxLCBwb3c6IDIsIGF0YW4y
OiAyIH07XG4gIC8vIE5hdGl2ZSBidWlsdGlucyAobm8gaW1wb3J0IG5lZWRlZCkg4oCUIHJlc29s
dmVkIHBlci10eXBlIGluIGVtaXRGdW5jQ2FsbFxuICBjb25zdCBOQVRJVkVfQlVJTFRJTlMgPSBu
ZXcgU2V0KFtcbiAgICAnc3FydCcsJ2FicycsJ2Zsb29yJywnY2VpbCcsJ3RydW5jJywnbmVhcmVz
dCcsJ2NvcHlzaWduJyxcbiAgICAnbWluJywnbWF4Jywnc2VsZWN0JyxcbiAgICAnY2x6JywnY3R6
JywncG9wY250Jywncm90bCcsJ3JvdHInLFxuICAgICdtZW1vcnlfc2l6ZScsJ21lbW9yeV9ncm93
JywnbWVtb3J5X2NvcHknLCdtZW1vcnlfZmlsbCcsXG4gICAgJ2kzMicsJ2k2NCcsJ2YzMicsJ2Y2
NCcsIC8vIHR5cGUgY29udmVyc2lvbnNcbiAgICAnZjY0eDInLCdmMzJ4NCcsJ2kzMng0JywnaTY0
eDInLCAvLyB2ZWN0b3IgY29uc3RydWN0b3JzXG4gIF0pO1xuXG4gIC8vIFNjYW4gYWxsIGZ1bmN0
aW9uIGJvZGllcyBmb3IgdW5yZXNvbHZlZCBjYWxsc1xuICBjb25zdCB1c2VkQ2FsbHMgPSBuZXcg
U2V0KCk7XG4gIGZ1bmN0aW9uIHNjYW5DYWxscyhzdG10cykge1xuICAgIGZvciAoY29uc3QgcyBv
ZiBzdG10cykge1xuICAgICAgaWYgKHMudHlwZSA9PT0gJ0NhbGwnIHx8IHMudHlwZSA9PT0gJ0Z1
bmNDYWxsJykgdXNlZENhbGxzLmFkZChzLm5hbWUpO1xuICAgICAgaWYgKHMudHlwZSA9PT0gJ0lm
JykgeyBzY2FuQ2FsbHMocy5ib2R5KTsgaWYgKHMuZWxzZUJvZHkpIHNjYW5DYWxscyhzLmVsc2VC
b2R5KTsgfVxuICAgICAgaWYgKHMudHlwZSA9PT0gJ0ZvcicgfHwgcy50eXBlID09PSAnV2hpbGUn
IHx8IHMudHlwZSA9PT0gJ0RvV2hpbGUnKSBzY2FuQ2FsbHMocy5ib2R5KTtcbiAgICAgIC8vIHNj
YW4gZXhwcmVzc2lvbnNcbiAgICAgIHNjYW5FeHByQ2FsbHMocyk7XG4gICAgfVxuICB9XG4gIGZ1
bmN0aW9uIHNjYW5FeHByQ2FsbHMobm9kZSkge1xuICAgIGlmICghbm9kZSB8fCB0eXBlb2Ygbm9k
ZSAhPT0gJ29iamVjdCcpIHJldHVybjtcbiAgICBpZiAobm9kZS50eXBlID09PSAnRnVuY0NhbGwn
KSB1c2VkQ2FsbHMuYWRkKG5vZGUubmFtZSk7XG4gICAgLy8gKiogb3BlcmF0b3IgbWF5IG5lZWQg
cG93IGltcG9ydCAoZm9yIG5vbi1zcXJ0LCBub24tc21hbGwtaW50IGV4cG9uZW50cylcbiAgICBp
ZiAobm9kZS50eXBlID09PSAnQmluT3AnICYmIG5vZGUub3AgPT09ICcqKicpIHVzZWRDYWxscy5h
ZGQoJ3BvdycpO1xuICAgIGZvciAoY29uc3QgayBvZiBPYmplY3Qua2V5cyhub2RlKSkge1xuICAg
ICAgY29uc3QgdiA9IG5vZGVba107XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2KSkgdi5mb3JF
YWNoKHNjYW5FeHByQ2FsbHMpO1xuICAgICAgZWxzZSBpZiAodiAmJiB0eXBlb2YgdiA9PT0gJ29i
amVjdCcgJiYgdi50eXBlKSBzY2FuRXhwckNhbGxzKHYpO1xuICAgIH1cbiAgfVxuICBmb3IgKGNv
bnN0IGZuIG9mIGZ1bmN0aW9ucykgc2NhbkNhbGxzKGZuLmJvZHkpO1xuXG4gIC8vIEF1dG8taW1w
b3J0IG1hdGggYnVpbHRpbnMgdGhhdCBhcmUgYWN0dWFsbHkgdXNlZFxuICBjb25zdCBtYXRoSW1w
b3J0cyA9IFtdO1xuICBmb3IgKGNvbnN0IG5hbWUgb2YgdXNlZENhbGxzKSB7XG4gICAgaWYgKE1B
VEhfQlVJTFRJTlNbbmFtZV0gIT09IHVuZGVmaW5lZCAmJiAhbG9jYWxGdW5jTmFtZXMuaGFzKG5h
bWUpICYmICFpbXBvcnRzLmZpbmQoaW0gPT4gaW0ubmFtZSA9PT0gbmFtZSkpIHtcbiAgICAgIGNv
bnN0IG5QYXJhbXMgPSBNQVRIX0JVSUxUSU5TW25hbWVdO1xuICAgICAgY29uc3QgcGFyYW1zID0g
W107XG4gICAgICBmb3IgKGxldCBrID0gMDsgayA8IG5QYXJhbXM7IGsrKykgcGFyYW1zLnB1c2go
eyB0eXBlOiAnUGFyYW0nLCBuYW1lOiAneCcgKyBrLCB2dHlwZTogJ2Y2NCcsIGlzQXJyYXk6IGZh
bHNlLCBhcnJheURpbXM6IG51bGwgfSk7XG4gICAgICBtYXRoSW1wb3J0cy5wdXNoKHsgbmFtZSwg
bW9kdWxlTmFtZTogJ21hdGgnLCBwYXJhbXMsIHJldFR5cGU6ICdmNjQnLCBpbnRlcnBJZHg6IG51
bGwgfSk7XG4gICAgfVxuICB9XG5cbiAgLy8gQXV0by1pbXBvcnQgZnJvbSB1c2VySW1wb3J0cyBv
ciBnbG9iYWxUaGlzXG4gIGNvbnN0IGZsYXRJbXBvcnRzID0gdXNlckltcG9ydHMgPyBmbGF0dGVu
SW1wb3J0cyh1c2VySW1wb3J0cykgOiB7fTtcbiAgY29uc3QgaG9zdEltcG9ydHMgPSBbXTtcbiAg
Zm9yIChjb25zdCBuYW1lIG9mIHVzZWRDYWxscykge1xuICAgIGlmIChsb2NhbEZ1bmNOYW1lcy5o
YXMobmFtZSkgfHwgTkFUSVZFX0JVSUxUSU5TLmhhcyhuYW1lKSB8fCBuYW1lLnN0YXJ0c1dpdGgo
J3dhc20uJykgfHxcbiAgICAgICAgbmFtZS5zdGFydHNXaXRoKCd2MTI4LicpIHx8IEFUUkFfVkVD
VE9SX1RZUEVTLmhhcyhuYW1lLnNwbGl0KCcuJylbMF0pIHx8XG4gICAgICAgIE1BVEhfQlVJTFRJ
TlNbbmFtZV0gIT09IHVuZGVmaW5lZCB8fCBpbXBvcnRzLmZpbmQoaW0gPT4gaW0ubmFtZSA9PT0g
bmFtZSkpIGNvbnRpbnVlO1xuICAgIC8vIGNoZWNrIGZsYXR0ZW5lZCB1c2VySW1wb3J0cyB0aGVu
IGdsb2JhbFRoaXNcbiAgICBsZXQgZm4gPSBmbGF0SW1wb3J0c1tuYW1lXTtcbiAgICBpZiAoIWZu
ICYmIHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJykgZm4gPSBnbG9iYWxUaGlzW25h
bWVdO1xuICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNvbnN0IG5Q
YXJhbXMgPSBmbi5sZW5ndGg7XG4gICAgICBjb25zdCBwYXJhbXMgPSBbXTtcbiAgICAgIGZvciAo
bGV0IGsgPSAwOyBrIDwgblBhcmFtczsgaysrKSBwYXJhbXMucHVzaCh7IHR5cGU6ICdQYXJhbScs
IG5hbWU6ICd4JyArIGssIHZ0eXBlOiAnZjY0JywgaXNBcnJheTogZmFsc2UsIGFycmF5RGltczog
bnVsbCB9KTtcbiAgICAgIGhvc3RJbXBvcnRzLnB1c2goeyBuYW1lLCBtb2R1bGVOYW1lOiAnaG9z
dCcsIHBhcmFtcywgcmV0VHlwZTogJ2Y2NCcsIGludGVycElkeDogbnVsbCwganNGbjogZm4gfSk7
XG4gICAgfVxuICB9XG5cbiAgY29uc3QgYWxsSW1wb3J0cyA9IFsuLi5tYXRoSW1wb3J0cywgLi4u
aW1wb3J0cywgLi4uaG9zdEltcG9ydHNdO1xuXG4gIC8vIEJ1aWxkIGZ1bmN0aW9uIGluZGV4IHRh
YmxlOiBpbXBvcnRzIGZpcnN0LCB0aGVuIGxvY2FsIGZ1bmN0aW9uc1xuICBjb25zdCBmdW5jSW5k
ZXggPSB7fTtcbiAgbGV0IGlkeCA9IDA7XG4gIGZvciAoY29uc3QgaW0gb2YgYWxsSW1wb3J0cykg
eyBmdW5jSW5kZXhbaW0ubmFtZV0gPSBpZHgrKzsgfVxuICBmb3IgKGNvbnN0IGZuIG9mIGZ1bmN0
aW9ucykgeyBmdW5jSW5kZXhbZm4ubmFtZV0gPSBpZHgrKzsgfVxuXG4gIC8vIEdsb2JhbCBpbmRl
eCB0YWJsZSAoKyB0cmFjayBmdW5jU2lnIGZvciBmdW5jdGlvbi10eXBlZCBnbG9iYWxzKVxuICBj
b25zdCBnbG9iYWxJbmRleCA9IHt9O1xuICBjb25zdCBnbG9iYWxGdW5jU2lnID0ge307IC8vIG5h
bWUg4oaSIGZ1bmNTaWcgZm9yIGZ1bmN0aW9uLXR5cGVkIGdsb2JhbHNcbiAgZm9yIChsZXQgZ2kg
PSAwOyBnaSA8IGdsb2JhbHMubGVuZ3RoOyBnaSsrKSB7XG4gICAgZ2xvYmFsSW5kZXhbZ2xvYmFs
c1tnaV0ubmFtZV0gPSBnaTtcbiAgICBpZiAoZ2xvYmFsc1tnaV0uZnVuY1NpZykgZ2xvYmFsRnVu
Y1NpZ1tnbG9iYWxzW2dpXS5uYW1lXSA9IGdsb2JhbHNbZ2ldLmZ1bmNTaWc7XG4gIH1cblxuICAv
LyDilIDilIAgU2NhbiBmb3IgZnVuY3Rpb24gcmVmZXJlbmNlcyAoYmFyZSBmdW5jdGlvbiBuYW1l
cyB1c2VkIGFzIHZhbHVlcykg4pSA4pSAXG4gIGNvbnN0IHJlZmVyZW5jZWRGdW5jcyA9IG5ldyBT
ZXQoKTtcbiAgZnVuY3Rpb24gc2NhbkZ1bmNSZWZzKHN0bXRzLCBsb2NhbE5hbWVzKSB7XG4gICAg
Zm9yIChjb25zdCBzIG9mIHN0bXRzKSBzY2FuTm9kZVJlZnMocywgbG9jYWxOYW1lcyk7XG4gIH1c
biAgZnVuY3Rpb24gc2Nhbk5vZGVSZWZzKG5vZGUsIGxvY2FsTmFtZXMpIHtcbiAgICBpZiAoIW5v
ZGUgfHwgdHlwZW9mIG5vZGUgIT09ICdvYmplY3QnKSByZXR1cm47XG4gICAgaWYgKG5vZGUudHlw
ZSA9PT0gJ0lkZW50JyAmJiBmdW5jSW5kZXhbbm9kZS5uYW1lXSAhPT0gdW5kZWZpbmVkICYmICFs
b2NhbE5hbWVzLmhhcyhub2RlLm5hbWUpICYmIGdsb2JhbEluZGV4W25vZGUubmFtZV0gPT09IHVu
ZGVmaW5lZCkge1xuICAgICAgcmVmZXJlbmNlZEZ1bmNzLmFkZChub2RlLm5hbWUpO1xuICAgIH1c
biAgICBmb3IgKGNvbnN0IGsgb2YgT2JqZWN0LmtleXMobm9kZSkpIHtcbiAgICAgIGNvbnN0IHYg
PSBub2RlW2tdO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodikpIHYuZm9yRWFjaChjID0+IHNj
YW5Ob2RlUmVmcyhjLCBsb2NhbE5hbWVzKSk7XG4gICAgICBlbHNlIGlmICh2ICYmIHR5cGVvZiB2
ID09PSAnb2JqZWN0JyAmJiB2LnR5cGUpIHNjYW5Ob2RlUmVmcyh2LCBsb2NhbE5hbWVzKTtcbiAg
ICB9XG4gIH1cbiAgZm9yIChjb25zdCBmbiBvZiBmdW5jdGlvbnMpIHtcbiAgICBjb25zdCBsb2Nh
bE5hbWVzID0gbmV3IFNldCgpO1xuICAgIGZvciAoY29uc3QgcCBvZiBmbi5wYXJhbXMpIGxvY2Fs
TmFtZXMuYWRkKHAubmFtZSk7XG4gICAgZm9yIChjb25zdCBsIG9mIGZuLmxvY2FscykgbG9jYWxO
YW1lcy5hZGQobC5uYW1lKTtcbiAgICBpZiAoZm4udHlwZSA9PT0gJ0Z1bmN0aW9uJykgbG9jYWxO
YW1lcy5hZGQoZm4ubmFtZSk7IC8vIHJldHVybiB2YXJcbiAgICBzY2FuRnVuY1JlZnMoZm4uYm9k
eSwgbG9jYWxOYW1lcyk7XG4gIH1cblxuICAvLyBEZXRlY3QgaWYgY2FsbF9pbmRpcmVjdCBpcyBu
ZWVkZWQgKGZ1bmN0aW9uLXR5cGVkIHBhcmFtcy9sb2NhbHMvZ2xvYmFscyBleGlzdClcbiAgbGV0
IGhhc0luZGlyZWN0Q2FsbHMgPSBPYmplY3Qua2V5cyhnbG9iYWxGdW5jU2lnKS5sZW5ndGggPiAw
O1xuICBpZiAoIWhhc0luZGlyZWN0Q2FsbHMpIHtcbiAgICBmb3IgKGNvbnN0IGZuIG9mIGZ1bmN0
aW9ucykge1xuICAgICAgaWYgKGZuLnBhcmFtcy5zb21lKHAgPT4gcC5mdW5jU2lnKSB8fCBmbi5s
b2NhbHMuc29tZShsID0+IGwuZnVuY1NpZykpIHsgaGFzSW5kaXJlY3RDYWxscyA9IHRydWU7IGJy
ZWFrOyB9XG4gICAgfVxuICB9XG5cbiAgLy8gQnVpbGQgdGFibGU6IGV4cGxpY2l0bHkgcmVmZXJl
bmNlZCBmdW5jcyBhbHdheXM7IGlmIGNhbGxfaW5kaXJlY3QgdXNlZCwgYWxzbyBleHBsaWNpdCBp
bXBvcnRzICsgbG9jYWwgZnVuY3Rpb25zLlxuICAvLyBBdXRvLWltcG9ydHMgb25seSBlbnRlciB0
aGUgdGFibGUgaWYgZXhwbGljaXRseSByZWZlcmVuY2VkIGJ5IGJhcmUgbmFtZS5cbiAgY29uc3Qg
YXV0b0ltcG9ydE5hbWVzID0gbmV3IFNldChbLi4ubWF0aEltcG9ydHMubWFwKG0gPT4gbS5uYW1l
KSwgLi4uaG9zdEltcG9ydHMubWFwKG0gPT4gbS5uYW1lKV0pO1xuICBsZXQgdGFibGVGdW5jU2V0
O1xuICBpZiAoaGFzSW5kaXJlY3RDYWxscykge1xuICAgIHRhYmxlRnVuY1NldCA9IG5ldyBTZXQo
W1xuICAgICAgLi4uaW1wb3J0cy5tYXAoaW0gPT4gaW0ubmFtZSksXG4gICAgICAuLi5mdW5jdGlv
bnMubWFwKGZuID0+IGZuLm5hbWUpLFxuICAgICAgLi4ucmVmZXJlbmNlZEZ1bmNzLFxuICAgIF0p
O1xuICAgIC8vIEV4Y2x1ZGUgYXV0by1pbXBvcnRzIHRoYXQgYXJlbid0IGV4cGxpY2l0bHkgcmVm
ZXJlbmNlZCBieSBiYXJlIG5hbWVcbiAgICBmb3IgKGNvbnN0IG5hbWUgb2YgYXV0b0ltcG9ydE5h
bWVzKSB7XG4gICAgICBpZiAoIXJlZmVyZW5jZWRGdW5jcy5oYXMobmFtZSkpIHRhYmxlRnVuY1Nl
dC5kZWxldGUobmFtZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRhYmxlRnVuY1NldCA9IG5l
dyBTZXQocmVmZXJlbmNlZEZ1bmNzKTtcbiAgfVxuICBjb25zdCB0YWJsZUZ1bmNzID0gWy4uLnRh
YmxlRnVuY1NldF0uc29ydCgoYSwgYikgPT4gZnVuY0luZGV4W2FdIC0gZnVuY0luZGV4W2JdKTtc
biAgY29uc3QgdGFibGVTbG90ID0ge307IC8vIGZ1bmNOYW1lIOKGkiB0YWJsZSBpbmRleFxuICBm
b3IgKGxldCB0aSA9IDA7IHRpIDwgdGFibGVGdW5jcy5sZW5ndGg7IHRpKyspIHRhYmxlU2xvdFt0
YWJsZUZ1bmNzW3RpXV0gPSB0aTtcblxuICAvLyDilIDilIAgQnVpbGQgdHlwZSBzaWduYXR1cmVz
IOKUgOKUgFxuICBmdW5jdGlvbiBwYXJhbVdhc21UeXBlKHApIHsgcmV0dXJuIHAuaXNBcnJheSA/
ICdpMzInIDogcC52dHlwZTsgfVxuICBmdW5jdGlvbiBzaWdLZXkocGFyYW1zLCByZXRUeXBlKSB7
XG4gICAgcmV0dXJuIHBhcmFtcy5tYXAocCA9PiBwYXJhbVdhc21UeXBlKHApKS5qb2luKCcsJykg
KyAnOicgKyAocmV0VHlwZSB8fCAnJyk7XG4gIH1cbiAgY29uc3Qgc2lnTWFwID0gbmV3IE1hcCgp
O1xuICBjb25zdCBzaWdMaXN0ID0gW107IC8vIFt7cGFyYW1zLCByZXRUeXBlfV1cbiAgZnVuY3Rp
b24gZ2V0T3JBZGRTaWcocGFyYW1zLCByZXRUeXBlKSB7XG4gICAgY29uc3Qga2V5ID0gc2lnS2V5
KHBhcmFtcywgcmV0VHlwZSk7XG4gICAgaWYgKHNpZ01hcC5oYXMoa2V5KSkgcmV0dXJuIHNpZ01h
cC5nZXQoa2V5KTtcbiAgICBjb25zdCBpZCA9IHNpZ0xpc3QubGVuZ3RoO1xuICAgIHNpZ0xpc3Qu
cHVzaCh7IHBhcmFtcywgcmV0VHlwZSB9KTtcbiAgICBzaWdNYXAuc2V0KGtleSwgaWQpO1xuICAg
IHJldHVybiBpZDtcbiAgfVxuXG4gIC8vIFJlZ2lzdGVyIGFsbCBzaWduYXR1cmVzXG4gIGNvbnN0
IGltcG9ydFNpZ0lkcyA9IGFsbEltcG9ydHMubWFwKGltID0+IGdldE9yQWRkU2lnKGltLnBhcmFt
cywgaW0ucmV0VHlwZSkpO1xuICBjb25zdCBmdW5jU2lnSWRzID0gZnVuY3Rpb25zLm1hcChmbiA9
PiB7XG4gICAgY29uc3QgcmV0VHlwZSA9IGZuLnR5cGUgPT09ICdTdWJyb3V0aW5lJyA/IG51bGwg
OiBmbi5yZXRUeXBlO1xuICAgIHJldHVybiBnZXRPckFkZFNpZyhmbi5wYXJhbXMsIHJldFR5cGUp
O1xuICB9KTtcblxuICAvLyDilIDilIAgRGV0ZXJtaW5lIG1lbW9yeSDilIDilIBcbiAgY29uc3Qg
aGFzTWVtb3J5ID0gZnVuY3Rpb25zLnNvbWUoZm4gPT4gZm4ucGFyYW1zLnNvbWUocCA9PiBwLmlz
QXJyYXkpKTtcbiAgY29uc3QgaW1wb3J0TWVtb3J5ID0gdXNlckltcG9ydHMgJiYgdXNlckltcG9y
dHMuX19tZW1vcnk7XG5cbiAgLy8g4pSA4pSAIEVtaXQgV2FzbSBiaW5hcnkg4pSA4pSAXG4gIC8v
IE1hZ2ljICsgdmVyc2lvblxuICB3LmJ5dGVzKFsweDAwLCAweDYxLCAweDczLCAweDZkXSk7IC8v
IFxcMGFzbVxuICB3LmJ5dGVzKFsweDAxLCAweDAwLCAweDAwLCAweDAwXSk7IC8vIHZlcnNpb24g
MVxuXG4gIC8vIFR5cGUgc2VjdGlvbiAoMSlcbiAgdy5zZWN0aW9uKDEsIHMgPT4ge1xuICAgIHMu
dTMyKHNpZ0xpc3QubGVuZ3RoKTtcbiAgICBmb3IgKGNvbnN0IHNpZyBvZiBzaWdMaXN0KSB7XG4g
ICAgICBzLmJ5dGUoMHg2MCk7IC8vIGZ1bmMgdHlwZVxuICAgICAgcy51MzIoc2lnLnBhcmFtcy5s
ZW5ndGgpO1xuICAgICAgZm9yIChjb25zdCBwIG9mIHNpZy5wYXJhbXMpIHMuYnl0ZSh3YXNtVHlw
ZShwYXJhbVdhc21UeXBlKHApKSk7XG4gICAgICBpZiAoc2lnLnJldFR5cGUpIHsgcy51MzIoMSk7
IHMuYnl0ZSh3YXNtVHlwZShzaWcucmV0VHlwZSkpOyB9XG4gICAgICBlbHNlIHMudTMyKDApO1xu
ICAgIH1cbiAgfSk7XG5cbiAgLy8gSW1wb3J0IHNlY3Rpb24gKDIpXG4gIGlmIChhbGxJbXBvcnRz
Lmxlbmd0aCA+IDAgfHwgaW1wb3J0TWVtb3J5KSB7XG4gICAgdy5zZWN0aW9uKDIsIHMgPT4ge1xu
ICAgICAgcy51MzIoYWxsSW1wb3J0cy5sZW5ndGggKyAoaW1wb3J0TWVtb3J5ID8gMSA6IDApKTtc
biAgICAgIGZvciAobGV0IGlpID0gMDsgaWkgPCBhbGxJbXBvcnRzLmxlbmd0aDsgaWkrKykge1xu
ICAgICAgICBjb25zdCBpbSA9IGFsbEltcG9ydHNbaWldO1xuICAgICAgICBzLnN0cihpbS5tb2R1
bGVOYW1lKTtcbiAgICAgICAgcy5zdHIoaW0ubmFtZSk7XG4gICAgICAgIHMuYnl0ZSgweDAwKTsg
Ly8gZnVuYyBpbXBvcnRcbiAgICAgICAgcy51MzIoaW1wb3J0U2lnSWRzW2lpXSk7XG4gICAgICB9
XG4gICAgICBpZiAoaW1wb3J0TWVtb3J5KSB7XG4gICAgICAgIHMuc3RyKCdlbnYnKTtcbiAgICAg
ICAgcy5zdHIoJ21lbW9yeScpO1xuICAgICAgICBzLmJ5dGUoMHgwMik7IC8vIG1lbW9yeSBpbXBv
cnRcbiAgICAgICAgcy5ieXRlKDB4MDApOyAvLyBubyBtYXhcbiAgICAgICAgcy51MzIoMSk7IC8v
IGluaXRpYWwgMSBwYWdlXG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvLyBGdW5jdGlvbiBz
ZWN0aW9uICgzKVxuICB3LnNlY3Rpb24oMywgcyA9PiB7XG4gICAgcy51MzIoZnVuY3Rpb25zLmxl
bmd0aCk7XG4gICAgZm9yIChjb25zdCBzaWdJZCBvZiBmdW5jU2lnSWRzKSBzLnUzMihzaWdJZCk7
XG4gIH0pO1xuXG4gIC8vIFRhYmxlIHNlY3Rpb24gKDQpIOKAlCBvbmx5IGlmIGNhbGxfaW5kaXJl
Y3QgaXMgdXNlZFxuICBpZiAodGFibGVGdW5jcy5sZW5ndGggPiAwKSB7XG4gICAgdy5zZWN0aW9u
KDQsIHMgPT4ge1xuICAgICAgcy51MzIoMSk7IC8vIG9uZSB0YWJsZVxuICAgICAgcy5ieXRlKDB4
NzApOyAvLyBmdW5jcmVmXG4gICAgICBzLmJ5dGUoMHgwMCk7IC8vIG5vIG1heFxuICAgICAgcy51
MzIodGFibGVGdW5jcy5sZW5ndGgpOyAvLyBpbml0aWFsIHNpemUgPSBudW1iZXIgb2YgcmVmZXJl
bmNlZCBmdW5jdGlvbnNcbiAgICB9KTtcbiAgfVxuXG4gIC8vIE1lbW9yeSBzZWN0aW9uICg1KSDi
gJQgb25seSBpZiBhcnJheXMgdXNlZCBhbmQgbm8gaW1wb3J0ZWQgbWVtb3J5XG4gIGlmIChoYXNN
ZW1vcnkgJiYgIWltcG9ydE1lbW9yeSkge1xuICAgIHcuc2VjdGlvbig1LCBzID0+IHtcbiAgICAg
IHMudTMyKDEpO1xuICAgICAgcy5ieXRlKDB4MDApOyAvLyBubyBtYXhcbiAgICAgIHMudTMyKDEp
OyAvLyBpbml0aWFsOiAxIHBhZ2UgKDY0S0IpXG4gICAgfSk7XG4gIH1cblxuICAvLyBHbG9iYWwg
c2VjdGlvbiAoNilcbiAgaWYgKGdsb2JhbHMubGVuZ3RoID4gMCkge1xuICAgIHcuc2VjdGlvbig2
LCBzID0+IHtcbiAgICAgIHMudTMyKGdsb2JhbHMubGVuZ3RoKTtcbiAgICAgIGZvciAoY29uc3Qg
ZyBvZiBnbG9iYWxzKSB7XG4gICAgICAgIHMuYnl0ZSh3YXNtVHlwZShnLnZ0eXBlKSk7XG4gICAg
ICAgIHMuYnl0ZShnLm11dGFibGUgPyAweDAxIDogMHgwMCk7XG4gICAgICAgIC8vIGluaXQgZXhw
cmVzc2lvblxuICAgICAgICBlbWl0Q29uc3RFeHByKHMsIGcuaW5pdCwgZy52dHlwZSk7XG4gICAg
ICAgIHMuYnl0ZShPUF9FTkQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLy8gRXhwb3J0
IHNlY3Rpb24gKDcpXG4gIHcuc2VjdGlvbig3LCBzID0+IHtcbiAgICBjb25zdCBleHBvcnRzID0g
ZnVuY3Rpb25zLm1hcCgoZm4sIGkpID0+ICh7IG5hbWU6IGZuLm5hbWUsIGlkeDogYWxsSW1wb3J0
cy5sZW5ndGggKyBpIH0pKTtcbiAgICBjb25zdCBtZW1FeHBvcnQgPSAoaGFzTWVtb3J5ICYmICFp
bXBvcnRNZW1vcnkpID8gMSA6IDA7XG4gICAgcy51MzIoZXhwb3J0cy5sZW5ndGggKyBtZW1FeHBv
cnQpO1xuICAgIGZvciAoY29uc3QgZSBvZiBleHBvcnRzKSB7XG4gICAgICBzLnN0cihlLm5hbWUp
O1xuICAgICAgcy5ieXRlKDB4MDApOyAvLyBmdW5jIGV4cG9ydFxuICAgICAgcy51MzIoZS5pZHgp
O1xuICAgIH1cbiAgICBpZiAobWVtRXhwb3J0KSB7XG4gICAgICBzLnN0cignbWVtb3J5Jyk7XG4g
ICAgICBzLmJ5dGUoMHgwMik7IC8vIG1lbW9yeSBleHBvcnRcbiAgICAgIHMudTMyKDApO1xuICAg
IH1cbiAgfSk7XG5cbiAgLy8gRWxlbWVudCBzZWN0aW9uICg5KSDigJQgcG9wdWxhdGUgdGhlIHRh
YmxlIHdpdGggZnVuY3Rpb24gcmVmZXJlbmNlc1xuICBpZiAodGFibGVGdW5jcy5sZW5ndGggPiAw
KSB7XG4gICAgdy5zZWN0aW9uKDksIHMgPT4ge1xuICAgICAgcy51MzIoMSk7IC8vIG9uZSBlbGVt
ZW50IHNlZ21lbnRcbiAgICAgIHMudTMyKDApOyAvLyB0YWJsZSBpbmRleCAwXG4gICAgICAvLyBv
ZmZzZXQgZXhwcmVzc2lvbjogaTMyLmNvbnN0IDBcbiAgICAgIHMuYnl0ZShPUF9JMzJfQ09OU1Qp
OyBzLnMzMigwKTsgcy5ieXRlKE9QX0VORCk7XG4gICAgICBzLnUzMih0YWJsZUZ1bmNzLmxlbmd0
aCk7XG4gICAgICBmb3IgKGNvbnN0IGZuYW1lIG9mIHRhYmxlRnVuY3MpIHMudTMyKGZ1bmNJbmRl
eFtmbmFtZV0pO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gQ29kZSBzZWN0aW9uICgxMClcbiAgdy5z
ZWN0aW9uKDEwLCBzID0+IHtcbiAgICBzLnUzMihmdW5jdGlvbnMubGVuZ3RoKTtcbiAgICBmb3Ig
KGNvbnN0IGZuIG9mIGZ1bmN0aW9ucykge1xuICAgICAgY29uc3QgYm9keVdyaXRlciA9IG5ldyBC
eXRlV3JpdGVyKCk7XG4gICAgICBlbWl0RnVuY3Rpb25Cb2R5KGJvZHlXcml0ZXIsIGZuKTtcbiAg
ICAgIHMudTMyKGJvZHlXcml0ZXIuYnVmLmxlbmd0aCk7XG4gICAgICBzLmJ5dGVzKGJvZHlXcml0
ZXIuYnVmKTtcbiAgICB9XG4gIH0pO1xuXG4gIGNvbnN0IGJ5dGVzID0gdy50b1VpbnQ4QXJyYXko
KTtcbiAgY29uc3QgdGFibGUgPSB0YWJsZUZ1bmNzLmxlbmd0aCA+IDAgPyB7IC4uLnRhYmxlU2xv
dCB9IDogbnVsbDtcbiAgcmV0dXJuIHsgYnl0ZXMsIHRhYmxlIH07XG5cbiAgLy8g4pSA4pSAIEhl
bHBlcjogZW1pdCBjb25zdGFudCBpbml0IGV4cHJlc3Npb24g4pSA4pSAXG4gIGZ1bmN0aW9uIGVt
aXRDb25zdEV4cHIocywgbm9kZSwgdnR5cGUpIHtcbiAgICBpZiAoIW5vZGUpIHtcbiAgICAgIC8v
IGRlZmF1bHQgemVyb1xuICAgICAgaWYgKHZ0eXBlID09PSAnaTMyJykgeyBzLmJ5dGUoT1BfSTMy
X0NPTlNUKTsgcy5zMzIoMCk7IH1cbiAgICAgIGVsc2UgaWYgKHZ0eXBlID09PSAnaTY0JykgeyBz
LmJ5dGUoT1BfSTY0X0NPTlNUKTsgcy5zNjQoMG4pOyB9XG4gICAgICBlbHNlIGlmICh2dHlwZSA9
PT0gJ2YzMicpIHsgcy5ieXRlKE9QX0YzMl9DT05TVCk7IHMuZjMyKDApOyB9XG4gICAgICBlbHNl
IGlmICh2dHlwZSA9PT0gJ2Y2NCcpIHsgcy5ieXRlKE9QX0Y2NF9DT05TVCk7IHMuZjY0KDApOyB9
XG4gICAgICBlbHNlIGlmIChpc1ZlY3Rvcih2dHlwZSkpIHtcbiAgICAgICAgLy8gdjEyOC5jb25z
dCB3aXRoIDE2IHplcm8gYnl0ZXNcbiAgICAgICAgcy5ieXRlKE9QX1NJTURfUFJFRklYKTsgcy51
MzIoU0lNRF9PUFNbJ3YxMjguY29uc3QnXSk7XG4gICAgICAgIGZvciAobGV0IHZpID0gMDsgdmkg
PCAxNjsgdmkrKykgcy5ieXRlKDApO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAg
ICBpZiAobm9kZS50eXBlID09PSAnTnVtYmVyTGl0Jykge1xuICAgICAgY29uc3QgdmFsID0gcGFy
c2VOdW1lcmljVmFsdWUobm9kZSwgdnR5cGUpO1xuICAgICAgZW1pdFR5cGVkQ29uc3QocywgdnR5
cGUsIHZhbCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChub2RlLnR5cGUgPT09ICdV
bmFyeU9wJyAmJiBub2RlLm9wID09PSAnLScgJiYgbm9kZS5vcGVyYW5kLnR5cGUgPT09ICdOdW1i
ZXJMaXQnKSB7XG4gICAgICBjb25zdCB2YWwgPSAtcGFyc2VOdW1lcmljVmFsdWUobm9kZS5vcGVy
YW5kLCB2dHlwZSk7XG4gICAgICBlbWl0VHlwZWRDb25zdChzLCB2dHlwZSwgdmFsKTtcbiAgICAg
IHJldHVybjtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdHbG9iYWwgaW5pdCBtdXN0IGJl
IGEgY29uc3RhbnQgZXhwcmVzc2lvbicpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VOdW1lcmlj
VmFsdWUobm9kZSwgZGVmYXVsdFR5cGUpIHtcbiAgICBjb25zdCByYXcgPSBub2RlLnZhbHVlO1xu
ICAgIGlmIChyYXcuaW5jbHVkZXMoJy4nKSB8fCByYXcuaW5jbHVkZXMoJ2UnKSB8fCByYXcuaW5j
bHVkZXMoJ0UnKSB8fCBub2RlLmlzRmxvYXQpIHJldHVybiBwYXJzZUZsb2F0KHJhdyk7XG4gICAg
cmV0dXJuIHBhcnNlSW50KHJhdywgMTApO1xuICB9XG5cbiAgZnVuY3Rpb24gZW1pdFR5cGVkQ29u
c3QocywgdnR5cGUsIHZhbCkge1xuICAgIGlmICh2dHlwZSA9PT0gJ2kzMicpIHsgcy5ieXRlKE9Q
X0kzMl9DT05TVCk7IHMuczMyKHZhbCB8IDApOyB9XG4gICAgZWxzZSBpZiAodnR5cGUgPT09ICdp
NjQnKSB7IHMuYnl0ZShPUF9JNjRfQ09OU1QpOyBzLnM2NChCaWdJbnQodmFsKSk7IH1cbiAgICBl
bHNlIGlmICh2dHlwZSA9PT0gJ2YzMicpIHsgcy5ieXRlKE9QX0YzMl9DT05TVCk7IHMuZjMyKHZh
bCk7IH1cbiAgICBlbHNlIGlmICh2dHlwZSA9PT0gJ2Y2NCcpIHsgcy5ieXRlKE9QX0Y2NF9DT05T
VCk7IHMuZjY0KHZhbCk7IH1cbiAgfVxuXG4gIC8vIOKUgOKUgCBFbWl0IGZ1bmN0aW9uIGJvZHkg
4pSA4pSAXG4gIGZ1bmN0aW9uIGVtaXRGdW5jdGlvbkJvZHkoYncsIGZuKSB7XG4gICAgY29uc3Qg
aXNGdW5jID0gZm4udHlwZSA9PT0gJ0Z1bmN0aW9uJztcbiAgICBjb25zdCByZXRUeXBlID0gaXNG
dW5jID8gZm4ucmV0VHlwZSA6IG51bGw7XG5cbiAgICAvLyBCdWlsZCBsb2NhbCBtYXA6IHBhcmFt
cyArIGxvY2FscyArIHJldHVybiB2YXJcbiAgICBjb25zdCBsb2NhbE1hcCA9IHt9OyAvLyBuYW1l
IOKGkiB7IGlkeCwgdnR5cGUgfVxuICAgIGxldCBsb2NhbElkeCA9IDA7XG4gICAgZm9yIChjb25z
dCBwIG9mIGZuLnBhcmFtcykge1xuICAgICAgY29uc3QgZW50cnkgPSB7XG4gICAgICAgIGlkeDog
bG9jYWxJZHgrKyxcbiAgICAgICAgdnR5cGU6IHAuaXNBcnJheSA/ICdpMzInIDogcC52dHlwZSwg
Ly8gV2FzbSB0eXBlOiBhcnJheXMgYXJlIGkzMiBwb2ludGVyc1xuICAgICAgICBpc0FycmF5OiBw
LmlzQXJyYXksXG4gICAgICAgIGFycmF5RGltczogcC5hcnJheURpbXMsXG4gICAgICAgIGVsZW1U
eXBlOiBwLmlzQXJyYXkgPyBwLnZ0eXBlIDogbnVsbCAgLy8gZWxlbWVudCB0eXBlIGZvciBsb2Fk
L3N0b3JlXG4gICAgICB9O1xuICAgICAgaWYgKHAuZnVuY1NpZykgZW50cnkuZnVuY1NpZyA9IHAu
ZnVuY1NpZztcbiAgICAgIGxvY2FsTWFwW3AubmFtZV0gPSBlbnRyeTtcbiAgICB9XG4gICAgLy8g
QWRkaXRpb25hbCBsb2NhbHMgZGVjbGFyZWRcbiAgICBjb25zdCBkZWNsYXJlZExvY2FscyA9IFsu
Li5mbi5sb2NhbHNdO1xuICAgIGlmIChpc0Z1bmMpIHtcbiAgICAgIC8vIGhpZGRlbiByZXR1cm4g
bG9jYWwgKHVzZXMgZnVuY3Rpb24gbmFtZSlcbiAgICAgIGRlY2xhcmVkTG9jYWxzLnB1c2goeyBu
YW1lOiAnJF9yZXR1cm4nLCB2dHlwZTogcmV0VHlwZSB9KTtcbiAgICB9XG4gICAgZm9yIChjb25z
dCBsb2Mgb2YgZGVjbGFyZWRMb2NhbHMpIHtcbiAgICAgIGNvbnN0IGVudHJ5ID0geyBpZHg6IGxv
Y2FsSWR4KyssIHZ0eXBlOiBsb2MudnR5cGUgfTtcbiAgICAgIGlmIChsb2MuZnVuY1NpZykgZW50
cnkuZnVuY1NpZyA9IGxvYy5mdW5jU2lnO1xuICAgICAgbG9jYWxNYXBbbG9jLm5hbWVdID0gZW50
cnk7XG4gICAgfVxuXG4gICAgLy8gRW1pdCBsb2NhbCBkZWNsYXJhdGlvbnMgKG9ubHkgdGhlIG5v
bi1wYXJhbSBvbmVzKVxuICAgIGNvbnN0IGxvY2FsVHlwZXMgPSBkZWNsYXJlZExvY2Fscy5tYXAo
bCA9PiBsLnZ0eXBlKTtcbiAgICAvLyBDb21wcmVzczogcnVucyBvZiBzYW1lIHR5cGVcbiAgICBj
b25zdCBsb2NhbFJ1bnMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGx0IG9mIGxvY2FsVHlwZXMpIHtc
biAgICAgIGlmIChsb2NhbFJ1bnMubGVuZ3RoID4gMCAmJiBsb2NhbFJ1bnNbbG9jYWxSdW5zLmxl
bmd0aCAtIDFdLnR5cGUgPT09IGx0KSBsb2NhbFJ1bnNbbG9jYWxSdW5zLmxlbmd0aCAtIDFdLmNv
dW50Kys7XG4gICAgICBlbHNlIGxvY2FsUnVucy5wdXNoKHsgY291bnQ6IDEsIHR5cGU6IGx0IH0p
O1xuICAgIH1cbiAgICBidy51MzIobG9jYWxSdW5zLmxlbmd0aCk7XG4gICAgZm9yIChjb25zdCBy
dW4gb2YgbG9jYWxSdW5zKSB7XG4gICAgICBidy51MzIocnVuLmNvdW50KTtcbiAgICAgIGJ3LmJ5
dGUod2FzbVR5cGUocnVuLnR5cGUpKTtcbiAgICB9XG5cbiAgICAvLyBTSU1EIGhlbHBlclxuICAg
IGZ1bmN0aW9uIGVtaXRTaW1kKG9wKSB7IGJ3LmJ5dGUoT1BfU0lNRF9QUkVGSVgpOyBidy51MzIo
b3ApOyB9XG5cbiAgICAvLyBFbWl0IGJvZHkgc3RhdGVtZW50c1xuICAgIGxldCBkZXB0aCA9IDA7
IC8vIGN1cnJlbnQgYmxvY2sgbmVzdGluZyBkZXB0aFxuICAgIGNvbnN0IGJyZWFrVGFyZ2V0cyA9
IFtdOyAvLyBzdGFjayBvZiB7ZGVwdGh9IGZvciBlYWNoIGVuY2xvc2luZyBsb29wJ3MgYnJlYWsg
YmxvY2tcblxuICAgIGZ1bmN0aW9uIGVtaXRTdG10cyhzdG10cykgeyBmb3IgKGNvbnN0IHMgb2Yg
c3RtdHMpIGVtaXRTdG10KHMpOyB9XG5cbiAgICBmdW5jdGlvbiBlbWl0U3RtdChzdG10KSB7XG4g
ICAgICBzd2l0Y2ggKHN0bXQudHlwZSkge1xuICAgICAgICBjYXNlICdBc3NpZ24nOiB7XG4gICAg
ICAgICAgY29uc3QgdGFyZ2V0ID0gc3RtdC5uYW1lO1xuICAgICAgICAgIC8vIEFzc2lnbm1lbnQg
dG8gZnVuY3Rpb24gbmFtZSA9IHNldCByZXR1cm4gdmFyaWFibGVcbiAgICAgICAgICBpZiAoaXNG
dW5jICYmIHRhcmdldCA9PT0gZm4ubmFtZSkge1xuICAgICAgICAgICAgZW1pdEV4cHIoc3RtdC52
YWx1ZSwgcmV0VHlwZSk7XG4gICAgICAgICAgICBidy5ieXRlKE9QX0xPQ0FMX1NFVCk7XG4gICAg
ICAgICAgICBidy51MzIobG9jYWxNYXBbJyRfcmV0dXJuJ10uaWR4KTtcbiAgICAgICAgICB9IGVs
c2UgaWYgKGxvY2FsTWFwW3RhcmdldF0pIHtcbiAgICAgICAgICAgIGVtaXRFeHByKHN0bXQudmFs
dWUsIGxvY2FsTWFwW3RhcmdldF0udnR5cGUpO1xuICAgICAgICAgICAgYncuYnl0ZShPUF9MT0NB
TF9TRVQpO1xuICAgICAgICAgICAgYncudTMyKGxvY2FsTWFwW3RhcmdldF0uaWR4KTtcbiAgICAg
ICAgICB9IGVsc2UgaWYgKGdsb2JhbEluZGV4W3RhcmdldF0gIT09IHVuZGVmaW5lZCkge1xuICAg
ICAgICAgICAgZW1pdEV4cHIoc3RtdC52YWx1ZSwgZ2xvYmFsc1tnbG9iYWxJbmRleFt0YXJnZXRd
XS52dHlwZSk7XG4gICAgICAgICAgICBidy5ieXRlKE9QX0dMT0JBTF9TRVQpO1xuICAgICAgICAg
ICAgYncudTMyKGdsb2JhbEluZGV4W3RhcmdldF0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAg
ICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZGVmaW5lZCB2YXJpYWJsZTogJHt0YXJnZXR9YCk7
XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2Ug
J0FycmF5U3RvcmUnOiB7XG4gICAgICAgICAgY29uc3QgaW5mbyA9IGxvY2FsTWFwW3N0bXQubmFt
ZV07XG4gICAgICAgICAgaWYgKCFpbmZvKSB0aHJvdyBuZXcgRXJyb3IoYFVuZGVmaW5lZCBhcnJh
eTogJHtzdG10Lm5hbWV9YCk7XG4gICAgICAgICAgY29uc3QgZWxlbVR5cGUgPSBpbmZvLmVsZW1U
eXBlIHx8IGluZm8udnR5cGU7XG4gICAgICAgICAgLy8gY29tcHV0ZSBhZGRyZXNzXG4gICAgICAg
ICAgZW1pdEFycmF5QWRkcihzdG10Lm5hbWUsIHN0bXQuaW5kaWNlcywgaW5mbywgZWxlbVR5cGUp
O1xuICAgICAgICAgIC8vIGNvbXB1dGUgdmFsdWVcbiAgICAgICAgICBlbWl0RXhwcihzdG10LnZh
bHVlLCBlbGVtVHlwZSk7XG4gICAgICAgICAgLy8gc3RvcmVcbiAgICAgICAgICBlbWl0U3RvcmUo
ZWxlbVR5cGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ0lm
Jzoge1xuICAgICAgICAgIGVtaXRFeHByKHN0bXQuY29uZCwgJ2kzMicpO1xuICAgICAgICAgIGJ3
LmJ5dGUoT1BfSUYpO1xuICAgICAgICAgIGJ3LmJ5dGUoV0FTTV9WT0lEKTtcbiAgICAgICAgICBk
ZXB0aCsrO1xuICAgICAgICAgIGVtaXRTdG10cyhzdG10LmJvZHkpO1xuICAgICAgICAgIGlmIChz
dG10LmVsc2VCb2R5KSB7XG4gICAgICAgICAgICBidy5ieXRlKE9QX0VMU0UpO1xuICAgICAgICAg
ICAgZW1pdFN0bXRzKHN0bXQuZWxzZUJvZHkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZXB0
aC0tO1xuICAgICAgICAgIGJ3LmJ5dGUoT1BfRU5EKTtcbiAgICAgICAgICBicmVhaztcbiAgICAg
ICAgfVxuICAgICAgICBjYXNlICdGb3InOiB7XG4gICAgICAgICAgY29uc3QgdkluZm8gPSBsb2Nh
bE1hcFtzdG10LnZhck5hbWVdO1xuICAgICAgICAgIGlmICghdkluZm8pIHRocm93IG5ldyBFcnJv
cihgVW5kZWZpbmVkIGxvb3AgdmFyaWFibGU6ICR7c3RtdC52YXJOYW1lfWApO1xuICAgICAgICAg
IGNvbnN0IHZ0ID0gdkluZm8udnR5cGU7XG4gICAgICAgICAgZW1pdEV4cHIoc3RtdC5zdGFydCwg
dnQpO1xuICAgICAgICAgIGJ3LmJ5dGUoT1BfTE9DQUxfU0VUKTtcbiAgICAgICAgICBidy51MzIo
dkluZm8uaWR4KTtcblxuICAgICAgICAgIGNvbnN0IGhhc1N0ZXAgPSBzdG10LnN0ZXAgIT09IG51
bGw7XG5cbiAgICAgICAgICBidy5ieXRlKE9QX0JMT0NLKTsgYncuYnl0ZShXQVNNX1ZPSUQpOyBk
ZXB0aCsrO1xuICAgICAgICAgIGNvbnN0IGJyZWFrRGVwdGggPSBkZXB0aDsgLy8gYnJlYWsgdGFy
Z2V0ID0gdGhpcyBibG9ja1xuICAgICAgICAgIGJ3LmJ5dGUoT1BfTE9PUCk7IGJ3LmJ5dGUoV0FT
TV9WT0lEKTsgZGVwdGgrKztcbiAgICAgICAgICBicmVha1RhcmdldHMucHVzaChicmVha0RlcHRo
KTtcblxuICAgICAgICAgIC8vIGNvbmRpdGlvbiBjaGVjazogYnJfaWYgdG8gYnJlYWsgYmxvY2tc
biAgICAgICAgICBidy5ieXRlKE9QX0xPQ0FMX0dFVCk7IGJ3LnUzMih2SW5mby5pZHgpO1xuICAg
ICAgICAgIGVtaXRFeHByKHN0bXQuZW5kLCB2dCk7XG4gICAgICAgICAgaWYgKCFoYXNTdGVwKSB7
XG4gICAgICAgICAgICBlbWl0Q21wKCc+PScsIHZ0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAg
ICAgICAgICAgY29uc3Qgc3RlcElzTmVnTGl0ID0gc3RtdC5zdGVwLnR5cGUgPT09ICdVbmFyeU9w
JyAmJiBzdG10LnN0ZXAub3AgPT09ICctJyAmJiBzdG10LnN0ZXAub3BlcmFuZC50eXBlID09PSAn
TnVtYmVyTGl0JztcbiAgICAgICAgICAgIGNvbnN0IHN0ZXBJc05lZ0NvbnN0ID0gc3RlcElzTmVn
TGl0IHx8IChzdG10LnN0ZXAudHlwZSA9PT0gJ051bWJlckxpdCcgJiYgcGFyc2VGbG9hdChzdG10
LnN0ZXAudmFsdWUpIDwgMCk7XG4gICAgICAgICAgICBlbWl0Q21wKHN0ZXBJc05lZ0NvbnN0ID8g
Jzw9JyA6ICc+PScsIHZ0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYncuYnl0ZShPUF9CUl9J
Rik7IGJ3LnUzMihkZXB0aCAtIGJyZWFrRGVwdGgpO1xuXG4gICAgICAgICAgZW1pdFN0bXRzKHN0
bXQuYm9keSk7XG5cbiAgICAgICAgICAvLyBpbmNyZW1lbnRcbiAgICAgICAgICBidy5ieXRlKE9Q
X0xPQ0FMX0dFVCk7IGJ3LnUzMih2SW5mby5pZHgpO1xuICAgICAgICAgIGlmIChoYXNTdGVwKSB7
IGVtaXRFeHByKHN0bXQuc3RlcCwgdnQpOyB9IGVsc2UgeyBlbWl0VHlwZWRDb25zdChidywgdnQs
IDEpOyB9XG4gICAgICAgICAgZW1pdEFkZCh2dCk7XG4gICAgICAgICAgYncuYnl0ZShPUF9MT0NB
TF9TRVQpOyBidy51MzIodkluZm8uaWR4KTtcblxuICAgICAgICAgIGJ3LmJ5dGUoT1BfQlIpOyBi
dy51MzIoMCk7IC8vIGNvbnRpbnVlIHRvIGxvb3BcbiAgICAgICAgICBkZXB0aC0tOyBidy5ieXRl
KE9QX0VORCk7IC8vIGVuZCBsb29wXG4gICAgICAgICAgYnJlYWtUYXJnZXRzLnBvcCgpO1xuICAg
ICAgICAgIGRlcHRoLS07IGJ3LmJ5dGUoT1BfRU5EKTsgLy8gZW5kIGJsb2NrXG4gICAgICAgICAg
YnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnV2hpbGUnOiB7XG4gICAgICAgICAgYncu
Ynl0ZShPUF9CTE9DSyk7IGJ3LmJ5dGUoV0FTTV9WT0lEKTsgZGVwdGgrKztcbiAgICAgICAgICBj
b25zdCBicmVha0RlcHRoID0gZGVwdGg7XG4gICAgICAgICAgYncuYnl0ZShPUF9MT09QKTsgYncu
Ynl0ZShXQVNNX1ZPSUQpOyBkZXB0aCsrO1xuICAgICAgICAgIGJyZWFrVGFyZ2V0cy5wdXNoKGJy
ZWFrRGVwdGgpO1xuXG4gICAgICAgICAgZW1pdEV4cHIoc3RtdC5jb25kLCAnaTMyJyk7XG4gICAg
ICAgICAgYncuYnl0ZShPUF9JMzJfRVFaKTtcbiAgICAgICAgICBidy5ieXRlKE9QX0JSX0lGKTsg
YncudTMyKGRlcHRoIC0gYnJlYWtEZXB0aCk7XG5cbiAgICAgICAgICBlbWl0U3RtdHMoc3RtdC5i
b2R5KTtcblxuICAgICAgICAgIGJ3LmJ5dGUoT1BfQlIpOyBidy51MzIoMCk7IC8vIGNvbnRpbnVl
IGxvb3BcbiAgICAgICAgICBkZXB0aC0tOyBidy5ieXRlKE9QX0VORCk7IC8vIGVuZCBsb29wXG4g
ICAgICAgICAgYnJlYWtUYXJnZXRzLnBvcCgpO1xuICAgICAgICAgIGRlcHRoLS07IGJ3LmJ5dGUo
T1BfRU5EKTsgLy8gZW5kIGJsb2NrXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAg
ICAgY2FzZSAnRG9XaGlsZSc6IHtcbiAgICAgICAgICBidy5ieXRlKE9QX0JMT0NLKTsgYncuYnl0
ZShXQVNNX1ZPSUQpOyBkZXB0aCsrO1xuICAgICAgICAgIGNvbnN0IGJyZWFrRGVwdGggPSBkZXB0
aDtcbiAgICAgICAgICBidy5ieXRlKE9QX0xPT1ApOyBidy5ieXRlKFdBU01fVk9JRCk7IGRlcHRo
Kys7XG4gICAgICAgICAgYnJlYWtUYXJnZXRzLnB1c2goYnJlYWtEZXB0aCk7XG5cbiAgICAgICAg
ICBlbWl0U3RtdHMoc3RtdC5ib2R5KTtcblxuICAgICAgICAgIGVtaXRFeHByKHN0bXQuY29uZCwg
J2kzMicpO1xuICAgICAgICAgIGJ3LmJ5dGUoT1BfQlJfSUYpOyBidy51MzIoMCk7IC8vIGNvbnRp
bnVlIGlmIHRydWVcblxuICAgICAgICAgIGRlcHRoLS07IGJ3LmJ5dGUoT1BfRU5EKTsgLy8gZW5k
IGxvb3BcbiAgICAgICAgICBicmVha1RhcmdldHMucG9wKCk7XG4gICAgICAgICAgZGVwdGgtLTsg
YncuYnl0ZShPUF9FTkQpOyAvLyBlbmQgYmxvY2tcbiAgICAgICAgICBicmVhaztcbiAgICAgICAg
fVxuICAgICAgICBjYXNlICdCcmVhayc6IHtcbiAgICAgICAgICBpZiAoYnJlYWtUYXJnZXRzLmxl
bmd0aCA9PT0gMCkgdGhyb3cgbmV3IEVycm9yKCdicmVhayBvdXRzaWRlIGxvb3AnKTtcbiAgICAg
ICAgICBjb25zdCB0YXJnZXREZXB0aCA9IGJyZWFrVGFyZ2V0c1ticmVha1RhcmdldHMubGVuZ3Ro
IC0gMV07XG4gICAgICAgICAgYncuYnl0ZShPUF9CUik7XG4gICAgICAgICAgYncudTMyKGRlcHRo
IC0gdGFyZ2V0RGVwdGgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNh
c2UgJ0NhbGwnOiB7XG4gICAgICAgICAgLy8gRWFybHkgcmV0dXJuOiBjYWxsIHJldHVybihleHBy
KSBvciBjYWxsIHJldHVybigpXG4gICAgICAgICAgaWYgKHN0bXQubmFtZSA9PT0gJ3JldHVybicp
IHtcbiAgICAgICAgICAgIGlmIChpc0Z1bmMpIHtcbiAgICAgICAgICAgICAgaWYgKHN0bXQuYXJn
cy5sZW5ndGggIT09IDEpIHRocm93IG5ldyBFcnJvcigncmV0dXJuKCkgaW4gYSBmdW5jdGlvbiBy
ZXF1aXJlcyBleGFjdGx5IG9uZSBhcmd1bWVudCcpO1xuICAgICAgICAgICAgICBlbWl0RXhwcihz
dG10LmFyZ3NbMF0sIHJldFR5cGUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAg
ICAgaWYgKHN0bXQuYXJncy5sZW5ndGggIT09IDApIHRocm93IG5ldyBFcnJvcigncmV0dXJuKCkg
aW4gYSBzdWJyb3V0aW5lIHRha2VzIG5vIGFyZ3VtZW50cycpO1xuICAgICAgICAgICAgfVxuICAg
ICAgICAgICAgYncuYnl0ZShPUF9SRVRVUk4pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAg
ICAgfVxuICAgICAgICAgIC8vIFNJTUQgbmFtZXNwYWNlZCBidWlsdGlucyB1c2VkIGFzIHN0YXRl
bWVudHMgKGUuZy4gY2FsbCB2MTI4LnN0b3JlKC4uLikpXG4gICAgICAgICAgY29uc3QgY2FsbERv
dElkeCA9IHN0bXQubmFtZS5pbmRleE9mKCcuJyk7XG4gICAgICAgICAgaWYgKGNhbGxEb3RJZHgg
IT09IC0xKSB7XG4gICAgICAgICAgICBjb25zdCBjYWxsUHJlZml4ID0gc3RtdC5uYW1lLnNsaWNl
KDAsIGNhbGxEb3RJZHgpO1xuICAgICAgICAgICAgY29uc3QgY2FsbE1ldGhvZCA9IHN0bXQubmFt
ZS5zbGljZShjYWxsRG90SWR4ICsgMSk7XG4gICAgICAgICAgICBpZiAoaXNWZWN0b3IoY2FsbFBy
ZWZpeCkgfHwgY2FsbFByZWZpeCA9PT0gJ3YxMjgnKSB7XG4gICAgICAgICAgICAgIGVtaXRTaW1k
QnVpbHRpbihjYWxsUHJlZml4LCBjYWxsTWV0aG9kLCBzdG10LCBudWxsKTtcbiAgICAgICAgICAg
ICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIE5hdGl2
ZSBidWlsdGlucyB1c2VkIGFzIHN0YXRlbWVudHMgKGUuZy4gY2FsbCBtZW1vcnlfY29weSguLi4p
KVxuICAgICAgICAgIGlmIChOQVRJVkVfQlVJTFRJTlMuaGFzKHN0bXQubmFtZSkpIHtcbiAgICAg
ICAgICAgIGVtaXRGdW5jQ2FsbChzdG10LCBudWxsKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAg
ICAgICAgIH1cbiAgICAgICAgICAvLyBJbmRpcmVjdCBjYWxsIHZpYSBmdW5jdGlvbi10eXBlZCB2
YXJpYWJsZSB1c2VkIGFzIHN0YXRlbWVudFxuICAgICAgICAgIGNvbnN0IGNhbGxMb2NhbEluZm8g
PSBsb2NhbE1hcFtzdG10Lm5hbWVdO1xuICAgICAgICAgIGNvbnN0IGNhbGxHU2lnID0gZ2xvYmFs
RnVuY1NpZ1tzdG10Lm5hbWVdO1xuICAgICAgICAgIGlmICgoY2FsbExvY2FsSW5mbyAmJiBjYWxs
TG9jYWxJbmZvLmZ1bmNTaWcpIHx8IGNhbGxHU2lnKSB7XG4gICAgICAgICAgICBlbWl0RnVuY0Nh
bGwoc3RtdCwgbnVsbCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAg
ICAgLy8gc3Vicm91dGluZSBjYWxsIG9yIGZ1bmN0aW9uIGNhbGwgKHJlc3VsdCBkaXNjYXJkZWQp
XG4gICAgICAgICAgY29uc3QgZklkeCA9IGZ1bmNJbmRleFtzdG10Lm5hbWVdO1xuICAgICAgICAg
IGlmIChmSWR4ID09PSB1bmRlZmluZWQpIHRocm93IG5ldyBFcnJvcihgVW5kZWZpbmVkIGZ1bmN0
aW9uOiAke3N0bXQubmFtZX1gKTtcbiAgICAgICAgICBmb3IgKGxldCBhaSA9IDA7IGFpIDwgc3Rt
dC5hcmdzLmxlbmd0aDsgYWkrKykge1xuICAgICAgICAgICAgLy8gaW5mZXIgcGFyYW0gdHlwZSBm
cm9tIGRlY2xhcmF0aW9uXG4gICAgICAgICAgICBjb25zdCBwYXJhbVR5cGUgPSBnZXRQYXJhbVR5
cGUoc3RtdC5uYW1lLCBhaSk7XG4gICAgICAgICAgICBlbWl0RXhwcihzdG10LmFyZ3NbYWldLCBw
YXJhbVR5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBidy5ieXRlKE9QX0NBTEwpO1xuICAg
ICAgICAgIGJ3LnUzMihmSWR4KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAg
ICBjYXNlICdUYWlsQ2FsbCc6IHtcbiAgICAgICAgICBjb25zdCB0Y05hbWUgPSBzdG10Lm5hbWU7
XG5cbiAgICAgICAgICAvLyBJbmRpcmVjdCB0YWlsIGNhbGwgdmlhIGZ1bmN0aW9uLXR5cGVkIHZh
cmlhYmxlXG4gICAgICAgICAgY29uc3QgdGNMb2NhbEluZm8gPSBsb2NhbE1hcFt0Y05hbWVdO1xu
ICAgICAgICAgIGNvbnN0IHRjR1NpZyA9IGdsb2JhbEZ1bmNTaWdbdGNOYW1lXTtcbiAgICAgICAg
ICBpZiAoKHRjTG9jYWxJbmZvICYmIHRjTG9jYWxJbmZvLmZ1bmNTaWcpIHx8IHRjR1NpZykge1xu
ICAgICAgICAgICAgY29uc3Qgc2lnID0gKHRjTG9jYWxJbmZvICYmIHRjTG9jYWxJbmZvLmZ1bmNT
aWcpIHx8IHRjR1NpZztcbiAgICAgICAgICAgIGNvbnN0IGNhbGxlZVJldCA9IHNpZy5yZXRUeXBl
IHx8IG51bGw7XG4gICAgICAgICAgICBpZiAoY2FsbGVlUmV0ICE9PSByZXRUeXBlKVxuICAgICAg
ICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHRhaWxjYWxsIHR5cGUgbWlzbWF0Y2g6ICR7dGNOYW1l
fSByZXR1cm5zICR7Y2FsbGVlUmV0IHx8ICd2b2lkJ30sIGN1cnJlbnQgZnVuY3Rpb24gcmV0dXJu
cyAke3JldFR5cGUgfHwgJ3ZvaWQnfWApO1xuICAgICAgICAgICAgZm9yIChsZXQgYWkgPSAwOyBh
aSA8IHN0bXQuYXJncy5sZW5ndGg7IGFpKyspIHtcbiAgICAgICAgICAgICAgY29uc3QgcHQgPSBz
aWcucGFyYW1zW2FpXSA/IChzaWcucGFyYW1zW2FpXS5pc0FycmF5ID8gJ2kzMicgOiBzaWcucGFy
YW1zW2FpXS52dHlwZSkgOiAnZjY0JztcbiAgICAgICAgICAgICAgZW1pdEV4cHIoc3RtdC5hcmdz
W2FpXSwgcHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRjTG9jYWxJbmZvKSB7
IGJ3LmJ5dGUoT1BfTE9DQUxfR0VUKTsgYncudTMyKHRjTG9jYWxJbmZvLmlkeCk7IH1cbiAgICAg
ICAgICAgIGVsc2UgeyBidy5ieXRlKE9QX0dMT0JBTF9HRVQpOyBidy51MzIoZ2xvYmFsSW5kZXhb
dGNOYW1lXSk7IH1cbiAgICAgICAgICAgIGNvbnN0IGluZGlyZWN0U2lnSWQgPSBnZXRPckFkZFNp
ZyhzaWcucGFyYW1zLCBzaWcucmV0VHlwZSk7XG4gICAgICAgICAgICBidy5ieXRlKE9QX1JFVFVS
Tl9DQUxMX0lORElSRUNUKTtcbiAgICAgICAgICAgIGJ3LnUzMihpbmRpcmVjdFNpZ0lkKTtcbiAg
ICAgICAgICAgIGJ3LnUzMigwKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxu
ICAgICAgICAgIC8vIERpcmVjdCB0YWlsIGNhbGwg4oCUIHR5cGUgdmFsaWRhdGlvblxuICAgICAg
ICAgIGNvbnN0IGNhbGxlZUZuID0gZnVuY3Rpb25zLmZpbmQoZiA9PiBmLm5hbWUgPT09IHRjTmFt
ZSk7XG4gICAgICAgICAgY29uc3QgY2FsbGVlSW0gPSAhY2FsbGVlRm4gJiYgYWxsSW1wb3J0cy5m
aW5kKGkgPT4gaS5uYW1lID09PSB0Y05hbWUpO1xuICAgICAgICAgIGNvbnN0IGNhbGxlZVJldCA9
IGNhbGxlZUZuID8gKGNhbGxlZUZuLnR5cGUgPT09ICdTdWJyb3V0aW5lJyA/IG51bGwgOiBjYWxs
ZWVGbi5yZXRUeXBlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICA6IGNhbGxlZUltID8gY2Fs
bGVlSW0ucmV0VHlwZSA6IG51bGw7XG4gICAgICAgICAgaWYgKGNhbGxlZVJldCAhPT0gcmV0VHlw
ZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgdGFpbGNhbGwgdHlwZSBtaXNtYXRjaDog
JHt0Y05hbWV9IHJldHVybnMgJHtjYWxsZWVSZXQgfHwgJ3ZvaWQnfSwgY3VycmVudCBmdW5jdGlv
biByZXR1cm5zICR7cmV0VHlwZSB8fCAndm9pZCd9YCk7XG5cbiAgICAgICAgICBjb25zdCB0Y0ZJ
ZHggPSBmdW5jSW5kZXhbdGNOYW1lXTtcbiAgICAgICAgICBpZiAodGNGSWR4ID09PSB1bmRlZmlu
ZWQpIHRocm93IG5ldyBFcnJvcihgVW5kZWZpbmVkIGZ1bmN0aW9uOiAke3RjTmFtZX1gKTtcbiAg
ICAgICAgICBmb3IgKGxldCBhaSA9IDA7IGFpIDwgc3RtdC5hcmdzLmxlbmd0aDsgYWkrKykge1xu
ICAgICAgICAgICAgZW1pdEV4cHIoc3RtdC5hcmdzW2FpXSwgZ2V0UGFyYW1UeXBlKHRjTmFtZSwg
YWkpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYncuYnl0ZShPUF9SRVRVUk5fQ0FMTCk7XG4g
ICAgICAgICAgYncudTMyKHRjRklkeCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAg
ICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gc3RhdGVt
ZW50IHR5cGU6ICR7c3RtdC50eXBlfWApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9u
IGdldFBhcmFtVHlwZShmdW5jTmFtZSwgcGFyYW1JZHgpIHtcbiAgICAgIC8vIGNoZWNrIGxvY2Fs
IGZ1bmN0aW9uc1xuICAgICAgY29uc3QgZm4gPSBmdW5jdGlvbnMuZmluZChmID0+IGYubmFtZSA9
PT0gZnVuY05hbWUpO1xuICAgICAgaWYgKGZuICYmIGZuLnBhcmFtc1twYXJhbUlkeF0pIHJldHVy
biBmbi5wYXJhbXNbcGFyYW1JZHhdLmlzQXJyYXkgPyAnaTMyJyA6IGZuLnBhcmFtc1twYXJhbUlk
eF0udnR5cGU7XG4gICAgICAvLyBjaGVjayBpbXBvcnRzXG4gICAgICBjb25zdCBpbSA9IGFsbElt
cG9ydHMuZmluZChpID0+IGkubmFtZSA9PT0gZnVuY05hbWUpO1xuICAgICAgaWYgKGltICYmIGlt
LnBhcmFtc1twYXJhbUlkeF0pIHJldHVybiBpbS5wYXJhbXNbcGFyYW1JZHhdLnZ0eXBlO1xuICAg
ICAgcmV0dXJuICdmNjQnOyAvLyBkZWZhdWx0XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVzb2x2
ZVR5cGUobmFtZSkge1xuICAgICAgaWYgKGxvY2FsTWFwW25hbWVdKSByZXR1cm4gbG9jYWxNYXBb
bmFtZV0udnR5cGU7XG4gICAgICBpZiAoZ2xvYmFsSW5kZXhbbmFtZV0gIT09IHVuZGVmaW5lZCkg
cmV0dXJuIGdsb2JhbHNbZ2xvYmFsSW5kZXhbbmFtZV1dLnZ0eXBlO1xuICAgICAgcmV0dXJuIG51
bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5mZXJFeHByVHlwZShleHByKSB7XG4gICAgICBz
d2l0Y2ggKGV4cHIudHlwZSkge1xuICAgICAgICBjYXNlICdOdW1iZXJMaXQnOiB7XG4gICAgICAg
ICAgaWYgKGV4cHIudHlwZVN1ZmZpeCkgcmV0dXJuIGV4cHIudHlwZVN1ZmZpeDtcbiAgICAgICAg
ICBpZiAoZXhwci5pc0Zsb2F0IHx8IGV4cHIudmFsdWUuaW5jbHVkZXMoJy4nKSB8fCBleHByLnZh
bHVlLmluY2x1ZGVzKCdlJykgfHwgZXhwci52YWx1ZS5pbmNsdWRlcygnRScpKSByZXR1cm4gJ2Y2
NCc7XG4gICAgICAgICAgcmV0dXJuICdpMzInO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ0lk
ZW50JzogcmV0dXJuIHJlc29sdmVUeXBlKGV4cHIubmFtZSkgfHwgKHRhYmxlU2xvdFtleHByLm5h
bWVdICE9PSB1bmRlZmluZWQgPyAnaTMyJyA6IG51bGwpIHx8ICdmNjQnO1xuICAgICAgICBjYXNl
ICdCaW5PcCc6IHJldHVybiBpbmZlckV4cHJUeXBlKGV4cHIubGVmdCk7XG4gICAgICAgIGNhc2Ug
J1VuYXJ5T3AnOiByZXR1cm4gaW5mZXJFeHByVHlwZShleHByLm9wZXJhbmQpO1xuICAgICAgICBj
YXNlICdGdW5jQ2FsbCc6IHtcbiAgICAgICAgICAvLyB0eXBlIGNvbnZlcnNpb25zIC8gdmVjdG9y
IGNvbnN0cnVjdG9yc1xuICAgICAgICAgIGlmIChBVFJBX1RZUEVTLmhhcyhleHByLm5hbWUpKSBy
ZXR1cm4gZXhwci5uYW1lO1xuICAgICAgICAgIC8vIFNJTUQgbmFtZXNwYWNlZCBidWlsdGluc1xu
ICAgICAgICAgIGNvbnN0IGRvdElkeCA9IGV4cHIubmFtZS5pbmRleE9mKCcuJyk7XG4gICAgICAg
ICAgaWYgKGRvdElkeCAhPT0gLTEpIHtcbiAgICAgICAgICAgIGNvbnN0IHByZWZpeCA9IGV4cHIu
bmFtZS5zbGljZSgwLCBkb3RJZHgpO1xuICAgICAgICAgICAgY29uc3QgbWV0aG9kID0gZXhwci5u
YW1lLnNsaWNlKGRvdElkeCArIDEpO1xuICAgICAgICAgICAgaWYgKGlzVmVjdG9yKHByZWZpeCkp
IHtcbiAgICAgICAgICAgICAgLy8gZXh0cmFjdF9sYW5lIHJldHVybnMgdGhlIHNjYWxhciB0eXBl
XG4gICAgICAgICAgICAgIGlmIChtZXRob2QgPT09ICdleHRyYWN0X2xhbmUnKSByZXR1cm4gdmVj
dG9yU2NhbGFyVHlwZShwcmVmaXgpO1xuICAgICAgICAgICAgICAvLyBzcGxhdCwgcmVwbGFjZV9s
YW5lLCBhZGQsIHN1YiwgbXVsLCBkaXYsIG5lZywgYWJzLCBzcXJ0LCBlcSwgZXRjLiByZXR1cm4g
dGhlIHZlY3RvciB0eXBlXG4gICAgICAgICAgICAgIHJldHVybiBwcmVmaXg7XG4gICAgICAgICAg
ICB9XG4gICAgICAgICAgICBpZiAocHJlZml4ID09PSAndjEyOCcpIHtcbiAgICAgICAgICAgICAg
Ly8gdjEyOC5hbmQvb3IveG9yL25vdC9sb2FkIHJldHVybiB2MTI4IOKAlCBpbmZlciBmcm9tIGZp
cnN0IGFyZ1xuICAgICAgICAgICAgICBpZiAobWV0aG9kID09PSAnbG9hZCcpIHJldHVybiBpbmZl
ckV4cHJUeXBlKGV4cHIuYXJnc1swXSkgfHwgJ2Y2NHgyJzsgLy8gZGVmYXVsdCB0byBmNjR4Mlxu
ICAgICAgICAgICAgICBpZiAoWydhbmQnLCdvcicsJ3hvcicsJ25vdCddLmluY2x1ZGVzKG1ldGhv
ZCkpIHJldHVybiBpbmZlckV4cHJUeXBlKGV4cHIuYXJnc1swXSk7XG4gICAgICAgICAgICAgIGlm
IChtZXRob2QgPT09ICdzdG9yZScpIHJldHVybiAnaTMyJzsgLy8gc3RvcmUgaXMgYSBzdGF0ZW1l
bnQsIGJ1dCB0eXBlIGRvZXNuJ3QgbWF0dGVyIG11Y2hcbiAgICAgICAgICAgIH1cbiAgICAgICAg
ICB9XG4gICAgICAgICAgLy8gSW5kaXJlY3QgY2FsbCB2aWEgZnVuY3Rpb24tdHlwZWQgdmFyaWFi
bGVcbiAgICAgICAgICBjb25zdCBjYWxsSW5mbyA9IGxvY2FsTWFwW2V4cHIubmFtZV07XG4gICAg
ICAgICAgaWYgKGNhbGxJbmZvICYmIGNhbGxJbmZvLmZ1bmNTaWcgJiYgY2FsbEluZm8uZnVuY1Np
Zy5yZXRUeXBlKSByZXR1cm4gY2FsbEluZm8uZnVuY1NpZy5yZXRUeXBlO1xuICAgICAgICAgIGlm
IChnbG9iYWxGdW5jU2lnW2V4cHIubmFtZV0gJiYgZ2xvYmFsRnVuY1NpZ1tleHByLm5hbWVdLnJl
dFR5cGUpIHJldHVybiBnbG9iYWxGdW5jU2lnW2V4cHIubmFtZV0ucmV0VHlwZTtcbiAgICAgICAg
ICAvLyBrbm93biByZXR1cm4gdHlwZXNcbiAgICAgICAgICBjb25zdCBmbiA9IGZ1bmN0aW9ucy5m
aW5kKGYgPT4gZi5uYW1lID09PSBleHByLm5hbWUpO1xuICAgICAgICAgIGlmIChmbiAmJiBmbi5y
ZXRUeXBlKSByZXR1cm4gZm4ucmV0VHlwZTtcbiAgICAgICAgICByZXR1cm4gJ2Y2NCc7XG4gICAg
ICAgIH1cbiAgICAgICAgY2FzZSAnQXJyYXlBY2Nlc3MnOiB7XG4gICAgICAgICAgY29uc3QgaW5m
byA9IGxvY2FsTWFwW2V4cHIubmFtZV07XG4gICAgICAgICAgcmV0dXJuIGluZm8gPyAoaW5mby5l
bGVtVHlwZSB8fCBpbmZvLnZ0eXBlKSA6ICdmNjQnO1xuICAgICAgICB9XG4gICAgICAgIGNhc2Ug
J0lmRXhwcic6IHJldHVybiBpbmZlckV4cHJUeXBlKGV4cHIudGhlbkV4cHIpO1xuICAgICAgICBk
ZWZhdWx0OiByZXR1cm4gJ2Y2NCc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZW1p
dEV4cHIoZXhwciwgZXhwZWN0ZWRUeXBlKSB7XG4gICAgICBjb25zdCBhY3R1YWxUeXBlID0gZXhw
ZWN0ZWRUeXBlIHx8IGluZmVyRXhwclR5cGUoZXhwcik7XG5cbiAgICAgIHN3aXRjaCAoZXhwci50
eXBlKSB7XG4gICAgICAgIGNhc2UgJ051bWJlckxpdCc6IHtcbiAgICAgICAgICBjb25zdCB0ID0g
ZXhwZWN0ZWRUeXBlIHx8IGluZmVyRXhwclR5cGUoZXhwcik7XG4gICAgICAgICAgY29uc3QgcmF3
ID0gZXhwci52YWx1ZTtcbiAgICAgICAgICBpZiAodCA9PT0gJ2kzMicpIHsgYncuYnl0ZShPUF9J
MzJfQ09OU1QpOyBidy5zMzIocGFyc2VJbnQocmF3LCAxMCkgfCAwKTsgfVxuICAgICAgICAgIGVs
c2UgaWYgKHQgPT09ICdpNjQnKSB7IGJ3LmJ5dGUoT1BfSTY0X0NPTlNUKTsgYncuczY0KEJpZ0lu
dChwYXJzZUludChyYXcsIDEwKSkpOyB9XG4gICAgICAgICAgZWxzZSBpZiAodCA9PT0gJ2YzMicp
IHsgYncuYnl0ZShPUF9GMzJfQ09OU1QpOyBidy5mMzIocGFyc2VGbG9hdChyYXcpKTsgfVxuICAg
ICAgICAgIGVsc2UgeyBidy5ieXRlKE9QX0Y2NF9DT05TVCk7IGJ3LmY2NChwYXJzZUZsb2F0KHJh
dykpOyB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnSWRlbnQn
OiB7XG4gICAgICAgICAgY29uc3QgbmFtZSA9IGV4cHIubmFtZTtcbiAgICAgICAgICBpZiAobG9j
YWxNYXBbbmFtZV0pIHsgYncuYnl0ZShPUF9MT0NBTF9HRVQpOyBidy51MzIobG9jYWxNYXBbbmFt
ZV0uaWR4KTsgfVxuICAgICAgICAgIGVsc2UgaWYgKGdsb2JhbEluZGV4W25hbWVdICE9PSB1bmRl
ZmluZWQpIHsgYncuYnl0ZShPUF9HTE9CQUxfR0VUKTsgYncudTMyKGdsb2JhbEluZGV4W25hbWVd
KTsgfVxuICAgICAgICAgIGVsc2UgaWYgKHRhYmxlU2xvdFtuYW1lXSAhPT0gdW5kZWZpbmVkKSB7
XG4gICAgICAgICAgICAvLyBCYXJlIGZ1bmN0aW9uIG5hbWUg4oaSIHRhYmxlIGluZGV4IChmb3Ig
Y2FsbF9pbmRpcmVjdClcbiAgICAgICAgICAgIGJ3LmJ5dGUoT1BfSTMyX0NPTlNUKTsgYncuczMy
KHRhYmxlU2xvdFtuYW1lXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgdGhyb3cgbmV3
IEVycm9yKGBVbmRlZmluZWQgdmFyaWFibGU6ICR7bmFtZX1gKTtcbiAgICAgICAgICBicmVhaztc
biAgICAgICAgfVxuICAgICAgICBjYXNlICdCaW5PcCc6IHtcbiAgICAgICAgICBjb25zdCB0ID0g
ZXhwZWN0ZWRUeXBlIHx8IGluZmVyRXhwclR5cGUoZXhwcik7XG4gICAgICAgICAgZW1pdEJpbk9w
KGV4cHIsIHQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ1Vu
YXJ5T3AnOiB7XG4gICAgICAgICAgY29uc3QgdCA9IGV4cGVjdGVkVHlwZSB8fCBpbmZlckV4cHJU
eXBlKGV4cHIpO1xuICAgICAgICAgIGlmIChleHByLm9wID09PSAnLScpIHtcbiAgICAgICAgICAg
IGlmICh0ID09PSAnZjY0JykgeyBlbWl0RXhwcihleHByLm9wZXJhbmQsIHQpOyBidy5ieXRlKE9Q
X0Y2NF9ORUcpOyB9XG4gICAgICAgICAgICBlbHNlIGlmICh0ID09PSAnZjMyJykgeyBlbWl0RXhw
cihleHByLm9wZXJhbmQsIHQpOyBidy5ieXRlKE9QX0YzMl9ORUcpOyB9XG4gICAgICAgICAgICBl
bHNlIGlmICh0ID09PSAnaTMyJykgeyBidy5ieXRlKE9QX0kzMl9DT05TVCk7IGJ3LnMzMigwKTsg
ZW1pdEV4cHIoZXhwci5vcGVyYW5kLCB0KTsgYncuYnl0ZShPUF9JMzJfU1VCKTsgfVxuICAgICAg
ICAgICAgZWxzZSBpZiAodCA9PT0gJ2k2NCcpIHsgYncuYnl0ZShPUF9JNjRfQ09OU1QpOyBidy5z
NjQoMG4pOyBlbWl0RXhwcihleHByLm9wZXJhbmQsIHQpOyBidy5ieXRlKE9QX0k2NF9TVUIpOyB9
XG4gICAgICAgICAgICBlbHNlIGlmIChpc1ZlY3Rvcih0KSkgeyBlbWl0RXhwcihleHByLm9wZXJh
bmQsIHQpOyBlbWl0U2ltZChTSU1EX09QU1t0ICsgJy5uZWcnXSk7IH1cbiAgICAgICAgICB9IGVs
c2UgaWYgKGV4cHIub3AgPT09ICdub3QnKSB7XG4gICAgICAgICAgICBlbWl0RXhwcihleHByLm9w
ZXJhbmQsICdpMzInKTtcbiAgICAgICAgICAgIGJ3LmJ5dGUoT1BfSTMyX0VRWik7XG4gICAgICAg
ICAgfSBlbHNlIGlmIChleHByLm9wID09PSAnficpIHtcbiAgICAgICAgICAgIGVtaXRFeHByKGV4
cHIub3BlcmFuZCwgdCk7XG4gICAgICAgICAgICBpZiAodCA9PT0gJ2kzMicpIHsgYncuYnl0ZShP
UF9JMzJfQ09OU1QpOyBidy5zMzIoLTEpOyBidy5ieXRlKE9QX0kzMl9YT1IpOyB9XG4gICAgICAg
ICAgICBlbHNlIGlmICh0ID09PSAnaTY0JykgeyBidy5ieXRlKE9QX0k2NF9DT05TVCk7IGJ3LnM2
NCgtMW4pOyBidy5ieXRlKE9QX0k2NF9YT1IpOyB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAg
ICAgICAgIGVtaXRFeHByKGV4cHIub3BlcmFuZCwgdCk7XG4gICAgICAgICAgfVxuICAgICAgICAg
IGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ0Z1bmNDYWxsJzoge1xuICAgICAgICAg
IGVtaXRGdW5jQ2FsbChleHByLCBleHBlY3RlZFR5cGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAg
ICAgICB9XG4gICAgICAgIGNhc2UgJ0FycmF5QWNjZXNzJzoge1xuICAgICAgICAgIGNvbnN0IGlu
Zm8gPSBsb2NhbE1hcFtleHByLm5hbWVdO1xuICAgICAgICAgIGlmICghaW5mbykgdGhyb3cgbmV3
IEVycm9yKGBVbmRlZmluZWQgYXJyYXk6ICR7ZXhwci5uYW1lfWApO1xuICAgICAgICAgIGNvbnN0
IGVsZW1UeXBlID0gaW5mby5lbGVtVHlwZSB8fCBpbmZvLnZ0eXBlO1xuICAgICAgICAgIGVtaXRB
cnJheUFkZHIoZXhwci5uYW1lLCBleHByLmluZGljZXMsIGluZm8sIGVsZW1UeXBlKTtcbiAgICAg
ICAgICBlbWl0TG9hZChlbGVtVHlwZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAg
ICAgICAgY2FzZSAnSWZFeHByJzoge1xuICAgICAgICAgIGNvbnN0IHQgPSBleHBlY3RlZFR5cGUg
fHwgaW5mZXJFeHByVHlwZShleHByLnRoZW5FeHByKTtcbiAgICAgICAgICBlbWl0RXhwcihleHBy
LmNvbmQsICdpMzInKTtcbiAgICAgICAgICBidy5ieXRlKE9QX0lGKTtcbiAgICAgICAgICBidy5i
eXRlKHdhc21UeXBlKHQpKTtcbiAgICAgICAgICBlbWl0RXhwcihleHByLnRoZW5FeHByLCB0KTtc
biAgICAgICAgICBidy5ieXRlKE9QX0VMU0UpO1xuICAgICAgICAgIGVtaXRFeHByKGV4cHIuZWxz
ZUV4cHIsIHQpO1xuICAgICAgICAgIGJ3LmJ5dGUoT1BfRU5EKTtcbiAgICAgICAgICBicmVhaztc
biAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihg
VW5rbm93biBleHByZXNzaW9uIHR5cGU6ICR7ZXhwci50eXBlfWApO1xuICAgICAgfVxuICAgIH1c
blxuICAgIGZ1bmN0aW9uIGVtaXRCaW5PcChleHByLCB0KSB7XG4gICAgICBjb25zdCBvcCA9IGV4
cHIub3A7XG5cbiAgICAgIC8vIEV4cG9uZW50aWF0aW9uXG4gICAgICBpZiAob3AgPT09ICcqKicp
IHtcbiAgICAgICAgZW1pdFBvdyhleHByLCB0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxu
XG4gICAgICAvLyBDb21wYXJpc29uIG9wZXJhdG9ycyByZXR1cm4gaTMyXG4gICAgICBpZiAob3Ag
PT09ICc9PScgfHwgb3AgPT09ICcvPScgfHwgb3AgPT09ICc8JyB8fCBvcCA9PT0gJz4nIHx8IG9w
ID09PSAnPD0nIHx8IG9wID09PSAnPj0nKSB7XG4gICAgICAgIGNvbnN0IG9wZXJhbmRUeXBlID0g
aW5mZXJFeHByVHlwZShleHByLmxlZnQpO1xuICAgICAgICBlbWl0RXhwcihleHByLmxlZnQsIG9w
ZXJhbmRUeXBlKTtcbiAgICAgICAgZW1pdEV4cHIoZXhwci5yaWdodCwgb3BlcmFuZFR5cGUpO1xu
ICAgICAgICBlbWl0Q21wKG9wLCBvcGVyYW5kVHlwZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAg
IH1cblxuICAgICAgLy8gTG9naWNhbDogYW5kLCBvclxuICAgICAgaWYgKG9wID09PSAnYW5kJykg
e1xuICAgICAgICBlbWl0RXhwcihleHByLmxlZnQsICdpMzInKTtcbiAgICAgICAgZW1pdEV4cHIo
ZXhwci5yaWdodCwgJ2kzMicpO1xuICAgICAgICBidy5ieXRlKE9QX0kzMl9BTkQpO1xuICAgICAg
ICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAob3AgPT09ICdvcicpIHtcbiAgICAgICAgZW1p
dEV4cHIoZXhwci5sZWZ0LCAnaTMyJyk7XG4gICAgICAgIGVtaXRFeHByKGV4cHIucmlnaHQsICdp
MzInKTtcbiAgICAgICAgYncuYnl0ZShPUF9JMzJfT1IpO1xuICAgICAgICByZXR1cm47XG4gICAg
ICB9XG5cbiAgICAgIGVtaXRFeHByKGV4cHIubGVmdCwgdCk7XG4gICAgICBlbWl0RXhwcihleHBy
LnJpZ2h0LCB0KTtcblxuICAgICAgaWYgKG9wID09PSAnKycpIGVtaXRBZGQodCk7XG4gICAgICBl
bHNlIGlmIChvcCA9PT0gJy0nKSBlbWl0U3ViKHQpO1xuICAgICAgZWxzZSBpZiAob3AgPT09ICcq
JykgZW1pdE11bCh0KTtcbiAgICAgIGVsc2UgaWYgKG9wID09PSAnLycpIGVtaXREaXYodCk7XG4g
ICAgICBlbHNlIGlmIChvcCA9PT0gJ21vZCcpIHtcbiAgICAgICAgaWYgKHQgPT09ICdpMzInKSBi
dy5ieXRlKE9QX0kzMl9SRU1fUyk7XG4gICAgICAgIGVsc2UgaWYgKHQgPT09ICdpNjQnKSBidy5i
eXRlKE9QX0k2NF9SRU1fUyk7XG4gICAgICAgIGVsc2UgdGhyb3cgbmV3IEVycm9yKCdtb2QgcmVx
dWlyZXMgaW50ZWdlciB0eXBlJyk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChvcCA9PT0gJyYn
KSB7IGlmICh0ID09PSAnaTMyJykgYncuYnl0ZShPUF9JMzJfQU5EKTsgZWxzZSBidy5ieXRlKE9Q
X0k2NF9BTkQpOyB9XG4gICAgICBlbHNlIGlmIChvcCA9PT0gJ3wnKSB7IGlmICh0ID09PSAnaTMy
JykgYncuYnl0ZShPUF9JMzJfT1IpOyBlbHNlIGJ3LmJ5dGUoT1BfSTY0X09SKTsgfVxuICAgICAg
ZWxzZSBpZiAob3AgPT09ICdeJykgeyBpZiAodCA9PT0gJ2kzMicpIGJ3LmJ5dGUoT1BfSTMyX1hP
Uik7IGVsc2UgYncuYnl0ZShPUF9JNjRfWE9SKTsgfVxuICAgICAgZWxzZSBpZiAob3AgPT09ICc8
PCcpIHsgaWYgKHQgPT09ICdpMzInKSBidy5ieXRlKE9QX0kzMl9TSEwpOyBlbHNlIGJ3LmJ5dGUo
T1BfSTY0X1NITCk7IH1cbiAgICAgIGVsc2UgaWYgKG9wID09PSAnPj4nKSB7IGlmICh0ID09PSAn
aTMyJykgYncuYnl0ZShPUF9JMzJfU0hSX1MpOyBlbHNlIGJ3LmJ5dGUoT1BfSTY0X1NIUl9TKTsg
fVxuICAgICAgZWxzZSB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gb3BlcmF0b3I6ICR7b3B9YCk7
XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZW1pdFBvdyhleHByLCB0KSB7XG4gICAgICAvLyAqKjAu
NSDihpIgc3FydFxuICAgICAgaWYgKGV4cHIucmlnaHQudHlwZSA9PT0gJ051bWJlckxpdCcgJiYg
KGV4cHIucmlnaHQudmFsdWUgPT09ICcwLjUnIHx8IGV4cHIucmlnaHQudmFsdWUgPT09ICcuNScp
KSB7XG4gICAgICAgIGVtaXRFeHByKGV4cHIubGVmdCwgdCk7XG4gICAgICAgIGlmICh0ID09PSAn
ZjY0JykgYncuYnl0ZShPUF9GNjRfU1FSVCk7XG4gICAgICAgIGVsc2UgaWYgKHQgPT09ICdmMzIn
KSBidy5ieXRlKE9QX0YzMl9TUVJUKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAg
Ly8gR2VuZXJhbDogY2FsbCBwb3cgaW1wb3J0ICh3b3JrcyBmb3IgYWxsIGNhc2VzIGluY2x1ZGlu
ZyAqKjIsICoqMylcbiAgICAgIGVtaXRFeHByKGV4cHIubGVmdCwgJ2Y2NCcpO1xuICAgICAgZW1p
dEV4cHIoZXhwci5yaWdodCwgJ2Y2NCcpO1xuICAgICAgYncuYnl0ZShPUF9DQUxMKTtcbiAgICAg
IGJ3LnUzMihmdW5jSW5kZXhbJ3BvdyddKTtcbiAgICAgIC8vIENvbnZlcnQgcmVzdWx0IGJhY2sg
aWYgbmVlZGVkXG4gICAgICBpZiAodCA9PT0gJ2YzMicpIGJ3LmJ5dGUoT1BfRjMyX0RFTU9URV9G
NjQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVtaXRGdW5jQ2FsbChleHByLCBleHBlY3RlZFR5
cGUpIHtcbiAgICAgIGNvbnN0IG5hbWUgPSBleHByLm5hbWU7XG5cbiAgICAgIC8vIFZlY3RvciBj
b25zdHJ1Y3RvcnM6IGY2NHgyKGEsIGIpLCBmMzJ4NChhLCBiLCBjLCBkKSwgZXRjLlxuICAgICAg
aWYgKGlzVmVjdG9yKG5hbWUpKSB7XG4gICAgICAgIGVtaXRWZWN0b3JDb25zdHJ1Y3RvcihuYW1l
LCBleHByLmFyZ3MpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFNjYWxh
ciB0eXBlIGNvbnZlcnNpb25zOiBpMzIoeCksIGY2NCh4KSwgZXRjLlxuICAgICAgaWYgKEFUUkFf
VFlQRVMuaGFzKG5hbWUpKSB7XG4gICAgICAgIGNvbnN0IGZyb21UeXBlID0gaW5mZXJFeHByVHlw
ZShleHByLmFyZ3NbMF0pO1xuICAgICAgICBjb25zdCB0b1R5cGUgPSBuYW1lO1xuICAgICAgICBl
bWl0RXhwcihleHByLmFyZ3NbMF0sIGZyb21UeXBlKTtcbiAgICAgICAgZW1pdENvbnZlcnNpb24o
ZnJvbVR5cGUsIHRvVHlwZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8g
U0lNRCBuYW1lc3BhY2VkIGJ1aWx0aW5zOiBmNjR4Mi5zcGxhdCwgdjEyOC5hbmQsIGV0Yy5cbiAg
ICAgIGNvbnN0IGRvdElkeCA9IG5hbWUuaW5kZXhPZignLicpO1xuICAgICAgaWYgKGRvdElkeCAh
PT0gLTEpIHtcbiAgICAgICAgY29uc3QgcHJlZml4ID0gbmFtZS5zbGljZSgwLCBkb3RJZHgpO1xu
ICAgICAgICBjb25zdCBtZXRob2QgPSBuYW1lLnNsaWNlKGRvdElkeCArIDEpO1xuICAgICAgICBp
ZiAoaXNWZWN0b3IocHJlZml4KSB8fCBwcmVmaXggPT09ICd2MTI4Jykge1xuICAgICAgICAgIGVt
aXRTaW1kQnVpbHRpbihwcmVmaXgsIG1ldGhvZCwgZXhwciwgZXhwZWN0ZWRUeXBlKTtcbiAgICAg
ICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gTmF0aXZlIGJ1aWx0
aW5zIOKAlCB3aXRoIHZlY3RvciB0eXBlIHN1cHBvcnRcbiAgICAgIGlmIChuYW1lID09PSAnc3Fy
dCcpIHtcbiAgICAgICAgZW1pdEV4cHIoZXhwci5hcmdzWzBdLCBleHBlY3RlZFR5cGUpO1xuICAg
ICAgICBpZiAoaXNWZWN0b3IoZXhwZWN0ZWRUeXBlKSkgeyBjb25zdCBvcCA9IFNJTURfT1BTW2V4
cGVjdGVkVHlwZSArICcuc3FydCddOyBpZiAob3AgPT09IHVuZGVmaW5lZCkgdGhyb3cgbmV3IEVy
cm9yKCdzcXJ0IG5vdCBzdXBwb3J0ZWQgZm9yICcgKyBleHBlY3RlZFR5cGUpOyBlbWl0U2ltZChv
cCk7IH1cbiAgICAgICAgZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSAnZjMyJykgYncuYnl0ZShP
UF9GMzJfU1FSVCk7XG4gICAgICAgIGVsc2UgYncuYnl0ZShPUF9GNjRfU1FSVCk7XG4gICAgICAg
IHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChuYW1lID09PSAnYWJzJykge1xuICAgICAgICBl
bWl0RXhwcihleHByLmFyZ3NbMF0sIGV4cGVjdGVkVHlwZSk7XG4gICAgICAgIGlmIChpc1ZlY3Rv
cihleHBlY3RlZFR5cGUpKSB7IGNvbnN0IG9wID0gU0lNRF9PUFNbZXhwZWN0ZWRUeXBlICsgJy5h
YnMnXTsgaWYgKG9wID09PSB1bmRlZmluZWQpIHRocm93IG5ldyBFcnJvcignYWJzIG5vdCBzdXBw
b3J0ZWQgZm9yICcgKyBleHBlY3RlZFR5cGUpOyBlbWl0U2ltZChvcCk7IH1cbiAgICAgICAgZWxz
ZSBpZiAoZXhwZWN0ZWRUeXBlID09PSAnZjMyJykgYncuYnl0ZShPUF9GMzJfQUJTKTtcbiAgICAg
ICAgZWxzZSBidy5ieXRlKE9QX0Y2NF9BQlMpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4g
ICAgICBpZiAobmFtZSA9PT0gJ2Zsb29yJykgeyBlbWl0RXhwcihleHByLmFyZ3NbMF0sIGV4cGVj
dGVkVHlwZSk7IGlmIChleHBlY3RlZFR5cGUgPT09ICdmMzInKSBidy5ieXRlKE9QX0YzMl9GTE9P
Uik7IGVsc2UgYncuYnl0ZShPUF9GNjRfRkxPT1IpOyByZXR1cm47IH1cbiAgICAgIGlmIChuYW1l
ID09PSAnY2VpbCcpIHsgZW1pdEV4cHIoZXhwci5hcmdzWzBdLCBleHBlY3RlZFR5cGUpOyBpZiAo
ZXhwZWN0ZWRUeXBlID09PSAnZjMyJykgYncuYnl0ZShPUF9GMzJfQ0VJTCk7IGVsc2UgYncuYnl0
ZShPUF9GNjRfQ0VJTCk7IHJldHVybjsgfVxuICAgICAgaWYgKG5hbWUgPT09ICd0cnVuYycpIHsg
ZW1pdEV4cHIoZXhwci5hcmdzWzBdLCBleHBlY3RlZFR5cGUpOyBpZiAoZXhwZWN0ZWRUeXBlID09
PSAnZjMyJykgYncuYnl0ZShPUF9GMzJfVFJVTkMpOyBlbHNlIGJ3LmJ5dGUoT1BfRjY0X1RSVU5D
KTsgcmV0dXJuOyB9XG4gICAgICBpZiAobmFtZSA9PT0gJ25lYXJlc3QnKSB7IGVtaXRFeHByKGV4
cHIuYXJnc1swXSwgZXhwZWN0ZWRUeXBlKTsgaWYgKGV4cGVjdGVkVHlwZSA9PT0gJ2YzMicpIGJ3
LmJ5dGUoT1BfRjMyX05FQVJFU1QpOyBlbHNlIGJ3LmJ5dGUoT1BfRjY0X05FQVJFU1QpOyByZXR1
cm47IH1cbiAgICAgIGlmIChuYW1lID09PSAnbWluJykge1xuICAgICAgICBlbWl0RXhwcihleHBy
LmFyZ3NbMF0sIGV4cGVjdGVkVHlwZSk7IGVtaXRFeHByKGV4cHIuYXJnc1sxXSwgZXhwZWN0ZWRU
eXBlKTtcbiAgICAgICAgaWYgKGlzVmVjdG9yKGV4cGVjdGVkVHlwZSkpIHsgY29uc3Qgb3AgPSBT
SU1EX09QU1tleHBlY3RlZFR5cGUgKyAnLm1pbiddOyBpZiAob3AgPT09IHVuZGVmaW5lZCkgdGhy
b3cgbmV3IEVycm9yKCdtaW4gbm90IHN1cHBvcnRlZCBmb3IgJyArIGV4cGVjdGVkVHlwZSk7IGVt
aXRTaW1kKG9wKTsgfVxuICAgICAgICBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09ICdmMzInKSBi
dy5ieXRlKE9QX0YzMl9NSU4pO1xuICAgICAgICBlbHNlIGJ3LmJ5dGUoT1BfRjY0X01JTik7XG4g
ICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChuYW1lID09PSAnbWF4Jykge1xuICAg
ICAgICBlbWl0RXhwcihleHByLmFyZ3NbMF0sIGV4cGVjdGVkVHlwZSk7IGVtaXRFeHByKGV4cHIu
YXJnc1sxXSwgZXhwZWN0ZWRUeXBlKTtcbiAgICAgICAgaWYgKGlzVmVjdG9yKGV4cGVjdGVkVHlw
ZSkpIHsgY29uc3Qgb3AgPSBTSU1EX09QU1tleHBlY3RlZFR5cGUgKyAnLm1heCddOyBpZiAob3Ag
PT09IHVuZGVmaW5lZCkgdGhyb3cgbmV3IEVycm9yKCdtYXggbm90IHN1cHBvcnRlZCBmb3IgJyAr
IGV4cGVjdGVkVHlwZSk7IGVtaXRTaW1kKG9wKTsgfVxuICAgICAgICBlbHNlIGlmIChleHBlY3Rl
ZFR5cGUgPT09ICdmMzInKSBidy5ieXRlKE9QX0YzMl9NQVgpO1xuICAgICAgICBlbHNlIGJ3LmJ5
dGUoT1BfRjY0X01BWCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChuYW1l
ID09PSAnY29weXNpZ24nKSB7IGVtaXRFeHByKGV4cHIuYXJnc1swXSwgZXhwZWN0ZWRUeXBlKTsg
ZW1pdEV4cHIoZXhwci5hcmdzWzFdLCBleHBlY3RlZFR5cGUpOyBpZiAoZXhwZWN0ZWRUeXBlID09
PSAnZjMyJykgYncuYnl0ZShPUF9GMzJfQ09QWVNJR04pOyBlbHNlIGJ3LmJ5dGUoT1BfRjY0X0NP
UFlTSUdOKTsgcmV0dXJuOyB9XG4gICAgICBpZiAobmFtZSA9PT0gJ3NlbGVjdCcpIHtcbiAgICAg
ICAgLy8gc2VsZWN0KGEsIGIsIGNvbmQpIOKAlCBXYXNtIHNlbGVjdCBwaWNrcyBhIGlmIGNvbmQh
PTAsIGIgb3RoZXJ3aXNlXG4gICAgICAgIGNvbnN0IHQgPSBleHBlY3RlZFR5cGUgfHwgaW5mZXJF
eHByVHlwZShleHByLmFyZ3NbMF0pO1xuICAgICAgICBlbWl0RXhwcihleHByLmFyZ3NbMF0sIHQp
O1xuICAgICAgICBlbWl0RXhwcihleHByLmFyZ3NbMV0sIHQpO1xuICAgICAgICBlbWl0RXhwcihl
eHByLmFyZ3NbMl0sICdpMzInKTtcbiAgICAgICAgYncuYnl0ZShPUF9TRUxFQ1QpO1xuICAgICAg
ICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAobmFtZSA9PT0gJ2NseicpIHsgZW1pdEV4cHIo
ZXhwci5hcmdzWzBdLCBleHBlY3RlZFR5cGUpOyBpZiAoZXhwZWN0ZWRUeXBlID09PSAnaTY0Jykg
YncuYnl0ZShPUF9JNjRfQ0xaKTsgZWxzZSBidy5ieXRlKE9QX0kzMl9DTFopOyByZXR1cm47IH1c
biAgICAgIGlmIChuYW1lID09PSAnY3R6JykgeyBlbWl0RXhwcihleHByLmFyZ3NbMF0sIGV4cGVj
dGVkVHlwZSk7IGlmIChleHBlY3RlZFR5cGUgPT09ICdpNjQnKSBidy5ieXRlKE9QX0k2NF9DVFop
OyBlbHNlIGJ3LmJ5dGUoT1BfSTMyX0NUWik7IHJldHVybjsgfVxuICAgICAgaWYgKG5hbWUgPT09
ICdwb3BjbnQnKSB7IGVtaXRFeHByKGV4cHIuYXJnc1swXSwgZXhwZWN0ZWRUeXBlKTsgaWYgKGV4
cGVjdGVkVHlwZSA9PT0gJ2k2NCcpIGJ3LmJ5dGUoT1BfSTY0X1BPUENOVCk7IGVsc2UgYncuYnl0
ZShPUF9JMzJfUE9QQ05UKTsgcmV0dXJuOyB9XG4gICAgICBpZiAobmFtZSA9PT0gJ3JvdGwnKSB7
IGVtaXRFeHByKGV4cHIuYXJnc1swXSwgZXhwZWN0ZWRUeXBlKTsgZW1pdEV4cHIoZXhwci5hcmdz
WzFdLCBleHBlY3RlZFR5cGUpOyBpZiAoZXhwZWN0ZWRUeXBlID09PSAnaTY0JykgYncuYnl0ZShP
UF9JNjRfUk9UTCk7IGVsc2UgYncuYnl0ZShPUF9JMzJfUk9UTCk7IHJldHVybjsgfVxuICAgICAg
aWYgKG5hbWUgPT09ICdyb3RyJykgeyBlbWl0RXhwcihleHByLmFyZ3NbMF0sIGV4cGVjdGVkVHlw
ZSk7IGVtaXRFeHByKGV4cHIuYXJnc1sxXSwgZXhwZWN0ZWRUeXBlKTsgaWYgKGV4cGVjdGVkVHlw
ZSA9PT0gJ2k2NCcpIGJ3LmJ5dGUoT1BfSTY0X1JPVFIpOyBlbHNlIGJ3LmJ5dGUoT1BfSTMyX1JP
VFIpOyByZXR1cm47IH1cbiAgICAgIGlmIChuYW1lID09PSAnbWVtb3J5X3NpemUnKSB7IGJ3LmJ5
dGUoT1BfTUVNT1JZX1NJWkUpOyBidy51MzIoMCk7IHJldHVybjsgfVxuICAgICAgaWYgKG5hbWUg
PT09ICdtZW1vcnlfZ3JvdycpIHsgZW1pdEV4cHIoZXhwci5hcmdzWzBdLCAnaTMyJyk7IGJ3LmJ5
dGUoT1BfTUVNT1JZX0dST1cpOyBidy51MzIoMCk7IHJldHVybjsgfVxuICAgICAgaWYgKG5hbWUg
PT09ICdtZW1vcnlfY29weScpIHtcbiAgICAgICAgZW1pdEV4cHIoZXhwci5hcmdzWzBdLCAnaTMy
Jyk7IGVtaXRFeHByKGV4cHIuYXJnc1sxXSwgJ2kzMicpOyBlbWl0RXhwcihleHByLmFyZ3NbMl0s
ICdpMzInKTtcbiAgICAgICAgYncuYnl0ZShPUF9GQ19QUkVGSVgpOyBidy51MzIoMTApOyBidy51
MzIoMCk7IGJ3LnUzMigwKTsgLy8gbWVtb3J5LmNvcHksIGRzdF9tZW09MCwgc3JjX21lbT0wXG4g
ICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChuYW1lID09PSAnbWVtb3J5X2ZpbGwn
KSB7XG4gICAgICAgIGVtaXRFeHByKGV4cHIuYXJnc1swXSwgJ2kzMicpOyBlbWl0RXhwcihleHBy
LmFyZ3NbMV0sICdpMzInKTsgZW1pdEV4cHIoZXhwci5hcmdzWzJdLCAnaTMyJyk7XG4gICAgICAg
IGJ3LmJ5dGUoT1BfRkNfUFJFRklYKTsgYncudTMyKDExKTsgYncudTMyKDApOyAvLyBtZW1vcnku
ZmlsbCwgbWVtPTBcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyB3YXNtLiog
ZXNjYXBlIGhhdGNoXG4gICAgICBpZiAobmFtZS5zdGFydHNXaXRoKCd3YXNtLicpKSB7XG4gICAg
ICAgIGVtaXRXYXNtQnVpbHRpbihuYW1lLnNsaWNlKDUpLCBleHByLCBleHBlY3RlZFR5cGUpO1xu
ICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIEluZGlyZWN0IGNhbGwgdmlhIGZ1
bmN0aW9uLXR5cGVkIHZhcmlhYmxlXG4gICAgICBjb25zdCBsb2NhbEluZm8gPSBsb2NhbE1hcFtu
YW1lXTtcbiAgICAgIGNvbnN0IGdTaWcgPSBnbG9iYWxGdW5jU2lnW25hbWVdO1xuICAgICAgaWYg
KChsb2NhbEluZm8gJiYgbG9jYWxJbmZvLmZ1bmNTaWcpIHx8IGdTaWcpIHtcbiAgICAgICAgY29u
c3Qgc2lnID0gKGxvY2FsSW5mbyAmJiBsb2NhbEluZm8uZnVuY1NpZykgfHwgZ1NpZztcbiAgICAg
ICAgLy8gRW1pdCBhcmd1bWVudHMgdXNpbmcgZnVuY1NpZyBwYXJhbSB0eXBlc1xuICAgICAgICBm
b3IgKGxldCBhaSA9IDA7IGFpIDwgZXhwci5hcmdzLmxlbmd0aDsgYWkrKykge1xuICAgICAgICAg
IGNvbnN0IHB0ID0gc2lnLnBhcmFtc1thaV0gPyAoc2lnLnBhcmFtc1thaV0uaXNBcnJheSA/ICdp
MzInIDogc2lnLnBhcmFtc1thaV0udnR5cGUpIDogJ2Y2NCc7XG4gICAgICAgICAgZW1pdEV4cHIo
ZXhwci5hcmdzW2FpXSwgcHQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFB1c2ggdGhlIHRhYmxl
IGluZGV4ICh0aGUgdmFyaWFibGUgdmFsdWUpXG4gICAgICAgIGlmIChsb2NhbEluZm8pIHsgYncu
Ynl0ZShPUF9MT0NBTF9HRVQpOyBidy51MzIobG9jYWxJbmZvLmlkeCk7IH1cbiAgICAgICAgZWxz
ZSB7IGJ3LmJ5dGUoT1BfR0xPQkFMX0dFVCk7IGJ3LnUzMihnbG9iYWxJbmRleFtuYW1lXSk7IH1c
biAgICAgICAgLy8gY2FsbF9pbmRpcmVjdCB0eXBlX2luZGV4IHRhYmxlX2luZGV4XG4gICAgICAg
IGNvbnN0IGluZGlyZWN0U2lnSWQgPSBnZXRPckFkZFNpZyhzaWcucGFyYW1zLCBzaWcucmV0VHlw
ZSk7XG4gICAgICAgIGJ3LmJ5dGUoT1BfQ0FMTF9JTkRJUkVDVCk7XG4gICAgICAgIGJ3LnUzMihp
bmRpcmVjdFNpZ0lkKTtcbiAgICAgICAgYncudTMyKDApOyAvLyB0YWJsZSBpbmRleCAwXG4gICAg
ICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gUmVndWxhciBmdW5jdGlvbiBjYWxsXG4g
ICAgICBjb25zdCBmSWR4ID0gZnVuY0luZGV4W25hbWVdO1xuICAgICAgaWYgKGZJZHggPT09IHVu
ZGVmaW5lZCkgdGhyb3cgbmV3IEVycm9yKGBVbmRlZmluZWQgZnVuY3Rpb246ICR7bmFtZX1gKTtc
biAgICAgIGZvciAobGV0IGFpID0gMDsgYWkgPCBleHByLmFyZ3MubGVuZ3RoOyBhaSsrKSB7XG4g
ICAgICAgIGNvbnN0IHBhcmFtVHlwZSA9IGdldFBhcmFtVHlwZShuYW1lLCBhaSk7XG4gICAgICAg
IGVtaXRFeHByKGV4cHIuYXJnc1thaV0sIHBhcmFtVHlwZSk7XG4gICAgICB9XG4gICAgICBidy5i
eXRlKE9QX0NBTEwpO1xuICAgICAgYncudTMyKGZJZHgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9u
IGVtaXRXYXNtQnVpbHRpbihvcCwgZXhwciwgZXhwZWN0ZWRUeXBlKSB7XG4gICAgICBjb25zdCB0
ID0gZXhwZWN0ZWRUeXBlIHx8ICdpMzInO1xuICAgICAgaWYgKG9wID09PSAnZGl2X3UnKSB7IGVt
aXRFeHByKGV4cHIuYXJnc1swXSwgdCk7IGVtaXRFeHByKGV4cHIuYXJnc1sxXSwgdCk7IGJ3LmJ5
dGUodCA9PT0gJ2k2NCcgPyBPUF9JNjRfRElWX1UgOiBPUF9JMzJfRElWX1UpOyByZXR1cm47IH1c
biAgICAgIGlmIChvcCA9PT0gJ3JlbV91JykgeyBlbWl0RXhwcihleHByLmFyZ3NbMF0sIHQpOyBl
bWl0RXhwcihleHByLmFyZ3NbMV0sIHQpOyBidy5ieXRlKHQgPT09ICdpNjQnID8gT1BfSTY0X1JF
TV9VIDogT1BfSTMyX1JFTV9VKTsgcmV0dXJuOyB9XG4gICAgICBpZiAob3AgPT09ICdzaHJfdScp
IHsgZW1pdEV4cHIoZXhwci5hcmdzWzBdLCB0KTsgZW1pdEV4cHIoZXhwci5hcmdzWzFdLCB0KTsg
YncuYnl0ZSh0ID09PSAnaTY0JyA/IE9QX0k2NF9TSFJfVSA6IE9QX0kzMl9TSFJfVSk7IHJldHVy
bjsgfVxuICAgICAgaWYgKG9wID09PSAnbHRfdScpIHsgZW1pdEV4cHIoZXhwci5hcmdzWzBdLCB0
KTsgZW1pdEV4cHIoZXhwci5hcmdzWzFdLCB0KTsgYncuYnl0ZSh0ID09PSAnaTY0JyA/IE9QX0k2
NF9MVF9VIDogT1BfSTMyX0xUX1UpOyByZXR1cm47IH1cbiAgICAgIGlmIChvcCA9PT0gJ2d0X3Un
KSB7IGVtaXRFeHByKGV4cHIuYXJnc1swXSwgdCk7IGVtaXRFeHByKGV4cHIuYXJnc1sxXSwgdCk7
IGJ3LmJ5dGUodCA9PT0gJ2k2NCcgPyBPUF9JNjRfR1RfVSA6IE9QX0kzMl9HVF9VKTsgcmV0dXJu
OyB9XG4gICAgICBpZiAob3AgPT09ICdsZV91JykgeyBlbWl0RXhwcihleHByLmFyZ3NbMF0sIHQp
OyBlbWl0RXhwcihleHByLmFyZ3NbMV0sIHQpOyBidy5ieXRlKHQgPT09ICdpNjQnID8gT1BfSTY0
X0xFX1UgOiBPUF9JMzJfTEVfVSk7IHJldHVybjsgfVxuICAgICAgaWYgKG9wID09PSAnZ2VfdScp
IHsgZW1pdEV4cHIoZXhwci5hcmdzWzBdLCB0KTsgZW1pdEV4cHIoZXhwci5hcmdzWzFdLCB0KTsg
YncuYnl0ZSh0ID09PSAnaTY0JyA/IE9QX0k2NF9HRV9VIDogT1BfSTMyX0dFX1UpOyByZXR1cm47
IH1cbiAgICAgIGlmIChvcCA9PT0gJ3JlaW50ZXJwcmV0X2Y2NCcpIHsgZW1pdEV4cHIoZXhwci5h
cmdzWzBdLCAnZjY0Jyk7IGJ3LmJ5dGUoT1BfSTY0X1JFSU5URVJQUkVUX0Y2NCk7IHJldHVybjsg
fVxuICAgICAgaWYgKG9wID09PSAncmVpbnRlcnByZXRfZjMyJykgeyBlbWl0RXhwcihleHByLmFy
Z3NbMF0sICdmMzInKTsgYncuYnl0ZShPUF9JMzJfUkVJTlRFUlBSRVRfRjMyKTsgcmV0dXJuOyB9
XG4gICAgICBpZiAob3AgPT09ICdyZWludGVycHJldF9pNjQnKSB7IGVtaXRFeHByKGV4cHIuYXJn
c1swXSwgJ2k2NCcpOyBidy5ieXRlKE9QX0Y2NF9SRUlOVEVSUFJFVF9JNjQpOyByZXR1cm47IH1c
biAgICAgIGlmIChvcCA9PT0gJ3JlaW50ZXJwcmV0X2kzMicpIHsgZW1pdEV4cHIoZXhwci5hcmdz
WzBdLCAnaTMyJyk7IGJ3LmJ5dGUoT1BfRjMyX1JFSU5URVJQUkVUX0kzMik7IHJldHVybjsgfVxu
ICAgICAgaWYgKG9wID09PSAnZXh0ZW5kOF9zJykgeyBlbWl0RXhwcihleHByLmFyZ3NbMF0sIHQp
OyBidy5ieXRlKHQgPT09ICdpNjQnID8gT1BfSTY0X0VYVEVORDhfUyA6IE9QX0kzMl9FWFRFTkQ4
X1MpOyByZXR1cm47IH1cbiAgICAgIGlmIChvcCA9PT0gJ2V4dGVuZDE2X3MnKSB7IGVtaXRFeHBy
KGV4cHIuYXJnc1swXSwgdCk7IGJ3LmJ5dGUodCA9PT0gJ2k2NCcgPyBPUF9JNjRfRVhURU5EMTZf
UyA6IE9QX0kzMl9FWFRFTkQxNl9TKTsgcmV0dXJuOyB9XG4gICAgICBpZiAob3AgPT09ICd0cnVu
Y19zYXRfcycpIHtcbiAgICAgICAgY29uc3QgZnJvbVR5cGUgPSBpbmZlckV4cHJUeXBlKGV4cHIu
YXJnc1swXSk7XG4gICAgICAgIGVtaXRFeHByKGV4cHIuYXJnc1swXSwgZnJvbVR5cGUpO1xuICAg
ICAgICBidy5ieXRlKE9QX0ZDX1BSRUZJWCk7XG4gICAgICAgIGlmICh0ID09PSAnaTMyJyAmJiBm
cm9tVHlwZSA9PT0gJ2YzMicpIGJ3LnUzMihPUF9JMzJfVFJVTkNfU0FUX0YzMl9TKTtcbiAgICAg
ICAgZWxzZSBpZiAodCA9PT0gJ2kzMicgJiYgZnJvbVR5cGUgPT09ICdmNjQnKSBidy51MzIoT1Bf
STMyX1RSVU5DX1NBVF9GNjRfUyk7XG4gICAgICAgIGVsc2UgaWYgKHQgPT09ICdpNjQnICYmIGZy
b21UeXBlID09PSAnZjMyJykgYncudTMyKE9QX0k2NF9UUlVOQ19TQVRfRjMyX1MpO1xuICAgICAg
ICBlbHNlIGlmICh0ID09PSAnaTY0JyAmJiBmcm9tVHlwZSA9PT0gJ2Y2NCcpIGJ3LnUzMihPUF9J
NjRfVFJVTkNfU0FUX0Y2NF9TKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYg
KG9wID09PSAndHJ1bmNfc2F0X3UnKSB7XG4gICAgICAgIGNvbnN0IGZyb21UeXBlID0gaW5mZXJF
eHByVHlwZShleHByLmFyZ3NbMF0pO1xuICAgICAgICBlbWl0RXhwcihleHByLmFyZ3NbMF0sIGZy
b21UeXBlKTtcbiAgICAgICAgYncuYnl0ZShPUF9GQ19QUkVGSVgpO1xuICAgICAgICBpZiAodCA9
PT0gJ2kzMicgJiYgZnJvbVR5cGUgPT09ICdmMzInKSBidy51MzIoT1BfSTMyX1RSVU5DX1NBVF9G
MzJfVSk7XG4gICAgICAgIGVsc2UgaWYgKHQgPT09ICdpMzInICYmIGZyb21UeXBlID09PSAnZjY0
JykgYncudTMyKE9QX0kzMl9UUlVOQ19TQVRfRjY0X1UpO1xuICAgICAgICBlbHNlIGlmICh0ID09
PSAnaTY0JyAmJiBmcm9tVHlwZSA9PT0gJ2YzMicpIGJ3LnUzMihPUF9JNjRfVFJVTkNfU0FUX0Yz
Ml9VKTtcbiAgICAgICAgZWxzZSBpZiAodCA9PT0gJ2k2NCcgJiYgZnJvbVR5cGUgPT09ICdmNjQn
KSBidy51MzIoT1BfSTY0X1RSVU5DX1NBVF9GNjRfVSk7XG4gICAgICAgIHJldHVybjtcbiAgICAg
IH1cbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biB3YXNtIGJ1aWx0aW46IHdhc20uJHtv
cH1gKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlbWl0VmVjdG9yQ29uc3RydWN0b3IodmVjVHlw
ZSwgYXJncykge1xuICAgICAgY29uc3Qgc2NhbGFyID0gdmVjdG9yU2NhbGFyVHlwZSh2ZWNUeXBl
KTtcbiAgICAgIGNvbnN0IGxhbmVDb3VudCA9IHZlY1R5cGUgPT09ICdmMzJ4NCcgfHwgdmVjVHlw
ZSA9PT0gJ2kzMng0JyA/IDQgOiAyO1xuXG4gICAgICBpZiAoYXJncy5sZW5ndGggIT09IGxhbmVD
b3VudCkgdGhyb3cgbmV3IEVycm9yKGAke3ZlY1R5cGV9IGNvbnN0cnVjdG9yIGV4cGVjdHMgJHts
YW5lQ291bnR9IGFyZ3MsIGdvdCAke2FyZ3MubGVuZ3RofWApO1xuXG4gICAgICAvLyBDaGVjayBp
ZiBhbGwgYXJncyBhcmUgY29uc3RhbnQgKE51bWJlckxpdCBvciBuZWdhdGl2ZSBOdW1iZXJMaXQp
XG4gICAgICBjb25zdCBhbGxDb25zdCA9IGFyZ3MuZXZlcnkoYSA9PlxuICAgICAgICBhLnR5cGUg
PT09ICdOdW1iZXJMaXQnIHx8XG4gICAgICAgIChhLnR5cGUgPT09ICdVbmFyeU9wJyAmJiBhLm9w
ID09PSAnLScgJiYgYS5vcGVyYW5kLnR5cGUgPT09ICdOdW1iZXJMaXQnKSk7XG5cbiAgICAgIGlm
IChhbGxDb25zdCkge1xuICAgICAgICAvLyBFbWl0IHYxMjguY29uc3Qgd2l0aCBpbmxpbmUgYnl0
ZXNcbiAgICAgICAgZW1pdFNpbWQoU0lNRF9PUFNbJ3YxMjguY29uc3QnXSk7XG4gICAgICAgIGNv
bnN0IGFidWYgPSBuZXcgQXJyYXlCdWZmZXIoMTYpO1xuICAgICAgICBjb25zdCB2aWV3ID0gbmV3
IERhdGFWaWV3KGFidWYpO1xuICAgICAgICBmb3IgKGxldCBsaSA9IDA7IGxpIDwgbGFuZUNvdW50
OyBsaSsrKSB7XG4gICAgICAgICAgY29uc3QgYSA9IGFyZ3NbbGldO1xuICAgICAgICAgIGNvbnN0
IHJhdyA9IGEudHlwZSA9PT0gJ051bWJlckxpdCcgPyBhLnZhbHVlIDogYS5vcGVyYW5kLnZhbHVl
O1xuICAgICAgICAgIGNvbnN0IHZhbCA9IGEudHlwZSA9PT0gJ1VuYXJ5T3AnID8gLXBhcnNlRmxv
YXQocmF3KSA6IHBhcnNlRmxvYXQocmF3KTtcbiAgICAgICAgICBpZiAoc2NhbGFyID09PSAnZjY0
Jykgdmlldy5zZXRGbG9hdDY0KGxpICogOCwgdmFsLCB0cnVlKTtcbiAgICAgICAgICBlbHNlIGlm
IChzY2FsYXIgPT09ICdmMzInKSB2aWV3LnNldEZsb2F0MzIobGkgKiA0LCB2YWwsIHRydWUpO1xu
ICAgICAgICAgIGVsc2UgaWYgKHNjYWxhciA9PT0gJ2kzMicpIHZpZXcuc2V0SW50MzIobGkgKiA0
LCB2YWwgfCAwLCB0cnVlKTtcbiAgICAgICAgICBlbHNlIGlmIChzY2FsYXIgPT09ICdpNjQnKSB7
XG4gICAgICAgICAgICAvLyBCaWdJbnQ2NCBhcyB0d28gaTMycywgbGl0dGxlLWVuZGlhblxuICAg
ICAgICAgICAgY29uc3QgYnYgPSBCaWdJbnQoTWF0aC50cnVuYyh2YWwpKTtcbiAgICAgICAgICAg
IHZpZXcuc2V0SW50MzIobGkgKiA4LCBOdW1iZXIoYnYgJiAweGZmZmZmZmZmbiksIHRydWUpO1xu
ICAgICAgICAgICAgdmlldy5zZXRJbnQzMihsaSAqIDggKyA0LCBOdW1iZXIoKGJ2ID4+IDMybikg
JiAweGZmZmZmZmZmbiksIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBi
dy5ieXRlcyhuZXcgVWludDhBcnJheShhYnVmKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAv
LyBTcGxhdCBmaXJzdCBhcmcsIHRoZW4gcmVwbGFjZV9sYW5lIGZvciB0aGUgcmVzdFxuICAgICAg
ICBlbWl0RXhwcihhcmdzWzBdLCBzY2FsYXIpO1xuICAgICAgICBlbWl0U2ltZChTSU1EX09QU1t2
ZWNUeXBlICsgJy5zcGxhdCddKTtcbiAgICAgICAgZm9yIChsZXQgbGkgPSAxOyBsaSA8IGxhbmVD
b3VudDsgbGkrKykge1xuICAgICAgICAgIGVtaXRFeHByKGFyZ3NbbGldLCBzY2FsYXIpO1xuICAg
ICAgICAgIGVtaXRTaW1kKFNJTURfT1BTW3ZlY1R5cGUgKyAnLnJlcGxhY2VfbGFuZSddKTtcbiAg
ICAgICAgICBidy5ieXRlKGxpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1
bmN0aW9uIGVtaXRTaW1kQnVpbHRpbihwcmVmaXgsIG1ldGhvZCwgZXhwciwgZXhwZWN0ZWRUeXBl
KSB7XG4gICAgICAvLyBmNjR4Mi5zcGxhdCh4KSwgaTMyeDQuc3BsYXQoeCksIGV0Yy5cbiAgICAg
IGlmIChtZXRob2QgPT09ICdzcGxhdCcpIHtcbiAgICAgICAgY29uc3Qgc2NhbGFyID0gdmVjdG9y
U2NhbGFyVHlwZShwcmVmaXgpO1xuICAgICAgICBlbWl0RXhwcihleHByLmFyZ3NbMF0sIHNjYWxh
cik7XG4gICAgICAgIGVtaXRTaW1kKFNJTURfT1BTW3ByZWZpeCArICcuc3BsYXQnXSk7XG4gICAg
ICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gZjY0eDIuZXh0cmFjdF9sYW5lKHYsIGxh
bmUpXG4gICAgICBpZiAobWV0aG9kID09PSAnZXh0cmFjdF9sYW5lJykge1xuICAgICAgICBlbWl0
RXhwcihleHByLmFyZ3NbMF0sIHByZWZpeCk7XG4gICAgICAgIGVtaXRTaW1kKFNJTURfT1BTW3By
ZWZpeCArICcuZXh0cmFjdF9sYW5lJ10pO1xuICAgICAgICAvLyBsYW5lIG11c3QgYmUgYSBjb25z
dGFudFxuICAgICAgICBpZiAoZXhwci5hcmdzWzFdLnR5cGUgIT09ICdOdW1iZXJMaXQnKSB0aHJv
dyBuZXcgRXJyb3IoJ2V4dHJhY3RfbGFuZSByZXF1aXJlcyBjb25zdGFudCBsYW5lIGluZGV4Jyk7
XG4gICAgICAgIGJ3LmJ5dGUocGFyc2VJbnQoZXhwci5hcmdzWzFdLnZhbHVlLCAxMCkpO1xuICAg
ICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIGY2NHgyLnJlcGxhY2VfbGFuZSh2LCBs
YW5lLCB4KVxuICAgICAgaWYgKG1ldGhvZCA9PT0gJ3JlcGxhY2VfbGFuZScpIHtcbiAgICAgICAg
Y29uc3Qgc2NhbGFyID0gdmVjdG9yU2NhbGFyVHlwZShwcmVmaXgpO1xuICAgICAgICBlbWl0RXhw
cihleHByLmFyZ3NbMF0sIHByZWZpeCk7IC8vIHYxMjggdmFsdWVcbiAgICAgICAgZW1pdEV4cHIo
ZXhwci5hcmdzWzJdLCBzY2FsYXIpOyAvLyByZXBsYWNlbWVudCBzY2FsYXJcbiAgICAgICAgZW1p
dFNpbWQoU0lNRF9PUFNbcHJlZml4ICsgJy5yZXBsYWNlX2xhbmUnXSk7XG4gICAgICAgIGlmIChl
eHByLmFyZ3NbMV0udHlwZSAhPT0gJ051bWJlckxpdCcpIHRocm93IG5ldyBFcnJvcigncmVwbGFj
ZV9sYW5lIHJlcXVpcmVzIGNvbnN0YW50IGxhbmUgaW5kZXgnKTtcbiAgICAgICAgYncuYnl0ZShw
YXJzZUludChleHByLmFyZ3NbMV0udmFsdWUsIDEwKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAg
IH1cblxuICAgICAgLy8gZjY0eDIuZXEsIGY2NHgyLm5lLCBmNjR4Mi5sdCwgZjY0eDIuZ3QsIGY2
NHgyLmxlLCBmNjR4Mi5nZVxuICAgICAgaWYgKFsnZXEnLCduZScsJ2x0JywnZ3QnLCdsZScsJ2dl
JywnbHRfcycsJ2d0X3MnLCdsZV9zJywnZ2VfcyddLmluY2x1ZGVzKG1ldGhvZCkpIHtcbiAgICAg
ICAgZW1pdEV4cHIoZXhwci5hcmdzWzBdLCBwcmVmaXgpO1xuICAgICAgICBlbWl0RXhwcihleHBy
LmFyZ3NbMV0sIHByZWZpeCk7XG4gICAgICAgIGNvbnN0IGtleSA9IHByZWZpeCArICcuJyArIG1l
dGhvZDtcbiAgICAgICAgY29uc3Qgb3AgPSBTSU1EX09QU1trZXldO1xuICAgICAgICBpZiAob3Ag
PT09IHVuZGVmaW5lZCkgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIFNJTUQgb3A6ICR7a2V5fWAp
O1xuICAgICAgICBlbWl0U2ltZChvcCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAg
ICAgLy8gZjY0eDIubmVnLCBmNjR4Mi5hYnMsIGY2NHgyLnNxcnQgKHVuYXJ5KVxuICAgICAgaWYg
KFsnbmVnJywnYWJzJywnc3FydCddLmluY2x1ZGVzKG1ldGhvZCkpIHtcbiAgICAgICAgZW1pdEV4
cHIoZXhwci5hcmdzWzBdLCBwcmVmaXgpO1xuICAgICAgICBjb25zdCBrZXkgPSBwcmVmaXggKyAn
LicgKyBtZXRob2Q7XG4gICAgICAgIGNvbnN0IG9wID0gU0lNRF9PUFNba2V5XTtcbiAgICAgICAg
aWYgKG9wID09PSB1bmRlZmluZWQpIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBTSU1EIG9wOiAk
e2tleX1gKTtcbiAgICAgICAgZW1pdFNpbWQob3ApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9
XG5cbiAgICAgIC8vIGY2NHgyLmFkZCwgZjY0eDIuc3ViLCBmNjR4Mi5tdWwsIGY2NHgyLmRpdiwg
ZjY0eDIubWluLCBmNjR4Mi5tYXggKGJpbmFyeSlcbiAgICAgIGlmIChbJ2FkZCcsJ3N1YicsJ211
bCcsJ2RpdicsJ21pbicsJ21heCddLmluY2x1ZGVzKG1ldGhvZCkpIHtcbiAgICAgICAgZW1pdEV4
cHIoZXhwci5hcmdzWzBdLCBwcmVmaXgpO1xuICAgICAgICBlbWl0RXhwcihleHByLmFyZ3NbMV0s
IHByZWZpeCk7XG4gICAgICAgIGNvbnN0IGtleSA9IHByZWZpeCArICcuJyArIG1ldGhvZDtcbiAg
ICAgICAgY29uc3Qgb3AgPSBTSU1EX09QU1trZXldO1xuICAgICAgICBpZiAob3AgPT09IHVuZGVm
aW5lZCkgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIFNJTUQgb3A6ICR7a2V5fWApO1xuICAgICAg
ICBlbWl0U2ltZChvcCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gdjEy
OC5hbmQsIHYxMjgub3IsIHYxMjgueG9yIChiaW5hcnkgYml0d2lzZSlcbiAgICAgIGlmIChwcmVm
aXggPT09ICd2MTI4JyAmJiBbJ2FuZCcsJ29yJywneG9yJ10uaW5jbHVkZXMobWV0aG9kKSkge1xu
ICAgICAgICAvLyBJbmZlciBvcGVyYW5kIHR5cGUgZnJvbSBmaXJzdCBhcmdcbiAgICAgICAgY29u
c3QgdnQgPSBpbmZlckV4cHJUeXBlKGV4cHIuYXJnc1swXSk7XG4gICAgICAgIGVtaXRFeHByKGV4
cHIuYXJnc1swXSwgdnQpO1xuICAgICAgICBlbWl0RXhwcihleHByLmFyZ3NbMV0sIHZ0KTtcbiAg
ICAgICAgZW1pdFNpbWQoU0lNRF9PUFNbJ3YxMjguJyArIG1ldGhvZF0pO1xuICAgICAgICByZXR1
cm47XG4gICAgICB9XG5cbiAgICAgIC8vIHYxMjgubm90ICh1bmFyeSBiaXR3aXNlKVxuICAgICAg
aWYgKHByZWZpeCA9PT0gJ3YxMjgnICYmIG1ldGhvZCA9PT0gJ25vdCcpIHtcbiAgICAgICAgY29u
c3QgdnQgPSBpbmZlckV4cHJUeXBlKGV4cHIuYXJnc1swXSk7XG4gICAgICAgIGVtaXRFeHByKGV4
cHIuYXJnc1swXSwgdnQpO1xuICAgICAgICBlbWl0U2ltZChTSU1EX09QU1sndjEyOC5ub3QnXSk7
XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gdjEyOC5sb2FkKGFyciwgaSkg
4oCUIGxvYWQgMTYgYnl0ZXMgZnJvbSBtZW1vcnkgYXQgYXJyICsgaSAqIDE2XG4gICAgICBpZiAo
cHJlZml4ID09PSAndjEyOCcgJiYgbWV0aG9kID09PSAnbG9hZCcpIHtcbiAgICAgICAgLy8gQ29t
cHV0ZSBhZGRyZXNzOiBhcnIgKyBpICogMTZcbiAgICAgICAgZW1pdEV4cHIoZXhwci5hcmdzWzBd
LCAnaTMyJyk7IC8vIGJhc2UgcG9pbnRlclxuICAgICAgICBlbWl0RXhwcihleHByLmFyZ3NbMV0s
ICdpMzInKTsgLy8gaW5kZXhcbiAgICAgICAgYncuYnl0ZShPUF9JMzJfQ09OU1QpOyBidy5zMzIo
MTYpO1xuICAgICAgICBidy5ieXRlKE9QX0kzMl9NVUwpO1xuICAgICAgICBidy5ieXRlKE9QX0kz
Ml9BREQpO1xuICAgICAgICBlbWl0U2ltZChTSU1EX09QU1sndjEyOC5sb2FkJ10pOyBidy51MzIo
NCk7IGJ3LnUzMigwKTsgLy8gYWxpZ249MTZcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4g
ICAgICAvLyB2MTI4LnN0b3JlKGFyciwgaSwgdikg4oCUIHN0b3JlIDE2IGJ5dGVzIHRvIG1lbW9y
eSBhdCBhcnIgKyBpICogMTZcbiAgICAgIGlmIChwcmVmaXggPT09ICd2MTI4JyAmJiBtZXRob2Qg
PT09ICdzdG9yZScpIHtcbiAgICAgICAgLy8gQ29tcHV0ZSBhZGRyZXNzXG4gICAgICAgIGVtaXRF
eHByKGV4cHIuYXJnc1swXSwgJ2kzMicpO1xuICAgICAgICBlbWl0RXhwcihleHByLmFyZ3NbMV0s
ICdpMzInKTtcbiAgICAgICAgYncuYnl0ZShPUF9JMzJfQ09OU1QpOyBidy5zMzIoMTYpO1xuICAg
ICAgICBidy5ieXRlKE9QX0kzMl9NVUwpO1xuICAgICAgICBidy5ieXRlKE9QX0kzMl9BREQpO1xu
ICAgICAgICAvLyBFbWl0IHZhbHVlXG4gICAgICAgIGNvbnN0IHZ0ID0gaW5mZXJFeHByVHlwZShl
eHByLmFyZ3NbMl0pO1xuICAgICAgICBlbWl0RXhwcihleHByLmFyZ3NbMl0sIHZ0KTtcbiAgICAg
ICAgZW1pdFNpbWQoU0lNRF9PUFNbJ3YxMjguc3RvcmUnXSk7IGJ3LnUzMig0KTsgYncudTMyKDAp
O1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5r
bm93biBTSU1EIGJ1aWx0aW46ICR7cHJlZml4fS4ke21ldGhvZH1gKTtcbiAgICB9XG5cbiAgICBm
dW5jdGlvbiBlbWl0Q29udmVyc2lvbihmcm9tLCB0bykge1xuICAgICAgaWYgKGZyb20gPT09IHRv
KSByZXR1cm47XG4gICAgICBpZiAoZnJvbSA9PT0gJ2kzMicgJiYgdG8gPT09ICdmNjQnKSBidy5i
eXRlKE9QX0Y2NF9DT05WRVJUX0kzMl9TKTtcbiAgICAgIGVsc2UgaWYgKGZyb20gPT09ICdpMzIn
ICYmIHRvID09PSAnZjMyJykgYncuYnl0ZShPUF9GMzJfQ09OVkVSVF9JMzJfUyk7XG4gICAgICBl
bHNlIGlmIChmcm9tID09PSAnaTMyJyAmJiB0byA9PT0gJ2k2NCcpIGJ3LmJ5dGUoT1BfSTY0X0VY
VEVORF9JMzJfUyk7XG4gICAgICBlbHNlIGlmIChmcm9tID09PSAnaTY0JyAmJiB0byA9PT0gJ2kz
MicpIGJ3LmJ5dGUoT1BfSTMyX1dSQVBfSTY0KTtcbiAgICAgIGVsc2UgaWYgKGZyb20gPT09ICdp
NjQnICYmIHRvID09PSAnZjY0JykgYncuYnl0ZShPUF9GNjRfQ09OVkVSVF9JNjRfUyk7XG4gICAg
ICBlbHNlIGlmIChmcm9tID09PSAnaTY0JyAmJiB0byA9PT0gJ2YzMicpIGJ3LmJ5dGUoT1BfRjMy
X0NPTlZFUlRfSTY0X1MpO1xuICAgICAgZWxzZSBpZiAoZnJvbSA9PT0gJ2Y2NCcgJiYgdG8gPT09
ICdpMzInKSBidy5ieXRlKE9QX0kzMl9UUlVOQ19GNjRfUyk7XG4gICAgICBlbHNlIGlmIChmcm9t
ID09PSAnZjY0JyAmJiB0byA9PT0gJ2k2NCcpIGJ3LmJ5dGUoT1BfSTY0X1RSVU5DX0Y2NF9TKTtc
biAgICAgIGVsc2UgaWYgKGZyb20gPT09ICdmNjQnICYmIHRvID09PSAnZjMyJykgYncuYnl0ZShP
UF9GMzJfREVNT1RFX0Y2NCk7XG4gICAgICBlbHNlIGlmIChmcm9tID09PSAnZjMyJyAmJiB0byA9
PT0gJ2Y2NCcpIGJ3LmJ5dGUoT1BfRjY0X1BST01PVEVfRjMyKTtcbiAgICAgIGVsc2UgaWYgKGZy
b20gPT09ICdmMzInICYmIHRvID09PSAnaTMyJykgYncuYnl0ZShPUF9JMzJfVFJVTkNfRjMyX1Mp
O1xuICAgICAgZWxzZSBpZiAoZnJvbSA9PT0gJ2YzMicgJiYgdG8gPT09ICdpNjQnKSBidy5ieXRl
KE9QX0k2NF9UUlVOQ19GMzJfUyk7XG4gICAgICBlbHNlIHRocm93IG5ldyBFcnJvcihgQ2Fubm90
IGNvbnZlcnQgJHtmcm9tfSB0byAke3RvfWApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVtaXRB
cnJheUFkZHIobmFtZSwgaW5kaWNlcywgaW5mbywgZWxlbVR5cGUpIHtcbiAgICAgIC8vIEJhc2Ug
cG9pbnRlclxuICAgICAgYncuYnl0ZShPUF9MT0NBTF9HRVQpO1xuICAgICAgYncudTMyKGluZm8u
aWR4KTtcblxuICAgICAgY29uc3Qgc3ogPSB0eXBlU2l6ZShlbGVtVHlwZSk7XG5cbiAgICAgIGlm
IChpbmRpY2VzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAvLyAxRDogYmFzZSArIGkgKiBzaXpl
b2ZcbiAgICAgICAgZW1pdEV4cHIoaW5kaWNlc1swXSwgJ2kzMicpO1xuICAgICAgICBidy5ieXRl
KE9QX0kzMl9DT05TVCk7IGJ3LnMzMihzeik7XG4gICAgICAgIGJ3LmJ5dGUoT1BfSTMyX01VTCk7
XG4gICAgICAgIGJ3LmJ5dGUoT1BfSTMyX0FERCk7XG4gICAgICB9IGVsc2UgaWYgKGluZGljZXMu
bGVuZ3RoID09PSAzICYmICFpbmZvLmFycmF5RGltcykge1xuICAgICAgICAvLyAyRCB3aXRoIGV4
cGxpY2l0IHN0cmlkZTogYVtpLCBzdHJpZGUsIGpdIOKGkiBiYXNlICsgKGkqc3RyaWRlICsgaikg
KiBzaXplb2ZcbiAgICAgICAgZW1pdEV4cHIoaW5kaWNlc1swXSwgJ2kzMicpO1xuICAgICAgICBl
bWl0RXhwcihpbmRpY2VzWzFdLCAnaTMyJyk7XG4gICAgICAgIGJ3LmJ5dGUoT1BfSTMyX01VTCk7
XG4gICAgICAgIGVtaXRFeHByKGluZGljZXNbMl0sICdpMzInKTtcbiAgICAgICAgYncuYnl0ZShP
UF9JMzJfQUREKTtcbiAgICAgICAgYncuYnl0ZShPUF9JMzJfQ09OU1QpOyBidy5zMzIoc3opO1xu
ICAgICAgICBidy5ieXRlKE9QX0kzMl9NVUwpO1xuICAgICAgICBidy5ieXRlKE9QX0kzMl9BREQp
O1xuICAgICAgfSBlbHNlIGlmIChpbmRpY2VzLmxlbmd0aCA9PT0gMiAmJiBpbmZvLmFycmF5RGlt
cyAmJiBpbmZvLmFycmF5RGltcy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgLy8gMkQgd2l0aCBk
ZWNsYXJlZCBkaW1zOiBhW2ksIGpdIOKGkiBiYXNlICsgKGkqZGltMSArIGopICogc2l6ZW9mXG4g
ICAgICAgIGVtaXRFeHByKGluZGljZXNbMF0sICdpMzInKTtcbiAgICAgICAgZW1pdEV4cHIoaW5m
by5hcnJheURpbXNbMV0sICdpMzInKTtcbiAgICAgICAgYncuYnl0ZShPUF9JMzJfTVVMKTtcbiAg
ICAgICAgZW1pdEV4cHIoaW5kaWNlc1sxXSwgJ2kzMicpO1xuICAgICAgICBidy5ieXRlKE9QX0kz
Ml9BREQpO1xuICAgICAgICBidy5ieXRlKE9QX0kzMl9DT05TVCk7IGJ3LnMzMihzeik7XG4gICAg
ICAgIGJ3LmJ5dGUoT1BfSTMyX01VTCk7XG4gICAgICAgIGJ3LmJ5dGUoT1BfSTMyX0FERCk7XG4g
ICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGFycmF5
IGluZGV4IHBhdHRlcm4gZm9yICR7bmFtZX1gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5j
dGlvbiBlbWl0TG9hZCh0KSB7XG4gICAgICBpZiAodCA9PT0gJ2kzMicpIHsgYncuYnl0ZShPUF9J
MzJfTE9BRCk7IGJ3LnUzMigyKTsgYncudTMyKDApOyB9IC8vIGFsaWduPTRcbiAgICAgIGVsc2Ug
aWYgKHQgPT09ICdpNjQnKSB7IGJ3LmJ5dGUoT1BfSTY0X0xPQUQpOyBidy51MzIoMyk7IGJ3LnUz
MigwKTsgfVxuICAgICAgZWxzZSBpZiAodCA9PT0gJ2YzMicpIHsgYncuYnl0ZShPUF9GMzJfTE9B
RCk7IGJ3LnUzMigyKTsgYncudTMyKDApOyB9XG4gICAgICBlbHNlIGlmICh0ID09PSAnZjY0Jykg
eyBidy5ieXRlKE9QX0Y2NF9MT0FEKTsgYncudTMyKDMpOyBidy51MzIoMCk7IH1cbiAgICAgIGVs
c2UgaWYgKGlzVmVjdG9yKHQpKSB7IGVtaXRTaW1kKFNJTURfT1BTWyd2MTI4LmxvYWQnXSk7IGJ3
LnUzMig0KTsgYncudTMyKDApOyB9IC8vIGFsaWduPTE2XG4gICAgfVxuXG4gICAgZnVuY3Rpb24g
ZW1pdFN0b3JlKHQpIHtcbiAgICAgIGlmICh0ID09PSAnaTMyJykgeyBidy5ieXRlKE9QX0kzMl9T
VE9SRSk7IGJ3LnUzMigyKTsgYncudTMyKDApOyB9XG4gICAgICBlbHNlIGlmICh0ID09PSAnaTY0
JykgeyBidy5ieXRlKE9QX0k2NF9TVE9SRSk7IGJ3LnUzMigzKTsgYncudTMyKDApOyB9XG4gICAg
ICBlbHNlIGlmICh0ID09PSAnZjMyJykgeyBidy5ieXRlKE9QX0YzMl9TVE9SRSk7IGJ3LnUzMigy
KTsgYncudTMyKDApOyB9XG4gICAgICBlbHNlIGlmICh0ID09PSAnZjY0JykgeyBidy5ieXRlKE9Q
X0Y2NF9TVE9SRSk7IGJ3LnUzMigzKTsgYncudTMyKDApOyB9XG4gICAgICBlbHNlIGlmIChpc1Zl
Y3Rvcih0KSkgeyBlbWl0U2ltZChTSU1EX09QU1sndjEyOC5zdG9yZSddKTsgYncudTMyKDQpOyBi
dy51MzIoMCk7IH0gLy8gYWxpZ249MTZcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlbWl0Q21wKG9w
LCB0KSB7XG4gICAgICBpZiAodCA9PT0gJ2Y2NCcpIHtcbiAgICAgICAgaWYgKG9wID09PSAnPT0n
KSBidy5ieXRlKE9QX0Y2NF9FUSk7XG4gICAgICAgIGVsc2UgaWYgKG9wID09PSAnLz0nKSBidy5i
eXRlKE9QX0Y2NF9ORSk7XG4gICAgICAgIGVsc2UgaWYgKG9wID09PSAnPCcpIGJ3LmJ5dGUoT1Bf
RjY0X0xUKTtcbiAgICAgICAgZWxzZSBpZiAob3AgPT09ICc+JykgYncuYnl0ZShPUF9GNjRfR1Qp
O1xuICAgICAgICBlbHNlIGlmIChvcCA9PT0gJzw9JykgYncuYnl0ZShPUF9GNjRfTEUpO1xuICAg
ICAgICBlbHNlIGlmIChvcCA9PT0gJz49JykgYncuYnl0ZShPUF9GNjRfR0UpO1xuICAgICAgfSBl
bHNlIGlmICh0ID09PSAnZjMyJykge1xuICAgICAgICBpZiAob3AgPT09ICc9PScpIGJ3LmJ5dGUo
T1BfRjMyX0VRKTtcbiAgICAgICAgZWxzZSBpZiAob3AgPT09ICcvPScpIGJ3LmJ5dGUoT1BfRjMy
X05FKTtcbiAgICAgICAgZWxzZSBpZiAob3AgPT09ICc8JykgYncuYnl0ZShPUF9GMzJfTFQpO1xu
ICAgICAgICBlbHNlIGlmIChvcCA9PT0gJz4nKSBidy5ieXRlKE9QX0YzMl9HVCk7XG4gICAgICAg
IGVsc2UgaWYgKG9wID09PSAnPD0nKSBidy5ieXRlKE9QX0YzMl9MRSk7XG4gICAgICAgIGVsc2Ug
aWYgKG9wID09PSAnPj0nKSBidy5ieXRlKE9QX0YzMl9HRSk7XG4gICAgICB9IGVsc2UgaWYgKHQg
PT09ICdpMzInKSB7XG4gICAgICAgIGlmIChvcCA9PT0gJz09JykgYncuYnl0ZShPUF9JMzJfRVEp
O1xuICAgICAgICBlbHNlIGlmIChvcCA9PT0gJy89JykgYncuYnl0ZShPUF9JMzJfTkUpO1xuICAg
ICAgICBlbHNlIGlmIChvcCA9PT0gJzwnKSBidy5ieXRlKE9QX0kzMl9MVF9TKTtcbiAgICAgICAg
ZWxzZSBpZiAob3AgPT09ICc+JykgYncuYnl0ZShPUF9JMzJfR1RfUyk7XG4gICAgICAgIGVsc2Ug
aWYgKG9wID09PSAnPD0nKSBidy5ieXRlKE9QX0kzMl9MRV9TKTtcbiAgICAgICAgZWxzZSBpZiAo
b3AgPT09ICc+PScpIGJ3LmJ5dGUoT1BfSTMyX0dFX1MpO1xuICAgICAgfSBlbHNlIGlmICh0ID09
PSAnaTY0Jykge1xuICAgICAgICBpZiAob3AgPT09ICc9PScpIGJ3LmJ5dGUoT1BfSTY0X0VRKTtc
biAgICAgICAgZWxzZSBpZiAob3AgPT09ICcvPScpIGJ3LmJ5dGUoT1BfSTY0X05FKTtcbiAgICAg
ICAgZWxzZSBpZiAob3AgPT09ICc8JykgYncuYnl0ZShPUF9JNjRfTFRfUyk7XG4gICAgICAgIGVs
c2UgaWYgKG9wID09PSAnPicpIGJ3LmJ5dGUoT1BfSTY0X0dUX1MpO1xuICAgICAgICBlbHNlIGlm
IChvcCA9PT0gJzw9JykgYncuYnl0ZShPUF9JNjRfTEVfUyk7XG4gICAgICAgIGVsc2UgaWYgKG9w
ID09PSAnPj0nKSBidy5ieXRlKE9QX0k2NF9HRV9TKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNWZWN0
b3IodCkpIHtcbiAgICAgICAgLy8gVmVjdG9yIGNvbXBhcmlzb25zIOKAlCBtYXAgYXRyYSBvcHMg
dG8gU0lNRCBvcGNvZGUga2V5c1xuICAgICAgICBjb25zdCBpc0ludFZlYyA9ICh0ID09PSAnaTMy
eDQnIHx8IHQgPT09ICdpNjR4MicpO1xuICAgICAgICBjb25zdCBzdWZmaXggPSBpc0ludFZlYyA/
ICdfcycgOiAnJztcbiAgICAgICAgbGV0IGtleTtcbiAgICAgICAgaWYgKG9wID09PSAnPT0nKSBr
ZXkgPSB0ICsgJy5lcSc7XG4gICAgICAgIGVsc2UgaWYgKG9wID09PSAnLz0nKSBrZXkgPSB0ICsg
Jy5uZSc7XG4gICAgICAgIGVsc2UgaWYgKG9wID09PSAnPCcpIGtleSA9IHQgKyAoaXNJbnRWZWMg
PyAnLmx0X3MnIDogJy5sdCcpO1xuICAgICAgICBlbHNlIGlmIChvcCA9PT0gJz4nKSBrZXkgPSB0
ICsgKGlzSW50VmVjID8gJy5ndF9zJyA6ICcuZ3QnKTtcbiAgICAgICAgZWxzZSBpZiAob3AgPT09
ICc8PScpIGtleSA9IHQgKyAoaXNJbnRWZWMgPyAnLmxlX3MnIDogJy5sZScpO1xuICAgICAgICBl
bHNlIGlmIChvcCA9PT0gJz49Jykga2V5ID0gdCArIChpc0ludFZlYyA/ICcuZ2VfcycgOiAnLmdl
Jyk7XG4gICAgICAgIGNvbnN0IG9wY29kZSA9IFNJTURfT1BTW2tleV07XG4gICAgICAgIGlmIChv
cGNvZGUgPT09IHVuZGVmaW5lZCkgdGhyb3cgbmV3IEVycm9yKGBDb21wYXJpc29uICR7b3B9IG5v
dCBzdXBwb3J0ZWQgZm9yICR7dH1gKTtcbiAgICAgICAgZW1pdFNpbWQob3Bjb2RlKTtcbiAgICAg
IH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlbWl0QWRkKHQpIHtcbiAgICAgIGlmICh0ID09PSAn
ZjY0JykgYncuYnl0ZShPUF9GNjRfQUREKTtcbiAgICAgIGVsc2UgaWYgKHQgPT09ICdmMzInKSBi
dy5ieXRlKE9QX0YzMl9BREQpO1xuICAgICAgZWxzZSBpZiAodCA9PT0gJ2kzMicpIGJ3LmJ5dGUo
T1BfSTMyX0FERCk7XG4gICAgICBlbHNlIGlmICh0ID09PSAnaTY0JykgYncuYnl0ZShPUF9JNjRf
QUREKTtcbiAgICAgIGVsc2UgaWYgKGlzVmVjdG9yKHQpKSBlbWl0U2ltZChTSU1EX09QU1t0ICsg
Jy5hZGQnXSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZW1pdFN1Yih0KSB7XG4gICAgICBpZiAo
dCA9PT0gJ2Y2NCcpIGJ3LmJ5dGUoT1BfRjY0X1NVQik7XG4gICAgICBlbHNlIGlmICh0ID09PSAn
ZjMyJykgYncuYnl0ZShPUF9GMzJfU1VCKTtcbiAgICAgIGVsc2UgaWYgKHQgPT09ICdpMzInKSBi
dy5ieXRlKE9QX0kzMl9TVUIpO1xuICAgICAgZWxzZSBpZiAodCA9PT0gJ2k2NCcpIGJ3LmJ5dGUo
T1BfSTY0X1NVQik7XG4gICAgICBlbHNlIGlmIChpc1ZlY3Rvcih0KSkgZW1pdFNpbWQoU0lNRF9P
UFNbdCArICcuc3ViJ10pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVtaXRNdWwodCkge1xuICAg
ICAgaWYgKHQgPT09ICdmNjQnKSBidy5ieXRlKE9QX0Y2NF9NVUwpO1xuICAgICAgZWxzZSBpZiAo
dCA9PT0gJ2YzMicpIGJ3LmJ5dGUoT1BfRjMyX01VTCk7XG4gICAgICBlbHNlIGlmICh0ID09PSAn
aTMyJykgYncuYnl0ZShPUF9JMzJfTVVMKTtcbiAgICAgIGVsc2UgaWYgKHQgPT09ICdpNjQnKSBi
dy5ieXRlKE9QX0k2NF9NVUwpO1xuICAgICAgZWxzZSBpZiAoaXNWZWN0b3IodCkpIGVtaXRTaW1k
KFNJTURfT1BTW3QgKyAnLm11bCddKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlbWl0RGl2KHQp
IHtcbiAgICAgIGlmICh0ID09PSAnZjY0JykgYncuYnl0ZShPUF9GNjRfRElWKTtcbiAgICAgIGVs
c2UgaWYgKHQgPT09ICdmMzInKSBidy5ieXRlKE9QX0YzMl9ESVYpO1xuICAgICAgZWxzZSBpZiAo
dCA9PT0gJ2kzMicpIGJ3LmJ5dGUoT1BfSTMyX0RJVl9TKTtcbiAgICAgIGVsc2UgaWYgKHQgPT09
ICdpNjQnKSBidy5ieXRlKE9QX0k2NF9ESVZfUyk7XG4gICAgICBlbHNlIGlmIChpc1ZlY3Rvcih0
KSkge1xuICAgICAgICBjb25zdCBvcCA9IFNJTURfT1BTW3QgKyAnLmRpdiddO1xuICAgICAgICBp
ZiAoIW9wKSB0aHJvdyBuZXcgRXJyb3IoJ0RpdmlzaW9uIG5vdCBzdXBwb3J0ZWQgZm9yICcgKyB0
KTtcbiAgICAgICAgZW1pdFNpbWQob3ApO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIOKUgOKU
gCBFbWl0IGZ1bmN0aW9uIGJvZHkgc3RhdGVtZW50cyDilIDilIBcbiAgICBlbWl0U3RtdHMoZm4u
Ym9keSk7XG5cbiAgICAvLyDilIDilIAgRW5kIG9mIGZ1bmN0aW9uIGJvZHk6IHJldHVybiB2YWx1
ZSDilIDilIBcbiAgICBpZiAoaXNGdW5jKSB7XG4gICAgICBidy5ieXRlKE9QX0xPQ0FMX0dFVCk7
XG4gICAgICBidy51MzIobG9jYWxNYXBbJyRfcmV0dXJuJ10uaWR4KTtcbiAgICB9XG4gICAgYncu
Ynl0ZShPUF9FTkQpO1xuICB9XG59XG5cbi8vIOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKV
kOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKV
kOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKV
kOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKV
kOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkFxuLy8gNS4gVEFHR0VEIFRFTVBMQVRFIEdMVUUgKyBT
RUxGLVJFR0lTVFJBVElPTlxuLy8g4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ
4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ
4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ
4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ
4pWQ4pWQ4pWQ4pWQ4pWQ4pWQXG5cbmZ1bmN0aW9uIGNvbXBpbGVTb3VyY2Uoc291cmNlLCBpbnRl
cnBWYWx1ZXMsIHVzZXJJbXBvcnRzKSB7XG4gIGNvbnN0IHRva2VucyA9IGxleChzb3VyY2UpO1xu
ICBjb25zdCBhc3QgPSBwYXJzZSh0b2tlbnMpO1xuICByZXR1cm4gY29kZWdlbihhc3QsIGludGVy
cFZhbHVlcywgdXNlckltcG9ydHMpO1xufVxuXG4vLyBGbGF0dGVuIG5lc3RlZCBvYmplY3RzIHRv
IGRvdHRlZCBrZXlzOiB7IGE6IHsgYjogZm4gfSB9IOKGkiB7ICdhLmInOiBmbiB9XG4vLyBFbmFi
bGVzIGF0cmEgb3V0cHV0IChuZXN0ZWQgZXhwb3J0cykgdG8gZmVlZCBkaXJlY3RseSBhcyBhdHJh
IGlucHV0IChpbXBvcnRzKS5cbmZ1bmN0aW9uIGZsYXR0ZW5JbXBvcnRzKG9iaiwgcHJlZml4KSB7
XG4gIGNvbnN0IGZsYXQgPSB7fTtcbiAgZm9yIChjb25zdCBbaywgdl0gb2YgT2JqZWN0LmVudHJp
ZXMob2JqKSkge1xuICAgIGlmICghcHJlZml4ICYmIChrID09PSAnX19tZW1vcnknIHx8IGsgPT09
ICdtZW1vcnknIHx8IGsgPT09ICdfX3RhYmxlJykpIGNvbnRpbnVlO1xuICAgIGNvbnN0IGtleSA9
IHByZWZpeCA/IHByZWZpeCArICcuJyArIGsgOiBrO1xuICAgIGlmICh0eXBlb2YgdiA9PT0gJ2Z1
bmN0aW9uJykgZmxhdFtrZXldID0gdjtcbiAgICBlbHNlIGlmICh2ICYmIHR5cGVvZiB2ID09PSAn
b2JqZWN0JyAmJiAhQXJyYXlCdWZmZXIuaXNWaWV3KHYpKSBPYmplY3QuYXNzaWduKGZsYXQsIGZs
YXR0ZW5JbXBvcnRzKHYsIGtleSkpO1xuICB9XG4gIHJldHVybiBmbGF0O1xufVxuXG5mdW5jdGlv
biBpbnN0YW50aWF0ZShieXRlcywgdXNlckltcG9ydHMsIGludGVycFZhbHVlcykge1xuICBjb25z
dCBpbXBvcnRPYmogPSB7IG1hdGg6IHt9IH07XG5cbiAgLy8gTWF0aCBidWlsdGluc1xuICBpbXBv
cnRPYmoubWF0aC5zaW4gPSBNYXRoLnNpbjtcbiAgaW1wb3J0T2JqLm1hdGguY29zID0gTWF0aC5j
b3M7XG4gIGltcG9ydE9iai5tYXRoLmxuID0gTWF0aC5sb2c7XG4gIGltcG9ydE9iai5tYXRoLmV4
cCA9IE1hdGguZXhwO1xuICBpbXBvcnRPYmoubWF0aC5wb3cgPSBNYXRoLnBvdztcbiAgaW1wb3J0
T2JqLm1hdGguYXRhbjIgPSBNYXRoLmF0YW4yO1xuXG4gIC8vIEhvc3QgaW1wb3J0cyAoZnJvbSB1
c2VySW1wb3J0cyBvciBnbG9iYWxUaGlzKVxuICBpbXBvcnRPYmouaG9zdCA9IHt9O1xuICBpZiAo
dXNlckltcG9ydHMpIHtcbiAgICBjb25zdCBmbGF0ID0gZmxhdHRlbkltcG9ydHModXNlckltcG9y
dHMpO1xuICAgIGZvciAoY29uc3QgW2ssIHZdIG9mIE9iamVjdC5lbnRyaWVzKGZsYXQpKSBpbXBv
cnRPYmouaG9zdFtrXSA9IHY7XG4gIH1cblxuICAvLyBJbnRlcnBvbGF0ZWQgaW1wb3J0c1xuICBp
ZiAoaW50ZXJwVmFsdWVzKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnRlcnBWYWx1ZXMu
bGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHYgPSBpbnRlcnBWYWx1ZXNbaV07XG4gICAgICBp
ZiAodHlwZW9mIHYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaW1wb3J0T2JqLmhvc3RbJ19f
SU5URVJQXycgKyBpICsgJ19fJ10gPSB2O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIE1l
bW9yeVxuICBpZiAodXNlckltcG9ydHMgJiYgdXNlckltcG9ydHMuX19tZW1vcnkpIHtcbiAgICBp
ZiAoIWltcG9ydE9iai5lbnYpIGltcG9ydE9iai5lbnYgPSB7fTtcbiAgICBpbXBvcnRPYmouZW52
Lm1lbW9yeSA9IHVzZXJJbXBvcnRzLl9fbWVtb3J5O1xuICB9XG5cbiAgY29uc3QgbW9kID0gbmV3
IFdlYkFzc2VtYmx5Lk1vZHVsZShieXRlcyk7XG4gIGNvbnN0IGluc3RhbmNlID0gbmV3IFdlYkFz
c2VtYmx5Lkluc3RhbmNlKG1vZCwgaW1wb3J0T2JqKTtcbiAgcmV0dXJuIGluc3RhbmNlO1xufVxu
XG5leHBvcnQgZnVuY3Rpb24gYXRyYShzdHJpbmdzT3JPcHRzLCAuLi52YWx1ZXMpIHtcbiAgLy8g
Q3VycmllZCBmb3JtOiBhdHJhKHtpbXBvcnRzfSlgLi4uYFxuICBpZiAoc3RyaW5nc09yT3B0cyAm
JiAhQXJyYXkuaXNBcnJheShzdHJpbmdzT3JPcHRzKSAmJiB0eXBlb2Ygc3RyaW5nc09yT3B0cyA9
PT0gJ29iamVjdCcgJiYgIXN0cmluZ3NPck9wdHMucmF3KSB7XG4gICAgY29uc3Qgb3B0cyA9IHN0
cmluZ3NPck9wdHM7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHN0cmluZ3MsIC4uLnZhbHMpIHtcbiAg
ICAgIHJldHVybiBjb21waWxlQW5kSW5zdGFudGlhdGUoc3RyaW5ncywgdmFscywgb3B0cyk7XG4g
ICAgfTtcbiAgfVxuICAvLyBEaXJlY3QgZm9ybTogYXRyYWAuLi5gXG4gIHJldHVybiBjb21waWxl
QW5kSW5zdGFudGlhdGUoc3RyaW5nc09yT3B0cywgdmFsdWVzLCBudWxsKTtcbn1cblxuZnVuY3Rp
b24gd3JhcEV4cG9ydHMoaW5zdGFuY2UsIHRhYmxlKSB7XG4gIGNvbnN0IGV4cG9ydHMgPSBPYmpl
Y3QuY3JlYXRlKGluc3RhbmNlLmV4cG9ydHMpO1xuICBpZiAodGFibGUpIGV4cG9ydHMuX190YWJs
ZSA9IHRhYmxlO1xuICAvLyBOZXN0IGRvdHRlZCBleHBvcnQgbmFtZXM6IFwicGh5c2ljcy5ncmF2
aXR5XCIg4oaSIGV4cG9ydHMucGh5c2ljcy5ncmF2aXR5XG4gIGZvciAoY29uc3Qga2V5IG9mIE9i
amVjdC5rZXlzKGluc3RhbmNlLmV4cG9ydHMpKSB7XG4gICAgaWYgKGtleS5pbmNsdWRlcygnLicp
KSB7XG4gICAgICBjb25zdCBwYXJ0cyA9IGtleS5zcGxpdCgnLicpO1xuICAgICAgbGV0IG9iaiA9
IGV4cG9ydHM7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aCAtIDE7IGkr
Kykge1xuICAgICAgICBpZiAoIW9ialtwYXJ0c1tpXV0gfHwgdHlwZW9mIG9ialtwYXJ0c1tpXV0g
IT09ICdvYmplY3QnKSBvYmpbcGFydHNbaV1dID0ge307XG4gICAgICAgIG9iaiA9IG9ialtwYXJ0
c1tpXV07XG4gICAgICB9XG4gICAgICBvYmpbcGFydHNbcGFydHMubGVuZ3RoIC0gMV1dID0gaW5z
dGFuY2UuZXhwb3J0c1trZXldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZXhwb3J0cztcbn1cblxu
ZnVuY3Rpb24gbm9ybWFsaXplTWVtb3J5SW1wb3J0KHVzZXJJbXBvcnRzKSB7XG4gIGlmICh1c2Vy
SW1wb3J0cyAmJiB1c2VySW1wb3J0cy5tZW1vcnkgJiYgIXVzZXJJbXBvcnRzLl9fbWVtb3J5KSB7
XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHVzZXJJbXBvcnRzLCB7IF9fbWVtb3J5OiB1
c2VySW1wb3J0cy5tZW1vcnkgfSk7XG4gIH1cbiAgcmV0dXJuIHVzZXJJbXBvcnRzO1xufVxuXG5m
dW5jdGlvbiBjb21waWxlQW5kSW5zdGFudGlhdGUoc3RyaW5ncywgdmFsdWVzLCB1c2VySW1wb3J0
cykge1xuICB1c2VySW1wb3J0cyA9IG5vcm1hbGl6ZU1lbW9yeUltcG9ydCh1c2VySW1wb3J0cyk7
XG4gIC8vIEpvaW4gdGVtcGxhdGUgc3RyaW5ncyB3aXRoIGludGVycG9sYXRpb24gbWFya2Vyc1xu
ICBsZXQgc291cmNlID0gc3RyaW5nc1swXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZXMu
bGVuZ3RoOyBpKyspIHtcbiAgICAvLyBGb3IgbnVtZXJpYyB2YWx1ZXMsIGlubGluZSB0aGVtIGRp
cmVjdGx5XG4gICAgaWYgKHR5cGVvZiB2YWx1ZXNbaV0gPT09ICdudW1iZXInKSB7XG4gICAgICBz
b3VyY2UgKz0gU3RyaW5nKHZhbHVlc1tpXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNvdXJjZSAr
PSAnX19JTlRFUlBfJyArIGkgKyAnX18nO1xuICAgIH1cbiAgICBzb3VyY2UgKz0gc3RyaW5nc1tp
ICsgMV07XG4gIH1cblxuICBjb25zdCB7IGJ5dGVzLCB0YWJsZSB9ID0gY29tcGlsZVNvdXJjZShz
b3VyY2UsIHZhbHVlcywgdXNlckltcG9ydHMpO1xuICBjb25zdCBpbnN0YW5jZSA9IGluc3RhbnRp
YXRlKGJ5dGVzLCB1c2VySW1wb3J0cywgdmFsdWVzKTtcbiAgcmV0dXJuIHdyYXBFeHBvcnRzKGlu
c3RhbmNlLCB0YWJsZSk7XG59XG5cbi8vIERpcmVjdCBjb21waWxlciBhY2Nlc3NcbmF0cmEuY29t
cGlsZSA9IGZ1bmN0aW9uKHNvdXJjZSkge1xuICByZXR1cm4gY29tcGlsZVNvdXJjZShzb3VyY2Us
IG51bGwsIG51bGwpLmJ5dGVzO1xufTtcblxuYXRyYS5wYXJzZSA9IGZ1bmN0aW9uKHNvdXJjZSkg
e1xuICBjb25zdCB0b2tlbnMgPSBsZXgoc291cmNlKTtcbiAgcmV0dXJuIHBhcnNlKHRva2Vucyk7
XG59O1xuXG5hdHJhLmR1bXAgPSBmdW5jdGlvbihzb3VyY2UpIHtcbiAgY29uc3QgeyBieXRlcyB9
ID0gY29tcGlsZVNvdXJjZShzb3VyY2UsIG51bGwsIG51bGwpO1xuICByZXR1cm4gQXJyYXkuZnJv
bShieXRlcykubWFwKGIgPT4gYi50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSkuam9pbign
ICcpO1xufTtcblxuYXRyYS5ydW4gPSBmdW5jdGlvbihzb3VyY2UsIHVzZXJJbXBvcnRzKSB7XG4g
IHVzZXJJbXBvcnRzID0gbm9ybWFsaXplTWVtb3J5SW1wb3J0KHVzZXJJbXBvcnRzKTtcbiAgY29u
c3QgeyBieXRlcywgdGFibGUgfSA9IGNvbXBpbGVTb3VyY2Uoc291cmNlLCBudWxsLCB1c2VySW1w
b3J0cyk7XG4gIGNvbnN0IGluc3RhbmNlID0gaW5zdGFudGlhdGUoYnl0ZXMsIHVzZXJJbXBvcnRz
LCBudWxsKTtcbiAgcmV0dXJuIHdyYXBFeHBvcnRzKGluc3RhbmNlLCB0YWJsZSk7XG59O1xuXG4v
LyDilIDilIAgU2VsZi1yZWdpc3RyYXRpb24g4pSA4pSAXG5cbmlmICh0eXBlb2Ygd2luZG93ICE9
PSAndW5kZWZpbmVkJykge1xuICBpZiAoIXdpbmRvdy5fdGFnZ2VkTGFuZ3VhZ2VzKSB3aW5kb3cu
X3RhZ2dlZExhbmd1YWdlcyA9IHt9O1xuICB3aW5kb3cuX3RhZ2dlZExhbmd1YWdlcy5hdHJhID0g
eyB0b2tlbml6ZTogdG9rZW5pemVBdHJhLCBjb21wbGV0aW9uczogYXRyYUNvbXBsZXRpb25zIH07
XG59XG5cbi8vIEF0dGFjaCBpbnRlcm5hbHMgZm9yIHRlc3RpbmcgLyBhZHZhbmNlZCB1c2VcbmF0
cmEuX2xleCA9IGxleDtcbmF0cmEuX3BhcnNlID0gcGFyc2U7XG5hdHJhLl90b2tlbml6ZSA9IHRv
a2VuaXplQXRyYTtcbiIsImNlbGxJZCI6bnVsbH19
AUDITABLE-MODULES-->
<!-- notebook settings: JSON {theme, fontSize, width, ...} -->
<!--AUDITABLE-SETTINGS
{"theme":"dark","fontSize":13,"width":"860"}
AUDITABLE-SETTINGS-->

<script>
// -- state.js --

// ═══════════════════════════════════════════════════
// AUDITABLE — reactive notebook runtime
// Geoscientific Chaos Union, 2025
// ═══════════════════════════════════════════════════

const $ = s => document.querySelector(s);
const $$ = s => [...document.querySelectorAll(s)];

// ── STATE ──
const S = {
  cells: [],        // { id, type, code, el, defines, uses, output, error }
  scope: {},        // shared variable scope
  cellId: 0,        // unique cell ID counter
  editTimer: null,  // debounce timer for autorun
  autorun: true,    // reactive mode flag
  selectedId: null, // currently selected cell
  pendingD: false,  // for "dd" double-tap delete
  pendingDTimer: null,
  clipboard: null,  // copied cell data
  trash: [],        // undo stack for deleted cells
  findActive: false,
  findQuery: '',
  findCase: false,
  findRegex: false,
  findMatches: [],   // { cellId, index, length }
  findCurrent: -1,
  initialized: false, // set after loadFromEmbed/init completes
};

const JS_KEYWORDS = new Set([
  'const','let','var','function','return','if','else','for','while','do',
  'switch','case','break','continue','new','this','class','extends','import',
  'export','default','from','of','in','typeof','instanceof','void','delete',
  'throw','try','catch','finally','async','await','yield','true','false',
  'null','undefined','NaN','Infinity'
]);

const JS_BUILTINS = new Set([
  'Math','Array','Object','String','Number','Float64Array','Float32Array',
  'Int32Array','Uint8Array','Map','Set','Promise','console','JSON',
  'ui','std','load','install','print',
  'workshop','notebook','md','html','css'
]);


// -- stdlib.js --

// ── STDLIB ──
// Bundled standard library for notebook work.
// Module-level — no per-cell state needed.

// ── Provider Registry ──

const _providers = { file: null, download: null };

function registerProvider(name, fn) {
  if (name in _providers) _providers[name] = fn;
}

// ── Data ──

function csv(text, opts = {}) {
  const sep = opts.separator || ',';
  const typed = !!opts.typed;
  const lines = [];
  let i = 0;
  const len = text.length;

  while (i < len) {
    const row = [];
    while (i < len) {
      if (text[i] === '"') {
        // quoted field
        i++;
        let field = '';
        while (i < len) {
          if (text[i] === '"') {
            if (text[i + 1] === '"') { field += '"'; i += 2; }
            else { i++; break; }
          } else { field += text[i]; i++; }
        }
        row.push(field);
        if (text[i] === sep) i++;
        else if (text[i] === '\r') { i++; if (text[i] === '\n') i++; break; }
        else if (text[i] === '\n') { i++; break; }
        else if (i >= len) break;
      } else {
        // unquoted field
        let field = '';
        while (i < len && text[i] !== sep && text[i] !== '\n' && text[i] !== '\r') {
          field += text[i]; i++;
        }
        row.push(field);
        if (text[i] === sep) i++;
        else if (text[i] === '\r') { i++; if (text[i] === '\n') i++; break; }
        else if (text[i] === '\n') { i++; break; }
        else break;
      }
    }
    if (row.length > 0 && !(row.length === 1 && row[0] === '')) lines.push(row);
  }

  if (lines.length < 2) return [];
  const headers = lines[0];
  const result = [];
  for (let r = 1; r < lines.length; r++) {
    const obj = {};
    for (let c = 0; c < headers.length; c++) {
      let val = lines[r][c] !== undefined ? lines[r][c] : '';
      if (typed) {
        const num = Number(val);
        if (val !== '' && !isNaN(num)) val = num;
        else if (val === 'true') val = true;
        else if (val === 'false') val = false;
        else if (val === '') val = null;
      }
      obj[headers[c]] = val;
    }
    result.push(obj);
  }
  return result;
}

async function fetchJSON(url) {
  const resp = await fetch(url);
  if (!resp.ok) throw new Error(`fetchJSON: ${resp.status} ${resp.statusText}`);
  return resp.json();
}

// ── Math / Stats ──

function _acc(arr, fn) {
  return fn ? arr.map(fn) : arr;
}

function sum(arr, fn) {
  const vals = _acc(arr, fn);
  let s = 0;
  for (let i = 0; i < vals.length; i++) s += vals[i];
  return s;
}

function mean(arr, fn) {
  if (!arr.length) return NaN;
  return sum(arr, fn) / arr.length;
}

function median(arr, fn) {
  const vals = _acc(arr, fn).slice().sort((a, b) => a - b);
  const n = vals.length;
  if (n === 0) return NaN;
  if (n % 2 === 1) return vals[(n - 1) / 2];
  return (vals[n / 2 - 1] + vals[n / 2]) / 2;
}

function extent(arr, fn) {
  const vals = _acc(arr, fn);
  let lo = Infinity, hi = -Infinity;
  for (let i = 0; i < vals.length; i++) {
    if (vals[i] < lo) lo = vals[i];
    if (vals[i] > hi) hi = vals[i];
  }
  return [lo, hi];
}

function bin(arr, n = 10, fn) {
  const vals = _acc(arr, fn);
  const [lo, hi] = extent(vals);
  const range = hi - lo || 1;
  const step = range / n;
  const bins = [];
  for (let i = 0; i < n; i++) {
    bins.push({ x0: lo + i * step, x1: lo + (i + 1) * step, values: [] });
  }
  for (const v of vals) {
    let idx = Math.floor((v - lo) / step);
    if (idx >= n) idx = n - 1;
    if (idx < 0) idx = 0;
    bins[idx].values.push(v);
  }
  return bins;
}

function linspace(start, stop, n) {
  if (n < 2) return n === 1 ? [start] : [];
  const result = new Array(n);
  const step = (stop - start) / (n - 1);
  for (let i = 0; i < n; i++) result[i] = start + i * step;
  result[n - 1] = stop; // exact endpoint
  return result;
}

// ── Array ──

function unique(arr, fn) {
  if (!fn) return [...new Set(arr)];
  const seen = new Set();
  const result = [];
  for (const item of arr) {
    const key = fn(item);
    if (!seen.has(key)) { seen.add(key); result.push(item); }
  }
  return result;
}

function zip(...arrays) {
  const len = Math.min(...arrays.map(a => a.length));
  const result = new Array(len);
  for (let i = 0; i < len; i++) {
    result[i] = arrays.map(a => a[i]);
  }
  return result;
}

function cross(...arrays) {
  if (arrays.length === 0) return [[]];
  const [first, ...rest] = arrays;
  const sub = cross(...rest);
  const result = [];
  for (const item of first) {
    for (const tail of sub) {
      result.push([item, ...tail]);
    }
  }
  return result;
}

// ── DOM / IO ──

async function file(accept) {
  if (_providers.file) return _providers.file(accept);
  return new Promise((resolve, reject) => {
    const input = document.createElement('input');
    input.type = 'file';
    if (accept) input.accept = accept;
    input.onchange = async () => {
      const f = input.files[0];
      if (!f) { reject(new Error('no file selected')); return; }
      const text = await f.text();
      resolve({ name: f.name, text, size: f.size });
    };
    input.click();
  });
}

function download(data, filename, mimeType) {
  if (_providers.download) return _providers.download(data, filename, mimeType);
  const str = typeof data === 'string' ? data : JSON.stringify(data, null, 2);
  const mime = mimeType || (typeof data === 'string' ? 'text/plain' : 'application/json');
  const blob = new Blob([str], { type: mime });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename || 'download';
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  setTimeout(() => URL.revokeObjectURL(url), 1000);
}

function el(tag, attrs, ...children) {
  const elem = document.createElement(tag);
  if (attrs && typeof attrs === 'object' && !(attrs instanceof Node)) {
    for (const [k, v] of Object.entries(attrs)) {
      if (k === 'style' && typeof v === 'object') {
        Object.assign(elem.style, v);
      } else if (k.startsWith('on') && typeof v === 'function') {
        elem.addEventListener(k.slice(2), v);
      } else {
        elem.setAttribute(k, v);
      }
    }
  } else if (attrs != null) {
    // attrs is actually a child
    children.unshift(attrs);
  }
  for (const child of children) {
    if (child instanceof Node) elem.appendChild(child);
    else if (child != null) elem.appendChild(document.createTextNode(String(child)));
  }
  return elem;
}

async function copy(text) {
  await navigator.clipboard.writeText(text);
}

function fmt(number, opts = {}) {
  const { decimals, prefix, suffix } = opts;
  let s = decimals != null ? number.toFixed(decimals)
    : new Intl.NumberFormat(undefined, { maximumFractionDigits: 6 }).format(number);
  if (prefix) s = prefix + s;
  if (suffix) s = s + suffix;
  return s;
}

// ── Export ──

const std = {
  csv, fetchJSON,
  sum, mean, median, extent, bin, linspace,
  unique, zip, cross,
  file, download, el, copy, fmt,
};

// -- python.js --

// ── @python COMPAT HELPERS ──
// Python-familiar functions for users transitioning from Python.
// Each has a .help property showing the idiomatic JS equivalent.

function range(a, b, step) {
  let start, stop, s;
  if (b === undefined) { start = 0; stop = a; s = 1; }
  else { start = a; stop = b; s = step || 1; }
  const result = [];
  if (s > 0) { for (let i = start; i < stop; i += s) result.push(i); }
  else if (s < 0) { for (let i = start; i > stop; i += s) result.push(i); }
  return result;
}
range.help = 'JS: Array.from({length: n}, (_, i) => start + i * step)';

function enumerate(arr) {
  return arr.map((v, i) => [i, v]);
}
enumerate.help = 'JS: arr.map((v, i) => [i, v]) or arr.entries()';

function len(x) {
  if (x == null) throw new TypeError('len() of unsized object');
  if (x.size !== undefined) return x.size;
  return x.length;
}
len.help = 'JS: x.length or x.size';

function sorted(arr, key, reverse) {
  const copy = [...arr];
  if (key) copy.sort((a, b) => {
    const ka = key(a), kb = key(b);
    return ka < kb ? -1 : ka > kb ? 1 : 0;
  });
  else copy.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
  if (reverse) copy.reverse();
  return copy;
}
sorted.help = 'JS: arr.toSorted((a, b) => ...)';

function reversed(arr) {
  return [...arr].reverse();
}
reversed.help = 'JS: arr.toReversed()';

function isinstance(obj, cls) {
  return obj instanceof cls;
}
isinstance.help = 'JS: obj instanceof cls';

function type(x) {
  if (x === null) return 'null';
  if (Array.isArray(x)) return 'array';
  return typeof x;
}
type.help = 'JS: typeof x';

const python = {
  range, enumerate, len, sorted, reversed,
  isinstance, type,
};

function zenOfPython() {
  return [
    'The Zen of Python, by Tim Peters',
    '',
    'Beautiful is better than ugly.',
    'Explicit is better than implicit.',
    'Simple is better than complex.',
    'Complex is better than complicated.',
    'Flat is better than nested.',
    'Sparse is better than dense.',
    'Readability counts.',
    "Special cases aren't special enough to break the rules.",
    'Although practicality beats purity.',
    'Errors should never pass silently.',
    'Unless explicitly silenced.',
    'In the face of ambiguity, refuse the temptation to guess.',
    'There should be one-- and preferably only one --obvious way to do it.',
    "Although that way may not be obvious at first unless you're Dutch.",
    'Now is better than never.',
    'Although never is often better than *right* now.',
    "If the implementation is hard to explain, it's a bad idea.",
    'If the implementation is easy to explain, it may be a good idea.',
    "Namespaces are one honking great idea -- let's do more of those!",
  ].join('\n');
}

// -- syntax.js --

// ── SYNTAX HIGHLIGHTING ──

const CSS_NAMED_COLORS = new Set([
  'black','silver','gray','white','maroon','red','purple','fuchsia',
  'green','lime','olive','yellow','navy','blue','teal','aqua','orange'
]);

// detect curried tagged template: scan back through tokens for lang({...})`
function detectCurriedTag(tokens) {
  // last non-whitespace token must be )
  let j = tokens.length - 1;
  while (j >= 0 && tokens[j].type === '') j--;
  if (j < 0 || tokens[j].text !== ')') return null;
  // scan back to matching (
  let depth = 1;
  j--;
  while (j >= 0 && depth > 0) {
    if (tokens[j].text === ')') depth++;
    else if (tokens[j].text === '(') depth--;
    j--;
  }
  // token before ( should be the language name
  while (j >= 0 && tokens[j].type === '') j--;
  if (j < 0) return null;
  const name = tokens[j].text;
  if (window._taggedLanguages && window._taggedLanguages[name]) {
    return window._taggedLanguages[name];
  }
  return null;
}

// tokenize a tagged template literal starting at the opening backtick
function tokenizeTaggedTemplate(code, i, len, lang, tokens) {
  tokens.push({ type: 'punc', text: '`' });
  i++; // skip opening backtick
  let strBuf = '';
  while (i < len && code[i] !== '`') {
    if (code[i] === '\\') {
      strBuf += code[i] + (i + 1 < len ? code[i + 1] : '');
      i += 2;
      continue;
    }
    if (code[i] === '$' && i + 1 < len && code[i + 1] === '{') {
      if (strBuf) {
        tokens.push(...lang.tokenize(strBuf));
        strBuf = '';
      }
      tokens.push({ type: 'punc', text: '${' });
      i += 2;
      let depth = 1;
      let exprStart = i;
      while (i < len && depth > 0) {
        if (code[i] === '{') depth++;
        else if (code[i] === '}') { depth--; if (depth === 0) break; }
        else if (code[i] === '`') {
          i++;
          while (i < len && code[i] !== '`') {
            if (code[i] === '\\') i++;
            i++;
          }
        } else if (code[i] === '"' || code[i] === "'") {
          const q = code[i]; i++;
          while (i < len && code[i] !== q) {
            if (code[i] === '\\') i++;
            i++;
          }
        }
        i++;
      }
      const expr = code.slice(exprStart, i);
      if (expr) tokens.push(...tokenize(expr));
      if (i < len && code[i] === '}') {
        tokens.push({ type: 'punc', text: '}' });
        i++;
      }
      continue;
    }
    strBuf += code[i];
    i++;
  }
  if (strBuf) tokens.push(...lang.tokenize(strBuf));
  if (i < len && code[i] === '`') {
    tokens.push({ type: 'punc', text: '`' });
    i++;
  }
  return i;
}

function tokenize(code) {
  const tokens = [];
  let i = 0;
  const len = code.length;

  while (i < len) {
    // line comment
    if (code[i] === '/' && code[i+1] === '/') {
      const start = i;
      while (i < len && code[i] !== '\n') i++;
      tokens.push({ type: 'cmt', text: code.slice(start, i) });
      continue;
    }
    // block comment
    if (code[i] === '/' && code[i+1] === '*') {
      const start = i;
      i += 2;
      while (i < len && !(code[i-1] === '*' && code[i] === '/')) i++;
      if (i < len) i++;
      tokens.push({ type: 'cmt', text: code.slice(start, i) });
      continue;
    }
    // strings
    if (code[i] === '"' || code[i] === "'" || code[i] === '`') {
      // curried tagged template: lang({...})`...` — detect before treating as plain string
      if (code[i] === '`' && typeof window !== 'undefined' && window._taggedLanguages) {
        const lang = detectCurriedTag(tokens);
        if (lang) {
          i = tokenizeTaggedTemplate(code, i, len, lang, tokens);
          continue;
        }
      }
      const q = code[i];
      const start = i;
      i++;
      while (i < len && code[i] !== q) {
        if (code[i] === '\\') i++;
        i++;
      }
      if (i < len) i++;
      tokens.push({ type: 'str', text: code.slice(start, i) });
      continue;
    }
    // numbers
    if (/\d/.test(code[i]) || (code[i] === '.' && i+1 < len && /\d/.test(code[i+1]))) {
      const start = i;
      if (code[i] === '0' && (code[i+1] === 'x' || code[i+1] === 'X')) {
        i += 2;
        while (i < len && /[0-9a-fA-F_]/.test(code[i])) i++;
      } else {
        while (i < len && /[0-9._eE+-]/.test(code[i])) i++;
      }
      tokens.push({ type: 'num', text: code.slice(start, i) });
      continue;
    }
    // identifiers / keywords
    if (/[a-zA-Z_$]/.test(code[i])) {
      const start = i;
      while (i < len && /\w/.test(code[i])) i++;
      const word = code.slice(start, i);

      // tagged template literal — delegate to registered language tokenizer
      if (i < len && code[i] === '`' && typeof window !== 'undefined'
          && window._taggedLanguages && window._taggedLanguages[word]) {
        tokens.push({ type: 'fn', text: word });
        i = tokenizeTaggedTemplate(code, i, len, window._taggedLanguages[word], tokens);
        continue;
      }

      if (JS_KEYWORDS.has(word)) {
        tokens.push({ type: 'kw', text: word });
      } else if (JS_BUILTINS.has(word)) {
        tokens.push({ type: 'const', text: word });
      } else if (i < len && code[i] === '(') {
        tokens.push({ type: 'fn', text: word });
      } else {
        tokens.push({ type: 'id', text: word });
      }
      continue;
    }
    // operators
    if ('=+-*/<>!&|^~%?:'.includes(code[i])) {
      tokens.push({ type: 'op', text: code[i] });
      i++;
      continue;
    }
    // punctuation
    if ('(){}[];,.'.includes(code[i])) {
      tokens.push({ type: 'punc', text: code[i] });
      i++;
      continue;
    }
    // whitespace / other — pass through
    tokens.push({ type: '', text: code[i] });
    i++;
  }

  return tokens;
}

function highlightCode(ta, hl) {
  const code = ta.value;
  if (!code) { hl.innerHTML = '\n'; return; }

  const tokens = tokenize(code);
  let html = '';
  for (const t of tokens) {
    const escaped = t.text
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;');
    if (t.type && t.type !== 'id') {
      html += `<span class="hl-${t.type}">${escaped}</span>`;
    } else {
      html += escaped;
    }
  }
  // trailing newline so highlight layer matches textarea height
  hl.innerHTML = html + '\n';
}

// ── CSS SYNTAX HIGHLIGHTING ──

function tokenizeCss(code) {
  const tokens = [];
  let i = 0;
  const len = code.length;
  let ctx = 'sel'; // 'sel' | 'prop' | 'val'
  let depth = 0;

  while (i < len) {
    // block comment
    if (code[i] === '/' && code[i+1] === '*') {
      const start = i;
      i += 2;
      while (i < len && !(code[i-1] === '*' && code[i] === '/')) i++;
      if (i < len) i++;
      tokens.push({ type: 'cmt', text: code.slice(start, i) });
      continue;
    }
    // strings
    if (code[i] === '"' || code[i] === "'") {
      const q = code[i];
      const start = i;
      i++;
      while (i < len && code[i] !== q) {
        if (code[i] === '\\') i++;
        i++;
      }
      if (i < len) i++;
      tokens.push({ type: 'str', text: code.slice(start, i) });
      continue;
    }
    // punctuation with context transitions
    if (code[i] === '{') {
      tokens.push({ type: 'punc', text: '{' });
      depth++;
      ctx = 'prop';
      i++;
      continue;
    }
    if (code[i] === '}') {
      tokens.push({ type: 'punc', text: '}' });
      depth--;
      ctx = depth > 0 ? 'prop' : 'sel';
      i++;
      continue;
    }
    if (code[i] === ':' && ctx === 'prop') {
      tokens.push({ type: 'punc', text: ':' });
      ctx = 'val';
      i++;
      continue;
    }
    if (code[i] === ';') {
      tokens.push({ type: 'punc', text: ';' });
      ctx = 'prop';
      i++;
      continue;
    }
    if ('(),'.includes(code[i])) {
      tokens.push({ type: 'punc', text: code[i] });
      i++;
      continue;
    }
    // @-rules
    if (code[i] === '@') {
      const start = i;
      i++;
      while (i < len && /[a-zA-Z-]/.test(code[i])) i++;
      tokens.push({ type: 'atrule', text: code.slice(start, i) });
      continue;
    }
    // !important
    if (code[i] === '!' && ctx === 'val') {
      const start = i;
      i++;
      while (i < len && /[a-zA-Z]/.test(code[i])) i++;
      tokens.push({ type: 'important', text: code.slice(start, i) });
      continue;
    }
    // # — hex color in val, ID selector in sel
    if (code[i] === '#') {
      if (ctx === 'val') {
        const start = i;
        i++;
        while (i < len && /[0-9a-fA-F]/.test(code[i])) i++;
        tokens.push({ type: 'color', text: code.slice(start, i) });
      } else {
        // ID selector
        const start = i;
        i++;
        while (i < len && /[\w-]/.test(code[i])) i++;
        tokens.push({ type: 'sel', text: code.slice(start, i) });
      }
      continue;
    }
    // : in selector context = pseudo-class
    if (code[i] === ':' && ctx === 'sel') {
      const start = i;
      i++;
      if (i < len && code[i] === ':') i++; // ::
      while (i < len && /[a-zA-Z-]/.test(code[i])) i++;
      // handle pseudo with parens like :nth-child(...)
      if (i < len && code[i] === '(') {
        i++;
        let pdepth = 1;
        while (i < len && pdepth > 0) {
          if (code[i] === '(') pdepth++;
          else if (code[i] === ')') pdepth--;
          if (pdepth > 0) i++;
        }
        if (i < len) i++;
      }
      tokens.push({ type: 'sel', text: code.slice(start, i) });
      continue;
    }
    // . in selector context = class selector
    if (code[i] === '.' && ctx === 'sel') {
      const start = i;
      i++;
      while (i < len && /[\w-]/.test(code[i])) i++;
      tokens.push({ type: 'sel', text: code.slice(start, i) });
      continue;
    }
    // numbers (with units)
    if (ctx === 'val' && (/\d/.test(code[i]) || (code[i] === '.' && i+1 < len && /\d/.test(code[i+1])))) {
      const start = i;
      while (i < len && /[0-9.]/.test(code[i])) i++;
      // units
      while (i < len && /[a-zA-Z%]/.test(code[i])) i++;
      tokens.push({ type: 'num', text: code.slice(start, i) });
      continue;
    }
    // identifiers
    if (/[a-zA-Z_-]/.test(code[i])) {
      const start = i;
      while (i < len && /[\w-]/.test(code[i])) i++;
      const word = code.slice(start, i);
      // function call
      if (i < len && code[i] === '(') {
        tokens.push({ type: 'fn', text: word });
        continue;
      }
      if (ctx === 'val' && CSS_NAMED_COLORS.has(word.toLowerCase())) {
        tokens.push({ type: 'color', text: word });
      } else if (ctx === 'prop') {
        tokens.push({ type: 'prop', text: word });
      } else if (ctx === 'sel') {
        tokens.push({ type: 'sel', text: word });
      } else {
        tokens.push({ type: '', text: word });
      }
      continue;
    }
    // whitespace / other
    tokens.push({ type: '', text: code[i] });
    i++;
  }

  return tokens;
}

function resolveToHex(colorStr) {
  const d = document.createElement('div');
  d.style.color = colorStr;
  document.body.appendChild(d);
  const rgb = getComputedStyle(d).color;
  d.remove();
  const m = rgb.match(/(\d+)/g);
  if (!m || m.length < 3) return colorStr;
  return '#' + m.slice(0, 3).map(n => parseInt(n).toString(16).padStart(2, '0')).join('');
}

let _colorPicker = null;
let _pickerTarget = null; // { ta, offset, len }

function ensureColorPicker() {
  if (_colorPicker) return _colorPicker;
  _colorPicker = document.createElement('input');
  _colorPicker.type = 'color';
  _colorPicker.style.cssText = 'position:absolute;visibility:hidden;width:0;height:0;';
  document.body.appendChild(_colorPicker);
  _colorPicker.addEventListener('input', () => {
    if (!_pickerTarget) return;
    const { ta, offset, len } = _pickerTarget;
    const newColor = _colorPicker.value;
    ta.focus();
    ta.selectionStart = offset;
    ta.selectionEnd = offset + len;
    document.execCommand('insertText', false, newColor);
    ta.dispatchEvent(new Event('input'));
    // update offset for new length
    _pickerTarget.len = newColor.length;
  });
  return _colorPicker;
}

function highlightCss(ta, hl) {
  const code = ta.value;
  if (!code) { hl.innerHTML = '\n'; return; }

  const tokens = tokenizeCss(code);
  let html = '';
  let offset = 0;
  for (const t of tokens) {
    const escaped = t.text
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;');
    if (t.type === 'color') {
      const hex = resolveToHex(t.text);
      html += `<span class="hl-color"><span class="hl-swatch" style="background:${hex}" data-offset="${offset}" data-len="${t.text.length}"></span>${escaped}</span>`;
    } else if (t.type && t.type !== 'id') {
      html += `<span class="hl-${t.type}">${escaped}</span>`;
    } else {
      html += escaped;
    }
    offset += t.text.length;
  }
  hl.innerHTML = html + '\n';

  // wire swatch clicks (only add once per highlight layer)
  if (!hl._swatchWired) {
    hl._swatchWired = true;
    hl.addEventListener('click', (e) => {
      const swatch = e.target.closest('.hl-swatch');
      if (!swatch) return;
      const off = parseInt(swatch.dataset.offset);
      const len = parseInt(swatch.dataset.len);
      const picker = ensureColorPicker();
      _pickerTarget = { ta, offset: off, len };
      const hex = resolveToHex(ta.value.slice(off, off + len));
      picker.value = hex;
      picker.click();
    });
  }
}

// ── HTML SYNTAX HIGHLIGHTING ──

function tokenizeHtml(code) {
  const tokens = [];
  let i = 0;
  const len = code.length;

  while (i < len) {
    // template expression ${...}
    if (code[i] === '$' && i + 1 < len && code[i + 1] === '{') {
      const start = i;
      i += 2;
      let depth = 1;
      while (i < len && depth > 0) {
        if (code[i] === '{') depth++;
        else if (code[i] === '}') depth--;
        if (depth > 0) i++;
      }
      if (i < len) i++;
      tokens.push({ type: 'expr', text: code.slice(start, i) });
      continue;
    }
    // comment <!-- ... -->
    if (code[i] === '<' && code[i + 1] === '!' && code[i + 2] === '-' && code[i + 3] === '-') {
      const start = i;
      i += 4;
      while (i < len) {
        if (code[i] === '-' && code[i + 1] === '-' && code[i + 2] === '>') { i += 3; break; }
        i++;
      }
      tokens.push({ type: 'cmt', text: code.slice(start, i) });
      continue;
    }
    // tag
    if (code[i] === '<') {
      tokens.push({ type: 'tag', text: '<' });
      i++;
      // closing slash
      if (i < len && code[i] === '/') { tokens.push({ type: 'tag', text: '/' }); i++; }
      // tag name
      const ns = i;
      while (i < len && /[a-zA-Z0-9-]/.test(code[i])) i++;
      if (i > ns) tokens.push({ type: 'tag', text: code.slice(ns, i) });
      // attributes until >
      while (i < len && code[i] !== '>') {
        // template expression inside tag
        if (code[i] === '$' && i + 1 < len && code[i + 1] === '{') {
          const start = i;
          i += 2;
          let depth = 1;
          while (i < len && depth > 0) {
            if (code[i] === '{') depth++;
            else if (code[i] === '}') depth--;
            if (depth > 0) i++;
          }
          if (i < len) i++;
          tokens.push({ type: 'expr', text: code.slice(start, i) });
          continue;
        }
        if (/\s/.test(code[i])) { tokens.push({ type: '', text: code[i] }); i++; continue; }
        if (code[i] === '/') { tokens.push({ type: 'tag', text: '/' }); i++; continue; }
        if (code[i] === '=') { tokens.push({ type: 'punc', text: '=' }); i++; continue; }
        // quoted attribute value
        if (code[i] === '"' || code[i] === "'") {
          const q = code[i];
          const start = i;
          i++;
          while (i < len && code[i] !== q) { if (code[i] === '\\') i++; i++; }
          if (i < len) i++;
          tokens.push({ type: 'str', text: code.slice(start, i) });
          continue;
        }
        // attribute name or unquoted value
        const as = i;
        while (i < len && !/[\s=>/"']/.test(code[i])) i++;
        if (i > as) {
          let j = i;
          while (j < len && /\s/.test(code[j])) j++;
          tokens.push({ type: (j < len && code[j] === '=') ? 'attr' : 'attr', text: code.slice(as, i) });
        }
      }
      if (i < len && code[i] === '>') { tokens.push({ type: 'tag', text: '>' }); i++; }
      continue;
    }
    // plain text
    tokens.push({ type: '', text: code[i] });
    i++;
  }

  return tokens;
}

function highlightHtml(ta, hl) {
  const code = ta.value;
  if (!code) { hl.innerHTML = '\n'; return; }

  const tokens = tokenizeHtml(code);
  let html = '';
  for (const t of tokens) {
    const escaped = t.text
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;');
    if (t.type) {
      html += `<span class="hl-${t.type}">${escaped}</span>`;
    } else {
      html += escaped;
    }
  }
  hl.innerHTML = html + '\n';
}

// -- dag.js --

// ── REACTIVE DAG ──

// ── directive helpers ──

function hasDirective(code, name) {
  return new RegExp(String.raw`^\s*\/\/\s*%${name}\b`, 'm').test(code);
}

function getDirective(code, name) {
  const m = code.match(new RegExp(String.raw`^\s*\/\/\s*%${name}\s+(.+)`, 'm'));
  return m ? m[1].trim() : null;
}

const isManual    = code => hasDirective(code, 'manual');
const isHidden    = code => hasDirective(code, 'hide');
const isNorun     = code => hasDirective(code, 'norun');
const isCollapsed = code => hasDirective(code, 'collapsed');
const parseCellName    = code => getDirective(code, 'cellName');
const parseOutputId    = code => { const v = getDirective(code, 'outputId'); return v ? v.split(/\s+/)[0] : null; };
const parseOutputClass = code => getDirective(code, 'outputClass');

// ── code analysis ──

function stripCommentsAndStrings(code) {
  // single-pass: strings take precedence over comments (// inside "..." is not a comment)
  let out = '', i = 0;
  while (i < code.length) {
    // single-quoted string
    if (code[i] === "'") {
      out += '""';
      i++;
      while (i < code.length && code[i] !== "'") { if (code[i] === '\\') i++; i++; }
      i++; // skip closing quote
      continue;
    }
    // double-quoted string
    if (code[i] === '"') {
      out += '""';
      i++;
      while (i < code.length && code[i] !== '"') { if (code[i] === '\\') i++; i++; }
      i++; // skip closing quote
      continue;
    }
    // template literal: replace string parts with spaces but keep ${expr} content
    if (code[i] === '`') {
      i++;
      while (i < code.length && code[i] !== '`') {
        if (code[i] === '\\') { i += 2; continue; }
        if (code[i] === '$' && code[i + 1] === '{') {
          i += 2;
          let depth = 1;
          out += ' ';
          while (i < code.length && depth > 0) {
            if (code[i] === '{') depth++;
            else if (code[i] === '}') { depth--; if (depth === 0) break; }
            out += code[i];
            i++;
          }
          out += ' ';
          i++; // skip closing }
          continue;
        }
        i++;
      }
      i++; // skip closing backtick
      continue;
    }
    // line comment
    if (code[i] === '/' && code[i + 1] === '/') {
      while (i < code.length && code[i] !== '\n') i++;
      continue;
    }
    // block comment
    if (code[i] === '/' && code[i + 1] === '*') {
      i += 2;
      while (i < code.length && !(code[i - 1] === '*' && code[i] === '/')) i++;
      i++;
      continue;
    }
    out += code[i];
    i++;
  }
  return out;
}

function parseNames(code) {
  // extract ONLY top-level variable definitions (brace depth 0)
  const defines = new Set();

  const stripped = stripCommentsAndStrings(code);

  let depth = 0;
  let parenDepth = 0;
  let i = 0;
  while (i < stripped.length) {
    const ch = stripped[i];
    if (ch === '{') { depth++; i++; continue; }
    if (ch === '}') { depth--; i++; continue; }
    if (ch === '(') { parenDepth++; i++; continue; }
    if (ch === ')') { parenDepth--; i++; continue; }

    if (depth === 0 && parenDepth === 0) {
      // check for const/let/var
      const rest = stripped.slice(i);
      const dm = rest.match(/^(?:const|let|var)\s+(\w+)/);
      if (dm) {
        defines.add(dm[1]);
        // scan forward for comma-separated declarations: const W = 80, H = 60
        // skip initializer expressions tracking depth, grab identifiers after commas
        let j = dm[0].length;
        let d = 0, pd = 0, bd = 0;
        while (j < rest.length) {
          const ch = rest[j];
          if (ch === '{') d++;
          else if (ch === '}') d--;
          else if (ch === '(') pd++;
          else if (ch === ')') pd--;
          else if (ch === '[') bd++;
          else if (ch === ']') bd--;
          else if (ch === ';' || ch === '\n') {
            if (d === 0 && pd === 0 && bd === 0) break;
          }
          else if (ch === ',' && d === 0 && pd === 0 && bd === 0) {
            // next identifier after comma
            const after = rest.slice(j + 1).match(/^\s*(\w+)/);
            if (after) defines.add(after[1]);
          }
          j++;
        }
        i += j;
        continue;
      }
      // destructuring: const { a, b } = ... or const [ a, b ] = ...
      const destruct = rest.match(/^(?:const|let|var)\s*[\{\[]/);
      if (destruct) {
        // find the closing } or ] then extract identifiers
        const opener = rest[destruct[0].length - 1];
        const closer = opener === '{' ? '}' : ']';
        const closeIdx = rest.indexOf(closer, destruct[0].length);
        if (closeIdx > 0) {
          const inner = rest.slice(destruct[0].length, closeIdx);
          // split on commas, take last word of each part (handles renaming)
          inner.split(',').forEach(part => {
            const parts = part.trim().split(/\s*:\s*/);
            const name = (parts.length > 1 ? parts[1] : parts[0]).trim().match(/^\w+/);
            if (name) defines.add(name[0]);
          });
          i += closeIdx + 1;
          continue;
        }
      }
      // check for function declarations
      const fm = rest.match(/^function\s+(\w+)/);
      if (fm) {
        defines.add(fm[1]);
        i += fm[0].length;
        continue;
      }
    }
    i++;
  }

  return { defines };
}

function findUses(code, allDefined, selfDefined) {
  // find identifiers that reference other cells' definitions
  const uses = new Set();
  const stripped = stripCommentsAndStrings(code);
  if (!selfDefined) selfDefined = parseNames(code).defines;

  const idRe = /\b([a-zA-Z_$]\w*)\b/g;
  let m;
  while ((m = idRe.exec(stripped))) {
    if (allDefined.has(m[1]) && !selfDefined.has(m[1])) {
      uses.add(m[1]);
    }
  }
  return uses;
}

function findHtmlUses(code, allDefined) {
  const uses = new Set();
  const re = /\$\{([^}]+)\}/g;
  let m;
  while ((m = re.exec(code))) {
    const expr = m[1];
    const idRe = /\b([a-zA-Z_$]\w*)\b/g;
    let im;
    while ((im = idRe.exec(expr))) {
      if (allDefined.has(im[1])) uses.add(im[1]);
    }
  }
  return uses;
}

function buildDAG() {
  // collect all defined names globally (only re-parse changed cells)
  const allDefined = new Map(); // name -> cell id
  for (const c of S.cells) {
    if (c.type !== 'code') continue;
    if (c.code !== c._parsedCode) {
      const { defines } = parseNames(c.code);
      c.defines = defines;
      c._parsedCode = c.code;
    }
    for (const name of c.defines) {
      allDefined.set(name, c.id);
    }
  }

  // find uses for each cell (invalidate if code changed or global names changed)
  const definedNames = new Set(allDefined.keys());
  const definedKey = [...definedNames].sort().join(',');
  for (const c of S.cells) {
    if (c.type === 'code') {
      if (c.code !== c._usesCode || c._definedKey !== definedKey) {
        c.uses = findUses(c.code, definedNames, c.defines);
        c._usesCode = c.code;
        c._definedKey = definedKey;
      }
    } else if (c.type === 'html') {
      if (c.code !== c._usesCode || c._definedKey !== definedKey) {
        c.uses = findHtmlUses(c.code, definedNames);
        c._usesCode = c.code;
        c._definedKey = definedKey;
      }
    }
  }

  return allDefined;
}

function topoSort(dirtyIds) {
  // BFS from dirty cells to find all downstream dependents
  const dependents = new Map(); // varName -> Set<cellId>
  for (const c of S.cells) {
    if (!c.uses) continue;
    for (const name of c.uses) {
      if (!dependents.has(name)) dependents.set(name, new Set());
      dependents.get(name).add(c.id);
    }
  }

  const needsRun = new Set(dirtyIds);
  const queue = [...dirtyIds];
  while (queue.length) {
    const id = queue.shift();
    const cell = S.cells.find(c => c.id === id);
    if (!cell || !cell.defines) continue;
    for (const name of cell.defines) {
      const deps = dependents.get(name);
      if (!deps) continue;
      for (const depId of deps) {
        if (!needsRun.has(depId)) {
          needsRun.add(depId);
          queue.push(depId);
        }
      }
    }
  }

  // return in document order
  return S.cells.filter(c => needsRun.has(c.id)).map(c => c.id);
}

// -- exec.js --

// ── EXECUTION ENGINE ──
//
// Scope model: each cell runs inside an AsyncFunction where upstream variables
// are passed as parameters. This is pass-by-value for primitives — reassigning
// a variable in cell A (e.g. `grid = next`) does NOT propagate to cell B.
// Mutable state that needs to survive across callbacks belongs in %manual cells
// using DOM elements, objects, or closures.
//
// Cell builtins (display, canvas, slider, load, install, installBinary, etc.)
// are injected as additional parameters — listed in _injected, not in scope.
// They are NOT propagated to downstream cells.

// ── BINARY HELPERS ──

function uint8ToBase64(bytes) {
  let bin = '';
  for (let i = 0; i < bytes.length; i++) bin += String.fromCharCode(bytes[i]);
  return btoa(bin);
}

async function decodeBinary(entry) {
  const type = entry.type || 'application/octet-stream';
  const bytes = Uint8Array.from(atob(entry.source), c => c.charCodeAt(0));
  if (entry.compressed) {
    const ds = new DecompressionStream('gzip');
    const stream = new Blob([bytes]).stream().pipeThrough(ds);
    const decompressed = new Uint8Array(await new Response(stream).arrayBuffer());
    return URL.createObjectURL(new Blob([decompressed], { type }));
  }
  return URL.createObjectURL(new Blob([bytes], { type }));
}

// ── TAGGED CONTENT ──

class TaggedContent {
  constructor(type, content) { this.type = type; this.content = content; }
  toString() { return this.content; }
}

function taggedTemplate(type) {
  return (strings, ...values) => {
    let result = strings[0];
    for (let i = 0; i < values.length; i++) result += String(values[i]) + strings[i + 1];
    return new TaggedContent(type, result);
  };
}

// ── EXECUTION ──

function renderHtmlCell(cell) {
  const viewEl = cell.el.querySelector('.cell-html-view');
  const outputEl = cell.el.querySelector('.cell-output');
  if (!viewEl) return;
  if (outputEl) { outputEl.textContent = ''; outputEl.className = 'cell-output'; }

  // use only variables this cell references for stable function signatures
  const scopeKeys = cell.uses ? [...cell.uses].sort() : [];
  const scopeVals = scopeKeys.map(k => S.scope[k]);

  // cache compiled template functions per expression
  if (!cell._tplCache) cell._tplCache = {};
  const scopeSig = scopeKeys.join(',');
  if (cell._tplScopeSig !== scopeSig) {
    cell._tplCache = {};  // scope signature changed, invalidate all
    cell._tplScopeSig = scopeSig;
  }

  let rendered = cell.code.replace(/\$\{([^}]+)\}/g, (match, expr) => {
    try {
      let fn = cell._tplCache[expr];
      if (!fn) {
        fn = new Function(...scopeKeys, '"use strict"; return (' + expr + ')');
        cell._tplCache[expr] = fn;
      }
      const val = fn(...scopeVals);
      return val === undefined ? '' : String(val);
    } catch (e) {
      return '[Error: ' + e.message + ']';
    }
  });

  viewEl.innerHTML = rendered;
  cell.el.classList.remove('stale', 'error');
  cell.el.classList.add('fresh');
  setTimeout(() => cell.el.classList.remove('fresh'), 800);
}

async function execCell(cell) {
  // fire invalidation promise from previous run (cleanup resources)
  if (cell._invalidate) { cell._invalidate(); cell._invalidate = null; }

  const outputEl = cell.el.querySelector('.cell-output');
  const widgetEl = cell.el.querySelector('.cell-widgets');

  // preserve canvases before clearing output
  const prevCanvases = [...outputEl.querySelectorAll('canvas')];
  outputEl.textContent = '';
  outputEl.className = 'cell-output';
  const outClass = parseOutputClass(cell.code);
  if (outClass) outputEl.classList.add(...outClass.split(/\s+/));
  const outId = parseOutputId(cell.code);
  outputEl.id = outId || '';
  cell.el.classList.toggle('present-hidden', isHidden(cell.code));
  cell.error = null;

  // create invalidation promise for this run
  let invalidationResolve;
  const invalidation = new Promise(r => { invalidationResolve = r; });
  cell._invalidate = invalidationResolve;

  // track which widgets are used this run
  const usedWidgets = new Set();
  let canvasIdx = 0;

  // build display function for this cell
  const display = (...args) => {
    for (const arg of args) {
      if (arg instanceof Element) {
        outputEl.appendChild(arg);
      } else if (typeof arg === 'object' && arg !== null) {
        const pre = document.createElement('span');
        try { pre.textContent = JSON.stringify(arg, null, 2); }
        catch { pre.textContent = String(arg); }
        outputEl.appendChild(pre);
        outputEl.appendChild(document.createTextNode('\n'));
      } else {
        outputEl.appendChild(document.createTextNode(String(arg) + '\n'));
      }
    }
  };

  // canvas helper — reuses existing canvas if dimensions match
  const canvas = (w = 400, h = 300) => {
    const prev = prevCanvases[canvasIdx++];
    if (prev && prev.width === w && prev.height === h) {
      outputEl.appendChild(prev);
      return prev;
    }
    const c = document.createElement('canvas');
    c.width = w; c.height = h;
    c.style.background = '#000';
    outputEl.appendChild(c);
    return c;
  };

  // table helper
  const table = (data, columns) => {
    if (!data || !data.length) return;
    const cols = columns || Object.keys(data[0]);

    // detect numeric columns by scanning first 10 rows
    const isNumCol = {};
    for (const c of cols) {
      let allNum = true;
      const scanRows = data.slice(0, 10);
      for (const row of scanRows) {
        const v = row[c];
        if (v !== null && v !== undefined && typeof v !== 'number') { allNum = false; break; }
      }
      isNumCol[c] = allNum;
    }

    const t = document.createElement('table');
    const thead = document.createElement('thead');
    const hr = document.createElement('tr');
    for (const c of cols) {
      const th = document.createElement('th');
      th.textContent = c;
      th.style.textAlign = isNumCol[c] ? 'right' : 'left';
      hr.appendChild(th);
    }
    thead.appendChild(hr);
    t.appendChild(thead);
    const tbody = document.createElement('tbody');
    for (const row of data) {
      const tr = document.createElement('tr');
      for (const c of cols) {
        const td = document.createElement('td');
        const v = row[c];
        td.textContent = typeof v === 'number' ? (Number.isInteger(v) ? v : v.toFixed(4)) : String(v ?? '');
        td.style.textAlign = isNumCol[c] ? 'right' : 'left';
        tr.appendChild(td);
      }
      tbody.appendChild(tr);
    }
    t.appendChild(tbody);
    outputEl.appendChild(t);
  };

  // input widget helpers — persist state and DOM across re-runs
  if (!cell._inputs) cell._inputs = {};
  if (!cell._callbacks) cell._callbacks = {};

  const mkInput = (label, type, defaultVal, opts = {}) => {
    const key = label;
    const prev = cell._inputs[key];
    let val = prev !== undefined ? prev : defaultVal;
    usedWidgets.add(key);
    cell._callbacks[key] = { onInput: opts.onInput, onChange: opts.onChange };

    // check if widget DOM already exists
    const existing = widgetEl.querySelector(`[data-widget-key="${CSS.escape(key)}"]`);
    if (existing) {
      // update id/class in case they changed on re-run
      existing.id = opts.id || '';
      existing.className = 'cell-widget' + (opts.class ? ' ' + opts.class : '');
      // just return current value, DOM stays — callbacks already updated above
      cell._inputs[key] = type === 'slider' ? parseFloat(val)
                         : type === 'checkbox' ? !!val
                         : val;
      return cell._inputs[key];
    }

    // create new widget
    const wrap = document.createElement('div');
    wrap.dataset.widgetKey = key;
    wrap.className = 'cell-widget' + (opts.class ? ' ' + opts.class : '');
    if (opts.id) wrap.id = opts.id;

    const lbl = document.createElement('span');
    lbl.textContent = label;
    lbl.className = 'cell-widget-label';
    wrap.appendChild(lbl);

    let input;
    if (type === 'slider') {
      input = document.createElement('input');
      input.type = 'range';
      input.min = opts.min ?? 0;
      input.max = opts.max ?? 100;
      input.step = opts.step ?? 1;
      input.value = val;
      const valSpan = document.createElement('span');
      valSpan.textContent = val;
      valSpan.className = 'cell-widget-val';
      input.oninput = () => {
        const n = parseFloat(input.value);
        cell._inputs[key] = n;
        valSpan.textContent = n;
        const cb = cell._callbacks[key];
        if (cb.onInput) { cb.onInput(n); }
        else if (!cb.onChange) { clearTimeout(cell._inputTimer); cell._inputTimer = setTimeout(() => runDAG([cell.id], true), 80); }
      };
      input.onchange = () => { const cb = cell._callbacks[key]; if (cb.onChange) cb.onChange(parseFloat(input.value)); };
      wrap.appendChild(input);
      wrap.appendChild(valSpan);
    } else if (type === 'dropdown') {
      input = document.createElement('select');
      for (const o of (opts.options || [])) {
        const opt = document.createElement('option');
        opt.value = o;
        opt.textContent = o;
        if (o === val) opt.selected = true;
        input.appendChild(opt);
      }
      input.onchange = () => {
        cell._inputs[key] = input.value;
        const cb = cell._callbacks[key];
        if (cb.onInput || cb.onChange) {
          if (cb.onInput) cb.onInput(input.value);
          if (cb.onChange) cb.onChange(input.value);
        } else { runDAG([cell.id], true); }
      };
      wrap.appendChild(input);
    } else if (type === 'checkbox') {
      input = document.createElement('input');
      input.type = 'checkbox';
      input.checked = !!val;
      input.onchange = () => {
        cell._inputs[key] = input.checked;
        const cb = cell._callbacks[key];
        if (cb.onInput || cb.onChange) {
          if (cb.onInput) cb.onInput(input.checked);
          if (cb.onChange) cb.onChange(input.checked);
        } else { runDAG([cell.id], true); }
      };
      wrap.appendChild(input);
    } else if (type === 'text') {
      input = document.createElement('input');
      input.type = 'text';
      input.value = val;
      input.oninput = () => {
        cell._inputs[key] = input.value;
        const cb = cell._callbacks[key];
        if (cb.onInput) { cb.onInput(input.value); }
        else if (!cb.onChange) { clearTimeout(cell._inputTimer); cell._inputTimer = setTimeout(() => runDAG([cell.id], true), 300); }
      };
      input.onchange = () => { const cb = cell._callbacks[key]; if (cb.onChange) cb.onChange(input.value); };
      wrap.appendChild(input);
    }

    widgetEl.appendChild(wrap);
    cell._inputs[key] = type === 'slider' ? parseFloat(val)
                       : type === 'checkbox' ? !!val
                       : val;
    return cell._inputs[key];
  };

  const slider = (label, defaultVal = 50, opts = {}) => mkInput(label, 'slider', defaultVal, opts);
  const dropdown = (label, options, defaultVal, opts = {}) => mkInput(label, 'dropdown', defaultVal || options[0], { ...opts, options });
  const checkbox = (label, defaultVal = false, opts = {}) => mkInput(label, 'checkbox', defaultVal, opts);
  const textInput = (label, defaultVal = '', opts = {}) => mkInput(label, 'text', defaultVal, opts);

  // execute with scoped parameters (only what this cell uses, for stable V8 JIT)
  // filter out injected names — they're per-cell params, not scope-propagated
  const _injected = ['ui', 'std', 'load', 'install', 'installBinary', 'invalidation', 'print', 'md', 'html', 'css', 'workshop', 'notebook'];
  const scopeKeys = cell.uses ? [...cell.uses].filter(k => !_injected.includes(k)).sort() : [];
  const defNames = cell.defines ? [...cell.defines].sort().join(', ') : '';

  // import cache — shared across all cells
  if (!window._importCache) window._importCache = {};
  if (!window._installedModules) window._installedModules = {}; // url -> { source, cellId }

  const load = async (url) => {
    // virtual modules
    if (url === '@std') return std;
    if (url === '@python') return python;
    if (url === '@python/this') { display(zenOfPython()); return python; }
    if (window._importCache[url]) return window._importCache[url];

    // binary assets — return blob URL
    if (window._installedModules[url]?.binary) {
      const blobUrl = await decodeBinary(window._installedModules[url]);
      window._importCache[url] = blobUrl;
      return blobUrl;
    }

    const langsBefore = window._taggedLanguages ? Object.keys(window._taggedLanguages).length : 0;

    let mod;
    // check installed (offline) modules first
    if (window._installedModules[url]) {
      const entry = window._installedModules[url];
      let src = typeof entry === 'string' ? entry : entry.source;
      // resolve root-relative paths for legacy saved modules
      try { src = resolveModulePaths(src, url); } catch {}
      const blob = new Blob([src], { type: 'application/javascript' });
      const blobUrl = URL.createObjectURL(blob);
      mod = await import(blobUrl);
    } else {
      mod = await import(url);
    }
    window._importCache[url] = mod;

    // if the module registered new tagged languages, re-highlight all code cells
    const langsAfter = window._taggedLanguages ? Object.keys(window._taggedLanguages).length : 0;
    if (langsAfter > langsBefore) {
      for (const c of S.cells) {
        if (c.type !== 'code') continue;
        const ta = c.el.querySelector('textarea');
        const hl = c.el.querySelector('.highlight-layer');
        if (ta && hl) highlightCode(ta, hl);
      }
    }

    return mod;
  };

  // resolve root-relative paths in module source so blob URLs work
  const resolveModulePaths = (source, responseUrl) => {
    const origin = new URL(responseUrl).origin;
    return source.replace(/(from\s+["'])(\/[^"']+)(["'])/g, '$1' + origin + '$2$3')
                 .replace(/(import\s*\(["'])(\/[^"']+)(["']\))/g, '$1' + origin + '$2$3')
                 .replace(/(export\s+\*\s+from\s+["'])(\/[^"']+)(["'])/g, '$1' + origin + '$2$3')
                 .replace(/(export\s*\{[^}]*\}\s*from\s+["'])(\/[^"']+)(["'])/g, '$1' + origin + '$2$3');
  };

  const install = async (url) => {
    // normalize: add ?bundle for esm.sh if not present
    let bundleUrl = url;
    if (bundleUrl.includes('esm.sh') && !bundleUrl.includes('?bundle') && !bundleUrl.includes('&bundle')) {
      bundleUrl += (bundleUrl.includes('?') ? '&' : '?') + 'bundle';
    }
    // fetch source
    const resp = await fetch(bundleUrl);
    if (!resp.ok) throw new Error(`Failed to fetch ${bundleUrl}: ${resp.status}`);
    let source = await resp.text();
    // resolve root-relative paths to absolute so blob URLs work
    source = resolveModulePaths(source, resp.url);
    // store under original url with cell reference
    window._installedModules[url] = { source, cellId: cell.id };
    // also load it into cache
    const blob = new Blob([source], { type: 'application/javascript' });
    const blobUrl = URL.createObjectURL(blob);
    const mod = await import(blobUrl);
    window._importCache[url] = mod;
    display(`installed ${url} (${(source.length / 1024).toFixed(1)} KB)`);
    return mod;
  };

  const installBinary = async (url, opts = {}) => {
    const compress = opts.compress !== false;
    // if already installed, decode and return blob URL
    if (window._installedModules[url]?.binary) {
      return decodeBinary(window._installedModules[url]);
    }
    const resp = await fetch(url);
    if (!resp.ok) throw new Error(`Failed to fetch ${url}: ${resp.status}`);
    const contentType = resp.headers.get('content-type')?.split(';')[0] || 'application/octet-stream';
    const buf = await resp.arrayBuffer();
    const raw = new Uint8Array(buf);
    let stored, isCompressed = false;
    if (compress) {
      const cs = new CompressionStream('gzip');
      const stream = new Blob([raw]).stream().pipeThrough(cs);
      const compressed = new Uint8Array(await new Response(stream).arrayBuffer());
      stored = uint8ToBase64(compressed);
      isCompressed = true;
    } else {
      stored = uint8ToBase64(raw);
    }
    window._installedModules[url] = { source: stored, cellId: cell.id, binary: true, compressed: isCompressed, type: contentType };
    const ratio = isCompressed ? ` \u2192 ${(stored.length / 1024).toFixed(1)} KB compressed` : '';
    display(`installed binary ${url} (${(buf.byteLength / 1024).toFixed(1)} KB${ratio})`);
    return URL.createObjectURL(new Blob([raw], { type: contentType }));
  };

  // ui object — constructed per-cell (closes over cell context)
  const ui = { display, print: display, canvas, table, slider, dropdown, checkbox, textInput };

  // tagged template builtins
  const md = taggedTemplate('md');
  const html = taggedTemplate('html');
  const css = taggedTemplate('css');

  // workshop builtin — slide-out side panel with navigable pages
  const workshop = (pages, opts) => {
    const key = '__workshop__';
    usedWidgets.add(key);
    const useOverlay = !!(opts && opts.overlay);

    // persist page index across re-runs
    if (cell._inputs[key] === undefined) cell._inputs[key] = 0;
    let currentPage = cell._inputs[key];

    // get or create panel DOM
    let panel = document.getElementById('workshopPanel');
    let overlay = document.getElementById('workshopOverlay');
    if (!panel) {
      overlay = document.createElement('div');
      overlay.id = 'workshopOverlay';
      overlay.className = 'workshop-overlay';
      overlay.onclick = () => toggleWorkshop(false);
      document.body.appendChild(overlay);

      panel = document.createElement('div');
      panel.id = 'workshopPanel';
      panel.className = 'workshop-panel';
      document.body.appendChild(panel);
    }

    // side tab attached to the panel edge
    let toggleBtn = document.getElementById('workshopToggle');
    if (!toggleBtn) {
      toggleBtn = document.createElement('button');
      toggleBtn.id = 'workshopToggle';
      toggleBtn.className = 'workshop-tab';
      toggleBtn.title = 'toggle workshop panel';
      toggleBtn.textContent = 'workshop';
      document.body.appendChild(toggleBtn);
      toggleBtn.onclick = () => toggleWorkshop();
    }

    function toggleWorkshop(show) {
      const isOpen = panel.classList.contains('open');
      const shouldOpen = show !== undefined ? show : !isOpen;
      panel.classList.toggle('open', shouldOpen);
      if (useOverlay) overlay.classList.toggle('visible', shouldOpen);
    }

    function renderPage(idx) {
      idx = Math.max(0, Math.min(idx, pages.length - 1));
      currentPage = idx;
      cell._inputs[key] = idx;
      const page = pages[idx];

      panel.innerHTML = '';

      // header with close button
      const header = document.createElement('div');
      header.className = 'workshop-header';
      const title = document.createElement('span');
      title.className = 'workshop-title';
      title.textContent = page.title || `Page ${idx + 1}`;
      header.appendChild(title);
      const closeBtn = document.createElement('button');
      closeBtn.className = 'workshop-close';
      closeBtn.textContent = '\u00d7';
      closeBtn.onclick = () => toggleWorkshop(false);
      header.appendChild(closeBtn);
      panel.appendChild(header);

      // content
      const body = document.createElement('div');
      body.className = 'workshop-body';
      if (page.content instanceof Element) {
        body.appendChild(page.content);
      } else if (page.content instanceof TaggedContent) {
        if (page.content.type === 'md') {
          body.innerHTML = renderMd(page.content.content);
        } else if (page.content.type === 'css') {
          const pre = document.createElement('pre');
          pre.textContent = page.content.content;
          body.appendChild(pre);
        } else {
          body.innerHTML = page.content.content;
        }
      } else {
        body.textContent = String(page.content ?? '');
      }
      panel.appendChild(body);

      // progress pips
      const pips = document.createElement('div');
      pips.className = 'workshop-pips';
      for (let i = 0; i < pages.length; i++) {
        const pip = document.createElement('span');
        pip.className = 'workshop-pip' + (i === idx ? ' active' : '') + (i < idx ? ' done' : '');
        pip.onclick = () => navigate(i);
        pips.appendChild(pip);
      }
      panel.appendChild(pips);

      // nav buttons
      const nav = document.createElement('div');
      nav.className = 'workshop-nav';
      if (idx > 0) {
        const prev = document.createElement('button');
        prev.textContent = '\u2190 prev';
        prev.onclick = () => navigate(idx - 1);
        nav.appendChild(prev);
      }
      const spacer = document.createElement('span');
      spacer.style.flex = '1';
      nav.appendChild(spacer);
      const counter = document.createElement('span');
      counter.className = 'workshop-counter';
      counter.textContent = `${idx + 1} / ${pages.length}`;
      nav.appendChild(counter);
      if (idx < pages.length - 1) {
        const next = document.createElement('button');
        next.className = 'workshop-next';
        next.textContent = 'next \u2192';
        if (page.canAdvance && !page.canAdvance()) {
          next.disabled = true;
          next.title = 'complete the task to continue';
        }
        next.onclick = () => navigate(idx + 1);
        nav.appendChild(next);
      }
      panel.appendChild(nav);

      // fire onEnter
      if (page.onEnter) page.onEnter();
    }

    function navigate(idx) {
      const prevPage = pages[currentPage];
      if (prevPage?.onLeave) prevPage.onLeave();
      renderPage(idx);
    }

    // store re-check function for canAdvance gating
    cell._workshopRecheck = () => {
      const page = pages[currentPage];
      if (!page?.canAdvance) return;
      const nextBtn = panel.querySelector('.workshop-next');
      if (nextBtn) {
        nextBtn.disabled = !page.canAdvance();
      }
    };

    renderPage(currentPage);

    // auto-open on first creation
    if (!panel.classList.contains('open') && !cell._workshopShown) {
      toggleWorkshop(true);
      cell._workshopShown = true;
    }

    // store cleanup so deleteCell can tear down workshop DOM
    cell._workshopCleanup = () => {
      panel.remove();
      overlay.remove();
      toggleBtn.remove();
      cell._workshopRecheck = null;
    };
    // on re-run, just clear the recheck — DOM is reused by ID
    invalidation.then(() => {
      cell._workshopRecheck = null;
    });

    return { goto: navigate, toggle: toggleWorkshop, recheck: cell._workshopRecheck };
  };

  // notebook API — programmatic notebook control
  const notebook = {
    get cells() { return S.cells.map(c => ({ id: c.id, type: c.type, code: c.code })); },
    get scope() { return { ...S.scope }; },
    addCell: (type, code, afterId) => addCell(type, code, afterId),
    scrollTo: (id) => {
      const c = S.cells.find(c => c.id === id);
      if (c?.el) c.el.scrollIntoView({ behavior: 'smooth', block: 'center' });
    },
    focus: (id) => {
      const c = S.cells.find(c => c.id === id);
      if (c?.el) {
        c.el.scrollIntoView({ behavior: 'smooth', block: 'center' });
        const ta = c.el.querySelector('textarea');
        if (ta) ta.focus();
      }
    },
    collapse: (id) => {
      const c = S.cells.find(c => c.id === id);
      if (c?.el) c.el.classList.add('collapsed');
    },
    expand: (id) => {
      const c = S.cells.find(c => c.id === id);
      if (c?.el) c.el.classList.remove('collapsed');
    },
    run: (ids) => runDAG(Array.isArray(ids) ? ids : [ids], true),
  };

  // function caching — reuse compiled function if code/uses/defines unchanged
  const cacheKey = scopeKeys.join(',') + '|' + defNames + '|' + cell.code;

  try {
    let fn;
    if (cell._cacheKey === cacheKey && cell._cachedFn) {
      fn = cell._cachedFn;
    } else {
      const AsyncFunction = Object.getPrototypeOf(async function(){}).constructor;
      const cellName = parseCellName(cell.code);
      const slug = cellName ? '-' + cellName.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/(^-|-$)/g, '') : '';
      fn = new AsyncFunction(
        ...scopeKeys,
        'ui', 'std', 'load', 'install', 'installBinary', 'invalidation', 'print',
        'md', 'html', 'css', 'workshop', 'notebook',
        `"use strict";\n${cell.code}\n\n` +
        `return { ${defNames} };\n` +
        `//# sourceURL=auditable://cell-${cell.id}${slug}.js`
      );
      cell._cachedFn = fn;
      cell._cacheKey = cacheKey;
    }

    const scopeVals = scopeKeys.map(k => S.scope[k]);
    const result = await fn(...scopeVals, ui, std, load, install, installBinary, invalidation, display,
      md, html, css, workshop, notebook);

    // update scope with defined variables
    if (result && typeof result === 'object') {
      cell._lastResult = result;
      for (const [k, v] of Object.entries(result)) {
        if (v !== undefined) S.scope[k] = v;
      }
    }

    cell.el.classList.remove('stale', 'error');
    cell.el.classList.add('fresh');
    setTimeout(() => cell.el.classList.remove('fresh'), 800);

    // remove widgets no longer referenced by code
    for (const w of widgetEl.querySelectorAll('[data-widget-key]')) {
      if (!usedWidgets.has(w.dataset.widgetKey)) {
        delete cell._inputs[w.dataset.widgetKey];
        delete cell._callbacks[w.dataset.widgetKey];
        w.remove();
      }
    }

  } catch (e) {
    cell.error = e.message;
    outputEl.textContent = e.message;
    outputEl.className = 'cell-output error';
    cell.el.classList.remove('stale', 'fresh');
    cell.el.classList.add('error');
  }
}

async function runDAG(dirtyIds, force = false) {
  buildDAG();
  const isAutorun = S.autorun && !force;

  // determine which cells need execution via topo sort
  const runSet = new Set(topoSort(dirtyIds));

  if (window._dagStart) window._dagStart();

  // rebuild scope in document order, only executing cells in runSet
  S.scope = {};
  const poisoned = new Set(); // variable names defined by errored cells
  for (let i = 0; i < S.cells.length; i++) {
    const cell = S.cells[i];

    if (cell.type === 'html') {
      if (runSet.has(cell.id)) {
        // check if any used variable is poisoned
        if (cell.uses && [...cell.uses].some(n => poisoned.has(n))) {
          cell.el.classList.remove('fresh');
          cell.el.classList.add('stale');
        } else {
          renderHtmlCell(cell);
        }
      }
      continue;
    }
    if (cell.type !== 'code') continue;

    // skip norun cells (unless explicitly triggered)
    if (isNorun(cell.code) && !dirtyIds.includes(cell.id)) {
      if (cell._lastResult) {
        for (const [k, v] of Object.entries(cell._lastResult)) {
          if (v !== undefined) S.scope[k] = v;
        }
      }
      continue;
    }

    // skip manual cells unless force or explicitly triggered
    if (!force && isManual(cell.code) && !dirtyIds.includes(cell.id)) {
      if (cell._lastResult) {
        for (const [k, v] of Object.entries(cell._lastResult)) {
          if (v !== undefined) S.scope[k] = v;
        }
      }
      cell.el.classList.add('stale');
      continue;
    }

    // not in run set — restore cached results, skip execution
    if (!runSet.has(cell.id)) {
      if (cell._lastResult) {
        for (const [k, v] of Object.entries(cell._lastResult)) {
          if (v !== undefined) S.scope[k] = v;
        }
      }
      continue;
    }

    // error isolation: if any upstream dependency is poisoned, skip this cell
    if (cell.uses && cell.uses.size > 0) {
      let blocked = false;
      for (const name of cell.uses) {
        if (poisoned.has(name)) { blocked = true; break; }
      }
      if (blocked) {
        const outputEl = cell.el.querySelector('.cell-output');
        if (outputEl && !cell.error) {
          outputEl.textContent = 'blocked by upstream error';
          outputEl.className = 'cell-output error';
        }
        cell.el.classList.remove('stale', 'fresh');
        cell.el.classList.add('error');
        // poison our own defines so downstream also blocks
        if (cell.defines) for (const name of cell.defines) poisoned.add(name);
        continue;
      }
    }

    // value-equality gating: if this cell is a downstream dependent (not directly
    // dirty) and all its input values are unchanged, skip re-execution entirely
    if (!dirtyIds.includes(cell.id) && cell._lastResult && cell.uses && cell.uses.size > 0) {
      let inputsChanged = false;
      for (const name of cell.uses) {
        if (S.scope[name] !== cell._prevInputs?.[name]) { inputsChanged = true; break; }
      }
      if (!inputsChanged) {
        // inputs identical — restore previous results, skip execution
        for (const [k, v] of Object.entries(cell._lastResult)) {
          if (v !== undefined) S.scope[k] = v;
        }
        continue;
      }
    }

    if (window._beforeExec) window._beforeExec(cell);
    await execCell(cell);

    // if the cell errored, poison its defines
    if (cell.error) {
      if (cell.defines) for (const name of cell.defines) poisoned.add(name);
    }

    // snapshot input values for future equality checks
    if (cell.uses) {
      cell._prevInputs = {};
      for (const name of cell.uses) cell._prevInputs[name] = S.scope[name];
    }

    if (window._afterExec && !isAutorun) {
      const jump = window._afterExec(cell, i);
      if (jump >= 0) { i = jump - 1; continue; }
    }
  }

  updateStatus();

  // recheck workshop canAdvance gates after scope changes
  for (const c of S.cells) {
    if (c._workshopRecheck) c._workshopRecheck();
  }
}

async function runAll() {
  const ids = S.cells.filter(c => c.type === 'code' || c.type === 'html').map(c => c.id);
  if (ids.length === 0) return;
  await runDAG(ids, true);
  setMsg('ran all cells', 'ok');
}

// late import to avoid circular dependency at module load time

// -- markdown.js --

// ── MARKDOWN RENDERING (minimal) ──

function renderMd(src) {
  let html = src
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;');

  // headings
  html = html.replace(/^### (.+)$/gm, '<h3>$1</h3>');
  html = html.replace(/^## (.+)$/gm, '<h2>$1</h2>');
  html = html.replace(/^# (.+)$/gm, '<h1>$1</h1>');

  // bold/italic
  html = html.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
  html = html.replace(/\*(.+?)\*/g, '<em>$1</em>');

  // inline code
  html = html.replace(/`(.+?)`/g, '<code>$1</code>');

  // links
  html = html.replace(/\[(.+?)\]\((.+?)\)/g, '<a href="$2">$1</a>');

  // tables — detect pipe-delimited blocks before paragraph wrapping
  html = html.replace(
    /((?:^\|.+\|[ \t]*$\n?)+)/gm,
    (block) => {
      const rows = block.trim().split('\n').map(r =>
        r.trim().replace(/^\|/, '').replace(/\|$/, '').split('|').map(c => c.trim())
      );
      if (rows.length < 2) return block;
      // check for separator row (--- or :--- etc)
      const sep = rows[1];
      if (!sep.every(c => /^:?-{1,}:?$/.test(c))) return block;
      const hdr = rows[0];
      const body = rows.slice(2);
      let t = '<table><thead><tr>' +
        hdr.map(c => `<th>${c}</th>`).join('') +
        '</tr></thead><tbody>';
      for (const row of body) {
        t += '<tr>' + row.map(c => `<td>${c}</td>`).join('') + '</tr>';
      }
      t += '</tbody></table>';
      return t;
    }
  );

  // paragraphs
  html = html.replace(/\n\n/g, '</p><p>');
  if (!html.startsWith('<h') && !html.startsWith('<p') && !html.startsWith('<table')) html = '<p>' + html + '</p>';

  return html;
}

// -- cell-dom.js --

// ── CELL DOM ──

function cssSummary(code) {
  if (!code || !code.trim()) return '';
  const rules = (code.match(/[^{}]+\{/g) || []).length;
  const lines = code.split('\n').length;
  return `${rules} rule${rules !== 1 ? 's' : ''} \u00b7 ${lines} line${lines !== 1 ? 's' : ''}`;
}

function cellHeaderHTML(type, id) {
  return `<div class="cell-header">
    <span class="cell-type">${type}</span>
    <button class="cell-btn cell-convert" onclick="toggleTypePicker(${id})" title="convert type">\u21c4</button>
    <div class="cell-type-picker" data-cell-id="${id}">
      <button onclick="convertCell(${id},'code')">code</button>
      <button onclick="convertCell(${id},'md')">md</button>
      <button onclick="convertCell(${id},'css')">css</button>
      <button onclick="convertCell(${id},'html')">html</button>
    </div>
    <button class="cell-btn cell-insert" onclick="showInsertPicker(${id},'before')" title="insert above">+\u2191</button>
    <button class="cell-btn cell-insert" onclick="showInsertPicker(${id},'after')" title="insert below">+\u2193</button>
    <button class="cell-btn" onclick="moveCell(${id},-1)" title="move up">\u2191</button>
    <button class="cell-btn" onclick="moveCell(${id},1)" title="move down">\u2193</button>
    <button class="cell-btn del" onclick="deleteCellWithUndo(${id})" title="delete">\u00d7</button>
  </div>`;
}

function createCellEl(type, id) {
  const div = document.createElement('div');
  div.className = 'cell';
  div.dataset.id = id;
  div.dataset.type = type;

  if (type === 'code') {
    div.innerHTML = `
      ${cellHeaderHTML('code', id)}
      <div class="cell-code">
        <div class="editor-wrap">
          <div class="line-numbers" aria-hidden="true">1</div>
          <textarea rows="3" spellcheck="false" wrap="off" placeholder="// code"></textarea>
          <div class="highlight-layer" aria-hidden="true"></div>
        </div>
      </div>
      <div class="cell-widgets"></div>
      <div class="cell-output"></div>
    `;

    const ta = div.querySelector('textarea');
    const hl = div.querySelector('.highlight-layer');
    div.querySelector('.cell-type').addEventListener('click', () => div.classList.toggle('collapsed'));
    const ln = div.querySelector('.line-numbers');
    ta.addEventListener('input', () => { highlightCode(ta, hl); onCodeEdit(id); });
    ta.addEventListener('scroll', () => { hl.scrollTop = ta.scrollTop; hl.scrollLeft = ta.scrollLeft; ln.scrollTop = ta.scrollTop; });
    attachAutocomplete(ta, id);
    ta.addEventListener('keydown', handleTab);
    ta.addEventListener('input', autoResize);
  } else if (type === 'css') {
    div.innerHTML = `
      ${cellHeaderHTML('css', id)}
      <div class="cell-css-view"></div>
      <div class="cell-css-edit" style="display:none">
        <div class="editor-wrap">
          <div class="line-numbers" aria-hidden="true">1</div>
          <textarea rows="3" spellcheck="false" wrap="off" placeholder="/* css */"></textarea>
          <div class="highlight-layer" aria-hidden="true"></div>
        </div>
      </div>
    `;

    const cssView = div.querySelector('.cell-css-view');
    const cssEditWrap = div.querySelector('.cell-css-edit');
    const ta = div.querySelector('textarea');
    const hl = div.querySelector('.highlight-layer');
    div.querySelector('.cell-type').addEventListener('click', () => div.classList.toggle('collapsed'));

    cssView.addEventListener('click', () => {
      cssEditWrap.style.display = '';
      cssView.style.display = 'none';
      ta.focus();
      autoResize({ target: ta });
    });

    ta.addEventListener('blur', () => {
      if (S.findActive) return;
      const cell = S.cells.find(c => c.id === id);
      if (cell) {
        cell.code = ta.value;
        cssView.textContent = cssSummary(ta.value);
      }
      cssEditWrap.style.display = 'none';
      cssView.style.display = '';
    });

    const ln = div.querySelector('.line-numbers');
    ta.addEventListener('input', () => { highlightCss(ta, hl); onCssEdit(id); });
    ta.addEventListener('scroll', () => { hl.scrollTop = ta.scrollTop; hl.scrollLeft = ta.scrollLeft; ln.scrollTop = ta.scrollTop; });
    ta.addEventListener('input', autoResize);
    ta.addEventListener('keydown', handleTab);
  } else if (type === 'html') {
    div.innerHTML = `
      ${cellHeaderHTML('html', id)}
      <div class="cell-html-view"></div>
      <div class="cell-html-edit" style="display:none">
        <div class="editor-wrap">
          <div class="line-numbers" aria-hidden="true">1</div>
          <textarea rows="2" spellcheck="false" wrap="off" placeholder="<html template>"></textarea>
          <div class="highlight-layer" aria-hidden="true"></div>
        </div>
      </div>
      <div class="cell-output"></div>
    `;

    const view = div.querySelector('.cell-html-view');
    const editWrap = div.querySelector('.cell-html-edit');
    const ta = div.querySelector('.cell-html-edit textarea');
    const hl = div.querySelector('.highlight-layer');
    div.querySelector('.cell-type').addEventListener('click', () => div.classList.toggle('collapsed'));

    view.addEventListener('click', () => {
      editWrap.style.display = '';
      view.style.display = 'none';
      ta.focus();
      autoResize({ target: ta });
    });

    ta.addEventListener('blur', () => {
      if (S.findActive) return;
      const cell = S.cells.find(c => c.id === id);
      if (cell) {
        cell.code = ta.value;
        renderHtmlCell(cell);
      }
      editWrap.style.display = 'none';
      view.style.display = '';
    });

    const ln = div.querySelector('.line-numbers');
    ta.addEventListener('input', () => { highlightHtml(ta, hl); onHtmlEdit(id); });
    ta.addEventListener('scroll', () => { hl.scrollTop = ta.scrollTop; hl.scrollLeft = ta.scrollLeft; ln.scrollTop = ta.scrollTop; });
    ta.addEventListener('input', autoResize);
    ta.addEventListener('keydown', handleTab);
  } else {
    div.innerHTML = `
      ${cellHeaderHTML('md', id)}
      <div class="cell-md-view"></div>
      <div class="cell-md-edit" style="display:none">
        <textarea rows="2" spellcheck="false" placeholder="markdown"></textarea>
      </div>
    `;

    const view = div.querySelector('.cell-md-view');
    const editWrap = div.querySelector('.cell-md-edit');
    const ta = div.querySelector('.cell-md-edit textarea');
    div.querySelector('.cell-type').addEventListener('click', () => div.classList.toggle('collapsed'));

    view.addEventListener('click', () => {
      editWrap.style.display = '';
      view.style.display = 'none';
      ta.focus();
      autoResize({ target: ta });
    });

    ta.addEventListener('blur', () => {
      if (S.findActive) return;
      const cell = S.cells.find(c => c.id === id);
      if (cell) {
        cell.code = ta.value;
        view.innerHTML = renderMd(ta.value);
      }
      editWrap.style.display = 'none';
      view.style.display = '';
    });

    ta.addEventListener('input', autoResize);
    ta.addEventListener('keydown', handleTab);
  }

  return div;
}

// undoable text replacement — uses execCommand so the browser records it in the undo stack
function replaceRange(ta, from, to, text) {
  ta.focus();
  ta.selectionStart = from;
  ta.selectionEnd = to;
  document.execCommand('insertText', false, text);
}

function handleTab(e) {
  const ta = e.target;
  const start = ta.selectionStart;
  const end = ta.selectionEnd;

  if (e.key === 'Tab') {
    e.preventDefault();

    if (start === end) {
      // no selection — insert 2 spaces
      replaceRange(ta, start, end, '  ');
    } else {
      // selection — indent/unindent lines
      const val = ta.value;
      const lineStart = val.lastIndexOf('\n', start - 1) + 1;
      const lineEnd = val.indexOf('\n', end);
      const blockEnd = lineEnd === -1 ? val.length : lineEnd;
      const block = val.slice(lineStart, blockEnd);
      let newBlock;
      if (e.shiftKey) {
        newBlock = block.replace(/^  /gm, '');
      } else {
        newBlock = block.replace(/^/gm, '  ');
      }
      replaceRange(ta, lineStart, blockEnd, newBlock);
      ta.selectionStart = lineStart;
      ta.selectionEnd = lineStart + newBlock.length;
    }
    ta.dispatchEvent(new Event('input'));
    return;
  }

  // Enter — auto-indent
  if (e.key === 'Enter') {
    e.preventDefault();
    const val = ta.value;
    const before = val.slice(0, start);
    const after = val.slice(end);

    // find current line's leading whitespace
    const lineStart = before.lastIndexOf('\n') + 1;
    const line = before.slice(lineStart);
    const indent = line.match(/^(\s*)/)[1];

    // check if the character before cursor is an opener
    const charBefore = before.trimEnd().slice(-1);
    const extra = '{(['.includes(charBefore) ? '  ' : '';

    // check if the character after cursor is a matching closer
    const charAfter = after.trimStart()[0];
    const pairs = { '{': '}', '(': ')', '[': ']' };
    const needClose = extra && charAfter === pairs[charBefore];

    if (needClose) {
      // cursor between brackets: add indented line + closing line
      const insert = '\n' + indent + extra + '\n' + indent;
      replaceRange(ta, start, end, insert);
      ta.selectionStart = ta.selectionEnd = start + 1 + indent.length + extra.length;
    } else {
      const insert = '\n' + indent + extra;
      replaceRange(ta, start, end, insert);
    }
    ta.dispatchEvent(new Event('input'));
    return;
  }

  // Ctrl+X / Ctrl+C with no selection — whole-line cut/copy
  if ((e.key === 'x' || e.key === 'c') && (e.ctrlKey || e.metaKey) && !e.shiftKey && !e.altKey && start === end) {
    e.preventDefault();
    const val = ta.value;
    const lineStart = val.lastIndexOf('\n', start - 1) + 1;
    let lineEnd = val.indexOf('\n', start);
    if (lineEnd === -1) lineEnd = val.length;
    else lineEnd++; // include the newline

    const lineText = val.slice(lineStart, lineEnd);
    navigator.clipboard.writeText(lineText);

    if (e.key === 'x') {
      replaceRange(ta, lineStart, lineEnd, '');
      ta.dispatchEvent(new Event('input'));
    }
    return;
  }
}

function toggleComment(ta) {
  const val = ta.value;
  const start = ta.selectionStart;
  const end = ta.selectionEnd;

  // find affected line range
  const lineStart = val.lastIndexOf('\n', start - 1) + 1;
  let lineEnd = val.indexOf('\n', end);
  if (lineEnd === -1) lineEnd = val.length;

  const block = val.slice(lineStart, lineEnd);
  const lines = block.split('\n');

  // check if all lines are commented
  const allCommented = lines.every(l => /^\s*\/\//.test(l) || l.trim() === '');

  let newLines;
  if (allCommented) {
    // uncomment: remove first // (and one trailing space if present)
    newLines = lines.map(l => l.replace(/^(\s*)\/\/ ?/, '$1'));
  } else {
    // comment: add // at the minimum indent level
    const indents = lines.filter(l => l.trim()).map(l => l.match(/^(\s*)/)[1].length);
    const minIndent = indents.length ? Math.min(...indents) : 0;
    newLines = lines.map(l => {
      if (l.trim() === '') return l;
      return l.slice(0, minIndent) + '// ' + l.slice(minIndent);
    });
  }

  const newBlock = newLines.join('\n');
  replaceRange(ta, lineStart, lineEnd, newBlock);
  ta.selectionStart = lineStart;
  ta.selectionEnd = lineStart + newBlock.length;
  ta.dispatchEvent(new Event('input'));
}

function updateLineNumbers(ta) {
  const wrap = ta.closest('.editor-wrap');
  if (!wrap) return;
  const gutter = wrap.querySelector('.line-numbers');
  if (!gutter) return;
  const count = ta.value.split('\n').length;
  const lines = [];
  for (let i = 1; i <= count; i++) lines.push(i);
  gutter.textContent = lines.join('\n');
}

function autoResize(e) {
  const ta = e.target || e;
  ta.style.height = 'auto';
  ta.style.height = ta.scrollHeight + 'px';
  // sync highlight layer if present
  const hl = ta.parentElement && ta.parentElement.querySelector('.highlight-layer');
  if (hl) { hl.style.height = ta.style.height; }
  updateLineNumbers(ta);
}

// -- cell-ops.js --

// ── CELL OPERATIONS ──

function addCell(type, code = '', afterId = null, beforeId = null) {
  const id = S.cellId++;
  const cell = {
    id, type, code,
    defines: new Set(),
    uses: new Set(),
    error: null,
    el: createCellEl(type, id)
  };

  const nb = $('#notebook');
  if (beforeId !== null) {
    const idx = S.cells.findIndex(c => c.id === beforeId);
    if (idx >= 0) {
      S.cells.splice(idx, 0, cell);
      S.cells[idx + 1].el.before(cell.el);
    } else {
      S.cells.push(cell);
      nb.appendChild(cell.el);
    }
  } else if (afterId !== null) {
    const idx = S.cells.findIndex(c => c.id === afterId);
    if (idx >= 0) {
      S.cells.splice(idx + 1, 0, cell);
      if (idx < S.cells.length - 2) {
        S.cells[idx + 2].el.before(cell.el);
      } else {
        nb.appendChild(cell.el);
      }
    } else {
      S.cells.push(cell);
      nb.appendChild(cell.el);
    }
  } else {
    S.cells.push(cell);
    nb.appendChild(cell.el);
  }

  // set code
  const ta = cell.el.querySelector('textarea');
  if (code) {
    ta.value = code;
    autoResize({ target: ta });
    if (type === 'code') {
      const hl = cell.el.querySelector('.highlight-layer');
      if (hl) highlightCode(ta, hl);
      if (isManual(code)) cell.el.classList.add('manual');
    }
    if (type === 'md') {
      cell.el.querySelector('.cell-md-view').innerHTML = renderMd(code);
    }
  }

  // CSS cell: create <style> element in <head>
  if (type === 'css') {
    const hl = cell.el.querySelector('.highlight-layer');
    if (hl && code) highlightCss(ta, hl);
    const cssView = cell.el.querySelector('.cell-css-view');
    if (cssView && code) cssView.textContent = cssSummary(code);
    const styleEl = document.createElement('style');
    styleEl.dataset.cellId = id;
    styleEl.textContent = code;
    document.head.appendChild(styleEl);
    cell._styleEl = styleEl;
  }

  // HTML cell: render template
  if (type === 'html' && code) {
    renderHtmlCell(cell);
  }

  ta.focus();
  updateStatus();
  notifyDirty();
  return cell;
}

function deleteCell(id) {
  const idx = S.cells.findIndex(c => c.id === id);
  if (idx < 0) return;
  // fire invalidation so cell resources (timers, etc.) clean up
  if (S.cells[idx]._invalidate) { S.cells[idx]._invalidate(); S.cells[idx]._invalidate = null; }
  // tear down workshop DOM if this cell had one
  if (S.cells[idx]._workshopCleanup) { S.cells[idx]._workshopCleanup(); S.cells[idx]._workshopCleanup = null; }
  if (S.cells[idx]._styleEl) {
    S.cells[idx]._styleEl.remove();
    S.cells[idx]._styleEl = null;
  }
  S.cells[idx].el.remove();
  S.cells.splice(idx, 1);
  // re-run to clean scope
  if (S.cells.some(c => c.type === 'code' || c.type === 'html')) runAll();
  updateStatus();
  notifyDirty();
}

function convertCell(id, newType) {
  const cell = S.cells.find(c => c.id === id);
  if (!cell || cell.type === newType) return;

  const code = cell.code;

  // cleanup old type
  if (cell._styleEl) {
    cell._styleEl.remove();
    cell._styleEl = null;
  }

  // create new cell element
  const newEl = createCellEl(newType, id);
  cell.el.replaceWith(newEl);
  cell.el = newEl;
  cell.type = newType;

  // set code
  const ta = newEl.querySelector('textarea');
  ta.value = code;
  cell.code = code;
  autoResize({ target: ta });

  if (newType === 'code') {
    const hl = newEl.querySelector('.highlight-layer');
    if (hl) highlightCode(ta, hl);
  }
  if (newType === 'md') {
    newEl.querySelector('.cell-md-view').innerHTML = renderMd(code);
  }
  if (newType === 'css') {
    const hl = newEl.querySelector('.highlight-layer');
    if (hl) highlightCss(ta, hl);
    const cssView = newEl.querySelector('.cell-css-view');
    if (cssView && code) cssView.textContent = cssSummary(code);
    const styleEl = document.createElement('style');
    styleEl.dataset.cellId = id;
    styleEl.textContent = code;
    document.head.appendChild(styleEl);
    cell._styleEl = styleEl;
  }
  if (newType === 'html') {
    renderHtmlCell(cell);
  }

  selectCell(id);
  updateStatus();
  notifyDirty();
  if (S.cells.some(c => c.type === 'code' || c.type === 'html')) runAll();
}

function moveCell(id, dir) {
  const idx = S.cells.findIndex(c => c.id === id);
  const newIdx = idx + dir;
  if (newIdx < 0 || newIdx >= S.cells.length) return;

  const [cell] = S.cells.splice(idx, 1);
  S.cells.splice(newIdx, 0, cell);

  // re-order DOM
  const nb = $('#notebook');
  nb.innerHTML = '';
  for (const c of S.cells) nb.appendChild(c.el);

  // re-order CSS <style> elements in <head> to match cell order
  for (const c of S.cells) {
    if (c._styleEl) document.head.appendChild(c._styleEl);
  }

  notifyDirty();
  if (S.cells.some(c => c.type === 'code' || c.type === 'html')) runAll();
}

// -- editor.js --

// ── EDITING ──

function notifyDirty() {
  if (S.initialized && window.__AF_BRIDGE__) window.parent.postMessage({ type: 'af:dirty' }, '*');
}

function toggleAutorun() {
  S.autorun = !S.autorun;
  const btn = $('#autorunBtn');
  const btnMobile = document.getElementById('autorunBtnMobile');
  const cls = S.autorun ? 'autorun-on' : 'autorun-off';
  const text = S.autorun ? '\u25b6' : '\u2016';
  btn.textContent = text;
  btn.title = S.autorun ? 'reactive mode \u2014 cells auto-run on edit' : 'manual mode \u2014 only Run All or Ctrl+Enter';
  btn.className = cls;
  if (btnMobile) {
    btnMobile.textContent = text;
    btnMobile.className = cls;
  }
  const sel = $('#setExecMode');
  if (sel) sel.value = S.autorun ? 'reactive' : 'manual';
  setMsg(S.autorun ? 'autorun on' : 'autorun off', 'ok');
}

function onCssEdit(id) {
  const cell = S.cells.find(c => c.id === id);
  if (!cell) return;
  cell.code = cell.el.querySelector('textarea').value;
  if (cell._styleEl) cell._styleEl.textContent = cell.code;
  notifyDirty();
}

function onHtmlEdit(id) {
  const cell = S.cells.find(c => c.id === id);
  if (!cell) return;
  cell.code = cell.el.querySelector('textarea').value;
  cell.el.classList.add('stale');
  notifyDirty();

  if (S.autorun) {
    clearTimeout(S.editTimer);
    S.editTimer = setTimeout(() => runDAG([id], false), 400);
  }
}

function onCodeEdit(id) {
  const cell = S.cells.find(c => c.id === id);
  if (!cell) return;
  const ta = cell.el.querySelector('textarea');
  cell.code = ta.value;

  // update manual state
  if (isManual(cell.code)) {
    cell.el.classList.add('manual');
  } else {
    cell.el.classList.remove('manual');
  }

  cell.el.classList.add('stale');
  notifyDirty();

  if (S.autorun) {
    clearTimeout(S.editTimer);
    S.editTimer = setTimeout(() => runDAG([id], false), 400);
  }
}

// -- settings.js --

// ── SETTINGS ──

// Safe localStorage access — blob URL iframes have opaque origins where localStorage throws
function lsGet(key) { try { return localStorage.getItem(key); } catch { return null; } }
function lsSet(key, val) { try { localStorage.setItem(key, val); } catch {} }
function lsRemove(key) { try { localStorage.removeItem(key); } catch {} }

function toggleSettings() {
  const overlay = $('#settingsOverlay');
  const panel = $('#settingsPanel');
  const open = !overlay.classList.contains('visible');
  overlay.classList.toggle('visible');
  panel.style.display = open ? 'block' : 'none';
  if (open) refreshModuleList();
}

function applyTheme(theme) {
  if (theme === 'light') {
    document.documentElement.classList.add('light');
  } else {
    document.documentElement.classList.remove('light');
  }
  $('#setTheme').value = theme;
}

function applyFontSize(size) {
  size = parseInt(size);
  document.documentElement.style.setProperty('--editor-font-size', size + 'px');
  $('#setFontSize').value = size;
  $('#setFontSizeVal').textContent = size;
}

function applyWidth(w) {
  const nb = $('#notebook');
  nb.style.maxWidth = w;
  $('#setWidth').value = w;
}

function applyLineNumbers(show) {
  const on = show === true || show === 'true' || show === 'on';
  document.documentElement.classList.toggle('hide-line-numbers', !on);
  const el = $('#setLineNumbers');
  if (el) el.value = on ? 'on' : 'off';
}

function applyHeader(mode) {
  const root = document.documentElement;
  root.classList.remove('header-always', 'header-hover', 'header-compact');
  if (mode === 'always') root.classList.add('header-always');
  else if (mode === 'hover') root.classList.add('header-hover');
  else if (mode === 'compact') root.classList.add('header-compact');
  // 'auto' = no class, CSS media queries handle it
  $('#setHeader').value = mode;
}

// ── EXECUTION MODE ──

const __AUDITABLE_DEFAULT_EXEC_MODE__ = 'reactive';
const __AUDITABLE_DEFAULT_RUN_ON_LOAD__ = 'yes';

let _runOnLoad = 'yes';
let _showToggle = 'yes';

function applyExecMode(mode) {
  S.autorun = (mode === 'reactive');
  const btn = $('#autorunBtn');
  const btnMobile = document.getElementById('autorunBtnMobile');
  const cls = S.autorun ? 'autorun-on' : 'autorun-off';
  const text = S.autorun ? '\u25b6' : '\u2016';
  if (btn) { btn.textContent = text; btn.className = cls; btn.title = S.autorun ? 'reactive mode \u2014 cells auto-run on edit' : 'manual mode \u2014 only Run All or Ctrl+Enter'; }
  if (btnMobile) { btnMobile.textContent = text; btnMobile.className = cls; }
  const sel = $('#setExecMode');
  if (sel) sel.value = mode;
}

function applyRunOnLoad(val) {
  _runOnLoad = val;
  const sel = $('#setRunOnLoad');
  if (sel) sel.value = val;
}

function applyShowToggle(val) {
  _showToggle = val;
  document.documentElement.classList.toggle('hide-run-toggle', val === 'no');
  const sel = $('#setShowToggle');
  if (sel) sel.value = val;
}

function applyGlobalExecMode(val) {
  if (val) lsSet('auditable-exec-mode', val);
  else lsRemove('auditable-exec-mode');
}

function applyGlobalRunOnLoad(val) {
  if (val) lsSet('auditable-run-on-load', val);
  else lsRemove('auditable-run-on-load');
}

function resolveExecMode() {
  return lsGet('auditable-exec-mode')
    || $('#setExecMode')?.value
    || __AUDITABLE_DEFAULT_EXEC_MODE__;
}

function resolveRunOnLoad() {
  return lsGet('auditable-run-on-load')
    || _runOnLoad
    || __AUDITABLE_DEFAULT_RUN_ON_LOAD__;
}

function getSettings() {
  const s = {
    theme: document.documentElement.classList.contains('light') ? 'light' : 'dark',
    fontSize: parseInt($('#setFontSize').value),
    width: $('#setWidth').value,
    header: $('#setHeader').value,
    lineNumbers: document.documentElement.classList.contains('hide-line-numbers') ? 'off' : 'on',
    execMode: S.autorun ? 'reactive' : 'manual',
    runOnLoad: _runOnLoad,
    showToggle: _showToggle,
  };
  if (window._sizeCompare) s.sizeCompare = true;
  if (window._sizeCompareRef === 'content') s.sizeCompareRef = 'content';
  return s;
}

function applySettings(s) {
  if (!s) return;
  if (s.theme) applyTheme(s.theme);
  if (s.fontSize) applyFontSize(s.fontSize);
  if (s.width) applyWidth(s.width);
  if (s.header) applyHeader(s.header);
  if (s.lineNumbers) applyLineNumbers(s.lineNumbers);
  if (s.execMode) applyExecMode(s.execMode);
  if (s.runOnLoad) applyRunOnLoad(s.runOnLoad);
  if (s.showToggle) applyShowToggle(s.showToggle);
  // optional: size-compare.js (typeof guards for --lean builds without it)
  if (s.sizeCompare !== undefined && typeof applySizeCompare === 'function') applySizeCompare(s.sizeCompare);
  if (s.sizeCompareRef !== undefined && typeof applySizeCompareRef === 'function') applySizeCompareRef(s.sizeCompareRef);
}

function togglePresent() {
  document.body.classList.toggle('presenting');
}

// ── ABOUT ──

const __AUDITABLE_VERSION__ = '0.3.0';
const __AUDITABLE_RELEASE__ = 'dev';
const __AUDITABLE_BUILD_DATE__ = '2026-02-24';
const __AUDITABLE_BASE_SIZE__ = 251968;

(function() {
  const ver = $('#aboutVersion');
  const build = $('#aboutBuild');
  const rt = $('#aboutRuntime');
  if (ver) ver.textContent = 'auditable v' + __AUDITABLE_VERSION__;
  if (build) build.textContent = (__AUDITABLE_RELEASE__ !== 'dev' ? __AUDITABLE_RELEASE__ + ' \u00b7 ' : '') + 'built ' + __AUDITABLE_BUILD_DATE__;
  if (rt && __AUDITABLE_BASE_SIZE__ > 0) rt.textContent = 'runtime ' + (__AUDITABLE_BASE_SIZE__ / 1024).toFixed(1) + ' KB';
})();

// ── EXECUTION SETTINGS INIT ──

(function() {
  const gm = lsGet('auditable-exec-mode') || '';
  const gr = lsGet('auditable-run-on-load') || '';
  const selGm = $('#setGlobalExecMode');
  const selGr = $('#setGlobalRunOnLoad');
  if (selGm) selGm.value = gm;
  if (selGr) selGr.value = gr;
})();

// ── MODULE MANAGEMENT ──

function formatSize(bytes) {
  return (bytes / 1024).toFixed(1) + ' KB';
}

function renderEntryRow(url, entry) {
  const src = typeof entry === 'string' ? entry : entry.source;
  const cellId = typeof entry === 'string' ? null : entry.cellId;
  const isBinary = typeof entry === 'object' && entry.binary;
  const size = src ? src.length : 0;
  const displaySize = isBinary ? Math.floor(size * 3 / 4) : size;

  const row = document.createElement('div');
  row.className = 'module-row';

  const urlSpan = document.createElement('span');
  urlSpan.className = 'module-url';
  urlSpan.textContent = url;
  urlSpan.title = url;
  row.appendChild(urlSpan);

  const info = document.createElement('span');
  info.className = 'module-info';
  info.textContent = (cellId != null ? 'cell ' + cellId + '  ' : '')
    + (isBinary && entry.compressed ? 'gzipped  ' : '')
    + formatSize(displaySize);
  row.appendChild(info);

  const btn = document.createElement('button');
  btn.className = 'module-remove';
  btn.textContent = '\u00d7';
  btn.title = isBinary ? 'remove binary' : 'remove module';
  btn.onclick = () => removeModule(url);
  row.appendChild(btn);

  return { row, size };
}

function renderSection(list, urls, mods, emptyText) {
  list.innerHTML = '';
  if (urls.length === 0) {
    const empty = document.createElement('div');
    empty.className = 'module-empty';
    empty.textContent = emptyText;
    list.appendChild(empty);
    return 0;
  }
  let totalSize = 0;
  for (const url of urls) {
    const { row, size } = renderEntryRow(url, mods[url]);
    list.appendChild(row);
    totalSize += size;
  }
  const total = document.createElement('div');
  total.className = 'module-total';
  total.textContent = 'total  ' + formatSize(totalSize);
  list.appendChild(total);
  return totalSize;
}

function refreshModuleList() {
  const modList = $('#moduleList');
  const binList = $('#binaryList');
  if (!modList) return;

  const mods = window._installedModules || {};
  const modUrls = [];
  const binUrls = [];
  for (const url of Object.keys(mods)) {
    const entry = mods[url];
    if (typeof entry === 'object' && entry.binary) binUrls.push(url);
    else modUrls.push(url);
  }

  renderSection(modList, modUrls, mods, 'no modules installed');
  if (binList) renderSection(binList, binUrls, mods, 'no binaries installed');
}

function removeModule(url) {
  const entry = window._installedModules?.[url];
  const cellId = entry && typeof entry === 'object' ? entry.cellId : null;
  const kind = entry?.binary ? 'binary' : 'module';
  if (window._installedModules) delete window._installedModules[url];
  if (window._importCache) delete window._importCache[url];
  refreshModuleList();
  updateStatus();
  if (cellId != null) {
    setMsg(`removed ${kind} \u2014 cell ${cellId} will re-install it on next run`, 'warn');
  }
}

// -- update.js --

// ── UPDATE PANEL ──

function toggleUpdate() {
  const overlay = $('#updateOverlay');
  const panel = $('#updatePanel');
  const open = !overlay.classList.contains('visible');
  overlay.classList.toggle('visible');
  panel.style.display = open ? 'block' : 'none';
}

// ── SELF-UPDATE SYSTEM ──

const __AUDITABLE_PUBLIC_KEY__ = '';
const __AUDITABLE_REPO__ = 'endarthur/auditable';
const __AUDITABLE_PAGES_URL__ = 'https://endarthur.github.io/auditable';

// ── SIGNATURE EXTRACTION ──

function extractSignature(html) {
  const m = html.match(/<!--AUDITABLE-SIGNATURE\n([\s\S]*?)\nAUDITABLE-SIGNATURE-->/);
  if (!m) return null;
  try { return JSON.parse(m[1]); } catch { return null; }
}

// ── RUNTIME EXTRACTION ──

function extractRuntime(html) {
  const style = html.match(/<style>([\s\S]*?)<\/style>/);
  const script = html.match(/<script>([\s\S]*?)<\/script>/);
  if (!style || !script) return null;
  return { style: style[1], script: script[1] };
}

// ── DATA EXTRACTION ──

function extractData(html) {
  const data = html.match(/<!--AUDITABLE-DATA\n([\s\S]*?)\nAUDITABLE-DATA-->/);
  const settings = html.match(/<!--AUDITABLE-SETTINGS\n([\s\S]*?)\nAUDITABLE-SETTINGS-->/);
  const modules = html.match(/<!--AUDITABLE-MODULES\n([\s\S]*?)\nAUDITABLE-MODULES-->/);
  const title = html.match(/<title>([^<]*)<\/title>/);
  return {
    data: data ? data[0] : null,
    settings: settings ? settings[0] : null,
    modules: modules ? modules[0] : null,
    title: title ? title[1].replace(/^Auditable\s*\u2014\s*/, '') : 'untitled',
  };
}

// ── SIGNED CONTENT CONSTRUCTION ──

function buildSignedContent(style, script) {
  return 'AUDITABLE-SIGNED-CONTENT\n'
    + style + '\n'
    + 'AUDITABLE-STYLE-SCRIPT-BOUNDARY\n'
    + script;
}

// ── SIGNATURE VERIFICATION (Web Crypto) ──

async function verifySignature(html) {
  const sig = extractSignature(html);
  if (!sig) return { status: 'unsigned' };

  const pubKeyB64 = __AUDITABLE_PUBLIC_KEY__;
  if (!pubKeyB64) return { status: 'no-key', sig };

  // Check if the signature's public key matches ours
  if (sig.pub !== pubKeyB64) return { status: 'wrong-key', sig };

  const runtime = extractRuntime(html);
  if (!runtime) return { status: 'error', message: 'could not extract runtime' };

  const content = buildSignedContent(runtime.style, runtime.script);

  try {
    const pubBytes = Uint8Array.from(atob(pubKeyB64), c => c.charCodeAt(0));
    const key = await crypto.subtle.importKey(
      'raw', pubBytes, { name: 'Ed25519' }, false, ['verify']
    );
    const sigBytes = Uint8Array.from(atob(sig.sig), c => c.charCodeAt(0));
    const msgBytes = new TextEncoder().encode(content);
    const valid = await crypto.subtle.verify('Ed25519', key, sigBytes, msgBytes);
    return { status: valid ? 'valid' : 'invalid', sig };
  } catch (e) {
    if (e.name === 'NotSupportedError') {
      return { status: 'unsupported', message: 'browser does not support Ed25519 verification' };
    }
    return { status: 'error', message: e.message };
  }
}

// ── REASSEMBLE ──

function reassemble(newHtml, oldData) {
  let html = newHtml;

  // Remove any existing data/settings/modules comments (and their description comments) from the new template
  html = html.replace(/(?:<!-- [^\n]*-->\n)?<!--AUDITABLE-DATA\n[\s\S]*?\nAUDITABLE-DATA-->\n?/g, '');
  html = html.replace(/(?:<!-- [^\n]*-->\n)?<!--AUDITABLE-SETTINGS\n[\s\S]*?\nAUDITABLE-SETTINGS-->\n?/g, '');
  html = html.replace(/(?:<!-- [^\n]*-->\n)?<!--AUDITABLE-MODULES\n[\s\S]*?\nAUDITABLE-MODULES-->\n?/g, '');

  // Build data block to inject
  const parts = [];
  if (oldData.data) parts.push(oldData.data);
  if (oldData.modules) parts.push(oldData.modules);
  if (oldData.settings) parts.push(oldData.settings);
  const dataBlock = parts.length ? '\n' + parts.join('\n') + '\n' : '';

  // Inject before the signature comment or before <script>
  const sigIdx = html.indexOf('<!--AUDITABLE-SIGNATURE');
  const scriptIdx = html.indexOf('<script>');
  const insertIdx = sigIdx >= 0 ? sigIdx : scriptIdx;
  if (insertIdx >= 0) {
    html = html.slice(0, insertIdx) + dataBlock + html.slice(insertIdx);
  }

  // Update title
  if (oldData.title && oldData.title !== 'untitled') {
    html = html.replace(/<title>[^<]*<\/title>/, '<title>Auditable \u2014 ' + escHtml(oldData.title) + '</title>');
    // Also update the docTitle input value
    html = html.replace(/(<input[^>]*id="docTitle"[^>]*value=")[^"]*"/, '$1' + escHtml(oldData.title) + '"');
  }

  return html;
}

function escHtml(s) {
  return s.replace(/&/g, '&amp;').replace(/"/g, '&quot;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
}

// ── VERSION COMPARISON ──

function compareVersions(a, b) {
  // compare semver strings like "0.1.0" vs "0.2.0"
  const pa = a.replace(/^v/, '').split('.').map(Number);
  const pb = b.replace(/^v/, '').split('.').map(Number);
  for (let i = 0; i < Math.max(pa.length, pb.length); i++) {
    const na = pa[i] || 0, nb = pb[i] || 0;
    if (na < nb) return -1;
    if (na > nb) return 1;
  }
  return 0;
}

// ── TOOLBAR BADGES ──

function setBadge(id, label, cls) {
  const container = $('#toolbarBadges');
  if (!container) return;
  let el = container.querySelector('[data-badge="' + id + '"]');
  if (!label) {
    if (el) el.remove();
    return;
  }
  if (!el) {
    el = document.createElement('span');
    el.className = 'toolbar-badge toolbar-badge-' + id;
    el.setAttribute('data-badge', id);
    container.appendChild(el);
  }
  el.textContent = label;
  if (cls) el.className = 'toolbar-badge ' + cls;
}

// ── UPDATE STATUS UI ──

function setUpdateStatus(html, cls) {
  const el = $('#updateStatus');
  if (el) {
    el.innerHTML = html;
    el.className = 'update-status' + (cls ? ' update-' + cls : '');
  }
}

// ── CHECK FOR UPDATE (GitHub API) ──

async function checkForUpdate() {
  const btn = $('#updateCheckBtn');
  if (btn) btn.disabled = true;
  setUpdateStatus('checking...', '');

  try {
    // Fetch version.json from GitHub Pages (CORS-friendly)
    const vResp = await fetch(__AUDITABLE_PAGES_URL__ + '/version.json');
    if (!vResp.ok) throw new Error('version check failed: ' + vResp.status);
    const vData = await vResp.json();
    const remoteVersion = vData.version || '';
    const currentRelease = $('#updateRelease')?.textContent || 'dev';

    if (currentRelease === 'dev') {
      // Dev builds always offer the latest release
    } else if (compareVersions(currentRelease, remoteVersion) >= 0) {
      setUpdateStatus('up to date (' + currentRelease + ')', 'ok');
      if (btn) btn.disabled = false;
      return;
    }

    const notes = vData.notes || '';
    const notesHtml = notes
      ? '<div class="update-notes">' + renderMd(notes) + '</div>'
      : '';

    setUpdateStatus(
      '<strong>' + remoteVersion + '</strong> available'
      + notesHtml
      + '<button id="updateApplyBtn" onclick="applyOnlineUpdate()">update</button>',
      'available'
    );

    window._updateVersion = remoteVersion;
  } catch (e) {
    setUpdateStatus('error: ' + escHtml(e.message), 'err');
  }
  if (btn) btn.disabled = false;
}

// ── APPLY ONLINE UPDATE ──

async function applyOnlineUpdate() {
  setUpdateStatus('downloading...', '');

  try {
    // Download signed build from GitHub Pages (CORS-friendly)
    const resp = await fetch(__AUDITABLE_PAGES_URL__ + '/auditable.html');
    if (!resp.ok) throw new Error('download failed: ' + resp.status);
    const newHtml = await resp.text();
    await applyUpdate(newHtml, window._updateVersion);
  } catch (e) {
    setUpdateStatus('error: ' + escHtml(e.message), 'err');
  }
}

// ── APPLY UPDATE (verify + reassemble + download) ──

async function applyUpdate(newHtml, version) {
  setUpdateStatus('verifying signature...', '');

  const result = await verifySignature(newHtml);

  if (result.status === 'invalid') {
    setUpdateStatus('signature verification FAILED \u2014 update rejected', 'err');
    return;
  }

  const warnMessages = {
    'unsigned': 'this file is not signed',
    'no-key': 'no public key configured \u2014 cannot verify signature',
    'wrong-key': 'signed with an unknown key',
  };
  if (warnMessages[result.status]) {
    setUpdateStatus(
      'warning: ' + warnMessages[result.status]
      + '<div class="update-confirm">'
      + '<button onclick="proceedUpdate()">proceed anyway</button>'
      + '<button onclick="cancelUpdate()">cancel</button>'
      + '</div>',
      'warn'
    );
    window._pendingUpdateHtml = newHtml;
    window._pendingUpdateVersion = version;
    return;
  }

  if (result.status === 'unsupported') {
    setUpdateStatus(
      result.message
      + '<div class="update-confirm">'
      + '<button onclick="proceedUpdate()">proceed without verification</button>'
      + '<button onclick="cancelUpdate()">cancel</button>'
      + '</div>',
      'warn'
    );
    window._pendingUpdateHtml = newHtml;
    window._pendingUpdateVersion = version;
    return;
  }

  if (result.status === 'error') {
    setUpdateStatus('verification error: ' + escHtml(result.message), 'err');
    return;
  }

  // Valid signature — proceed
  finishUpdate(newHtml, version);
}

function proceedUpdate() {
  if (window._pendingUpdateHtml) {
    finishUpdate(window._pendingUpdateHtml, window._pendingUpdateVersion);
    delete window._pendingUpdateHtml;
    delete window._pendingUpdateVersion;
  }
}

function cancelUpdate() {
  delete window._pendingUpdateHtml;
  delete window._pendingUpdateVersion;
  setUpdateStatus('update cancelled', '');
}

function finishUpdate(newHtml, version) {
  setUpdateStatus('reassembling...', '');

  // Extract current document as HTML to get data comments
  const currentHtml = document.documentElement.outerHTML;
  // But the data comments are in the body innerHTML at load time; grab from live source
  const bodyHtml = document.body.innerHTML;
  const fullHtml = '<!DOCTYPE html>\n<html>' + document.head.outerHTML + '<body>' + bodyHtml + '</body></html>';

  const oldData = extractData(fullHtml);
  // Override title from live doc
  const titleInput = $('#docTitle');
  if (titleInput) oldData.title = titleInput.value || 'untitled';

  // Build fresh data comments from live state (more reliable than regex from DOM)
  if (S.cells.length) {
    const cellData = S.cells.map(c => ({
      type: c.type,
      code: c.code,
      collapsed: c.el?.classList.contains('collapsed') || undefined
    }));
    oldData.data = '<!-- cell data: JSON array of {type, code, collapsed?} -->\n<!--AUDITABLE-DATA\n' + JSON.stringify(cellData) + '\nAUDITABLE-DATA-->';
  }
  if (window._installedModules && Object.keys(window._installedModules).length) {
    oldData.modules = '<!-- installed modules: base64-encoded JSON mapping URLs to {source, cellId} -->\n<!--AUDITABLE-MODULES\n' + encodeModules(window._installedModules) + '\nAUDITABLE-MODULES-->';
  }
  oldData.settings = '<!-- notebook settings: JSON {theme, fontSize, width, ...} -->\n<!--AUDITABLE-SETTINGS\n' + JSON.stringify(getSettings()) + '\nAUDITABLE-SETTINGS-->';

  const result = reassemble(newHtml, oldData);

  // Offer as download
  const title = (titleInput ? titleInput.value : 'untitled') || 'untitled';
  const blob = new Blob([result], { type: 'text/html' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = title.replace(/[^a-zA-Z0-9_-]/g, '_') + '.html';
  a.click();
  URL.revokeObjectURL(url);

  const vLabel = version ? ' to ' + version : '';
  setUpdateStatus('updated' + vLabel + ' \u2014 saved as ' + a.download, 'ok');
  setMsg('updated' + vLabel, 'ok');
}

// ── UPDATE FROM FILE ──

function updateFromFile() {
  const input = document.createElement('input');
  input.type = 'file';
  input.accept = '.html';
  input.onchange = async () => {
    const file = input.files[0];
    if (!file) return;
    setUpdateStatus('reading file...', '');
    const text = await file.text();

    // Try to extract version from the file
    const vMatch = text.match(/__AUDITABLE_VERSION__\s*=\s*'([^']+)'/);
    const version = vMatch ? 'v' + vMatch[1] : null;

    await applyUpdate(text, version);
  };
  input.click();
}

// ── VERIFY CURRENT DOCUMENT ──

async function verifySelf() {
  const el = $('#updateSigStatus');
  if (!el) return;

  // Reconstruct from live DOM
  const styleEl = document.querySelector('style');
  const scriptEl = document.querySelector('script');
  if (!styleEl || !scriptEl) {
    el.textContent = 'error: no style/script';
    el.className = 'update-sig update-err';
    return;
  }

  const raw = document.body.innerHTML;
  const sigMatch = raw.match(/<!--AUDITABLE-SIGNATURE\n([\s\S]*?)\nAUDITABLE-SIGNATURE-->/);
  if (!sigMatch) {
    el.textContent = 'unsigned';
    el.className = 'update-sig update-warn';
    return;
  }

  let sig;
  try { sig = JSON.parse(sigMatch[1]); } catch {
    el.textContent = 'invalid signature format';
    el.className = 'update-sig update-err';
    return;
  }

  const pubKeyB64 = __AUDITABLE_PUBLIC_KEY__;
  if (!pubKeyB64) {
    el.textContent = 'no public key configured';
    el.className = 'update-sig update-warn';
    return;
  }

  if (sig.pub !== pubKeyB64) {
    el.textContent = 'signed with unknown key';
    el.className = 'update-sig update-warn';
    return;
  }

  const content = buildSignedContent(styleEl.textContent, scriptEl.textContent);

  try {
    const pubBytes = Uint8Array.from(atob(pubKeyB64), c => c.charCodeAt(0));
    const key = await crypto.subtle.importKey(
      'raw', pubBytes, { name: 'Ed25519' }, false, ['verify']
    );
    const sigBytes = Uint8Array.from(atob(sig.sig), c => c.charCodeAt(0));
    const msgBytes = new TextEncoder().encode(content);
    const valid = await crypto.subtle.verify('Ed25519', key, sigBytes, msgBytes);
    if (valid) {
      el.textContent = 'signed \u2713';
      el.className = 'update-sig update-ok';
      setBadge('signed', 'signed', 'toolbar-badge toolbar-badge-signed');
    } else {
      el.textContent = 'signature invalid';
      el.className = 'update-sig update-err';
    }
  } catch (e) {
    if (e.name === 'NotSupportedError') {
      el.textContent = 'Ed25519 not supported';
      el.className = 'update-sig update-warn';
    } else {
      el.textContent = 'error: ' + e.message;
      el.className = 'update-sig update-err';
    }
  }
}

// ── INIT ──
(function() {
  const ver = $('#updateCurrentVer');
  if (ver) ver.textContent = 'v' + __AUDITABLE_VERSION__;
  const rel = $('#updateRelease');
  if (rel) {
    rel.textContent = __AUDITABLE_RELEASE__;
    if (__AUDITABLE_RELEASE__ === 'dev') rel.className = 'update-sig update-warn';
  }
  // Show public key status
  const keyEl = $('#updatePubKey');
  if (keyEl) {
    if (__AUDITABLE_PUBLIC_KEY__) {
      keyEl.textContent = __AUDITABLE_PUBLIC_KEY__.slice(0, 8) + '...';
      keyEl.className = 'update-sig update-key-truncated';
      keyEl.onclick = () => {
        if (keyEl.classList.contains('update-key-expanded')) {
          keyEl.textContent = __AUDITABLE_PUBLIC_KEY__.slice(0, 8) + '...';
          keyEl.classList.remove('update-key-expanded');
          keyEl.classList.add('update-key-truncated');
        } else {
          keyEl.textContent = __AUDITABLE_PUBLIC_KEY__;
          keyEl.classList.remove('update-key-truncated');
          keyEl.classList.add('update-key-expanded');
        }
      };
    } else {
      keyEl.textContent = 'not configured';
      keyEl.className = 'update-sig update-warn';
    }
  }
  // Run self-verification on load
  verifySelf();
})();

// -- save.js --

// ── MODULES ENCODING ──
// base64-encode modules JSON to avoid HTML comment / String.replace issues
// (source code can contain --, $', etc.)

function encodeModules(obj) {
  const b64 = btoa(unescape(encodeURIComponent(JSON.stringify(obj))));
  return b64.replace(/.{1,76}/g, '$&\n').trimEnd();
}

function decodeModules(raw) {
  const b64 = raw.replace(/\s/g, '');
  // detect legacy format: starts with { means raw JSON (not base64)
  if (b64.startsWith('{') || b64.startsWith('%7B')) return JSON.parse(raw);
  return JSON.parse(decodeURIComponent(escape(atob(b64))));
}

// ── SAVE / LOAD ──

// save mode: 'normal' or 'packed'
let _saveMode = 'normal';

function getSaveMode() { return _saveMode; }

function toggleSaveTray() {
  const tray = $('#saveTray');
  if (tray) tray.classList.toggle('open');
}

function setSaveMode(mode) {
  _saveMode = mode;
  // update UI
  const label = $('#saveLabel');
  if (label) label.textContent = mode === 'packed' ? 'pack' : 'save';
  const tray = $('#saveTray');
  if (tray) tray.classList.remove('open');
  // update mobile buttons
  const mobSave = $('#mobileSaveBtn');
  const mobPack = $('#mobilePackBtn');
  if (mobSave) mobSave.classList.toggle('active-mode', mode === 'normal');
  if (mobPack) mobPack.classList.toggle('active-mode', mode === 'packed');
}

function buildNotebookHtml() {
  // serialize current state back to a self-contained HTML file
  const title = $('#docTitle').value || 'untitled';

  // collect cells as data
  const cellData = S.cells.map(c => ({
    type: c.type,
    code: c.code,
    collapsed: c.el.classList.contains('collapsed') || undefined
  }));

  // get the runtime and styles from current document
  const styleEl = document.querySelector('style');
  const styles = styleEl.textContent;

  // get the script
  const scriptEl = document.querySelector('script');
  const script = scriptEl.textContent;

  // read static elements from live DOM
  const helpHTML = $('#helpOverlay').outerHTML;
  const settingsOvHTML = $('#settingsOverlay').outerHTML;
  const settingsPanHTML = $('#settingsPanel').outerHTML.replace(/display:\s*block;?/, '');
  const updateOvHTML = $('#updateOverlay').outerHTML.replace(/\bvisible\b/, '').replace(/class="\s*"/, 'class=""');
  const updatePanEl = $('#updatePanel').cloneNode(true);
  updatePanEl.style.display = '';
  // reset update status and dynamic text
  const uStatus = updatePanEl.querySelector('#updateStatus');
  if (uStatus) { uStatus.innerHTML = ''; uStatus.className = 'update-status'; }
  const updatePanHTML = updatePanEl.outerHTML.replace(/display:\s*block;?/, '');
  const statusbarHTML = document.querySelector('.statusbar').outerHTML;

  // read toolbar from live DOM and patch the title value
  const toolbarEl = document.querySelector('.toolbar').cloneNode(true);
  toolbarEl.querySelector('#docTitle').value = title;
  toolbarEl.querySelector('#toolbarStatus').textContent = '';
  // reset autorun button state to match saved mode
  const autoBtn = toolbarEl.querySelector('#autorunBtn');
  const savedMode = S.autorun ? 'reactive' : 'manual';
  if (autoBtn) {
    autoBtn.className = savedMode === 'reactive' ? 'autorun-on' : 'autorun-off';
    autoBtn.textContent = savedMode === 'reactive' ? '\u25b6' : '\u2016';
  }
  // close overflow and save tray if open
  const overflow = toolbarEl.querySelector('.toolbar-overflow');
  if (overflow) overflow.classList.remove('open');
  const saveTray = toolbarEl.querySelector('#saveTray');
  if (saveTray) saveTray.classList.remove('open');
  // reset save label to default
  const saveLabel = toolbarEl.querySelector('#saveLabel');
  if (saveLabel) saveLabel.textContent = 'save';
  // clear badges (they get set dynamically on load)
  const badges = toolbarEl.querySelector('.toolbar-badges');
  if (badges) badges.innerHTML = '';
  const toolbarHTML = toolbarEl.outerHTML;

  // capture find bar and reset to default state
  const findBarEl = $('#findBar').cloneNode(true);
  findBarEl.style.display = '';
  findBarEl.classList.remove('show-replace');
  findBarEl.querySelector('#findInput').value = '';
  findBarEl.querySelector('#replaceInput').value = '';
  findBarEl.querySelector('#findCount').textContent = '';
  findBarEl.querySelector('#findCaseBtn').classList.remove('active');
  findBarEl.querySelector('#findRegexBtn').classList.remove('active');
  const findBarHTML = findBarEl.outerHTML;

  // build output HTML
  return `<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Auditable \u2014 ${esc(title)}</title>
<style>\n${styles}\n</style>
</head>
<body>

${helpHTML}

${settingsOvHTML}
${settingsPanHTML}

${updateOvHTML}
${updatePanHTML}

${toolbarHTML}

${findBarHTML}

<button class="present-exit" onclick="togglePresent()">\u2715 exit</button>

<div class="notebook" id="notebook">
</div>

${statusbarHTML}

${'<!-- cell data: JSON array of {type, code, collapsed?} -->\n<!--AUDITABLE-DATA\n' + JSON.stringify(cellData) + '\nAUDITABLE-DATA-->'}
${Object.keys(window._installedModules || {}).length ? '<!-- installed modules: base64-encoded JSON mapping URLs to {source, cellId} -->\n<!--AUDITABLE-MODULES\n' + encodeModules(window._installedModules) + '\nAUDITABLE-MODULES-->' : ''}
${'<!-- notebook settings: JSON {theme, fontSize, width, ...} -->\n<!--AUDITABLE-SETTINGS\n' + JSON.stringify(getSettings()) + '\nAUDITABLE-SETTINGS-->'}

<script>\n${script}\n<\/script>
</body>
</html>`;
}

function downloadHtml(html, title) {
  const blob = new Blob([html], { type: 'text/html' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = title.replace(/[^a-zA-Z0-9_-]/g, '_') + '.html';
  a.click();
  URL.revokeObjectURL(url);
  return a.download;
}

function saveNotebook() {
  if (_saveMode === 'packed') {
    savePackedNotebook();
    return;
  }
  const title = $('#docTitle').value || 'untitled';
  const html = buildNotebookHtml();

  // AF bridge: send serialized HTML to parent shell instead of downloading
  if (window.__AF_BRIDGE__) {
    window.parent.postMessage({ type: 'af:serialized', payload: { html } }, '*');
    setMsg('saved', 'ok');
    return;
  }

  const fn = downloadHtml(html, title);
  setMsg('saved ' + fn, 'ok');
}

async function savePackedNotebook() {
  const title = $('#docTitle').value || 'untitled';
  const html = buildNotebookHtml();

  try {
    // compress via CompressionStream
    const blob = new Blob([html]);
    const cs = new CompressionStream('gzip');
    const stream = blob.stream().pipeThrough(cs);
    const compressed = await new Response(stream).arrayBuffer();
    const b64 = btoa(String.fromCharCode(...new Uint8Array(compressed)));
    const b64Lines = b64.replace(/.{1,76}/g, '$&\n');

    const loader = `<!DOCTYPE html>
<!-- packed auditable notebook -->
<!-- the full notebook is gzip-compressed and base64-encoded in the <pre> block below. -->
<!-- on load, the script decodes and decompresses it, then replaces the page contents. -->
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Auditable \u2014 ${esc(title)}</title>
  <style>
    html { background: #1a1a1a }
    body { color: #999; font: 14px/1.5 monospace; display: flex; justify-content: center; align-items: center; height: 100vh; margin: 0 }
    #_d { display: none }
  </style>
</head>
<body>
<div id="_l">unpacking\u2026</div>

<!-- base64-encoded gzip payload (76-char lines) -->
<pre id="_d">
${b64Lines}</pre>

<script>
(async () => {
  // 1. read base64 from the hidden <pre>, strip whitespace from line wrapping
  var b64 = document.getElementById('_d').textContent.replace(/\\s/g, '');

  // 2. decode base64 to binary
  var bytes = Uint8Array.from(atob(b64), c => c.charCodeAt(0));

  // 3. decompress gzip via DecompressionStream
  var stream = new Response(new Blob([bytes])).body.pipeThrough(new DecompressionStream('gzip'));
  var html = await new Response(stream).text();

  // 4. mark as packed (so the notebook knows it was loaded from a packed save)
  html = html.replace('<head>', '<head><meta name="auditable-packed">');

  // 5. replace the current page with the full notebook
  document.open();
  document.write(html);
  document.close();
})().catch(function(e) {
  document.getElementById('_l').textContent = 'error: ' + e.message;
});
<\/script>
</body>
</html>`;


    const fn = downloadHtml(loader, title);
    const kb = (loader.length / 1024).toFixed(0);
    setMsg('packed ' + fn + ' (' + kb + ' KB)', 'ok');
  } catch (e) {
    setMsg('pack failed: ' + e.message, 'err');
  }
}

function esc(s) {
  return s.replace(/"/g, '&quot;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
}

function exportAsTxt() {
  const title = $('#docTitle').value || 'untitled';
  const html = buildNotebookHtml();

  // extract notebook data from HTML
  const dataMatch = html.match(/<!--AUDITABLE-DATA\n([\s\S]*?)\nAUDITABLE-DATA-->/);
  let cells = [];
  if (dataMatch) {
    try { cells = JSON.parse(dataMatch[1]); } catch {}
  }

  const setMatch = html.match(/<!--AUDITABLE-SETTINGS\n([\s\S]*?)\nAUDITABLE-SETTINGS-->/);
  let settings = {};
  if (setMatch) {
    try { settings = JSON.parse(setMatch[1]); } catch {}
  }

  // extract module URLs (without sources — standalone export just records URLs)
  const modMatch = html.match(/<!--AUDITABLE-MODULES\n([\s\S]*?)\nAUDITABLE-MODULES-->/);
  let moduleUrls = [];
  if (modMatch) {
    try {
      const decoded = decodeModules(modMatch[1]);
      moduleUrls = Object.keys(decoded);
    } catch {}
  }

  // build /// formatted text
  const lines = ['/// auditable'];
  if (title && title !== 'untitled') {
    lines.push('/// title: ' + title);
  }
  const defaultSettings = { theme: 'dark', fontSize: 13, width: '860' };
  if (JSON.stringify(settings) !== JSON.stringify(defaultSettings)) {
    lines.push('/// settings: ' + JSON.stringify(settings));
  }
  for (const url of moduleUrls) {
    lines.push('/// module: ' + url);
  }
  for (const cell of cells) {
    lines.push('');
    const flags = cell.collapsed ? ' collapsed' : '';
    lines.push('/// ' + cell.type + flags);
    lines.push(cell.code || '');
  }
  const txt = lines.join('\n') + '\n';

  // download
  if (window.__AF_BRIDGE__) {
    window.parent.postMessage({ type: 'af:download', payload: { data: txt, filename: title.replace(/[^a-zA-Z0-9_-]/g, '_') + '.txt', mime: 'text/plain' } }, '*');
  } else {
    const blob = new Blob([txt], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = title.replace(/[^a-zA-Z0-9_-]/g, '_') + '.txt';
    a.click();
    URL.revokeObjectURL(url);
  }
  setMsg('exported .txt', 'ok');
}

function loadFromEmbed() {
  // look for embedded cell data in HTML comments
  const raw = document.body.innerHTML;

  // restore installed modules first (before cells run)
  const modMatch = raw.match(/<!--AUDITABLE-MODULES\n([\s\S]*?)\nAUDITABLE-MODULES-->/);
  if (modMatch) {
    try {
      window._installedModules = decodeModules(modMatch[1]);
    } catch (e) {
      console.error('Failed to parse installed modules:', e);
    }
  }

  // restore settings
  const setMatch = raw.match(/<!--AUDITABLE-SETTINGS\n([\s\S]*?)\nAUDITABLE-SETTINGS-->/);
  if (setMatch) {
    try {
      applySettings(JSON.parse(setMatch[1]));
    } catch (e) {
      console.error('Failed to parse settings:', e);
    }
  }

  // apply execution mode priority chain (localStorage > notebook > build default)
  const effectiveMode = resolveExecMode();
  const effectiveRun = resolveRunOnLoad();
  if (effectiveMode === 'manual') {
    S.autorun = false;
    const btn = document.getElementById('autorunBtn');
    const btnMobile = document.getElementById('autorunBtnMobile');
    if (btn) { btn.className = 'autorun-off'; btn.textContent = '\u2016'; btn.title = 'manual mode \u2014 only Run All or Ctrl+Enter'; }
    if (btnMobile) { btnMobile.className = 'autorun-off'; btnMobile.textContent = '\u2016'; }
    const sel = document.getElementById('setExecMode');
    if (sel) sel.value = 'manual';
  }

  const match = raw.match(/<!--AUDITABLE-DATA\n([\s\S]*?)\nAUDITABLE-DATA-->/);
  if (match) {
    try {
      const data = JSON.parse(match[1]);
      for (const c of data) {
        const cell = addCell(c.type, c.code);
        if (c.collapsed || isCollapsed(c.code)) cell.el.classList.add('collapsed');
      }
      // run after load (gated on resolved runOnLoad)
      if (effectiveRun === 'yes' && S.cells.some(c => c.type === 'code')) {
        setTimeout(runAll, 50);
      }
      return true;
    } catch (e) {
      console.error('Failed to parse embedded data:', e);
    }
  }
  return false;
}

// -- ui.js --

// ── STATUS ──

function estimateContentSize() {
  let modules = 0;
  for (const v of Object.values(window._installedModules || {})) {
    modules += typeof v === 'string' ? v.length : (v.source?.length || 0);
  }
  const cells = JSON.stringify(S.cells.map(c => ({ type: c.type, code: c.code }))).length;
  return modules + cells;
}

function estimateFileSize() {
  const style = document.querySelector('style')?.textContent.length || 0;
  const script = document.querySelector('script')?.textContent.length || 0;
  return style + script + estimateContentSize() + 2000; // ~2KB HTML boilerplate
}

function updateStatus() {
  const counts = { code: 0, md: 0, css: 0, html: 0 };
  for (const c of S.cells) if (counts[c.type] !== undefined) counts[c.type]++;
  const parts = [];
  for (const [t, n] of Object.entries(counts)) if (n > 0) parts.push(`${n} ${t}`);
  const statusText = parts.join(' \u00b7 ') || '0 cells';
  const totalBytes = estimateFileSize();
  const contentBytes = estimateContentSize();
  const useContent = window._sizeCompareRef === 'content';
  const displayBytes = useContent ? contentBytes : totalBytes;
  const sizeKB = displayBytes >= 1024 ? Math.round(displayBytes / 1024) : 1;
  const sizeText = '~' + sizeKB + ' KB' + (useContent ? ' content' : '');
  $('#statusCells').textContent = statusText;
  const compare = typeof sizeCompare === 'function' ? sizeCompare(displayBytes) : '';
  const sizeEl = document.getElementById('statusSize');
  if (sizeEl) sizeEl.textContent = (compare ? sizeText + ' \u00b7 ' + compare : sizeText) + ' \u00b7 ';
  // mirror to toolbar for mobile
  const toolbarStatus = document.getElementById('toolbarStatus');
  if (toolbarStatus) toolbarStatus.textContent = (compare || sizeText) + ' \u00b7 ' + statusText;
  updateInsertBars();
}

function updateInsertBars() {
  const nb = $('#notebook');
  // remove existing insert bars
  nb.querySelectorAll('.insert-bar').forEach(b => b.remove());

  // add one before first cell and between each pair
  for (let i = 0; i <= S.cells.length; i++) {
    const bar = document.createElement('div');
    bar.className = 'insert-bar';
    const afterId = i > 0 ? S.cells[i - 1].id : null;
    bar.innerHTML = `<div class="insert-btns">
      <button onclick="insertAt(${afterId},'code')">+ code</button>
      <button onclick="insertAt(${afterId},'md')">+ md</button>
      <button onclick="insertAt(${afterId},'css')">+ css</button>
      <button onclick="insertAt(${afterId},'html')">+ html</button>
    </div>`;
    if (i < S.cells.length) {
      S.cells[i].el.before(bar);
    } else {
      nb.appendChild(bar);
    }
  }
}

function insertAt(afterId, type) {
  let cell;
  if (afterId === null && S.cells.length > 0) {
    // insert before first cell
    cell = addCellWithUndo(type, '', null, S.cells[0].id);
  } else {
    cell = addCellWithUndo(type, '', afterId);
  }
  selectCell(cell.id);
  editCell(cell.id);
}

function setMsg(msg, cls = '') {
  const el = $('#statusMsg');
  el.textContent = msg;
  el.className = 'status-msg' + (cls ? ' ' + cls : '');
  if (cls) setTimeout(() => { el.textContent = ''; el.className = 'status-msg'; }, 3000);
}

// -- find.js --

// ── FIND / REPLACE ──

function openFind(showReplace) {
  const bar = $('#findBar');
  bar.style.display = 'flex';
  S.findActive = true;
  if (showReplace) bar.classList.add('show-replace');
  else bar.classList.remove('show-replace');
  const inp = $('#findInput');
  // pre-fill from textarea selection
  const active = document.activeElement;
  if (active && active.tagName === 'TEXTAREA') {
    const sel = active.value.substring(active.selectionStart, active.selectionEnd);
    if (sel && sel.indexOf('\n') === -1) inp.value = sel;
  }
  inp.focus();
  inp.select();
  if (inp.value) findComputeMatches();
}

function closeFind() {
  const bar = $('#findBar');
  bar.style.display = '';
  bar.classList.remove('show-replace');
  S.findActive = false;
  S.findQuery = '';
  S.findMatches = [];
  S.findCurrent = -1;
  $('#findCount').textContent = '';
  // remove all overlays
  document.querySelectorAll('.search-overlay').forEach(el => el.remove());
  document.querySelectorAll('.md-search-wrap').forEach(wrap => {
    const ta = wrap.querySelector('textarea');
    if (ta) wrap.parentNode.insertBefore(ta, wrap);
    wrap.remove();
  });
}

function escapeRegex(s) {
  return s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

function findComputeMatches() {
  const query = $('#findInput').value;
  S.findQuery = query;
  S.findMatches = [];
  if (!query) {
    S.findCurrent = -1;
    findUpdateCount();
    document.querySelectorAll('.search-overlay').forEach(el => el.remove());
    document.querySelectorAll('.md-search-wrap').forEach(wrap => {
      const ta = wrap.querySelector('textarea');
      if (ta) wrap.parentNode.insertBefore(ta, wrap);
      wrap.remove();
    });
    return;
  }
  const flags = S.findCase ? 'g' : 'gi';
  const pattern = S.findRegex ? query : escapeRegex(query);
  let re;
  try { re = new RegExp(pattern, flags); }
  catch (e) {
    S.findCurrent = -1;
    $('#findCount').textContent = 'bad regex';
    return;
  }

  for (const cell of S.cells) {
    let m;
    re.lastIndex = 0;
    while ((m = re.exec(cell.code)) !== null) {
      S.findMatches.push({ cellId: cell.id, index: m.index, length: m[0].length });
      if (m[0].length === 0) re.lastIndex++;  // prevent infinite loop on zero-length match
    }
  }
  // keep findCurrent in range
  if (S.findMatches.length === 0) S.findCurrent = -1;
  else if (S.findCurrent < 0 || S.findCurrent >= S.findMatches.length) S.findCurrent = 0;
  findUpdateOverlays();
  findUpdateCount();
}

function findNext() {
  if (!S.findMatches.length) return;
  S.findCurrent = (S.findCurrent + 1) % S.findMatches.length;
  findUpdateOverlays();
  findUpdateCount();
  findScrollToMatch();
}

function findPrev() {
  if (!S.findMatches.length) return;
  S.findCurrent = (S.findCurrent - 1 + S.findMatches.length) % S.findMatches.length;
  findUpdateOverlays();
  findUpdateCount();
  findScrollToMatch();
}

function findReplace() {
  if (S.findCurrent < 0 || S.findCurrent >= S.findMatches.length) return;
  const match = S.findMatches[S.findCurrent];
  const cell = S.cells.find(c => c.id === match.cellId);
  if (!cell) return;
  const replaceVal = $('#replaceInput').value;
  if (S.findRegex) {
    const flags = S.findCase ? '' : 'i';
    try {
      const re = new RegExp(S.findQuery, flags);
      const matched = cell.code.substring(match.index, match.index + match.length);
      const replaced = matched.replace(re, replaceVal);
      cell.code = cell.code.substring(0, match.index) + replaced + cell.code.substring(match.index + match.length);
    } catch (e) { return; }
  } else {
    cell.code = cell.code.substring(0, match.index) + replaceVal + cell.code.substring(match.index + match.length);
  }
  // update textarea
  const ta = cell.el.querySelector('textarea');
  if (ta) {
    ta.value = cell.code;
    ta.dispatchEvent(new Event('input'));
  }
  findComputeMatches();
}

function findReplaceAll() {
  const query = S.findQuery;
  if (!query) return;
  const replaceVal = $('#replaceInput').value;
  const flags = S.findCase ? 'g' : 'gi';
  const pattern = S.findRegex ? query : escapeRegex(query);
  let re;
  try { re = new RegExp(pattern, flags); }
  catch (e) { return; }
  let count = 0;
  for (const cell of S.cells) {
    const before = cell.code;
    if (S.findRegex) {
      cell.code = cell.code.replace(re, (...args) => { count++; return replaceVal.replace(/\$(\d+)/g, (_, n) => args[+n] != null ? args[+n] : ''); });
    } else {
      cell.code = cell.code.replace(re, () => { count++; return replaceVal; });
    }
    if (cell.code !== before) {
      const ta = cell.el.querySelector('textarea');
      if (ta) {
        ta.value = cell.code;
        ta.dispatchEvent(new Event('input'));
      }
    }
  }
  findComputeMatches();
}

function findUpdateOverlays() {
  // remove existing overlays
  document.querySelectorAll('.search-overlay').forEach(el => el.remove());
  // unwrap md-search-wraps
  document.querySelectorAll('.md-search-wrap').forEach(wrap => {
    const ta = wrap.querySelector('textarea');
    if (ta) wrap.parentNode.insertBefore(ta, wrap);
    wrap.remove();
  });

  if (!S.findQuery || !S.findMatches.length) return;

  // group matches by cellId
  const byCell = {};
  S.findMatches.forEach((m, i) => {
    if (!byCell[m.cellId]) byCell[m.cellId] = [];
    byCell[m.cellId].push({ ...m, globalIdx: i });
  });

  for (const cellId of Object.keys(byCell)) {
    const cell = S.cells.find(c => c.id === parseInt(cellId));
    if (!cell) continue;
    const matches = byCell[cellId];
    const code = cell.code;

    // build overlay content
    let html = '';
    let pos = 0;
    for (const m of matches) {
      // text before match
      html += escHtml(code.substring(pos, m.index));
      const cls = m.globalIdx === S.findCurrent ? 'search-match search-match-current' : 'search-match';
      html += `<mark class="${cls}">${escHtml(code.substring(m.index, m.index + m.length))}</mark>`;
      pos = m.index + m.length;
    }
    html += escHtml(code.substring(pos));

    const overlay = document.createElement('div');

    if (cell.type === 'md') {
      // markdown cells: wrap textarea in md-search-wrap
      overlay.className = 'search-overlay search-overlay-md';
      overlay.innerHTML = html;
      const editWrap = cell.el.querySelector('.cell-md-edit');
      const ta = editWrap.querySelector('textarea');
      let wrap = editWrap.querySelector('.md-search-wrap');
      if (!wrap) {
        wrap = document.createElement('div');
        wrap.className = 'md-search-wrap';
        ta.parentNode.insertBefore(wrap, ta);
        wrap.appendChild(ta);
      }
      wrap.appendChild(overlay);
      wireScrollSync(ta, overlay);
    } else {
      // code, css, html cells: insert in editor-wrap
      overlay.className = 'search-overlay';
      overlay.innerHTML = html;
      let editorWrap;
      if (cell.type === 'code') editorWrap = cell.el.querySelector('.cell-code .editor-wrap');
      else if (cell.type === 'css') editorWrap = cell.el.querySelector('.cell-css-edit .editor-wrap');
      else if (cell.type === 'html') editorWrap = cell.el.querySelector('.cell-html-edit .editor-wrap');
      if (editorWrap) {
        editorWrap.appendChild(overlay);
        const ta = editorWrap.querySelector('textarea');
        if (ta) wireScrollSync(ta, overlay);
      }
    }
  }
}

function wireScrollSync(ta, overlay) {
  if (ta._searchScrollWired) return;
  ta._searchScrollWired = true;
  ta.addEventListener('scroll', () => {
    const ov = ta.closest('.editor-wrap, .md-search-wrap');
    if (!ov) return;
    const so = ov.querySelector('.search-overlay');
    if (so) {
      so.scrollTop = ta.scrollTop;
      so.scrollLeft = ta.scrollLeft;
    }
  });
}

function findUpdateCount() {
  const el = $('#findCount');
  if (!S.findQuery) { el.textContent = ''; return; }
  if (S.findMatches.length === 0) { el.textContent = 'no results'; return; }
  el.textContent = `${S.findCurrent + 1}/${S.findMatches.length}`;
}

function findScrollToMatch() {
  if (S.findCurrent < 0) return;
  const match = S.findMatches[S.findCurrent];
  if (!match) return;
  const cell = S.cells.find(c => c.id === match.cellId);
  if (!cell) return;

  // open editor for non-code cells if needed
  if (cell.type === 'css') {
    const editWrap = cell.el.querySelector('.cell-css-edit');
    const view = cell.el.querySelector('.cell-css-view');
    if (editWrap.style.display === 'none') {
      const ta = editWrap.querySelector('textarea');
      editWrap.style.display = '';
      view.style.display = 'none';
      ta.value = cell.code;
      autoResize({ target: ta });
    }
  } else if (cell.type === 'html') {
    const editWrap = cell.el.querySelector('.cell-html-edit');
    const view = cell.el.querySelector('.cell-html-view');
    if (editWrap.style.display === 'none') {
      const ta = editWrap.querySelector('textarea');
      editWrap.style.display = '';
      view.style.display = 'none';
      ta.value = cell.code;
      autoResize({ target: ta });
    }
  } else if (cell.type === 'md') {
    const editWrap = cell.el.querySelector('.cell-md-edit');
    const view = cell.el.querySelector('.cell-md-view');
    if (editWrap.style.display === 'none') {
      const ta = editWrap.querySelector('textarea');
      editWrap.style.display = '';
      view.style.display = 'none';
      ta.value = cell.code;
      autoResize({ target: ta });
    }
  }

  // uncollapse if collapsed
  cell.el.classList.remove('collapsed');

  // scroll cell into view
  cell.el.scrollIntoView({ block: 'nearest', behavior: 'smooth' });

  // scroll textarea to match line
  const ta = cell.type === 'md'
    ? cell.el.querySelector('.cell-md-edit textarea')
    : cell.type === 'css'
    ? cell.el.querySelector('.cell-css-edit textarea')
    : cell.type === 'html'
    ? cell.el.querySelector('.cell-html-edit textarea')
    : cell.el.querySelector('textarea');
  if (ta) {
    const textBefore = cell.code.substring(0, match.index);
    const lineNum = textBefore.split('\n').length - 1;
    const lineHeight = parseFloat(getComputedStyle(ta).lineHeight) || 20;
    ta.scrollTop = Math.max(0, lineNum * lineHeight - ta.clientHeight / 2);
  }
}

function escHtml(s) {
  return s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
}

// ── EVENT WIRING ──
(function () {
  const findInput = $('#findInput');
  const replaceInput = $('#replaceInput');
  if (!findInput) return;

  findInput.addEventListener('input', () => findComputeMatches());

  findInput.addEventListener('keydown', (e) => {
    if (e.key === 'Enter' && e.shiftKey) { e.preventDefault(); findPrev(); }
    else if (e.key === 'Enter') { e.preventDefault(); findNext(); }
    else if (e.key === 'Escape') { e.preventDefault(); closeFind(); }
  });

  if (replaceInput) {
    replaceInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') { e.preventDefault(); findReplace(); }
      else if (e.key === 'Escape') { e.preventDefault(); closeFind(); }
    });
  }

  const nextBtn = $('#findNextBtn');
  const prevBtn = $('#findPrevBtn');
  const replBtn = $('#findReplaceBtn');
  const replAllBtn = $('#findReplaceAllBtn');
  const caseBtn = $('#findCaseBtn');
  const regexBtn = $('#findRegexBtn');
  const closeBtn = $('#findCloseBtn');

  if (nextBtn) nextBtn.addEventListener('click', findNext);
  if (prevBtn) prevBtn.addEventListener('click', findPrev);
  if (replBtn) replBtn.addEventListener('click', findReplace);
  if (replAllBtn) replAllBtn.addEventListener('click', findReplaceAll);
  if (closeBtn) closeBtn.addEventListener('click', closeFind);
  if (caseBtn) caseBtn.addEventListener('click', () => {
    S.findCase = !S.findCase;
    caseBtn.classList.toggle('active', S.findCase);
    findComputeMatches();
  });
  if (regexBtn) regexBtn.addEventListener('click', () => {
    S.findRegex = !S.findRegex;
    regexBtn.classList.toggle('active', S.findRegex);
    findComputeMatches();
  });

  // live recompute on edit — delegation
  let recomputeTimer = null;
  document.getElementById('notebook').addEventListener('input', (e) => {
    if (!S.findActive) return;
    if (e.target.tagName !== 'TEXTAREA') return;
    clearTimeout(recomputeTimer);
    recomputeTimer = setTimeout(findComputeMatches, 150);
  });
})();

// -- complete.js --

// ── AUTOCOMPLETE ENGINE ──

// well-known property lists for dot completion on builtins
const KNOWN_PROPS = {
  Math: ['abs','acos','asin','atan','atan2','ceil','cos','exp','floor','hypot',
         'log','log2','log10','max','min','pow','random','round','sign','sin',
         'sqrt','tan','trunc','PI','E','LN2','LN10'],
  Array: ['from','isArray','of'],
  Object: ['keys','values','entries','assign','freeze','create','defineProperty','fromEntries','hasOwn'],
  JSON: ['parse','stringify'],
  console: ['log','warn','error','info','table','time','timeEnd','clear'],
  Promise: ['all','allSettled','any','race','resolve','reject'],
  Number: ['isFinite','isInteger','isNaN','parseFloat','parseInt','MAX_SAFE_INTEGER','MIN_SAFE_INTEGER','EPSILON'],
  String: ['fromCharCode','fromCodePoint','raw'],
  ui: ['display','print','canvas','table','slider','dropdown','checkbox','textInput'],
  std: ['csv','fetchJSON','sum','mean','median','extent','bin','linspace',
        'unique','zip','cross','file','download','el','copy','fmt'],
};

// common prototype methods by type
const PROTO_PROPS = {
  array: ['push','pop','shift','unshift','splice','slice','concat','join','reverse',
          'sort','map','filter','reduce','reduceRight','find','findIndex','indexOf',
          'includes','every','some','flat','flatMap','fill','forEach','at','length'],
  string: ['charAt','charCodeAt','codePointAt','concat','endsWith','includes',
           'indexOf','lastIndexOf','match','matchAll','padEnd','padStart','repeat',
           'replace','replaceAll','search','slice','split','startsWith','substring',
           'toLowerCase','toUpperCase','trim','trimEnd','trimStart','at','length'],
  number: ['toFixed','toPrecision','toString','valueOf'],
};

// ── BUILTIN HELP (injected by build.js from src/builtins.json) ──

const BUILTIN_HELP = {
  "ui.display": {
    "sig": "ui.display(...values)",
    "desc": "output values to cell"
  },
  "ui.canvas": {
    "sig": "ui.canvas(w?, h?)",
    "desc": "create/reuse canvas (default 400\u00d7300)"
  },
  "ui.table": {
    "sig": "ui.table(data, columns?)",
    "desc": "render array of objects as table"
  },
  "ui.slider": {
    "sig": "ui.slider(label, default?, {min,max,step,onInput,onChange}?)",
    "desc": "range input \u2014 reactive, or callback via onInput/onChange"
  },
  "ui.dropdown": {
    "sig": "ui.dropdown(label, options, default?, {onInput,onChange}?)",
    "desc": "select menu \u2014 reactive, or callback via onInput/onChange"
  },
  "ui.checkbox": {
    "sig": "ui.checkbox(label, default?, {onInput,onChange}?)",
    "desc": "toggle \u2014 reactive, or callback via onInput/onChange"
  },
  "ui.textInput": {
    "sig": "ui.textInput(label, default?, {onInput,onChange}?)",
    "desc": "text field \u2014 reactive, or callback via onInput/onChange"
  },
  "std.csv": {
    "sig": "std.csv(text, {separator?, typed?}?)",
    "desc": "parse CSV text to array of objects"
  },
  "std.fetchJSON": {
    "sig": "std.fetchJSON(url)",
    "desc": "fetch URL and parse JSON"
  },
  "std.sum": {
    "sig": "std.sum(arr, fn?)",
    "desc": "sum array values"
  },
  "std.mean": {
    "sig": "std.mean(arr, fn?)",
    "desc": "arithmetic mean"
  },
  "std.median": {
    "sig": "std.median(arr, fn?)",
    "desc": "median value"
  },
  "std.extent": {
    "sig": "std.extent(arr, fn?)",
    "desc": "returns [min, max]"
  },
  "std.bin": {
    "sig": "std.bin(arr, n?, fn?)",
    "desc": "histogram bins (default 10)"
  },
  "std.linspace": {
    "sig": "std.linspace(start, stop, n)",
    "desc": "evenly-spaced numbers"
  },
  "std.unique": {
    "sig": "std.unique(arr, fn?)",
    "desc": "unique values with optional key fn"
  },
  "std.zip": {
    "sig": "std.zip(...arrays)",
    "desc": "zip arrays together"
  },
  "std.cross": {
    "sig": "std.cross(...arrays)",
    "desc": "cartesian product"
  },
  "std.file": {
    "sig": "std.file(accept?)",
    "desc": "open file picker"
  },
  "std.download": {
    "sig": "std.download(data, filename, mimeType?)",
    "desc": "download data as file"
  },
  "std.el": {
    "sig": "std.el(tag, attrs?, ...children)",
    "desc": "create DOM element"
  },
  "std.copy": {
    "sig": "std.copy(text)",
    "desc": "copy text to clipboard"
  },
  "std.fmt": {
    "sig": "std.fmt(number, {decimals?, prefix?, suffix?}?)",
    "desc": "format number to string"
  },
  "print": {
    "sig": "print(...values)",
    "desc": "output values to cell (alias for ui.display)"
  },
  "load": {
    "sig": "load(url)",
    "desc": "import ES module (cached). @std, @python supported."
  },
  "install": {
    "sig": "install(url)",
    "desc": "fetch & embed module for offline"
  },
  "invalidation": {
    "sig": "invalidation",
    "desc": "promise \u2014 resolves when cell re-runs"
  },
  "atra": {
    "sig": "atra`...` or atra({imports})`...`",
    "desc": "compile Fortran/Pascal to Wasm (load ext/atra/index.js)"
  }
};

// ── FUZZY MATCHING ──

// returns { score, indices } or null if no match
// indices = positions in `text` that matched characters from `query`
function fuzzyMatch(query, text) {
  const qLen = query.length;
  const tLen = text.length;
  if (qLen === 0) return { score: 0, indices: [] };
  if (qLen > tLen) return null;

  const qLower = query.toLowerCase();
  const tLower = text.toLowerCase();

  // fast check: all query chars exist in text in order
  let qi = 0;
  for (let ti = 0; ti < tLen && qi < qLen; ti++) {
    if (qLower[qi] === tLower[ti]) qi++;
  }
  if (qi < qLen) return null;

  // find best match using a greedy approach that prefers word boundaries
  // word boundaries: start of string, after _ or $, camelCase transitions
  const indices = [];
  qi = 0;

  // first pass: try to match at word boundaries
  const boundaryIndices = [];
  let bqi = 0;
  for (let ti = 0; ti < tLen && bqi < qLen; ti++) {
    if (qLower[bqi] !== tLower[ti]) continue;
    const isBoundary = ti === 0
      || text[ti - 1] === '_' || text[ti - 1] === '$'
      || (text[ti] >= 'A' && text[ti] <= 'Z' && (ti === 0 || text[ti - 1] < 'A' || text[ti - 1] > 'Z'));
    if (isBoundary) {
      boundaryIndices.push(ti);
      bqi++;
    }
  }

  if (bqi === qLen) {
    // all chars matched at boundaries — use those indices
    indices.push(...boundaryIndices);
  } else {
    // fallback: greedy left-to-right match, prefer consecutive runs
    qi = 0;
    for (let ti = 0; ti < tLen && qi < qLen; ti++) {
      if (qLower[qi] === tLower[ti]) {
        indices.push(ti);
        qi++;
      }
    }
  }

  // score the match
  let score = 0;

  // bonus for matching at start of string
  if (indices[0] === 0) score += 10;

  // bonus for consecutive characters
  for (let i = 1; i < indices.length; i++) {
    if (indices[i] === indices[i - 1] + 1) score += 5;
  }

  // bonus for word boundary matches
  for (const idx of indices) {
    if (idx === 0) { score += 3; continue; }
    const prev = text[idx - 1];
    if (prev === '_' || prev === '$') { score += 3; continue; }
    if (text[idx] >= 'A' && text[idx] <= 'Z' && (prev < 'A' || prev > 'Z')) score += 3;
  }

  // bonus for exact case match
  for (let i = 0; i < indices.length; i++) {
    if (query[i] === text[indices[i]]) score += 1;
  }

  // penalty for spread-out matches (large gaps between indices)
  const span = indices[indices.length - 1] - indices[0];
  score -= span * 0.5;

  // slight penalty for longer names (prefer shorter completions)
  score -= tLen * 0.1;

  return { score, indices };
}

// determine cursor context: is it inside a string or comment?
function cursorContext(code, cursor) {
  let i = 0;
  while (i < cursor) {
    const ch = code[i];
    // single-line comment
    if (ch === '/' && code[i + 1] === '/') {
      const nl = code.indexOf('\n', i);
      if (nl === -1 || nl >= cursor) return 'comment';
      i = nl + 1;
      continue;
    }
    // block comment
    if (ch === '/' && code[i + 1] === '*') {
      const end = code.indexOf('*/', i + 2);
      if (end === -1 || end + 2 > cursor) return 'comment';
      i = end + 2;
      continue;
    }
    // single-quoted string
    if (ch === "'") {
      i++;
      while (i < code.length) {
        if (code[i] === '\\') { i += 2; continue; }
        if (code[i] === "'") { i++; break; }
        if (i >= cursor) return 'string';
        i++;
      }
      continue;
    }
    // double-quoted string
    if (ch === '"') {
      i++;
      while (i < code.length) {
        if (code[i] === '\\') { i += 2; continue; }
        if (code[i] === '"') { i++; break; }
        if (i >= cursor) return 'string';
        i++;
      }
      continue;
    }
    // template literal (possibly tagged)
    if (ch === '`') {
      // look back for a tag name: identifier immediately before the backtick,
      // or curried form: identifier(...) before the backtick
      let tagName = null;
      if (i > 0 && typeof window !== 'undefined' && window._taggedLanguages) {
        let te = i;
        let ts = te;
        // direct form: ident`
        while (ts > 0 && /\w/.test(code[ts - 1])) ts--;
        if (ts < te) {
          const candidate = code.slice(ts, te);
          if (window._taggedLanguages[candidate]) tagName = candidate;
        }
        // curried form: ident(...)`
        if (!tagName && code[i - 1] === ')') {
          let p = i - 2, depth = 1;
          while (p >= 0 && depth > 0) {
            if (code[p] === ')') depth++;
            else if (code[p] === '(') depth--;
            p--;
          }
          // p now points one before the (
          let ne = p + 1;
          let ns = ne;
          while (ns > 0 && /\w/.test(code[ns - 1])) ns--;
          if (ns < ne) {
            const candidate = code.slice(ns, ne);
            if (window._taggedLanguages[candidate]) tagName = candidate;
          }
        }
      }

      i++;
      let depth = 0;
      while (i < code.length) {
        if (code[i] === '\\') { i += 2; continue; }
        if (code[i] === '$' && code[i + 1] === '{') {
          depth++;
          i += 2;
          // inside ${...} — this is code context
          let braces = 1;
          while (i < code.length && braces > 0) {
            if (code[i] === '{') braces++;
            else if (code[i] === '}') { braces--; if (braces === 0) break; }
            if (i >= cursor) return 'code'; // inside template expression = code
            i++;
          }
          if (i >= cursor) return 'code';
          i++; // skip closing }
          continue;
        }
        if (code[i] === '`') { i++; break; }
        if (i >= cursor) return tagName ? { type: 'tagged', lang: tagName } : 'string';
        i++;
      }
      continue;
    }
    i++;
  }
  return 'code';
}

// extract the word being typed at cursor position
function extractPrefix(code, cursor) {
  let end = cursor;
  let start = cursor;
  while (start > 0 && /[a-zA-Z0-9_$]/.test(code[start - 1])) start--;
  return { prefix: code.slice(start, end), start };
}

// detect dot access: returns the expression before the dot, or null
function detectDot(code, cursor) {
  // cursor is right after a dot or after dot + partial word
  const before = code.slice(0, cursor);
  // match patterns like "identifier." or "identifier.par" at end
  const m = before.match(/([a-zA-Z_$][\w$]*)\.\s*([a-zA-Z_$][\w$]*)?$/);
  if (m) return { obj: m[1], prefix: m[2] || '' };
  return null;
}

function getPropsForValue(val) {
  if (val == null) return [];
  const props = new Set();
  // own properties
  const own = Object.getOwnPropertyNames(val);
  for (const p of own) {
    if (/^[a-zA-Z_$]/.test(p)) props.add(p);
  }
  // prototype chain (1 level)
  const proto = Object.getPrototypeOf(val);
  if (proto && proto !== Object.prototype) {
    try {
      const pNames = Object.getOwnPropertyNames(proto);
      for (const p of pNames) {
        if (p !== 'constructor' && /^[a-zA-Z_$]/.test(p)) props.add(p);
      }
    } catch {}
  }
  return [...props];
}

function getCompletions(code, cursor, cellId) {
  const ctx = cursorContext(code, cursor);

  // tagged template literal — delegate to extension completions
  if (ctx && typeof ctx === 'object' && ctx.type === 'tagged') {
    const lang = typeof window !== 'undefined' && window._taggedLanguages
      && window._taggedLanguages[ctx.lang];
    if (lang && lang.completions) {
      const { prefix, start } = extractPrefix(code, cursor);
      if (!prefix) return { prefix: '', items: [] };
      const extItems = lang.completions(prefix);
      // score and annotate items
      const items = [];
      for (const it of extItems) {
        const m = fuzzyMatch(prefix, it.text);
        if (m) items.push({ text: it.text, kind: it.kind || 'var', score: m.score, indices: m.indices });
      }
      items.sort((a, b) => b.score - a.score || a.text.localeCompare(b.text));
      return { prefix, items: items.slice(0, 30) };
    }
    return { prefix: '', items: [] };
  }

  if (ctx !== 'code') return { prefix: '', items: [] };

  // check for dot completion
  const dot = detectDot(code, cursor);
  if (dot) {
    const items = [];
    const prefix = dot.prefix;
    let propList = [];

    // check known builtins
    if (KNOWN_PROPS[dot.obj]) {
      propList = KNOWN_PROPS[dot.obj];
    } else if (dot.obj in S.scope) {
      // live value inspection
      const val = S.scope[dot.obj];
      if (val != null) {
        propList = getPropsForValue(val);
        // also add type-based suggestions
        if (Array.isArray(val)) propList = [...new Set([...propList, ...PROTO_PROPS.array])];
        else if (typeof val === 'string') propList = [...new Set([...propList, ...PROTO_PROPS.string])];
        else if (typeof val === 'number') propList = [...new Set([...propList, ...PROTO_PROPS.number])];
      }
    }

    for (const p of propList) {
      if (!prefix) {
        items.push({ text: p, kind: 'prop', score: 0, indices: [] });
        continue;
      }
      const m = fuzzyMatch(prefix, p);
      if (m) items.push({ text: p, kind: 'prop', score: m.score, indices: m.indices });
    }

    items.sort((a, b) => b.score - a.score || a.text.localeCompare(b.text));
    return { prefix, items: items.slice(0, 30) };
  }

  // word prefix completion
  const { prefix, start } = extractPrefix(code, cursor);
  if (!prefix) return { prefix: '', items: [] };

  const items = [];
  const seen = new Set();

  // collect candidates from all sources with their kind
  const candidates = [];

  // 1. scope variables
  for (const name of Object.keys(S.scope)) {
    if (!seen.has(name)) { seen.add(name); candidates.push({ text: name, kind: 'var' }); }
  }

  // 2. own cell defines
  const cell = S.cells.find(c => c.id === cellId);
  if (cell && cell.defines) {
    for (const name of cell.defines) {
      if (!seen.has(name)) { seen.add(name); candidates.push({ text: name, kind: 'def' }); }
    }
  }

  // 3. builtin functions (with help detail)
  for (const name of Object.keys(BUILTIN_HELP)) {
    if (!seen.has(name)) {
      seen.add(name);
      const h = BUILTIN_HELP[name];
      candidates.push({ text: name, kind: 'fn', detail: h.sig });
    }
  }

  // 4. JS builtins
  for (const name of JS_BUILTINS) {
    if (!seen.has(name)) { seen.add(name); candidates.push({ text: name, kind: 'const' }); }
  }

  // 5. JS keywords (min 2 chars to avoid noise)
  if (prefix.length >= 2) {
    for (const name of JS_KEYWORDS) {
      if (!seen.has(name)) { seen.add(name); candidates.push({ text: name, kind: 'kw' }); }
    }
  }

  // fuzzy match all candidates
  for (const c of candidates) {
    if (c.text === prefix) continue; // skip exact match (already typed)
    const m = fuzzyMatch(prefix, c.text);
    if (m) {
      const item = { text: c.text, kind: c.kind, score: m.score, indices: m.indices };
      if (c.detail) item.detail = c.detail;
      items.push(item);
    }
  }

  // sort by score descending, then alphabetical
  items.sort((a, b) => b.score - a.score || a.text.localeCompare(b.text));

  return { prefix, items: items.slice(0, 30) };
}

// ── TEXTAREA ADAPTER ──

const KIND_LABELS = { var: 'v', fn: 'f', kw: 'k', const: 'c', prop: 'p', def: 'd' };

let activeMenu = null;
let activeState = null;
let activeSigHint = null;

function dismissAutocomplete() {
  if (activeMenu) {
    activeMenu.remove();
    activeMenu = null;
    activeState = null;
  }
}

function dismissSigHint() {
  if (activeSigHint) {
    activeSigHint.remove();
    activeSigHint = null;
  }
}

// detect if cursor is inside a function call's arguments for a known builtin
function detectCallContext(code, cursor) {
  // scan backwards from cursor to find an unmatched (
  let depth = 0;
  let i = cursor - 1;
  while (i >= 0) {
    const ch = code[i];
    if (ch === ')') depth++;
    else if (ch === '(') {
      if (depth === 0) {
        // found the opening paren — extract the function name before it (including dot for ui.slider etc.)
        let end = i;
        let start = end - 1;
        while (start >= 0 && /[a-zA-Z0-9_$.]/.test(code[start])) start--;
        start++;
        const fnName = code.slice(start, end);
        if (BUILTIN_HELP[fnName]) {
          // figure out which parameter we're on by counting commas at depth 0
          let paramIdx = 0;
          let d = 0;
          for (let j = i + 1; j < cursor; j++) {
            if (code[j] === '(' || code[j] === '[' || code[j] === '{') d++;
            else if (code[j] === ')' || code[j] === ']' || code[j] === '}') d--;
            else if (code[j] === ',' && d === 0) paramIdx++;
          }
          return { fnName, parenPos: i, paramIdx };
        }
        return null;
      }
      depth--;
    }
    i--;
  }
  return null;
}

function showSigHint(ta) {
  const code = ta.value;
  const cursor = ta.selectionStart;
  if (ta.selectionStart !== ta.selectionEnd) { dismissSigHint(); return; }

  const ctx = cursorContext(code, cursor);
  if (ctx !== 'code') { dismissSigHint(); return; }

  const call = detectCallContext(code, cursor);
  if (!call) { dismissSigHint(); return; }

  const wrap = ta.closest('.editor-wrap');
  if (!wrap) { dismissSigHint(); return; }

  const help = BUILTIN_HELP[call.fnName];
  const pos = measureCursorPos(ta, call.parenPos);

  if (!activeSigHint) {
    activeSigHint = document.createElement('div');
    activeSigHint.className = 'ac-sig-hint';
    wrap.appendChild(activeSigHint);
  } else if (activeSigHint.parentElement !== wrap) {
    activeSigHint.remove();
    wrap.appendChild(activeSigHint);
  }

  // highlight current parameter in the signature
  const sigHtml = highlightParam(help.sig, call.paramIdx);
  activeSigHint.innerHTML = `<span class="ac-sig-fn">${sigHtml}</span><span class="ac-sig-desc">${esc(help.desc)}</span>`;

  const cs = getComputedStyle(ta);
  const padLeft = parseFloat(cs.paddingLeft) || 0;
  const padTop = parseFloat(cs.paddingTop) || 0;
  const lineHeight = parseFloat(cs.lineHeight) || parseFloat(cs.fontSize) * 1.5;

  const left = pos.x + padLeft - ta.scrollLeft;

  // place above the current line; pos.y is bottom of the line
  // so subtract lineHeight (to get top of line) then the hint's own height
  activeSigHint.style.left = left + 'px';
  activeSigHint.style.top = '0px'; // render off-screen first to measure
  activeSigHint.style.visibility = 'hidden';
  const hintH = activeSigHint.offsetHeight || lineHeight;
  activeSigHint.style.visibility = '';

  let top = pos.y + padTop - ta.scrollTop - lineHeight - hintH;

  // if it would go above the editor, show below the current line instead
  const wrapRect = wrap.getBoundingClientRect();
  const taRect = ta.getBoundingClientRect();
  const absTop = taRect.top + top;
  if (absTop < wrapRect.top) {
    top = pos.y + padTop - ta.scrollTop;
  }

  activeSigHint.style.top = top + 'px';
}

function highlightParam(sig, paramIdx) {
  // find the params inside parens
  const openParen = sig.indexOf('(');
  if (openParen === -1) return esc(sig);
  const closeParen = sig.lastIndexOf(')');
  if (closeParen === -1) return esc(sig);

  const before = sig.slice(0, openParen + 1);
  const params = sig.slice(openParen + 1, closeParen);
  const after = sig.slice(closeParen);

  // split on commas (respecting nested braces)
  const parts = [];
  let depth = 0;
  let start = 0;
  for (let i = 0; i < params.length; i++) {
    if (params[i] === '{' || params[i] === '(' || params[i] === '[') depth++;
    else if (params[i] === '}' || params[i] === ')' || params[i] === ']') depth--;
    else if (params[i] === ',' && depth === 0) {
      parts.push(params.slice(start, i));
      start = i + 1;
    }
  }
  parts.push(params.slice(start));

  let html = esc(before);
  for (let i = 0; i < parts.length; i++) {
    if (i > 0) html += esc(',');
    if (i === paramIdx) {
      html += '<span class="ac-sig-active">' + esc(parts[i]) + '</span>';
    } else {
      html += esc(parts[i]);
    }
  }
  html += esc(after);
  return html;
}

function measureCursorPos(ta, cursor) {
  const text = ta.value.substring(0, cursor);
  const lines = text.split('\n');
  const lineNum = lines.length - 1;
  const colText = lines[lineNum];

  // measure column offset using a hidden span
  let measurer = ta._acMeasurer;
  if (!measurer) {
    measurer = document.createElement('span');
    measurer.style.cssText = 'position:absolute;visibility:hidden;white-space:pre;pointer-events:none;';
    document.body.appendChild(measurer);
    ta._acMeasurer = measurer;
  }
  const cs = getComputedStyle(ta);
  measurer.style.font = cs.font;
  measurer.style.fontSize = cs.fontSize;
  measurer.style.fontFamily = cs.fontFamily;
  measurer.style.letterSpacing = cs.letterSpacing;
  measurer.style.tabSize = cs.tabSize;
  measurer.textContent = colText;

  const lineHeight = parseFloat(cs.lineHeight) || parseFloat(cs.fontSize) * 1.5;
  const x = measurer.offsetWidth;
  const y = (lineNum + 1) * lineHeight;

  return { x, y, lineHeight };
}

function highlightMatches(text, indices) {
  if (!indices || !indices.length) return esc(text);
  const set = new Set(indices);
  let html = '';
  let inMatch = false;
  for (let i = 0; i < text.length; i++) {
    if (set.has(i)) {
      if (!inMatch) { html += '<span class="ac-match">'; inMatch = true; }
      html += esc(text[i]);
    } else {
      if (inMatch) { html += '</span>'; inMatch = false; }
      html += esc(text[i]);
    }
  }
  if (inMatch) html += '</span>';
  return html;
}

function renderMenu(items, prefix, selectedIdx) {
  let html = '';
  const max = Math.min(items.length, 30);
  for (let i = 0; i < max; i++) {
    const it = items[i];
    const cls = i === selectedIdx ? 'ac-item active' : 'ac-item';
    const kindCls = 'ac-kind ac-kind-' + it.kind;
    const label = KIND_LABELS[it.kind] || '?';
    const textHtml = highlightMatches(it.text, it.indices);
    const detailHtml = it.detail ? `<span class="ac-detail">${esc(it.detail)}</span>` : '';
    html += `<div class="${cls}" data-index="${i}"><span class="${kindCls}">${label}</span><span class="ac-text">${textHtml}</span>${detailHtml}</div>`;
  }
  return html;
}

function esc(s) {
  return s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
}

function showMenu(ta, cellId) {
  const code = ta.value;
  const cursor = ta.selectionStart;
  if (ta.selectionStart !== ta.selectionEnd) { dismissAutocomplete(); return; }

  const result = getCompletions(code, cursor, cellId);
  if (!result.items.length) { dismissAutocomplete(); return; }

  const wrap = ta.closest('.editor-wrap');
  if (!wrap) { dismissAutocomplete(); return; }

  const pos = measureCursorPos(ta, cursor);

  if (!activeMenu) {
    activeMenu = document.createElement('div');
    activeMenu.className = 'ac-menu';
    wrap.appendChild(activeMenu);
  } else if (activeMenu.parentElement !== wrap) {
    activeMenu.remove();
    wrap.appendChild(activeMenu);
  }

  activeState = {
    items: result.items,
    prefix: result.prefix,
    selected: 0,
    ta,
    cellId,
    cursorStart: cursor - result.prefix.length
  };

  activeMenu.innerHTML = renderMenu(result.items, result.prefix, 0);

  // position: account for padding and scroll
  const cs = getComputedStyle(ta);
  const padLeft = parseFloat(cs.paddingLeft) || 0;
  const padTop = parseFloat(cs.paddingTop) || 0;

  const left = pos.x + padLeft - ta.scrollLeft;
  const top = pos.y + padTop - ta.scrollTop;

  activeMenu.style.left = left + 'px';
  activeMenu.style.top = top + 'px';

  // flip above if it would overflow viewport
  const menuRect = activeMenu.getBoundingClientRect();
  if (menuRect.bottom > window.innerHeight - 20) {
    activeMenu.style.top = (top - pos.lineHeight - activeMenu.offsetHeight) + 'px';
  }

  // mouse interaction
  activeMenu.onmousedown = (e) => {
    e.preventDefault(); // don't blur textarea
    const item = e.target.closest('.ac-item');
    if (item) {
      activeState.selected = parseInt(item.dataset.index);
      acceptCompletion();
    }
  };
}

function updateSelection(idx) {
  if (!activeMenu || !activeState) return;
  activeState.selected = idx;
  const items = activeMenu.querySelectorAll('.ac-item');
  items.forEach((el, i) => el.classList.toggle('active', i === idx));
  // scroll into view
  if (items[idx]) items[idx].scrollIntoView({ block: 'nearest' });
}

function acceptCompletion() {
  if (!activeState) return;
  const { items, selected, ta, prefix, cursorStart } = activeState;
  const item = items[selected];
  if (!item) return;

  ta.focus();
  ta.selectionStart = cursorStart;
  ta.selectionEnd = cursorStart + prefix.length;
  document.execCommand('insertText', false, item.text);

  dismissAutocomplete();
  ta.dispatchEvent(new Event('input'));
}

function attachAutocomplete(textarea, cellId) {
  // keydown handler — must be added BEFORE handleTab so stopImmediatePropagation works
  textarea.addEventListener('keydown', (e) => {
    // Ctrl+Shift+Space — manual signature hint trigger
    if (e.key === ' ' && (e.ctrlKey || e.metaKey) && e.shiftKey) {
      e.preventDefault();
      e.stopImmediatePropagation();
      dismissAutocomplete();
      showSigHint(textarea);
      return;
    }

    if (!activeMenu || !activeState) return;

    if (e.key === 'ArrowDown') {
      e.preventDefault();
      e.stopImmediatePropagation();
      const next = (activeState.selected + 1) % activeState.items.length;
      updateSelection(next);
      return;
    }
    if (e.key === 'ArrowUp') {
      e.preventDefault();
      e.stopImmediatePropagation();
      const prev = (activeState.selected - 1 + activeState.items.length) % activeState.items.length;
      updateSelection(prev);
      return;
    }
    if (e.key === 'Tab' || e.key === 'Enter') {
      e.preventDefault();
      e.stopImmediatePropagation();
      acceptCompletion();
      return;
    }
    if (e.key === 'Escape') {
      e.preventDefault();
      e.stopImmediatePropagation();
      dismissAutocomplete();
      dismissSigHint();
      return;
    }
  });

  // input handler — show/update completions + signature hints
  textarea.addEventListener('input', () => {
    // use a microtask so the value is settled
    Promise.resolve().then(() => {
      showMenu(textarea, cellId);
      // show sig hint only when autocomplete menu is not visible
      if (!activeMenu) showSigHint(textarea);
      else dismissSigHint();
    });
  });

  // dismiss on blur
  textarea.addEventListener('blur', () => {
    // delay so mousedown on menu can fire first
    setTimeout(() => { dismissAutocomplete(); dismissSigHint(); }, 150);
  });

  // dismiss on scroll (position goes stale)
  textarea.addEventListener('scroll', () => {
    dismissAutocomplete();
    dismissSigHint();
  });
}

// -- keyboard.js --

// ── KEYBOARD / SELECTION ──

function addCellWithUndo(type, code, afterId, beforeId) {
  const cell = addCell(type, code, afterId, beforeId);
  S.trash.push({ action: 'add', id: cell.id });
  return cell;
}

function deleteCellWithUndo(id) {
  const idx = S.cells.findIndex(c => c.id === id);
  if (idx < 0) return;
  const cell = S.cells[idx];
  const afterId = idx > 0 ? S.cells[idx - 1].id : null;
  const beforeId = afterId === null && idx < S.cells.length - 1 ? S.cells[idx + 1].id : null;
  S.trash.push({ action: 'delete', type: cell.type, code: cell.code, afterId, beforeId, collapsed: !!cell.el.classList.contains('collapsed') });
  deleteCell(id);
  setMsg('deleted cell (z to undo)', 'ok');
}

function undo() {
  if (!S.trash.length) { setMsg('nothing to undo', ''); return; }
  const entry = S.trash.pop();

  if (entry.action === 'add') {
    // undo add = delete the cell (without pushing to undo stack)
    deleteCell(entry.id);
    setMsg('undid add', 'ok');
  } else {
    // undo delete = restore the cell
    const { type, code, afterId, beforeId, collapsed } = entry;
    const validAfter = afterId !== null && S.cells.find(c => c.id === afterId) ? afterId : null;
    const validBefore = beforeId !== null && S.cells.find(c => c.id === beforeId) ? beforeId : null;
    const newCell = addCell(type, code, validAfter, validBefore);
    if (collapsed) newCell.el.classList.add('collapsed');
    selectCell(newCell.id);
    if ((type === 'code' || type === 'html') && S.cells.some(c => c.type === 'code' || c.type === 'html')) runAll();
    setMsg('restored cell', 'ok');
  }
}

function selectCell(id, scroll) {
  // deselect previous
  $$('.cell.selected').forEach(el => el.classList.remove('selected'));
  S.selectedId = id;
  if (id === null) return;
  const cell = S.cells.find(c => c.id === id);
  if (cell) {
    cell.el.classList.add('selected');
    if (scroll) cell.el.scrollIntoView({ block: 'nearest' });
  }
}

function getEditingCell() {
  const active = document.activeElement;
  if (active && active.tagName === 'TEXTAREA') {
    const cellEl = active.closest('.cell');
    if (cellEl) {
      const id = parseInt(cellEl.dataset.id);
      return S.cells.find(c => c.id === id) || null;
    }
  }
  return null;
}

function editCell(id) {
  const cell = S.cells.find(c => c.id === id);
  if (!cell) return;
  selectCell(id);

  if (cell.type === 'md') {
    // open md editor
    const view = cell.el.querySelector('.cell-md-view');
    const editWrap = cell.el.querySelector('.cell-md-edit');
    const ta = cell.el.querySelector('.cell-md-edit textarea');
    editWrap.style.display = '';
    view.style.display = 'none';
    ta.value = cell.code;
    ta.focus();
    autoResize({ target: ta });
  } else if (cell.type === 'css') {
    // open css editor
    const view = cell.el.querySelector('.cell-css-view');
    const editWrap = cell.el.querySelector('.cell-css-edit');
    const ta = cell.el.querySelector('.cell-css-edit textarea');
    editWrap.style.display = '';
    view.style.display = 'none';
    ta.value = cell.code;
    ta.focus();
    autoResize({ target: ta });
  } else if (cell.type === 'html') {
    // open html editor
    const view = cell.el.querySelector('.cell-html-view');
    const editWrap = cell.el.querySelector('.cell-html-edit');
    const ta = cell.el.querySelector('.cell-html-edit textarea');
    editWrap.style.display = '';
    view.style.display = 'none';
    ta.value = cell.code;
    ta.focus();
    autoResize({ target: ta });
  } else {
    cell.el.querySelector('textarea').focus();
  }
}

function exitEdit() {
  const active = document.activeElement;
  if (active && active.tagName === 'TEXTAREA') {
    active.blur();
  }
}

function runSelected() {
  if (S.selectedId === null && S.cells.length) selectCell(S.cells[0].id);
  const cell = S.cells.find(c => c.id === S.selectedId);
  if (!cell) return;
  if (cell.type === 'code') {
    cell.code = cell.el.querySelector('.cell-code textarea').value;
    runDAG([cell.id]);
  } else if (cell.type === 'html') {
    renderHtmlCell(cell);
  }
}

// ── MOBILE TRAY TOGGLES ──

function closeAllTrays() {
  document.querySelectorAll('.action-add-tray.open, .action-more-tray.open, .cell-type-picker.open, .cell-insert-picker.open').forEach(el => el.classList.remove('open'));
}

function toggleToolbarMenu() {
  const menu = document.querySelector('.toolbar-overflow');
  if (!menu) return;
  menu.classList.toggle('open');
}

function toggleAddTray() {
  const tray = document.querySelector('.action-add-tray');
  if (!tray) return;
  const wasOpen = tray.classList.contains('open');
  closeAllTrays();
  if (!wasOpen) tray.classList.add('open');
}

function toggleMoreTray() {
  const tray = document.querySelector('.action-more-tray');
  if (!tray) return;
  const wasOpen = tray.classList.contains('open');
  closeAllTrays();
  if (!wasOpen) tray.classList.add('open');
}

function showInsertPicker(id, dir) {
  closeAllTrays();
  const cell = S.cells.find(c => c.id === id);
  if (!cell) return;
  document.querySelectorAll('.cell-insert-picker').forEach(el => el.remove());
  const picker = document.createElement('div');
  picker.className = 'cell-insert-picker open';
  let afterId;
  if (dir === 'after') {
    afterId = id;
  } else {
    const idx = S.cells.findIndex(c => c.id === id);
    afterId = idx > 0 ? S.cells[idx - 1].id : null;
  }
  picker.innerHTML = ['code', 'md', 'css', 'html'].map(t =>
    `<button onclick="insertAt(${afterId !== null ? afterId : 'null'},'${t}');this.closest('.cell-insert-picker').remove()">${t}</button>`
  ).join('');
  const header = cell.el.querySelector('.cell-header');
  header.style.position = 'relative';
  picker.style.top = '100%';
  picker.style.left = dir === 'before' ? '0' : 'auto';
  picker.style.right = dir === 'after' ? '0' : 'auto';
  header.appendChild(picker);
}

function toggleTypePicker(id) {
  closeAllTrays();
  const picker = document.querySelector(`.cell-type-picker[data-cell-id="${id}"]`);
  if (picker) picker.classList.toggle('open');
}

function collapseAll() {
  S.cells.forEach(c => c.el.classList.add('collapsed'));
  setMsg('collapsed all', 'ok');
}

function expandAll() {
  S.cells.forEach(c => c.el.classList.remove('collapsed'));
  setMsg('expanded all', 'ok');
}

function newNotebook() {
  if (!confirm('Clear all cells?')) return;
  while (S.cells.length) {
    const cell = S.cells[0];
    if (cell._styleEl) { cell._styleEl.remove(); cell._styleEl = null; }
    cell.el.remove();
    S.cells.shift();
  }
  S.scope = {};
  S.selectedId = null;
  S.clipboard = null;
  S.trash = [];
  $('#docTitle').value = 'untitled';
  updateStatus();
  setMsg('new notebook', 'ok');
}

function runSelectedCell() { runSelectedAndAdvance(); }

function runSelectedAndAdvance() {
  runSelected();
  if (S.selectedId === null) return;
  // respect goto target if set
  const gotoIdx = window._lastGotoTarget;
  if (gotoIdx != null && gotoIdx >= 0 && gotoIdx < S.cells.length) {
    editCell(S.cells[gotoIdx].id);
  } else {
    const idx = S.cells.findIndex(c => c.id === S.selectedId);
    if (idx < S.cells.length - 1) {
      editCell(S.cells[idx + 1].id);
    } else {
      const newCell = addCellWithUndo('code', '', S.selectedId);
      selectCell(newCell.id);
    }
  }
}

function navigateCell(dir) {
  if (!S.cells.length) return;
  if (S.selectedId === null) {
    selectCell(S.cells[0].id, true);
    return;
  }
  const idx = S.cells.findIndex(c => c.id === S.selectedId);
  const newIdx = idx + dir;
  if (newIdx >= 0 && newIdx < S.cells.length) {
    selectCell(S.cells[newIdx].id, true);
  }
}

document.addEventListener('keydown', (e) => {
  // find bar shortcuts (must be before edit/command branches)
  if ((e.key === 'f') && (e.ctrlKey || e.metaKey) && !e.altKey) {
    e.preventDefault(); openFind(false); return;
  }
  if ((e.key === 'h') && (e.ctrlKey || e.metaKey) && !e.altKey) {
    e.preventDefault(); openFind(true); return;
  }
  if (e.key === 'Escape' && S.findActive) {
    e.preventDefault(); closeFind(); return;
  }

  const editing = getEditingCell();

  if (editing) {
    // ── EDIT MODE ──
    if (e.key === '/' && (e.ctrlKey || e.metaKey)) {
      e.preventDefault();
      toggleComment(document.activeElement);
      return;
    }
    if (e.key === 'Escape') {
      e.preventDefault();
      exitEdit();
      selectCell(editing.id);
      return;
    }
    if (e.key === 'Enter' && e.ctrlKey) {
      e.preventDefault();
      editing.code = editing.el.querySelector('textarea').value;
      if (editing.type === 'code') runDAG([editing.id], true);
      return;
    }
    if (e.key === 'Enter' && e.shiftKey) {
      e.preventDefault();
      editing.code = editing.el.querySelector('textarea').value;
      if (editing.type === 'code') runDAG([editing.id], true);
      // advance — respect goto target if set
      const gotoIdx = window._lastGotoTarget;
      if (gotoIdx != null && gotoIdx >= 0 && gotoIdx < S.cells.length) {
        editCell(S.cells[gotoIdx].id);
      } else {
        const idx = S.cells.findIndex(c => c.id === editing.id);
        if (idx < S.cells.length - 1) {
          editCell(S.cells[idx + 1].id);
        } else {
          const newCell = addCellWithUndo('code', '', editing.id);
          selectCell(newCell.id);
          editCell(newCell.id);
        }
      }
      return;
    }
  } else {
    // ── COMMAND MODE ──
    // ignore if typing in any input field (title, find bar, etc.)
    if (document.activeElement && (document.activeElement.tagName === 'INPUT' || document.activeElement.id === 'docTitle')) return;

    // let browser shortcuts through (Ctrl+J downloads, etc.)
    if (e.ctrlKey || e.metaKey || e.altKey) return;

    if (e.key === 'ArrowUp' || e.key === 'k') {
      e.preventDefault();
      navigateCell(-1);
      return;
    }
    if (e.key === 'ArrowDown' || e.key === 'j') {
      e.preventDefault();
      navigateCell(1);
      return;
    }
    if (e.key === 'Enter') {
      e.preventDefault();
      if (S.selectedId !== null) editCell(S.selectedId);
      return;
    }
    if (e.key === 'a') {
      e.preventDefault();
      const newCell = addCellWithUndo('code', '', null, S.selectedId);
      selectCell(newCell.id);
      editCell(newCell.id);
      return;
    }
    if (e.key === 'b') {
      e.preventDefault();
      const newCell = addCellWithUndo('code', '', S.selectedId);
      selectCell(newCell.id);
      editCell(newCell.id);
      return;
    }
    if (e.key === 'd') {
      e.preventDefault();
      if (S.pendingD) {
        // dd — delete
        clearTimeout(S.pendingDTimer);
        S.pendingD = false;
        if (S.selectedId !== null) {
          const idx = S.cells.findIndex(c => c.id === S.selectedId);
          const nextId = idx < S.cells.length - 1 ? S.cells[idx + 1].id
                       : idx > 0 ? S.cells[idx - 1].id : null;
          deleteCellWithUndo(S.selectedId);
          if (nextId !== null) selectCell(nextId);
        }
      } else {
        S.pendingD = true;
        S.pendingDTimer = setTimeout(() => { S.pendingD = false; }, 600);
      }
      return;
    }
    if (e.key !== 'd' && S.pendingD) { S.pendingD = false; clearTimeout(S.pendingDTimer); }
    if (e.key === 'z') {
      e.preventDefault();
      undo();
      return;
    }
    if (e.key === 'c' && S.selectedId !== null) {
      e.preventDefault();
      const cell = S.cells.find(c => c.id === S.selectedId);
      if (cell) S.clipboard = { type: cell.type, code: cell.code };
      setMsg('copied cell', 'ok');
      return;
    }
    if (e.key === 'v' && S.clipboard) {
      e.preventDefault();
      const newCell = addCellWithUndo(S.clipboard.type, S.clipboard.code, S.selectedId);
      selectCell(newCell.id);
      if (S.clipboard.type === 'code' && S.cells.some(c => c.type === 'code')) runAll();
      return;
    }
    if (e.key === 'x' && S.selectedId !== null) {
      // cut = copy + delete
      e.preventDefault();
      const cell = S.cells.find(c => c.id === S.selectedId);
      if (cell) S.clipboard = { type: cell.type, code: cell.code };
      const idx = S.cells.findIndex(c => c.id === S.selectedId);
      const nextId = idx < S.cells.length - 1 ? S.cells[idx + 1].id
                   : idx > 0 ? S.cells[idx - 1].id : null;
      deleteCellWithUndo(S.selectedId);
      if (nextId !== null) selectCell(nextId);
      setMsg('cut cell', 'ok');
      return;
    }
    if (e.key === 'h' && S.selectedId !== null) {
      e.preventDefault();
      const cell = S.cells.find(c => c.id === S.selectedId);
      if (cell) cell.el.classList.toggle('collapsed');
      return;
    }
    if (e.key === 'l') {
      e.preventDefault();
      const on = getSettings().lineNumbers === 'on';
      applyLineNumbers(!on);
      setMsg(on ? 'line numbers off' : 'line numbers on', 'ok');
      return;
    }
    if (e.key === 'p') {
      e.preventDefault();
      togglePresent();
      return;
    }
    if (e.key === 'm' && S.selectedId !== null) {
      e.preventDefault();
      convertCell(S.selectedId, 'md');
      return;
    }
    if (e.key === 'y' && S.selectedId !== null) {
      e.preventDefault();
      convertCell(S.selectedId, 'code');
      return;
    }
    if (e.key === 's' && S.selectedId !== null) {
      e.preventDefault();
      convertCell(S.selectedId, 'css');
      return;
    }
    if (e.key === 't' && S.selectedId !== null) {
      e.preventDefault();
      convertCell(S.selectedId, 'html');
      return;
    }
  }

  // global: F1 help overlay
  if (e.key === 'F1') {
    e.preventDefault();
    $('#helpOverlay').classList.toggle('visible');
    return;
  }

  // close presentation mode on Escape
  if (e.key === 'Escape' && document.body.classList.contains('presenting')) {
    togglePresent();
    e.stopImmediatePropagation();
    return;
  }

  // close settings on Escape if visible
  if (e.key === 'Escape' && $('#settingsOverlay').classList.contains('visible')) {
    toggleSettings();
    e.stopImmediatePropagation();
    return;
  }

  // close help on Escape if visible
  if (e.key === 'Escape' && $('#helpOverlay').classList.contains('visible')) {
    $('#helpOverlay').classList.remove('visible');
    e.stopImmediatePropagation();
    return;
  }

  // global: Ctrl+S / Cmd+S
  if (e.key === 's' && (e.ctrlKey || e.metaKey)) {
    e.preventDefault();
    saveNotebook();
  }
});

// click to dismiss help
$('#helpOverlay').addEventListener('click', (e) => {
  if (e.target === $('#helpOverlay')) $('#helpOverlay').classList.remove('visible');
});

// click to select + close trays
document.addEventListener('click', (e) => {
  // close action trays if clicking outside their wrapper (wrapper = parent div with tray + button)
  const addTray = document.querySelector('.action-add-tray');
  const moreTray = document.querySelector('.action-more-tray');
  if (addTray && addTray.classList.contains('open') && !addTray.parentElement.contains(e.target)) {
    addTray.classList.remove('open');
  }
  if (moreTray && moreTray.classList.contains('open') && !moreTray.parentElement.contains(e.target)) {
    moreTray.classList.remove('open');
  }
  // close cell type pickers if clicking outside
  if (!e.target.closest('.cell-type-picker') && !e.target.closest('.cell-type')) {
    document.querySelectorAll('.cell-type-picker.open').forEach(el => el.classList.remove('open'));
  }
  // close cell insert pickers if clicking outside
  if (!e.target.closest('.cell-insert-picker')) {
    document.querySelectorAll('.cell-insert-picker').forEach(el => el.remove());
  }
  // close toolbar overflow menu if clicking outside
  const tbOverflow = document.querySelector('.toolbar-overflow');
  if (tbOverflow && tbOverflow.classList.contains('open') && !tbOverflow.contains(e.target)) {
    tbOverflow.classList.remove('open');
  }
  // close save tray if clicking outside
  const saveTray = document.getElementById('saveTray');
  if (saveTray && saveTray.classList.contains('open') && !saveTray.parentElement.contains(e.target)) {
    saveTray.classList.remove('open');
  }

  const cellEl = e.target.closest('.cell');
  if (cellEl) {
    const id = parseInt(cellEl.dataset.id);
    selectCell(id);
  }
});

// late import to avoid circular dependency at module load time

// -- goto.js --

// ── GOTO ── @optional

function parseGoto(code) {
  const m = code.match(/^\s*\/\/\s*%goto\b\s*(.*)/m);
  if (!m) return null;
  return m[1].trim() || '';
}

const MAX_VISITS = 1000;
let visits = {};

window._dagStart = function() {
  visits = {};
  window._lastGotoTarget = null;
};

window._beforeExec = function(cell) {
  const target = parseGoto(cell.code);
  if (target !== null) {
    S.scope.__goto = target;
    cell.defines.add('__goto');
  } else {
    delete S.scope.__goto;
  }
};

window._afterExec = function(cell, index) {
  const gotoTarget = S.scope.__goto;
  delete S.scope.__goto;
  window._lastGotoTarget = null;

  if (!gotoTarget) return -1;

  // resolve by cellName
  const targetIdx = S.cells.findIndex(c => parseCellName(c.code) === gotoTarget);
  if (targetIdx < 0) {
    const out = cell.el.querySelector('.cell-output');
    if (out) {
      out.appendChild(document.createTextNode('\ngoto: cell \u201c' + gotoTarget + '\u201d not found'));
      out.classList.add('error');
    }
    return -1;
  }

  // loop protection
  const key = index + ':' + targetIdx;
  visits[key] = (visits[key] || 0) + 1;
  if (visits[key] > MAX_VISITS) {
    const out = cell.el.querySelector('.cell-output');
    if (out) {
      out.appendChild(document.createTextNode('\ngoto: loop limit reached (' + MAX_VISITS + ' iterations)'));
      out.classList.add('error');
    }
    return -1;
  }

  window._lastGotoTarget = targetIdx;
  return targetIdx;
};

// -- size-compare.js --

// ── SIZE COMPARISON ── @optional

const SIZE_MEDIA = [
  [4096, 'an Atari 2600 cartridge'],
  [49152, 'a ZX Spectrum tape'],
  [73728, 'Apollo AGC rope memory'],
  [81920, 'an 8\u2033 floppy (SS/SD)'],
  [262144, 'an NES cartridge'],
  [368640, 'a 5.25\u2033 floppy (DS/DD)'],
  [737280, 'a 3.5\u2033 floppy (DS/DD)'],
  [1228800, 'a 5.25\u2033 floppy (DS/HD)'],
  [1474560, 'a 3.5\u2033 floppy (DS/HD)'],
];

function sizeCompare(bytes) {
  if (!window._sizeCompare) return '';
  for (const [size, name] of SIZE_MEDIA) {
    if (bytes <= size) return 'fits on ' + name;
  }
  const n = Math.ceil(bytes / 1474560);
  return n + '\u00d7 3.5\u2033 floppies';
}

function applySizeCompare(val) {
  const on = val === true || val === 'true' || val === 'on';
  window._sizeCompare = on;
  const el = $('#setSizeCompare');
  if (el) el.value = on ? 'on' : 'off';
  updateStatus();
}

function applySizeCompareRef(val) {
  window._sizeCompareRef = val === 'content' ? 'content' : 'total';
  const el = $('#setSizeCompareRef');
  if (el) el.value = window._sizeCompareRef;
  updateStatus();
}

// inject settings rows before modules section
(function() {
  const panel = $('#settingsPanel');
  if (!panel) return;
  const headings = panel.querySelectorAll('h2');
  const modulesH2 = headings[headings.length - 1];
  if (!modulesH2) return;

  const h2 = document.createElement('h2');
  h2.textContent = 'status bar';
  modulesH2.before(h2);

  const refRow = document.createElement('div');
  refRow.className = 'settings-row';
  refRow.innerHTML = '<label>size reference</label>' +
    '<select id="setSizeCompareRef" onchange="applySizeCompareRef(this.value)">' +
    '<option value="total" selected>total file</option>' +
    '<option value="content">content only</option></select>';
  modulesH2.before(refRow);

  const row = document.createElement('div');
  row.className = 'settings-row';
  row.innerHTML = '<label>size comparison</label>' +
    '<select id="setSizeCompare" onchange="applySizeCompare(this.value)">' +
    '<option value="off">off</option><option value="on" selected>on</option></select>';
  modulesH2.before(row);

  window._sizeCompare = true;
  window._sizeCompareRef = 'total';
})();

// -- globals.js --

// ── GLOBAL BINDINGS ──
// This module wires exported functions to window.* for use by onclick/onchange
// handlers in template HTML and dynamically generated markup.
// Modules stay pure (no side effects, no window assignments).











// state
window.$ = $;
window.S = S;

// editor
window.toggleAutorun = toggleAutorun;

// settings
window.toggleSettings = toggleSettings;
window.togglePresent = togglePresent;
window.applyTheme = applyTheme;
window.applyFontSize = applyFontSize;
window.applyWidth = applyWidth;
window.applyLineNumbers = applyLineNumbers;
window.applyHeader = applyHeader;
window.applyExecMode = applyExecMode;
window.applyRunOnLoad = applyRunOnLoad;
window.applyShowToggle = applyShowToggle;
window.applyGlobalExecMode = applyGlobalExecMode;
window.applyGlobalRunOnLoad = applyGlobalRunOnLoad;

// update
window.toggleUpdate = toggleUpdate;
window.checkForUpdate = checkForUpdate;
window.applyOnlineUpdate = applyOnlineUpdate;
window.proceedUpdate = proceedUpdate;
window.cancelUpdate = cancelUpdate;
window.updateFromFile = updateFromFile;

// save
window.saveNotebook = saveNotebook;
window.savePackedNotebook = savePackedNotebook;
window.setSaveMode = setSaveMode;
window.toggleSaveTray = toggleSaveTray;
window.exportAsTxt = exportAsTxt;

// exec
window.runAll = runAll;

// ui
window.insertAt = insertAt;

// find
window.openFind = openFind;
window.closeFind = closeFind;

// stdlib
window.__auditable_registerProvider = registerProvider;

// keyboard / toolbar
window.addCellWithUndo = addCellWithUndo;
window.deleteCellWithUndo = deleteCellWithUndo;
window.runSelectedCell = runSelectedCell;
window.toggleToolbarMenu = toggleToolbarMenu;
window.toggleAddTray = toggleAddTray;
window.toggleMoreTray = toggleMoreTray;
window.showInsertPicker = showInsertPicker;
window.toggleTypePicker = toggleTypePicker;
window.collapseAll = collapseAll;
window.expandAll = expandAll;
window.newNotebook = newNotebook;

// -- init.js --

// ── INIT ──

(function init() {
  // detect packed format (meta tag injected by loader)
  const packedMeta = document.querySelector('meta[name="auditable-packed"]');
  if (packedMeta) {
    packedMeta.remove();
    setBadge('packed', 'packed', 'toolbar-badge toolbar-badge-packed');
    setSaveMode('packed');
  }

  if (!loadFromEmbed()) {
    addCell('md', '');
    addCell('code', '');
  }
  S.initialized = true;
})();

// ── AF BRIDGE ──
// When running inside AF shell (iframe), establish postMessage communication.
// No-op when running standalone (window.parent === window).
//
// Message protocol (notebook ↔ AF shell):
//   af:ready          → sent on init with { title }
//   af:serialize      ← received to trigger saveNotebook()
//   af:saved          ← received after save (shows "saved" status)
//   af:setTitle       ← received to update docTitle input
//   af:resize         ← received when iframe becomes visible (recalc textareas)
//   af:titleChanged   → sent when user edits the title
//   af:fileRequest    → sent to request file picker { id, accept }
//   af:fileResult     ← received with picked file { id, file }
//   af:download       → sent to request download { data, filename, mimeType }
//   af:dirty          → sent when notebook has unsaved changes

(function afBridge() {
  if (window.parent === window) return;
  window.__AF_BRIDGE__ = true;

  // register AF-specific providers for file/download
  registerProvider('file', (accept) => {
    return new Promise((resolve) => {
      const id = 'af_file_' + Date.now();
      function handler(e) {
        if (e.data?.type === 'af:fileResult' && e.data.payload?.id === id) {
          window.removeEventListener('message', handler);
          resolve(e.data.payload.file);
        }
      }
      window.addEventListener('message', handler);
      window.parent.postMessage({ type: 'af:fileRequest', payload: { id, accept } }, '*');
    });
  });

  registerProvider('download', (data, filename, mimeType) => {
    const str = typeof data === 'string' ? data : JSON.stringify(data, null, 2);
    const mime = mimeType || (typeof data === 'string' ? 'text/plain' : 'application/json');
    window.parent.postMessage({
      type: 'af:download',
      payload: { data: str, filename, mimeType: mime }
    }, '*');
  });

  const title = document.getElementById('docTitle')?.value || 'untitled';
  window.parent.postMessage({ type: 'af:ready', payload: { title } }, '*');

  window.addEventListener('message', (e) => {
    const msg = e.data;
    if (!msg?.type) return;
    if (msg.type === 'af:serialize') saveNotebook();
    else if (msg.type === 'af:saved') setMsg('saved', 'ok');
    else if (msg.type === 'af:setTitle') {
      const input = document.getElementById('docTitle');
      if (input && msg.payload?.title) input.value = msg.payload.title;
    } else if (msg.type === 'af:resize') {
      // recalculate textarea heights after becoming visible
      document.querySelectorAll('textarea').forEach(ta => {
        ta.style.height = 'auto';
        ta.style.height = ta.scrollHeight + 'px';
        const hl = ta.parentElement?.querySelector('.highlight-layer');
        if (hl) hl.style.height = ta.style.height;
      });
    }
  });

  document.getElementById('docTitle')?.addEventListener('input', () => {
    window.parent.postMessage({
      type: 'af:titleChanged',
      payload: { title: document.getElementById('docTitle').value }
    }, '*');
  });
})();
</script>
</body>
<!-- good luck out there -->
</html>
