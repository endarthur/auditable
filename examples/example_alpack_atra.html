<!DOCTYPE html>
<!-- auditable — a reactive computational notebook in a single HTML file -->
<!-- https://github.com/endarthur/auditable — MIT license -->
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Auditable — atra + ALPACK — all-Wasm interpolation</title>
<style>
:root {
  --bg: #0a0a0a;
  --bg1: #111;
  --bg2: #1a1a1a;
  --border: #222;
  --border-hi: #333;
  --fg: #aaa;
  --fg-dim: #555;
  --fg-bright: #ccc;
  --accent: #c89b3c;
  --accent-dim: #8a6c2a;
  --err: #a33;
  --ok: #3a7;
  --mono: 'Courier New', Courier, monospace;
  --editor-font-size: 13px;
}

* { margin: 0; padding: 0; box-sizing: border-box; }

/* scrollbar */
::-webkit-scrollbar { width: 6px; height: 6px; }
::-webkit-scrollbar-track { background: var(--bg); }
::-webkit-scrollbar-thumb { background: var(--border-hi); border-radius: 0; }
::-webkit-scrollbar-thumb:hover { background: var(--fg-dim); }
textarea::-webkit-scrollbar-thumb { background: var(--border); }
@supports (scrollbar-color: auto) {
  * { scrollbar-color: var(--border-hi) var(--bg); scrollbar-width: thin; }
}

html, body {
  background: var(--bg);
  color: var(--fg);
  font-family: var(--mono);
  font-size: 13px;
  line-height: 1.5;
  min-height: 100vh;
}

/* ── TOOLBAR ── */
.toolbar {
  position: sticky;
  top: 0;
  z-index: 100;
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 6px 12px;
  background: var(--bg);
  border-bottom: 1px solid var(--border);
}

.toolbar-title {
  font-size: 11px;
  letter-spacing: 3px;
  text-transform: uppercase;
  color: var(--accent);
  opacity: 0.8;
  user-select: none;
}

.toolbar-sep {
  width: 1px;
  height: 16px;
  background: var(--border);
  margin: 0 4px;
}

.toolbar-filename {
  font-size: 12px;
  color: var(--fg-dim);
  flex: 1;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.toolbar-filename input {
  background: none;
  border: none;
  border-bottom: 1px solid transparent;
  color: var(--fg);
  font-family: var(--mono);
  font-size: 12px;
  outline: none;
  width: 200px;
}
.toolbar-filename input:focus {
  border-bottom-color: var(--accent-dim);
}

button {
  background: var(--bg2);
  border: 1px solid var(--border);
  color: var(--fg-dim);
  font-family: var(--mono);
  font-size: 10px;
  letter-spacing: 1px;
  text-transform: uppercase;
  padding: 4px 10px;
  cursor: pointer;
  transition: border-color 0.15s, color 0.15s;
}
button:hover {
  border-color: var(--border-hi);
  color: var(--fg);
}
button.accent {
  border-color: var(--accent-dim);
  color: var(--accent);
}
button.accent:hover {
  border-color: var(--accent);
}

/* ── TOOLBAR BADGES ── */
.toolbar-badges {
  display: inline-flex;
  gap: 4px;
  margin-left: 6px;
  align-items: center;
}
.toolbar-badge {
  font-size: 9px;
  letter-spacing: 0.5px;
  padding: 1px 4px;
  border-radius: 2px;
  user-select: none;
  opacity: 0.85;
}
.toolbar-badge-signed {
  color: var(--ok);
  border: 1px solid color-mix(in srgb, var(--ok) 40%, transparent);
}
.toolbar-badge-packed {
  color: var(--fg-dim);
  border: 1px solid var(--border);
}

/* ── SPLIT SAVE BUTTON ── */
.save-split {
  display: inline-flex;
  position: relative;
}
.save-split button:first-child {
  border-right: none;
  border-radius: 3px 0 0 3px;
}
.save-caret {
  border-radius: 0 3px 3px 0 !important;
  padding: 4px 4px !important;
  font-size: 10px;
}
.save-tray {
  display: none;
  position: absolute;
  right: 0;
  top: 100%;
  margin-top: 4px;
  background: var(--bg);
  border: 1px solid var(--border);
  z-index: 100;
  min-width: 120px;
}
.save-tray.open { display: flex; flex-direction: column; }
.save-tray button {
  border: none;
  border-bottom: 1px solid var(--border);
  text-align: left;
  padding: 6px 10px;
  white-space: nowrap;
  font-size: 12px;
}
.save-tray button:last-child { border-bottom: none; }
.save-tray button:hover { background: var(--bg-hi); }

/* ── TRANSPORT CONTROLS ── */
.transport {
  display: inline-flex;
  border: 1px solid var(--border);
}
.transport button {
  border: none;
  border-right: 1px solid var(--border);
  padding: 4px 8px;
}
.transport button:last-child { border-right: none; }
.transport button.autorun-on {
  background: #33aa77;
  color: #111;
}
.transport button.autorun-off {
  background: #dd4444;
  color: #111;
}

.toolbar-right {
  margin-left: auto;
  display: flex;
  align-items: center;
  gap: 8px;
}

/* ── TOOLBAR OVERFLOW MENU ── */
.toolbar-overflow {
  position: relative;
  display: inline-block;
}
.toolbar-overflow-tray {
  display: none;
  position: absolute;
  top: 100%;
  right: 0;
  background: var(--bg1);
  border: 1px solid var(--border);
  z-index: 200;
  flex-direction: column;
  min-width: 140px;
}
.toolbar-overflow-tray button {
  border: none;
  border-bottom: 1px solid var(--border);
  text-align: left;
  padding: 8px 12px;
  background: var(--bg1);
  white-space: nowrap;
}
.toolbar-overflow-tray button:last-child { border-bottom: none; }
.toolbar-overflow-tray button:hover { background: var(--bg2); color: var(--fg-bright); }
.toolbar-overflow.open .toolbar-overflow-tray { display: flex; }

/* ── BOTTOM ACTION BAR ── */
.action-bar { display: none; }

/* ── ACTION BAR TRAYS ── */
.action-add-tray,
.action-more-tray {
  display: none;
  position: absolute;
  bottom: 100%;
  background: var(--bg1);
  border: 1px solid var(--border);
  flex-direction: column;
  z-index: 200;
}
.action-add-tray { left: 0; min-width: 120px; }
.action-more-tray { right: 0; min-width: 120px; }
.action-add-tray.open,
.action-more-tray.open { display: flex; }
.action-add-tray button,
.action-more-tray button {
  min-height: 48px;
  border: none;
  border-bottom: 1px solid var(--border);
  text-align: left;
  padding: 8px 16px;
  background: var(--bg1);
  color: var(--fg);
  font-family: var(--mono);
  font-size: 12px;
  letter-spacing: 1px;
  text-transform: uppercase;
}
.action-add-tray button:last-child,
.action-more-tray button:last-child { border-bottom: none; }
.action-add-tray button:hover,
.action-more-tray button:hover { background: var(--bg2); color: var(--fg-bright); }
.action-more-tray button.active-mode { color: var(--accent); }

/* ── CELL INSERT / CONVERT BUTTONS (touch only) ── */
.cell-insert { display: none; }
.cell-convert { display: none; }

/* ── CELL TYPE PICKER ── */
.cell-type-picker {
  display: none;
  gap: 2px;
  padding: 2px 8px 4px;
}
.cell-type-picker.open { display: flex; }
.cell-type-picker button {
  font-size: 9px;
  padding: 2px 8px;
  background: var(--bg2);
  border: 1px solid var(--border);
  color: var(--fg-dim);
  font-family: var(--mono);
  letter-spacing: 1px;
  text-transform: uppercase;
}
.cell-type-picker button:hover {
  border-color: var(--accent-dim);
  color: var(--accent);
}

/* ── CELL INSERT PICKER ── */
.cell-insert-picker {
  display: none;
  gap: 2px;
  position: absolute;
  background: var(--bg1);
  border: 1px solid var(--border);
  padding: 4px;
  z-index: 200;
}
.cell-insert-picker.open { display: flex; }
.cell-insert-picker button {
  font-size: 9px;
  padding: 4px 8px;
  background: var(--bg2);
  border: 1px solid var(--border);
  color: var(--fg-dim);
  font-family: var(--mono);
  letter-spacing: 1px;
  text-transform: uppercase;
  min-height: 36px;
}
.cell-insert-picker button:hover {
  border-color: var(--accent-dim);
  color: var(--accent);
}

/* ── TOOLBAR STATUS (mobile cell count) ── */
.toolbar-status { display: none; }

/* ── NOTEBOOK ── */
.notebook {
  max-width: 860px;
  margin: 0 auto;
  padding: 16px 12px 120px;
}

/* ── CELL ── */
.cell {
  position: relative;
  margin: 6px 0;
  border-left: 2px solid transparent;
  transition: border-color 0.15s;
}
.cell:hover {
  border-left-color: var(--border-hi);
}
.cell.selected {
  border-left-color: var(--accent);
}
.cell.selected .cell-header {
  opacity: 1;
}
.cell.manual .cell-type::after {
  content: ' \00b7 manual';
  color: var(--accent-dim);
}
.cell.stale {
  border-left-color: var(--accent-dim);
}
.cell.error {
  border-left-color: var(--err);
}
.cell.fresh {
  border-left-color: var(--ok);
  transition: border-color 0.5s;
}

/* cell header — type label + controls */
.cell-header {
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 2px 8px;
  opacity: 0;
  transition: opacity 0.15s;
  user-select: none;
}
.cell:hover .cell-header,
.cell:focus-within .cell-header {
  opacity: 1;
}

.cell.collapsed .cell-code,
.cell.collapsed .cell-md-edit,
.cell.collapsed .cell-css-edit,
.cell.collapsed .cell-html-edit {
  display: none !important;
}
.cell.collapsed .cell-type::before {
  content: '\25b8 ';
}
.cell:not(.collapsed) .cell-type::before {
  content: '\25be ';
}
.cell-type {
  cursor: pointer;
  user-select: none;
  font-size: 9px;
  letter-spacing: 2px;
  text-transform: uppercase;
  color: var(--fg-dim);
}
.cell[data-type="code"] .cell-type { color: #7aabcf; }
.cell[data-type="css"]  .cell-type { color: #d4955a; }
.cell[data-type="html"] .cell-type { color: #6dbfb8; }
.cell[data-type="md"]   .cell-type { color: var(--fg-dim); }

.cell-btn {
  background: none;
  border: none;
  color: var(--fg-dim);
  font-family: var(--mono);
  font-size: 10px;
  padding: 0 4px;
  cursor: pointer;
}
.cell-btn:hover { color: var(--fg); }
.cell-btn.del:hover { color: var(--err); }

/* ── CODE CELL ── */
.cell-code {
  position: relative;
}

.editor-wrap {
  --gutter: 36px;
  position: relative;
  overflow: hidden;
}

.line-numbers {
  position: absolute;
  top: 0; left: 0; bottom: 0;
  width: var(--gutter);
  padding: 8px 4px 8px 0;
  font-family: var(--mono);
  font-size: var(--editor-font-size);
  line-height: 1.5;
  text-align: right;
  color: var(--fg-dim);
  background: var(--bg1);
  border-right: 1px solid var(--border);
  border-top: 1px solid var(--border);
  border-bottom: 1px solid var(--border);
  border-left: 1px solid var(--border);
  overflow: hidden;
  z-index: 3;
  pointer-events: none;
  white-space: pre;
  box-sizing: border-box;
}

:root.hide-line-numbers .line-numbers { display: none; }
:root.hide-line-numbers .editor-wrap { --gutter: 0px; }

.cell-code textarea {
  display: block;
  width: 100%;
  background: transparent;
  border: 1px solid var(--border);
  color: var(--fg-bright);
  caret-color: var(--fg-bright);
  font-family: var(--mono);
  font-size: var(--editor-font-size);
  line-height: 1.5;
  padding: 8px 10px 8px calc(var(--gutter) + 10px);
  resize: vertical;
  min-height: 38px;
  outline: none;
  tab-size: 2;
  white-space: pre;
  overflow-x: auto;
  position: relative;
  z-index: 2;
  -webkit-text-fill-color: transparent;
}
.cell-code textarea::selection {
  -webkit-text-fill-color: var(--fg-bright);
  background: rgba(200,155,60,0.25);
}
.cell-code textarea:focus + .highlight-layer {
  border-color: var(--border-hi);
}
.cell-code textarea:focus ~ .line-numbers {
  border-color: var(--border-hi);
}

.highlight-layer {
  position: absolute;
  top: 0; left: 0; right: 0; bottom: 0;
  background: var(--bg1);
  border: 1px solid var(--border);
  padding: 8px 10px 8px calc(var(--gutter) + 10px);
  font-family: var(--mono);
  font-size: var(--editor-font-size);
  line-height: 1.5;
  tab-size: 2;
  white-space: pre;
  overflow: hidden;
  z-index: 1;
  pointer-events: none;
  color: var(--fg-bright);
}

/* syntax tokens */
.hl-kw { color: #7a9ec7; }
.hl-str { color: var(--accent); }
.hl-num { color: #8cb878; }
.hl-cmt { color: #555; font-style: italic; }
.hl-fn { color: #c4a6d0; }
.hl-const { color: #d09870; }
.hl-op { color: #888; }
.hl-punc { color: #666; }

/* CSS syntax tokens */
.hl-atrule { color: #7aabcf; }
.hl-prop { color: #7aabcf; }
.hl-sel { color: #d4955a; }
.hl-color { color: var(--accent); }
.hl-important { color: #d4555a; font-weight: bold; }

/* HTML syntax tokens */
.hl-tag { color: #6dbfb8; }
.hl-attr { color: #7aabcf; }
.hl-expr { color: var(--accent); }

.hl-swatch {
  display: inline-block;
  width: 10px;
  height: 10px;
  border: 1px solid var(--border-hi);
  vertical-align: middle;
  margin-right: 2px;
  cursor: pointer;
  pointer-events: auto;
}

.cell-output {
  padding: 4px 10px;
  min-height: 0;
  font-size: 12px;
  color: var(--fg);
  white-space: pre-wrap;
  word-break: break-all;
}
.cell-output:empty {
  display: none;
}
.cell-output.error {
  color: var(--err);
}

.cell-output canvas {
  max-width: 100%;
  display: block;
  margin: 4px 0;
}

.cell-output table {
  border-collapse: collapse;
  font-size: 11px;
  margin: 4px 0;
}
.cell-output table th,
.cell-output table td {
  border: 1px solid var(--border);
  padding: 2px 8px;
}
.cell-output table th {
  color: var(--accent);
  font-weight: normal;
  text-transform: uppercase;
  font-size: 9px;
  letter-spacing: 1px;
}

/* ── CSS CELL ── */
.cell-css-view {
  padding: 6px 10px;
  color: var(--fg-dim);
  cursor: text;
  min-height: 24px;
  font-size: 11px;
  font-style: italic;
}
.cell-css-view:empty::before {
  content: '(empty stylesheet)';
}

.cell-css-edit textarea {
  display: block;
  width: 100%;
  background: transparent;
  border: 1px solid var(--border);
  color: var(--fg-bright);
  caret-color: var(--fg-bright);
  font-family: var(--mono);
  font-size: var(--editor-font-size);
  line-height: 1.5;
  padding: 8px 10px 8px calc(var(--gutter) + 10px);
  resize: vertical;
  min-height: 38px;
  outline: none;
  tab-size: 2;
  white-space: pre;
  overflow-x: auto;
  position: relative;
  z-index: 2;
  -webkit-text-fill-color: transparent;
}
.cell-css-edit textarea::selection {
  -webkit-text-fill-color: var(--fg-bright);
  background: rgba(200,155,60,0.25);
}
.cell-css-edit textarea:focus + .highlight-layer {
  border-color: var(--border-hi);
}
.cell-css-edit textarea:focus ~ .line-numbers {
  border-color: var(--border-hi);
}

/* ── HTML CELL ── */
.cell-html-view {
  padding: 6px 10px;
  color: var(--fg);
  cursor: text;
  min-height: 24px;
}
.cell-html-view:empty::before {
  content: '(empty html template)';
  color: var(--fg-dim);
  font-style: italic;
  font-size: 11px;
}
.cell-html-edit textarea {
  display: block;
  width: 100%;
  background: transparent;
  border: 1px solid var(--border);
  color: var(--fg-bright);
  caret-color: var(--fg-bright);
  font-family: var(--mono);
  font-size: var(--editor-font-size);
  line-height: 1.5;
  padding: 8px 10px 8px calc(var(--gutter) + 10px);
  resize: vertical;
  min-height: 38px;
  outline: none;
  tab-size: 2;
  white-space: pre;
  overflow-x: auto;
  position: relative;
  z-index: 2;
  -webkit-text-fill-color: transparent;
}
.cell-html-edit textarea::selection {
  -webkit-text-fill-color: var(--fg-bright);
  background: rgba(200,155,60,0.25);
}
.cell-html-edit textarea:focus + .highlight-layer {
  border-color: var(--border-hi);
}
.cell-html-edit textarea:focus ~ .line-numbers {
  border-color: var(--border-hi);
}

/* ── MARKDOWN CELL ── */
.cell-md-view {
  padding: 6px 10px;
  color: var(--fg);
  cursor: text;
  min-height: 24px;
}
.cell-md-view:empty::before {
  content: '(empty markdown cell)';
  color: var(--fg-dim);
  font-style: italic;
  font-size: 11px;
}
.cell-md-view h1, .cell-md-view h2, .cell-md-view h3 {
  color: var(--fg-bright);
  font-weight: normal;
  margin: 4px 0;
}
.cell-md-view h1 { font-size: 18px; letter-spacing: 2px; }
.cell-md-view h2 { font-size: 15px; letter-spacing: 1px; color: var(--accent); }
.cell-md-view h3 { font-size: 13px; }
.cell-md-view p { margin: 4px 0; }
.cell-md-view code {
  background: var(--bg2);
  padding: 1px 4px;
  font-size: 12px;
}
.cell-md-view strong { color: var(--fg-bright); }
.cell-md-view em { font-style: italic; }
.cell-md-view a { color: var(--accent); }
.cell-md-view table {
  border-collapse: collapse;
  font-size: 11px;
  margin: 4px 0;
}
.cell-md-view table th,
.cell-md-view table td {
  border: 1px solid var(--border);
  padding: 2px 8px;
}
.cell-md-view table th {
  color: var(--accent);
  font-weight: normal;
  text-transform: uppercase;
  font-size: 9px;
  letter-spacing: 1px;
}

.cell-md-edit textarea {
  display: block;
  width: 100%;
  background: var(--bg1);
  border: 1px solid var(--border);
  color: var(--fg-bright);
  font-family: var(--mono);
  font-size: var(--editor-font-size);
  line-height: 1.5;
  padding: 8px 10px;
  resize: vertical;
  min-height: 38px;
  outline: none;
}

/* ── PRESENTATION MODE ── */
body.presenting .toolbar { display: none; }
body.presenting .cell-header { display: none; }
body.presenting .cell-code { display: none; }
body.presenting .cell-md-edit { display: none !important; }
body.presenting .cell-css-edit { display: none; }
body.presenting .cell-css-view { display: none; }
body.presenting .cell-html-edit { display: none !important; }
body.presenting .cell { border-left: none; margin: 0; }
body.presenting .cell:hover { border-left: none; }
body.presenting .insert-bar { display: none; }
body.presenting .notebook { max-width: 900px; padding-top: 40px; }
body.presenting .statusbar { display: none; }
body.presenting .present-hidden { display: none; }
body.presenting .present-exit {
  display: block;
  position: fixed;
  top: 12px;
  right: 12px;
  z-index: 200;
}
.present-exit { display: none; }

/* ── INSERT BAR (between cells) ── */
.insert-bar {
  height: 16px;
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  margin: -6px 0;
}
.insert-bar::before {
  content: '';
  position: absolute;
  left: 20px;
  right: 20px;
  top: 50%;
  height: 1px;
  background: var(--border);
  opacity: 0;
  transition: opacity 0.15s;
}
.insert-bar:hover::before { opacity: 1; }
.insert-bar .insert-btns {
  display: flex;
  gap: 4px;
  opacity: 0;
  transition: opacity 0.15s;
  position: relative;
  z-index: 10;
}
.insert-bar:hover .insert-btns { opacity: 1; }
.insert-bar .insert-btns button {
  font-size: 9px;
  padding: 1px 8px;
  background: var(--bg);
  border: 1px solid var(--border);
  color: var(--fg-dim);
}
.insert-bar .insert-btns button:hover {
  border-color: var(--accent-dim);
  color: var(--accent);
}

/* ── ADD CELL BAR ── */
.add-bar {
  display: flex;
  justify-content: center;
  gap: 8px;
  padding: 6px 0;
  opacity: 0;
  transition: opacity 0.15s;
}
.notebook:hover .add-bar,
.add-bar.visible {
  opacity: 0.5;
}
.add-bar:hover {
  opacity: 1 !important;
}

/* ── WIDGET CLASSES ── */
.cell-widget {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 2px 0;
  font-size: 12px;
  color: var(--fg-dim);
}
.cell-widget-label {
  min-width: 80px;
  font-size: 10px;
  letter-spacing: 1px;
  text-transform: uppercase;
  color: var(--fg-dim);
}
.cell-widget input[type="range"] {
  flex: 1;
  accent-color: var(--accent);
  max-width: 200px;
}
.cell-widget select {
  background: var(--bg2);
  border: 1px solid var(--border);
  color: var(--fg-bright);
  font-family: var(--mono);
  font-size: 12px;
  padding: 2px 4px;
}
.cell-widget input[type="checkbox"] {
  accent-color: var(--accent);
}
.cell-widget input[type="text"] {
  background: var(--bg2);
  border: 1px solid var(--border);
  color: var(--fg-bright);
  font-family: var(--mono);
  font-size: 12px;
  padding: 2px 6px;
  flex: 1;
  max-width: 200px;
}
.cell-widget-val {
  min-width: 40px;
  text-align: right;
  color: var(--fg-bright);
  font-size: 12px;
}

/* ── STATUS BAR ── */
.statusbar {
  position: fixed;
  bottom: 0;
  left: 0;
  right: 0;
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 4px 12px;
  background: var(--bg);
  border-top: 1px solid var(--border);
  font-size: 10px;
  color: var(--fg-dim);
  letter-spacing: 1px;
  z-index: 100;
}
.statusbar .status-size { color: var(--fg-dim); }
.statusbar .status-cells { color: var(--fg-dim); }
.statusbar .status-msg { flex: 1; text-align: right; }
.statusbar .status-msg.ok { color: var(--ok); }
.statusbar .status-msg.warn { color: var(--accent); }
.statusbar .status-msg.err { color: var(--err); }
.statusbar .status-attr { margin-left: auto; display: flex; align-items: center; gap: 6px; }
.statusbar .status-attr a {
  color: var(--fg-dim);
  text-decoration: none;
  transition: color 0.2s;
}
.statusbar .status-attr a:hover { color: var(--accent); }
.statusbar .status-attr svg { vertical-align: middle; }

/* ── EMPTY STATE ── */
.empty-state {
  text-align: center;
  padding: 80px 20px;
  color: var(--fg-dim);
}
.empty-state .logo {
  font-size: 11px;
  letter-spacing: 4px;
  text-transform: uppercase;
  color: var(--accent);
  margin-bottom: 16px;
}
.empty-state .tagline {
  font-size: 11px;
  margin-bottom: 24px;
}

.help-overlay {
  display: none;
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.85);
  z-index: 1000;
  overflow-y: auto;
  padding: 40px;
}
.help-overlay.visible { display: flex; justify-content: center; }
.help-content {
  position: relative;
  max-width: 600px;
  width: 100%;
  color: var(--fg);
  font-family: var(--mono);
  font-size: 13px;
  line-height: 1.8;
}
.help-content h2 {
  color: var(--accent);
  font-size: 14px;
  letter-spacing: 2px;
  text-transform: uppercase;
  margin: 24px 0 8px 0;
  border-bottom: 1px solid var(--border);
  padding-bottom: 4px;
}
.help-content h2:first-child { margin-top: 0; }
.help-row {
  display: flex;
  justify-content: space-between;
  padding: 2px 0;
}
.help-key {
  background: var(--bg2);
  border: 1px solid var(--border);
  border-radius: 3px;
  padding: 0 6px;
  font-size: 11px;
  color: var(--fg-bright);
  min-width: 80px;
  text-align: center;
  display: inline-block;
}
.help-desc { color: var(--fg); }
.help-close {
  color: var(--accent-dim);
  font-size: 11px;
  text-align: center;
  margin-top: 24px;
  letter-spacing: 1px;
}
.help-close-btn {
  position: absolute;
  top: 0;
  right: 0;
  background: none;
  border: 1px solid var(--border);
  color: var(--fg-dim);
  font-size: 20px;
  width: 44px;
  height: 44px;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 0;
  cursor: pointer;
  text-transform: none;
  letter-spacing: 0;
}
.help-close-btn:hover {
  border-color: var(--err);
  color: var(--err);
}

/* ── SETTINGS PANEL ── */
.settings-overlay {
  display: none;
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.5);
  z-index: 1000;
}
.settings-overlay.visible { display: block; }
.settings-panel {
  display: none;
  position: fixed;
  top: 0;
  right: 0;
  bottom: 0;
  width: 280px;
  max-width: 90vw;
  background: var(--bg1);
  border-left: 1px solid var(--border);
  padding: 20px;
  overflow-y: auto;
  z-index: 1001;
  font-family: var(--mono);
  font-size: 12px;
  color: var(--fg);
}
.settings-close {
  position: absolute;
  top: 12px;
  right: 12px;
  background: none;
  border: 1px solid var(--border);
  color: var(--fg-dim);
  font-size: 18px;
  width: 32px;
  height: 32px;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 0;
  cursor: pointer;
  text-transform: none;
  letter-spacing: 0;
}
.settings-close:hover {
  border-color: var(--err);
  color: var(--err);
}

.settings-panel h2 {
  color: var(--accent);
  font-size: 11px;
  letter-spacing: 2px;
  text-transform: uppercase;
  margin: 20px 0 10px 0;
}
.settings-panel h2:first-child { margin-top: 0; }
.settings-row {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 6px 0;
}
.settings-row label { color: var(--fg-dim); font-size: 11px; }
.settings-row select,
.settings-row input[type="range"] {
  background: var(--bg2);
  border: 1px solid var(--border);
  color: var(--fg-bright);
  font-family: var(--mono);
  font-size: 11px;
  padding: 2px 4px;
}
.settings-row input[type="range"] {
  accent-color: var(--accent);
  width: 100px;
}
.settings-val {
  min-width: 30px;
  text-align: right;
  color: var(--fg-bright);
  font-size: 11px;
}

/* ── SETTINGS DESCRIPTIONS ── */
.settings-desc {
  color: var(--fg-dim);
  font-size: 10px;
  line-height: 1.5;
  padding: 4px 0 8px;
}
.settings-desc strong {
  color: var(--fg);
}

/* ── HIDE RUN TOGGLE ── */
html.hide-run-toggle #autorunBtn,
html.hide-run-toggle #autorunBtnMobile { display: none; }

/* ── MODULE LIST (settings panel) ── */
.module-row {
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 4px 0;
  font-size: 11px;
}
.module-url {
  flex: 1;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  color: var(--fg);
}
.module-info {
  color: var(--fg-dim);
  white-space: nowrap;
  font-size: 10px;
}
.module-remove {
  background: none;
  border: none;
  color: var(--fg-dim);
  font-size: 14px;
  padding: 0 2px;
  cursor: pointer;
  line-height: 1;
  text-transform: none;
  letter-spacing: 0;
}
.module-remove:hover { color: var(--err); }
.module-total {
  padding: 4px 0;
  font-size: 10px;
  color: var(--fg-dim);
  border-top: 1px solid var(--border);
  text-align: right;
}
.module-empty {
  color: var(--fg-dim);
  font-size: 11px;
  font-style: italic;
  padding: 4px 0;
}
/* ── UPDATE PANEL ── */
.update-overlay {
  display: none;
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.5);
  z-index: 1000;
}
.update-overlay.visible { display: block; }
.update-panel {
  display: none;
  position: fixed;
  top: 0;
  right: 0;
  bottom: 0;
  width: 280px;
  max-width: 90vw;
  background: var(--bg1);
  border-left: 1px solid var(--border);
  padding: 20px;
  overflow-y: auto;
  z-index: 1001;
  font-family: var(--mono);
  font-size: 12px;
  color: var(--fg);
}
.update-panel h2 {
  color: var(--accent);
  font-size: 11px;
  letter-spacing: 2px;
  text-transform: uppercase;
  margin: 0 0 12px 0;
}
.update-panel .settings-row {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 6px 0;
}
.update-panel .settings-row label { color: var(--fg-dim); font-size: 11px; }
.update-actions {
  display: flex;
  flex-direction: column;
  gap: 6px;
  padding: 8px 0;
}
.update-actions button {
  width: 100%;
  padding: 8px 10px;
}
.update-status {
  font-size: 11px;
  padding: 8px 0;
  line-height: 1.5;
}
.update-status strong { color: var(--fg-bright); }
.update-status button {
  display: block;
  width: 100%;
  margin-top: 8px;
  padding: 8px 10px;
  border-color: var(--accent-dim);
  color: var(--accent);
}
.update-status button:hover {
  border-color: var(--accent);
}
.update-ok { color: var(--ok); }
.update-err { color: var(--err); }
.update-warn { color: var(--accent); }
.update-available { color: var(--fg); }
.update-notes {
  color: var(--fg-dim);
  font-size: 11px;
  padding: 6px 0;
  max-height: 120px;
  overflow-y: auto;
  line-height: 1.4;
}
.update-notes p { margin: 0 0 4px; }
.update-notes ul { margin: 2px 0; padding-left: 16px; }
.update-notes li { margin: 1px 0; }
.update-notes h1, .update-notes h2, .update-notes h3 { font-size: 11px; margin: 4px 0 2px; color: var(--fg); }
.update-confirm {
  display: flex;
  gap: 8px;
  padding: 6px 0;
}
.update-confirm button { width: auto; }
.update-sig {
  font-size: 11px;
}
.update-key-truncated {
  cursor: pointer;
}
.update-key-truncated:hover {
  color: var(--accent);
}
.update-key-expanded {
  word-break: break-all;
  user-select: all;
  cursor: pointer;
  color: var(--fg-bright);
}
/* ── UPDATE BUTTON IN OVERFLOW TRAY ── */
.toolbar-update-btn {
  color: var(--accent) !important;
}

.settings-about {
  margin-top: 24px;
  padding-top: 12px;
  border-top: 1px solid var(--border);
  font-size: 11px;
  color: var(--fg-dim);
  display: flex;
  flex-direction: column;
  gap: 2px;
}
.settings-about a {
  color: var(--accent);
  text-decoration: none;
}
.settings-about a:hover { text-decoration: underline; }

/* ── FIND BAR ── */
.find-bar {
  display: none;
  flex-direction: column;
  position: sticky;
  top: 33px;
  z-index: 99;
  float: right;
  max-width: 400px;
  width: 100%;
  background: var(--bg1);
  border: 1px solid var(--border);
  border-top: none;
  padding: 6px 8px;
  gap: 4px;
}
.find-row {
  display: flex;
  align-items: center;
  gap: 4px;
}
.find-replace-row {
  display: none;
  align-items: center;
  gap: 4px;
}
.find-bar.show-replace .find-replace-row { display: flex; }
.find-bar input[type="text"] {
  flex: 1;
  background: var(--bg2);
  border: 1px solid var(--border);
  color: var(--fg-bright);
  font-family: var(--mono);
  font-size: 12px;
  padding: 4px 8px;
  outline: none;
  min-width: 0;
}
.find-bar input[type="text"]:focus {
  border-color: var(--border-hi);
}
.find-count {
  font-size: 10px;
  color: var(--fg-dim);
  white-space: nowrap;
  min-width: 50px;
  text-align: center;
  letter-spacing: 1px;
}
.find-bar button {
  padding: 3px 8px;
  font-size: 10px;
  min-width: 28px;
}
.find-bar button.active {
  color: var(--accent);
  border-color: var(--accent-dim);
}
body.presenting .find-bar { display: none !important; }

/* ── SEARCH OVERLAY ── */
.search-overlay {
  position: absolute;
  top: 0; left: 0; right: 0; bottom: 0;
  padding: 8px 10px 8px calc(var(--gutter) + 10px);
  font-family: var(--mono);
  font-size: var(--editor-font-size);
  line-height: 1.5;
  tab-size: 2;
  white-space: pre;
  overflow: hidden;
  z-index: 1;
  pointer-events: none;
  color: transparent;
  border: 1px solid transparent;
}
.search-overlay-md {
  padding: 8px 10px;
}
.md-search-wrap {
  position: relative;
}
.search-match {
  background: rgba(200,155,60,0.25);
  color: transparent;
}
.search-match-current {
  background: rgba(200,155,60,0.5);
  outline: 1px solid var(--accent);
}

/* ── AUTOCOMPLETE MENU ── */
.ac-menu {
  position: absolute;
  z-index: 10;
  background: #1e1e1e;
  border: 1px solid #444;
  border-radius: 3px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.4);
  max-height: 200px;
  overflow-y: auto;
  font-family: var(--mono);
  font-size: var(--editor-font-size);
  min-width: 120px;
}
.ac-item {
  padding: 2px 8px;
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 6px;
  white-space: nowrap;
}
.ac-item.active,
.ac-item:hover {
  background: rgba(200,155,60,0.2);
}
.ac-kind {
  width: 16px;
  height: 16px;
  border-radius: 2px;
  font-size: 10px;
  text-align: center;
  line-height: 16px;
  flex-shrink: 0;
}
.ac-kind-var, .ac-kind-def { color: #5ca7e4; }
.ac-kind-fn { color: #c89b3c; }
.ac-kind-kw { color: #cc7832; }
.ac-kind-const { color: #9876aa; }
.ac-kind-prop { color: #6a8759; }
.ac-text { color: var(--fg-bright); }
.ac-detail {
  margin-left: auto;
  padding-left: 12px;
  color: var(--fg-dim);
  font-size: 11px;
}
.ac-match { font-weight: bold; }
.ac-sig-hint {
  position: absolute;
  z-index: 10;
  background: #1e1e1e;
  border: 1px solid #444;
  border-radius: 3px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.4);
  padding: 3px 8px;
  font-family: var(--mono);
  font-size: var(--editor-font-size);
  white-space: nowrap;
  display: flex;
  gap: 10px;
  align-items: baseline;
}
.ac-sig-fn { color: var(--fg-bright); }
.ac-sig-active { color: var(--accent); font-weight: bold; text-decoration: underline; }
.ac-sig-desc { color: var(--fg-dim); font-size: 11px; }
:root.light .ac-sig-hint {
  background: #eae8e3;
  border-color: #b0ab9f;
  box-shadow: 0 2px 8px rgba(0,0,0,0.15);
}
:root.light .ac-menu {
  background: #eae8e3;
  border-color: #b0ab9f;
  box-shadow: 0 2px 8px rgba(0,0,0,0.15);
}
:root.light .ac-item.active,
:root.light .ac-item:hover {
  background: rgba(153,107,31,0.15);
}

/* ── WORKSHOP PANEL ── */
.workshop-overlay {
  display: none;
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.3);
  z-index: 900;
}
.workshop-overlay.visible { display: block; }
.workshop-panel {
  position: fixed;
  top: 0;
  right: -380px;
  bottom: 0;
  width: 360px;
  max-width: 90vw;
  background: var(--bg1);
  border-left: 1px solid var(--border);
  z-index: 901;
  display: flex;
  flex-direction: column;
  font-family: var(--mono);
  font-size: 13px;
  color: var(--fg);
  transition: right 0.25s ease;
  overflow: hidden;
}
.workshop-panel.open { right: 0; }
.workshop-tab {
  position: fixed;
  right: 0;
  top: 50%;
  transform: translateY(-50%) rotate(180deg);
  writing-mode: vertical-rl;
  background: var(--bg1);
  border: 1px solid var(--border);
  border-right: none;
  color: var(--accent);
  font-family: var(--mono);
  font-size: 10px;
  letter-spacing: 2px;
  text-transform: uppercase;
  padding: 10px 5px;
  cursor: pointer;
  z-index: 902;
  transition: right 0.25s ease;
}
.workshop-tab:hover { background: var(--bg2); }
.workshop-panel.open ~ .workshop-tab { right: min(360px, 90vw); }
.workshop-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 16px 16px 12px;
  border-bottom: 1px solid var(--border);
}
.workshop-title {
  color: var(--accent);
  font-size: 11px;
  letter-spacing: 2px;
  text-transform: uppercase;
}
.workshop-close {
  background: none;
  border: 1px solid var(--border);
  color: var(--fg-dim);
  font-size: 18px;
  width: 28px; height: 28px;
  display: flex; align-items: center; justify-content: center;
  padding: 0; cursor: pointer;
  text-transform: none;
  letter-spacing: 0;
}
.workshop-close:hover { border-color: var(--err); color: var(--err); }
.workshop-body {
  flex: 1;
  overflow-y: auto;
  padding: 16px;
  line-height: 1.6;
}
.workshop-body h1, .workshop-body h2, .workshop-body h3 {
  color: var(--fg-bright);
  margin: 1em 0 0.5em;
}
.workshop-body h1:first-child, .workshop-body h2:first-child, .workshop-body h3:first-child {
  margin-top: 0;
}
.workshop-body code {
  background: var(--bg2);
  padding: 1px 4px;
  font-size: 0.9em;
}
.workshop-body strong { color: var(--accent); }
.workshop-pips {
  display: flex;
  justify-content: center;
  gap: 6px;
  padding: 8px 16px;
}
.workshop-pip {
  width: 8px; height: 8px;
  border-radius: 50%;
  background: var(--border);
  cursor: pointer;
}
.workshop-pip.done { background: var(--fg-dim); }
.workshop-pip.active { background: var(--accent); }
.workshop-nav {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 12px 16px;
  border-top: 1px solid var(--border);
}
.workshop-nav button {
  background: var(--bg2);
  border: 1px solid var(--border);
  color: var(--fg);
  font-family: var(--mono);
  font-size: 11px;
  padding: 4px 12px;
  cursor: pointer;
}
.workshop-nav button:hover { border-color: var(--accent); color: var(--accent); }
.workshop-nav button:disabled { opacity: 0.3; cursor: default; }
.workshop-nav button:disabled:hover { border-color: var(--border); color: var(--fg); }
.workshop-counter { color: var(--fg-dim); font-size: 11px; }

/* ── LIGHT THEME ── */
:root.light {
  --bg: #f5f4f0;
  --bg1: #eae8e3;
  --bg2: #dedad3;
  --border: #ccc8bf;
  --border-hi: #b0ab9f;
  --fg: #444;
  --fg-dim: #888;
  --fg-bright: #222;
  --accent: #996b1f;
  --accent-dim: #b8924a;
  --err: #c33;
  --ok: #287;
}
:root.light .cell[data-type="code"] .cell-type { color: #4a7a9e; }
:root.light .cell[data-type="css"]  .cell-type { color: #a56e33; }
:root.light .cell[data-type="html"] .cell-type { color: #3d8a83; }
:root.light ::-webkit-scrollbar-track { background: var(--bg); }
:root.light ::-webkit-scrollbar-thumb { background: var(--border-hi); }

/* ── TOUCH / HEADER MODES ── */
@media (hover: none) {
  .insert-bar { display: none; }
  .cell.selected .cell-insert { display: inline; }
  .cell.selected .cell-convert { display: inline; }
  .cell.selected .cell-header {
    gap: 2px;
  }
  .cell.selected .cell-btn {
    min-height: 36px;
    min-width: 36px;
    font-size: 14px;
    display: inline-flex;
    align-items: center;
    justify-content: center;
  }
}

/* compact header: ellipsis indicator, full controls on select */
@media (hover: none) {
  :root:not(.header-always):not(.header-hover) .cell-header > * { display: none; }
  :root:not(.header-always):not(.header-hover) .cell-header {
    opacity: 1;
    justify-content: center;
    padding: 1px 8px;
  }
  :root:not(.header-always):not(.header-hover) .cell-header::before {
    content: '\22ef';
    color: var(--fg-dim);
    font-size: 12px;
    opacity: 0.4;
  }
  :root:not(.header-always):not(.header-hover) .cell.selected .cell-header > * { display: inline; }
  :root:not(.header-always):not(.header-hover) .cell.selected .cell-header::before { display: none; }
  :root:not(.header-always):not(.header-hover) .cell.selected .cell-header {
    justify-content: flex-start;
    padding: 2px 8px;
  }
}

/* header-always: full header visible on all devices */
:root.header-always .cell-header { opacity: 0.6; }
:root.header-always .cell:hover .cell-header,
:root.header-always .cell.selected .cell-header { opacity: 1; }

/* header-compact: forced compact mode on all devices */
:root.header-compact .cell-header > * { display: none; }
:root.header-compact .cell-header {
  opacity: 1 !important;
  justify-content: center;
  padding: 1px 8px;
}
:root.header-compact .cell-header::before {
  content: '\22ef';
  color: var(--fg-dim);
  font-size: 12px;
  opacity: 0.4;
}
:root.header-compact .cell.selected .cell-header > * { display: inline; }
:root.header-compact .cell.selected .cell-header::before { display: none; }
:root.header-compact .cell.selected .cell-header {
  justify-content: flex-start;
  padding: 2px 8px;
}

/* ── RESPONSIVE ── */
@media (max-width: 640px) {
  /* slim top toolbar: filename + cell count only */
  .toolbar {
    flex-wrap: nowrap;
    gap: 4px;
    padding: 6px 8px;
  }
  .toolbar-title { display: none; }
  .toolbar-sep { display: none; }
  .toolbar .toolbar-add, .toolbar .toolbar-secondary { display: none; }
  .transport { display: none; }
  .toolbar-right { display: none; }
  .toolbar-filename { flex: 1; }
  .toolbar-filename input { width: 100%; }
  .toolbar-status {
    display: inline;
    font-size: 10px;
    color: var(--fg-dim);
    white-space: nowrap;
    letter-spacing: 1px;
  }

  /* bottom action bar replaces statusbar */
  .statusbar {
    display: block;
    padding: 0;
    height: 48px;
  }
  .statusbar .status-size,
  .statusbar .status-cells,
  .statusbar .status-msg,
  .statusbar .status-attr { display: none; }
  .action-bar {
    display: grid;
    grid-template-columns: repeat(5, 1fr);
    height: 48px;
  }
  /* wrapper divs for tray positioning must fill their grid cell */
  .action-bar > div {
    position: relative;
    display: flex;
  }
  .action-bar > div > button {
    flex: 1;
  }
  /* style only the 5 action buttons, not tray buttons */
  .action-bar > button,
  .action-bar > div > button {
    min-height: 48px;
    border: none;
    border-right: 1px solid var(--border);
    background: var(--bg);
    font-family: var(--mono);
    font-size: 16px;
    color: var(--fg);
    padding: 0;
    letter-spacing: 0;
    text-transform: none;
  }
  .action-bar > :last-child > button,
  .action-bar > button:last-child { border-right: none; }
  .action-bar > button:active,
  .action-bar > div > button:active { background: var(--bg2); }
  .action-bar > button.autorun-on,
  .action-bar > div > button.autorun-on {
    background: #33aa77;
    color: #111;
  }
  .action-bar > button.autorun-off,
  .action-bar > div > button.autorun-off {
    background: #dd4444;
    color: #111;
  }

  .find-bar { max-width: 100%; float: none; }
  .notebook { padding: 8px 6px 100px; }
  .cell-header { padding: 2px 4px; }
  .settings-close { width: 44px; height: 44px; font-size: 22px; }
  .settings-row { padding: 10px 0; }
  .settings-row select { min-height: 44px; font-size: 14px; padding: 4px 8px; }
  .settings-row input[type="range"] { height: 44px; }
  .help-overlay { padding: 20px 12px; }
  .settings-panel { width: 260px; }
}

</style>
</head>
<body>

<div class="help-overlay" id="helpOverlay">
<div class="help-content">
<button class="help-close-btn" onclick="$('#helpOverlay').classList.remove('visible')">&#x00d7;</button>
<h2>command mode</h2>
<div class="help-row"><span class="help-key">&#x2191; / k</span><span class="help-desc">select cell above</span></div>
<div class="help-row"><span class="help-key">&#x2193; / j</span><span class="help-desc">select cell below</span></div>
<div class="help-row"><span class="help-key">Enter</span><span class="help-desc">edit selected cell</span></div>
<div class="help-row"><span class="help-key">a</span><span class="help-desc">insert cell above</span></div>
<div class="help-row"><span class="help-key">b</span><span class="help-desc">insert cell below</span></div>
<div class="help-row"><span class="help-key">d d</span><span class="help-desc">delete cell</span></div>
<div class="help-row"><span class="help-key">z</span><span class="help-desc">undo delete</span></div>
<div class="help-row"><span class="help-key">c</span><span class="help-desc">copy cell</span></div>
<div class="help-row"><span class="help-key">v</span><span class="help-desc">paste cell below</span></div>
<div class="help-row"><span class="help-key">x</span><span class="help-desc">cut cell</span></div>
<div class="help-row"><span class="help-key">m</span><span class="help-desc">convert to markdown</span></div>
<div class="help-row"><span class="help-key">y</span><span class="help-desc">convert to code</span></div>
<div class="help-row"><span class="help-key">s</span><span class="help-desc">convert to css</span></div>
<div class="help-row"><span class="help-key">t</span><span class="help-desc">convert to html template</span></div>
<div class="help-row"><span class="help-key">h</span><span class="help-desc">collapse / expand cell</span></div>
<div class="help-row"><span class="help-key">l</span><span class="help-desc">toggle line numbers</span></div>
<div class="help-row"><span class="help-key">p</span><span class="help-desc">presentation mode</span></div>

<h2>edit mode</h2>
<div class="help-row"><span class="help-key">Esc</span><span class="help-desc">exit to command mode</span></div>
<div class="help-row"><span class="help-key">Ctrl+Enter</span><span class="help-desc">run cell</span></div>
<div class="help-row"><span class="help-key">Shift+Enter</span><span class="help-desc">run cell + advance</span></div>
<div class="help-row"><span class="help-key">Ctrl+/</span><span class="help-desc">toggle comment</span></div>
<div class="help-row"><span class="help-key">Tab</span><span class="help-desc">indent</span></div>
<div class="help-row"><span class="help-key">Shift+Tab</span><span class="help-desc">unindent</span></div>

<h2>global</h2>
<div class="help-row"><span class="help-key">F1</span><span class="help-desc">toggle this help</span></div>
<div class="help-row"><span class="help-key">Ctrl+S</span><span class="help-desc">save notebook</span></div>
<div class="help-row"><span class="help-key">Ctrl+F</span><span class="help-desc">find in notebook</span></div>
<div class="help-row"><span class="help-key">Ctrl+H</span><span class="help-desc">find and replace</span></div>

<h2>toolbar</h2>
<div class="help-row"><span class="help-key">&#x23f5; step</span><span class="help-desc">run selected cell</span></div>
<div class="help-row"><span class="help-key">&#x25b6;/&#x2016;</span><span class="help-desc">toggle reactive mode (autorun)</span></div>
<div class="help-row"><span class="help-key">&#x25b6;&#x25b6; run all</span><span class="help-desc">run all cells</span></div>

<h2>builtins</h2>
<div class="help-row"><span class="help-key">display()</span><span class="help-desc">show text, objects, or DOM elements</span></div>
<div class="help-row"><span class="help-key">canvas(w,h)</span><span class="help-desc">create a canvas element</span></div>
<div class="help-row"><span class="help-key">table(data)</span><span class="help-desc">render array of objects as table</span></div>
<div class="help-row"><span class="help-key">slider()</span><span class="help-desc">reactive range input</span></div>
<div class="help-row"><span class="help-key">dropdown()</span><span class="help-desc">reactive select input</span></div>
<div class="help-row"><span class="help-key">checkbox()</span><span class="help-desc">reactive boolean input</span></div>
<div class="help-row"><span class="help-key">textInput()</span><span class="help-desc">reactive text input</span></div>
<div class="help-row"><span class="help-key">load(url)</span><span class="help-desc">import ESM module (cached)</span></div>
<div class="help-row"><span class="help-key">install(url)</span><span class="help-desc">import + embed in HTML on save</span></div>
<div class="help-row"><span class="help-key">installBinary(url)</span><span class="help-desc">fetch binary asset + embed gzipped</span></div>
<div class="help-row"><span class="help-key">invalidation</span><span class="help-desc">promise that resolves before cell re-runs</span></div>
<div class="help-row"><span class="help-key">md``</span><span class="help-desc">markdown tagged template</span></div>
<div class="help-row"><span class="help-key">html``</span><span class="help-desc">HTML tagged template</span></div>
<div class="help-row"><span class="help-key">css``</span><span class="help-desc">CSS tagged template</span></div>
<div class="help-row"><span class="help-key">workshop(pages)</span><span class="help-desc">interactive side panel with pages</span></div>
<div class="help-row"><span class="help-key">notebook</span><span class="help-desc">API for cells, scope, scrollTo, focus</span></div>

<h2>directives</h2>
<div class="help-row"><span class="help-key">// %manual</span><span class="help-desc">skip cell on reactive updates</span></div>
<div class="help-row"><span class="help-key">// %norun</span><span class="help-desc">skip cell on Run All</span></div>
<div class="help-row"><span class="help-key">// %hide</span><span class="help-desc">hide cell in present mode</span></div>
<div class="help-row"><span class="help-key">// %cellName &lt;label&gt;</span><span class="help-desc">name cell in DevTools</span></div>
<div class="help-row"><span class="help-key">// %outputId &lt;id&gt;</span><span class="help-desc">set id on output div</span></div>
<div class="help-row"><span class="help-key">// %outputClass &lt;cls&gt;</span><span class="help-desc">add classes to output div</span></div>
<div class="help-row"><span class="help-key">// %goto &lt;label&gt;</span><span class="help-desc">jump to named cell after execution</span></div>
<div class="help-row"><span class="help-key">// %collapsed</span><span class="help-desc">start cell collapsed</span></div>

<div class="help-close">press F1 or Esc to close</div>
</div>
</div>

<div class="settings-overlay" id="settingsOverlay" onclick="if(event.target===this)toggleSettings()"></div>
<div class="settings-panel" id="settingsPanel">
  <button class="settings-close" onclick="toggleSettings()">&#x00d7;</button>
  <h2>theme</h2>
  <div class="settings-row">
    <label>color scheme</label>
    <select id="setTheme" onchange="applyTheme(this.value)">
      <option value="dark">dark</option>
      <option value="light">light</option>
    </select>
  </div>

  <h2>editor</h2>
  <div class="settings-row">
    <label>font size</label>
    <input type="range" id="setFontSize" min="10" max="20" value="13" oninput="applyFontSize(this.value)">
    <span class="settings-val" id="setFontSizeVal">13</span>
  </div>
  <div class="settings-row">
    <label>line numbers</label>
    <select id="setLineNumbers" onchange="applyLineNumbers(this.value)">
      <option value="on" selected>on</option>
      <option value="off">off</option>
    </select>
  </div>

  <h2>notebook</h2>
  <div class="settings-row">
    <label>max width</label>
    <select id="setWidth" onchange="applyWidth(this.value)">
      <option value="720">narrow</option>
      <option value="860" selected>default</option>
      <option value="1100">wide</option>
      <option value="100%">full</option>
    </select>
  </div>
  <div class="settings-row">
    <label>cell header</label>
    <select id="setHeader" onchange="applyHeader(this.value)">
      <option value="auto" selected>auto</option>
      <option value="always">always visible</option>
      <option value="compact">compact</option>
      <option value="hover">hover only</option>
    </select>
  </div>

  <h2>execution</h2>
  <div class="settings-row">
    <label>mode</label>
    <select id="setExecMode" onchange="applyExecMode(this.value)">
      <option value="reactive">reactive</option>
      <option value="manual">manual</option>
    </select>
  </div>
  <div class="settings-row">
    <label>run on load</label>
    <select id="setRunOnLoad" onchange="applyRunOnLoad(this.value)">
      <option value="yes">yes</option>
      <option value="no">no</option>
    </select>
  </div>
  <div class="settings-row">
    <label>show run toggle</label>
    <select id="setShowToggle" onchange="applyShowToggle(this.value)">
      <option value="yes">yes</option>
      <option value="no">no</option>
    </select>
  </div>
  <div class="settings-desc">
    <strong>reactive</strong>: cells auto-run on edit, changes propagate.<br>
    <strong>manual</strong>: only Ctrl+Enter, Shift+Enter, or Run All.
  </div>
  <div class="settings-row">
    <label>global override</label>
    <select id="setGlobalExecMode" onchange="applyGlobalExecMode(this.value)">
      <option value="">(notebook default)</option>
      <option value="reactive">always reactive</option>
      <option value="manual">always manual</option>
    </select>
  </div>
  <div class="settings-row">
    <label>global run on load</label>
    <select id="setGlobalRunOnLoad" onchange="applyGlobalRunOnLoad(this.value)">
      <option value="">(notebook default)</option>
      <option value="yes">always run</option>
      <option value="no">never run</option>
    </select>
  </div>

  <h2>modules</h2>
  <div id="moduleList"></div>
  <h2>binaries</h2>
  <div id="binaryList"></div>

  <div class="settings-about">
    <span id="aboutVersion"></span>
    <span id="aboutBuild"></span>
    <span id="aboutRuntime"></span>
    <a href="https://github.com/endarthur/auditable" target="_blank">github.com/endarthur/auditable</a>
  </div>
</div>

<div class="update-overlay" id="updateOverlay" onclick="if(event.target===this)toggleUpdate()"></div>
<div class="update-panel" id="updatePanel">
  <button class="settings-close" onclick="toggleUpdate()">&#x00d7;</button>
  <h2>update</h2>
  <div class="settings-row">
    <label>version</label>
    <span id="updateCurrentVer">v0.0.0</span>
  </div>
  <div class="settings-row">
    <label>release</label>
    <span id="updateRelease">dev</span>
  </div>
  <div class="settings-row">
    <label>signature</label>
    <span id="updateSigStatus" class="update-sig">checking...</span>
  </div>
  <div class="settings-row">
    <label>public key</label>
    <span id="updatePubKey" class="update-sig">-</span>
  </div>
  <div id="updateStatus" class="update-status"></div>
  <div class="update-actions">
    <button id="updateCheckBtn" onclick="checkForUpdate()">check for updates</button>
    <button onclick="updateFromFile()">update from file</button>
  </div>
</div>

<div class="toolbar">
  <span class="toolbar-title">auditable</span>
  <span class="toolbar-badges" id="toolbarBadges"></span>
  <span class="toolbar-sep"></span>
  <span class="toolbar-filename">
    <input type="text" id="docTitle" value="atra + ALPACK — all-Wasm interpolation" spellcheck="false">
  </span>
  <span class="toolbar-status" id="toolbarStatus"></span>
  <button class="toolbar-add" onclick="addCellWithUndo('code','',S.selectedId)">+ code</button>
  <button class="toolbar-add" onclick="addCellWithUndo('md','',S.selectedId)">+ md</button>
  <button class="toolbar-secondary" onclick="addCellWithUndo('css','',S.selectedId)">+ css</button>
  <button class="toolbar-secondary" onclick="addCellWithUndo('html','',S.selectedId)">+ html</button>
  <span class="toolbar-sep"></span>
  <span class="transport">
    <button onclick="runSelectedCell()" title="run cell + advance (Shift+Enter)">&#x23f5;</button>
    <button id="autorunBtn" class="autorun-on" onclick="toggleAutorun()" title="reactive mode &#x2014; cells auto-run on edit">&#x25b6;</button>
    <button onclick="runAll()" title="run all cells">&#x25b6;&#x25b6;</button>
  </span>
  <span class="toolbar-right">
    <span class="save-split">
      <button class="accent" onclick="saveNotebook()"><span id="saveLabel">save</span></button><button class="accent save-caret" onclick="toggleSaveTray()">&#x25be;</button>
      <div class="save-tray" id="saveTray">
        <button onclick="setSaveMode('normal');saveNotebook()">save</button>
        <button onclick="setSaveMode('packed');saveNotebook()">save packed</button>
        <button onclick="exportAsTxt();toggleSaveTray()">export .txt</button>
      </div>
    </span>
    <div class="toolbar-overflow">
      <button onclick="toggleToolbarMenu()" title="more">&#x22ef;</button>
      <div class="toolbar-overflow-tray">
        <button onclick="newNotebook();toggleToolbarMenu()">new</button>
        <button onclick="collapseAll();toggleToolbarMenu()">collapse all</button>
        <button onclick="expandAll();toggleToolbarMenu()">expand all</button>
        <button onclick="$('#helpOverlay').classList.toggle('visible');toggleToolbarMenu()">help (F1)</button>
        <button onclick="toggleSettings();toggleToolbarMenu()">settings</button>
        <button class="toolbar-update-btn" onclick="toggleUpdate();toggleToolbarMenu()">update</button>
        <button onclick="togglePresent();toggleToolbarMenu()">present</button>
        <button onclick="openFind(false);toggleToolbarMenu()">find (Ctrl+F)</button>
      </div>
    </div>
  </span>
</div>

<div class="find-bar" id="findBar">
  <div class="find-row">
    <input type="text" id="findInput" placeholder="find" spellcheck="false" autocomplete="off">
    <span class="find-count" id="findCount"></span>
    <button id="findRegexBtn" title="use regex">.*</button>
    <button id="findCaseBtn" title="match case">Aa</button>
    <button id="findPrevBtn" title="previous (Shift+Enter)">&#x2191;</button>
    <button id="findNextBtn" title="next (Enter)">&#x2193;</button>
    <button id="findCloseBtn" title="close (Esc)">&#x00d7;</button>
  </div>
  <div class="find-replace-row" id="findReplaceRow">
    <input type="text" id="replaceInput" placeholder="replace" spellcheck="false" autocomplete="off">
    <button id="findReplaceBtn">replace</button>
    <button id="findReplaceAllBtn">all</button>
  </div>
</div>

<button class="present-exit" onclick="togglePresent()">&#x2715; exit</button>

<div class="notebook" id="notebook">
  <!-- cells go here -->
</div>

<div class="statusbar">
  <span class="status-size" id="statusSize"></span>
  <span class="status-cells" id="statusCells">0 cells</span>
  <span class="status-msg" id="statusMsg"></span>
  <span class="status-attr">
    <a href="https://endarthur.github.io" target="_blank">endarthur</a>
    <span>&middot;</span>
    <a href="https://gentropic.org" target="_blank">geoscientific chaos union</a>
    <span>&middot;</span>
    <a href="https://github.com/endarthur/auditable" target="_blank" title="source on GitHub"><svg width="14" height="14" viewBox="0 0 16 16" fill="currentColor"><path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"/></svg></a>
  </span>
  <div class="action-bar">
    <div>
      <div class="action-add-tray">
        <button onclick="insertAt(S.selectedId,'code');toggleAddTray()">+ code</button>
        <button onclick="insertAt(S.selectedId,'md');toggleAddTray()">+ md</button>
        <button onclick="insertAt(S.selectedId,'css');toggleAddTray()">+ css</button>
        <button onclick="insertAt(S.selectedId,'html');toggleAddTray()">+ html</button>
      </div>
      <button class="action-add" onclick="toggleAddTray()">+</button>
    </div>
    <button onclick="runSelectedCell()" title="run cell + advance">&#x23f5;</button>
    <button id="autorunBtnMobile" class="autorun-on" onclick="toggleAutorun()" title="autorun">&#x25b6;</button>
    <button onclick="runAll()" title="run all">&#x25b6;&#x25b6;</button>
    <div>
      <div class="action-more-tray">
        <button onclick="newNotebook();toggleMoreTray()">new</button>
        <button id="mobileSaveBtn" class="active-mode" onclick="setSaveMode('normal');saveNotebook();toggleMoreTray()">save</button>
        <button id="mobilePackBtn" onclick="setSaveMode('packed');saveNotebook();toggleMoreTray()">save packed</button>
        <button onclick="collapseAll();toggleMoreTray()">collapse all</button>
        <button onclick="expandAll();toggleMoreTray()">expand all</button>
        <button onclick="$('#helpOverlay').classList.toggle('visible');toggleMoreTray()">help</button>
        <button onclick="toggleSettings();toggleMoreTray()">settings</button>
        <button class="toolbar-update-btn" onclick="toggleUpdate();toggleMoreTray()">update</button>
        <button onclick="togglePresent();toggleMoreTray()">present</button>
        <button onclick="openFind(false);toggleMoreTray()">find</button>
      </div>
      <button class="action-more" onclick="toggleMoreTray()">&#x22ef;</button>
    </div>
  </div>
</div>


<!-- cell data: JSON array of {type, code, collapsed?} -->
<!--AUDITABLE-DATA
[{"type":"md","code":"# atra + ALPACK — library routines in atra\n\natra functions call each other with zero overhead — they compile to Wasm `call` instructions. this notebook does **radial basis function (RBF) interpolation** entirely in WebAssembly: matrix assembly, LU factorization, backsolve, and grid evaluation all happen in atra. JS only generates samples and renders the result.\n\nthe key pattern: `rbf.solve` calls `alpack.dgetrf` and `alpack.dgetrs`. library routines are just regular functions in the same compilation unit — no FFI, no glue code, no overhead. `std.include()` resolves dependencies and `${}` splices the source in at compile time."},{"type":"code","code":"const { atra } = await load(\"./ext/atra/index.js\");\nconst alpack = await load(\"./ext/atra/lib/alpack.src.js\");\n\nconst nPts = ui.slider(\"samples\", 25, {min: 5, max: 60, step: 1});\nconst gridN = ui.slider(\"grid\", 100, {min: 40, max: 200, step: 10});\nconst eps0 = ui.slider(\"\\u03b5 (shape)\", 20.0, {min: 1, max: 100, step: 1});"},{"type":"code","code":"// all-atra RBF interpolation — ALPACK solver + application kernel\nconst mem = new WebAssembly.Memory({ initial: 4 });\n\nconst wasm = atra({ memory: mem })`\n  ! ══ ALPACK: LU factorization (library) ══\n  ! std.include() resolves dependencies and splices source from alpack.atra.\n  ${std.include(alpack, 'alpack.dgetrf', 'alpack.dgetrs')}\n\n  ! ══ RBF interpolation (application) ══\n\n  ! Gaussian RBF kernel: φ(r) = exp(−ε r²)\n  function rbf.kernel(r2, eps: f64): f64\n  begin\n    rbf.kernel := exp(-eps * r2)\n  end\n\n  ! build n×n RBF interpolation matrix\n  ! samples stored as (x, y, value) triples\n  subroutine rbf.build_matrix(\n    samples: array f64; n: i32;\n    A: array f64; eps: f64\n  )\n  var i, j: i32; dx, dy: f64\n  begin\n    for i := 0, n\n      for j := 0, n\n        dx := samples[i * 3] - samples[j * 3]\n        dy := samples[i * 3 + 1] - samples[j * 3 + 1]\n        A[i, n, j] := rbf.kernel(dx * dx + dy * dy, eps)\n      end for\n    end for\n  end\n\n  ! copy sample values into weight vector (= RHS before solve)\n  subroutine rbf.init_weights(\n    samples: array f64; n: i32;\n    w: array f64\n  )\n  var i: i32\n  begin\n    for i := 0, n\n      w[i] := samples[i * 3 + 2]\n    end for\n  end\n\n  ! factorize + solve: A * w = values\n  ! w is overwritten: input = sample values, output = RBF weights\n  ! this is where atra calls ALPACK library routines\n  subroutine rbf.solve(\n    A: array f64; w: array f64; n: i32;\n    ipiv: array i32; info: array i32\n  )\n  begin\n    call alpack.dgetrf(A, n, ipiv, info)\n    call alpack.dgetrs(A, ipiv, w, n, 1)\n  end\n\n  ! evaluate RBF interpolant on a gridN × gridN grid\n  subroutine rbf.eval_grid(\n    samples: array f64; w: array f64; n: i32;\n    grid: array f64; gridN: i32; eps: f64\n  )\n  var\n    ix, iy, k: i32\n    gx, gy, dx, dy, val: f64\n  begin\n    for iy := 0, gridN\n      for ix := 0, gridN\n        gx := f64(ix) / f64(gridN)\n        gy := f64(iy) / f64(gridN)\n        val := 0.0\n        for k := 0, n\n          dx := gx - samples[k * 3]\n          dy := gy - samples[k * 3 + 1]\n          val := val + w[k] * rbf.kernel(dx * dx + dy * dy, eps)\n        end for\n        grid[iy * gridN + ix] := val\n      end for\n    end for\n  end\n`;"},{"type":"code","code":"// generate samples + run all-Wasm pipeline\nfunction mulberry32(a) {\n  return function() {\n    a |= 0; a = a + 0x6D2B79F5 | 0;\n    let t = Math.imul(a ^ a >>> 15, 1 | a);\n    t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;\n    return ((t ^ t >>> 14) >>> 0) / 4294967296;\n  };\n}\nconst rng = mulberry32(42);\n\nconst f64 = new Float64Array(mem.buffer);\n\n// memory layout (byte offsets)\nconst sampPtr = 0;\nconst matPtr = sampPtr + nPts * 3 * 8;\nconst wPtr = matPtr + nPts * nPts * 8;\nconst gridPtr = wPtr + nPts * 8;\nconst ipivPtr = gridPtr + gridN * gridN * 8;\nconst infoPtr = ipivPtr + nPts * 4;\n\n// generate samples in [0,1]x[0,1]\nfor (let i = 0; i < nPts; i++) {\n  const x = rng(), y = rng();\n  const v = 0.5 * Math.sin(x * 4) * Math.cos(y * 3) + 0.5 + 0.2 * rng();\n  f64[i * 3] = x;\n  f64[i * 3 + 1] = y;\n  f64[i * 3 + 2] = v;\n}\n\n// entire pipeline in Wasm\nconst t0 = performance.now();\nwasm.rbf.build_matrix(sampPtr, nPts, matPtr, eps0);\nwasm.rbf.init_weights(sampPtr, nPts, wPtr);\nwasm.rbf.solve(matPtr, wPtr, nPts, ipivPtr, infoPtr);\nwasm.rbf.eval_grid(sampPtr, wPtr, nPts, gridPtr, gridN, eps0);\nconst elapsed = (performance.now() - t0).toFixed(2);\n\nconst grid = new Float64Array(mem.buffer, gridPtr, gridN * gridN);"},{"type":"code","code":"// render\nconst size = Math.min(480, window.innerWidth - 80);\nconst c = ui.canvas(size, size);\nconst ctx = c.getContext(\"2d\");\n\nfunction viridis(t) {\n  t = Math.max(0, Math.min(1, t));\n  const r = Math.round(255 * Math.max(0, Math.min(1,\n    0.267 + t * (0.004 + t * (5.294 + t * (-14.05 + t * 8.5))))));\n  const g = Math.round(255 * Math.max(0, Math.min(1,\n    0.004 + t * (1.384 + t * (0.098 + t * (-2.74 + t * 2.23))))));\n  const b = Math.round(255 * Math.max(0, Math.min(1,\n    0.329 + t * (1.44 + t * (-5.11 + t * (6.87 + t * -3.57))))));\n  return `rgb(${r},${g},${b})`;\n}\n\nlet vmin = Infinity, vmax = -Infinity;\nfor (let i = 0; i < grid.length; i++) {\n  if (grid[i] < vmin) vmin = grid[i];\n  if (grid[i] > vmax) vmax = grid[i];\n}\nconst vrange = vmax - vmin || 1;\n\nconst cellW = size / gridN;\nfor (let iy = 0; iy < gridN; iy++) {\n  for (let ix = 0; ix < gridN; ix++) {\n    const t = (grid[iy * gridN + ix] - vmin) / vrange;\n    ctx.fillStyle = viridis(t);\n    ctx.fillRect(ix * cellW, iy * cellW, cellW + 0.5, cellW + 0.5);\n  }\n}\n\n// overlay sample points\nfor (let i = 0; i < nPts; i++) {\n  const x = f64[i * 3] * size, y = f64[i * 3 + 1] * size;\n  ctx.beginPath();\n  ctx.arc(x, y, 4, 0, Math.PI * 2);\n  ctx.fillStyle = \"#fff\";\n  ctx.fill();\n  ctx.lineWidth = 1.5;\n  ctx.strokeStyle = \"#000\";\n  ctx.stroke();\n}\n\nui.display(`RBF interpolation \\u00b7 ${gridN}\\u00d7${gridN} grid \\u00b7 ${nPts} samples \\u00b7 \\u03b5=${eps0} \\u00b7 all-Wasm: ${elapsed} ms`);"},{"type":"md","code":"**how it works:** `alpack.src.js` exports each ALPACK routine as a source string, plus a dependency map. `std.include(alpack, 'alpack.dgetrf', 'alpack.dgetrs')` resolves transitive dependencies and returns the needed source. `${}` splices it into the tagged template — atra treats string interpolations as source inclusion. the result is a single Wasm module where `rbf.solve` calls `alpack.dgetrf` and `alpack.dgetrs` with plain `call` instructions. the entire pipeline runs in Wasm; JS only writes sample coordinates into shared linear memory and reads the grid back for rendering."}]
AUDITABLE-DATA-->
<!-- installed modules: base64-encoded JSON mapping URLs to {source, cellId} -->
<!--AUDITABLE-MODULES
eyIuL2V4dC9hdHJhL2luZGV4LmpzIjp7InNvdXJjZSI6Ii8vIEBhdWRpdGFibGUvYXRyYSDigJQg
QXJpdGhtZXRpYyBUUkFuc3BpbGVyXG4vLyBGb3J0cmFuL1Bhc2NhbCBoeWJyaWQg4oaSIFdlYkFz
c2VtYmx5IGJ5dGVjb2RlLiBTaW5nbGUtZmlsZSBjb21waWxlci5cblxuLy8gLS0gaGlnaGxpZ2h0
LmpzIC0tXG5cbi8vIFN5bnRheCBoaWdobGlnaHRpbmcg4oCUIHRva2VuaXplciArIGNvbXBsZXRp
b25zIGZvciBhdWRpdGFibGUgZWRpdG9yIGludGVncmF0aW9uXG4vL1xuLy8gVGhlc2Uga2V5d29y
ZC90eXBlL2J1aWx0aW4gc2V0cyBkZWZpbmUgdGhlIGxhbmd1YWdlJ3Mgdm9jYWJ1bGFyeS4gVGhl
eSdyZSBzaGFyZWRcbi8vIGJldHdlZW4gdGhpcyBtb2R1bGUgKGVkaXRvciBoaWdobGlnaHRpbmcg
KyBjb21wbGV0aW9ucykgYW5kIGxleC5qcyAoY29tcGlsZXIgdG9rZW5pemVyKS5cblxuY29uc3Qg
QVRSQV9LRVlXT1JEUyA9IG5ldyBTZXQoW1xuICAnZnVuY3Rpb24nLCdzdWJyb3V0aW5lJywnYmVn
aW4nLCdlbmQnLCd2YXInLCdjb25zdCcsJ2lmJywndGhlbicsJ2Vsc2UnLFxuICAnZm9yJywnd2hp
bGUnLCdkbycsJ2JyZWFrJywnYW5kJywnb3InLCdub3QnLCdtb2QnLCdpbXBvcnQnLCdleHBvcnQn
LFxuICAnY2FsbCcsJ2FycmF5JywndHJ1ZScsJ2ZhbHNlJywnZnJvbScsJ3RhaWxjYWxsJywncmV0
dXJuJyxcbl0pO1xuXG5jb25zdCBBVFJBX1RZUEVTID0gbmV3IFNldChbJ2kzMicsJ2k2NCcsJ2Yz
MicsJ2Y2NCcsJ2Y2NHgyJywnZjMyeDQnLCdpMzJ4NCcsJ2k2NHgyJ10pO1xuXG5jb25zdCBBVFJB
X0JVSUxUSU5TID0gbmV3IFNldChbXG4gICdzaW4nLCdjb3MnLCdzcXJ0JywnYWJzJywnZmxvb3In
LCdjZWlsJywnbG4nLCdleHAnLCdwb3cnLFxuICAnbWluJywnbWF4JywndHJ1bmMnLCduZWFyZXN0
JywnY29weXNpZ24nLCdzZWxlY3QnLFxuICAnY2x6JywnY3R6JywncG9wY250Jywncm90bCcsJ3Jv
dHInLCdtZW1vcnlfc2l6ZScsJ21lbW9yeV9ncm93JyxcbiAgJ21lbW9yeV9jb3B5JywnbWVtb3J5
X2ZpbGwnLFxuXSk7XG5cbmNvbnN0IEFUUkFfVkVDVE9SX1RZUEVTID0gbmV3IFNldChbJ2Y2NHgy
JywnZjMyeDQnLCdpMzJ4NCcsJ2k2NHgyJ10pO1xuXG5mdW5jdGlvbiB0b2tlbml6ZUF0cmEoY29k
ZSkge1xuICBjb25zdCB0b2tlbnMgPSBbXTtcbiAgbGV0IGkgPSAwO1xuICBjb25zdCBsZW4gPSBj
b2RlLmxlbmd0aDtcblxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIC8vIGxpbmUgY29tbWVudDog
ISB0byBlbmQgb2YgbGluZVxuICAgIGlmIChjb2RlW2ldID09PSAnIScpIHtcbiAgICAgIGNvbnN0
IHN0YXJ0ID0gaTtcbiAgICAgIHdoaWxlIChpIDwgbGVuICYmIGNvZGVbaV0gIT09ICdcXG4nKSBp
Kys7XG4gICAgICB0b2tlbnMucHVzaCh7IHR5cGU6ICdjbXQnLCB0ZXh0OiBjb2RlLnNsaWNlKHN0
YXJ0LCBpKSB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICAvLyBudW1iZXJzICh3aXRo
IG9wdGlvbmFsIHR5cGUgc3VmZml4IF9mMzIsIF9mNjQsIF9pMzIsIF9pNjQpXG4gICAgaWYgKC9c
XGQvLnRlc3QoY29kZVtpXSkgfHwgKGNvZGVbaV0gPT09ICcuJyAmJiBpICsgMSA8IGxlbiAmJiAv
XFxkLy50ZXN0KGNvZGVbaSArIDFdKSkpIHtcbiAgICAgIGNvbnN0IHN0YXJ0ID0gaTtcbiAgICAg
IHdoaWxlIChpIDwgbGVuICYmIC9bMC05Ll0vLnRlc3QoY29kZVtpXSkpIGkrKztcbiAgICAgIGlm
IChpIDwgbGVuICYmIC9bZUVdLy50ZXN0KGNvZGVbaV0pKSB7XG4gICAgICAgIGkrKztcbiAgICAg
ICAgaWYgKGkgPCBsZW4gJiYgL1srLV0vLnRlc3QoY29kZVtpXSkpIGkrKztcbiAgICAgICAgd2hp
bGUgKGkgPCBsZW4gJiYgL1xcZC8udGVzdChjb2RlW2ldKSkgaSsrO1xuICAgICAgfVxuICAgICAg
Ly8gdHlwZSBzdWZmaXg6IF9mMzIsIF9mNjQsIF9pMzIsIF9pNjRcbiAgICAgIGlmIChjb2RlW2ld
ID09PSAnXycgJiYgaSArIDMgPD0gbGVuICYmIC9eW2ZpXS8udGVzdChjb2RlW2kgKyAxXSkpIHtc
biAgICAgICAgY29uc3Qgc3VmID0gY29kZS5zbGljZShpICsgMSwgaSArIDQpO1xuICAgICAgICBp
ZiAoQVRSQV9UWVBFUy5oYXMoc3VmKSkgaSArPSA0O1xuICAgICAgfVxuICAgICAgdG9rZW5zLnB1
c2goeyB0eXBlOiAnbnVtJywgdGV4dDogY29kZS5zbGljZShzdGFydCwgaSkgfSk7XG4gICAgICBj
b250aW51ZTtcbiAgICB9XG4gICAgLy8gaWRlbnRpZmllcnMgLyBrZXl3b3Jkc1xuICAgIGlmICgv
W2EtekEtWl9dLy50ZXN0KGNvZGVbaV0pKSB7XG4gICAgICBjb25zdCBzdGFydCA9IGk7XG4gICAg
ICB3aGlsZSAoaSA8IGxlbiAmJiAvW1xcdy5dLy50ZXN0KGNvZGVbaV0pKSBpKys7XG4gICAgICBj
b25zdCB3b3JkID0gY29kZS5zbGljZShzdGFydCwgaSk7XG4gICAgICBjb25zdCBsb3dlciA9IHdv
cmQudG9Mb3dlckNhc2UoKTtcbiAgICAgIGlmIChBVFJBX0tFWVdPUkRTLmhhcyhsb3dlcikpIHtc
biAgICAgICAgdG9rZW5zLnB1c2goeyB0eXBlOiAna3cnLCB0ZXh0OiB3b3JkIH0pO1xuICAgICAg
fSBlbHNlIGlmIChBVFJBX1RZUEVTLmhhcyhsb3dlcikpIHtcbiAgICAgICAgLy8gdHlwZSBuYW1l
cyBhcyBidWlsdGlucyB3aGVuIGZvbGxvd2VkIGJ5IChcbiAgICAgICAgaWYgKGkgPCBsZW4gJiYg
Y29kZVtpXSA9PT0gJygnKSB7XG4gICAgICAgICAgdG9rZW5zLnB1c2goeyB0eXBlOiAnZm4nLCB0
ZXh0OiB3b3JkIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRva2Vucy5wdXNoKHsg
dHlwZTogJ2NvbnN0JywgdGV4dDogd29yZCB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlm
IChBVFJBX0JVSUxUSU5TLmhhcyhsb3dlcikgfHwgbG93ZXIuc3RhcnRzV2l0aCgnd2FzbS4nKSB8
fFxuICAgICAgICAgICAgICAgICBsb3dlci5zdGFydHNXaXRoKCd2MTI4LicpIHx8IChBVFJBX1ZF
Q1RPUl9UWVBFUy5oYXMobG93ZXIuc3BsaXQoJy4nKVswXSkgJiYgbG93ZXIuaW5jbHVkZXMoJy4n
KSkpIHtcbiAgICAgICAgdG9rZW5zLnB1c2goeyB0eXBlOiAnZm4nLCB0ZXh0OiB3b3JkIH0pO1xu
ICAgICAgfSBlbHNlIGlmIChpIDwgbGVuICYmIGNvZGVbaV0gPT09ICcoJykge1xuICAgICAgICB0
b2tlbnMucHVzaCh7IHR5cGU6ICdmbicsIHRleHQ6IHdvcmQgfSk7XG4gICAgICB9IGVsc2Uge1xu
ICAgICAgICB0b2tlbnMucHVzaCh7IHR5cGU6ICdpZCcsIHRleHQ6IHdvcmQgfSk7XG4gICAgICB9
XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgLy8gbXVsdGktY2hhciBvcGVyYXRvcnNcbiAg
ICBpZiAoaSArIDEgPCBsZW4pIHtcbiAgICAgIGNvbnN0IHR3byA9IGNvZGVbaV0gKyBjb2RlW2kg
KyAxXTtcbiAgICAgIGlmICh0d28gPT09ICcqKicgfHwgdHdvID09PSAnOj0nIHx8IHR3byA9PT0g
Jys9JyB8fCB0d28gPT09ICctPScgfHxcbiAgICAgICAgICB0d28gPT09ICcqPScgfHwgdHdvID09
PSAnLz0nIHx8IHR3byA9PT0gJz09JyB8fCB0d28gPT09ICc8PScgfHxcbiAgICAgICAgICB0d28g
PT09ICc+PScgfHwgdHdvID09PSAnPDwnIHx8IHR3byA9PT0gJz4+Jykge1xuICAgICAgICB0b2tl
bnMucHVzaCh7IHR5cGU6ICdvcCcsIHRleHQ6IHR3byB9KTtcbiAgICAgICAgaSArPSAyO1xuICAg
ICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gc2luZ2xlLWNoYXIgb3BlcmF0
b3JzXG4gICAgaWYgKCcrLSovPD49JnxefkAnLmluY2x1ZGVzKGNvZGVbaV0pKSB7XG4gICAgICB0
b2tlbnMucHVzaCh7IHR5cGU6ICdvcCcsIHRleHQ6IGNvZGVbaV0gfSk7XG4gICAgICBpKys7XG4g
ICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgLy8gcHVuY3R1YXRpb25cbiAgICBpZiAoJygpW107
LDonLmluY2x1ZGVzKGNvZGVbaV0pKSB7XG4gICAgICB0b2tlbnMucHVzaCh7IHR5cGU6ICdwdW5j
JywgdGV4dDogY29kZVtpXSB9KTtcbiAgICAgIGkrKztcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1c
biAgICAvLyB3aGl0ZXNwYWNlIC8gb3RoZXJcbiAgICB0b2tlbnMucHVzaCh7IHR5cGU6ICcnLCB0
ZXh0OiBjb2RlW2ldIH0pO1xuICAgIGkrKztcbiAgfVxuICByZXR1cm4gdG9rZW5zO1xufVxuXG5m
dW5jdGlvbiBhdHJhQ29tcGxldGlvbnMoKSB7XG4gIGNvbnN0IGl0ZW1zID0gW107XG4gIGZvciAo
Y29uc3QgdyBvZiBBVFJBX0tFWVdPUkRTKSBpdGVtcy5wdXNoKHsgdGV4dDogdywga2luZDogJ2t3
JyB9KTtcbiAgZm9yIChjb25zdCB3IG9mIEFUUkFfVFlQRVMpICAgIGl0ZW1zLnB1c2goeyB0ZXh0
OiB3LCBraW5kOiAnY29uc3QnIH0pO1xuICBmb3IgKGNvbnN0IHcgb2YgQVRSQV9CVUlMVElOUykg
aXRlbXMucHVzaCh7IHRleHQ6IHcsIGtpbmQ6ICdmbicgfSk7XG4gIHJldHVybiBpdGVtcztcbn1c
blxuLy8gLS0gbGV4LmpzIC0tXG5cbi8vIExleGVyIOKAlCB0b2tlbml6ZXIgZm9yIHRoZSBwYXJz
ZXJcbi8vXG4vLyBBdHJhJ3MgbGV4aWNhbCBkZXNpZ24gYm9ycm93cyBmcm9tIEZvcnRyYW46ICEg
Zm9yIGxpbmUgY29tbWVudHMsIC89IGZvciBub3QtZXF1YWwsXG4vLyBzZW1pY29sb25zIGFzIHdo
aXRlc3BhY2UgKG9wdGlvbmFsIHN0YXRlbWVudCBzZXBhcmF0b3JzKS4gSWRlbnRpZmllcnMgY2Fu
IGNvbnRhaW4gZG90c1xuLy8gZm9yIG5hbWVzcGFjZS1zdHlsZSBhY2Nlc3MgKGUuZy4gcGh5c2lj
cy5ncmF2aXR5KSwgdHJlYXRlZCBhcyBhIHNpbmdsZSB0b2tlbi5cblxuXG5jb25zdCBUT0sgPSB7
XG4gIE5VTTogJ251bScsIElEOiAnaWQnLCBLVzogJ2t3JywgT1A6ICdvcCcsIFBVTkM6ICdwdW5j
JywgRU9GOiAnZW9mJyxcbn07XG5cbmZ1bmN0aW9uIGxleChzb3VyY2UpIHtcbiAgY29uc3QgdG9r
ZW5zID0gW107XG4gIGxldCBpID0gMCwgbGluZSA9IDEsIGNvbCA9IDE7XG4gIGNvbnN0IGxlbiA9
IHNvdXJjZS5sZW5ndGg7XG5cbiAgZnVuY3Rpb24gYWR2KCkgeyBpZiAoc291cmNlW2ldID09PSAn
XFxuJykgeyBsaW5lKys7IGNvbCA9IDE7IH0gZWxzZSB7IGNvbCsrOyB9IGkrKzsgfVxuICBmdW5j
dGlvbiBwZWVrKCkgeyByZXR1cm4gaSA8IGxlbiA/IHNvdXJjZVtpXSA6ICcnOyB9XG4gIGZ1bmN0
aW9uIHBlZWsyKCkgeyByZXR1cm4gaSArIDEgPCBsZW4gPyBzb3VyY2VbaV0gKyBzb3VyY2VbaSAr
IDFdIDogc291cmNlW2ldIHx8ICcnOyB9XG5cbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAvLyBz
a2lwIHdoaXRlc3BhY2UgYW5kIHNlbWljb2xvbnNcbiAgICBpZiAoJyBcXHRcXHJcXG47Jy5pbmNs
dWRlcyhzb3VyY2VbaV0pKSB7IGFkdigpOyBjb250aW51ZTsgfVxuICAgIC8vIGNvbW1lbnRcbiAg
ICBpZiAoc291cmNlW2ldID09PSAnIScpIHtcbiAgICAgIHdoaWxlIChpIDwgbGVuICYmIHNvdXJj
ZVtpXSAhPT0gJ1xcbicpIGFkdigpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0
IHRsID0gbGluZSwgdGMgPSBjb2w7XG4gICAgLy8gbnVtYmVyXG4gICAgaWYgKC9cXGQvLnRlc3Qo
c291cmNlW2ldKSB8fCAoc291cmNlW2ldID09PSAnLicgJiYgaSArIDEgPCBsZW4gJiYgL1xcZC8u
dGVzdChzb3VyY2VbaSArIDFdKSkpIHtcbiAgICAgIGNvbnN0IHN0YXJ0ID0gaTtcbiAgICAgIGxl
dCBpc0Zsb2F0ID0gZmFsc2U7XG4gICAgICB3aGlsZSAoaSA8IGxlbiAmJiAvXFxkLy50ZXN0KHNv
dXJjZVtpXSkpIGFkdigpO1xuICAgICAgaWYgKHBlZWsoKSA9PT0gJy4nICYmIC9cXGQvLnRlc3Qo
c291cmNlW2kgKyAxXSB8fCAnJykpIHsgaXNGbG9hdCA9IHRydWU7IGFkdigpOyB3aGlsZSAoaSA8
IGxlbiAmJiAvXFxkLy50ZXN0KHNvdXJjZVtpXSkpIGFkdigpOyB9XG4gICAgICBpZiAoL1tlRV0v
LnRlc3QocGVlaygpKSkgeyBpc0Zsb2F0ID0gdHJ1ZTsgYWR2KCk7IGlmICgvWystXS8udGVzdChw
ZWVrKCkpKSBhZHYoKTsgd2hpbGUgKGkgPCBsZW4gJiYgL1xcZC8udGVzdChzb3VyY2VbaV0pKSBh
ZHYoKTsgfVxuICAgICAgbGV0IHR5cGVTdWZmaXggPSBudWxsO1xuICAgICAgaWYgKHBlZWsoKSA9
PT0gJ18nKSB7XG4gICAgICAgIGNvbnN0IHMgPSBzb3VyY2Uuc2xpY2UoaSArIDEsIGkgKyA0KTtc
biAgICAgICAgaWYgKEFUUkFfVFlQRVMuaGFzKHMpKSB7IHR5cGVTdWZmaXggPSBzOyBhZHYoKTsg
YWR2KCk7IGFkdigpOyBhZHYoKTsgfVxuICAgICAgfVxuICAgICAgY29uc3QgcmF3ID0gc291cmNl
LnNsaWNlKHN0YXJ0LCBpKTtcbiAgICAgIHRva2Vucy5wdXNoKHsgdHlwZTogVE9LLk5VTSwgdmFs
dWU6IHJhdywgaXNGbG9hdCwgdHlwZVN1ZmZpeCwgbGluZTogdGwsIGNvbDogdGMgfSk7XG4gICAg
ICBjb250aW51ZTtcbiAgICB9XG4gICAgLy8gaWRlbnRpZmllciAoZG90cyBhbGxvd2VkIOKAlCBu
YW1lc3BhY2VzIGJ5IGNvbnZlbnRpb24pXG4gICAgaWYgKC9bYS16QS1aX10vLnRlc3Qoc291cmNl
W2ldKSkge1xuICAgICAgY29uc3Qgc3RhcnQgPSBpO1xuICAgICAgd2hpbGUgKGkgPCBsZW4gJiYg
L1tcXHcuXS8udGVzdChzb3VyY2VbaV0pKSBhZHYoKTtcbiAgICAgIC8vIFRyaW0gdHJhaWxpbmcg
ZG90OiBwYXJ0aWFsIG5hbWVzcGFjZSBhdCBFT0YgKGUuZy4gXCJuYW1lLlwiKSBzaG91bGRuJ3Rc
biAgICAgIC8vIHN3YWxsb3cgdGhlIGRvdC4gVGhpcyBsZXRzIHRoZSBlZGl0b3IgcmVjb3ZlciBn
cmFjZWZ1bGx5IG1pZC10eXBpbmcuXG4gICAgICB3aGlsZSAoaSA+IHN0YXJ0ICsgMSAmJiBzb3Vy
Y2VbaSAtIDFdID09PSAnLicpIHsgaS0tOyBjb2wtLTsgfVxuICAgICAgbGV0IHZhbCA9IHNvdXJj
ZS5zbGljZShzdGFydCwgaSk7XG4gICAgICAvLyBUYWdnZWQgdGVtcGxhdGUgaW50ZXJwb2xhdGlv
bnMgYmVjb21lIF9fSU5URVJQX05fXyBtYXJrZXJzIGluIHRoZSBzb3VyY2UgdGV4dC5cbiAgICAg
IC8vIFRoZSBwYXJzZXIgdHJlYXRzIHRoZW0gYXMgaWRlbnRpZmllcnM7IGNvZGVnZW4gcmVzb2x2
ZXMgdGhlbSB0byBpbXBvcnRzLlxuICAgICAgaWYgKC9eX19JTlRFUlBfXFxkK19fJC8udGVzdCh2
YWwpKSB7XG4gICAgICAgIHRva2Vucy5wdXNoKHsgdHlwZTogVE9LLklELCB2YWx1ZTogdmFsLCBp
bnRlcnA6IHRydWUsIGxpbmU6IHRsLCBjb2w6IHRjIH0pO1xuICAgICAgfSBlbHNlIGlmIChBVFJB
X0tFWVdPUkRTLmhhcyh2YWwpIHx8IEFUUkFfVFlQRVMuaGFzKHZhbCkpIHtcbiAgICAgICAgdG9r
ZW5zLnB1c2goeyB0eXBlOiBUT0suS1csIHZhbHVlOiB2YWwsIGxpbmU6IHRsLCBjb2w6IHRjIH0p
O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdG9rZW5zLnB1c2goeyB0eXBlOiBUT0suSUQsIHZh
bHVlOiB2YWwsIGxpbmU6IHRsLCBjb2w6IHRjIH0pO1xuICAgICAgfVxuICAgICAgY29udGludWU7
XG4gICAgfVxuICAgIC8vIG11bHRpLWNoYXIgb3BlcmF0b3JzXG4gICAgY29uc3QgdHcgPSBwZWVr
MigpO1xuICAgIGlmICh0dyA9PT0gJyoqJyB8fCB0dyA9PT0gJzo9JyB8fCB0dyA9PT0gJys9JyB8
fCB0dyA9PT0gJy09JyB8fCB0dyA9PT0gJyo9JyB8fFxuICAgICAgICB0dyA9PT0gJz09JyB8fCB0
dyA9PT0gJzw9JyB8fCB0dyA9PT0gJz49JyB8fCB0dyA9PT0gJzw8JyB8fCB0dyA9PT0gJz4+Jykg
e1xuICAgICAgdG9rZW5zLnB1c2goeyB0eXBlOiBUT0suT1AsIHZhbHVlOiB0dywgbGluZTogdGws
IGNvbDogdGMgfSk7XG4gICAgICBhZHYoKTsgYWR2KCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9
XG4gICAgLy8gLz0g4oCUIHRoaXMgaXMgbm90LWVxdWFsIGluIGF0cmFcbiAgICBpZiAoc291cmNl
W2ldID09PSAnLycgJiYgc291cmNlW2kgKyAxXSA9PT0gJz0nKSB7XG4gICAgICB0b2tlbnMucHVz
aCh7IHR5cGU6IFRPSy5PUCwgdmFsdWU6ICcvPScsIGxpbmU6IHRsLCBjb2w6IHRjIH0pO1xuICAg
ICAgYWR2KCk7IGFkdigpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIC8vIHNpbmdsZS1j
aGFyIG9wZXJhdG9yc1xuICAgIGlmICgnKy0qLzw+PSZ8Xn5AJy5pbmNsdWRlcyhzb3VyY2VbaV0p
KSB7XG4gICAgICB0b2tlbnMucHVzaCh7IHR5cGU6IFRPSy5PUCwgdmFsdWU6IHNvdXJjZVtpXSwg
bGluZTogdGwsIGNvbDogdGMgfSk7XG4gICAgICBhZHYoKTtcbiAgICAgIGNvbnRpbnVlO1xuICAg
IH1cbiAgICAvLyBwdW5jdHVhdGlvblxuICAgIGlmICgnKClbXTssOicuaW5jbHVkZXMoc291cmNl
W2ldKSkge1xuICAgICAgdG9rZW5zLnB1c2goeyB0eXBlOiBUT0suUFVOQywgdmFsdWU6IHNvdXJj
ZVtpXSwgbGluZTogdGwsIGNvbDogdGMgfSk7XG4gICAgICBhZHYoKTtcbiAgICAgIGNvbnRpbnVl
O1xuICAgIH1cbiAgICAvLyBza2lwIHVua25vd25cbiAgICBhZHYoKTtcbiAgfVxuICB0b2tlbnMu
cHVzaCh7IHR5cGU6IFRPSy5FT0YsIHZhbHVlOiAnJywgbGluZSwgY29sIH0pO1xuICByZXR1cm4g
dG9rZW5zO1xufVxuXG4vLyAtLSBwYXJzZS5qcyAtLVxuXG4vLyBQYXJzZXIg4oCUIHJlY3Vyc2l2
ZSBkZXNjZW50ICsgUHJhdHQgZXhwcmVzc2lvbnMg4oaSIEFTVFxuLy9cbi8vIEdyYW1tYXIgc2tl
dGNoOlxuLy8gICBwcm9ncmFtICAgID0geyBjb25zdERlY2wgfCB2YXJEZWNsIHwgZnVuY3Rpb24g
fCBzdWJyb3V0aW5lIHwgaW1wb3J0IHwgZXhwb3J0IGZ1bmN0aW9uIH1cbi8vICAgZnVuY3Rpb24g
ICA9ICdmdW5jdGlvbicgSUQgJygnIHBhcmFtcyAnKScgJzonIFRZUEUgW3ZhciBsb2NhbHNdICdi
ZWdpbicgc3RtdHMgJ2VuZCdcbi8vICAgc3Vicm91dGluZSA9ICdzdWJyb3V0aW5lJyBJRCAnKCcg
cGFyYW1zICcpJyBbdmFyIGxvY2Fsc10gJ2JlZ2luJyBzdG10cyAnZW5kJ1xuLy8gICBwYXJhbXMg
ICAgID0gbmFtZSB7JywnIG5hbWV9ICc6JyBUWVBFIHsnLCcgcGFyYW1zfSAgICDigJQgY29tbWEt
c2VwYXJhdGVkIG5hbWVzIHNoYXJlIGEgdHlwZVxuLy8gICBzdG10ICAgICAgID0gaWYgfCBmb3Ig
fCB3aGlsZSB8IGRvLXdoaWxlIHwgYnJlYWsgfCB0YWlsY2FsbCB8IGNhbGwgfCBhc3NpZ24gfCBh
cnJheVN0b3JlXG4vLyAgIGFzc2lnbiAgICAgPSBJRCAnOj0nIGV4cHIgIHwgIElEICcrPScgZXhw
ciAgfCAgSUQgJy89JyBleHByICAoZXRjLilcbi8vICAgaWYgICAgICAgICA9ICdpZicgJygnIGV4
cHIgJyknICd0aGVuJyBzdG10cyBbJ2Vsc2UnIHN0bXRzIHwgJ2Vsc2UnIGlmXSAnZW5kJyAnaWYn
XG4vLyAgIGZvciAgICAgICAgPSAnZm9yJyBJRCAnOj0nIGV4cHIgJywnIGV4cHIgWycsJyBzdGVw
XSBzdG10cyAnZW5kJyAnZm9yJ1xuLy8gICBleHByICAgICAgID0gUHJhdHQgZXhwcmVzc2lvbiAo
c2VlIGxicCBmb3IgcHJlY2VkZW5jZSB0b3dlcilcbi8vICAgYXRvbSAgICAgICA9IG51bWJlciB8
IElEIHwgSUQgJygnIGFyZ3MgJyknIHwgSUQgJ1snIGluZGljZXMgJ10nIHwgJygnIGV4cHIgJykn
XG4vLyAgICAgICAgICAgICAgfCBUWVBFICcoJyBhcmdzICcpJyAg4oCUIHR5cGUgY29udmVyc2lv
biAvIHZlY3RvciBjb25zdHJ1Y3RvclxuLy8gICAgICAgICAgICAgIHwgJ2lmJyAnKCcgZXhwciAn
KScgJ3RoZW4nIGV4cHIgJ2Vsc2UnIGV4cHIgIOKAlCB0ZXJuYXJ5XG5cblxuXG5mdW5jdGlvbiBw
YXJzZSh0b2tlbnMpIHtcbiAgbGV0IHBvcyA9IDA7XG4gIGZ1bmN0aW9uIGN1cigpIHsgcmV0dXJu
IHRva2Vuc1twb3NdOyB9XG4gIGZ1bmN0aW9uIGF0KHR5cGUsIHZhbHVlKSB7IGNvbnN0IHQgPSBj
dXIoKTsgcmV0dXJuIHQudHlwZSA9PT0gdHlwZSAmJiAodmFsdWUgPT09IHVuZGVmaW5lZCB8fCB0
LnZhbHVlID09PSB2YWx1ZSk7IH1cbiAgZnVuY3Rpb24gZWF0KHR5cGUsIHZhbHVlKSB7XG4gICAg
Y29uc3QgdCA9IGN1cigpO1xuICAgIGlmICh0LnR5cGUgIT09IHR5cGUgfHwgKHZhbHVlICE9PSB1
bmRlZmluZWQgJiYgdC52YWx1ZSAhPT0gdmFsdWUpKVxuICAgICAgdGhyb3cgbmV3IFN5bnRheEVy
cm9yKGBFeHBlY3RlZCAke3ZhbHVlIHx8IHR5cGV9IGJ1dCBnb3QgXCIke3QudmFsdWV9XCIgYXQg
JHt0LmxpbmV9OiR7dC5jb2x9YCk7XG4gICAgcG9zKys7XG4gICAgcmV0dXJuIHQ7XG4gIH1cbiAg
ZnVuY3Rpb24gbWF5YmUodHlwZSwgdmFsdWUpIHsgaWYgKGF0KHR5cGUsIHZhbHVlKSkgeyBwb3Mr
KzsgcmV0dXJuIHRydWU7IH0gcmV0dXJuIGZhbHNlOyB9XG5cbiAgZnVuY3Rpb24gcGFyc2VQcm9n
cmFtKCkge1xuICAgIGNvbnN0IGJvZHkgPSBbXTtcbiAgICB3aGlsZSAoIWF0KFRPSy5FT0YpKSB7
XG4gICAgICBpZiAoYXQoVE9LLktXLCAnY29uc3QnKSAmJiAhaXNMb2NhbENvbnRleHQoKSkgYm9k
eS5wdXNoKHBhcnNlR2xvYmFsQ29uc3QoKSk7XG4gICAgICBlbHNlIGlmIChhdChUT0suS1csICd2
YXInKSAmJiAhaXNMb2NhbENvbnRleHQoKSkgYm9keS5wdXNoKHBhcnNlR2xvYmFsVmFyKCkpO1xu
ICAgICAgZWxzZSBpZiAoYXQoVE9LLktXLCAnZnVuY3Rpb24nKSkgYm9keS5wdXNoKHBhcnNlRnVu
Y3Rpb24oKSk7XG4gICAgICBlbHNlIGlmIChhdChUT0suS1csICdzdWJyb3V0aW5lJykpIGJvZHku
cHVzaChwYXJzZVN1YnJvdXRpbmUoKSk7XG4gICAgICBlbHNlIGlmIChhdChUT0suS1csICdpbXBv
cnQnKSkgYm9keS5wdXNoKHBhcnNlSW1wb3J0KCkpO1xuICAgICAgZWxzZSBpZiAoYXQoVE9LLktX
LCAnZXhwb3J0JykpIHsgcG9zKys7IGJvZHkucHVzaChwYXJzZUZ1bmN0aW9uKHRydWUpKTsgfVxu
ICAgICAgZWxzZSB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFVuZXhwZWN0ZWQgXCIke2N1cigpLnZh
bHVlfVwiIGF0ICR7Y3VyKCkubGluZX06JHtjdXIoKS5jb2x9YCk7XG4gICAgfVxuICAgIHJldHVy
biB7IHR5cGU6ICdQcm9ncmFtJywgYm9keSB9O1xuICB9XG5cbiAgZnVuY3Rpb24gaXNMb2NhbENv
bnRleHQoKSB7IHJldHVybiBmYWxzZTsgfSAvLyBnbG9iYWxzIG9ubHkgYXQgdG9wIGxldmVsXG5c
biAgLy8gUGFyc2UgZnVuY3Rpb24gdHlwZSBzaWduYXR1cmU6IGZ1bmN0aW9uKHg6IGY2NCwgeTog
ZjY0KTogZjY0XG4gIGZ1bmN0aW9uIHBhcnNlRnVuY1R5cGVTaWcoKSB7XG4gICAgZWF0KFRPSy5L
VywgJ2Z1bmN0aW9uJyk7XG4gICAgZWF0KFRPSy5QVU5DLCAnKCcpO1xuICAgIGNvbnN0IHBhcmFt
cyA9IGF0KFRPSy5QVU5DLCAnKScpID8gW10gOiBwYXJzZVBhcmFtRW50cmllcygpO1xuICAgIGVh
dChUT0suUFVOQywgJyknKTtcbiAgICBsZXQgcmV0VHlwZSA9IG51bGw7XG4gICAgaWYgKG1heWJl
KFRPSy5QVU5DLCAnOicpKSByZXRUeXBlID0gZWF0KFRPSy5LVykudmFsdWU7XG4gICAgcmV0dXJu
IHsgcGFyYW1zLCByZXRUeXBlIH07XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUdsb2JhbENvbnN0
KCkge1xuICAgIGVhdChUT0suS1csICdjb25zdCcpO1xuICAgIGNvbnN0IG5hbWUgPSBlYXQoVE9L
LklEKS52YWx1ZTtcbiAgICBlYXQoVE9LLlBVTkMsICc6Jyk7XG4gICAgY29uc3QgdnR5cGUgPSBl
YXQoVE9LLktXKS52YWx1ZTtcbiAgICBlYXQoVE9LLk9QLCAnPScpO1xuICAgIGNvbnN0IGluaXQg
PSBwYXJzZUV4cHIoMCk7XG4gICAgcmV0dXJuIHsgdHlwZTogJ0NvbnN0RGVjbCcsIG5hbWUsIHZ0
eXBlLCBpbml0IH07XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUdsb2JhbFZhcigpIHtcbiAgICBl
YXQoVE9LLktXLCAndmFyJyk7XG4gICAgY29uc3QgbmFtZSA9IGVhdChUT0suSUQpLnZhbHVlO1xu
ICAgIGVhdChUT0suUFVOQywgJzonKTtcbiAgICBpZiAoYXQoVE9LLktXLCAnZnVuY3Rpb24nKSkg
e1xuICAgICAgY29uc3QgZnVuY1NpZyA9IHBhcnNlRnVuY1R5cGVTaWcoKTtcbiAgICAgIGxldCBp
bml0ID0gbnVsbDtcbiAgICAgIGlmIChtYXliZShUT0suT1AsICc9JykpIGluaXQgPSBwYXJzZUV4
cHIoMCk7XG4gICAgICByZXR1cm4geyB0eXBlOiAnVmFyRGVjbCcsIG5hbWUsIHZ0eXBlOiAnaTMy
JywgZnVuY1NpZywgaW5pdCB9O1xuICAgIH1cbiAgICBjb25zdCB2dHlwZSA9IGVhdChUT0suS1cp
LnZhbHVlO1xuICAgIGxldCBpbml0ID0gbnVsbDtcbiAgICBpZiAobWF5YmUoVE9LLk9QLCAnPScp
KSBpbml0ID0gcGFyc2VFeHByKDApO1xuICAgIHJldHVybiB7IHR5cGU6ICdWYXJEZWNsJywgbmFt
ZSwgdnR5cGUsIGluaXQgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlSW1wb3J0KCkge1xuICAg
IGVhdChUT0suS1csICdpbXBvcnQnKTtcbiAgICAvLyBpbXBvcnQgZnVuY3Rpb24gbmFtZShwYXJh
bXMpOiByZXRUeXBlIGZyb20gJ21vZHVsZSdcbiAgICAvLyBpbXBvcnQgbmFtZSA9ICR7aW50ZXJw
fVxuICAgIC8vIGltcG9ydCBuYW1lKHBhcmFtcyk6IHJldFR5cGUgPSAke2ludGVycH1cbiAgICBp
ZiAoYXQoVE9LLktXLCAnZnVuY3Rpb24nKSkge1xuICAgICAgcG9zKys7XG4gICAgfVxuICAgIGNv
bnN0IG5hbWUgPSBlYXQoVE9LLklEKS52YWx1ZTtcbiAgICBsZXQgcGFyYW1zID0gW10sIHJldFR5
cGUgPSBudWxsLCBtb2R1bGVOYW1lID0gJ2hvc3QnLCBpbnRlcnBJZHggPSBudWxsO1xuICAgIGlm
IChhdChUT0suUFVOQywgJygnKSkge1xuICAgICAgcGFyYW1zID0gcGFyc2VQYXJhbUxpc3QoKTtc
biAgICB9XG4gICAgaWYgKG1heWJlKFRPSy5QVU5DLCAnOicpKSB7XG4gICAgICByZXRUeXBlID0g
ZWF0KFRPSy5LVykudmFsdWU7XG4gICAgfVxuICAgIGlmIChtYXliZShUT0suT1AsICc9JykpIHtc
biAgICAgIC8vIGludGVycG9sYXRpb24gbWFya2VyXG4gICAgICBjb25zdCB0ID0gZWF0KFRPSy5J
RCk7XG4gICAgICBpbnRlcnBJZHggPSB0LnZhbHVlO1xuICAgIH0gZWxzZSBpZiAobWF5YmUoVE9L
LktXLCAnZnJvbScpKSB7XG4gICAgICAvLyAnbW9kdWxlJyDigJQgd2UganVzdCByZWFkIHRoZSBp
ZGVudGlmaWVyIGFzIGEgc3RyaW5nLWxpa2UgdGhpbmdcbiAgICAgIG1vZHVsZU5hbWUgPSBlYXQo
VE9LLklEKS52YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHsgdHlwZTogJ0ltcG9ydERlY2wnLCBu
YW1lLCBwYXJhbXMsIHJldFR5cGUsIG1vZHVsZU5hbWUsIGludGVycElkeCB9O1xuICB9XG5cbiAg
ZnVuY3Rpb24gcGFyc2VGdW5jdGlvbihleHBvcnRlZCA9IGZhbHNlKSB7XG4gICAgZWF0KFRPSy5L
VywgJ2Z1bmN0aW9uJyk7XG4gICAgY29uc3QgbmFtZSA9IGVhdChUT0suSUQpLnZhbHVlO1xuICAg
IGVhdChUT0suUFVOQywgJygnKTtcbiAgICBjb25zdCBwYXJhbXMgPSBhdChUT0suUFVOQywgJykn
KSA/IFtdIDogcGFyc2VQYXJhbUVudHJpZXMoKTtcbiAgICBlYXQoVE9LLlBVTkMsICcpJyk7XG4g
ICAgZWF0KFRPSy5QVU5DLCAnOicpO1xuICAgIGNvbnN0IHJldFR5cGUgPSBlYXQoVE9LLktXKS52
YWx1ZTtcbiAgICBjb25zdCBsb2NhbHMgPSBbXTtcbiAgICBpZiAoYXQoVE9LLktXLCAndmFyJykp
IHtcbiAgICAgIHBvcysrO1xuICAgICAgd2hpbGUgKCFhdChUT0suS1csICdiZWdpbicpKSB7XG4g
ICAgICAgIGNvbnN0IGxuYW1lcyA9IFtlYXQoVE9LLklEKS52YWx1ZV07XG4gICAgICAgIHdoaWxl
IChtYXliZShUT0suUFVOQywgJywnKSkgbG5hbWVzLnB1c2goZWF0KFRPSy5JRCkudmFsdWUpO1xu
ICAgICAgICBlYXQoVE9LLlBVTkMsICc6Jyk7XG4gICAgICAgIGlmIChhdChUT0suS1csICdmdW5j
dGlvbicpKSB7XG4gICAgICAgICAgY29uc3QgZnVuY1NpZyA9IHBhcnNlRnVuY1R5cGVTaWcoKTtc
biAgICAgICAgICBmb3IgKGNvbnN0IGxuIG9mIGxuYW1lcykgbG9jYWxzLnB1c2goeyB0eXBlOiAn
TG9jYWwnLCBuYW1lOiBsbiwgdnR5cGU6ICdpMzInLCBmdW5jU2lnIH0pO1xuICAgICAgICB9IGVs
c2Uge1xuICAgICAgICAgIGNvbnN0IGx0ID0gZWF0KFRPSy5LVykudmFsdWU7XG4gICAgICAgICAg
Zm9yIChjb25zdCBsbiBvZiBsbmFtZXMpIGxvY2Fscy5wdXNoKHsgdHlwZTogJ0xvY2FsJywgbmFt
ZTogbG4sIHZ0eXBlOiBsdCB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBlYXQo
VE9LLktXLCAnYmVnaW4nKTtcbiAgICBjb25zdCBib2R5ID0gcGFyc2VTdGF0ZW1lbnRzKCdlbmQn
KTtcbiAgICBlYXQoVE9LLktXLCAnZW5kJyk7XG4gICAgcmV0dXJuIHsgdHlwZTogJ0Z1bmN0aW9u
JywgbmFtZSwgcGFyYW1zLCByZXRUeXBlLCBsb2NhbHMsIGJvZHksIGV4cG9ydGVkIH07XG4gIH1c
blxuICBmdW5jdGlvbiBwYXJzZVN1YnJvdXRpbmUoKSB7XG4gICAgZWF0KFRPSy5LVywgJ3N1YnJv
dXRpbmUnKTtcbiAgICBjb25zdCBuYW1lID0gZWF0KFRPSy5JRCkudmFsdWU7XG4gICAgZWF0KFRP
Sy5QVU5DLCAnKCcpO1xuICAgIGNvbnN0IHBhcmFtcyA9IGF0KFRPSy5QVU5DLCAnKScpID8gW10g
OiBwYXJzZVBhcmFtRW50cmllcygpO1xuICAgIGVhdChUT0suUFVOQywgJyknKTtcbiAgICBjb25z
dCBsb2NhbHMgPSBbXTtcbiAgICBpZiAoYXQoVE9LLktXLCAndmFyJykpIHtcbiAgICAgIHBvcysr
O1xuICAgICAgd2hpbGUgKCFhdChUT0suS1csICdiZWdpbicpKSB7XG4gICAgICAgIGNvbnN0IGxu
YW1lcyA9IFtlYXQoVE9LLklEKS52YWx1ZV07XG4gICAgICAgIHdoaWxlIChtYXliZShUT0suUFVO
QywgJywnKSkgbG5hbWVzLnB1c2goZWF0KFRPSy5JRCkudmFsdWUpO1xuICAgICAgICBlYXQoVE9L
LlBVTkMsICc6Jyk7XG4gICAgICAgIGlmIChhdChUT0suS1csICdmdW5jdGlvbicpKSB7XG4gICAg
ICAgICAgY29uc3QgZnVuY1NpZyA9IHBhcnNlRnVuY1R5cGVTaWcoKTtcbiAgICAgICAgICBmb3Ig
KGNvbnN0IGxuIG9mIGxuYW1lcykgbG9jYWxzLnB1c2goeyB0eXBlOiAnTG9jYWwnLCBuYW1lOiBs
biwgdnR5cGU6ICdpMzInLCBmdW5jU2lnIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAg
IGNvbnN0IGx0ID0gZWF0KFRPSy5LVykudmFsdWU7XG4gICAgICAgICAgZm9yIChjb25zdCBsbiBv
ZiBsbmFtZXMpIGxvY2Fscy5wdXNoKHsgdHlwZTogJ0xvY2FsJywgbmFtZTogbG4sIHZ0eXBlOiBs
dCB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBlYXQoVE9LLktXLCAnYmVnaW4n
KTtcbiAgICBjb25zdCBib2R5ID0gcGFyc2VTdGF0ZW1lbnRzKCdlbmQnKTtcbiAgICBlYXQoVE9L
LktXLCAnZW5kJyk7XG4gICAgcmV0dXJuIHsgdHlwZTogJ1N1YnJvdXRpbmUnLCBuYW1lLCBwYXJh
bXMsIGxvY2FscywgYm9keSB9O1xuICB9XG5cbiAgLy8gUGFyYW0gZ3JvdXBpbmc6IFwieCwgeTog
ZjY0XCIgc2hhcmVzIGEgdHlwZSBhY3Jvc3MgY29tbWEtc2VwYXJhdGVkIG5hbWVzLlxuICAvLyBU
aGUgbG9va2FoZWFkIChwb3MrMiBpcyAnLCcgb3IgJzonKSBkaXN0aW5ndWlzaGVzIGdyb3VwZWQg
bmFtZXMgZnJvbSB0aGUgbmV4dCBwYXJhbSBncm91cC5cbiAgZnVuY3Rpb24gcGFyc2VQYXJhbUVu
dHJpZXMoKSB7XG4gICAgY29uc3QgcGFyYW1zID0gW107XG4gICAgd2hpbGUgKGN1cigpLnR5cGUg
PT09IFRPSy5JRCkge1xuICAgICAgY29uc3QgbmFtZXMgPSBbZWF0KFRPSy5JRCkudmFsdWVdO1xu
ICAgICAgd2hpbGUgKGF0KFRPSy5QVU5DLCAnLCcpICYmIHRva2Vuc1twb3MgKyAxXSAmJiB0b2tl
bnNbcG9zICsgMV0udHlwZSA9PT0gVE9LLklEICYmXG4gICAgICAgICAgICAgdG9rZW5zW3BvcyAr
IDJdICYmICh0b2tlbnNbcG9zICsgMl0udmFsdWUgPT09ICcsJyB8fCB0b2tlbnNbcG9zICsgMl0u
dmFsdWUgPT09ICc6JykpIHtcbiAgICAgICAgcG9zKys7IC8vIHNraXAgLFxuICAgICAgICBuYW1l
cy5wdXNoKGVhdChUT0suSUQpLnZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGVhdChUT0suUFVOQywg
JzonKTtcbiAgICAgIC8vIGZ1bmN0aW9uIHR5cGU6IGNhbGxiYWNrOiBmdW5jdGlvbih4OiBmNjQp
OiBmNjRcbiAgICAgIGlmIChhdChUT0suS1csICdmdW5jdGlvbicpKSB7XG4gICAgICAgIGNvbnN0
IGZ1bmNTaWcgPSBwYXJzZUZ1bmNUeXBlU2lnKCk7XG4gICAgICAgIGZvciAoY29uc3QgbiBvZiBu
YW1lcykgcGFyYW1zLnB1c2goeyB0eXBlOiAnUGFyYW0nLCBuYW1lOiBuLCB2dHlwZTogJ2kzMics
IGlzQXJyYXk6IGZhbHNlLCBhcnJheURpbXM6IG51bGwsIGZ1bmNTaWcgfSk7XG4gICAgICAgIG1h
eWJlKFRPSy5QVU5DLCAnLCcpOyAvLyBjb25zdW1lIGNvbW1hIGJldHdlZW4gcGFyYW0gZ3JvdXBz
XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgbGV0IGlzQXJyYXkgPSBmYWxzZSwg
YXJyYXlEaW1zID0gbnVsbDtcbiAgICAgIGlmIChhdChUT0suS1csICdhcnJheScpKSB7XG4gICAg
ICAgIHBvcysrO1xuICAgICAgICBpc0FycmF5ID0gdHJ1ZTtcbiAgICAgICAgaWYgKGF0KFRPSy5Q
VU5DLCAnKCcpKSB7XG4gICAgICAgICAgcG9zKys7XG4gICAgICAgICAgYXJyYXlEaW1zID0gW107
XG4gICAgICAgICAgYXJyYXlEaW1zLnB1c2gocGFyc2VFeHByKDApKTtcbiAgICAgICAgICB3aGls
ZSAobWF5YmUoVE9LLlBVTkMsICcsJykpIGFycmF5RGltcy5wdXNoKHBhcnNlRXhwcigwKSk7XG4g
ICAgICAgICAgZWF0KFRPSy5QVU5DLCAnKScpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBj
b25zdCB2dHlwZSA9IGVhdChUT0suS1cpLnZhbHVlO1xuICAgICAgZm9yIChjb25zdCBuIG9mIG5h
bWVzKSBwYXJhbXMucHVzaCh7IHR5cGU6ICdQYXJhbScsIG5hbWU6IG4sIHZ0eXBlLCBpc0FycmF5
LCBhcnJheURpbXMgfSk7XG4gICAgICBtYXliZShUT0suUFVOQywgJywnKTsgLy8gY29uc3VtZSBj
b21tYSBiZXR3ZWVuIHBhcmFtIGdyb3Vwc1xuICAgIH1cbiAgICByZXR1cm4gcGFyYW1zO1xuICB9
XG5cbiAgZnVuY3Rpb24gcGFyc2VQYXJhbUxpc3QoKSB7XG4gICAgLy8gc2ltcGxpZmllZCBwYXJh
bSBsaXN0IGZvciBpbXBvcnRzOiBuYW1lOiB0eXBlLCAuLi5cbiAgICBlYXQoVE9LLlBVTkMsICco
Jyk7XG4gICAgY29uc3QgcGFyYW1zID0gW107XG4gICAgd2hpbGUgKGN1cigpLnR5cGUgPT09IFRP
Sy5JRCkge1xuICAgICAgY29uc3QgbmFtZXMgPSBbZWF0KFRPSy5JRCkudmFsdWVdO1xuICAgICAg
d2hpbGUgKGF0KFRPSy5QVU5DLCAnLCcpICYmIHRva2Vuc1twb3MgKyAxXSAmJiB0b2tlbnNbcG9z
ICsgMV0udHlwZSA9PT0gVE9LLklEICYmXG4gICAgICAgICAgICAgdG9rZW5zW3BvcyArIDJdICYm
ICh0b2tlbnNbcG9zICsgMl0udmFsdWUgPT09ICcsJyB8fCB0b2tlbnNbcG9zICsgMl0udmFsdWUg
PT09ICc6JykpIHtcbiAgICAgICAgcG9zKys7XG4gICAgICAgIG5hbWVzLnB1c2goZWF0KFRPSy5J
RCkudmFsdWUpO1xuICAgICAgfVxuICAgICAgZWF0KFRPSy5QVU5DLCAnOicpO1xuICAgICAgY29u
c3QgdnR5cGUgPSBlYXQoVE9LLktXKS52YWx1ZTtcbiAgICAgIGZvciAoY29uc3QgbiBvZiBuYW1l
cykgcGFyYW1zLnB1c2goeyB0eXBlOiAnUGFyYW0nLCBuYW1lOiBuLCB2dHlwZSwgaXNBcnJheTog
ZmFsc2UsIGFycmF5RGltczogbnVsbCB9KTtcbiAgICAgIG1heWJlKFRPSy5QVU5DLCAnLCcpOyAv
LyBjb25zdW1lIGNvbW1hIGJldHdlZW4gcGFyYW0gZ3JvdXBzXG4gICAgfVxuICAgIGVhdChUT0su
UFVOQywgJyknKTtcbiAgICByZXR1cm4gcGFyYW1zO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VT
dGF0ZW1lbnRzKGVuZEt3KSB7XG4gICAgY29uc3Qgc3RtdHMgPSBbXTtcbiAgICB3aGlsZSAoIWF0
KFRPSy5LVywgZW5kS3cpICYmICFhdChUT0suRU9GKSkge1xuICAgICAgLy8gYWxzbyBzdG9wIGF0
ICdlbHNlJyBmb3IgaWYgYmxvY2tzXG4gICAgICBpZiAoZW5kS3cgPT09ICdlbmQnICYmIGF0KFRP
Sy5LVywgJ2Vsc2UnKSkgYnJlYWs7XG4gICAgICBzdG10cy5wdXNoKHBhcnNlU3RhdGVtZW50KCkp
O1xuICAgIH1cbiAgICByZXR1cm4gc3RtdHM7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVN0YXRl
bWVudCgpIHtcbiAgICBpZiAoYXQoVE9LLktXLCAnaWYnKSkgcmV0dXJuIHBhcnNlSWYoKTtcbiAg
ICBpZiAoYXQoVE9LLktXLCAnZm9yJykpIHJldHVybiBwYXJzZUZvcigpO1xuICAgIGlmIChhdChU
T0suS1csICd3aGlsZScpKSByZXR1cm4gcGFyc2VXaGlsZSgpO1xuICAgIGlmIChhdChUT0suS1cs
ICdkbycpKSByZXR1cm4gcGFyc2VEb1doaWxlKCk7XG4gICAgaWYgKGF0KFRPSy5LVywgJ2JyZWFr
JykpIHsgcG9zKys7IHJldHVybiB7IHR5cGU6ICdCcmVhaycgfTsgfVxuICAgIGlmIChhdChUT0su
S1csICd0YWlsY2FsbCcpKSB7IHBvcysrOyBjb25zdCBuYW1lID0gZWF0KFRPSy5JRCkudmFsdWU7
IGVhdChUT0suUFVOQywgJygnKTsgY29uc3QgYXJncyA9IHBhcnNlQXJncygpOyBlYXQoVE9LLlBV
TkMsICcpJyk7IHJldHVybiB7IHR5cGU6ICdUYWlsQ2FsbCcsIG5hbWUsIGFyZ3MgfTsgfVxuICAg
IGlmIChhdChUT0suS1csICdjYWxsJykpIHsgcG9zKys7IGNvbnN0IG5hbWUgPSBhdChUT0suS1cs
ICdyZXR1cm4nKSA/IChwb3MrKywgJ3JldHVybicpIDogZWF0KFRPSy5JRCkudmFsdWU7IGVhdChU
T0suUFVOQywgJygnKTsgY29uc3QgYXJncyA9IHBhcnNlQXJncygpOyBlYXQoVE9LLlBVTkMsICcp
Jyk7IHJldHVybiB7IHR5cGU6ICdDYWxsJywgbmFtZSwgYXJncyB9OyB9XG5cbiAgICAvLyBhc3Np
Z25tZW50IG9yIGV4cHJlc3Npb24gc3RhdGVtZW50XG4gICAgLy8gbG9vayBhaGVhZDogaWQgOj0g
LyBpZFsuLi5dIDo9IC8gaWQgKz0gZXRjLlxuICAgIGlmIChjdXIoKS50eXBlID09PSBUT0suSUQp
IHtcbiAgICAgIGNvbnN0IG5hbWUgPSBjdXIoKS52YWx1ZTtcbiAgICAgIC8vIGNoZWNrIGZvciBh
cnJheSBzdG9yZTogaWRbXG4gICAgICBpZiAodG9rZW5zW3BvcyArIDFdICYmIHRva2Vuc1twb3Mg
KyAxXS52YWx1ZSA9PT0gJ1snKSB7XG4gICAgICAgIHBvcysrO1xuICAgICAgICBlYXQoVE9LLlBV
TkMsICdbJyk7XG4gICAgICAgIGNvbnN0IGluZGljZXMgPSBbcGFyc2VFeHByKDApXTtcbiAgICAg
ICAgd2hpbGUgKG1heWJlKFRPSy5QVU5DLCAnLCcpKSBpbmRpY2VzLnB1c2gocGFyc2VFeHByKDAp
KTtcbiAgICAgICAgZWF0KFRPSy5QVU5DLCAnXScpO1xuICAgICAgICBpZiAoYXQoVE9LLk9QLCAn
Oj0nKSkge1xuICAgICAgICAgIHBvcysrO1xuICAgICAgICAgIGNvbnN0IHZhbHVlID0gcGFyc2VF
eHByKDApO1xuICAgICAgICAgIHJldHVybiB7IHR5cGU6ICdBcnJheVN0b3JlJywgbmFtZSwgaW5k
aWNlcywgdmFsdWUgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjb21wb3VuZCBhc3NpZ25tZW50
IG9uIGFycmF5XG4gICAgICAgIGNvbnN0IGNvcCA9IGN1cigpLnZhbHVlO1xuICAgICAgICBpZiAo
Y29wID09PSAnKz0nIHx8IGNvcCA9PT0gJy09JyB8fCBjb3AgPT09ICcqPScgfHwgY29wID09PSAn
Lz0nKSB7XG4gICAgICAgICAgLy8gTm90ZTogLz0gaXMgYW1iaWd1b3VzIOKAlCBhcyBhIHN0YXRl
bWVudCBzdGFydCBhZnRlciBhcnJheSBhY2Nlc3MsIGl0J3MgY29tcG91bmQgYXNzaWduXG4gICAg
ICAgICAgcG9zKys7XG4gICAgICAgICAgY29uc3QgcmhzID0gcGFyc2VFeHByKDApO1xuICAgICAg
ICAgIGNvbnN0IG9wID0gY29wWzBdOyAvLyArLCAtLCAqLCAvXG4gICAgICAgICAgcmV0dXJuIHsg
dHlwZTogJ0FycmF5U3RvcmUnLCBuYW1lLCBpbmRpY2VzLCB2YWx1ZToge1xuICAgICAgICAgICAg
dHlwZTogJ0Jpbk9wJywgb3AsIGxlZnQ6IHsgdHlwZTogJ0FycmF5QWNjZXNzJywgbmFtZSwgaW5k
aWNlcyB9LCByaWdodDogcmhzXG4gICAgICAgICAgfX07XG4gICAgICAgIH1cbiAgICAgICAgdGhy
b3cgbmV3IFN5bnRheEVycm9yKGBFeHBlY3RlZCA6PSBvciBjb21wb3VuZCBhc3NpZ25tZW50IGFm
dGVyIGFycmF5IGFjY2VzcyBhdCAke2N1cigpLmxpbmV9OiR7Y3VyKCkuY29sfWApO1xuICAgICAg
fVxuICAgICAgaWYgKHRva2Vuc1twb3MgKyAxXSAmJiB0b2tlbnNbcG9zICsgMV0udmFsdWUgPT09
ICc6PScpIHtcbiAgICAgICAgcG9zKys7IHBvcysrO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHBh
cnNlRXhwcigwKTtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogJ0Fzc2lnbicsIG5hbWUsIHZhbHVl
IH07XG4gICAgICB9XG4gICAgICAvLyBjb21wb3VuZCBhc3NpZ25tZW50OiArPSwgLT0sICo9XG4g
ICAgICBpZiAodG9rZW5zW3BvcyArIDFdICYmICh0b2tlbnNbcG9zICsgMV0udmFsdWUgPT09ICcr
PScgfHwgdG9rZW5zW3BvcyArIDFdLnZhbHVlID09PSAnLT0nIHx8IHRva2Vuc1twb3MgKyAxXS52
YWx1ZSA9PT0gJyo9JykpIHtcbiAgICAgICAgY29uc3QgY29wID0gdG9rZW5zW3BvcyArIDFdLnZh
bHVlO1xuICAgICAgICBjb25zdCBvcCA9IGNvcFswXTtcbiAgICAgICAgcG9zKys7IHBvcysrO1xu
ICAgICAgICBjb25zdCByaHMgPSBwYXJzZUV4cHIoMCk7XG4gICAgICAgIHJldHVybiB7IHR5cGU6
ICdBc3NpZ24nLCBuYW1lLCB2YWx1ZTogeyB0eXBlOiAnQmluT3AnLCBvcCwgbGVmdDogeyB0eXBl
OiAnSWRlbnQnLCBuYW1lIH0sIHJpZ2h0OiByaHMgfSB9O1xuICAgICAgfVxuICAgICAgLy8gLz0g
Y29tcG91bmQgYXNzaWdubWVudCAob25seSB3aGVuIG5vdCBpbiBleHByZXNzaW9uIGNvbnRleHQg
4oCUIHN0YXRlbWVudCBsZXZlbClcbiAgICAgIC8vIERpc2FtYmlndWF0aW9uOiBhdCBzdGF0ZW1l
bnQgbGV2ZWwsIGlkIC89IGV4cHIgaXMgY29tcG91bmQgZGl2aWRlLWFzc2lnblxuICAgICAgLy8g
QnV0IC89IGlzIGFsc28gbm90LWVxdWFsIG9wZXJhdG9yLiBBdCBzdGF0ZW1lbnQgbGV2ZWw6IGlk
IC89IGV4cHIg4oaSIGRpdmlkZS1hc3NpZ24uXG4gICAgICBpZiAodG9rZW5zW3BvcyArIDFdICYm
IHRva2Vuc1twb3MgKyAxXS52YWx1ZSA9PT0gJy89Jykge1xuICAgICAgICAvLyBsb29rIGZ1cnRo
ZXI6IGlmIHRoaXMgaXMgYSBzdGFuZGFsb25lIHN0YXRlbWVudCAoaWQgLz0gZXhwciksIHRyZWF0
IGFzIGNvbXBvdW5kIGFzc2lnblxuICAgICAgICBjb25zdCBvcCA9ICcvJztcbiAgICAgICAgcG9z
Kys7IHBvcysrO1xuICAgICAgICBjb25zdCByaHMgPSBwYXJzZUV4cHIoMCk7XG4gICAgICAgIHJl
dHVybiB7IHR5cGU6ICdBc3NpZ24nLCBuYW1lLCB2YWx1ZTogeyB0eXBlOiAnQmluT3AnLCBvcCwg
bGVmdDogeyB0eXBlOiAnSWRlbnQnLCBuYW1lIH0sIHJpZ2h0OiByaHMgfSB9O1xuICAgICAgfVxu
ICAgIH1cblxuICAgIC8vIGV4cHJlc3Npb24gc3RhdGVtZW50IChlLmcuLCBiYXJlIGZ1bmN0aW9u
IGNhbGwpXG4gICAgY29uc3QgZXhwciA9IHBhcnNlRXhwcigwKTtcbiAgICBpZiAoZXhwci50eXBl
ID09PSAnRnVuY0NhbGwnKSByZXR1cm4geyB0eXBlOiAnQ2FsbCcsIG5hbWU6IGV4cHIubmFtZSwg
YXJnczogZXhwci5hcmdzIH07XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVk
IGV4cHJlc3Npb24gc3RhdGVtZW50IGF0ICR7Y3VyKCkubGluZX06JHtjdXIoKS5jb2x9YCk7XG4g
IH1cblxuICAvLyBUaGUgaXNFbHNlSWYgZmxhZyBjb250cm9scyAnZW5kIGlmJyBjb25zdW1wdGlv
bjogaW5uZXIgaWYgaW4gYW4gZWxzZS1pZiBjaGFpblxuICAvLyBsZXRzIHRoZSBvdXRlcm1vc3Qg
aWYgY29uc3VtZSB0aGUgc2luZ2xlICdlbmQgaWYnLiBXaXRob3V0IHRoaXMsIGVhY2ggbGV2ZWxc
biAgLy8gd291bGQgZWF0IG9uZSAnZW5kJyBhbmQgdGhlIG5lc3Rpbmcgd291bGQgYnJlYWsuXG4g
IGZ1bmN0aW9uIHBhcnNlSWYoaXNFbHNlSWYpIHtcbiAgICBlYXQoVE9LLktXLCAnaWYnKTtcbiAg
ICBlYXQoVE9LLlBVTkMsICcoJyk7XG4gICAgY29uc3QgY29uZCA9IHBhcnNlRXhwcigwKTtcbiAg
ICBlYXQoVE9LLlBVTkMsICcpJyk7XG4gICAgZWF0KFRPSy5LVywgJ3RoZW4nKTtcbiAgICBjb25z
dCBib2R5ID0gW107XG4gICAgd2hpbGUgKCFhdChUT0suS1csICdlbHNlJykgJiYgIWF0KFRPSy5L
VywgJ2VuZCcpICYmICFhdChUT0suRU9GKSkge1xuICAgICAgYm9keS5wdXNoKHBhcnNlU3RhdGVt
ZW50KCkpO1xuICAgIH1cbiAgICBsZXQgZWxzZUJvZHkgPSBudWxsO1xuICAgIGlmIChtYXliZShU
T0suS1csICdlbHNlJykpIHtcbiAgICAgIGlmIChhdChUT0suS1csICdpZicpKSB7XG4gICAgICAg
IC8vIGVsc2UgaWYgY2hhaW46IGlubmVyIHBhcnNlSWYgaGFuZGxlcyBldmVyeXRoaW5nIGluY2x1
ZGluZyBlbmQgaWZcbiAgICAgICAgZWxzZUJvZHkgPSBbcGFyc2VJZih0cnVlKV07XG4gICAgICB9
IGVsc2Uge1xuICAgICAgICBlbHNlQm9keSA9IFtdO1xuICAgICAgICB3aGlsZSAoIWF0KFRPSy5L
VywgJ2VuZCcpICYmICFhdChUT0suRU9GKSkge1xuICAgICAgICAgIGVsc2VCb2R5LnB1c2gocGFy
c2VTdGF0ZW1lbnQoKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gT25seSBj
b25zdW1lICdlbmQgaWYnIGF0IHRoZSBvdXRlcm1vc3QgaWYgKG5vdCBpbiBlbHNlLWlmIGNoYWlu
KVxuICAgIGlmICghaXNFbHNlSWYgJiYgYXQoVE9LLktXLCAnZW5kJykpIHtcbiAgICAgIHBvcysr
O1xuICAgICAgbWF5YmUoVE9LLktXLCAnaWYnKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgdHlwZTog
J0lmJywgY29uZCwgYm9keSwgZWxzZUJvZHkgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlRm9y
KCkge1xuICAgIGVhdChUT0suS1csICdmb3InKTtcbiAgICBjb25zdCB2YXJOYW1lID0gZWF0KFRP
Sy5JRCkudmFsdWU7XG4gICAgZWF0KFRPSy5PUCwgJzo9Jyk7XG4gICAgY29uc3Qgc3RhcnQgPSBw
YXJzZUV4cHIoMCk7XG4gICAgZWF0KFRPSy5QVU5DLCAnLCcpO1xuICAgIGNvbnN0IGVuZCA9IHBh
cnNlRXhwcigwKTtcbiAgICBsZXQgc3RlcCA9IG51bGw7XG4gICAgaWYgKG1heWJlKFRPSy5QVU5D
LCAnLCcpKSBzdGVwID0gcGFyc2VFeHByKDApO1xuICAgIGNvbnN0IGJvZHkgPSBbXTtcbiAgICB3
aGlsZSAoIWF0KFRPSy5LVywgJ2VuZCcpICYmICFhdChUT0suRU9GKSkgYm9keS5wdXNoKHBhcnNl
U3RhdGVtZW50KCkpO1xuICAgIGVhdChUT0suS1csICdlbmQnKTtcbiAgICBlYXQoVE9LLktXLCAn
Zm9yJyk7XG4gICAgcmV0dXJuIHsgdHlwZTogJ0ZvcicsIHZhck5hbWUsIHN0YXJ0LCBlbmQsIHN0
ZXAsIGJvZHkgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlV2hpbGUoKSB7XG4gICAgZWF0KFRP
Sy5LVywgJ3doaWxlJyk7XG4gICAgZWF0KFRPSy5QVU5DLCAnKCcpO1xuICAgIGNvbnN0IGNvbmQg
PSBwYXJzZUV4cHIoMCk7XG4gICAgZWF0KFRPSy5QVU5DLCAnKScpO1xuICAgIGNvbnN0IGJvZHkg
PSBbXTtcbiAgICB3aGlsZSAoIWF0KFRPSy5LVywgJ2VuZCcpICYmICFhdChUT0suRU9GKSkgYm9k
eS5wdXNoKHBhcnNlU3RhdGVtZW50KCkpO1xuICAgIGVhdChUT0suS1csICdlbmQnKTtcbiAgICBl
YXQoVE9LLktXLCAnd2hpbGUnKTtcbiAgICByZXR1cm4geyB0eXBlOiAnV2hpbGUnLCBjb25kLCBi
b2R5IH07XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZURvV2hpbGUoKSB7XG4gICAgZWF0KFRPSy5L
VywgJ2RvJyk7XG4gICAgY29uc3QgYm9keSA9IFtdO1xuICAgIHdoaWxlICghYXQoVE9LLktXLCAn
d2hpbGUnKSAmJiAhYXQoVE9LLkVPRikpIGJvZHkucHVzaChwYXJzZVN0YXRlbWVudCgpKTtcbiAg
ICBlYXQoVE9LLktXLCAnd2hpbGUnKTtcbiAgICBlYXQoVE9LLlBVTkMsICcoJyk7XG4gICAgY29u
c3QgY29uZCA9IHBhcnNlRXhwcigwKTtcbiAgICBlYXQoVE9LLlBVTkMsICcpJyk7XG4gICAgcmV0
dXJuIHsgdHlwZTogJ0RvV2hpbGUnLCBjb25kLCBib2R5IH07XG4gIH1cblxuICBmdW5jdGlvbiBw
YXJzZUFyZ3MoKSB7XG4gICAgY29uc3QgYXJncyA9IFtdO1xuICAgIGlmICghYXQoVE9LLlBVTkMs
ICcpJykpIHtcbiAgICAgIGFyZ3MucHVzaChwYXJzZUV4cHIoMCkpO1xuICAgICAgd2hpbGUgKG1h
eWJlKFRPSy5QVU5DLCAnLCcpKSBhcmdzLnB1c2gocGFyc2VFeHByKDApKTtcbiAgICB9XG4gICAg
cmV0dXJuIGFyZ3M7XG4gIH1cblxuICAvLyDilIDilIAgUHJhdHQgZXhwcmVzc2lvbiBwYXJzZXIg
4pSA4pSAXG5cbiAgLy8gQmluZGluZyBwb3dlcnMgKGhpZ2hlciA9IHRpZ2h0ZXIpOlxuICAvLyAg
IG9yKDIpIDwgYW5kKDQpIDwgPT0vPS88IC8+Lzw9Lz49KDYpIDwgfCg4KSA8IF4oMTApIDwgJigx
MilcbiAgLy8gICA8IDw8Lz4+ICgxNCkgPCArLy0oMTYpIDwgKi/Dty9tb2QoMTgpIDwgKiooMjIs
IHJpZ2h0LWFzc29jKVxuICBmdW5jdGlvbiBsYnAodG9rKSB7XG4gICAgaWYgKHRvay50eXBlID09
PSBUT0suS1cpIHtcbiAgICAgIGlmICh0b2sudmFsdWUgPT09ICdvcicpIHJldHVybiAyO1xuICAg
ICAgaWYgKHRvay52YWx1ZSA9PT0gJ2FuZCcpIHJldHVybiA0O1xuICAgICAgaWYgKHRvay52YWx1
ZSA9PT0gJ21vZCcpIHJldHVybiAxODtcbiAgICB9XG4gICAgaWYgKHRvay50eXBlID09PSBUT0su
T1ApIHtcbiAgICAgIGNvbnN0IHYgPSB0b2sudmFsdWU7XG4gICAgICBpZiAodiA9PT0gJz09JyB8
fCB2ID09PSAnLz0nIHx8IHYgPT09ICc8JyB8fCB2ID09PSAnPicgfHwgdiA9PT0gJzw9JyB8fCB2
ID09PSAnPj0nKSByZXR1cm4gNjtcbiAgICAgIGlmICh2ID09PSAnfCcpIHJldHVybiA4O1xuICAg
ICAgaWYgKHYgPT09ICdeJykgcmV0dXJuIDEwO1xuICAgICAgaWYgKHYgPT09ICcmJykgcmV0dXJu
IDEyO1xuICAgICAgaWYgKHYgPT09ICc8PCcgfHwgdiA9PT0gJz4+JykgcmV0dXJuIDE0O1xuICAg
ICAgaWYgKHYgPT09ICcrJyB8fCB2ID09PSAnLScpIHJldHVybiAxNjtcbiAgICAgIGlmICh2ID09
PSAnKicgfHwgdiA9PT0gJy8nKSByZXR1cm4gMTg7XG4gICAgICBpZiAodiA9PT0gJyoqJykgcmV0
dXJuIDIyOyAvLyByaWdodC1hc3NvYzogcGFyc2VFeHByKGJwKSBub3QgcGFyc2VFeHByKGJwKzEp
XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VFeHByKG1pbkJw
KSB7XG4gICAgbGV0IGxlZnQgPSBwYXJzZVByZWZpeCgpO1xuXG4gICAgd2hpbGUgKHRydWUpIHtc
biAgICAgIGNvbnN0IHQgPSBjdXIoKTtcbiAgICAgIGNvbnN0IGJwID0gbGJwKHQpO1xuICAgICAg
aWYgKGJwID09PSAwIHx8IGJwIDwgbWluQnApIGJyZWFrO1xuXG4gICAgICAvLyBpZi1leHByZXNz
aW9uICh0ZXJuYXJ5KTogaWYgKGNvbmQpIHRoZW4gYSBlbHNlIGJcbiAgICAgIC8vIE5vdCBoYW5k
bGVkIGhlcmUg4oCUIGl0J3MgYSBwcmVmaXggZm9ybVxuICAgICAgaWYgKHQudHlwZSA9PT0gVE9L
LktXICYmIHQudmFsdWUgPT09ICdvcicpIHsgcG9zKys7IGxlZnQgPSB7IHR5cGU6ICdCaW5PcCcs
IG9wOiAnb3InLCBsZWZ0LCByaWdodDogcGFyc2VFeHByKGJwICsgMSkgfTsgY29udGludWU7IH1c
biAgICAgIGlmICh0LnR5cGUgPT09IFRPSy5LVyAmJiB0LnZhbHVlID09PSAnYW5kJykgeyBwb3Mr
KzsgbGVmdCA9IHsgdHlwZTogJ0Jpbk9wJywgb3A6ICdhbmQnLCBsZWZ0LCByaWdodDogcGFyc2VF
eHByKGJwICsgMSkgfTsgY29udGludWU7IH1cbiAgICAgIGlmICh0LnR5cGUgPT09IFRPSy5LVyAm
JiB0LnZhbHVlID09PSAnbW9kJykgeyBwb3MrKzsgbGVmdCA9IHsgdHlwZTogJ0Jpbk9wJywgb3A6
ICdtb2QnLCBsZWZ0LCByaWdodDogcGFyc2VFeHByKGJwICsgMSkgfTsgY29udGludWU7IH1cblxu
ICAgICAgaWYgKHQudHlwZSA9PT0gVE9LLk9QKSB7XG4gICAgICAgIGlmICh0LnZhbHVlID09PSAn
KionKSB7XG4gICAgICAgICAgcG9zKys7XG4gICAgICAgICAgLy8gUmlnaHQtYXNzb2NpYXRpdml0
eSB0cmljazogcGFyc2VFeHByKGJwKSBpbnN0ZWFkIG9mIHBhcnNlRXhwcihicCsxKVxuICAgICAg
ICAgIC8vIGxldHMgMioqMyoqNCBwYXJzZSBhcyAyKiooMyoqNCkuXG4gICAgICAgICAgbGVmdCA9
IHsgdHlwZTogJ0Jpbk9wJywgb3A6ICcqKicsIGxlZnQsIHJpZ2h0OiBwYXJzZUV4cHIoYnApIH07
XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgcG9zKys7XG4gICAgICAg
IGxlZnQgPSB7IHR5cGU6ICdCaW5PcCcsIG9wOiB0LnZhbHVlLCBsZWZ0LCByaWdodDogcGFyc2VF
eHByKGJwICsgMSkgfTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBicmVhaztc
biAgICB9XG4gICAgcmV0dXJuIGxlZnQ7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVByZWZpeCgp
IHtcbiAgICBjb25zdCB0ID0gY3VyKCk7XG5cbiAgICAvLyBwYXJlbnRoZXNpemVkIGV4cHJlc3Np
b25cbiAgICBpZiAodC50eXBlID09PSBUT0suUFVOQyAmJiB0LnZhbHVlID09PSAnKCcpIHtcbiAg
ICAgIHBvcysrO1xuICAgICAgY29uc3QgZXhwciA9IHBhcnNlRXhwcigwKTtcbiAgICAgIGVhdChU
T0suUFVOQywgJyknKTtcbiAgICAgIHJldHVybiBleHByO1xuICAgIH1cblxuICAgIC8vIGlmLWV4
cHJlc3Npb24gKHRlcm5hcnkpOiBpZiAoY29uZCkgdGhlbiBhIGVsc2UgYlxuICAgIGlmICh0LnR5
cGUgPT09IFRPSy5LVyAmJiB0LnZhbHVlID09PSAnaWYnKSB7XG4gICAgICBwb3MrKztcbiAgICAg
IGVhdChUT0suUFVOQywgJygnKTtcbiAgICAgIGNvbnN0IGNvbmQgPSBwYXJzZUV4cHIoMCk7XG4g
ICAgICBlYXQoVE9LLlBVTkMsICcpJyk7XG4gICAgICBlYXQoVE9LLktXLCAndGhlbicpO1xuICAg
ICAgY29uc3QgdGhlbkV4cHIgPSBwYXJzZUV4cHIoMCk7XG4gICAgICBlYXQoVE9LLktXLCAnZWxz
ZScpO1xuICAgICAgY29uc3QgZWxzZUV4cHIgPSBwYXJzZUV4cHIoMCk7XG4gICAgICByZXR1cm4g
eyB0eXBlOiAnSWZFeHByJywgY29uZCwgdGhlbkV4cHIsIGVsc2VFeHByIH07XG4gICAgfVxuXG4g
ICAgLy8gdW5hcnkgbWludXNcbiAgICBpZiAodC50eXBlID09PSBUT0suT1AgJiYgdC52YWx1ZSA9
PT0gJy0nKSB7XG4gICAgICBwb3MrKztcbiAgICAgIHJldHVybiB7IHR5cGU6ICdVbmFyeU9wJywg
b3A6ICctJywgb3BlcmFuZDogcGFyc2VFeHByKDIxKSB9O1xuICAgIH1cbiAgICAvLyBub3RcbiAg
ICBpZiAodC50eXBlID09PSBUT0suS1cgJiYgdC52YWx1ZSA9PT0gJ25vdCcpIHtcbiAgICAgIHBv
cysrO1xuICAgICAgcmV0dXJuIHsgdHlwZTogJ1VuYXJ5T3AnLCBvcDogJ25vdCcsIG9wZXJhbmQ6
IHBhcnNlRXhwcigyMSkgfTtcbiAgICB9XG4gICAgLy8gYml0d2lzZSBub3RcbiAgICBpZiAodC50
eXBlID09PSBUT0suT1AgJiYgdC52YWx1ZSA9PT0gJ34nKSB7XG4gICAgICBwb3MrKztcbiAgICAg
IHJldHVybiB7IHR5cGU6ICdVbmFyeU9wJywgb3A6ICd+Jywgb3BlcmFuZDogcGFyc2VFeHByKDIx
KSB9O1xuICAgIH1cbiAgICAvLyBmdW5jdGlvbiByZWZlcmVuY2U6IEBmdW5jbmFtZSDihpIgdGFi
bGUgaW5kZXhcbiAgICBpZiAodC50eXBlID09PSBUT0suT1AgJiYgdC52YWx1ZSA9PT0gJ0AnKSB7
XG4gICAgICBwb3MrKztcbiAgICAgIGNvbnN0IG5hbWUgPSBjdXIoKTtcbiAgICAgIGlmIChuYW1l
LnR5cGUgIT09IFRPSy5JRCkgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBFeHBlY3RlZCBmdW5jdGlv
biBuYW1lIGFmdGVyIEAgYXQgJHtuYW1lLmxpbmV9OiR7bmFtZS5jb2x9YCk7XG4gICAgICBwb3Mr
KztcbiAgICAgIC8vIGNvbnN1bWUgZG90dGVkIHBhcnRzOiBAbnMuZnVuY1xuICAgICAgbGV0IGZ1
bGxOYW1lID0gbmFtZS52YWx1ZTtcbiAgICAgIHdoaWxlIChjdXIoKS50eXBlID09PSBUT0suT1Ag
JiYgY3VyKCkudmFsdWUgPT09ICcuJyAmJiB0b2tlbnNbcG9zICsgMV0gJiYgdG9rZW5zW3BvcyAr
IDFdLnR5cGUgPT09IFRPSy5JRCkge1xuICAgICAgICBwb3MrKzsgLy8gc2tpcCBkb3RcbiAgICAg
ICAgZnVsbE5hbWUgKz0gJy4nICsgY3VyKCkudmFsdWU7XG4gICAgICAgIHBvcysrOyAvLyBza2lw
IGlkXG4gICAgICB9XG4gICAgICByZXR1cm4geyB0eXBlOiAnRnVuY1JlZicsIG5hbWU6IGZ1bGxO
YW1lIH07XG4gICAgfVxuICAgIC8vIG51bWJlciBsaXRlcmFsXG4gICAgaWYgKHQudHlwZSA9PT0g
VE9LLk5VTSkge1xuICAgICAgcG9zKys7XG4gICAgICByZXR1cm4geyB0eXBlOiAnTnVtYmVyTGl0
JywgdmFsdWU6IHQudmFsdWUsIGlzRmxvYXQ6IHQuaXNGbG9hdCwgdHlwZVN1ZmZpeDogdC50eXBl
U3VmZml4IH07XG4gICAgfVxuICAgIC8vIHRydWUvZmFsc2VcbiAgICBpZiAodC50eXBlID09PSBU
T0suS1cgJiYgKHQudmFsdWUgPT09ICd0cnVlJyB8fCB0LnZhbHVlID09PSAnZmFsc2UnKSkge1xu
ICAgICAgcG9zKys7XG4gICAgICByZXR1cm4geyB0eXBlOiAnTnVtYmVyTGl0JywgdmFsdWU6IHQu
dmFsdWUgPT09ICd0cnVlJyA/ICcxJyA6ICcwJywgaXNGbG9hdDogZmFsc2UsIHR5cGVTdWZmaXg6
ICdpMzInIH07XG4gICAgfVxuICAgIC8vIGlkZW50aWZpZXIg4oCUIG1heSBiZSBmdW5jdGlvbiBj
YWxsLCBhcnJheSBhY2Nlc3MsIG9yIHBsYWluIHZhcmlhYmxlXG4gICAgaWYgKHQudHlwZSA9PT0g
VE9LLklEKSB7XG4gICAgICBwb3MrKztcbiAgICAgIGNvbnN0IG5hbWUgPSB0LnZhbHVlO1xuICAg
ICAgLy8gZnVuY3Rpb24gY2FsbDogbmFtZSguLi4pXG4gICAgICBpZiAoYXQoVE9LLlBVTkMsICco
JykpIHtcbiAgICAgICAgcG9zKys7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSBwYXJzZUFyZ3MoKTtc
biAgICAgICAgZWF0KFRPSy5QVU5DLCAnKScpO1xuICAgICAgICByZXR1cm4geyB0eXBlOiAnRnVu
Y0NhbGwnLCBuYW1lLCBhcmdzIH07XG4gICAgICB9XG4gICAgICAvLyBhcnJheSBhY2Nlc3M6IG5h
bWVbLi4uXVxuICAgICAgaWYgKGF0KFRPSy5QVU5DLCAnWycpKSB7XG4gICAgICAgIHBvcysrO1xu
ICAgICAgICBjb25zdCBpbmRpY2VzID0gW3BhcnNlRXhwcigwKV07XG4gICAgICAgIHdoaWxlICht
YXliZShUT0suUFVOQywgJywnKSkgaW5kaWNlcy5wdXNoKHBhcnNlRXhwcigwKSk7XG4gICAgICAg
IGVhdChUT0suUFVOQywgJ10nKTtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogJ0FycmF5QWNjZXNz
JywgbmFtZSwgaW5kaWNlcyB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgdHlwZTogJ0lkZW50
JywgbmFtZSB9O1xuICAgIH1cbiAgICAvLyB0eXBlIGNvbnZlcnNpb24gLyB2ZWN0b3IgY29uc3Ry
dWN0b3I6IGkzMiguLi4pLCBmNjQoLi4uKSwgZjY0eDIoYSwgYiksIGV0Yy5cbiAgICBpZiAodC50
eXBlID09PSBUT0suS1cgJiYgQVRSQV9UWVBFUy5oYXModC52YWx1ZSkgJiYgdG9rZW5zW3BvcyAr
IDFdICYmIHRva2Vuc1twb3MgKyAxXS52YWx1ZSA9PT0gJygnKSB7XG4gICAgICBwb3MrKzsgLy8g
c2tpcCB0eXBlIGtleXdvcmRcbiAgICAgIHBvcysrOyAvLyBza2lwIChcbiAgICAgIGNvbnN0IGFy
Z3MgPSBwYXJzZUFyZ3MoKTtcbiAgICAgIGVhdChUT0suUFVOQywgJyknKTtcbiAgICAgIHJldHVy
biB7IHR5cGU6ICdGdW5jQ2FsbCcsIG5hbWU6IHQudmFsdWUsIGFyZ3MgfTtcbiAgICB9XG4gICAg
dGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIHRva2VuIFwiJHt0LnZhbHVlfVwiIGF0
ICR7dC5saW5lfToke3QuY29sfWApO1xuICB9XG5cbiAgcmV0dXJuIHBhcnNlUHJvZ3JhbSgpO1xu
fVxuXG4vLyAtLSBvcGNvZGVzLmpzIC0tXG5cbi8vIE9wY29kZXMg4oCUIFdhc20gb3Bjb2RlIGNv
bnN0YW50cywgdHlwZSBjb2RlcywgYW5kIFNJTUQgb3BzXG4vL1xuLy8gVGhlIFdhc20gb3Bjb2Rl
IHNwYWNlIGlzIG9yZ2FuaXplZCBieSBjYXRlZ29yeTogY29udHJvbCBmbG93IGF0IDB4MDAsIHZh
cmlhYmxlIGFjY2Vzc1xuLy8gYXQgMHgyMCwgbWVtb3J5IGF0IDB4MjgsIGNvbnN0YW50cyBhdCAw
eDQxLiBXaXRoaW4gdGhlIGFyaXRobWV0aWMgcmVnaW9uICgweDQ14oCTMHhhNiksXG4vLyBvcGNv
ZGVzIGZvcm0gYSB0eXBlw5dvcGVyYXRpb24gZ3JpZDogZWFjaCBvcGVyYXRpb24gaGFzIGZvdXIg
dmFyaWFudHMgKGkzMi9pNjQvZjMyL2Y2NClcbi8vIGxhaWQgb3V0IGluIGNvbnRpZ3VvdXMgYmxv
Y2tzLiBUd28tYnl0ZSBvcGNvZGVzICgweEZDLzB4RkQgcHJlZml4KSBleHRlbmQgdGhlIHNwYWNl
XG4vLyBmb3Igc2F0dXJhdGluZyB0cnVuY2F0aW9uIGFuZCBTSU1ELlxuXG4vLyDilIDilIAgQ29u
dHJvbCBmbG93ICgweDAw4oCTMHgxYikg4pSA4pSAXG5jb25zdCBPUF9VTlJFQUNIQUJMRSA9IDB4
MDAsIE9QX05PUCA9IDB4MDEsIE9QX0JMT0NLID0gMHgwMiwgT1BfTE9PUCA9IDB4MDMsXG4gIE9Q
X0lGID0gMHgwNCwgT1BfRUxTRSA9IDB4MDUsIE9QX0VORCA9IDB4MGIsIE9QX0JSID0gMHgwYywg
T1BfQlJfSUYgPSAweDBkLFxuICBPUF9SRVRVUk4gPSAweDBmLCBPUF9DQUxMID0gMHgxMCwgT1Bf
Q0FMTF9JTkRJUkVDVCA9IDB4MTEsXG4gIE9QX1JFVFVSTl9DQUxMID0gMHgxMiwgT1BfUkVUVVJO
X0NBTExfSU5ESVJFQ1QgPSAweDEzLCBPUF9TRUxFQ1QgPSAweDFiLFxuXG4vLyDilIDilIAgVmFy
aWFibGUgYWNjZXNzICgweDIw4oCTMHgyNCkg4pSA4pSAXG4gIE9QX0xPQ0FMX0dFVCA9IDB4MjAs
IE9QX0xPQ0FMX1NFVCA9IDB4MjEsIE9QX0xPQ0FMX1RFRSA9IDB4MjIsXG4gIE9QX0dMT0JBTF9H
RVQgPSAweDIzLCBPUF9HTE9CQUxfU0VUID0gMHgyNCxcblxuLy8g4pSA4pSAIE1lbW9yeSAoMHgy
OOKAkzB4NDApIOKUgOKUgFxuICBPUF9JMzJfTE9BRCA9IDB4MjgsIE9QX0k2NF9MT0FEID0gMHgy
OSwgT1BfRjMyX0xPQUQgPSAweDJhLCBPUF9GNjRfTE9BRCA9IDB4MmIsXG4gIE9QX0kzMl9TVE9S
RSA9IDB4MzYsIE9QX0k2NF9TVE9SRSA9IDB4MzcsIE9QX0YzMl9TVE9SRSA9IDB4MzgsIE9QX0Y2
NF9TVE9SRSA9IDB4MzksXG4gIE9QX01FTU9SWV9TSVpFID0gMHgzZiwgT1BfTUVNT1JZX0dST1cg
PSAweDQwLFxuXG4vLyDilIDilIAgQ29uc3RhbnRzICgweDQx4oCTMHg0NCkg4pSA4pSAXG4gIE9Q
X0kzMl9DT05TVCA9IDB4NDEsIE9QX0k2NF9DT05TVCA9IDB4NDIsIE9QX0YzMl9DT05TVCA9IDB4
NDMsIE9QX0Y2NF9DT05TVCA9IDB4NDQsXG5cbi8vIOKUgOKUgCBDb21wYXJpc29uICgweDQ14oCT
MHg2Nikg4oCUIHR5cGXDl29wZXJhdGlvbiBncmlkOiBlcXovZXEvbmUvbHQvZ3QvbGUvZ2UgcGVy
IHR5cGUg4pSA4pSAXG4gIE9QX0kzMl9FUVogPSAweDQ1LCBPUF9JMzJfRVEgPSAweDQ2LCBPUF9J
MzJfTkUgPSAweDQ3LFxuICBPUF9JMzJfTFRfUyA9IDB4NDgsIE9QX0kzMl9MVF9VID0gMHg0OSwg
T1BfSTMyX0dUX1MgPSAweDRhLCBPUF9JMzJfR1RfVSA9IDB4NGIsXG4gIE9QX0kzMl9MRV9TID0g
MHg0YywgT1BfSTMyX0xFX1UgPSAweDRkLCBPUF9JMzJfR0VfUyA9IDB4NGUsIE9QX0kzMl9HRV9V
ID0gMHg0ZixcbiAgT1BfSTY0X0VRWiA9IDB4NTAsIE9QX0k2NF9FUSA9IDB4NTEsIE9QX0k2NF9O
RSA9IDB4NTIsXG4gIE9QX0k2NF9MVF9TID0gMHg1MywgT1BfSTY0X0xUX1UgPSAweDU0LCBPUF9J
NjRfR1RfUyA9IDB4NTUsIE9QX0k2NF9HVF9VID0gMHg1NixcbiAgT1BfSTY0X0xFX1MgPSAweDU3
LCBPUF9JNjRfTEVfVSA9IDB4NTgsIE9QX0k2NF9HRV9TID0gMHg1OSwgT1BfSTY0X0dFX1UgPSAw
eDVhLFxuICBPUF9GMzJfRVEgPSAweDViLCBPUF9GMzJfTkUgPSAweDVjLCBPUF9GMzJfTFQgPSAw
eDVkLCBPUF9GMzJfR1QgPSAweDVlLCBPUF9GMzJfTEUgPSAweDVmLCBPUF9GMzJfR0UgPSAweDYw
LFxuICBPUF9GNjRfRVEgPSAweDYxLCBPUF9GNjRfTkUgPSAweDYyLCBPUF9GNjRfTFQgPSAweDYz
LCBPUF9GNjRfR1QgPSAweDY0LCBPUF9GNjRfTEUgPSAweDY1LCBPUF9GNjRfR0UgPSAweDY2LFxu
XG4vLyDilIDilIAgaTMyIGFyaXRobWV0aWMgKDB4NjfigJMweDc4KSDilIDilIBcbiAgT1BfSTMy
X0NMWiA9IDB4NjcsIE9QX0kzMl9DVFogPSAweDY4LCBPUF9JMzJfUE9QQ05UID0gMHg2OSxcbiAg
T1BfSTMyX0FERCA9IDB4NmEsIE9QX0kzMl9TVUIgPSAweDZiLCBPUF9JMzJfTVVMID0gMHg2Yyxc
biAgT1BfSTMyX0RJVl9TID0gMHg2ZCwgT1BfSTMyX0RJVl9VID0gMHg2ZSwgT1BfSTMyX1JFTV9T
ID0gMHg2ZiwgT1BfSTMyX1JFTV9VID0gMHg3MCxcbiAgT1BfSTMyX0FORCA9IDB4NzEsIE9QX0kz
Ml9PUiA9IDB4NzIsIE9QX0kzMl9YT1IgPSAweDczLFxuICBPUF9JMzJfU0hMID0gMHg3NCwgT1Bf
STMyX1NIUl9TID0gMHg3NSwgT1BfSTMyX1NIUl9VID0gMHg3NixcbiAgT1BfSTMyX1JPVEwgPSAw
eDc3LCBPUF9JMzJfUk9UUiA9IDB4NzgsXG5cbi8vIOKUgOKUgCBpNjQgYXJpdGhtZXRpYyAoMHg3
OeKAkzB4OGEpIOKUgOKUgFxuICBPUF9JNjRfQ0xaID0gMHg3OSwgT1BfSTY0X0NUWiA9IDB4N2Es
IE9QX0k2NF9QT1BDTlQgPSAweDdiLFxuICBPUF9JNjRfQUREID0gMHg3YywgT1BfSTY0X1NVQiA9
IDB4N2QsIE9QX0k2NF9NVUwgPSAweDdlLFxuICBPUF9JNjRfRElWX1MgPSAweDdmLCBPUF9JNjRf
RElWX1UgPSAweDgwLCBPUF9JNjRfUkVNX1MgPSAweDgxLCBPUF9JNjRfUkVNX1UgPSAweDgyLFxu
ICBPUF9JNjRfQU5EID0gMHg4MywgT1BfSTY0X09SID0gMHg4NCwgT1BfSTY0X1hPUiA9IDB4ODUs
XG4gIE9QX0k2NF9TSEwgPSAweDg2LCBPUF9JNjRfU0hSX1MgPSAweDg3LCBPUF9JNjRfU0hSX1Ug
PSAweDg4LFxuICBPUF9JNjRfUk9UTCA9IDB4ODksIE9QX0k2NF9ST1RSID0gMHg4YSxcblxuLy8g
4pSA4pSAIGYzMiB1bmFyeSArIGJpbmFyeSAoMHg4YuKAkzB4OTgpIOKUgOKUgFxuICBPUF9GMzJf
QUJTID0gMHg4YiwgT1BfRjMyX05FRyA9IDB4OGMsIE9QX0YzMl9DRUlMID0gMHg4ZCwgT1BfRjMy
X0ZMT09SID0gMHg4ZSxcbiAgT1BfRjMyX1RSVU5DID0gMHg4ZiwgT1BfRjMyX05FQVJFU1QgPSAw
eDkwLCBPUF9GMzJfU1FSVCA9IDB4OTEsXG4gIE9QX0YzMl9BREQgPSAweDkyLCBPUF9GMzJfU1VC
ID0gMHg5MywgT1BfRjMyX01VTCA9IDB4OTQsIE9QX0YzMl9ESVYgPSAweDk1LFxuICBPUF9GMzJf
TUlOID0gMHg5NiwgT1BfRjMyX01BWCA9IDB4OTcsIE9QX0YzMl9DT1BZU0lHTiA9IDB4OTgsXG5c
bi8vIOKUgOKUgCBmNjQgdW5hcnkgKyBiaW5hcnkgKDB4OTnigJMweGE2KSDilIDilIBcbiAgT1Bf
RjY0X0FCUyA9IDB4OTksIE9QX0Y2NF9ORUcgPSAweDlhLCBPUF9GNjRfQ0VJTCA9IDB4OWIsIE9Q
X0Y2NF9GTE9PUiA9IDB4OWMsXG4gIE9QX0Y2NF9UUlVOQyA9IDB4OWQsIE9QX0Y2NF9ORUFSRVNU
ID0gMHg5ZSwgT1BfRjY0X1NRUlQgPSAweDlmLFxuICBPUF9GNjRfQUREID0gMHhhMCwgT1BfRjY0
X1NVQiA9IDB4YTEsIE9QX0Y2NF9NVUwgPSAweGEyLCBPUF9GNjRfRElWID0gMHhhMyxcbiAgT1Bf
RjY0X01JTiA9IDB4YTQsIE9QX0Y2NF9NQVggPSAweGE1LCBPUF9GNjRfQ09QWVNJR04gPSAweGE2
LFxuXG4vLyDilIDilIAgQ29udmVyc2lvbnMgKDB4YTfigJMweGM0KSDilIDilIBcbiAgT1BfSTMy
X1dSQVBfSTY0ID0gMHhhNyxcbiAgT1BfSTMyX1RSVU5DX0YzMl9TID0gMHhhOCwgT1BfSTMyX1RS
VU5DX0Y2NF9TID0gMHhhYSxcbiAgT1BfSTY0X0VYVEVORF9JMzJfUyA9IDB4YWMsIE9QX0k2NF9F
WFRFTkRfSTMyX1UgPSAweGFkLFxuICBPUF9JNjRfVFJVTkNfRjMyX1MgPSAweGFlLCBPUF9JNjRf
VFJVTkNfRjY0X1MgPSAweGIwLFxuICBPUF9GMzJfQ09OVkVSVF9JMzJfUyA9IDB4YjIsIE9QX0Yz
Ml9DT05WRVJUX0k2NF9TID0gMHhiNCxcbiAgT1BfRjMyX0RFTU9URV9GNjQgPSAweGI2LFxuICBP
UF9GNjRfQ09OVkVSVF9JMzJfUyA9IDB4YjcsIE9QX0Y2NF9DT05WRVJUX0k2NF9TID0gMHhiOSxc
biAgT1BfRjY0X1BST01PVEVfRjMyID0gMHhiYixcbiAgT1BfSTMyX1JFSU5URVJQUkVUX0YzMiA9
IDB4YmMsIE9QX0k2NF9SRUlOVEVSUFJFVF9GNjQgPSAweGJkLFxuICBPUF9GMzJfUkVJTlRFUlBS
RVRfSTMyID0gMHhiZSwgT1BfRjY0X1JFSU5URVJQUkVUX0k2NCA9IDB4YmYsXG4gIE9QX0kzMl9F
WFRFTkQ4X1MgPSAweGMwLCBPUF9JMzJfRVhURU5EMTZfUyA9IDB4YzEsXG4gIE9QX0k2NF9FWFRF
TkQ4X1MgPSAweGMyLCBPUF9JNjRfRVhURU5EMTZfUyA9IDB4YzMsIE9QX0k2NF9FWFRFTkQzMl9T
ID0gMHhjNDtcblxuLy8g4pSA4pSAIEZDIHByZWZpeCAoMHhGQyArIHUzMikg4oCUIHNhdHVyYXRp
bmcgdHJ1bmNhdGlvbiDilIDilIBcbmNvbnN0IE9QX0ZDX1BSRUZJWCA9IDB4ZmM7XG5jb25zdCBP
UF9JMzJfVFJVTkNfU0FUX0YzMl9TID0gMCwgT1BfSTMyX1RSVU5DX1NBVF9GMzJfVSA9IDEsXG4g
IE9QX0kzMl9UUlVOQ19TQVRfRjY0X1MgPSAyLCBPUF9JMzJfVFJVTkNfU0FUX0Y2NF9VID0gMyxc
biAgT1BfSTY0X1RSVU5DX1NBVF9GMzJfUyA9IDQsIE9QX0k2NF9UUlVOQ19TQVRfRjMyX1UgPSA1
LFxuICBPUF9JNjRfVFJVTkNfU0FUX0Y2NF9TID0gNiwgT1BfSTY0X1RSVU5DX1NBVF9GNjRfVSA9
IDc7XG5cbi8vIOKUgOKUgCBUeXBlIGNvZGVzIOKUgOKUgFxuLy8gRGVzY2VuZGluZyBmcm9tIDB4
N2Y6IGkzMiwgaTY0LCBmMzIsIGY2NCwgdjEyOC4gVGhlc2UgYXJlIG5lZ2F0aXZlIHZhbHVlcyBp
blxuLy8gc2lnbmVkIExFQjEyOCwgd2hpY2ggaXMgaG93IHRoZXkgYXBwZWFyIGluIGZ1bmN0aW9u
IHNpZ25hdHVyZXMgYW5kIGxvY2FsIGRlY2xhcmF0aW9ucy5cbmNvbnN0IFdBU01fSTMyID0gMHg3
ZiwgV0FTTV9JNjQgPSAweDdlLCBXQVNNX0YzMiA9IDB4N2QsIFdBU01fRjY0ID0gMHg3YztcbmNv
bnN0IFdBU01fVjEyOCA9IDB4N2I7XG5jb25zdCBXQVNNX1ZPSUQgPSAweDQwO1xuXG4vLyDilIDi
lIAgU0lNRCBwcmVmaXggKDB4RkQgKyB1MzIpIOKUgOKUgFxuY29uc3QgT1BfU0lNRF9QUkVGSVgg
PSAweGZkO1xuXG4vLyBTSU1EIG9wY29kZSB0YWJsZSDigJQga2V5ZWQgYnkgXCJ0eXBlLm9wZXJh
dGlvblwiIGZvciBlYXN5IGxvb2t1cCBmcm9tIGNvZGVnZW5cbmNvbnN0IFNJTURfT1BTID0ge1xu
ICAvLyBzcGxhdFxuICAnaTMyeDQuc3BsYXQnOiAweDExLCAnaTY0eDIuc3BsYXQnOiAweDEyLCAn
ZjMyeDQuc3BsYXQnOiAweDEzLCAnZjY0eDIuc3BsYXQnOiAweDE0LFxuICAvLyBleHRyYWN0X2xh
bmVcbiAgJ2kzMng0LmV4dHJhY3RfbGFuZSc6IDB4MWIsICdpNjR4Mi5leHRyYWN0X2xhbmUnOiAw
eDFkLCAnZjMyeDQuZXh0cmFjdF9sYW5lJzogMHgxZiwgJ2Y2NHgyLmV4dHJhY3RfbGFuZSc6IDB4
MjEsXG4gIC8vIHJlcGxhY2VfbGFuZVxuICAnaTMyeDQucmVwbGFjZV9sYW5lJzogMHgxYywgJ2k2
NHgyLnJlcGxhY2VfbGFuZSc6IDB4MWUsICdmMzJ4NC5yZXBsYWNlX2xhbmUnOiAweDIwLCAnZjY0
eDIucmVwbGFjZV9sYW5lJzogMHgyMixcbiAgLy8gYWRkXG4gICdpMzJ4NC5hZGQnOiAweGFlLCAn
aTY0eDIuYWRkJzogMHhjZSwgJ2YzMng0LmFkZCc6IDB4ZTQsICdmNjR4Mi5hZGQnOiAweGYwLFxu
ICAvLyBzdWJcbiAgJ2kzMng0LnN1Yic6IDB4YjEsICdpNjR4Mi5zdWInOiAweGQxLCAnZjMyeDQu
c3ViJzogMHhlNSwgJ2Y2NHgyLnN1Yic6IDB4ZjEsXG4gIC8vIG11bFxuICAnaTMyeDQubXVsJzog
MHhiNSwgJ2k2NHgyLm11bCc6IDB4ZDUsICdmMzJ4NC5tdWwnOiAweGU2LCAnZjY0eDIubXVsJzog
MHhmMixcbiAgLy8gZGl2IChmbG9hdCBvbmx5KVxuICAnZjMyeDQuZGl2JzogMHhlNywgJ2Y2NHgy
LmRpdic6IDB4ZjMsXG4gIC8vIG5lZ1xuICAnaTMyeDQubmVnJzogMHhhMSwgJ2k2NHgyLm5lZyc6
IDB4YzEsICdmMzJ4NC5uZWcnOiAweGUxLCAnZjY0eDIubmVnJzogMHhlZCxcbiAgLy8gYWJzIChm
bG9hdCBvbmx5KVxuICAnZjMyeDQuYWJzJzogMHhlMCwgJ2Y2NHgyLmFicyc6IDB4ZWMsXG4gIC8v
IHNxcnQgKGZsb2F0IG9ubHkpXG4gICdmMzJ4NC5zcXJ0JzogMHhlMywgJ2Y2NHgyLnNxcnQnOiAw
eGVmLFxuICAvLyBtaW4vbWF4IChmbG9hdCBvbmx5KVxuICAnZjMyeDQubWluJzogMHhlOCwgJ2Y2
NHgyLm1pbic6IDB4ZjQsICdmMzJ4NC5tYXgnOiAweGU5LCAnZjY0eDIubWF4JzogMHhmNSxcbiAg
Ly8gY29tcGFyaXNvbiDigJQgZXFcbiAgJ2kzMng0LmVxJzogMHgzNywgJ2k2NHgyLmVxJzogMHhk
NiwgJ2YzMng0LmVxJzogMHg0MSwgJ2Y2NHgyLmVxJzogMHg0NyxcbiAgLy8gbmVcbiAgJ2kzMng0
Lm5lJzogMHgzOCwgJ2YzMng0Lm5lJzogMHg0MiwgJ2Y2NHgyLm5lJzogMHg0OCxcbiAgLy8gbHRc
biAgJ2kzMng0Lmx0X3MnOiAweDM5LCAnaTY0eDIubHRfcyc6IDB4ZDcsICdmMzJ4NC5sdCc6IDB4
NDMsICdmNjR4Mi5sdCc6IDB4NDksXG4gIC8vIGd0XG4gICdpMzJ4NC5ndF9zJzogMHgzYiwgJ2k2
NHgyLmd0X3MnOiAweGQ5LCAnZjMyeDQuZ3QnOiAweDQ0LCAnZjY0eDIuZ3QnOiAweDRhLFxuICAv
LyBsZVxuICAnaTMyeDQubGVfcyc6IDB4M2QsICdpNjR4Mi5sZV9zJzogMHhkYiwgJ2YzMng0Lmxl
JzogMHg0NSwgJ2Y2NHgyLmxlJzogMHg0YixcbiAgLy8gZ2VcbiAgJ2kzMng0LmdlX3MnOiAweDNm
LCAnaTY0eDIuZ2Vfcyc6IDB4ZGQsICdmMzJ4NC5nZSc6IDB4NDYsICdmNjR4Mi5nZSc6IDB4NGMs
XG4gIC8vIHYxMjggYml0d2lzZVxuICAndjEyOC5ub3QnOiAweDRkLCAndjEyOC5hbmQnOiAweDRl
LCAndjEyOC5vcic6IDB4NTAsICd2MTI4Lnhvcic6IDB4NTEsXG4gIC8vIHYxMjggbWVtb3J5XG4g
ICd2MTI4LmxvYWQnOiAweDAwLCAndjEyOC5zdG9yZSc6IDB4MGIsICd2MTI4LmNvbnN0JzogMHgw
Yyxcbn07XG5cbmZ1bmN0aW9uIHdhc21UeXBlKHQpIHtcbiAgaWYgKHQgPT09ICdpMzInKSByZXR1
cm4gV0FTTV9JMzI7XG4gIGlmICh0ID09PSAnaTY0JykgcmV0dXJuIFdBU01fSTY0O1xuICBpZiAo
dCA9PT0gJ2YzMicpIHJldHVybiBXQVNNX0YzMjtcbiAgaWYgKHQgPT09ICdmNjQnKSByZXR1cm4g
V0FTTV9GNjQ7XG4gIGlmIChpc1ZlY3Rvcih0KSkgcmV0dXJuIFdBU01fVjEyODtcbiAgdGhyb3cg
bmV3IEVycm9yKCdVbmtub3duIHR5cGU6ICcgKyB0KTtcbn1cblxuZnVuY3Rpb24gdHlwZVNpemUo
dCkge1xuICBpZiAodCA9PT0gJ2kzMicgfHwgdCA9PT0gJ2YzMicpIHJldHVybiA0O1xuICBpZiAo
dCA9PT0gJ2k2NCcgfHwgdCA9PT0gJ2Y2NCcpIHJldHVybiA4O1xuICBpZiAoaXNWZWN0b3IodCkp
IHJldHVybiAxNjtcbiAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHR5cGU6ICcgKyB0KTtcbn1c
blxuZnVuY3Rpb24gaXNWZWN0b3IodCkgeyByZXR1cm4gdCA9PT0gJ2Y2NHgyJyB8fCB0ID09PSAn
ZjMyeDQnIHx8IHQgPT09ICdpMzJ4NCcgfHwgdCA9PT0gJ2k2NHgyJzsgfVxuZnVuY3Rpb24gdmVj
dG9yU2NhbGFyVHlwZSh0KSB7XG4gIGlmICh0ID09PSAnZjY0eDInKSByZXR1cm4gJ2Y2NCc7XG4g
IGlmICh0ID09PSAnZjMyeDQnKSByZXR1cm4gJ2YzMic7XG4gIGlmICh0ID09PSAnaTMyeDQnKSBy
ZXR1cm4gJ2kzMic7XG4gIGlmICh0ID09PSAnaTY0eDInKSByZXR1cm4gJ2k2NCc7XG4gIHJldHVy
biBudWxsO1xufVxuXG4vLyAtLSBieXRld3JpdGVyLmpzIC0tXG5cbi8vIEJ5dGVXcml0ZXIg4oCU
IGJpbmFyeSBidWlsZGVyIGZvciBXYXNtIG91dHB1dFxuLy9cbi8vIFdhc20gdXNlcyBMRUIxMjgg
KExpdHRsZS1FbmRpYW4gQmFzZSAxMjgpIGZvciBhbGwgaW50ZWdlcnMg4oCUIGEgdmFyaWFibGUt
bGVuZ3RoXG4vLyBlbmNvZGluZyB3aGVyZSBlYWNoIGJ5dGUgdXNlcyA3IGRhdGEgYml0cyArIDEg
Y29udGludWF0aW9uIGJpdC4gVGhpcyBrZWVwc1xuLy8gc21hbGwgdmFsdWVzIGNvbXBhY3QgKDEg
Ynl0ZSBmb3IgMOKAkzEyNykgd2hpbGUgc3RpbGwgc3VwcG9ydGluZyB0aGUgZnVsbCByYW5nZS5c
blxuY2xhc3MgQnl0ZVdyaXRlciB7XG4gIGNvbnN0cnVjdG9yKCkgeyB0aGlzLmJ1ZiA9IFtdOyB9
XG4gIGJ5dGUoYikgeyB0aGlzLmJ1Zi5wdXNoKGIgJiAweGZmKTsgfVxuICBieXRlcyhhcnIpIHsg
Zm9yIChjb25zdCBiIG9mIGFycikgdGhpcy5ieXRlKGIpOyB9XG4gIHUzMih2KSB7IC8vIExFQjEy
OCB1bnNpZ25lZFxuICAgIGRvIHsgbGV0IGIgPSB2ICYgMHg3ZjsgdiA+Pj49IDc7IGlmICh2KSBi
IHw9IDB4ODA7IHRoaXMuYnl0ZShiKTsgfSB3aGlsZSAodik7XG4gIH1cbiAgczMyKHYpIHsgLy8g
TEVCMTI4IHNpZ25lZFxuICAgIGxldCBtb3JlID0gdHJ1ZTtcbiAgICB3aGlsZSAobW9yZSkge1xu
ICAgICAgbGV0IGIgPSB2ICYgMHg3ZjsgdiA+Pj0gNztcbiAgICAgIGlmICgodiA9PT0gMCAmJiAh
KGIgJiAweDQwKSkgfHwgKHYgPT09IC0xICYmIChiICYgMHg0MCkpKSBtb3JlID0gZmFsc2U7IGVs
c2UgYiB8PSAweDgwO1xuICAgICAgdGhpcy5ieXRlKGIpO1xuICAgIH1cbiAgfVxuICBzNjQodikg
eyAvLyBMRUIxMjggc2lnbmVkIGZvciBpNjQgKEJpZ0ludClcbiAgICB2ID0gQmlnSW50KHYpO1xu
ICAgIGxldCBtb3JlID0gdHJ1ZTtcbiAgICB3aGlsZSAobW9yZSkge1xuICAgICAgbGV0IGIgPSBO
dW1iZXIodiAmIDB4N2ZuKTsgdiA+Pj0gN247XG4gICAgICBpZiAoKHYgPT09IDBuICYmICEoYiAm
IDB4NDApKSB8fCAodiA9PT0gLTFuICYmIChiICYgMHg0MCkpKSBtb3JlID0gZmFsc2U7IGVsc2Ug
YiB8PSAweDgwO1xuICAgICAgdGhpcy5ieXRlKGIpO1xuICAgIH1cbiAgfVxuICBmMzIodikgeyBj
b25zdCBidWYgPSBuZXcgQXJyYXlCdWZmZXIoNCk7IG5ldyBEYXRhVmlldyhidWYpLnNldEZsb2F0
MzIoMCwgdiwgdHJ1ZSk7IHRoaXMuYnl0ZXMobmV3IFVpbnQ4QXJyYXkoYnVmKSk7IH1cbiAgZjY0
KHYpIHsgY29uc3QgYnVmID0gbmV3IEFycmF5QnVmZmVyKDgpOyBuZXcgRGF0YVZpZXcoYnVmKS5z
ZXRGbG9hdDY0KDAsIHYsIHRydWUpOyB0aGlzLmJ5dGVzKG5ldyBVaW50OEFycmF5KGJ1ZikpOyB9
XG4gIHN0cihzKSB7IGNvbnN0IGVuYyA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShzKTsgdGhp
cy51MzIoZW5jLmxlbmd0aCk7IHRoaXMuYnl0ZXMoZW5jKTsgfVxuICAvLyBXYXNtIHNlY3Rpb25z
IGFyZSBsZW5ndGgtcHJlZml4ZWQsIGJ1dCB0aGUgbGVuZ3RoIGlzbid0IGtub3duIHVudGlsIHRo
ZSBjb250ZW50XG4gIC8vIGlzIHdyaXR0ZW4uIFNvbHV0aW9uOiB3cml0ZSBpbnRvIGEgdGVtcG9y
YXJ5IGJ1ZmZlciwgbWVhc3VyZSwgdGhlbiBlbWl0IGlkICsgc2l6ZSArIGNvbnRlbnQuXG4gIHNl
Y3Rpb24oaWQsIGNvbnRlbnRGbikge1xuICAgIGNvbnN0IGlubmVyID0gbmV3IEJ5dGVXcml0ZXIo
KTtcbiAgICBjb250ZW50Rm4oaW5uZXIpO1xuICAgIHRoaXMuYnl0ZShpZCk7XG4gICAgdGhpcy51
MzIoaW5uZXIuYnVmLmxlbmd0aCk7XG4gICAgdGhpcy5ieXRlcyhpbm5lci5idWYpO1xuICB9XG4g
IHRvVWludDhBcnJheSgpIHsgcmV0dXJuIG5ldyBVaW50OEFycmF5KHRoaXMuYnVmKTsgfVxufVxu
XG4vLyAtLSBjb2RlZ2VuLmpzIC0tXG5cbi8vIENvZGVnZW4g4oCUIEFTVCDihpIgV2FzbSBiaW5h
cnlcbi8vXG4vLyBTaW5nbGUtcGFzcyBjb21waWxlcjogQVNUIGluLCBXYXNtIGJ5dGVzIG91dC4g
Tm8gb3B0aW1pemF0aW9uLCBubyBpbnRlcm1lZGlhdGVcbi8vIHJlcHJlc2VudGF0aW9uLiBDbG9z
dXJlLWJhc2VkIGFyY2hpdGVjdHVyZTogZW1pdEZ1bmN0aW9uQm9keSBjYXB0dXJlcyBpbmRleCB0
YWJsZXNcbi8vIChmdW5jSW5kZXgsIGdsb2JhbEluZGV4LCBsb2NhbE1hcCkgZnJvbSB0aGUgb3V0
ZXIgY29kZWdlbiBzY29wZS5cbi8vXG4vLyBPdXRwdXQgZm9sbG93cyBXYXNtIGJpbmFyeSBzZWN0
aW9uIG9yZGVyaW5nOiBUeXBlKDEpLCBJbXBvcnQoMiksIEZ1bmN0aW9uKDMpLFxuLy8gVGFibGUo
NCksIE1lbW9yeSg1KSwgR2xvYmFsKDYpLCBFeHBvcnQoNyksIEVsZW1lbnQoOSksIENvZGUoMTAp
LlxuLy9cbi8vIE1vc3QgZW1pdHRlcnMgYnJhbmNoIG9uIHR5cGUgKGY2NC9mMzIvaTMyL2k2NC92
ZWN0b3IpIGJlY2F1c2UgV2FzbSdzIGluc3RydWN0aW9uXG4vLyBzZXQgaXMgZnVsbHkgdHlwZWQg
4oCUIHRoZXJlJ3Mgbm8gcG9seW1vcnBoaWMgYWRkLCBvbmx5IGkzMi5hZGQsIGY2NC5hZGQsIGV0
Yy5cblxuXG5cblxuLy8gTmVzdGVkIEpTIG9iamVjdHMg4oaSIGZsYXQgXCJhLmIuY1wiIGtleXMu
IFdhc20gaW1wb3J0cyB1c2UgYSB0d28tbGV2ZWwgbmFtZXNwYWNlXG4vLyAobW9kdWxlICsgbmFt
ZSksIHNvIG5lc3RlZCB1c2VyIGltcG9ydHMgbGlrZSB7cGh5c2ljczoge2dyYXZpdHk6IGZufX0g
bmVlZCBmbGF0dGVuaW5nLlxuZnVuY3Rpb24gZmxhdHRlbkltcG9ydHMob2JqLCBwcmVmaXgpIHtc
biAgY29uc3QgZmxhdCA9IHt9O1xuICBmb3IgKGNvbnN0IFtrLCB2XSBvZiBPYmplY3QuZW50cmll
cyhvYmopKSB7XG4gICAgaWYgKCFwcmVmaXggJiYgKGsgPT09ICdfX21lbW9yeScgfHwgayA9PT0g
J21lbW9yeScgfHwgayA9PT0gJ19fdGFibGUnKSkgY29udGludWU7XG4gICAgY29uc3Qga2V5ID0g
cHJlZml4ID8gcHJlZml4ICsgJy4nICsgayA6IGs7XG4gICAgaWYgKHR5cGVvZiB2ID09PSAnZnVu
Y3Rpb24nKSBmbGF0W2tleV0gPSB2O1xuICAgIGVsc2UgaWYgKHYgJiYgdHlwZW9mIHYgPT09ICdv
YmplY3QnICYmICFBcnJheUJ1ZmZlci5pc1ZpZXcodikpIE9iamVjdC5hc3NpZ24oZmxhdCwgZmxh
dHRlbkltcG9ydHModiwga2V5KSk7XG4gIH1cbiAgcmV0dXJuIGZsYXQ7XG59XG5cbmZ1bmN0aW9u
IGNvZGVnZW4oYXN0LCBpbnRlcnBWYWx1ZXMsIHVzZXJJbXBvcnRzKSB7XG4gIGNvbnN0IHcgPSBu
ZXcgQnl0ZVdyaXRlcigpO1xuXG4gIC8vIOKUgOKUgCBDb2xsZWN0IGluZm8g4pSA4pSAXG4gIGNv
bnN0IGdsb2JhbHMgPSBbXTsgICAgLy8geyBuYW1lLCB2dHlwZSwgbXV0YWJsZSwgaW5pdCB9XG4g
IGNvbnN0IGZ1bmN0aW9ucyA9IFtdOyAgLy8gQVNUIG5vZGVzXG4gIGNvbnN0IGltcG9ydHMgPSBb
XTsgICAgLy8geyBuYW1lLCBtb2R1bGVOYW1lLCBwYXJhbXMsIHJldFR5cGUsIGludGVycElkeCB9
XG4gIGNvbnN0IGxvY2FsRnVuY05hbWVzID0gbmV3IFNldCgpO1xuXG4gIGZvciAoY29uc3Qgbm9k
ZSBvZiBhc3QuYm9keSkge1xuICAgIGlmIChub2RlLnR5cGUgPT09ICdDb25zdERlY2wnKSBnbG9i
YWxzLnB1c2goeyBuYW1lOiBub2RlLm5hbWUsIHZ0eXBlOiBub2RlLnZ0eXBlLCBtdXRhYmxlOiBm
YWxzZSwgaW5pdDogbm9kZS5pbml0IH0pO1xuICAgIGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gJ1Zh
ckRlY2wnKSB7XG4gICAgICBjb25zdCBnID0geyBuYW1lOiBub2RlLm5hbWUsIHZ0eXBlOiBub2Rl
LnZ0eXBlLCBtdXRhYmxlOiB0cnVlLCBpbml0OiBub2RlLmluaXQgfTtcbiAgICAgIGlmIChub2Rl
LmZ1bmNTaWcpIGcuZnVuY1NpZyA9IG5vZGUuZnVuY1NpZztcbiAgICAgIGdsb2JhbHMucHVzaChn
KTtcbiAgICB9XG4gICAgZWxzZSBpZiAobm9kZS50eXBlID09PSAnRnVuY3Rpb24nIHx8IG5vZGUu
dHlwZSA9PT0gJ1N1YnJvdXRpbmUnKSB7IGZ1bmN0aW9ucy5wdXNoKG5vZGUpOyBsb2NhbEZ1bmNO
YW1lcy5hZGQobm9kZS5uYW1lKTsgfVxuICAgIGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gJ0ltcG9y
dERlY2wnKSBpbXBvcnRzLnB1c2gobm9kZSk7XG4gIH1cblxuICAvLyBNYXRoIGJ1aWx0aW5zOiBp
bXBvcnRlZCBmcm9tIEpTIE1hdGggb2JqZWN0LiBWYWx1ZSA9IHBhcmFtIGNvdW50LlxuICBjb25z
dCBNQVRIX0JVSUxUSU5TID0geyBzaW46IDEsIGNvczogMSwgbG46IDEsIGV4cDogMSwgcG93OiAy
LCBhdGFuMjogMiB9O1xuICAvLyBOYXRpdmUgYnVpbHRpbnM6IG1hcCBkaXJlY3RseSB0byBXYXNt
IG9wY29kZXMsIG5vIGltcG9ydCBuZWVkZWRcbiAgY29uc3QgTkFUSVZFX0JVSUxUSU5TID0gbmV3
IFNldChbXG4gICAgJ3NxcnQnLCdhYnMnLCdmbG9vcicsJ2NlaWwnLCd0cnVuYycsJ25lYXJlc3Qn
LCdjb3B5c2lnbicsXG4gICAgJ21pbicsJ21heCcsJ3NlbGVjdCcsXG4gICAgJ2NseicsJ2N0eics
J3BvcGNudCcsJ3JvdGwnLCdyb3RyJyxcbiAgICAnbWVtb3J5X3NpemUnLCdtZW1vcnlfZ3Jvdycs
J21lbW9yeV9jb3B5JywnbWVtb3J5X2ZpbGwnLFxuICAgICdpMzInLCdpNjQnLCdmMzInLCdmNjQn
LCAvLyB0eXBlIGNvbnZlcnNpb25zXG4gICAgJ2Y2NHgyJywnZjMyeDQnLCdpMzJ4NCcsJ2k2NHgy
JywgLy8gdmVjdG9yIGNvbnN0cnVjdG9yc1xuICBdKTtcblxuICAvLyBTY2FuIGFsbCBmdW5jdGlv
biBib2RpZXMgZm9yIHVucmVzb2x2ZWQgY2FsbHNcbiAgY29uc3QgdXNlZENhbGxzID0gbmV3IFNl
dCgpO1xuICBmdW5jdGlvbiBzY2FuQ2FsbHMoc3RtdHMpIHtcbiAgICBmb3IgKGNvbnN0IHMgb2Yg
c3RtdHMpIHtcbiAgICAgIGlmIChzLnR5cGUgPT09ICdDYWxsJyB8fCBzLnR5cGUgPT09ICdGdW5j
Q2FsbCcpIHVzZWRDYWxscy5hZGQocy5uYW1lKTtcbiAgICAgIGlmIChzLnR5cGUgPT09ICdJZicp
IHsgc2NhbkNhbGxzKHMuYm9keSk7IGlmIChzLmVsc2VCb2R5KSBzY2FuQ2FsbHMocy5lbHNlQm9k
eSk7IH1cbiAgICAgIGlmIChzLnR5cGUgPT09ICdGb3InIHx8IHMudHlwZSA9PT0gJ1doaWxlJyB8
fCBzLnR5cGUgPT09ICdEb1doaWxlJykgc2NhbkNhbGxzKHMuYm9keSk7XG4gICAgICAvLyBzY2Fu
IGV4cHJlc3Npb25zXG4gICAgICBzY2FuRXhwckNhbGxzKHMpO1xuICAgIH1cbiAgfVxuICBmdW5j
dGlvbiBzY2FuRXhwckNhbGxzKG5vZGUpIHtcbiAgICBpZiAoIW5vZGUgfHwgdHlwZW9mIG5vZGUg
IT09ICdvYmplY3QnKSByZXR1cm47XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gJ0Z1bmNDYWxsJykg
dXNlZENhbGxzLmFkZChub2RlLm5hbWUpO1xuICAgIC8vICoqIG9wZXJhdG9yIG1heSBuZWVkIHBv
dyBpbXBvcnQgKGZvciBub24tc3FydCwgbm9uLXNtYWxsLWludCBleHBvbmVudHMpXG4gICAgaWYg
KG5vZGUudHlwZSA9PT0gJ0Jpbk9wJyAmJiBub2RlLm9wID09PSAnKionKSB1c2VkQ2FsbHMuYWRk
KCdwb3cnKTtcbiAgICBmb3IgKGNvbnN0IGsgb2YgT2JqZWN0LmtleXMobm9kZSkpIHtcbiAgICAg
IGNvbnN0IHYgPSBub2RlW2tdO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodikpIHYuZm9yRWFj
aChzY2FuRXhwckNhbGxzKTtcbiAgICAgIGVsc2UgaWYgKHYgJiYgdHlwZW9mIHYgPT09ICdvYmpl
Y3QnICYmIHYudHlwZSkgc2NhbkV4cHJDYWxscyh2KTtcbiAgICB9XG4gIH1cbiAgZm9yIChjb25z
dCBmbiBvZiBmdW5jdGlvbnMpIHNjYW5DYWxscyhmbi5ib2R5KTtcblxuICAvLyBBdXRvLWltcG9y
dCBtYXRoIGJ1aWx0aW5zIHRoYXQgYXJlIGFjdHVhbGx5IHVzZWRcbiAgY29uc3QgbWF0aEltcG9y
dHMgPSBbXTtcbiAgZm9yIChjb25zdCBuYW1lIG9mIHVzZWRDYWxscykge1xuICAgIGlmIChNQVRI
X0JVSUxUSU5TW25hbWVdICE9PSB1bmRlZmluZWQgJiYgIWxvY2FsRnVuY05hbWVzLmhhcyhuYW1l
KSAmJiAhaW1wb3J0cy5maW5kKGltID0+IGltLm5hbWUgPT09IG5hbWUpKSB7XG4gICAgICBjb25z
dCBuUGFyYW1zID0gTUFUSF9CVUlMVElOU1tuYW1lXTtcbiAgICAgIGNvbnN0IHBhcmFtcyA9IFtd
O1xuICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBuUGFyYW1zOyBrKyspIHBhcmFtcy5wdXNoKHsg
dHlwZTogJ1BhcmFtJywgbmFtZTogJ3gnICsgaywgdnR5cGU6ICdmNjQnLCBpc0FycmF5OiBmYWxz
ZSwgYXJyYXlEaW1zOiBudWxsIH0pO1xuICAgICAgbWF0aEltcG9ydHMucHVzaCh7IG5hbWUsIG1v
ZHVsZU5hbWU6ICdtYXRoJywgcGFyYW1zLCByZXRUeXBlOiAnZjY0JywgaW50ZXJwSWR4OiBudWxs
IH0pO1xuICAgIH1cbiAgfVxuXG4gIC8vIEF1dG8taW1wb3J0OiBzY2FuIEFTVCBmb3IgdW5yZXNv
bHZlZCBjYWxscywgY2hlY2sgdXNlckltcG9ydHMgdGhlbiBnbG9iYWxUaGlzLlxuICAvLyBQYXJh
bSB0eXBlcyBkZWZhdWx0IHRvIGY2NCDigJQgaW5mZXJyZWQgZnJvbSB0aGUgSlMgZnVuY3Rpb24n
cyAubGVuZ3RoLlxuICBjb25zdCBmbGF0SW1wb3J0cyA9IHVzZXJJbXBvcnRzID8gZmxhdHRlbklt
cG9ydHModXNlckltcG9ydHMpIDoge307XG4gIGNvbnN0IGhvc3RJbXBvcnRzID0gW107XG4gIGZv
ciAoY29uc3QgbmFtZSBvZiB1c2VkQ2FsbHMpIHtcbiAgICBpZiAobG9jYWxGdW5jTmFtZXMuaGFz
KG5hbWUpIHx8IE5BVElWRV9CVUlMVElOUy5oYXMobmFtZSkgfHwgbmFtZS5zdGFydHNXaXRoKCd3
YXNtLicpIHx8XG4gICAgICAgIG5hbWUuc3RhcnRzV2l0aCgndjEyOC4nKSB8fCBBVFJBX1ZFQ1RP
Ul9UWVBFUy5oYXMobmFtZS5zcGxpdCgnLicpWzBdKSB8fFxuICAgICAgICBNQVRIX0JVSUxUSU5T
W25hbWVdICE9PSB1bmRlZmluZWQgfHwgaW1wb3J0cy5maW5kKGltID0+IGltLm5hbWUgPT09IG5h
bWUpKSBjb250aW51ZTtcbiAgICAvLyBjaGVjayBmbGF0dGVuZWQgdXNlckltcG9ydHMgdGhlbiBn
bG9iYWxUaGlzXG4gICAgbGV0IGZuID0gZmxhdEltcG9ydHNbbmFtZV07XG4gICAgaWYgKCFmbiAm
JiB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcpIGZuID0gZ2xvYmFsVGhpc1tuYW1l
XTtcbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb25zdCBuUGFy
YW1zID0gZm4ubGVuZ3RoO1xuICAgICAgY29uc3QgcGFyYW1zID0gW107XG4gICAgICBmb3IgKGxl
dCBrID0gMDsgayA8IG5QYXJhbXM7IGsrKykgcGFyYW1zLnB1c2goeyB0eXBlOiAnUGFyYW0nLCBu
YW1lOiAneCcgKyBrLCB2dHlwZTogJ2Y2NCcsIGlzQXJyYXk6IGZhbHNlLCBhcnJheURpbXM6IG51
bGwgfSk7XG4gICAgICBob3N0SW1wb3J0cy5wdXNoKHsgbmFtZSwgbW9kdWxlTmFtZTogJ2hvc3Qn
LCBwYXJhbXMsIHJldFR5cGU6ICdmNjQnLCBpbnRlcnBJZHg6IG51bGwsIGpzRm46IGZuIH0pO1xu
ICAgIH1cbiAgfVxuXG4gIGNvbnN0IGFsbEltcG9ydHMgPSBbLi4ubWF0aEltcG9ydHMsIC4uLmlt
cG9ydHMsIC4uLmhvc3RJbXBvcnRzXTtcblxuICAvLyBCdWlsZCBmdW5jdGlvbiBpbmRleCB0YWJs
ZTogaW1wb3J0cyBmaXJzdCwgdGhlbiBsb2NhbCBmdW5jdGlvbnNcbiAgY29uc3QgZnVuY0luZGV4
ID0ge307XG4gIGxldCBpZHggPSAwO1xuICBmb3IgKGNvbnN0IGltIG9mIGFsbEltcG9ydHMpIHsg
ZnVuY0luZGV4W2ltLm5hbWVdID0gaWR4Kys7IH1cbiAgZm9yIChjb25zdCBmbiBvZiBmdW5jdGlv
bnMpIHsgZnVuY0luZGV4W2ZuLm5hbWVdID0gaWR4Kys7IH1cblxuICAvLyBHbG9iYWwgaW5kZXgg
dGFibGUgKCsgdHJhY2sgZnVuY1NpZyBmb3IgZnVuY3Rpb24tdHlwZWQgZ2xvYmFscylcbiAgY29u
c3QgZ2xvYmFsSW5kZXggPSB7fTtcbiAgY29uc3QgZ2xvYmFsRnVuY1NpZyA9IHt9OyAvLyBuYW1l
IOKGkiBmdW5jU2lnIGZvciBmdW5jdGlvbi10eXBlZCBnbG9iYWxzXG4gIGZvciAobGV0IGdpID0g
MDsgZ2kgPCBnbG9iYWxzLmxlbmd0aDsgZ2krKykge1xuICAgIGdsb2JhbEluZGV4W2dsb2JhbHNb
Z2ldLm5hbWVdID0gZ2k7XG4gICAgaWYgKGdsb2JhbHNbZ2ldLmZ1bmNTaWcpIGdsb2JhbEZ1bmNT
aWdbZ2xvYmFsc1tnaV0ubmFtZV0gPSBnbG9iYWxzW2dpXS5mdW5jU2lnO1xuICB9XG5cbiAgLy8g
4pSA4pSAIFNjYW4gZm9yIGZ1bmN0aW9uIHJlZmVyZW5jZXMgKGJhcmUgZnVuY3Rpb24gbmFtZXMg
dXNlZCBhcyB2YWx1ZXMpIOKUgOKUgFxuICBjb25zdCByZWZlcmVuY2VkRnVuY3MgPSBuZXcgU2V0
KCk7XG4gIGZ1bmN0aW9uIHNjYW5GdW5jUmVmcyhzdG10cywgbG9jYWxOYW1lcykge1xuICAgIGZv
ciAoY29uc3QgcyBvZiBzdG10cykgc2Nhbk5vZGVSZWZzKHMsIGxvY2FsTmFtZXMpO1xuICB9XG4g
IGZ1bmN0aW9uIHNjYW5Ob2RlUmVmcyhub2RlLCBsb2NhbE5hbWVzKSB7XG4gICAgaWYgKCFub2Rl
IHx8IHR5cGVvZiBub2RlICE9PSAnb2JqZWN0JykgcmV0dXJuO1xuICAgIGlmIChub2RlLnR5cGUg
PT09ICdGdW5jUmVmJyAmJiBmdW5jSW5kZXhbbm9kZS5uYW1lXSAhPT0gdW5kZWZpbmVkKSB7XG4g
ICAgICByZWZlcmVuY2VkRnVuY3MuYWRkKG5vZGUubmFtZSk7XG4gICAgfVxuICAgIGZvciAoY29u
c3QgayBvZiBPYmplY3Qua2V5cyhub2RlKSkge1xuICAgICAgY29uc3QgdiA9IG5vZGVba107XG4g
ICAgICBpZiAoQXJyYXkuaXNBcnJheSh2KSkgdi5mb3JFYWNoKGMgPT4gc2Nhbk5vZGVSZWZzKGMs
IGxvY2FsTmFtZXMpKTtcbiAgICAgIGVsc2UgaWYgKHYgJiYgdHlwZW9mIHYgPT09ICdvYmplY3Qn
ICYmIHYudHlwZSkgc2Nhbk5vZGVSZWZzKHYsIGxvY2FsTmFtZXMpO1xuICAgIH1cbiAgfVxuICBm
b3IgKGNvbnN0IGZuIG9mIGZ1bmN0aW9ucykge1xuICAgIGNvbnN0IGxvY2FsTmFtZXMgPSBuZXcg
U2V0KCk7XG4gICAgZm9yIChjb25zdCBwIG9mIGZuLnBhcmFtcykgbG9jYWxOYW1lcy5hZGQocC5u
YW1lKTtcbiAgICBmb3IgKGNvbnN0IGwgb2YgZm4ubG9jYWxzKSBsb2NhbE5hbWVzLmFkZChsLm5h
bWUpO1xuICAgIGlmIChmbi50eXBlID09PSAnRnVuY3Rpb24nKSBsb2NhbE5hbWVzLmFkZChmbi5u
YW1lKTsgLy8gcmV0dXJuIHZhclxuICAgIHNjYW5GdW5jUmVmcyhmbi5ib2R5LCBsb2NhbE5hbWVz
KTtcbiAgfVxuXG4gIC8vIERldGVjdCBpZiBjYWxsX2luZGlyZWN0IGlzIG5lZWRlZCAoZnVuY3Rp
b24tdHlwZWQgcGFyYW1zL2xvY2Fscy9nbG9iYWxzIGV4aXN0KVxuICBsZXQgaGFzSW5kaXJlY3RD
YWxscyA9IE9iamVjdC5rZXlzKGdsb2JhbEZ1bmNTaWcpLmxlbmd0aCA+IDA7XG4gIGlmICghaGFz
SW5kaXJlY3RDYWxscykge1xuICAgIGZvciAoY29uc3QgZm4gb2YgZnVuY3Rpb25zKSB7XG4gICAg
ICBpZiAoZm4ucGFyYW1zLnNvbWUocCA9PiBwLmZ1bmNTaWcpIHx8IGZuLmxvY2Fscy5zb21lKGwg
PT4gbC5mdW5jU2lnKSkgeyBoYXNJbmRpcmVjdENhbGxzID0gdHJ1ZTsgYnJlYWs7IH1cbiAgICB9
XG4gIH1cblxuICAvLyBCdWlsZCB0YWJsZTogZXhwbGljaXRseSByZWZlcmVuY2VkIGZ1bmNzIGFs
d2F5czsgaWYgY2FsbF9pbmRpcmVjdCB1c2VkLCBhbHNvIGV4cGxpY2l0IGltcG9ydHMgKyBsb2Nh
bCBmdW5jdGlvbnMuXG4gIC8vIEF1dG8taW1wb3J0cyBvbmx5IGVudGVyIHRoZSB0YWJsZSBpZiBl
eHBsaWNpdGx5IHJlZmVyZW5jZWQgYnkgYmFyZSBuYW1lLlxuICBjb25zdCBhdXRvSW1wb3J0TmFt
ZXMgPSBuZXcgU2V0KFsuLi5tYXRoSW1wb3J0cy5tYXAobSA9PiBtLm5hbWUpLCAuLi5ob3N0SW1w
b3J0cy5tYXAobSA9PiBtLm5hbWUpXSk7XG4gIGxldCB0YWJsZUZ1bmNTZXQ7XG4gIGlmIChoYXNJ
bmRpcmVjdENhbGxzKSB7XG4gICAgdGFibGVGdW5jU2V0ID0gbmV3IFNldChbXG4gICAgICAuLi5p
bXBvcnRzLm1hcChpbSA9PiBpbS5uYW1lKSxcbiAgICAgIC4uLmZ1bmN0aW9ucy5tYXAoZm4gPT4g
Zm4ubmFtZSksXG4gICAgICAuLi5yZWZlcmVuY2VkRnVuY3MsXG4gICAgXSk7XG4gICAgLy8gRXhj
bHVkZSBhdXRvLWltcG9ydHMgdGhhdCBhcmVuJ3QgZXhwbGljaXRseSByZWZlcmVuY2VkIGJ5IGJh
cmUgbmFtZVxuICAgIGZvciAoY29uc3QgbmFtZSBvZiBhdXRvSW1wb3J0TmFtZXMpIHtcbiAgICAg
IGlmICghcmVmZXJlbmNlZEZ1bmNzLmhhcyhuYW1lKSkgdGFibGVGdW5jU2V0LmRlbGV0ZShuYW1l
KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGFibGVGdW5jU2V0ID0gbmV3IFNldChyZWZlcmVu
Y2VkRnVuY3MpO1xuICB9XG4gIGNvbnN0IHRhYmxlRnVuY3MgPSBbLi4udGFibGVGdW5jU2V0XS5z
b3J0KChhLCBiKSA9PiBmdW5jSW5kZXhbYV0gLSBmdW5jSW5kZXhbYl0pO1xuICBjb25zdCB0YWJs
ZVNsb3QgPSB7fTsgLy8gZnVuY05hbWUg4oaSIHRhYmxlIGluZGV4XG4gIGZvciAobGV0IHRpID0g
MDsgdGkgPCB0YWJsZUZ1bmNzLmxlbmd0aDsgdGkrKykgdGFibGVTbG90W3RhYmxlRnVuY3NbdGld
XSA9IHRpO1xuXG4gIC8vIOKUgOKUgCBCdWlsZCB0eXBlIHNpZ25hdHVyZXMg4pSA4pSAIGV2ZXJ5
IHVuaXF1ZSBmdW5jdGlvbiBzaWduYXR1cmUsIGRlZHVwZWQgYnkgc2lnS2V5XG4gIGZ1bmN0aW9u
IHBhcmFtV2FzbVR5cGUocCkgeyByZXR1cm4gcC5pc0FycmF5ID8gJ2kzMicgOiBwLnZ0eXBlOyB9
XG4gIGZ1bmN0aW9uIHNpZ0tleShwYXJhbXMsIHJldFR5cGUpIHtcbiAgICByZXR1cm4gcGFyYW1z
Lm1hcChwID0+IHBhcmFtV2FzbVR5cGUocCkpLmpvaW4oJywnKSArICc6JyArIChyZXRUeXBlIHx8
ICcnKTtcbiAgfVxuICBjb25zdCBzaWdNYXAgPSBuZXcgTWFwKCk7XG4gIGNvbnN0IHNpZ0xpc3Qg
PSBbXTsgLy8gW3twYXJhbXMsIHJldFR5cGV9XVxuICBmdW5jdGlvbiBnZXRPckFkZFNpZyhwYXJh
bXMsIHJldFR5cGUpIHtcbiAgICBjb25zdCBrZXkgPSBzaWdLZXkocGFyYW1zLCByZXRUeXBlKTtc
biAgICBpZiAoc2lnTWFwLmhhcyhrZXkpKSByZXR1cm4gc2lnTWFwLmdldChrZXkpO1xuICAgIGNv
bnN0IGlkID0gc2lnTGlzdC5sZW5ndGg7XG4gICAgc2lnTGlzdC5wdXNoKHsgcGFyYW1zLCByZXRU
eXBlIH0pO1xuICAgIHNpZ01hcC5zZXQoa2V5LCBpZCk7XG4gICAgcmV0dXJuIGlkO1xuICB9XG5c
biAgLy8gUmVnaXN0ZXIgYWxsIHNpZ25hdHVyZXNcbiAgY29uc3QgaW1wb3J0U2lnSWRzID0gYWxs
SW1wb3J0cy5tYXAoaW0gPT4gZ2V0T3JBZGRTaWcoaW0ucGFyYW1zLCBpbS5yZXRUeXBlKSk7XG4g
IGNvbnN0IGZ1bmNTaWdJZHMgPSBmdW5jdGlvbnMubWFwKGZuID0+IHtcbiAgICBjb25zdCByZXRU
eXBlID0gZm4udHlwZSA9PT0gJ1N1YnJvdXRpbmUnID8gbnVsbCA6IGZuLnJldFR5cGU7XG4gICAg
cmV0dXJuIGdldE9yQWRkU2lnKGZuLnBhcmFtcywgcmV0VHlwZSk7XG4gIH0pO1xuXG4gIC8vIOKU
gOKUgCBEZXRlcm1pbmUgbWVtb3J5IOKUgOKUgFxuICBjb25zdCBoYXNNZW1vcnkgPSBmdW5jdGlv
bnMuc29tZShmbiA9PiBmbi5wYXJhbXMuc29tZShwID0+IHAuaXNBcnJheSkpO1xuICBjb25zdCBp
bXBvcnRNZW1vcnkgPSB1c2VySW1wb3J0cyAmJiB1c2VySW1wb3J0cy5fX21lbW9yeTtcblxuICAv
LyDilIDilIAgRW1pdCBXYXNtIGJpbmFyeSDilIDilIBcbiAgLy8gTWFnaWMgKyB2ZXJzaW9uXG4g
IHcuYnl0ZXMoWzB4MDAsIDB4NjEsIDB4NzMsIDB4NmRdKTsgLy8gXFwwYXNtXG4gIHcuYnl0ZXMo
WzB4MDEsIDB4MDAsIDB4MDAsIDB4MDBdKTsgLy8gdmVyc2lvbiAxXG5cbiAgLy8gVHlwZSBzZWN0
aW9uICgxKSDigJQgZXZlcnkgdW5pcXVlIChwYXJhbXMg4oaSIHJldFR5cGUpIHNpZ25hdHVyZVxu
ICB3LnNlY3Rpb24oMSwgcyA9PiB7XG4gICAgcy51MzIoc2lnTGlzdC5sZW5ndGgpO1xuICAgIGZv
ciAoY29uc3Qgc2lnIG9mIHNpZ0xpc3QpIHtcbiAgICAgIHMuYnl0ZSgweDYwKTsgLy8gZnVuYyB0
eXBlXG4gICAgICBzLnUzMihzaWcucGFyYW1zLmxlbmd0aCk7XG4gICAgICBmb3IgKGNvbnN0IHAg
b2Ygc2lnLnBhcmFtcykgcy5ieXRlKHdhc21UeXBlKHBhcmFtV2FzbVR5cGUocCkpKTtcbiAgICAg
IGlmIChzaWcucmV0VHlwZSkgeyBzLnUzMigxKTsgcy5ieXRlKHdhc21UeXBlKHNpZy5yZXRUeXBl
KSk7IH1cbiAgICAgIGVsc2Ugcy51MzIoMCk7XG4gICAgfVxuICB9KTtcblxuICAvLyBJbXBvcnQg
c2VjdGlvbiAoMikg4oCUIG1hdGggYnVpbHRpbnMgKGF1dG8tZGV0ZWN0ZWQpLCBleHBsaWNpdCBp
bXBvcnRzLCBob3N0IGZ1bmN0aW9uc1xuICBpZiAoYWxsSW1wb3J0cy5sZW5ndGggPiAwIHx8IGlt
cG9ydE1lbW9yeSkge1xuICAgIHcuc2VjdGlvbigyLCBzID0+IHtcbiAgICAgIHMudTMyKGFsbElt
cG9ydHMubGVuZ3RoICsgKGltcG9ydE1lbW9yeSA/IDEgOiAwKSk7XG4gICAgICBmb3IgKGxldCBp
aSA9IDA7IGlpIDwgYWxsSW1wb3J0cy5sZW5ndGg7IGlpKyspIHtcbiAgICAgICAgY29uc3QgaW0g
PSBhbGxJbXBvcnRzW2lpXTtcbiAgICAgICAgcy5zdHIoaW0ubW9kdWxlTmFtZSk7XG4gICAgICAg
IHMuc3RyKGltLm5hbWUpO1xuICAgICAgICBzLmJ5dGUoMHgwMCk7IC8vIGZ1bmMgaW1wb3J0XG4g
ICAgICAgIHMudTMyKGltcG9ydFNpZ0lkc1tpaV0pO1xuICAgICAgfVxuICAgICAgaWYgKGltcG9y
dE1lbW9yeSkge1xuICAgICAgICBzLnN0cignZW52Jyk7XG4gICAgICAgIHMuc3RyKCdtZW1vcnkn
KTtcbiAgICAgICAgcy5ieXRlKDB4MDIpOyAvLyBtZW1vcnkgaW1wb3J0XG4gICAgICAgIHMuYnl0
ZSgweDAwKTsgLy8gbm8gbWF4XG4gICAgICAgIHMudTMyKDEpOyAvLyBpbml0aWFsIDEgcGFnZVxu
ICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLy8gRnVuY3Rpb24gc2VjdGlvbiAoMylcbiAgdy5z
ZWN0aW9uKDMsIHMgPT4ge1xuICAgIHMudTMyKGZ1bmN0aW9ucy5sZW5ndGgpO1xuICAgIGZvciAo
Y29uc3Qgc2lnSWQgb2YgZnVuY1NpZ0lkcykgcy51MzIoc2lnSWQpO1xuICB9KTtcblxuICAvLyBU
YWJsZSBzZWN0aW9uICg0KSDigJQgZnVuY3JlZiB0YWJsZSBmb3IgY2FsbF9pbmRpcmVjdCAoZnVu
Y3Rpb24gcG9pbnRlcnMpXG4gIGlmICh0YWJsZUZ1bmNzLmxlbmd0aCA+IDApIHtcbiAgICB3LnNl
Y3Rpb24oNCwgcyA9PiB7XG4gICAgICBzLnUzMigxKTsgLy8gb25lIHRhYmxlXG4gICAgICBzLmJ5
dGUoMHg3MCk7IC8vIGZ1bmNyZWZcbiAgICAgIHMuYnl0ZSgweDAwKTsgLy8gbm8gbWF4XG4gICAg
ICBzLnUzMih0YWJsZUZ1bmNzLmxlbmd0aCk7IC8vIGluaXRpYWwgc2l6ZSA9IG51bWJlciBvZiBy
ZWZlcmVuY2VkIGZ1bmN0aW9uc1xuICAgIH0pO1xuICB9XG5cbiAgLy8gTWVtb3J5IHNlY3Rpb24g
KDUpIOKAlCBvbmx5IGlmIGFycmF5cyB1c2VkIGFuZCBubyBpbXBvcnRlZCBtZW1vcnlcbiAgaWYg
KGhhc01lbW9yeSAmJiAhaW1wb3J0TWVtb3J5KSB7XG4gICAgdy5zZWN0aW9uKDUsIHMgPT4ge1xu
ICAgICAgcy51MzIoMSk7XG4gICAgICBzLmJ5dGUoMHgwMCk7IC8vIG5vIG1heFxuICAgICAgcy51
MzIoMSk7IC8vIGluaXRpYWw6IDEgcGFnZSAoNjRLQilcbiAgICB9KTtcbiAgfVxuXG4gIC8vIEds
b2JhbCBzZWN0aW9uICg2KVxuICBpZiAoZ2xvYmFscy5sZW5ndGggPiAwKSB7XG4gICAgdy5zZWN0
aW9uKDYsIHMgPT4ge1xuICAgICAgcy51MzIoZ2xvYmFscy5sZW5ndGgpO1xuICAgICAgZm9yIChj
b25zdCBnIG9mIGdsb2JhbHMpIHtcbiAgICAgICAgcy5ieXRlKHdhc21UeXBlKGcudnR5cGUpKTtc
biAgICAgICAgcy5ieXRlKGcubXV0YWJsZSA/IDB4MDEgOiAweDAwKTtcbiAgICAgICAgLy8gaW5p
dCBleHByZXNzaW9uXG4gICAgICAgIGVtaXRDb25zdEV4cHIocywgZy5pbml0LCBnLnZ0eXBlKTtc
biAgICAgICAgcy5ieXRlKE9QX0VORCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvLyBF
eHBvcnQgc2VjdGlvbiAoNylcbiAgdy5zZWN0aW9uKDcsIHMgPT4ge1xuICAgIGNvbnN0IGV4cG9y
dHMgPSBmdW5jdGlvbnMubWFwKChmbiwgaSkgPT4gKHsgbmFtZTogZm4ubmFtZSwgaWR4OiBhbGxJ
bXBvcnRzLmxlbmd0aCArIGkgfSkpO1xuICAgIGNvbnN0IG1lbUV4cG9ydCA9IChoYXNNZW1vcnkg
JiYgIWltcG9ydE1lbW9yeSkgPyAxIDogMDtcbiAgICBzLnUzMihleHBvcnRzLmxlbmd0aCArIG1l
bUV4cG9ydCk7XG4gICAgZm9yIChjb25zdCBlIG9mIGV4cG9ydHMpIHtcbiAgICAgIHMuc3RyKGUu
bmFtZSk7XG4gICAgICBzLmJ5dGUoMHgwMCk7IC8vIGZ1bmMgZXhwb3J0XG4gICAgICBzLnUzMihl
LmlkeCk7XG4gICAgfVxuICAgIGlmIChtZW1FeHBvcnQpIHtcbiAgICAgIHMuc3RyKCdtZW1vcnkn
KTtcbiAgICAgIHMuYnl0ZSgweDAyKTsgLy8gbWVtb3J5IGV4cG9ydFxuICAgICAgcy51MzIoMCk7
XG4gICAgfVxuICB9KTtcblxuICAvLyBFbGVtZW50IHNlY3Rpb24gKDkpIOKAlCBwb3B1bGF0ZSB0
YWJsZSB3aXRoIGZ1bmN0aW9uIHJlZmVyZW5jZXMgYXQgb2Zmc2V0IDBcbiAgaWYgKHRhYmxlRnVu
Y3MubGVuZ3RoID4gMCkge1xuICAgIHcuc2VjdGlvbig5LCBzID0+IHtcbiAgICAgIHMudTMyKDEp
OyAvLyBvbmUgZWxlbWVudCBzZWdtZW50XG4gICAgICBzLnUzMigwKTsgLy8gdGFibGUgaW5kZXgg
MFxuICAgICAgLy8gb2Zmc2V0IGV4cHJlc3Npb246IGkzMi5jb25zdCAwXG4gICAgICBzLmJ5dGUo
T1BfSTMyX0NPTlNUKTsgcy5zMzIoMCk7IHMuYnl0ZShPUF9FTkQpO1xuICAgICAgcy51MzIodGFi
bGVGdW5jcy5sZW5ndGgpO1xuICAgICAgZm9yIChjb25zdCBmbmFtZSBvZiB0YWJsZUZ1bmNzKSBz
LnUzMihmdW5jSW5kZXhbZm5hbWVdKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIENvZGUgc2VjdGlv
biAoMTApIOKAlCBvbmUgYm9keSBwZXIgbG9jYWwgZnVuY3Rpb24sIGVhY2ggd2l0aCBjb21wcmVz
c2VkIGxvY2FscyArIGJ5dGVjb2RlXG4gIHcuc2VjdGlvbigxMCwgcyA9PiB7XG4gICAgcy51MzIo
ZnVuY3Rpb25zLmxlbmd0aCk7XG4gICAgZm9yIChjb25zdCBmbiBvZiBmdW5jdGlvbnMpIHtcbiAg
ICAgIGNvbnN0IGJvZHlXcml0ZXIgPSBuZXcgQnl0ZVdyaXRlcigpO1xuICAgICAgZW1pdEZ1bmN0
aW9uQm9keShib2R5V3JpdGVyLCBmbik7XG4gICAgICBzLnUzMihib2R5V3JpdGVyLmJ1Zi5sZW5n
dGgpO1xuICAgICAgcy5ieXRlcyhib2R5V3JpdGVyLmJ1Zik7XG4gICAgfVxuICB9KTtcblxuICBj
b25zdCBieXRlcyA9IHcudG9VaW50OEFycmF5KCk7XG4gIGNvbnN0IHRhYmxlID0gdGFibGVGdW5j
cy5sZW5ndGggPiAwID8geyAuLi50YWJsZVNsb3QgfSA6IG51bGw7XG4gIHJldHVybiB7IGJ5dGVz
LCB0YWJsZSB9O1xuXG4gIC8vIOKUgOKUgCBIZWxwZXI6IGVtaXQgY29uc3RhbnQgaW5pdCBleHBy
ZXNzaW9uIOKUgOKUgFxuICBmdW5jdGlvbiBlbWl0Q29uc3RFeHByKHMsIG5vZGUsIHZ0eXBlKSB7
XG4gICAgaWYgKCFub2RlKSB7XG4gICAgICAvLyBkZWZhdWx0IHplcm9cbiAgICAgIGlmICh2dHlw
ZSA9PT0gJ2kzMicpIHsgcy5ieXRlKE9QX0kzMl9DT05TVCk7IHMuczMyKDApOyB9XG4gICAgICBl
bHNlIGlmICh2dHlwZSA9PT0gJ2k2NCcpIHsgcy5ieXRlKE9QX0k2NF9DT05TVCk7IHMuczY0KDBu
KTsgfVxuICAgICAgZWxzZSBpZiAodnR5cGUgPT09ICdmMzInKSB7IHMuYnl0ZShPUF9GMzJfQ09O
U1QpOyBzLmYzMigwKTsgfVxuICAgICAgZWxzZSBpZiAodnR5cGUgPT09ICdmNjQnKSB7IHMuYnl0
ZShPUF9GNjRfQ09OU1QpOyBzLmY2NCgwKTsgfVxuICAgICAgZWxzZSBpZiAoaXNWZWN0b3IodnR5
cGUpKSB7XG4gICAgICAgIC8vIHYxMjguY29uc3Qgd2l0aCAxNiB6ZXJvIGJ5dGVzXG4gICAgICAg
IHMuYnl0ZShPUF9TSU1EX1BSRUZJWCk7IHMudTMyKFNJTURfT1BTWyd2MTI4LmNvbnN0J10pO1xu
ICAgICAgICBmb3IgKGxldCB2aSA9IDA7IHZpIDwgMTY7IHZpKyspIHMuYnl0ZSgwKTtcbiAgICAg
IH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gJ051bWJlckxp
dCcpIHtcbiAgICAgIGNvbnN0IHZhbCA9IHBhcnNlTnVtZXJpY1ZhbHVlKG5vZGUsIHZ0eXBlKTtc
biAgICAgIGVtaXRUeXBlZENvbnN0KHMsIHZ0eXBlLCB2YWwpO1xuICAgICAgcmV0dXJuO1xuICAg
IH1cbiAgICBpZiAobm9kZS50eXBlID09PSAnVW5hcnlPcCcgJiYgbm9kZS5vcCA9PT0gJy0nICYm
IG5vZGUub3BlcmFuZC50eXBlID09PSAnTnVtYmVyTGl0Jykge1xuICAgICAgY29uc3QgdmFsID0g
LXBhcnNlTnVtZXJpY1ZhbHVlKG5vZGUub3BlcmFuZCwgdnR5cGUpO1xuICAgICAgZW1pdFR5cGVk
Q29uc3QocywgdnR5cGUsIHZhbCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRocm93IG5l
dyBFcnJvcignR2xvYmFsIGluaXQgbXVzdCBiZSBhIGNvbnN0YW50IGV4cHJlc3Npb24nKTtcbiAg
fVxuXG4gIGZ1bmN0aW9uIHBhcnNlTnVtZXJpY1ZhbHVlKG5vZGUsIGRlZmF1bHRUeXBlKSB7XG4g
ICAgY29uc3QgcmF3ID0gbm9kZS52YWx1ZTtcbiAgICBpZiAocmF3LmluY2x1ZGVzKCcuJykgfHwg
cmF3LmluY2x1ZGVzKCdlJykgfHwgcmF3LmluY2x1ZGVzKCdFJykgfHwgbm9kZS5pc0Zsb2F0KSBy
ZXR1cm4gcGFyc2VGbG9hdChyYXcpO1xuICAgIHJldHVybiBwYXJzZUludChyYXcsIDEwKTtcbiAg
fVxuXG4gIGZ1bmN0aW9uIGVtaXRUeXBlZENvbnN0KHMsIHZ0eXBlLCB2YWwpIHtcbiAgICBpZiAo
dnR5cGUgPT09ICdpMzInKSB7IHMuYnl0ZShPUF9JMzJfQ09OU1QpOyBzLnMzMih2YWwgfCAwKTsg
fVxuICAgIGVsc2UgaWYgKHZ0eXBlID09PSAnaTY0JykgeyBzLmJ5dGUoT1BfSTY0X0NPTlNUKTsg
cy5zNjQoQmlnSW50KHZhbCkpOyB9XG4gICAgZWxzZSBpZiAodnR5cGUgPT09ICdmMzInKSB7IHMu
Ynl0ZShPUF9GMzJfQ09OU1QpOyBzLmYzMih2YWwpOyB9XG4gICAgZWxzZSBpZiAodnR5cGUgPT09
ICdmNjQnKSB7IHMuYnl0ZShPUF9GNjRfQ09OU1QpOyBzLmY2NCh2YWwpOyB9XG4gIH1cblxuICAv
LyDilIDilIAgRW1pdCBmdW5jdGlvbiBib2R5IOKUgOKUgFxuICBmdW5jdGlvbiBlbWl0RnVuY3Rp
b25Cb2R5KGJ3LCBmbikge1xuICAgIGNvbnN0IGlzRnVuYyA9IGZuLnR5cGUgPT09ICdGdW5jdGlv
bic7XG4gICAgY29uc3QgcmV0VHlwZSA9IGlzRnVuYyA/IGZuLnJldFR5cGUgOiBudWxsO1xuXG4g
ICAgLy8g4pSA4pSAIExvY2FsIGxheW91dCDilIDilIAgcGFyYW1zLCBkZWNsYXJlZCBsb2NhbHMs
IGhpZGRlbiByZXR1cm4gdmFyaWFibGVcbiAgICBjb25zdCBsb2NhbE1hcCA9IHt9OyAvLyBuYW1l
IOKGkiB7IGlkeCwgdnR5cGUgfVxuICAgIGxldCBsb2NhbElkeCA9IDA7XG4gICAgZm9yIChjb25z
dCBwIG9mIGZuLnBhcmFtcykge1xuICAgICAgY29uc3QgZW50cnkgPSB7XG4gICAgICAgIGlkeDog
bG9jYWxJZHgrKyxcbiAgICAgICAgdnR5cGU6IHAuaXNBcnJheSA/ICdpMzInIDogcC52dHlwZSwg
Ly8gV2FzbSBoYXMgbm8gYXJyYXkgdHlwZTsgYXJyYXlzIGFyZSBpMzIgbWVtb3J5IHBvaW50ZXJz
XG4gICAgICAgIGlzQXJyYXk6IHAuaXNBcnJheSxcbiAgICAgICAgYXJyYXlEaW1zOiBwLmFycmF5
RGltcyxcbiAgICAgICAgZWxlbVR5cGU6IHAuaXNBcnJheSA/IHAudnR5cGUgOiBudWxsICAvLyBl
bGVtZW50IHR5cGUgZm9yIGxvYWQvc3RvcmVcbiAgICAgIH07XG4gICAgICBpZiAocC5mdW5jU2ln
KSBlbnRyeS5mdW5jU2lnID0gcC5mdW5jU2lnO1xuICAgICAgbG9jYWxNYXBbcC5uYW1lXSA9IGVu
dHJ5O1xuICAgIH1cbiAgICBjb25zdCBkZWNsYXJlZExvY2FscyA9IFsuLi5mbi5sb2NhbHNdO1xu
ICAgIGlmIChpc0Z1bmMpIHtcbiAgICAgIC8vICRfcmV0dXJuOiBGb3J0cmFuIGNvbnZlbnRpb24g
4oCUIGFzc2lnbmluZyB0byB0aGUgZnVuY3Rpb24gbmFtZSBzZXRzIHRoZSByZXR1cm4gdmFsdWUu
XG4gICAgICAvLyBNYXBwZWQgdG8gYSBoaWRkZW4gbG9jYWw7IHRoZSBmdW5jdGlvbiBlcGlsb2d1
ZSByZWFkcyBpdCB3aXRoIGxvY2FsLmdldC5cbiAgICAgIGRlY2xhcmVkTG9jYWxzLnB1c2goeyBu
YW1lOiAnJF9yZXR1cm4nLCB2dHlwZTogcmV0VHlwZSB9KTtcbiAgICB9XG4gICAgZm9yIChjb25z
dCBsb2Mgb2YgZGVjbGFyZWRMb2NhbHMpIHtcbiAgICAgIGNvbnN0IGVudHJ5ID0geyBpZHg6IGxv
Y2FsSWR4KyssIHZ0eXBlOiBsb2MudnR5cGUgfTtcbiAgICAgIGlmIChsb2MuZnVuY1NpZykgZW50
cnkuZnVuY1NpZyA9IGxvYy5mdW5jU2lnO1xuICAgICAgbG9jYWxNYXBbbG9jLm5hbWVdID0gZW50
cnk7XG4gICAgfVxuXG4gICAgLy8gRW1pdCBsb2NhbCBkZWNsYXJhdGlvbnMgKG9ubHkgdGhlIG5v
bi1wYXJhbSBvbmVzKVxuICAgIGNvbnN0IGxvY2FsVHlwZXMgPSBkZWNsYXJlZExvY2Fscy5tYXAo
bCA9PiBsLnZ0eXBlKTtcbiAgICAvLyBDb21wcmVzczogcnVucyBvZiBzYW1lIHR5cGVcbiAgICBj
b25zdCBsb2NhbFJ1bnMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGx0IG9mIGxvY2FsVHlwZXMpIHtc
biAgICAgIGlmIChsb2NhbFJ1bnMubGVuZ3RoID4gMCAmJiBsb2NhbFJ1bnNbbG9jYWxSdW5zLmxl
bmd0aCAtIDFdLnR5cGUgPT09IGx0KSBsb2NhbFJ1bnNbbG9jYWxSdW5zLmxlbmd0aCAtIDFdLmNv
dW50Kys7XG4gICAgICBlbHNlIGxvY2FsUnVucy5wdXNoKHsgY291bnQ6IDEsIHR5cGU6IGx0IH0p
O1xuICAgIH1cbiAgICBidy51MzIobG9jYWxSdW5zLmxlbmd0aCk7XG4gICAgZm9yIChjb25zdCBy
dW4gb2YgbG9jYWxSdW5zKSB7XG4gICAgICBidy51MzIocnVuLmNvdW50KTtcbiAgICAgIGJ3LmJ5
dGUod2FzbVR5cGUocnVuLnR5cGUpKTtcbiAgICB9XG5cbiAgICAvLyBTSU1EIGhlbHBlclxuICAg
IGZ1bmN0aW9uIGVtaXRTaW1kKG9wKSB7IGJ3LmJ5dGUoT1BfU0lNRF9QUkVGSVgpOyBidy51MzIo
b3ApOyB9XG5cbiAgICAvLyDilIDilIAgU3RhdGVtZW50IGVtaXNzaW9uIOKUgOKUgFxuICAgIGxl
dCBkZXB0aCA9IDA7IC8vIGN1cnJlbnQgYmxvY2sgbmVzdGluZyBkZXB0aFxuICAgIGNvbnN0IGJy
ZWFrVGFyZ2V0cyA9IFtdOyAvLyBzdGFjayBvZiB7ZGVwdGh9IGZvciBlYWNoIGVuY2xvc2luZyBs
b29wJ3MgYnJlYWsgYmxvY2tcblxuICAgIGZ1bmN0aW9uIGVtaXRTdG10cyhzdG10cykgeyBmb3Ig
KGNvbnN0IHMgb2Ygc3RtdHMpIGVtaXRTdG10KHMpOyB9XG5cbiAgICBmdW5jdGlvbiBlbWl0U3Rt
dChzdG10KSB7XG4gICAgICBzd2l0Y2ggKHN0bXQudHlwZSkge1xuICAgICAgICBjYXNlICdBc3Np
Z24nOiB7XG4gICAgICAgICAgY29uc3QgdGFyZ2V0ID0gc3RtdC5uYW1lO1xuICAgICAgICAgIC8v
IEFzc2lnbm1lbnQgdG8gZnVuY3Rpb24gbmFtZSA9IHNldCByZXR1cm4gdmFyaWFibGVcbiAgICAg
ICAgICBpZiAoaXNGdW5jICYmIHRhcmdldCA9PT0gZm4ubmFtZSkge1xuICAgICAgICAgICAgZW1p
dEV4cHIoc3RtdC52YWx1ZSwgcmV0VHlwZSk7XG4gICAgICAgICAgICBidy5ieXRlKE9QX0xPQ0FM
X1NFVCk7XG4gICAgICAgICAgICBidy51MzIobG9jYWxNYXBbJyRfcmV0dXJuJ10uaWR4KTtcbiAg
ICAgICAgICB9IGVsc2UgaWYgKGxvY2FsTWFwW3RhcmdldF0pIHtcbiAgICAgICAgICAgIGVtaXRF
eHByKHN0bXQudmFsdWUsIGxvY2FsTWFwW3RhcmdldF0udnR5cGUpO1xuICAgICAgICAgICAgYncu
Ynl0ZShPUF9MT0NBTF9TRVQpO1xuICAgICAgICAgICAgYncudTMyKGxvY2FsTWFwW3RhcmdldF0u
aWR4KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGdsb2JhbEluZGV4W3RhcmdldF0gIT09IHVuZGVm
aW5lZCkge1xuICAgICAgICAgICAgZW1pdEV4cHIoc3RtdC52YWx1ZSwgZ2xvYmFsc1tnbG9iYWxJ
bmRleFt0YXJnZXRdXS52dHlwZSk7XG4gICAgICAgICAgICBidy5ieXRlKE9QX0dMT0JBTF9TRVQp
O1xuICAgICAgICAgICAgYncudTMyKGdsb2JhbEluZGV4W3RhcmdldF0pO1xuICAgICAgICAgIH0g
ZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZGVmaW5lZCB2YXJpYWJsZTog
JHt0YXJnZXR9YCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4g
ICAgICAgIGNhc2UgJ0FycmF5U3RvcmUnOiB7XG4gICAgICAgICAgY29uc3QgaW5mbyA9IGxvY2Fs
TWFwW3N0bXQubmFtZV07XG4gICAgICAgICAgaWYgKCFpbmZvKSB0aHJvdyBuZXcgRXJyb3IoYFVu
ZGVmaW5lZCBhcnJheTogJHtzdG10Lm5hbWV9YCk7XG4gICAgICAgICAgY29uc3QgZWxlbVR5cGUg
PSBpbmZvLmVsZW1UeXBlIHx8IGluZm8udnR5cGU7XG4gICAgICAgICAgLy8gY29tcHV0ZSBhZGRy
ZXNzXG4gICAgICAgICAgZW1pdEFycmF5QWRkcihzdG10Lm5hbWUsIHN0bXQuaW5kaWNlcywgaW5m
bywgZWxlbVR5cGUpO1xuICAgICAgICAgIC8vIGNvbXB1dGUgdmFsdWVcbiAgICAgICAgICBlbWl0
RXhwcihzdG10LnZhbHVlLCBlbGVtVHlwZSk7XG4gICAgICAgICAgLy8gc3RvcmVcbiAgICAgICAg
ICBlbWl0U3RvcmUoZWxlbVR5cGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAg
ICAgIGNhc2UgJ0lmJzoge1xuICAgICAgICAgIGVtaXRFeHByKHN0bXQuY29uZCwgJ2kzMicpO1xu
ICAgICAgICAgIGJ3LmJ5dGUoT1BfSUYpO1xuICAgICAgICAgIGJ3LmJ5dGUoV0FTTV9WT0lEKTtc
biAgICAgICAgICBkZXB0aCsrO1xuICAgICAgICAgIGVtaXRTdG10cyhzdG10LmJvZHkpO1xuICAg
ICAgICAgIGlmIChzdG10LmVsc2VCb2R5KSB7XG4gICAgICAgICAgICBidy5ieXRlKE9QX0VMU0Up
O1xuICAgICAgICAgICAgZW1pdFN0bXRzKHN0bXQuZWxzZUJvZHkpO1xuICAgICAgICAgIH1cbiAg
ICAgICAgICBkZXB0aC0tO1xuICAgICAgICAgIGJ3LmJ5dGUoT1BfRU5EKTtcbiAgICAgICAgICBi
cmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdGb3InOiB7XG4gICAgICAgICAgY29uc3Qg
dkluZm8gPSBsb2NhbE1hcFtzdG10LnZhck5hbWVdO1xuICAgICAgICAgIGlmICghdkluZm8pIHRo
cm93IG5ldyBFcnJvcihgVW5kZWZpbmVkIGxvb3AgdmFyaWFibGU6ICR7c3RtdC52YXJOYW1lfWAp
O1xuICAgICAgICAgIGNvbnN0IHZ0ID0gdkluZm8udnR5cGU7XG4gICAgICAgICAgZW1pdEV4cHIo
c3RtdC5zdGFydCwgdnQpO1xuICAgICAgICAgIGJ3LmJ5dGUoT1BfTE9DQUxfU0VUKTtcbiAgICAg
ICAgICBidy51MzIodkluZm8uaWR4KTtcblxuICAgICAgICAgIGNvbnN0IGhhc1N0ZXAgPSBzdG10
LnN0ZXAgIT09IG51bGw7XG5cbiAgICAgICAgICBidy5ieXRlKE9QX0JMT0NLKTsgYncuYnl0ZShX
QVNNX1ZPSUQpOyBkZXB0aCsrO1xuICAgICAgICAgIGNvbnN0IGJyZWFrRGVwdGggPSBkZXB0aDsg
Ly8gYnJlYWsgdGFyZ2V0ID0gdGhpcyBibG9ja1xuICAgICAgICAgIGJ3LmJ5dGUoT1BfTE9PUCk7
IGJ3LmJ5dGUoV0FTTV9WT0lEKTsgZGVwdGgrKztcbiAgICAgICAgICBicmVha1RhcmdldHMucHVz
aChicmVha0RlcHRoKTtcblxuICAgICAgICAgIC8vIGNvbmRpdGlvbiBjaGVjazogYnJfaWYgdG8g
YnJlYWsgYmxvY2tcbiAgICAgICAgICBidy5ieXRlKE9QX0xPQ0FMX0dFVCk7IGJ3LnUzMih2SW5m
by5pZHgpO1xuICAgICAgICAgIGVtaXRFeHByKHN0bXQuZW5kLCB2dCk7XG4gICAgICAgICAgaWYg
KCFoYXNTdGVwKSB7XG4gICAgICAgICAgICBlbWl0Q21wKCc+PScsIHZ0KTtcbiAgICAgICAgICB9
IGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qgc3RlcElzTmVnTGl0ID0gc3RtdC5zdGVwLnR5cGUg
PT09ICdVbmFyeU9wJyAmJiBzdG10LnN0ZXAub3AgPT09ICctJyAmJiBzdG10LnN0ZXAub3BlcmFu
ZC50eXBlID09PSAnTnVtYmVyTGl0JztcbiAgICAgICAgICAgIGNvbnN0IHN0ZXBJc05lZ0NvbnN0
ID0gc3RlcElzTmVnTGl0IHx8IChzdG10LnN0ZXAudHlwZSA9PT0gJ051bWJlckxpdCcgJiYgcGFy
c2VGbG9hdChzdG10LnN0ZXAudmFsdWUpIDwgMCk7XG4gICAgICAgICAgICBlbWl0Q21wKHN0ZXBJ
c05lZ0NvbnN0ID8gJzw9JyA6ICc+PScsIHZ0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYncu
Ynl0ZShPUF9CUl9JRik7IGJ3LnUzMihkZXB0aCAtIGJyZWFrRGVwdGgpO1xuXG4gICAgICAgICAg
ZW1pdFN0bXRzKHN0bXQuYm9keSk7XG5cbiAgICAgICAgICAvLyBpbmNyZW1lbnRcbiAgICAgICAg
ICBidy5ieXRlKE9QX0xPQ0FMX0dFVCk7IGJ3LnUzMih2SW5mby5pZHgpO1xuICAgICAgICAgIGlm
IChoYXNTdGVwKSB7IGVtaXRFeHByKHN0bXQuc3RlcCwgdnQpOyB9IGVsc2UgeyBlbWl0VHlwZWRD
b25zdChidywgdnQsIDEpOyB9XG4gICAgICAgICAgZW1pdEFkZCh2dCk7XG4gICAgICAgICAgYncu
Ynl0ZShPUF9MT0NBTF9TRVQpOyBidy51MzIodkluZm8uaWR4KTtcblxuICAgICAgICAgIGJ3LmJ5
dGUoT1BfQlIpOyBidy51MzIoMCk7IC8vIGNvbnRpbnVlIHRvIGxvb3BcbiAgICAgICAgICBkZXB0
aC0tOyBidy5ieXRlKE9QX0VORCk7IC8vIGVuZCBsb29wXG4gICAgICAgICAgYnJlYWtUYXJnZXRz
LnBvcCgpO1xuICAgICAgICAgIGRlcHRoLS07IGJ3LmJ5dGUoT1BfRU5EKTsgLy8gZW5kIGJsb2Nr
XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnV2hpbGUnOiB7XG4g
ICAgICAgICAgYncuYnl0ZShPUF9CTE9DSyk7IGJ3LmJ5dGUoV0FTTV9WT0lEKTsgZGVwdGgrKztc
biAgICAgICAgICBjb25zdCBicmVha0RlcHRoID0gZGVwdGg7XG4gICAgICAgICAgYncuYnl0ZShP
UF9MT09QKTsgYncuYnl0ZShXQVNNX1ZPSUQpOyBkZXB0aCsrO1xuICAgICAgICAgIGJyZWFrVGFy
Z2V0cy5wdXNoKGJyZWFrRGVwdGgpO1xuXG4gICAgICAgICAgZW1pdEV4cHIoc3RtdC5jb25kLCAn
aTMyJyk7XG4gICAgICAgICAgYncuYnl0ZShPUF9JMzJfRVFaKTtcbiAgICAgICAgICBidy5ieXRl
KE9QX0JSX0lGKTsgYncudTMyKGRlcHRoIC0gYnJlYWtEZXB0aCk7XG5cbiAgICAgICAgICBlbWl0
U3RtdHMoc3RtdC5ib2R5KTtcblxuICAgICAgICAgIGJ3LmJ5dGUoT1BfQlIpOyBidy51MzIoMCk7
IC8vIGNvbnRpbnVlIGxvb3BcbiAgICAgICAgICBkZXB0aC0tOyBidy5ieXRlKE9QX0VORCk7IC8v
IGVuZCBsb29wXG4gICAgICAgICAgYnJlYWtUYXJnZXRzLnBvcCgpO1xuICAgICAgICAgIGRlcHRo
LS07IGJ3LmJ5dGUoT1BfRU5EKTsgLy8gZW5kIGJsb2NrXG4gICAgICAgICAgYnJlYWs7XG4gICAg
ICAgIH1cbiAgICAgICAgY2FzZSAnRG9XaGlsZSc6IHtcbiAgICAgICAgICBidy5ieXRlKE9QX0JM
T0NLKTsgYncuYnl0ZShXQVNNX1ZPSUQpOyBkZXB0aCsrO1xuICAgICAgICAgIGNvbnN0IGJyZWFr
RGVwdGggPSBkZXB0aDtcbiAgICAgICAgICBidy5ieXRlKE9QX0xPT1ApOyBidy5ieXRlKFdBU01f
Vk9JRCk7IGRlcHRoKys7XG4gICAgICAgICAgYnJlYWtUYXJnZXRzLnB1c2goYnJlYWtEZXB0aCk7
XG5cbiAgICAgICAgICBlbWl0U3RtdHMoc3RtdC5ib2R5KTtcblxuICAgICAgICAgIGVtaXRFeHBy
KHN0bXQuY29uZCwgJ2kzMicpO1xuICAgICAgICAgIGJ3LmJ5dGUoT1BfQlJfSUYpOyBidy51MzIo
MCk7IC8vIGNvbnRpbnVlIGlmIHRydWVcblxuICAgICAgICAgIGRlcHRoLS07IGJ3LmJ5dGUoT1Bf
RU5EKTsgLy8gZW5kIGxvb3BcbiAgICAgICAgICBicmVha1RhcmdldHMucG9wKCk7XG4gICAgICAg
ICAgZGVwdGgtLTsgYncuYnl0ZShPUF9FTkQpOyAvLyBlbmQgYmxvY2tcbiAgICAgICAgICBicmVh
aztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdCcmVhayc6IHtcbiAgICAgICAgICBpZiAoYnJl
YWtUYXJnZXRzLmxlbmd0aCA9PT0gMCkgdGhyb3cgbmV3IEVycm9yKCdicmVhayBvdXRzaWRlIGxv
b3AnKTtcbiAgICAgICAgICBjb25zdCB0YXJnZXREZXB0aCA9IGJyZWFrVGFyZ2V0c1ticmVha1Rh
cmdldHMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgYncuYnl0ZShPUF9CUik7XG4gICAgICAgICAg
YncudTMyKGRlcHRoIC0gdGFyZ2V0RGVwdGgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9
XG4gICAgICAgIGNhc2UgJ0NhbGwnOiB7XG4gICAgICAgICAgLy8gRWFybHkgcmV0dXJuOiBjYWxs
IHJldHVybihleHByKSBvciBjYWxsIHJldHVybigpXG4gICAgICAgICAgaWYgKHN0bXQubmFtZSA9
PT0gJ3JldHVybicpIHtcbiAgICAgICAgICAgIGlmIChpc0Z1bmMpIHtcbiAgICAgICAgICAgICAg
aWYgKHN0bXQuYXJncy5sZW5ndGggIT09IDEpIHRocm93IG5ldyBFcnJvcigncmV0dXJuKCkgaW4g
YSBmdW5jdGlvbiByZXF1aXJlcyBleGFjdGx5IG9uZSBhcmd1bWVudCcpO1xuICAgICAgICAgICAg
ICBlbWl0RXhwcihzdG10LmFyZ3NbMF0sIHJldFR5cGUpO1xuICAgICAgICAgICAgfSBlbHNlIHtc
biAgICAgICAgICAgICAgaWYgKHN0bXQuYXJncy5sZW5ndGggIT09IDApIHRocm93IG5ldyBFcnJv
cigncmV0dXJuKCkgaW4gYSBzdWJyb3V0aW5lIHRha2VzIG5vIGFyZ3VtZW50cycpO1xuICAgICAg
ICAgICAgfVxuICAgICAgICAgICAgYncuYnl0ZShPUF9SRVRVUk4pO1xuICAgICAgICAgICAgYnJl
YWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFNJTUQgbmFtZXNwYWNlZCBidWlsdGlucyB1
c2VkIGFzIHN0YXRlbWVudHMgKGUuZy4gY2FsbCB2MTI4LnN0b3JlKC4uLikpXG4gICAgICAgICAg
Y29uc3QgY2FsbERvdElkeCA9IHN0bXQubmFtZS5pbmRleE9mKCcuJyk7XG4gICAgICAgICAgaWYg
KGNhbGxEb3RJZHggIT09IC0xKSB7XG4gICAgICAgICAgICBjb25zdCBjYWxsUHJlZml4ID0gc3Rt
dC5uYW1lLnNsaWNlKDAsIGNhbGxEb3RJZHgpO1xuICAgICAgICAgICAgY29uc3QgY2FsbE1ldGhv
ZCA9IHN0bXQubmFtZS5zbGljZShjYWxsRG90SWR4ICsgMSk7XG4gICAgICAgICAgICBpZiAoaXNW
ZWN0b3IoY2FsbFByZWZpeCkgfHwgY2FsbFByZWZpeCA9PT0gJ3YxMjgnKSB7XG4gICAgICAgICAg
ICAgIGVtaXRTaW1kQnVpbHRpbihjYWxsUHJlZml4LCBjYWxsTWV0aG9kLCBzdG10LCBudWxsKTtc
biAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAg
ICAgIC8vIE5hdGl2ZSBidWlsdGlucyB1c2VkIGFzIHN0YXRlbWVudHMgKGUuZy4gY2FsbCBtZW1v
cnlfY29weSguLi4pKVxuICAgICAgICAgIGlmIChOQVRJVkVfQlVJTFRJTlMuaGFzKHN0bXQubmFt
ZSkpIHtcbiAgICAgICAgICAgIGVtaXRGdW5jQ2FsbChzdG10LCBudWxsKTtcbiAgICAgICAgICAg
IGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBJbmRpcmVjdCBjYWxsIHZpYSBmdW5j
dGlvbi10eXBlZCB2YXJpYWJsZSB1c2VkIGFzIHN0YXRlbWVudFxuICAgICAgICAgIGNvbnN0IGNh
bGxMb2NhbEluZm8gPSBsb2NhbE1hcFtzdG10Lm5hbWVdO1xuICAgICAgICAgIGNvbnN0IGNhbGxH
U2lnID0gZ2xvYmFsRnVuY1NpZ1tzdG10Lm5hbWVdO1xuICAgICAgICAgIGlmICgoY2FsbExvY2Fs
SW5mbyAmJiBjYWxsTG9jYWxJbmZvLmZ1bmNTaWcpIHx8IGNhbGxHU2lnKSB7XG4gICAgICAgICAg
ICBlbWl0RnVuY0NhbGwoc3RtdCwgbnVsbCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAg
ICB9XG4gICAgICAgICAgLy8gc3Vicm91dGluZSBjYWxsIG9yIGZ1bmN0aW9uIGNhbGwgKHJlc3Vs
dCBkaXNjYXJkZWQpXG4gICAgICAgICAgY29uc3QgZklkeCA9IGZ1bmNJbmRleFtzdG10Lm5hbWVd
O1xuICAgICAgICAgIGlmIChmSWR4ID09PSB1bmRlZmluZWQpIHRocm93IG5ldyBFcnJvcihgVW5k
ZWZpbmVkIGZ1bmN0aW9uOiAke3N0bXQubmFtZX1gKTtcbiAgICAgICAgICBmb3IgKGxldCBhaSA9
IDA7IGFpIDwgc3RtdC5hcmdzLmxlbmd0aDsgYWkrKykge1xuICAgICAgICAgICAgLy8gaW5mZXIg
cGFyYW0gdHlwZSBmcm9tIGRlY2xhcmF0aW9uXG4gICAgICAgICAgICBjb25zdCBwYXJhbVR5cGUg
PSBnZXRQYXJhbVR5cGUoc3RtdC5uYW1lLCBhaSk7XG4gICAgICAgICAgICBlbWl0RXhwcihzdG10
LmFyZ3NbYWldLCBwYXJhbVR5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBidy5ieXRlKE9Q
X0NBTEwpO1xuICAgICAgICAgIGJ3LnUzMihmSWR4KTtcbiAgICAgICAgICBicmVhaztcbiAgICAg
ICAgfVxuICAgICAgICBjYXNlICdUYWlsQ2FsbCc6IHtcbiAgICAgICAgICBjb25zdCB0Y05hbWUg
PSBzdG10Lm5hbWU7XG5cbiAgICAgICAgICAvLyBJbmRpcmVjdCB0YWlsIGNhbGwgdmlhIGZ1bmN0
aW9uLXR5cGVkIHZhcmlhYmxlXG4gICAgICAgICAgY29uc3QgdGNMb2NhbEluZm8gPSBsb2NhbE1h
cFt0Y05hbWVdO1xuICAgICAgICAgIGNvbnN0IHRjR1NpZyA9IGdsb2JhbEZ1bmNTaWdbdGNOYW1l
XTtcbiAgICAgICAgICBpZiAoKHRjTG9jYWxJbmZvICYmIHRjTG9jYWxJbmZvLmZ1bmNTaWcpIHx8
IHRjR1NpZykge1xuICAgICAgICAgICAgY29uc3Qgc2lnID0gKHRjTG9jYWxJbmZvICYmIHRjTG9j
YWxJbmZvLmZ1bmNTaWcpIHx8IHRjR1NpZztcbiAgICAgICAgICAgIGNvbnN0IGNhbGxlZVJldCA9
IHNpZy5yZXRUeXBlIHx8IG51bGw7XG4gICAgICAgICAgICBpZiAoY2FsbGVlUmV0ICE9PSByZXRU
eXBlKVxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHRhaWxjYWxsIHR5cGUgbWlzbWF0
Y2g6ICR7dGNOYW1lfSByZXR1cm5zICR7Y2FsbGVlUmV0IHx8ICd2b2lkJ30sIGN1cnJlbnQgZnVu
Y3Rpb24gcmV0dXJucyAke3JldFR5cGUgfHwgJ3ZvaWQnfWApO1xuICAgICAgICAgICAgZm9yIChs
ZXQgYWkgPSAwOyBhaSA8IHN0bXQuYXJncy5sZW5ndGg7IGFpKyspIHtcbiAgICAgICAgICAgICAg
Y29uc3QgcHQgPSBzaWcucGFyYW1zW2FpXSA/IChzaWcucGFyYW1zW2FpXS5pc0FycmF5ID8gJ2kz
MicgOiBzaWcucGFyYW1zW2FpXS52dHlwZSkgOiAnZjY0JztcbiAgICAgICAgICAgICAgZW1pdEV4
cHIoc3RtdC5hcmdzW2FpXSwgcHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRj
TG9jYWxJbmZvKSB7IGJ3LmJ5dGUoT1BfTE9DQUxfR0VUKTsgYncudTMyKHRjTG9jYWxJbmZvLmlk
eCk7IH1cbiAgICAgICAgICAgIGVsc2UgeyBidy5ieXRlKE9QX0dMT0JBTF9HRVQpOyBidy51MzIo
Z2xvYmFsSW5kZXhbdGNOYW1lXSk7IH1cbiAgICAgICAgICAgIGNvbnN0IGluZGlyZWN0U2lnSWQg
PSBnZXRPckFkZFNpZyhzaWcucGFyYW1zLCBzaWcucmV0VHlwZSk7XG4gICAgICAgICAgICBidy5i
eXRlKE9QX1JFVFVSTl9DQUxMX0lORElSRUNUKTtcbiAgICAgICAgICAgIGJ3LnUzMihpbmRpcmVj
dFNpZ0lkKTtcbiAgICAgICAgICAgIGJ3LnUzMigwKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAg
ICAgICAgIH1cblxuICAgICAgICAgIC8vIERpcmVjdCB0YWlsIGNhbGwg4oCUIHR5cGUgdmFsaWRh
dGlvblxuICAgICAgICAgIGNvbnN0IGNhbGxlZUZuID0gZnVuY3Rpb25zLmZpbmQoZiA9PiBmLm5h
bWUgPT09IHRjTmFtZSk7XG4gICAgICAgICAgY29uc3QgY2FsbGVlSW0gPSAhY2FsbGVlRm4gJiYg
YWxsSW1wb3J0cy5maW5kKGkgPT4gaS5uYW1lID09PSB0Y05hbWUpO1xuICAgICAgICAgIGNvbnN0
IGNhbGxlZVJldCA9IGNhbGxlZUZuID8gKGNhbGxlZUZuLnR5cGUgPT09ICdTdWJyb3V0aW5lJyA/
IG51bGwgOiBjYWxsZWVGbi5yZXRUeXBlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICA6IGNh
bGxlZUltID8gY2FsbGVlSW0ucmV0VHlwZSA6IG51bGw7XG4gICAgICAgICAgaWYgKGNhbGxlZVJl
dCAhPT0gcmV0VHlwZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgdGFpbGNhbGwgdHlw
ZSBtaXNtYXRjaDogJHt0Y05hbWV9IHJldHVybnMgJHtjYWxsZWVSZXQgfHwgJ3ZvaWQnfSwgY3Vy
cmVudCBmdW5jdGlvbiByZXR1cm5zICR7cmV0VHlwZSB8fCAndm9pZCd9YCk7XG5cbiAgICAgICAg
ICBjb25zdCB0Y0ZJZHggPSBmdW5jSW5kZXhbdGNOYW1lXTtcbiAgICAgICAgICBpZiAodGNGSWR4
ID09PSB1bmRlZmluZWQpIHRocm93IG5ldyBFcnJvcihgVW5kZWZpbmVkIGZ1bmN0aW9uOiAke3Rj
TmFtZX1gKTtcbiAgICAgICAgICBmb3IgKGxldCBhaSA9IDA7IGFpIDwgc3RtdC5hcmdzLmxlbmd0
aDsgYWkrKykge1xuICAgICAgICAgICAgZW1pdEV4cHIoc3RtdC5hcmdzW2FpXSwgZ2V0UGFyYW1U
eXBlKHRjTmFtZSwgYWkpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYncuYnl0ZShPUF9SRVRV
Uk5fQ0FMTCk7XG4gICAgICAgICAgYncudTMyKHRjRklkeCk7XG4gICAgICAgICAgYnJlYWs7XG4g
ICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVu
a25vd24gc3RhdGVtZW50IHR5cGU6ICR7c3RtdC50eXBlfWApO1xuICAgICAgfVxuICAgIH1cblxu
ICAgIGZ1bmN0aW9uIGdldFBhcmFtVHlwZShmdW5jTmFtZSwgcGFyYW1JZHgpIHtcbiAgICAgIC8v
IGNoZWNrIGxvY2FsIGZ1bmN0aW9uc1xuICAgICAgY29uc3QgZm4gPSBmdW5jdGlvbnMuZmluZChm
ID0+IGYubmFtZSA9PT0gZnVuY05hbWUpO1xuICAgICAgaWYgKGZuICYmIGZuLnBhcmFtc1twYXJh
bUlkeF0pIHJldHVybiBmbi5wYXJhbXNbcGFyYW1JZHhdLmlzQXJyYXkgPyAnaTMyJyA6IGZuLnBh
cmFtc1twYXJhbUlkeF0udnR5cGU7XG4gICAgICAvLyBjaGVjayBpbXBvcnRzXG4gICAgICBjb25z
dCBpbSA9IGFsbEltcG9ydHMuZmluZChpID0+IGkubmFtZSA9PT0gZnVuY05hbWUpO1xuICAgICAg
aWYgKGltICYmIGltLnBhcmFtc1twYXJhbUlkeF0pIHJldHVybiBpbS5wYXJhbXNbcGFyYW1JZHhd
LnZ0eXBlO1xuICAgICAgcmV0dXJuICdmNjQnOyAvLyBkZWZhdWx0XG4gICAgfVxuXG4gICAgZnVu
Y3Rpb24gcmVzb2x2ZVR5cGUobmFtZSkge1xuICAgICAgaWYgKGxvY2FsTWFwW25hbWVdKSByZXR1
cm4gbG9jYWxNYXBbbmFtZV0udnR5cGU7XG4gICAgICBpZiAoZ2xvYmFsSW5kZXhbbmFtZV0gIT09
IHVuZGVmaW5lZCkgcmV0dXJuIGdsb2JhbHNbZ2xvYmFsSW5kZXhbbmFtZV1dLnZ0eXBlO1xuICAg
ICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gVHlwZSBpbmZlcmVuY2UgZmFsbGJhY2s6
IHdoZW4gZXhwZWN0ZWRUeXBlIGlzIG51bGwsIGd1ZXNzIGZyb20gQVNUIHNoYXBlLiBEZWZhdWx0
IGlzIGY2NC5cbiAgICBmdW5jdGlvbiBpbmZlckV4cHJUeXBlKGV4cHIpIHtcbiAgICAgIHN3aXRj
aCAoZXhwci50eXBlKSB7XG4gICAgICAgIGNhc2UgJ051bWJlckxpdCc6IHtcbiAgICAgICAgICBp
ZiAoZXhwci50eXBlU3VmZml4KSByZXR1cm4gZXhwci50eXBlU3VmZml4O1xuICAgICAgICAgIGlm
IChleHByLmlzRmxvYXQgfHwgZXhwci52YWx1ZS5pbmNsdWRlcygnLicpIHx8IGV4cHIudmFsdWUu
aW5jbHVkZXMoJ2UnKSB8fCBleHByLnZhbHVlLmluY2x1ZGVzKCdFJykpIHJldHVybiAnZjY0Jztc
biAgICAgICAgICByZXR1cm4gJ2kzMic7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnRnVuY1Jl
Zic6IHJldHVybiAnaTMyJztcbiAgICAgICAgY2FzZSAnSWRlbnQnOiByZXR1cm4gcmVzb2x2ZVR5
cGUoZXhwci5uYW1lKSB8fCAnZjY0JztcbiAgICAgICAgY2FzZSAnQmluT3AnOiByZXR1cm4gaW5m
ZXJFeHByVHlwZShleHByLmxlZnQpO1xuICAgICAgICBjYXNlICdVbmFyeU9wJzogcmV0dXJuIGlu
ZmVyRXhwclR5cGUoZXhwci5vcGVyYW5kKTtcbiAgICAgICAgY2FzZSAnRnVuY0NhbGwnOiB7XG4g
ICAgICAgICAgLy8gdHlwZSBjb252ZXJzaW9ucyAvIHZlY3RvciBjb25zdHJ1Y3RvcnNcbiAgICAg
ICAgICBpZiAoQVRSQV9UWVBFUy5oYXMoZXhwci5uYW1lKSkgcmV0dXJuIGV4cHIubmFtZTtcbiAg
ICAgICAgICAvLyBTSU1EIG5hbWVzcGFjZWQgYnVpbHRpbnNcbiAgICAgICAgICBjb25zdCBkb3RJ
ZHggPSBleHByLm5hbWUuaW5kZXhPZignLicpO1xuICAgICAgICAgIGlmIChkb3RJZHggIT09IC0x
KSB7XG4gICAgICAgICAgICBjb25zdCBwcmVmaXggPSBleHByLm5hbWUuc2xpY2UoMCwgZG90SWR4
KTtcbiAgICAgICAgICAgIGNvbnN0IG1ldGhvZCA9IGV4cHIubmFtZS5zbGljZShkb3RJZHggKyAx
KTtcbiAgICAgICAgICAgIGlmIChpc1ZlY3RvcihwcmVmaXgpKSB7XG4gICAgICAgICAgICAgIC8v
IGV4dHJhY3RfbGFuZSByZXR1cm5zIHRoZSBzY2FsYXIgdHlwZVxuICAgICAgICAgICAgICBpZiAo
bWV0aG9kID09PSAnZXh0cmFjdF9sYW5lJykgcmV0dXJuIHZlY3RvclNjYWxhclR5cGUocHJlZml4
KTtcbiAgICAgICAgICAgICAgLy8gc3BsYXQsIHJlcGxhY2VfbGFuZSwgYWRkLCBzdWIsIG11bCwg
ZGl2LCBuZWcsIGFicywgc3FydCwgZXEsIGV0Yy4gcmV0dXJuIHRoZSB2ZWN0b3IgdHlwZVxuICAg
ICAgICAgICAgICByZXR1cm4gcHJlZml4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYg
KHByZWZpeCA9PT0gJ3YxMjgnKSB7XG4gICAgICAgICAgICAgIC8vIHYxMjguYW5kL29yL3hvci9u
b3QvbG9hZCByZXR1cm4gdjEyOCDigJQgaW5mZXIgZnJvbSBmaXJzdCBhcmdcbiAgICAgICAgICAg
ICAgaWYgKG1ldGhvZCA9PT0gJ2xvYWQnKSByZXR1cm4gaW5mZXJFeHByVHlwZShleHByLmFyZ3Nb
MF0pIHx8ICdmNjR4Mic7IC8vIGRlZmF1bHQgdG8gZjY0eDJcbiAgICAgICAgICAgICAgaWYgKFsn
YW5kJywnb3InLCd4b3InLCdub3QnXS5pbmNsdWRlcyhtZXRob2QpKSByZXR1cm4gaW5mZXJFeHBy
VHlwZShleHByLmFyZ3NbMF0pO1xuICAgICAgICAgICAgICBpZiAobWV0aG9kID09PSAnc3RvcmUn
KSByZXR1cm4gJ2kzMic7IC8vIHN0b3JlIGlzIGEgc3RhdGVtZW50LCBidXQgdHlwZSBkb2Vzbid0
IG1hdHRlciBtdWNoXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIElu
ZGlyZWN0IGNhbGwgdmlhIGZ1bmN0aW9uLXR5cGVkIHZhcmlhYmxlXG4gICAgICAgICAgY29uc3Qg
Y2FsbEluZm8gPSBsb2NhbE1hcFtleHByLm5hbWVdO1xuICAgICAgICAgIGlmIChjYWxsSW5mbyAm
JiBjYWxsSW5mby5mdW5jU2lnICYmIGNhbGxJbmZvLmZ1bmNTaWcucmV0VHlwZSkgcmV0dXJuIGNh
bGxJbmZvLmZ1bmNTaWcucmV0VHlwZTtcbiAgICAgICAgICBpZiAoZ2xvYmFsRnVuY1NpZ1tleHBy
Lm5hbWVdICYmIGdsb2JhbEZ1bmNTaWdbZXhwci5uYW1lXS5yZXRUeXBlKSByZXR1cm4gZ2xvYmFs
RnVuY1NpZ1tleHByLm5hbWVdLnJldFR5cGU7XG4gICAgICAgICAgLy8ga25vd24gcmV0dXJuIHR5
cGVzXG4gICAgICAgICAgY29uc3QgZm4gPSBmdW5jdGlvbnMuZmluZChmID0+IGYubmFtZSA9PT0g
ZXhwci5uYW1lKTtcbiAgICAgICAgICBpZiAoZm4gJiYgZm4ucmV0VHlwZSkgcmV0dXJuIGZuLnJl
dFR5cGU7XG4gICAgICAgICAgcmV0dXJuICdmNjQnO1xuICAgICAgICB9XG4gICAgICAgIGNhc2Ug
J0FycmF5QWNjZXNzJzoge1xuICAgICAgICAgIGNvbnN0IGluZm8gPSBsb2NhbE1hcFtleHByLm5h
bWVdO1xuICAgICAgICAgIHJldHVybiBpbmZvID8gKGluZm8uZWxlbVR5cGUgfHwgaW5mby52dHlw
ZSkgOiAnZjY0JztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdJZkV4cHInOiByZXR1cm4gaW5m
ZXJFeHByVHlwZShleHByLnRoZW5FeHByKTtcbiAgICAgICAgZGVmYXVsdDogcmV0dXJuICdmNjQn
O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIOKUgOKUgCBFeHByZXNzaW9uIGVtaXNzaW9uIOKU
gOKUgFxuICAgIGZ1bmN0aW9uIGVtaXRFeHByKGV4cHIsIGV4cGVjdGVkVHlwZSkge1xuICAgICAg
Y29uc3QgYWN0dWFsVHlwZSA9IGV4cGVjdGVkVHlwZSB8fCBpbmZlckV4cHJUeXBlKGV4cHIpO1xu
XG4gICAgICBzd2l0Y2ggKGV4cHIudHlwZSkge1xuICAgICAgICBjYXNlICdOdW1iZXJMaXQnOiB7
XG4gICAgICAgICAgY29uc3QgdCA9IGV4cGVjdGVkVHlwZSB8fCBpbmZlckV4cHJUeXBlKGV4cHIp
O1xuICAgICAgICAgIGNvbnN0IHJhdyA9IGV4cHIudmFsdWU7XG4gICAgICAgICAgaWYgKHQgPT09
ICdpMzInKSB7IGJ3LmJ5dGUoT1BfSTMyX0NPTlNUKTsgYncuczMyKHBhcnNlSW50KHJhdywgMTAp
IHwgMCk7IH1cbiAgICAgICAgICBlbHNlIGlmICh0ID09PSAnaTY0JykgeyBidy5ieXRlKE9QX0k2
NF9DT05TVCk7IGJ3LnM2NChCaWdJbnQocGFyc2VJbnQocmF3LCAxMCkpKTsgfVxuICAgICAgICAg
IGVsc2UgaWYgKHQgPT09ICdmMzInKSB7IGJ3LmJ5dGUoT1BfRjMyX0NPTlNUKTsgYncuZjMyKHBh
cnNlRmxvYXQocmF3KSk7IH1cbiAgICAgICAgICBlbHNlIHsgYncuYnl0ZShPUF9GNjRfQ09OU1Qp
OyBidy5mNjQocGFyc2VGbG9hdChyYXcpKTsgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9
XG4gICAgICAgIGNhc2UgJ0Z1bmNSZWYnOiB7XG4gICAgICAgICAgY29uc3QgbmFtZSA9IGV4cHIu
bmFtZTtcbiAgICAgICAgICBpZiAodGFibGVTbG90W25hbWVdID09PSB1bmRlZmluZWQpIHRocm93
IG5ldyBFcnJvcihgVW5rbm93biBmdW5jdGlvbjogJHtuYW1lfWApO1xuICAgICAgICAgIGJ3LmJ5
dGUoT1BfSTMyX0NPTlNUKTsgYncuczMyKHRhYmxlU2xvdFtuYW1lXSk7XG4gICAgICAgICAgYnJl
YWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnSWRlbnQnOiB7XG4gICAgICAgICAgY29uc3Qg
bmFtZSA9IGV4cHIubmFtZTtcbiAgICAgICAgICBpZiAoaXNGdW5jICYmIG5hbWUgPT09IGZuLm5h
bWUpIHtcbiAgICAgICAgICAgIC8vIEZvcnRyYW4gY29udmVudGlvbjogYmFyZSBmdW5jdGlvbiBu
YW1lIHJlYWRzIHRoZSByZXR1cm4gYWNjdW11bGF0b3JcbiAgICAgICAgICAgIGJ3LmJ5dGUoT1Bf
TE9DQUxfR0VUKTsgYncudTMyKGxvY2FsTWFwWyckX3JldHVybiddLmlkeCk7XG4gICAgICAgICAg
fVxuICAgICAgICAgIGVsc2UgaWYgKGxvY2FsTWFwW25hbWVdKSB7IGJ3LmJ5dGUoT1BfTE9DQUxf
R0VUKTsgYncudTMyKGxvY2FsTWFwW25hbWVdLmlkeCk7IH1cbiAgICAgICAgICBlbHNlIGlmIChn
bG9iYWxJbmRleFtuYW1lXSAhPT0gdW5kZWZpbmVkKSB7IGJ3LmJ5dGUoT1BfR0xPQkFMX0dFVCk7
IGJ3LnUzMihnbG9iYWxJbmRleFtuYW1lXSk7IH1cbiAgICAgICAgICBlbHNlIHRocm93IG5ldyBF
cnJvcihgVW5kZWZpbmVkIHZhcmlhYmxlOiAke25hbWV9YCk7XG4gICAgICAgICAgYnJlYWs7XG4g
ICAgICAgIH1cbiAgICAgICAgY2FzZSAnQmluT3AnOiB7XG4gICAgICAgICAgY29uc3QgdCA9IGV4
cGVjdGVkVHlwZSB8fCBpbmZlckV4cHJUeXBlKGV4cHIpO1xuICAgICAgICAgIGVtaXRCaW5PcChl
eHByLCB0KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdVbmFy
eU9wJzoge1xuICAgICAgICAgIGNvbnN0IHQgPSBleHBlY3RlZFR5cGUgfHwgaW5mZXJFeHByVHlw
ZShleHByKTtcbiAgICAgICAgICBpZiAoZXhwci5vcCA9PT0gJy0nKSB7XG4gICAgICAgICAgICBp
ZiAodCA9PT0gJ2Y2NCcpIHsgZW1pdEV4cHIoZXhwci5vcGVyYW5kLCB0KTsgYncuYnl0ZShPUF9G
NjRfTkVHKTsgfVxuICAgICAgICAgICAgZWxzZSBpZiAodCA9PT0gJ2YzMicpIHsgZW1pdEV4cHIo
ZXhwci5vcGVyYW5kLCB0KTsgYncuYnl0ZShPUF9GMzJfTkVHKTsgfVxuICAgICAgICAgICAgZWxz
ZSBpZiAodCA9PT0gJ2kzMicpIHsgYncuYnl0ZShPUF9JMzJfQ09OU1QpOyBidy5zMzIoMCk7IGVt
aXRFeHByKGV4cHIub3BlcmFuZCwgdCk7IGJ3LmJ5dGUoT1BfSTMyX1NVQik7IH1cbiAgICAgICAg
ICAgIGVsc2UgaWYgKHQgPT09ICdpNjQnKSB7IGJ3LmJ5dGUoT1BfSTY0X0NPTlNUKTsgYncuczY0
KDBuKTsgZW1pdEV4cHIoZXhwci5vcGVyYW5kLCB0KTsgYncuYnl0ZShPUF9JNjRfU1VCKTsgfVxu
ICAgICAgICAgICAgZWxzZSBpZiAoaXNWZWN0b3IodCkpIHsgZW1pdEV4cHIoZXhwci5vcGVyYW5k
LCB0KTsgZW1pdFNpbWQoU0lNRF9PUFNbdCArICcubmVnJ10pOyB9XG4gICAgICAgICAgfSBlbHNl
IGlmIChleHByLm9wID09PSAnbm90Jykge1xuICAgICAgICAgICAgZW1pdEV4cHIoZXhwci5vcGVy
YW5kLCAnaTMyJyk7XG4gICAgICAgICAgICBidy5ieXRlKE9QX0kzMl9FUVopO1xuICAgICAgICAg
IH0gZWxzZSBpZiAoZXhwci5vcCA9PT0gJ34nKSB7XG4gICAgICAgICAgICBlbWl0RXhwcihleHBy
Lm9wZXJhbmQsIHQpO1xuICAgICAgICAgICAgaWYgKHQgPT09ICdpMzInKSB7IGJ3LmJ5dGUoT1Bf
STMyX0NPTlNUKTsgYncuczMyKC0xKTsgYncuYnl0ZShPUF9JMzJfWE9SKTsgfVxuICAgICAgICAg
ICAgZWxzZSBpZiAodCA9PT0gJ2k2NCcpIHsgYncuYnl0ZShPUF9JNjRfQ09OU1QpOyBidy5zNjQo
LTFuKTsgYncuYnl0ZShPUF9JNjRfWE9SKTsgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAg
ICAgICBlbWl0RXhwcihleHByLm9wZXJhbmQsIHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBi
cmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdGdW5jQ2FsbCc6IHtcbiAgICAgICAgICBl
bWl0RnVuY0NhbGwoZXhwciwgZXhwZWN0ZWRUeXBlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAg
ICAgfVxuICAgICAgICBjYXNlICdBcnJheUFjY2Vzcyc6IHtcbiAgICAgICAgICBjb25zdCBpbmZv
ID0gbG9jYWxNYXBbZXhwci5uYW1lXTtcbiAgICAgICAgICBpZiAoIWluZm8pIHRocm93IG5ldyBF
cnJvcihgVW5kZWZpbmVkIGFycmF5OiAke2V4cHIubmFtZX1gKTtcbiAgICAgICAgICBjb25zdCBl
bGVtVHlwZSA9IGluZm8uZWxlbVR5cGUgfHwgaW5mby52dHlwZTtcbiAgICAgICAgICBlbWl0QXJy
YXlBZGRyKGV4cHIubmFtZSwgZXhwci5pbmRpY2VzLCBpbmZvLCBlbGVtVHlwZSk7XG4gICAgICAg
ICAgZW1pdExvYWQoZWxlbVR5cGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAg
ICAgIGNhc2UgJ0lmRXhwcic6IHtcbiAgICAgICAgICBjb25zdCB0ID0gZXhwZWN0ZWRUeXBlIHx8
IGluZmVyRXhwclR5cGUoZXhwci50aGVuRXhwcik7XG4gICAgICAgICAgZW1pdEV4cHIoZXhwci5j
b25kLCAnaTMyJyk7XG4gICAgICAgICAgYncuYnl0ZShPUF9JRik7XG4gICAgICAgICAgYncuYnl0
ZSh3YXNtVHlwZSh0KSk7XG4gICAgICAgICAgZW1pdEV4cHIoZXhwci50aGVuRXhwciwgdCk7XG4g
ICAgICAgICAgYncuYnl0ZShPUF9FTFNFKTtcbiAgICAgICAgICBlbWl0RXhwcihleHByLmVsc2VF
eHByLCB0KTtcbiAgICAgICAgICBidy5ieXRlKE9QX0VORCk7XG4gICAgICAgICAgYnJlYWs7XG4g
ICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVu
a25vd24gZXhwcmVzc2lvbiB0eXBlOiAke2V4cHIudHlwZX1gKTtcbiAgICAgIH1cbiAgICB9XG5c
biAgICAvLyDilIDilIAgQmluYXJ5IG9wZXJhdG9ycyDilIDilIBcbiAgICBmdW5jdGlvbiBlbWl0
QmluT3AoZXhwciwgdCkge1xuICAgICAgY29uc3Qgb3AgPSBleHByLm9wO1xuXG4gICAgICAvLyBF
eHBvbmVudGlhdGlvblxuICAgICAgaWYgKG9wID09PSAnKionKSB7XG4gICAgICAgIGVtaXRQb3co
ZXhwciwgdCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gQ29tcGFyaXNv
biBvcGVyYXRvcnMgcmV0dXJuIGkzMlxuICAgICAgaWYgKG9wID09PSAnPT0nIHx8IG9wID09PSAn
Lz0nIHx8IG9wID09PSAnPCcgfHwgb3AgPT09ICc+JyB8fCBvcCA9PT0gJzw9JyB8fCBvcCA9PT0g
Jz49Jykge1xuICAgICAgICBjb25zdCBvcGVyYW5kVHlwZSA9IGluZmVyRXhwclR5cGUoZXhwci5s
ZWZ0KTtcbiAgICAgICAgZW1pdEV4cHIoZXhwci5sZWZ0LCBvcGVyYW5kVHlwZSk7XG4gICAgICAg
IGVtaXRFeHByKGV4cHIucmlnaHQsIG9wZXJhbmRUeXBlKTtcbiAgICAgICAgZW1pdENtcChvcCwg
b3BlcmFuZFR5cGUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIExvZ2lj
YWw6IGFuZCwgb3JcbiAgICAgIGlmIChvcCA9PT0gJ2FuZCcpIHtcbiAgICAgICAgZW1pdEV4cHIo
ZXhwci5sZWZ0LCAnaTMyJyk7XG4gICAgICAgIGVtaXRFeHByKGV4cHIucmlnaHQsICdpMzInKTtc
biAgICAgICAgYncuYnl0ZShPUF9JMzJfQU5EKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxu
ICAgICAgaWYgKG9wID09PSAnb3InKSB7XG4gICAgICAgIGVtaXRFeHByKGV4cHIubGVmdCwgJ2kz
MicpO1xuICAgICAgICBlbWl0RXhwcihleHByLnJpZ2h0LCAnaTMyJyk7XG4gICAgICAgIGJ3LmJ5
dGUoT1BfSTMyX09SKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBlbWl0RXhw
cihleHByLmxlZnQsIHQpO1xuICAgICAgZW1pdEV4cHIoZXhwci5yaWdodCwgdCk7XG5cbiAgICAg
IGlmIChvcCA9PT0gJysnKSBlbWl0QWRkKHQpO1xuICAgICAgZWxzZSBpZiAob3AgPT09ICctJykg
ZW1pdFN1Yih0KTtcbiAgICAgIGVsc2UgaWYgKG9wID09PSAnKicpIGVtaXRNdWwodCk7XG4gICAg
ICBlbHNlIGlmIChvcCA9PT0gJy8nKSBlbWl0RGl2KHQpO1xuICAgICAgZWxzZSBpZiAob3AgPT09
ICdtb2QnKSB7XG4gICAgICAgIGlmICh0ID09PSAnaTMyJykgYncuYnl0ZShPUF9JMzJfUkVNX1Mp
O1xuICAgICAgICBlbHNlIGlmICh0ID09PSAnaTY0JykgYncuYnl0ZShPUF9JNjRfUkVNX1MpO1xu
ICAgICAgICBlbHNlIHRocm93IG5ldyBFcnJvcignbW9kIHJlcXVpcmVzIGludGVnZXIgdHlwZScp
O1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAob3AgPT09ICcmJykgeyBpZiAodCA9PT0gJ2kzMicp
IGJ3LmJ5dGUoT1BfSTMyX0FORCk7IGVsc2UgYncuYnl0ZShPUF9JNjRfQU5EKTsgfVxuICAgICAg
ZWxzZSBpZiAob3AgPT09ICd8JykgeyBpZiAodCA9PT0gJ2kzMicpIGJ3LmJ5dGUoT1BfSTMyX09S
KTsgZWxzZSBidy5ieXRlKE9QX0k2NF9PUik7IH1cbiAgICAgIGVsc2UgaWYgKG9wID09PSAnXicp
IHsgaWYgKHQgPT09ICdpMzInKSBidy5ieXRlKE9QX0kzMl9YT1IpOyBlbHNlIGJ3LmJ5dGUoT1Bf
STY0X1hPUik7IH1cbiAgICAgIGVsc2UgaWYgKG9wID09PSAnPDwnKSB7IGlmICh0ID09PSAnaTMy
JykgYncuYnl0ZShPUF9JMzJfU0hMKTsgZWxzZSBidy5ieXRlKE9QX0k2NF9TSEwpOyB9XG4gICAg
ICBlbHNlIGlmIChvcCA9PT0gJz4+JykgeyBpZiAodCA9PT0gJ2kzMicpIGJ3LmJ5dGUoT1BfSTMy
X1NIUl9TKTsgZWxzZSBidy5ieXRlKE9QX0k2NF9TSFJfUyk7IH1cbiAgICAgIGVsc2UgdGhyb3cg
bmV3IEVycm9yKGBVbmtub3duIG9wZXJhdG9yOiAke29wfWApO1xuICAgIH1cblxuICAgIGZ1bmN0
aW9uIGVtaXRQb3coZXhwciwgdCkge1xuICAgICAgLy8gKiowLjUg4oaSIHNxcnRcbiAgICAgIGlm
IChleHByLnJpZ2h0LnR5cGUgPT09ICdOdW1iZXJMaXQnICYmIChleHByLnJpZ2h0LnZhbHVlID09
PSAnMC41JyB8fCBleHByLnJpZ2h0LnZhbHVlID09PSAnLjUnKSkge1xuICAgICAgICBlbWl0RXhw
cihleHByLmxlZnQsIHQpO1xuICAgICAgICBpZiAodCA9PT0gJ2Y2NCcpIGJ3LmJ5dGUoT1BfRjY0
X1NRUlQpO1xuICAgICAgICBlbHNlIGlmICh0ID09PSAnZjMyJykgYncuYnl0ZShPUF9GMzJfU1FS
VCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIEdlbmVyYWw6IGNhbGwgcG93
IGltcG9ydCAod29ya3MgZm9yIGFsbCBjYXNlcyBpbmNsdWRpbmcgKioyLCAqKjMpXG4gICAgICBl
bWl0RXhwcihleHByLmxlZnQsICdmNjQnKTtcbiAgICAgIGVtaXRFeHByKGV4cHIucmlnaHQsICdm
NjQnKTtcbiAgICAgIGJ3LmJ5dGUoT1BfQ0FMTCk7XG4gICAgICBidy51MzIoZnVuY0luZGV4Wydw
b3cnXSk7XG4gICAgICAvLyBDb252ZXJ0IHJlc3VsdCBiYWNrIGlmIG5lZWRlZFxuICAgICAgaWYg
KHQgPT09ICdmMzInKSBidy5ieXRlKE9QX0YzMl9ERU1PVEVfRjY0KTtcbiAgICB9XG5cbiAgICAv
LyDilIDilIAgRnVuY3Rpb24gY2FsbCBkaXNwYXRjaCDilIDilIBcbiAgICAvLyBQcmlvcml0eTog
dmVjdG9yIGNvbnN0cnVjdG9ycyA+IHR5cGUgY29udmVyc2lvbnMgPiBTSU1EIGJ1aWx0aW5zID4g
bmF0aXZlIGJ1aWx0aW5zXG4gICAgLy8gICAgICAgICA+IHdhc20uKiBlc2NhcGUgaGF0Y2ggPiBp
bmRpcmVjdCBjYWxscyAoY2FsbF9pbmRpcmVjdCkgPiByZWd1bGFyIGNhbGxzXG4gICAgZnVuY3Rp
b24gZW1pdEZ1bmNDYWxsKGV4cHIsIGV4cGVjdGVkVHlwZSkge1xuICAgICAgY29uc3QgbmFtZSA9
IGV4cHIubmFtZTtcblxuICAgICAgLy8gVmVjdG9yIGNvbnN0cnVjdG9yczogZjY0eDIoYSwgYiks
IGYzMng0KGEsIGIsIGMsIGQpLCBldGMuXG4gICAgICBpZiAoaXNWZWN0b3IobmFtZSkpIHtcbiAg
ICAgICAgZW1pdFZlY3RvckNvbnN0cnVjdG9yKG5hbWUsIGV4cHIuYXJncyk7XG4gICAgICAgIHJl
dHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gU2NhbGFyIHR5cGUgY29udmVyc2lvbnM6IGkzMih4
KSwgZjY0KHgpLCBldGMuXG4gICAgICBpZiAoQVRSQV9UWVBFUy5oYXMobmFtZSkpIHtcbiAgICAg
ICAgY29uc3QgZnJvbVR5cGUgPSBpbmZlckV4cHJUeXBlKGV4cHIuYXJnc1swXSk7XG4gICAgICAg
IGNvbnN0IHRvVHlwZSA9IG5hbWU7XG4gICAgICAgIGVtaXRFeHByKGV4cHIuYXJnc1swXSwgZnJv
bVR5cGUpO1xuICAgICAgICBlbWl0Q29udmVyc2lvbihmcm9tVHlwZSwgdG9UeXBlKTtcbiAgICAg
ICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBTSU1EIG5hbWVzcGFjZWQgYnVpbHRpbnM6
IGY2NHgyLnNwbGF0LCB2MTI4LmFuZCwgZXRjLlxuICAgICAgY29uc3QgZG90SWR4ID0gbmFtZS5p
bmRleE9mKCcuJyk7XG4gICAgICBpZiAoZG90SWR4ICE9PSAtMSkge1xuICAgICAgICBjb25zdCBw
cmVmaXggPSBuYW1lLnNsaWNlKDAsIGRvdElkeCk7XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9IG5h
bWUuc2xpY2UoZG90SWR4ICsgMSk7XG4gICAgICAgIGlmIChpc1ZlY3RvcihwcmVmaXgpIHx8IHBy
ZWZpeCA9PT0gJ3YxMjgnKSB7XG4gICAgICAgICAgZW1pdFNpbWRCdWlsdGluKHByZWZpeCwgbWV0
aG9kLCBleHByLCBleHBlY3RlZFR5cGUpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxu
ICAgICAgfVxuXG4gICAgICAvLyBOYXRpdmUgYnVpbHRpbnMg4oCUIHdpdGggdmVjdG9yIHR5cGUg
c3VwcG9ydFxuICAgICAgaWYgKG5hbWUgPT09ICdzcXJ0Jykge1xuICAgICAgICBlbWl0RXhwcihl
eHByLmFyZ3NbMF0sIGV4cGVjdGVkVHlwZSk7XG4gICAgICAgIGlmIChpc1ZlY3RvcihleHBlY3Rl
ZFR5cGUpKSB7IGNvbnN0IG9wID0gU0lNRF9PUFNbZXhwZWN0ZWRUeXBlICsgJy5zcXJ0J107IGlm
IChvcCA9PT0gdW5kZWZpbmVkKSB0aHJvdyBuZXcgRXJyb3IoJ3NxcnQgbm90IHN1cHBvcnRlZCBm
b3IgJyArIGV4cGVjdGVkVHlwZSk7IGVtaXRTaW1kKG9wKTsgfVxuICAgICAgICBlbHNlIGlmIChl
eHBlY3RlZFR5cGUgPT09ICdmMzInKSBidy5ieXRlKE9QX0YzMl9TUVJUKTtcbiAgICAgICAgZWxz
ZSBidy5ieXRlKE9QX0Y2NF9TUVJUKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAg
aWYgKG5hbWUgPT09ICdhYnMnKSB7XG4gICAgICAgIGVtaXRFeHByKGV4cHIuYXJnc1swXSwgZXhw
ZWN0ZWRUeXBlKTtcbiAgICAgICAgaWYgKGlzVmVjdG9yKGV4cGVjdGVkVHlwZSkpIHsgY29uc3Qg
b3AgPSBTSU1EX09QU1tleHBlY3RlZFR5cGUgKyAnLmFicyddOyBpZiAob3AgPT09IHVuZGVmaW5l
ZCkgdGhyb3cgbmV3IEVycm9yKCdhYnMgbm90IHN1cHBvcnRlZCBmb3IgJyArIGV4cGVjdGVkVHlw
ZSk7IGVtaXRTaW1kKG9wKTsgfVxuICAgICAgICBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09ICdm
MzInKSBidy5ieXRlKE9QX0YzMl9BQlMpO1xuICAgICAgICBlbHNlIGJ3LmJ5dGUoT1BfRjY0X0FC
Uyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChuYW1lID09PSAnZmxvb3In
KSB7IGVtaXRFeHByKGV4cHIuYXJnc1swXSwgZXhwZWN0ZWRUeXBlKTsgaWYgKGV4cGVjdGVkVHlw
ZSA9PT0gJ2YzMicpIGJ3LmJ5dGUoT1BfRjMyX0ZMT09SKTsgZWxzZSBidy5ieXRlKE9QX0Y2NF9G
TE9PUik7IHJldHVybjsgfVxuICAgICAgaWYgKG5hbWUgPT09ICdjZWlsJykgeyBlbWl0RXhwcihl
eHByLmFyZ3NbMF0sIGV4cGVjdGVkVHlwZSk7IGlmIChleHBlY3RlZFR5cGUgPT09ICdmMzInKSBi
dy5ieXRlKE9QX0YzMl9DRUlMKTsgZWxzZSBidy5ieXRlKE9QX0Y2NF9DRUlMKTsgcmV0dXJuOyB9
XG4gICAgICBpZiAobmFtZSA9PT0gJ3RydW5jJykgeyBlbWl0RXhwcihleHByLmFyZ3NbMF0sIGV4
cGVjdGVkVHlwZSk7IGlmIChleHBlY3RlZFR5cGUgPT09ICdmMzInKSBidy5ieXRlKE9QX0YzMl9U
UlVOQyk7IGVsc2UgYncuYnl0ZShPUF9GNjRfVFJVTkMpOyByZXR1cm47IH1cbiAgICAgIGlmIChu
YW1lID09PSAnbmVhcmVzdCcpIHsgZW1pdEV4cHIoZXhwci5hcmdzWzBdLCBleHBlY3RlZFR5cGUp
OyBpZiAoZXhwZWN0ZWRUeXBlID09PSAnZjMyJykgYncuYnl0ZShPUF9GMzJfTkVBUkVTVCk7IGVs
c2UgYncuYnl0ZShPUF9GNjRfTkVBUkVTVCk7IHJldHVybjsgfVxuICAgICAgaWYgKG5hbWUgPT09
ICdtaW4nKSB7XG4gICAgICAgIGVtaXRFeHByKGV4cHIuYXJnc1swXSwgZXhwZWN0ZWRUeXBlKTsg
ZW1pdEV4cHIoZXhwci5hcmdzWzFdLCBleHBlY3RlZFR5cGUpO1xuICAgICAgICBpZiAoaXNWZWN0
b3IoZXhwZWN0ZWRUeXBlKSkgeyBjb25zdCBvcCA9IFNJTURfT1BTW2V4cGVjdGVkVHlwZSArICcu
bWluJ107IGlmIChvcCA9PT0gdW5kZWZpbmVkKSB0aHJvdyBuZXcgRXJyb3IoJ21pbiBub3Qgc3Vw
cG9ydGVkIGZvciAnICsgZXhwZWN0ZWRUeXBlKTsgZW1pdFNpbWQob3ApOyB9XG4gICAgICAgIGVs
c2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gJ2YzMicpIGJ3LmJ5dGUoT1BfRjMyX01JTik7XG4gICAg
ICAgIGVsc2UgYncuYnl0ZShPUF9GNjRfTUlOKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxu
ICAgICAgaWYgKG5hbWUgPT09ICdtYXgnKSB7XG4gICAgICAgIGVtaXRFeHByKGV4cHIuYXJnc1sw
XSwgZXhwZWN0ZWRUeXBlKTsgZW1pdEV4cHIoZXhwci5hcmdzWzFdLCBleHBlY3RlZFR5cGUpO1xu
ICAgICAgICBpZiAoaXNWZWN0b3IoZXhwZWN0ZWRUeXBlKSkgeyBjb25zdCBvcCA9IFNJTURfT1BT
W2V4cGVjdGVkVHlwZSArICcubWF4J107IGlmIChvcCA9PT0gdW5kZWZpbmVkKSB0aHJvdyBuZXcg
RXJyb3IoJ21heCBub3Qgc3VwcG9ydGVkIGZvciAnICsgZXhwZWN0ZWRUeXBlKTsgZW1pdFNpbWQo
b3ApOyB9XG4gICAgICAgIGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gJ2YzMicpIGJ3LmJ5dGUo
T1BfRjMyX01BWCk7XG4gICAgICAgIGVsc2UgYncuYnl0ZShPUF9GNjRfTUFYKTtcbiAgICAgICAg
cmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKG5hbWUgPT09ICdjb3B5c2lnbicpIHsgZW1pdEV4
cHIoZXhwci5hcmdzWzBdLCBleHBlY3RlZFR5cGUpOyBlbWl0RXhwcihleHByLmFyZ3NbMV0sIGV4
cGVjdGVkVHlwZSk7IGlmIChleHBlY3RlZFR5cGUgPT09ICdmMzInKSBidy5ieXRlKE9QX0YzMl9D
T1BZU0lHTik7IGVsc2UgYncuYnl0ZShPUF9GNjRfQ09QWVNJR04pOyByZXR1cm47IH1cbiAgICAg
IGlmIChuYW1lID09PSAnc2VsZWN0Jykge1xuICAgICAgICAvLyBzZWxlY3QoYSwgYiwgY29uZCkg
4oCUIFdhc20gc2VsZWN0IHBpY2tzIGEgaWYgY29uZCE9MCwgYiBvdGhlcndpc2VcbiAgICAgICAg
Y29uc3QgdCA9IGV4cGVjdGVkVHlwZSB8fCBpbmZlckV4cHJUeXBlKGV4cHIuYXJnc1swXSk7XG4g
ICAgICAgIGVtaXRFeHByKGV4cHIuYXJnc1swXSwgdCk7XG4gICAgICAgIGVtaXRFeHByKGV4cHIu
YXJnc1sxXSwgdCk7XG4gICAgICAgIGVtaXRFeHByKGV4cHIuYXJnc1syXSwgJ2kzMicpO1xuICAg
ICAgICBidy5ieXRlKE9QX1NFTEVDVCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAg
IGlmIChuYW1lID09PSAnY2x6JykgeyBlbWl0RXhwcihleHByLmFyZ3NbMF0sIGV4cGVjdGVkVHlw
ZSk7IGlmIChleHBlY3RlZFR5cGUgPT09ICdpNjQnKSBidy5ieXRlKE9QX0k2NF9DTFopOyBlbHNl
IGJ3LmJ5dGUoT1BfSTMyX0NMWik7IHJldHVybjsgfVxuICAgICAgaWYgKG5hbWUgPT09ICdjdHon
KSB7IGVtaXRFeHByKGV4cHIuYXJnc1swXSwgZXhwZWN0ZWRUeXBlKTsgaWYgKGV4cGVjdGVkVHlw
ZSA9PT0gJ2k2NCcpIGJ3LmJ5dGUoT1BfSTY0X0NUWik7IGVsc2UgYncuYnl0ZShPUF9JMzJfQ1Ra
KTsgcmV0dXJuOyB9XG4gICAgICBpZiAobmFtZSA9PT0gJ3BvcGNudCcpIHsgZW1pdEV4cHIoZXhw
ci5hcmdzWzBdLCBleHBlY3RlZFR5cGUpOyBpZiAoZXhwZWN0ZWRUeXBlID09PSAnaTY0JykgYncu
Ynl0ZShPUF9JNjRfUE9QQ05UKTsgZWxzZSBidy5ieXRlKE9QX0kzMl9QT1BDTlQpOyByZXR1cm47
IH1cbiAgICAgIGlmIChuYW1lID09PSAncm90bCcpIHsgZW1pdEV4cHIoZXhwci5hcmdzWzBdLCBl
eHBlY3RlZFR5cGUpOyBlbWl0RXhwcihleHByLmFyZ3NbMV0sIGV4cGVjdGVkVHlwZSk7IGlmIChl
eHBlY3RlZFR5cGUgPT09ICdpNjQnKSBidy5ieXRlKE9QX0k2NF9ST1RMKTsgZWxzZSBidy5ieXRl
KE9QX0kzMl9ST1RMKTsgcmV0dXJuOyB9XG4gICAgICBpZiAobmFtZSA9PT0gJ3JvdHInKSB7IGVt
aXRFeHByKGV4cHIuYXJnc1swXSwgZXhwZWN0ZWRUeXBlKTsgZW1pdEV4cHIoZXhwci5hcmdzWzFd
LCBleHBlY3RlZFR5cGUpOyBpZiAoZXhwZWN0ZWRUeXBlID09PSAnaTY0JykgYncuYnl0ZShPUF9J
NjRfUk9UUik7IGVsc2UgYncuYnl0ZShPUF9JMzJfUk9UUik7IHJldHVybjsgfVxuICAgICAgaWYg
KG5hbWUgPT09ICdtZW1vcnlfc2l6ZScpIHsgYncuYnl0ZShPUF9NRU1PUllfU0laRSk7IGJ3LnUz
MigwKTsgcmV0dXJuOyB9XG4gICAgICBpZiAobmFtZSA9PT0gJ21lbW9yeV9ncm93JykgeyBlbWl0
RXhwcihleHByLmFyZ3NbMF0sICdpMzInKTsgYncuYnl0ZShPUF9NRU1PUllfR1JPVyk7IGJ3LnUz
MigwKTsgcmV0dXJuOyB9XG4gICAgICBpZiAobmFtZSA9PT0gJ21lbW9yeV9jb3B5Jykge1xuICAg
ICAgICBlbWl0RXhwcihleHByLmFyZ3NbMF0sICdpMzInKTsgZW1pdEV4cHIoZXhwci5hcmdzWzFd
LCAnaTMyJyk7IGVtaXRFeHByKGV4cHIuYXJnc1syXSwgJ2kzMicpO1xuICAgICAgICBidy5ieXRl
KE9QX0ZDX1BSRUZJWCk7IGJ3LnUzMigxMCk7IGJ3LnUzMigwKTsgYncudTMyKDApOyAvLyBtZW1v
cnkuY29weSwgZHN0X21lbT0wLCBzcmNfbWVtPTBcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxu
ICAgICAgaWYgKG5hbWUgPT09ICdtZW1vcnlfZmlsbCcpIHtcbiAgICAgICAgZW1pdEV4cHIoZXhw
ci5hcmdzWzBdLCAnaTMyJyk7IGVtaXRFeHByKGV4cHIuYXJnc1sxXSwgJ2kzMicpOyBlbWl0RXhw
cihleHByLmFyZ3NbMl0sICdpMzInKTtcbiAgICAgICAgYncuYnl0ZShPUF9GQ19QUkVGSVgpOyBi
dy51MzIoMTEpOyBidy51MzIoMCk7IC8vIG1lbW9yeS5maWxsLCBtZW09MFxuICAgICAgICByZXR1
cm47XG4gICAgICB9XG5cbiAgICAgIC8vIHdhc20uKiBlc2NhcGUgaGF0Y2hcbiAgICAgIGlmIChu
YW1lLnN0YXJ0c1dpdGgoJ3dhc20uJykpIHtcbiAgICAgICAgZW1pdFdhc21CdWlsdGluKG5hbWUu
c2xpY2UoNSksIGV4cHIsIGV4cGVjdGVkVHlwZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1c
blxuICAgICAgLy8gSW5kaXJlY3QgY2FsbCB2aWEgZnVuY3Rpb24tdHlwZWQgdmFyaWFibGVcbiAg
ICAgIGNvbnN0IGxvY2FsSW5mbyA9IGxvY2FsTWFwW25hbWVdO1xuICAgICAgY29uc3QgZ1NpZyA9
IGdsb2JhbEZ1bmNTaWdbbmFtZV07XG4gICAgICBpZiAoKGxvY2FsSW5mbyAmJiBsb2NhbEluZm8u
ZnVuY1NpZykgfHwgZ1NpZykge1xuICAgICAgICBjb25zdCBzaWcgPSAobG9jYWxJbmZvICYmIGxv
Y2FsSW5mby5mdW5jU2lnKSB8fCBnU2lnO1xuICAgICAgICAvLyBFbWl0IGFyZ3VtZW50cyB1c2lu
ZyBmdW5jU2lnIHBhcmFtIHR5cGVzXG4gICAgICAgIGZvciAobGV0IGFpID0gMDsgYWkgPCBleHBy
LmFyZ3MubGVuZ3RoOyBhaSsrKSB7XG4gICAgICAgICAgY29uc3QgcHQgPSBzaWcucGFyYW1zW2Fp
XSA/IChzaWcucGFyYW1zW2FpXS5pc0FycmF5ID8gJ2kzMicgOiBzaWcucGFyYW1zW2FpXS52dHlw
ZSkgOiAnZjY0JztcbiAgICAgICAgICBlbWl0RXhwcihleHByLmFyZ3NbYWldLCBwdCk7XG4gICAg
ICAgIH1cbiAgICAgICAgLy8gUHVzaCB0aGUgdGFibGUgaW5kZXggKHRoZSB2YXJpYWJsZSB2YWx1
ZSlcbiAgICAgICAgaWYgKGxvY2FsSW5mbykgeyBidy5ieXRlKE9QX0xPQ0FMX0dFVCk7IGJ3LnUz
Mihsb2NhbEluZm8uaWR4KTsgfVxuICAgICAgICBlbHNlIHsgYncuYnl0ZShPUF9HTE9CQUxfR0VU
KTsgYncudTMyKGdsb2JhbEluZGV4W25hbWVdKTsgfVxuICAgICAgICAvLyBjYWxsX2luZGlyZWN0
IHR5cGVfaW5kZXggdGFibGVfaW5kZXhcbiAgICAgICAgY29uc3QgaW5kaXJlY3RTaWdJZCA9IGdl
dE9yQWRkU2lnKHNpZy5wYXJhbXMsIHNpZy5yZXRUeXBlKTtcbiAgICAgICAgYncuYnl0ZShPUF9D
QUxMX0lORElSRUNUKTtcbiAgICAgICAgYncudTMyKGluZGlyZWN0U2lnSWQpO1xuICAgICAgICBi
dy51MzIoMCk7IC8vIHRhYmxlIGluZGV4IDBcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4g
ICAgICAvLyBSZWd1bGFyIGZ1bmN0aW9uIGNhbGxcbiAgICAgIGNvbnN0IGZJZHggPSBmdW5jSW5k
ZXhbbmFtZV07XG4gICAgICBpZiAoZklkeCA9PT0gdW5kZWZpbmVkKSB0aHJvdyBuZXcgRXJyb3Io
YFVuZGVmaW5lZCBmdW5jdGlvbjogJHtuYW1lfWApO1xuICAgICAgZm9yIChsZXQgYWkgPSAwOyBh
aSA8IGV4cHIuYXJncy5sZW5ndGg7IGFpKyspIHtcbiAgICAgICAgY29uc3QgcGFyYW1UeXBlID0g
Z2V0UGFyYW1UeXBlKG5hbWUsIGFpKTtcbiAgICAgICAgZW1pdEV4cHIoZXhwci5hcmdzW2FpXSwg
cGFyYW1UeXBlKTtcbiAgICAgIH1cbiAgICAgIGJ3LmJ5dGUoT1BfQ0FMTCk7XG4gICAgICBidy51
MzIoZklkeCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZW1pdFdhc21CdWlsdGluKG9wLCBleHBy
LCBleHBlY3RlZFR5cGUpIHtcbiAgICAgIGNvbnN0IHQgPSBleHBlY3RlZFR5cGUgfHwgJ2kzMic7
XG4gICAgICBpZiAob3AgPT09ICdkaXZfdScpIHsgZW1pdEV4cHIoZXhwci5hcmdzWzBdLCB0KTsg
ZW1pdEV4cHIoZXhwci5hcmdzWzFdLCB0KTsgYncuYnl0ZSh0ID09PSAnaTY0JyA/IE9QX0k2NF9E
SVZfVSA6IE9QX0kzMl9ESVZfVSk7IHJldHVybjsgfVxuICAgICAgaWYgKG9wID09PSAncmVtX3Un
KSB7IGVtaXRFeHByKGV4cHIuYXJnc1swXSwgdCk7IGVtaXRFeHByKGV4cHIuYXJnc1sxXSwgdCk7
IGJ3LmJ5dGUodCA9PT0gJ2k2NCcgPyBPUF9JNjRfUkVNX1UgOiBPUF9JMzJfUkVNX1UpOyByZXR1
cm47IH1cbiAgICAgIGlmIChvcCA9PT0gJ3Nocl91JykgeyBlbWl0RXhwcihleHByLmFyZ3NbMF0s
IHQpOyBlbWl0RXhwcihleHByLmFyZ3NbMV0sIHQpOyBidy5ieXRlKHQgPT09ICdpNjQnID8gT1Bf
STY0X1NIUl9VIDogT1BfSTMyX1NIUl9VKTsgcmV0dXJuOyB9XG4gICAgICBpZiAob3AgPT09ICds
dF91JykgeyBlbWl0RXhwcihleHByLmFyZ3NbMF0sIHQpOyBlbWl0RXhwcihleHByLmFyZ3NbMV0s
IHQpOyBidy5ieXRlKHQgPT09ICdpNjQnID8gT1BfSTY0X0xUX1UgOiBPUF9JMzJfTFRfVSk7IHJl
dHVybjsgfVxuICAgICAgaWYgKG9wID09PSAnZ3RfdScpIHsgZW1pdEV4cHIoZXhwci5hcmdzWzBd
LCB0KTsgZW1pdEV4cHIoZXhwci5hcmdzWzFdLCB0KTsgYncuYnl0ZSh0ID09PSAnaTY0JyA/IE9Q
X0k2NF9HVF9VIDogT1BfSTMyX0dUX1UpOyByZXR1cm47IH1cbiAgICAgIGlmIChvcCA9PT0gJ2xl
X3UnKSB7IGVtaXRFeHByKGV4cHIuYXJnc1swXSwgdCk7IGVtaXRFeHByKGV4cHIuYXJnc1sxXSwg
dCk7IGJ3LmJ5dGUodCA9PT0gJ2k2NCcgPyBPUF9JNjRfTEVfVSA6IE9QX0kzMl9MRV9VKTsgcmV0
dXJuOyB9XG4gICAgICBpZiAob3AgPT09ICdnZV91JykgeyBlbWl0RXhwcihleHByLmFyZ3NbMF0s
IHQpOyBlbWl0RXhwcihleHByLmFyZ3NbMV0sIHQpOyBidy5ieXRlKHQgPT09ICdpNjQnID8gT1Bf
STY0X0dFX1UgOiBPUF9JMzJfR0VfVSk7IHJldHVybjsgfVxuICAgICAgaWYgKG9wID09PSAncmVp
bnRlcnByZXRfZjY0JykgeyBlbWl0RXhwcihleHByLmFyZ3NbMF0sICdmNjQnKTsgYncuYnl0ZShP
UF9JNjRfUkVJTlRFUlBSRVRfRjY0KTsgcmV0dXJuOyB9XG4gICAgICBpZiAob3AgPT09ICdyZWlu
dGVycHJldF9mMzInKSB7IGVtaXRFeHByKGV4cHIuYXJnc1swXSwgJ2YzMicpOyBidy5ieXRlKE9Q
X0kzMl9SRUlOVEVSUFJFVF9GMzIpOyByZXR1cm47IH1cbiAgICAgIGlmIChvcCA9PT0gJ3JlaW50
ZXJwcmV0X2k2NCcpIHsgZW1pdEV4cHIoZXhwci5hcmdzWzBdLCAnaTY0Jyk7IGJ3LmJ5dGUoT1Bf
RjY0X1JFSU5URVJQUkVUX0k2NCk7IHJldHVybjsgfVxuICAgICAgaWYgKG9wID09PSAncmVpbnRl
cnByZXRfaTMyJykgeyBlbWl0RXhwcihleHByLmFyZ3NbMF0sICdpMzInKTsgYncuYnl0ZShPUF9G
MzJfUkVJTlRFUlBSRVRfSTMyKTsgcmV0dXJuOyB9XG4gICAgICBpZiAob3AgPT09ICdleHRlbmQ4
X3MnKSB7IGVtaXRFeHByKGV4cHIuYXJnc1swXSwgdCk7IGJ3LmJ5dGUodCA9PT0gJ2k2NCcgPyBP
UF9JNjRfRVhURU5EOF9TIDogT1BfSTMyX0VYVEVORDhfUyk7IHJldHVybjsgfVxuICAgICAgaWYg
KG9wID09PSAnZXh0ZW5kMTZfcycpIHsgZW1pdEV4cHIoZXhwci5hcmdzWzBdLCB0KTsgYncuYnl0
ZSh0ID09PSAnaTY0JyA/IE9QX0k2NF9FWFRFTkQxNl9TIDogT1BfSTMyX0VYVEVORDE2X1MpOyBy
ZXR1cm47IH1cbiAgICAgIGlmIChvcCA9PT0gJ3RydW5jX3NhdF9zJykge1xuICAgICAgICBjb25z
dCBmcm9tVHlwZSA9IGluZmVyRXhwclR5cGUoZXhwci5hcmdzWzBdKTtcbiAgICAgICAgZW1pdEV4
cHIoZXhwci5hcmdzWzBdLCBmcm9tVHlwZSk7XG4gICAgICAgIGJ3LmJ5dGUoT1BfRkNfUFJFRklY
KTtcbiAgICAgICAgaWYgKHQgPT09ICdpMzInICYmIGZyb21UeXBlID09PSAnZjMyJykgYncudTMy
KE9QX0kzMl9UUlVOQ19TQVRfRjMyX1MpO1xuICAgICAgICBlbHNlIGlmICh0ID09PSAnaTMyJyAm
JiBmcm9tVHlwZSA9PT0gJ2Y2NCcpIGJ3LnUzMihPUF9JMzJfVFJVTkNfU0FUX0Y2NF9TKTtcbiAg
ICAgICAgZWxzZSBpZiAodCA9PT0gJ2k2NCcgJiYgZnJvbVR5cGUgPT09ICdmMzInKSBidy51MzIo
T1BfSTY0X1RSVU5DX1NBVF9GMzJfUyk7XG4gICAgICAgIGVsc2UgaWYgKHQgPT09ICdpNjQnICYm
IGZyb21UeXBlID09PSAnZjY0JykgYncudTMyKE9QX0k2NF9UUlVOQ19TQVRfRjY0X1MpO1xuICAg
ICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAob3AgPT09ICd0cnVuY19zYXRfdScpIHtc
biAgICAgICAgY29uc3QgZnJvbVR5cGUgPSBpbmZlckV4cHJUeXBlKGV4cHIuYXJnc1swXSk7XG4g
ICAgICAgIGVtaXRFeHByKGV4cHIuYXJnc1swXSwgZnJvbVR5cGUpO1xuICAgICAgICBidy5ieXRl
KE9QX0ZDX1BSRUZJWCk7XG4gICAgICAgIGlmICh0ID09PSAnaTMyJyAmJiBmcm9tVHlwZSA9PT0g
J2YzMicpIGJ3LnUzMihPUF9JMzJfVFJVTkNfU0FUX0YzMl9VKTtcbiAgICAgICAgZWxzZSBpZiAo
dCA9PT0gJ2kzMicgJiYgZnJvbVR5cGUgPT09ICdmNjQnKSBidy51MzIoT1BfSTMyX1RSVU5DX1NB
VF9GNjRfVSk7XG4gICAgICAgIGVsc2UgaWYgKHQgPT09ICdpNjQnICYmIGZyb21UeXBlID09PSAn
ZjMyJykgYncudTMyKE9QX0k2NF9UUlVOQ19TQVRfRjMyX1UpO1xuICAgICAgICBlbHNlIGlmICh0
ID09PSAnaTY0JyAmJiBmcm9tVHlwZSA9PT0gJ2Y2NCcpIGJ3LnUzMihPUF9JNjRfVFJVTkNfU0FU
X0Y2NF9VKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9y
KGBVbmtub3duIHdhc20gYnVpbHRpbjogd2FzbS4ke29wfWApO1xuICAgIH1cblxuICAgIGZ1bmN0
aW9uIGVtaXRWZWN0b3JDb25zdHJ1Y3Rvcih2ZWNUeXBlLCBhcmdzKSB7XG4gICAgICBjb25zdCBz
Y2FsYXIgPSB2ZWN0b3JTY2FsYXJUeXBlKHZlY1R5cGUpO1xuICAgICAgY29uc3QgbGFuZUNvdW50
ID0gdmVjVHlwZSA9PT0gJ2YzMng0JyB8fCB2ZWNUeXBlID09PSAnaTMyeDQnID8gNCA6IDI7XG5c
biAgICAgIGlmIChhcmdzLmxlbmd0aCAhPT0gbGFuZUNvdW50KSB0aHJvdyBuZXcgRXJyb3IoYCR7
dmVjVHlwZX0gY29uc3RydWN0b3IgZXhwZWN0cyAke2xhbmVDb3VudH0gYXJncywgZ290ICR7YXJn
cy5sZW5ndGh9YCk7XG5cbiAgICAgIC8vIENoZWNrIGlmIGFsbCBhcmdzIGFyZSBjb25zdGFudCAo
TnVtYmVyTGl0IG9yIG5lZ2F0aXZlIE51bWJlckxpdClcbiAgICAgIGNvbnN0IGFsbENvbnN0ID0g
YXJncy5ldmVyeShhID0+XG4gICAgICAgIGEudHlwZSA9PT0gJ051bWJlckxpdCcgfHxcbiAgICAg
ICAgKGEudHlwZSA9PT0gJ1VuYXJ5T3AnICYmIGEub3AgPT09ICctJyAmJiBhLm9wZXJhbmQudHlw
ZSA9PT0gJ051bWJlckxpdCcpKTtcblxuICAgICAgaWYgKGFsbENvbnN0KSB7XG4gICAgICAgIC8v
IEVtaXQgdjEyOC5jb25zdCB3aXRoIGlubGluZSBieXRlc1xuICAgICAgICBlbWl0U2ltZChTSU1E
X09QU1sndjEyOC5jb25zdCddKTtcbiAgICAgICAgY29uc3QgYWJ1ZiA9IG5ldyBBcnJheUJ1ZmZl
cigxNik7XG4gICAgICAgIGNvbnN0IHZpZXcgPSBuZXcgRGF0YVZpZXcoYWJ1Zik7XG4gICAgICAg
IGZvciAobGV0IGxpID0gMDsgbGkgPCBsYW5lQ291bnQ7IGxpKyspIHtcbiAgICAgICAgICBjb25z
dCBhID0gYXJnc1tsaV07XG4gICAgICAgICAgY29uc3QgcmF3ID0gYS50eXBlID09PSAnTnVtYmVy
TGl0JyA/IGEudmFsdWUgOiBhLm9wZXJhbmQudmFsdWU7XG4gICAgICAgICAgY29uc3QgdmFsID0g
YS50eXBlID09PSAnVW5hcnlPcCcgPyAtcGFyc2VGbG9hdChyYXcpIDogcGFyc2VGbG9hdChyYXcp
O1xuICAgICAgICAgIGlmIChzY2FsYXIgPT09ICdmNjQnKSB2aWV3LnNldEZsb2F0NjQobGkgKiA4
LCB2YWwsIHRydWUpO1xuICAgICAgICAgIGVsc2UgaWYgKHNjYWxhciA9PT0gJ2YzMicpIHZpZXcu
c2V0RmxvYXQzMihsaSAqIDQsIHZhbCwgdHJ1ZSk7XG4gICAgICAgICAgZWxzZSBpZiAoc2NhbGFy
ID09PSAnaTMyJykgdmlldy5zZXRJbnQzMihsaSAqIDQsIHZhbCB8IDAsIHRydWUpO1xuICAgICAg
ICAgIGVsc2UgaWYgKHNjYWxhciA9PT0gJ2k2NCcpIHtcbiAgICAgICAgICAgIC8vIEJpZ0ludDY0
IGFzIHR3byBpMzJzLCBsaXR0bGUtZW5kaWFuXG4gICAgICAgICAgICBjb25zdCBidiA9IEJpZ0lu
dChNYXRoLnRydW5jKHZhbCkpO1xuICAgICAgICAgICAgdmlldy5zZXRJbnQzMihsaSAqIDgsIE51
bWJlcihidiAmIDB4ZmZmZmZmZmZuKSwgdHJ1ZSk7XG4gICAgICAgICAgICB2aWV3LnNldEludDMy
KGxpICogOCArIDQsIE51bWJlcigoYnYgPj4gMzJuKSAmIDB4ZmZmZmZmZmZuKSwgdHJ1ZSk7XG4g
ICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJ3LmJ5dGVzKG5ldyBVaW50OEFycmF5KGFi
dWYpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFNwbGF0IGZpcnN0IGFyZywgdGhlbiBy
ZXBsYWNlX2xhbmUgZm9yIHRoZSByZXN0XG4gICAgICAgIGVtaXRFeHByKGFyZ3NbMF0sIHNjYWxh
cik7XG4gICAgICAgIGVtaXRTaW1kKFNJTURfT1BTW3ZlY1R5cGUgKyAnLnNwbGF0J10pO1xuICAg
ICAgICBmb3IgKGxldCBsaSA9IDE7IGxpIDwgbGFuZUNvdW50OyBsaSsrKSB7XG4gICAgICAgICAg
ZW1pdEV4cHIoYXJnc1tsaV0sIHNjYWxhcik7XG4gICAgICAgICAgZW1pdFNpbWQoU0lNRF9PUFNb
dmVjVHlwZSArICcucmVwbGFjZV9sYW5lJ10pO1xuICAgICAgICAgIGJ3LmJ5dGUobGkpO1xuICAg
ICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8g4pSA4pSAIFNJTUQgYnVpbHRpbnMg4pSA
4pSAXG4gICAgZnVuY3Rpb24gZW1pdFNpbWRCdWlsdGluKHByZWZpeCwgbWV0aG9kLCBleHByLCBl
eHBlY3RlZFR5cGUpIHtcbiAgICAgIC8vIGY2NHgyLnNwbGF0KHgpLCBpMzJ4NC5zcGxhdCh4KSwg
ZXRjLlxuICAgICAgaWYgKG1ldGhvZCA9PT0gJ3NwbGF0Jykge1xuICAgICAgICBjb25zdCBzY2Fs
YXIgPSB2ZWN0b3JTY2FsYXJUeXBlKHByZWZpeCk7XG4gICAgICAgIGVtaXRFeHByKGV4cHIuYXJn
c1swXSwgc2NhbGFyKTtcbiAgICAgICAgZW1pdFNpbWQoU0lNRF9PUFNbcHJlZml4ICsgJy5zcGxh
dCddKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBmNjR4Mi5leHRyYWN0
X2xhbmUodiwgbGFuZSlcbiAgICAgIGlmIChtZXRob2QgPT09ICdleHRyYWN0X2xhbmUnKSB7XG4g
ICAgICAgIGVtaXRFeHByKGV4cHIuYXJnc1swXSwgcHJlZml4KTtcbiAgICAgICAgZW1pdFNpbWQo
U0lNRF9PUFNbcHJlZml4ICsgJy5leHRyYWN0X2xhbmUnXSk7XG4gICAgICAgIC8vIGxhbmUgbXVz
dCBiZSBhIGNvbnN0YW50XG4gICAgICAgIGlmIChleHByLmFyZ3NbMV0udHlwZSAhPT0gJ051bWJl
ckxpdCcpIHRocm93IG5ldyBFcnJvcignZXh0cmFjdF9sYW5lIHJlcXVpcmVzIGNvbnN0YW50IGxh
bmUgaW5kZXgnKTtcbiAgICAgICAgYncuYnl0ZShwYXJzZUludChleHByLmFyZ3NbMV0udmFsdWUs
IDEwKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gZjY0eDIucmVwbGFj
ZV9sYW5lKHYsIGxhbmUsIHgpXG4gICAgICBpZiAobWV0aG9kID09PSAncmVwbGFjZV9sYW5lJykg
e1xuICAgICAgICBjb25zdCBzY2FsYXIgPSB2ZWN0b3JTY2FsYXJUeXBlKHByZWZpeCk7XG4gICAg
ICAgIGVtaXRFeHByKGV4cHIuYXJnc1swXSwgcHJlZml4KTsgLy8gdjEyOCB2YWx1ZVxuICAgICAg
ICBlbWl0RXhwcihleHByLmFyZ3NbMl0sIHNjYWxhcik7IC8vIHJlcGxhY2VtZW50IHNjYWxhclxu
ICAgICAgICBlbWl0U2ltZChTSU1EX09QU1twcmVmaXggKyAnLnJlcGxhY2VfbGFuZSddKTtcbiAg
ICAgICAgaWYgKGV4cHIuYXJnc1sxXS50eXBlICE9PSAnTnVtYmVyTGl0JykgdGhyb3cgbmV3IEVy
cm9yKCdyZXBsYWNlX2xhbmUgcmVxdWlyZXMgY29uc3RhbnQgbGFuZSBpbmRleCcpO1xuICAgICAg
ICBidy5ieXRlKHBhcnNlSW50KGV4cHIuYXJnc1sxXS52YWx1ZSwgMTApKTtcbiAgICAgICAgcmV0
dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBmNjR4Mi5lcSwgZjY0eDIubmUsIGY2NHgyLmx0LCBm
NjR4Mi5ndCwgZjY0eDIubGUsIGY2NHgyLmdlXG4gICAgICBpZiAoWydlcScsJ25lJywnbHQnLCdn
dCcsJ2xlJywnZ2UnLCdsdF9zJywnZ3RfcycsJ2xlX3MnLCdnZV9zJ10uaW5jbHVkZXMobWV0aG9k
KSkge1xuICAgICAgICBlbWl0RXhwcihleHByLmFyZ3NbMF0sIHByZWZpeCk7XG4gICAgICAgIGVt
aXRFeHByKGV4cHIuYXJnc1sxXSwgcHJlZml4KTtcbiAgICAgICAgY29uc3Qga2V5ID0gcHJlZml4
ICsgJy4nICsgbWV0aG9kO1xuICAgICAgICBjb25zdCBvcCA9IFNJTURfT1BTW2tleV07XG4gICAg
ICAgIGlmIChvcCA9PT0gdW5kZWZpbmVkKSB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gU0lNRCBv
cDogJHtrZXl9YCk7XG4gICAgICAgIGVtaXRTaW1kKG9wKTtcbiAgICAgICAgcmV0dXJuO1xuICAg
ICAgfVxuXG4gICAgICAvLyBmNjR4Mi5uZWcsIGY2NHgyLmFicywgZjY0eDIuc3FydCAodW5hcnkp
XG4gICAgICBpZiAoWyduZWcnLCdhYnMnLCdzcXJ0J10uaW5jbHVkZXMobWV0aG9kKSkge1xuICAg
ICAgICBlbWl0RXhwcihleHByLmFyZ3NbMF0sIHByZWZpeCk7XG4gICAgICAgIGNvbnN0IGtleSA9
IHByZWZpeCArICcuJyArIG1ldGhvZDtcbiAgICAgICAgY29uc3Qgb3AgPSBTSU1EX09QU1trZXld
O1xuICAgICAgICBpZiAob3AgPT09IHVuZGVmaW5lZCkgdGhyb3cgbmV3IEVycm9yKGBVbmtub3du
IFNJTUQgb3A6ICR7a2V5fWApO1xuICAgICAgICBlbWl0U2ltZChvcCk7XG4gICAgICAgIHJldHVy
bjtcbiAgICAgIH1cblxuICAgICAgLy8gZjY0eDIuYWRkLCBmNjR4Mi5zdWIsIGY2NHgyLm11bCwg
ZjY0eDIuZGl2LCBmNjR4Mi5taW4sIGY2NHgyLm1heCAoYmluYXJ5KVxuICAgICAgaWYgKFsnYWRk
Jywnc3ViJywnbXVsJywnZGl2JywnbWluJywnbWF4J10uaW5jbHVkZXMobWV0aG9kKSkge1xuICAg
ICAgICBlbWl0RXhwcihleHByLmFyZ3NbMF0sIHByZWZpeCk7XG4gICAgICAgIGVtaXRFeHByKGV4
cHIuYXJnc1sxXSwgcHJlZml4KTtcbiAgICAgICAgY29uc3Qga2V5ID0gcHJlZml4ICsgJy4nICsg
bWV0aG9kO1xuICAgICAgICBjb25zdCBvcCA9IFNJTURfT1BTW2tleV07XG4gICAgICAgIGlmIChv
cCA9PT0gdW5kZWZpbmVkKSB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gU0lNRCBvcDogJHtrZXl9
YCk7XG4gICAgICAgIGVtaXRTaW1kKG9wKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4g
ICAgICAvLyB2MTI4LmFuZCwgdjEyOC5vciwgdjEyOC54b3IgKGJpbmFyeSBiaXR3aXNlKVxuICAg
ICAgaWYgKHByZWZpeCA9PT0gJ3YxMjgnICYmIFsnYW5kJywnb3InLCd4b3InXS5pbmNsdWRlcyht
ZXRob2QpKSB7XG4gICAgICAgIC8vIEluZmVyIG9wZXJhbmQgdHlwZSBmcm9tIGZpcnN0IGFyZ1xu
ICAgICAgICBjb25zdCB2dCA9IGluZmVyRXhwclR5cGUoZXhwci5hcmdzWzBdKTtcbiAgICAgICAg
ZW1pdEV4cHIoZXhwci5hcmdzWzBdLCB2dCk7XG4gICAgICAgIGVtaXRFeHByKGV4cHIuYXJnc1sx
XSwgdnQpO1xuICAgICAgICBlbWl0U2ltZChTSU1EX09QU1sndjEyOC4nICsgbWV0aG9kXSk7XG4g
ICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gdjEyOC5ub3QgKHVuYXJ5IGJpdHdp
c2UpXG4gICAgICBpZiAocHJlZml4ID09PSAndjEyOCcgJiYgbWV0aG9kID09PSAnbm90Jykge1xu
ICAgICAgICBjb25zdCB2dCA9IGluZmVyRXhwclR5cGUoZXhwci5hcmdzWzBdKTtcbiAgICAgICAg
ZW1pdEV4cHIoZXhwci5hcmdzWzBdLCB2dCk7XG4gICAgICAgIGVtaXRTaW1kKFNJTURfT1BTWyd2
MTI4Lm5vdCddKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyB2MTI4Lmxv
YWQoYXJyLCBpKSDigJQgbG9hZCAxNiBieXRlcyBmcm9tIG1lbW9yeSBhdCBhcnIgKyBpICogMTZc
biAgICAgIGlmIChwcmVmaXggPT09ICd2MTI4JyAmJiBtZXRob2QgPT09ICdsb2FkJykge1xuICAg
ICAgICAvLyBDb21wdXRlIGFkZHJlc3M6IGFyciArIGkgKiAxNlxuICAgICAgICBlbWl0RXhwcihl
eHByLmFyZ3NbMF0sICdpMzInKTsgLy8gYmFzZSBwb2ludGVyXG4gICAgICAgIGVtaXRFeHByKGV4
cHIuYXJnc1sxXSwgJ2kzMicpOyAvLyBpbmRleFxuICAgICAgICBidy5ieXRlKE9QX0kzMl9DT05T
VCk7IGJ3LnMzMigxNik7XG4gICAgICAgIGJ3LmJ5dGUoT1BfSTMyX01VTCk7XG4gICAgICAgIGJ3
LmJ5dGUoT1BfSTMyX0FERCk7XG4gICAgICAgIGVtaXRTaW1kKFNJTURfT1BTWyd2MTI4LmxvYWQn
XSk7IGJ3LnUzMig0KTsgYncudTMyKDApOyAvLyBhbGlnbj0xNlxuICAgICAgICByZXR1cm47XG4g
ICAgICB9XG5cbiAgICAgIC8vIHYxMjguc3RvcmUoYXJyLCBpLCB2KSDigJQgc3RvcmUgMTYgYnl0
ZXMgdG8gbWVtb3J5IGF0IGFyciArIGkgKiAxNlxuICAgICAgaWYgKHByZWZpeCA9PT0gJ3YxMjgn
ICYmIG1ldGhvZCA9PT0gJ3N0b3JlJykge1xuICAgICAgICAvLyBDb21wdXRlIGFkZHJlc3NcbiAg
ICAgICAgZW1pdEV4cHIoZXhwci5hcmdzWzBdLCAnaTMyJyk7XG4gICAgICAgIGVtaXRFeHByKGV4
cHIuYXJnc1sxXSwgJ2kzMicpO1xuICAgICAgICBidy5ieXRlKE9QX0kzMl9DT05TVCk7IGJ3LnMz
MigxNik7XG4gICAgICAgIGJ3LmJ5dGUoT1BfSTMyX01VTCk7XG4gICAgICAgIGJ3LmJ5dGUoT1Bf
STMyX0FERCk7XG4gICAgICAgIC8vIEVtaXQgdmFsdWVcbiAgICAgICAgY29uc3QgdnQgPSBpbmZl
ckV4cHJUeXBlKGV4cHIuYXJnc1syXSk7XG4gICAgICAgIGVtaXRFeHByKGV4cHIuYXJnc1syXSwg
dnQpO1xuICAgICAgICBlbWl0U2ltZChTSU1EX09QU1sndjEyOC5zdG9yZSddKTsgYncudTMyKDQp
OyBidy51MzIoMCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhyb3cgbmV3
IEVycm9yKGBVbmtub3duIFNJTUQgYnVpbHRpbjogJHtwcmVmaXh9LiR7bWV0aG9kfWApO1xuICAg
IH1cblxuICAgIC8vIOKUgOKUgCBUeXBlIGNvbnZlcnNpb24g4pSA4pSAXG4gICAgZnVuY3Rpb24g
ZW1pdENvbnZlcnNpb24oZnJvbSwgdG8pIHtcbiAgICAgIGlmIChmcm9tID09PSB0bykgcmV0dXJu
O1xuICAgICAgaWYgKGZyb20gPT09ICdpMzInICYmIHRvID09PSAnZjY0JykgYncuYnl0ZShPUF9G
NjRfQ09OVkVSVF9JMzJfUyk7XG4gICAgICBlbHNlIGlmIChmcm9tID09PSAnaTMyJyAmJiB0byA9
PT0gJ2YzMicpIGJ3LmJ5dGUoT1BfRjMyX0NPTlZFUlRfSTMyX1MpO1xuICAgICAgZWxzZSBpZiAo
ZnJvbSA9PT0gJ2kzMicgJiYgdG8gPT09ICdpNjQnKSBidy5ieXRlKE9QX0k2NF9FWFRFTkRfSTMy
X1MpO1xuICAgICAgZWxzZSBpZiAoZnJvbSA9PT0gJ2k2NCcgJiYgdG8gPT09ICdpMzInKSBidy5i
eXRlKE9QX0kzMl9XUkFQX0k2NCk7XG4gICAgICBlbHNlIGlmIChmcm9tID09PSAnaTY0JyAmJiB0
byA9PT0gJ2Y2NCcpIGJ3LmJ5dGUoT1BfRjY0X0NPTlZFUlRfSTY0X1MpO1xuICAgICAgZWxzZSBp
ZiAoZnJvbSA9PT0gJ2k2NCcgJiYgdG8gPT09ICdmMzInKSBidy5ieXRlKE9QX0YzMl9DT05WRVJU
X0k2NF9TKTtcbiAgICAgIGVsc2UgaWYgKGZyb20gPT09ICdmNjQnICYmIHRvID09PSAnaTMyJykg
YncuYnl0ZShPUF9JMzJfVFJVTkNfRjY0X1MpO1xuICAgICAgZWxzZSBpZiAoZnJvbSA9PT0gJ2Y2
NCcgJiYgdG8gPT09ICdpNjQnKSBidy5ieXRlKE9QX0k2NF9UUlVOQ19GNjRfUyk7XG4gICAgICBl
bHNlIGlmIChmcm9tID09PSAnZjY0JyAmJiB0byA9PT0gJ2YzMicpIGJ3LmJ5dGUoT1BfRjMyX0RF
TU9URV9GNjQpO1xuICAgICAgZWxzZSBpZiAoZnJvbSA9PT0gJ2YzMicgJiYgdG8gPT09ICdmNjQn
KSBidy5ieXRlKE9QX0Y2NF9QUk9NT1RFX0YzMik7XG4gICAgICBlbHNlIGlmIChmcm9tID09PSAn
ZjMyJyAmJiB0byA9PT0gJ2kzMicpIGJ3LmJ5dGUoT1BfSTMyX1RSVU5DX0YzMl9TKTtcbiAgICAg
IGVsc2UgaWYgKGZyb20gPT09ICdmMzInICYmIHRvID09PSAnaTY0JykgYncuYnl0ZShPUF9JNjRf
VFJVTkNfRjMyX1MpO1xuICAgICAgZWxzZSB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBjb252ZXJ0
ICR7ZnJvbX0gdG8gJHt0b31gKTtcbiAgICB9XG5cbiAgICAvLyDilIDilIAgTWVtb3J5IGFjY2Vz
cyDilIDilIAgYXJyYXkgYWRkcmVzc2luZzogYmFzZSArIGluZGV4ICogc2l6ZW9mKGVsZW1UeXBl
KVxuICAgIGZ1bmN0aW9uIGVtaXRBcnJheUFkZHIobmFtZSwgaW5kaWNlcywgaW5mbywgZWxlbVR5
cGUpIHtcbiAgICAgIC8vIEJhc2UgcG9pbnRlclxuICAgICAgYncuYnl0ZShPUF9MT0NBTF9HRVQp
O1xuICAgICAgYncudTMyKGluZm8uaWR4KTtcblxuICAgICAgY29uc3Qgc3ogPSB0eXBlU2l6ZShl
bGVtVHlwZSk7XG5cbiAgICAgIGlmIChpbmRpY2VzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAv
LyAxRDogYmFzZSArIGkgKiBzaXplb2ZcbiAgICAgICAgZW1pdEV4cHIoaW5kaWNlc1swXSwgJ2kz
MicpO1xuICAgICAgICBidy5ieXRlKE9QX0kzMl9DT05TVCk7IGJ3LnMzMihzeik7XG4gICAgICAg
IGJ3LmJ5dGUoT1BfSTMyX01VTCk7XG4gICAgICAgIGJ3LmJ5dGUoT1BfSTMyX0FERCk7XG4gICAg
ICB9IGVsc2UgaWYgKGluZGljZXMubGVuZ3RoID09PSAzICYmICFpbmZvLmFycmF5RGltcykge1xu
ICAgICAgICAvLyAyRCB3aXRoIGV4cGxpY2l0IHN0cmlkZTogYVtpLCBzdHJpZGUsIGpdIOKGkiBi
YXNlICsgKGkqc3RyaWRlICsgaikgKiBzaXplb2ZcbiAgICAgICAgZW1pdEV4cHIoaW5kaWNlc1sw
XSwgJ2kzMicpO1xuICAgICAgICBlbWl0RXhwcihpbmRpY2VzWzFdLCAnaTMyJyk7XG4gICAgICAg
IGJ3LmJ5dGUoT1BfSTMyX01VTCk7XG4gICAgICAgIGVtaXRFeHByKGluZGljZXNbMl0sICdpMzIn
KTtcbiAgICAgICAgYncuYnl0ZShPUF9JMzJfQUREKTtcbiAgICAgICAgYncuYnl0ZShPUF9JMzJf
Q09OU1QpOyBidy5zMzIoc3opO1xuICAgICAgICBidy5ieXRlKE9QX0kzMl9NVUwpO1xuICAgICAg
ICBidy5ieXRlKE9QX0kzMl9BREQpO1xuICAgICAgfSBlbHNlIGlmIChpbmRpY2VzLmxlbmd0aCA9
PT0gMiAmJiBpbmZvLmFycmF5RGltcyAmJiBpbmZvLmFycmF5RGltcy5sZW5ndGggPT09IDIpIHtc
biAgICAgICAgLy8gMkQgd2l0aCBkZWNsYXJlZCBkaW1zOiBhW2ksIGpdIOKGkiBiYXNlICsgKGkq
ZGltMSArIGopICogc2l6ZW9mXG4gICAgICAgIGVtaXRFeHByKGluZGljZXNbMF0sICdpMzInKTtc
biAgICAgICAgZW1pdEV4cHIoaW5mby5hcnJheURpbXNbMV0sICdpMzInKTtcbiAgICAgICAgYncu
Ynl0ZShPUF9JMzJfTVVMKTtcbiAgICAgICAgZW1pdEV4cHIoaW5kaWNlc1sxXSwgJ2kzMicpO1xu
ICAgICAgICBidy5ieXRlKE9QX0kzMl9BREQpO1xuICAgICAgICBidy5ieXRlKE9QX0kzMl9DT05T
VCk7IGJ3LnMzMihzeik7XG4gICAgICAgIGJ3LmJ5dGUoT1BfSTMyX01VTCk7XG4gICAgICAgIGJ3
LmJ5dGUoT1BfSTMyX0FERCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJy
b3IoYFVuc3VwcG9ydGVkIGFycmF5IGluZGV4IHBhdHRlcm4gZm9yICR7bmFtZX1gKTtcbiAgICAg
IH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlbWl0TG9hZCh0KSB7XG4gICAgICBpZiAodCA9PT0g
J2kzMicpIHsgYncuYnl0ZShPUF9JMzJfTE9BRCk7IGJ3LnUzMigyKTsgYncudTMyKDApOyB9IC8v
IGFsaWduPTRcbiAgICAgIGVsc2UgaWYgKHQgPT09ICdpNjQnKSB7IGJ3LmJ5dGUoT1BfSTY0X0xP
QUQpOyBidy51MzIoMyk7IGJ3LnUzMigwKTsgfVxuICAgICAgZWxzZSBpZiAodCA9PT0gJ2YzMicp
IHsgYncuYnl0ZShPUF9GMzJfTE9BRCk7IGJ3LnUzMigyKTsgYncudTMyKDApOyB9XG4gICAgICBl
bHNlIGlmICh0ID09PSAnZjY0JykgeyBidy5ieXRlKE9QX0Y2NF9MT0FEKTsgYncudTMyKDMpOyBi
dy51MzIoMCk7IH1cbiAgICAgIGVsc2UgaWYgKGlzVmVjdG9yKHQpKSB7IGVtaXRTaW1kKFNJTURf
T1BTWyd2MTI4LmxvYWQnXSk7IGJ3LnUzMig0KTsgYncudTMyKDApOyB9IC8vIGFsaWduPTE2XG4g
ICAgfVxuXG4gICAgZnVuY3Rpb24gZW1pdFN0b3JlKHQpIHtcbiAgICAgIGlmICh0ID09PSAnaTMy
JykgeyBidy5ieXRlKE9QX0kzMl9TVE9SRSk7IGJ3LnUzMigyKTsgYncudTMyKDApOyB9XG4gICAg
ICBlbHNlIGlmICh0ID09PSAnaTY0JykgeyBidy5ieXRlKE9QX0k2NF9TVE9SRSk7IGJ3LnUzMigz
KTsgYncudTMyKDApOyB9XG4gICAgICBlbHNlIGlmICh0ID09PSAnZjMyJykgeyBidy5ieXRlKE9Q
X0YzMl9TVE9SRSk7IGJ3LnUzMigyKTsgYncudTMyKDApOyB9XG4gICAgICBlbHNlIGlmICh0ID09
PSAnZjY0JykgeyBidy5ieXRlKE9QX0Y2NF9TVE9SRSk7IGJ3LnUzMigzKTsgYncudTMyKDApOyB9
XG4gICAgICBlbHNlIGlmIChpc1ZlY3Rvcih0KSkgeyBlbWl0U2ltZChTSU1EX09QU1sndjEyOC5z
dG9yZSddKTsgYncudTMyKDQpOyBidy51MzIoMCk7IH0gLy8gYWxpZ249MTZcbiAgICB9XG5cbiAg
ICAvLyDilIDilIAgQ29tcGFyaXNvbiArIGFyaXRobWV0aWMgaGVscGVycyDilIDilIBcbiAgICBm
dW5jdGlvbiBlbWl0Q21wKG9wLCB0KSB7XG4gICAgICBpZiAodCA9PT0gJ2Y2NCcpIHtcbiAgICAg
ICAgaWYgKG9wID09PSAnPT0nKSBidy5ieXRlKE9QX0Y2NF9FUSk7XG4gICAgICAgIGVsc2UgaWYg
KG9wID09PSAnLz0nKSBidy5ieXRlKE9QX0Y2NF9ORSk7XG4gICAgICAgIGVsc2UgaWYgKG9wID09
PSAnPCcpIGJ3LmJ5dGUoT1BfRjY0X0xUKTtcbiAgICAgICAgZWxzZSBpZiAob3AgPT09ICc+Jykg
YncuYnl0ZShPUF9GNjRfR1QpO1xuICAgICAgICBlbHNlIGlmIChvcCA9PT0gJzw9JykgYncuYnl0
ZShPUF9GNjRfTEUpO1xuICAgICAgICBlbHNlIGlmIChvcCA9PT0gJz49JykgYncuYnl0ZShPUF9G
NjRfR0UpO1xuICAgICAgfSBlbHNlIGlmICh0ID09PSAnZjMyJykge1xuICAgICAgICBpZiAob3Ag
PT09ICc9PScpIGJ3LmJ5dGUoT1BfRjMyX0VRKTtcbiAgICAgICAgZWxzZSBpZiAob3AgPT09ICcv
PScpIGJ3LmJ5dGUoT1BfRjMyX05FKTtcbiAgICAgICAgZWxzZSBpZiAob3AgPT09ICc8JykgYncu
Ynl0ZShPUF9GMzJfTFQpO1xuICAgICAgICBlbHNlIGlmIChvcCA9PT0gJz4nKSBidy5ieXRlKE9Q
X0YzMl9HVCk7XG4gICAgICAgIGVsc2UgaWYgKG9wID09PSAnPD0nKSBidy5ieXRlKE9QX0YzMl9M
RSk7XG4gICAgICAgIGVsc2UgaWYgKG9wID09PSAnPj0nKSBidy5ieXRlKE9QX0YzMl9HRSk7XG4g
ICAgICB9IGVsc2UgaWYgKHQgPT09ICdpMzInKSB7XG4gICAgICAgIGlmIChvcCA9PT0gJz09Jykg
YncuYnl0ZShPUF9JMzJfRVEpO1xuICAgICAgICBlbHNlIGlmIChvcCA9PT0gJy89JykgYncuYnl0
ZShPUF9JMzJfTkUpO1xuICAgICAgICBlbHNlIGlmIChvcCA9PT0gJzwnKSBidy5ieXRlKE9QX0kz
Ml9MVF9TKTtcbiAgICAgICAgZWxzZSBpZiAob3AgPT09ICc+JykgYncuYnl0ZShPUF9JMzJfR1Rf
Uyk7XG4gICAgICAgIGVsc2UgaWYgKG9wID09PSAnPD0nKSBidy5ieXRlKE9QX0kzMl9MRV9TKTtc
biAgICAgICAgZWxzZSBpZiAob3AgPT09ICc+PScpIGJ3LmJ5dGUoT1BfSTMyX0dFX1MpO1xuICAg
ICAgfSBlbHNlIGlmICh0ID09PSAnaTY0Jykge1xuICAgICAgICBpZiAob3AgPT09ICc9PScpIGJ3
LmJ5dGUoT1BfSTY0X0VRKTtcbiAgICAgICAgZWxzZSBpZiAob3AgPT09ICcvPScpIGJ3LmJ5dGUo
T1BfSTY0X05FKTtcbiAgICAgICAgZWxzZSBpZiAob3AgPT09ICc8JykgYncuYnl0ZShPUF9JNjRf
TFRfUyk7XG4gICAgICAgIGVsc2UgaWYgKG9wID09PSAnPicpIGJ3LmJ5dGUoT1BfSTY0X0dUX1Mp
O1xuICAgICAgICBlbHNlIGlmIChvcCA9PT0gJzw9JykgYncuYnl0ZShPUF9JNjRfTEVfUyk7XG4g
ICAgICAgIGVsc2UgaWYgKG9wID09PSAnPj0nKSBidy5ieXRlKE9QX0k2NF9HRV9TKTtcbiAgICAg
IH0gZWxzZSBpZiAoaXNWZWN0b3IodCkpIHtcbiAgICAgICAgLy8gVmVjdG9yIGNvbXBhcmlzb25z
IOKAlCBtYXAgYXRyYSBvcHMgdG8gU0lNRCBvcGNvZGUga2V5c1xuICAgICAgICBjb25zdCBpc0lu
dFZlYyA9ICh0ID09PSAnaTMyeDQnIHx8IHQgPT09ICdpNjR4MicpO1xuICAgICAgICBjb25zdCBz
dWZmaXggPSBpc0ludFZlYyA/ICdfcycgOiAnJztcbiAgICAgICAgbGV0IGtleTtcbiAgICAgICAg
aWYgKG9wID09PSAnPT0nKSBrZXkgPSB0ICsgJy5lcSc7XG4gICAgICAgIGVsc2UgaWYgKG9wID09
PSAnLz0nKSBrZXkgPSB0ICsgJy5uZSc7XG4gICAgICAgIGVsc2UgaWYgKG9wID09PSAnPCcpIGtl
eSA9IHQgKyAoaXNJbnRWZWMgPyAnLmx0X3MnIDogJy5sdCcpO1xuICAgICAgICBlbHNlIGlmIChv
cCA9PT0gJz4nKSBrZXkgPSB0ICsgKGlzSW50VmVjID8gJy5ndF9zJyA6ICcuZ3QnKTtcbiAgICAg
ICAgZWxzZSBpZiAob3AgPT09ICc8PScpIGtleSA9IHQgKyAoaXNJbnRWZWMgPyAnLmxlX3MnIDog
Jy5sZScpO1xuICAgICAgICBlbHNlIGlmIChvcCA9PT0gJz49Jykga2V5ID0gdCArIChpc0ludFZl
YyA/ICcuZ2VfcycgOiAnLmdlJyk7XG4gICAgICAgIGNvbnN0IG9wY29kZSA9IFNJTURfT1BTW2tl
eV07XG4gICAgICAgIGlmIChvcGNvZGUgPT09IHVuZGVmaW5lZCkgdGhyb3cgbmV3IEVycm9yKGBD
b21wYXJpc29uICR7b3B9IG5vdCBzdXBwb3J0ZWQgZm9yICR7dH1gKTtcbiAgICAgICAgZW1pdFNp
bWQob3Bjb2RlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlbWl0QWRkKHQpIHtc
biAgICAgIGlmICh0ID09PSAnZjY0JykgYncuYnl0ZShPUF9GNjRfQUREKTtcbiAgICAgIGVsc2Ug
aWYgKHQgPT09ICdmMzInKSBidy5ieXRlKE9QX0YzMl9BREQpO1xuICAgICAgZWxzZSBpZiAodCA9
PT0gJ2kzMicpIGJ3LmJ5dGUoT1BfSTMyX0FERCk7XG4gICAgICBlbHNlIGlmICh0ID09PSAnaTY0
JykgYncuYnl0ZShPUF9JNjRfQUREKTtcbiAgICAgIGVsc2UgaWYgKGlzVmVjdG9yKHQpKSBlbWl0
U2ltZChTSU1EX09QU1t0ICsgJy5hZGQnXSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZW1pdFN1
Yih0KSB7XG4gICAgICBpZiAodCA9PT0gJ2Y2NCcpIGJ3LmJ5dGUoT1BfRjY0X1NVQik7XG4gICAg
ICBlbHNlIGlmICh0ID09PSAnZjMyJykgYncuYnl0ZShPUF9GMzJfU1VCKTtcbiAgICAgIGVsc2Ug
aWYgKHQgPT09ICdpMzInKSBidy5ieXRlKE9QX0kzMl9TVUIpO1xuICAgICAgZWxzZSBpZiAodCA9
PT0gJ2k2NCcpIGJ3LmJ5dGUoT1BfSTY0X1NVQik7XG4gICAgICBlbHNlIGlmIChpc1ZlY3Rvcih0
KSkgZW1pdFNpbWQoU0lNRF9PUFNbdCArICcuc3ViJ10pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9u
IGVtaXRNdWwodCkge1xuICAgICAgaWYgKHQgPT09ICdmNjQnKSBidy5ieXRlKE9QX0Y2NF9NVUwp
O1xuICAgICAgZWxzZSBpZiAodCA9PT0gJ2YzMicpIGJ3LmJ5dGUoT1BfRjMyX01VTCk7XG4gICAg
ICBlbHNlIGlmICh0ID09PSAnaTMyJykgYncuYnl0ZShPUF9JMzJfTVVMKTtcbiAgICAgIGVsc2Ug
aWYgKHQgPT09ICdpNjQnKSBidy5ieXRlKE9QX0k2NF9NVUwpO1xuICAgICAgZWxzZSBpZiAoaXNW
ZWN0b3IodCkpIGVtaXRTaW1kKFNJTURfT1BTW3QgKyAnLm11bCddKTtcbiAgICB9XG5cbiAgICBm
dW5jdGlvbiBlbWl0RGl2KHQpIHtcbiAgICAgIGlmICh0ID09PSAnZjY0JykgYncuYnl0ZShPUF9G
NjRfRElWKTtcbiAgICAgIGVsc2UgaWYgKHQgPT09ICdmMzInKSBidy5ieXRlKE9QX0YzMl9ESVYp
O1xuICAgICAgZWxzZSBpZiAodCA9PT0gJ2kzMicpIGJ3LmJ5dGUoT1BfSTMyX0RJVl9TKTtcbiAg
ICAgIGVsc2UgaWYgKHQgPT09ICdpNjQnKSBidy5ieXRlKE9QX0k2NF9ESVZfUyk7XG4gICAgICBl
bHNlIGlmIChpc1ZlY3Rvcih0KSkge1xuICAgICAgICBjb25zdCBvcCA9IFNJTURfT1BTW3QgKyAn
LmRpdiddO1xuICAgICAgICBpZiAoIW9wKSB0aHJvdyBuZXcgRXJyb3IoJ0RpdmlzaW9uIG5vdCBz
dXBwb3J0ZWQgZm9yICcgKyB0KTtcbiAgICAgICAgZW1pdFNpbWQob3ApO1xuICAgICAgfVxuICAg
IH1cblxuICAgIC8vIOKUgOKUgCBFbWl0IGZ1bmN0aW9uIGJvZHkgc3RhdGVtZW50cyDilIDilIBc
biAgICBlbWl0U3RtdHMoZm4uYm9keSk7XG5cbiAgICAvLyDilIDilIAgRW5kIG9mIGZ1bmN0aW9u
IGJvZHk6IHJldHVybiB2YWx1ZSDilIDilIBcbiAgICBpZiAoaXNGdW5jKSB7XG4gICAgICBidy5i
eXRlKE9QX0xPQ0FMX0dFVCk7XG4gICAgICBidy51MzIobG9jYWxNYXBbJyRfcmV0dXJuJ10uaWR4
KTtcbiAgICB9XG4gICAgYncuYnl0ZShPUF9FTkQpO1xuICB9XG59XG5cbi8vIC0tIGF0cmEuanMg
LS1cblxuLy8gUHVibGljIEFQSSDigJQgdGFnZ2VkIHRlbXBsYXRlLCAuY29tcGlsZSwgLnBhcnNl
LCAuZHVtcCwgLnJ1biwgc2VsZi1yZWdpc3RyYXRpb25cbi8vXG4vLyBQaXBlbGluZTogc291cmNl
IOKGkiBsZXgg4oaSIHBhcnNlIOKGkiBjb2RlZ2VuIOKGkiBieXRlcyDihpIgV2ViQXNzZW1ibHku
TW9kdWxlIOKGkiBleHBvcnRzXG5cblxuXG5cblxuZnVuY3Rpb24gY29tcGlsZVNvdXJjZShzb3Vy
Y2UsIGludGVycFZhbHVlcywgdXNlckltcG9ydHMpIHtcbiAgY29uc3QgdG9rZW5zID0gbGV4KHNv
dXJjZSk7XG4gIGNvbnN0IGFzdCA9IHBhcnNlKHRva2Vucyk7XG4gIHJldHVybiBjb2RlZ2VuKGFz
dCwgaW50ZXJwVmFsdWVzLCB1c2VySW1wb3J0cyk7XG59XG5cbmZ1bmN0aW9uIGluc3RhbnRpYXRl
KGJ5dGVzLCB1c2VySW1wb3J0cywgaW50ZXJwVmFsdWVzKSB7XG4gIGNvbnN0IGltcG9ydE9iaiA9
IHtcbiAgICBtYXRoOiB7IHNpbjogTWF0aC5zaW4sIGNvczogTWF0aC5jb3MsIGxuOiBNYXRoLmxv
ZywgZXhwOiBNYXRoLmV4cCwgcG93OiBNYXRoLnBvdywgYXRhbjI6IE1hdGguYXRhbjIgfSxcbiAg
ICBob3N0OiB7fSxcbiAgfTtcbiAgaWYgKHVzZXJJbXBvcnRzKSB7XG4gICAgY29uc3QgZmxhdCA9
IGZsYXR0ZW5JbXBvcnRzKHVzZXJJbXBvcnRzKTtcbiAgICBmb3IgKGNvbnN0IFtrLCB2XSBvZiBP
YmplY3QuZW50cmllcyhmbGF0KSkgaW1wb3J0T2JqLmhvc3Rba10gPSB2O1xuICB9XG5cbiAgLy8g
SW50ZXJwb2xhdGVkIGltcG9ydHNcbiAgaWYgKGludGVycFZhbHVlcykge1xuICAgIGZvciAobGV0
IGkgPSAwOyBpIDwgaW50ZXJwVmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCB2ID0g
aW50ZXJwVmFsdWVzW2ldO1xuICAgICAgaWYgKHR5cGVvZiB2ID09PSAnZnVuY3Rpb24nKSB7XG4g
ICAgICAgIGltcG9ydE9iai5ob3N0WydfX0lOVEVSUF8nICsgaSArICdfXyddID0gdjtcbiAgICAg
IH1cbiAgICB9XG4gIH1cblxuICAvLyBNZW1vcnlcbiAgaWYgKHVzZXJJbXBvcnRzICYmIHVzZXJJ
bXBvcnRzLl9fbWVtb3J5KSB7XG4gICAgaWYgKCFpbXBvcnRPYmouZW52KSBpbXBvcnRPYmouZW52
ID0ge307XG4gICAgaW1wb3J0T2JqLmVudi5tZW1vcnkgPSB1c2VySW1wb3J0cy5fX21lbW9yeTtc
biAgfVxuXG4gIGNvbnN0IG1vZCA9IG5ldyBXZWJBc3NlbWJseS5Nb2R1bGUoYnl0ZXMpO1xuICBj
b25zdCBpbnN0YW5jZSA9IG5ldyBXZWJBc3NlbWJseS5JbnN0YW5jZShtb2QsIGltcG9ydE9iaik7
XG4gIHJldHVybiBpbnN0YW5jZTtcbn1cblxuZnVuY3Rpb24gd3JhcEV4cG9ydHMoaW5zdGFuY2Us
IHRhYmxlKSB7XG4gIGNvbnN0IGV4cG9ydHMgPSBPYmplY3QuY3JlYXRlKGluc3RhbmNlLmV4cG9y
dHMpO1xuICBpZiAodGFibGUpIGV4cG9ydHMuX190YWJsZSA9IHRhYmxlO1xuICAvLyBOZXN0IGRv
dHRlZCBleHBvcnQgbmFtZXM6IFwicGh5c2ljcy5ncmF2aXR5XCIg4oaSIGV4cG9ydHMucGh5c2lj
cy5ncmF2aXR5XG4gIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKGluc3RhbmNlLmV4cG9y
dHMpKSB7XG4gICAgaWYgKGtleS5pbmNsdWRlcygnLicpKSB7XG4gICAgICBjb25zdCBwYXJ0cyA9
IGtleS5zcGxpdCgnLicpO1xuICAgICAgbGV0IG9iaiA9IGV4cG9ydHM7XG4gICAgICBmb3IgKGxl
dCBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICBpZiAoIW9ialtw
YXJ0c1tpXV0gfHwgdHlwZW9mIG9ialtwYXJ0c1tpXV0gIT09ICdvYmplY3QnKSBvYmpbcGFydHNb
aV1dID0ge307XG4gICAgICAgIG9iaiA9IG9ialtwYXJ0c1tpXV07XG4gICAgICB9XG4gICAgICBv
YmpbcGFydHNbcGFydHMubGVuZ3RoIC0gMV1dID0gaW5zdGFuY2UuZXhwb3J0c1trZXldO1xuICAg
IH1cbiAgfVxuICByZXR1cm4gZXhwb3J0cztcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplTWVtb3J5
SW1wb3J0KHVzZXJJbXBvcnRzKSB7XG4gIGlmICh1c2VySW1wb3J0cyAmJiB1c2VySW1wb3J0cy5t
ZW1vcnkgJiYgIXVzZXJJbXBvcnRzLl9fbWVtb3J5KSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3Np
Z24oe30sIHVzZXJJbXBvcnRzLCB7IF9fbWVtb3J5OiB1c2VySW1wb3J0cy5tZW1vcnkgfSk7XG4g
IH1cbiAgcmV0dXJuIHVzZXJJbXBvcnRzO1xufVxuXG5mdW5jdGlvbiBjb21waWxlQW5kSW5zdGFu
dGlhdGUoc3RyaW5ncywgdmFsdWVzLCB1c2VySW1wb3J0cykge1xuICB1c2VySW1wb3J0cyA9IG5v
cm1hbGl6ZU1lbW9yeUltcG9ydCh1c2VySW1wb3J0cyk7XG4gIC8vIEpvaW4gdGVtcGxhdGUgc3Ry
aW5ncyB3aXRoIGludGVycG9sYXRpb24gbWFya2Vyc1xuICBsZXQgc291cmNlID0gc3RyaW5nc1sw
XTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAvLyBO
dW1iZXJzIGFuZCBzdHJpbmdzIGlubGluZSBkaXJlY3RseSBpbnRvIHNvdXJjZSB0ZXh0LlxuICAg
IC8vIFN0cmluZ3MgYWN0IGFzIHNvdXJjZSBpbmNsdXNpb24gKGxpa2UgI2luY2x1ZGUpLlxuICAg
IC8vIEZ1bmN0aW9ucyBiZWNvbWUgX19JTlRFUlBfTl9fIG1hcmtlcnMsIHJlc29sdmVkIGFzIGhv
c3QgaW1wb3J0cyBieSBjb2RlZ2VuLlxuICAgIGlmICh0eXBlb2YgdmFsdWVzW2ldID09PSAnbnVt
YmVyJykge1xuICAgICAgc291cmNlICs9IFN0cmluZyh2YWx1ZXNbaV0pO1xuICAgIH0gZWxzZSBp
ZiAodHlwZW9mIHZhbHVlc1tpXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHNvdXJjZSArPSB2YWx1
ZXNbaV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHNvdXJjZSArPSAnX19JTlRFUlBfJyArIGkgKyAn
X18nO1xuICAgIH1cbiAgICBzb3VyY2UgKz0gc3RyaW5nc1tpICsgMV07XG4gIH1cblxuICBjb25z
dCB7IGJ5dGVzLCB0YWJsZSB9ID0gY29tcGlsZVNvdXJjZShzb3VyY2UsIHZhbHVlcywgdXNlcklt
cG9ydHMpO1xuICBjb25zdCBpbnN0YW5jZSA9IGluc3RhbnRpYXRlKGJ5dGVzLCB1c2VySW1wb3J0
cywgdmFsdWVzKTtcbiAgcmV0dXJuIHdyYXBFeHBvcnRzKGluc3RhbmNlLCB0YWJsZSk7XG59XG5c
bmZ1bmN0aW9uIGF0cmEoc3RyaW5nc09yT3B0cywgLi4udmFsdWVzKSB7XG4gIC8vIEN1cnJpZWQg
Zm9ybSBkZXRlY3Rpb246IGF0cmEoe2ltcG9ydHN9KWAuLi5gIHZzIGF0cmFgLi4uYFxuICAvLyBU
YWdnZWQgdGVtcGxhdGVzIHBhc3MgYSBzdHJpbmdzIGFycmF5IHdpdGggYSAucmF3IHByb3BlcnR5
OyBhIHBsYWluIG9iamVjdCB3b24ndCBoYXZlIGl0LlxuICBpZiAoc3RyaW5nc09yT3B0cyAmJiAh
QXJyYXkuaXNBcnJheShzdHJpbmdzT3JPcHRzKSAmJiB0eXBlb2Ygc3RyaW5nc09yT3B0cyA9PT0g
J29iamVjdCcgJiYgIXN0cmluZ3NPck9wdHMucmF3KSB7XG4gICAgY29uc3Qgb3B0cyA9IHN0cmlu
Z3NPck9wdHM7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHN0cmluZ3MsIC4uLnZhbHMpIHtcbiAgICAg
IHJldHVybiBjb21waWxlQW5kSW5zdGFudGlhdGUoc3RyaW5ncywgdmFscywgb3B0cyk7XG4gICAg
fTtcbiAgfVxuICAvLyBEaXJlY3QgZm9ybTogYXRyYWAuLi5gXG4gIHJldHVybiBjb21waWxlQW5k
SW5zdGFudGlhdGUoc3RyaW5nc09yT3B0cywgdmFsdWVzLCBudWxsKTtcbn1cblxuLy8gRGlyZWN0
IGNvbXBpbGVyIGFjY2Vzc1xuYXRyYS5jb21waWxlID0gZnVuY3Rpb24oc291cmNlLCB1c2VySW1w
b3J0cykge1xuICByZXR1cm4gY29tcGlsZVNvdXJjZShzb3VyY2UsIG51bGwsIHVzZXJJbXBvcnRz
IHx8IG51bGwpLmJ5dGVzO1xufTtcblxuYXRyYS5wYXJzZSA9IGZ1bmN0aW9uKHNvdXJjZSkge1xu
ICBjb25zdCB0b2tlbnMgPSBsZXgoc291cmNlKTtcbiAgcmV0dXJuIHBhcnNlKHRva2Vucyk7XG59
O1xuXG5hdHJhLmR1bXAgPSBmdW5jdGlvbihzb3VyY2UpIHtcbiAgY29uc3QgeyBieXRlcyB9ID0g
Y29tcGlsZVNvdXJjZShzb3VyY2UsIG51bGwsIG51bGwpO1xuICByZXR1cm4gQXJyYXkuZnJvbShi
eXRlcykubWFwKGIgPT4gYi50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSkuam9pbignICcp
O1xufTtcblxuYXRyYS5ydW4gPSBmdW5jdGlvbihzb3VyY2UsIHVzZXJJbXBvcnRzKSB7XG4gIHVz
ZXJJbXBvcnRzID0gbm9ybWFsaXplTWVtb3J5SW1wb3J0KHVzZXJJbXBvcnRzKTtcbiAgY29uc3Qg
eyBieXRlcywgdGFibGUgfSA9IGNvbXBpbGVTb3VyY2Uoc291cmNlLCBudWxsLCB1c2VySW1wb3J0
cyk7XG4gIGNvbnN0IGluc3RhbmNlID0gaW5zdGFudGlhdGUoYnl0ZXMsIHVzZXJJbXBvcnRzLCBu
dWxsKTtcbiAgcmV0dXJuIHdyYXBFeHBvcnRzKGluc3RhbmNlLCB0YWJsZSk7XG59O1xuXG4vLyDi
lIDilIAgU2VsZi1yZWdpc3RyYXRpb24g4pSA4pSAXG5cbmlmICh0eXBlb2Ygd2luZG93ICE9PSAn
dW5kZWZpbmVkJykge1xuICBpZiAoIXdpbmRvdy5fdGFnZ2VkTGFuZ3VhZ2VzKSB3aW5kb3cuX3Rh
Z2dlZExhbmd1YWdlcyA9IHt9O1xuICB3aW5kb3cuX3RhZ2dlZExhbmd1YWdlcy5hdHJhID0geyB0
b2tlbml6ZTogdG9rZW5pemVBdHJhLCBjb21wbGV0aW9uczogYXRyYUNvbXBsZXRpb25zIH07XG59
XG5cbi8vIEF0dGFjaCBpbnRlcm5hbHMgZm9yIHRlc3RpbmcgLyBhZHZhbmNlZCB1c2VcbmF0cmEu
X2xleCA9IGxleDtcbmF0cmEuX3BhcnNlID0gcGFyc2U7XG5hdHJhLl90b2tlbml6ZSA9IHRva2Vu
aXplQXRyYTtcblxuZXhwb3J0IHsgYXRyYSB9O1xuIiwiY2VsbElkIjpudWxsfSwiLi9leHQvYXRy
YS9saWIvYWxwYWNrLnNyYy5qcyI6eyJzb3VyY2UiOiIvLyBHZW5lcmF0ZWQgYnkgYXRyYWMg4oCU
IGRvIG5vdCBlZGl0XG5cbmV4cG9ydCBjb25zdCBhbGwgPSBcIiEg4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ
4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ
4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ
4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ
4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQXFxuISBBTEFTIC8gQUxQQUNLIOKAlCBkZW5zZSBsaW5lYXIg
YWxnZWJyYSBmb3IgYXRyYVxcbiFcXG4hIEFMQVMgIChBdWRpdGFibGUgTGluZWFyIEFsZ2VicmEg
U3VicHJvZ3JhbXMpIOKAlCB2ZWN0b3IvbWF0cml4IHByaW1pdGl2ZXNcXG4hIEFMUEFDSyAoQXVk
aXRhYmxlIExpbmVhciBBbGdlYnJhIFBBQ0thZ2UpICAgIOKAlCBmYWN0b3JpemF0aW9ucyAmIHNv
bHZlcnNcXG4hXFxuISBhbGwgbWF0cmljZXMgYXJlIHJvdy1tYWpvciwgZmxhdCBpbiBsaW5lYXIg
bWVtb3J5LlxcbiEgMkQgYWNjZXNzOiBhW2ksIG4sIGpdIHdoZXJlIG4gPSBudW1iZXIgb2YgY29s
dW1ucyAoc3RyaWRlKS5cXG4hIGNhbGxlciBwcm92aWRlcyBhbGwgYnVmZmVycy4gaW5mb1swXSA9
IDAgb24gc3VjY2Vzcy5cXG4hIOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKV
kOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKV
kOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKV
kOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKV
kFxcblxcbiEg4pSA4pSAIEFMQVMgTGV2ZWwgMTogdmVjdG9yLXZlY3RvciDilIDilIDilIDilIDi
lIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDi
lIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIBcXG5cXG4hIHggOj0gYWxw
aGEgKiB4XFxuc3Vicm91dGluZSBhbGFzLmRzY2FsKHg6IGFycmF5IGY2NDsgbjogaTMyOyBhbHBo
YTogZjY0KVxcbnZhciBpOiBpMzJcXG5iZWdpblxcbiAgZm9yIGkgOj0gMCwgblxcbiAgICB4W2ld
IDo9IGFscGhhICogeFtpXVxcbiAgZW5kIGZvclxcbmVuZFxcblxcbiEgeSA6PSB4ICAoY29weSB4
IGludG8geSlcXG5zdWJyb3V0aW5lIGFsYXMuZGNvcHkoeDogYXJyYXkgZjY0OyB5OiBhcnJheSBm
NjQ7IG46IGkzMilcXG52YXIgaTogaTMyXFxuYmVnaW5cXG4gIGZvciBpIDo9IDAsIG5cXG4gICAg
eVtpXSA6PSB4W2ldXFxuICBlbmQgZm9yXFxuZW5kXFxuXFxuISB5IDo9IGFscGhhICogeCArIHlc
XG5zdWJyb3V0aW5lIGFsYXMuZGF4cHkoeDogYXJyYXkgZjY0OyB5OiBhcnJheSBmNjQ7IG46IGkz
MjsgYWxwaGE6IGY2NClcXG52YXJcXG4gIGksIG4yOiBpMzJcXG4gIHZhLCB2eCwgdnk6IGY2NHgy
XFxuYmVnaW5cXG4gICEgc2NhbGFyIHZlcnNpb24gKGZvciByZWZlcmVuY2UpOlxcbiAgISAgIGZv
ciBpIDo9IDAsIG5cXG4gICEgICAgIHlbaV0gOj0gYWxwaGEgKiB4W2ldICsgeVtpXVxcbiAgISAg
IGVuZCBmb3JcXG4gIHZhIDo9IGY2NHgyLnNwbGF0KGFscGhhKVxcbiAgbjIgOj0gbiAvIDJcXG4g
IGZvciBpIDo9IDAsIG4yXFxuICAgIHZ4IDo9IHYxMjgubG9hZCh4LCBpKVxcbiAgICB2eSA6PSB2
MTI4LmxvYWQoeSwgaSlcXG4gICAgdnkgOj0gdmEgKiB2eCArIHZ5XFxuICAgIGNhbGwgdjEyOC5z
dG9yZSh5LCBpLCB2eSlcXG4gIGVuZCBmb3JcXG4gICEgc2NhbGFyIHRhaWwgZm9yIG9kZCBlbGVt
ZW50XFxuICBpZiAobjIgKiAyIDwgbikgdGhlblxcbiAgICBpIDo9IG4yICogMlxcbiAgICB5W2ld
IDo9IGFscGhhICogeFtpXSArIHlbaV1cXG4gIGVuZCBpZlxcbmVuZFxcblxcbiEgcmV0dXJucyB4
XlQgeSAgKGRvdCBwcm9kdWN0KVxcbmZ1bmN0aW9uIGFsYXMuZGRvdCh4OiBhcnJheSBmNjQ7IHk6
IGFycmF5IGY2NDsgbjogaTMyKTogZjY0XFxudmFyXFxuICBpLCBuMjogaTMyXFxuICB2eCwgdnks
IHZzOiBmNjR4MlxcbmJlZ2luXFxuICAhIHNjYWxhciB2ZXJzaW9uOlxcbiAgISAgIGFsYXMuZGRv
dCA6PSAwLjBcXG4gICEgICBmb3IgaSA6PSAwLCBuXFxuICAhICAgICBhbGFzLmRkb3QgOj0gYWxh
cy5kZG90ICsgeFtpXSAqIHlbaV1cXG4gICEgICBlbmQgZm9yXFxuICB2cyA6PSBmNjR4Mi5zcGxh
dCgwLjApXFxuICBuMiA6PSBuIC8gMlxcbiAgZm9yIGkgOj0gMCwgbjJcXG4gICAgdnggOj0gdjEy
OC5sb2FkKHgsIGkpXFxuICAgIHZ5IDo9IHYxMjgubG9hZCh5LCBpKVxcbiAgICB2cyA6PSB2cyAr
IHZ4ICogdnlcXG4gIGVuZCBmb3JcXG4gIGFsYXMuZGRvdCA6PSBmNjR4Mi5leHRyYWN0X2xhbmUo
dnMsIDApICsgZjY0eDIuZXh0cmFjdF9sYW5lKHZzLCAxKVxcbiAgISBzY2FsYXIgdGFpbFxcbiAg
aWYgKG4yICogMiA8IG4pIHRoZW5cXG4gICAgaSA6PSBuMiAqIDJcXG4gICAgYWxhcy5kZG90IDo9
IGFsYXMuZGRvdCArIHhbaV0gKiB5W2ldXFxuICBlbmQgaWZcXG5lbmRcXG5cXG4hIHJldHVybnMg
fHx4fHxfMiAgKEV1Y2xpZGVhbiBub3JtKVxcbmZ1bmN0aW9uIGFsYXMuZG5ybTIoeDogYXJyYXkg
ZjY0OyBuOiBpMzIpOiBmNjRcXG52YXJcXG4gIGksIG4yOiBpMzJcXG4gIHZ4LCB2czogZjY0eDJc
XG5iZWdpblxcbiAgdnMgOj0gZjY0eDIuc3BsYXQoMC4wKVxcbiAgbjIgOj0gbiAvIDJcXG4gIGZv
ciBpIDo9IDAsIG4yXFxuICAgIHZ4IDo9IHYxMjgubG9hZCh4LCBpKVxcbiAgICB2cyA6PSB2cyAr
IHZ4ICogdnhcXG4gIGVuZCBmb3JcXG4gIGFsYXMuZG5ybTIgOj0gZjY0eDIuZXh0cmFjdF9sYW5l
KHZzLCAwKSArIGY2NHgyLmV4dHJhY3RfbGFuZSh2cywgMSlcXG4gIGlmIChuMiAqIDIgPCBuKSB0
aGVuXFxuICAgIGkgOj0gbjIgKiAyXFxuICAgIGFsYXMuZG5ybTIgOj0gYWxhcy5kbnJtMiArIHhb
aV0gKiB4W2ldXFxuICBlbmQgaWZcXG4gIGFsYXMuZG5ybTIgOj0gc3FydChhbGFzLmRucm0yKVxc
bmVuZFxcblxcbiEgc3dhcCB4IGFuZCB5XFxuc3Vicm91dGluZSBhbGFzLmRzd2FwKHg6IGFycmF5
IGY2NDsgeTogYXJyYXkgZjY0OyBuOiBpMzIpXFxudmFyIGk6IGkzMjsgdDogZjY0XFxuYmVnaW5c
XG4gIGZvciBpIDo9IDAsIG5cXG4gICAgdCA6PSB4W2ldXFxuICAgIHhbaV0gOj0geVtpXVxcbiAg
ICB5W2ldIDo9IHRcXG4gIGVuZCBmb3JcXG5lbmRcXG5cXG4hIHJldHVybnMgaW5kZXggb2YgZWxl
bWVudCB3aXRoIG1heCBhYnNvbHV0ZSB2YWx1ZVxcbmZ1bmN0aW9uIGFsYXMuaWRhbWF4KHg6IGFy
cmF5IGY2NDsgbjogaTMyKTogaTMyXFxudmFyIGk6IGkzMjsgbXg6IGY2NDsgdjogZjY0XFxuYmVn
aW5cXG4gIGFsYXMuaWRhbWF4IDo9IDBcXG4gIG14IDo9IGFicyh4WzBdKVxcbiAgZm9yIGkgOj0g
MSwgblxcbiAgICB2IDo9IGFicyh4W2ldKVxcbiAgICBpZiAodiA+IG14KSB0aGVuXFxuICAgICAg
bXggOj0gdlxcbiAgICAgIGFsYXMuaWRhbWF4IDo9IGlcXG4gICAgZW5kIGlmXFxuICBlbmQgZm9y
XFxuZW5kXFxuXFxuISDilIDilIAgQUxBUyBMZXZlbCAyOiBtYXRyaXgtdmVjdG9yIOKUgOKUgOKU
gOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKU
gOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgFxcblxcbiEgeSA6
PSBhbHBoYSAqIEEgKiB4ICsgYmV0YSAqIHkgICAoZ2VuZXJhbCBtYXRyaXgtdmVjdG9yIG11bHRp
cGx5KVxcbiEgQSBpcyBtIHggbiwgeCBoYXMgbiBlbGVtZW50cywgeSBoYXMgbSBlbGVtZW50c1xc
bnN1YnJvdXRpbmUgYWxhcy5kZ2VtdihcXG4gIGE6IGFycmF5IGY2NDsgeDogYXJyYXkgZjY0OyB5
OiBhcnJheSBmNjQ7XFxuICBtLCBuOiBpMzI7IGFscGhhLCBiZXRhOiBmNjRcXG4pXFxudmFyIGks
IGo6IGkzMjsgczogZjY0XFxuYmVnaW5cXG4gIGZvciBpIDo9IDAsIG1cXG4gICAgcyA6PSAwLjBc
XG4gICAgZm9yIGogOj0gMCwgblxcbiAgICAgIHMgOj0gcyArIGFbaSwgbiwgal0gKiB4W2pdXFxu
ICAgIGVuZCBmb3JcXG4gICAgeVtpXSA6PSBhbHBoYSAqIHMgKyBiZXRhICogeVtpXVxcbiAgZW5k
IGZvclxcbmVuZFxcblxcbiEgc29sdmUgTCp4ID0gYiBvciBMXlQqeCA9IGIgICh0cmlhbmd1bGFy
IHNvbHZlKVxcbiEgdXBsbzogMCA9IGxvd2VyLCAxID0gdXBwZXJcXG4hIHRyYW5zOiAwID0gbm8g
dHJhbnNwb3NlLCAxID0gdHJhbnNwb3NlXFxuISB4IGlzIG92ZXJ3cml0dGVuIHdpdGggdGhlIHNv
bHV0aW9uIChpbnB1dCBpcyBiLCBvdXRwdXQgaXMgeClcXG5zdWJyb3V0aW5lIGFsYXMuZHRyc3Yo
XFxuICBhOiBhcnJheSBmNjQ7IHg6IGFycmF5IGY2NDtcXG4gIG4sIHVwbG8sIHRyYW5zOiBpMzJc
XG4pXFxudmFyIGksIGo6IGkzMjsgczogZjY0XFxuYmVnaW5cXG4gIGlmICh1cGxvID09IDAgYW5k
IHRyYW5zID09IDApIHRoZW5cXG4gICAgISBsb3dlciwgbm8gdHJhbnNwb3NlOiBmb3J3YXJkIHN1
YnN0aXR1dGlvblxcbiAgICBmb3IgaSA6PSAwLCBuXFxuICAgICAgcyA6PSB4W2ldXFxuICAgICAg
Zm9yIGogOj0gMCwgaVxcbiAgICAgICAgcyA6PSBzIC0gYVtpLCBuLCBqXSAqIHhbal1cXG4gICAg
ICBlbmQgZm9yXFxuICAgICAgeFtpXSA6PSBzIC8gYVtpLCBuLCBpXVxcbiAgICBlbmQgZm9yXFxu
ICBlbHNlIGlmICh1cGxvID09IDAgYW5kIHRyYW5zID09IDEpIHRoZW5cXG4gICAgISBsb3dlciwg
dHJhbnNwb3NlICg9IHVwcGVyKTogYmFjayBzdWJzdGl0dXRpb25cXG4gICAgZm9yIGkgOj0gbiAt
IDEsIC0xLCAtMVxcbiAgICAgIHMgOj0geFtpXVxcbiAgICAgIGZvciBqIDo9IGkgKyAxLCBuXFxu
ICAgICAgICBzIDo9IHMgLSBhW2osIG4sIGldICogeFtqXVxcbiAgICAgIGVuZCBmb3JcXG4gICAg
ICB4W2ldIDo9IHMgLyBhW2ksIG4sIGldXFxuICAgIGVuZCBmb3JcXG4gIGVsc2UgaWYgKHVwbG8g
PT0gMSBhbmQgdHJhbnMgPT0gMCkgdGhlblxcbiAgICAhIHVwcGVyLCBubyB0cmFuc3Bvc2U6IGJh
Y2sgc3Vic3RpdHV0aW9uXFxuICAgIGZvciBpIDo9IG4gLSAxLCAtMSwgLTFcXG4gICAgICBzIDo9
IHhbaV1cXG4gICAgICBmb3IgaiA6PSBpICsgMSwgblxcbiAgICAgICAgcyA6PSBzIC0gYVtpLCBu
LCBqXSAqIHhbal1cXG4gICAgICBlbmQgZm9yXFxuICAgICAgeFtpXSA6PSBzIC8gYVtpLCBuLCBp
XVxcbiAgICBlbmQgZm9yXFxuICBlbHNlXFxuICAgICEgdXBwZXIsIHRyYW5zcG9zZSAoPSBsb3dl
cik6IGZvcndhcmQgc3Vic3RpdHV0aW9uXFxuICAgIGZvciBpIDo9IDAsIG5cXG4gICAgICBzIDo9
IHhbaV1cXG4gICAgICBmb3IgaiA6PSAwLCBpXFxuICAgICAgICBzIDo9IHMgLSBhW2osIG4sIGld
ICogeFtqXVxcbiAgICAgIGVuZCBmb3JcXG4gICAgICB4W2ldIDo9IHMgLyBhW2ksIG4sIGldXFxu
ICAgIGVuZCBmb3JcXG4gIGVuZCBpZlxcbmVuZFxcblxcbiEgQSA6PSBBICsgYWxwaGEgKiB4ICog
eV5UICAocmFuay0xIHVwZGF0ZSlcXG4hIEEgaXMgbSB4IG4sIHggaGFzIG0gZWxlbWVudHMsIHkg
aGFzIG4gZWxlbWVudHNcXG5zdWJyb3V0aW5lIGFsYXMuZGdlcihcXG4gIGE6IGFycmF5IGY2NDsg
eDogYXJyYXkgZjY0OyB5OiBhcnJheSBmNjQ7XFxuICBtLCBuOiBpMzI7IGFscGhhOiBmNjRcXG4p
XFxudmFyIGksIGo6IGkzMjsgdDogZjY0XFxuYmVnaW5cXG4gIGZvciBpIDo9IDAsIG1cXG4gICAg
dCA6PSBhbHBoYSAqIHhbaV1cXG4gICAgZm9yIGogOj0gMCwgblxcbiAgICAgIGFbaSwgbiwgal0g
Oj0gYVtpLCBuLCBqXSArIHQgKiB5W2pdXFxuICAgIGVuZCBmb3JcXG4gIGVuZCBmb3JcXG5lbmRc
XG5cXG4hIHkgOj0gYWxwaGEgKiBBICogeCArIGJldGEgKiB5ICAoc3ltbWV0cmljIG1hdHJpeC12
ZWN0b3IgbXVsdGlwbHkpXFxuISBBIGlzIG4geCBuIHN5bW1ldHJpYywgb25seSBsb3dlciB0cmlh
bmdsZSBpcyByZWFkXFxuc3Vicm91dGluZSBhbGFzLmRzeW12KFxcbiAgYTogYXJyYXkgZjY0OyB4
OiBhcnJheSBmNjQ7IHk6IGFycmF5IGY2NDtcXG4gIG46IGkzMjsgYWxwaGEsIGJldGE6IGY2NFxc
bilcXG52YXIgaSwgajogaTMyOyBzLCB0OiBmNjRcXG5iZWdpblxcbiAgISBzY2FsZSB5IGJ5IGJl
dGFcXG4gIGZvciBpIDo9IDAsIG5cXG4gICAgeVtpXSA6PSBiZXRhICogeVtpXVxcbiAgZW5kIGZv
clxcbiAgISBhY2N1bXVsYXRlOiBkaWFnb25hbCArIG9mZi1kaWFnb25hbCAoc3ltbWV0cmljKVxc
biAgZm9yIGkgOj0gMCwgblxcbiAgICBzIDo9IDAuMFxcbiAgICBmb3IgaiA6PSAwLCBpXFxuICAg
ICAgdCA6PSBhbHBoYSAqIGFbaSwgbiwgal1cXG4gICAgICBzIDo9IHMgKyB0ICogeFtqXVxcbiAg
ICAgIHlbal0gOj0geVtqXSArIHQgKiB4W2ldXFxuICAgIGVuZCBmb3JcXG4gICAgeVtpXSA6PSB5
W2ldICsgcyArIGFscGhhICogYVtpLCBuLCBpXSAqIHhbaV1cXG4gIGVuZCBmb3JcXG5lbmRcXG5c
XG4hIOKUgOKUgCBBTEFTIExldmVsIDM6IG1hdHJpeC1tYXRyaXgg4pSA4pSA4pSA4pSA4pSA4pSA
4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA
4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSAXFxuXFxuISBDIDo9IGFscGhhICog
QSAqIEIgKyBiZXRhICogQyAgKGdlbmVyYWwgbWF0cml4LW1hdHJpeCBtdWx0aXBseSlcXG4hIEEg
aXMgbSB4IGssIEIgaXMgayB4IG4sIEMgaXMgbSB4IG5cXG5zdWJyb3V0aW5lIGFsYXMuZGdlbW0o
XFxuICBhOiBhcnJheSBmNjQ7IGI6IGFycmF5IGY2NDsgYzogYXJyYXkgZjY0O1xcbiAgbSwgbiwg
azogaTMyOyBhbHBoYSwgYmV0YTogZjY0XFxuKVxcbnZhclxcbiAgaSwgaiwgcDogaTMyXFxuICBz
OiBmNjRcXG5iZWdpblxcbiAgZm9yIGkgOj0gMCwgbVxcbiAgICBmb3IgaiA6PSAwLCBuXFxuICAg
ICAgcyA6PSAwLjBcXG4gICAgICBmb3IgcCA6PSAwLCBrXFxuICAgICAgICBzIDo9IHMgKyBhW2ks
IGssIHBdICogYltwLCBuLCBqXVxcbiAgICAgIGVuZCBmb3JcXG4gICAgICBjW2ksIG4sIGpdIDo9
IGFscGhhICogcyArIGJldGEgKiBjW2ksIG4sIGpdXFxuICAgIGVuZCBmb3JcXG4gIGVuZCBmb3Jc
XG5lbmRcXG5cXG4hIOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKV
kOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKV
kOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKV
kOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkFxcbiEg
QUxQQUNLIOKAlCBmYWN0b3JpemF0aW9ucywgc29sdmVycywgZWlnZW5kZWNvbXBvc2l0aW9uXFxu
ISDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDi
lZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDi
lZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDi
lZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZBcXG5cXG4hIOKUgOKUgCBD
aG9sZXNreSBmYWN0b3JpemF0aW9uIOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKU
gOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKU
gOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgFxcblxcbiEgQSA9IEwgKiBMXlQgIChp
bi1wbGFjZSwgbG93ZXIgdHJpYW5nbGUgb3ZlcndyaXR0ZW4gd2l0aCBMKVxcbiEgaW5mb1swXSA9
IDAgb24gc3VjY2VzcywgayA+IDAgaWYgbm90IHBvc2l0aXZlLWRlZmluaXRlIGF0IGNvbHVtbiBr
XFxuc3Vicm91dGluZSBhbHBhY2suZHBvdHJmKGE6IGFycmF5IGY2NDsgbjogaTMyOyBpbmZvOiBh
cnJheSBpMzIpXFxudmFyIGksIGosIGs6IGkzMjsgczogZjY0XFxuYmVnaW5cXG4gIGluZm9bMF0g
Oj0gMFxcbiAgZm9yIGogOj0gMCwgblxcbiAgICBzIDo9IGFbaiwgbiwgal1cXG4gICAgZm9yIGsg
Oj0gMCwgalxcbiAgICAgIHMgOj0gcyAtIGFbaiwgbiwga10gKiBhW2osIG4sIGtdXFxuICAgIGVu
ZCBmb3JcXG4gICAgaWYgKHMgPD0gMC4wKSB0aGVuXFxuICAgICAgaW5mb1swXSA6PSBqICsgMVxc
biAgICAgIGNhbGwgcmV0dXJuKClcXG4gICAgZW5kIGlmXFxuICAgIGFbaiwgbiwgal0gOj0gc3Fy
dChzKVxcbiAgICBmb3IgaSA6PSBqICsgMSwgblxcbiAgICAgIHMgOj0gYVtpLCBuLCBqXVxcbiAg
ICAgIGZvciBrIDo9IDAsIGpcXG4gICAgICAgIHMgOj0gcyAtIGFbaSwgbiwga10gKiBhW2osIG4s
IGtdXFxuICAgICAgZW5kIGZvclxcbiAgICAgIGFbaSwgbiwgal0gOj0gcyAvIGFbaiwgbiwgal1c
XG4gICAgZW5kIGZvclxcbiAgZW5kIGZvclxcbmVuZFxcblxcbiEgc29sdmUgQSpYID0gQiBnaXZl
biBDaG9sZXNreSBmYWN0b3IgTCBmcm9tIGRwb3RyZlxcbiEgQiBpcyBvdmVyd3JpdHRlbiB3aXRo
IFguICBCIGlzIG4geCBucmhzIChlYWNoIGNvbHVtbiBpcyBhbiBSSFMpXFxuc3Vicm91dGluZSBh
bHBhY2suZHBvdHJzKFxcbiAgbDogYXJyYXkgZjY0OyBiOiBhcnJheSBmNjQ7XFxuICBuLCBucmhz
OiBpMzJcXG4pXFxudmFyIHJocywgaSwgajogaTMyOyBzOiBmNjRcXG5iZWdpblxcbiAgZm9yIHJo
cyA6PSAwLCBucmhzXFxuICAgICEgZm9yd2FyZCBzdWJzdGl0dXRpb246IEwgKiB5ID0gYlxcbiAg
ICBmb3IgaSA6PSAwLCBuXFxuICAgICAgcyA6PSBiW2ksIG5yaHMsIHJoc11cXG4gICAgICBmb3Ig
aiA6PSAwLCBpXFxuICAgICAgICBzIDo9IHMgLSBsW2ksIG4sIGpdICogYltqLCBucmhzLCByaHNd
XFxuICAgICAgZW5kIGZvclxcbiAgICAgIGJbaSwgbnJocywgcmhzXSA6PSBzIC8gbFtpLCBuLCBp
XVxcbiAgICBlbmQgZm9yXFxuICAgICEgYmFjayBzdWJzdGl0dXRpb246IExeVCAqIHggPSB5XFxu
ICAgIGZvciBpIDo9IG4gLSAxLCAtMSwgLTFcXG4gICAgICBzIDo9IGJbaSwgbnJocywgcmhzXVxc
biAgICAgIGZvciBqIDo9IGkgKyAxLCBuXFxuICAgICAgICBzIDo9IHMgLSBsW2osIG4sIGldICog
YltqLCBucmhzLCByaHNdXFxuICAgICAgZW5kIGZvclxcbiAgICAgIGJbaSwgbnJocywgcmhzXSA6
PSBzIC8gbFtpLCBuLCBpXVxcbiAgICBlbmQgZm9yXFxuICBlbmQgZm9yXFxuZW5kXFxuXFxuISDi
lIDilIAgTFUgZmFjdG9yaXphdGlvbiB3aXRoIHBhcnRpYWwgcGl2b3Rpbmcg4pSA4pSA4pSA4pSA
4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA
4pSA4pSA4pSAXFxuXFxuISBBID0gUCAqIEwgKiBVICAoaW4tcGxhY2UsIEwgYmVsb3cgZGlhZ29u
YWwgd2l0aCB1bml0IGRpYWdvbmFsLCBVIG9uK2Fib3ZlKVxcbiEgaXBpdiBpcyBhbiBuLWVsZW1l
bnQgaTMyIGFycmF5IG9mIHBpdm90IGluZGljZXNcXG4hIGluZm9bMF0gPSAwIG9uIHN1Y2Nlc3Ms
IGsgPiAwIGlmIFUoayxrKSBpcyB6ZXJvXFxuc3Vicm91dGluZSBhbHBhY2suZGdldHJmKFxcbiAg
YTogYXJyYXkgZjY0OyBuOiBpMzI7XFxuICBpcGl2OiBhcnJheSBpMzI7IGluZm86IGFycmF5IGkz
MlxcbilcXG52YXIgaSwgaiwgaywgcGl2b3Q6IGkzMjsgdCwgaW52OiBmNjRcXG5iZWdpblxcbiAg
aW5mb1swXSA6PSAwXFxuICBmb3IgayA6PSAwLCBuXFxuICAgICEgZmluZCBwaXZvdCBpbiBjb2x1
bW4gayBmcm9tIHJvdyBrLi5uLTFcXG4gICAgISB1c2UgaW5saW5lIHNlYXJjaCAoaWRhbWF4IG9w
ZXJhdGVzIG9uIGNvbnRpZ3VvdXMgdmVjdG9yKVxcbiAgICBwaXZvdCA6PSBrXFxuICAgIHQgOj0g
YWJzKGFbaywgbiwga10pXFxuICAgIGZvciBpIDo9IGsgKyAxLCBuXFxuICAgICAgaWYgKGFicyhh
W2ksIG4sIGtdKSA+IHQpIHRoZW5cXG4gICAgICAgIHBpdm90IDo9IGlcXG4gICAgICAgIHQgOj0g
YWJzKGFbaSwgbiwga10pXFxuICAgICAgZW5kIGlmXFxuICAgIGVuZCBmb3JcXG4gICAgaXBpdltr
XSA6PSBwaXZvdFxcblxcbiAgICAhIHN3YXAgcm93cyBrIGFuZCBwaXZvdFxcbiAgICBpZiAocGl2
b3QgLz0gaykgdGhlblxcbiAgICAgIGZvciBqIDo9IDAsIG5cXG4gICAgICAgIHQgOj0gYVtrLCBu
LCBqXVxcbiAgICAgICAgYVtrLCBuLCBqXSA6PSBhW3Bpdm90LCBuLCBqXVxcbiAgICAgICAgYVtw
aXZvdCwgbiwgal0gOj0gdFxcbiAgICAgIGVuZCBmb3JcXG4gICAgZW5kIGlmXFxuXFxuICAgIGlm
IChhW2ssIG4sIGtdID09IDAuMCkgdGhlblxcbiAgICAgIGluZm9bMF0gOj0gayArIDFcXG4gICAg
ICBjYWxsIHJldHVybigpXFxuICAgIGVuZCBpZlxcblxcbiAgICAhIGVsaW1pbmF0ZSBiZWxvdyBk
aWFnb25hbFxcbiAgICBpbnYgOj0gMS4wIC8gYVtrLCBuLCBrXVxcbiAgICBmb3IgaSA6PSBrICsg
MSwgblxcbiAgICAgIGFbaSwgbiwga10gOj0gYVtpLCBuLCBrXSAqIGludlxcbiAgICAgIGZvciBq
IDo9IGsgKyAxLCBuXFxuICAgICAgICBhW2ksIG4sIGpdIDo9IGFbaSwgbiwgal0gLSBhW2ksIG4s
IGtdICogYVtrLCBuLCBqXVxcbiAgICAgIGVuZCBmb3JcXG4gICAgZW5kIGZvclxcbiAgZW5kIGZv
clxcbmVuZFxcblxcbiEgc29sdmUgQSpYID0gQiBnaXZlbiBMVSBmYWN0b3JpemF0aW9uIGZyb20g
ZGdldHJmXFxuISBCIGlzIG4geCBucmhzLCBvdmVyd3JpdHRlbiB3aXRoIFhcXG5zdWJyb3V0aW5l
IGFscGFjay5kZ2V0cnMoXFxuICBsdTogYXJyYXkgZjY0OyBpcGl2OiBhcnJheSBpMzI7XFxuICBi
OiBhcnJheSBmNjQ7IG4sIG5yaHM6IGkzMlxcbilcXG52YXIgcmhzLCBpLCBqLCBwOiBpMzI7IHMs
IHQ6IGY2NFxcbmJlZ2luXFxuICBmb3IgcmhzIDo9IDAsIG5yaHNcXG4gICAgISBhcHBseSByb3cg
cGVybXV0YXRpb25cXG4gICAgZm9yIGkgOj0gMCwgblxcbiAgICAgIHAgOj0gaXBpdltpXVxcbiAg
ICAgIGlmIChwIC89IGkpIHRoZW5cXG4gICAgICAgIHQgOj0gYltpLCBucmhzLCByaHNdXFxuICAg
ICAgICBiW2ksIG5yaHMsIHJoc10gOj0gYltwLCBucmhzLCByaHNdXFxuICAgICAgICBiW3AsIG5y
aHMsIHJoc10gOj0gdFxcbiAgICAgIGVuZCBpZlxcbiAgICBlbmQgZm9yXFxuICAgICEgZm9yd2Fy
ZCBzdWJzdGl0dXRpb24gKEwgd2l0aCB1bml0IGRpYWdvbmFsKVxcbiAgICBmb3IgaSA6PSAxLCBu
XFxuICAgICAgcyA6PSBiW2ksIG5yaHMsIHJoc11cXG4gICAgICBmb3IgaiA6PSAwLCBpXFxuICAg
ICAgICBzIDo9IHMgLSBsdVtpLCBuLCBqXSAqIGJbaiwgbnJocywgcmhzXVxcbiAgICAgIGVuZCBm
b3JcXG4gICAgICBiW2ksIG5yaHMsIHJoc10gOj0gc1xcbiAgICBlbmQgZm9yXFxuICAgICEgYmFj
ayBzdWJzdGl0dXRpb24gKFUpXFxuICAgIGZvciBpIDo9IG4gLSAxLCAtMSwgLTFcXG4gICAgICBz
IDo9IGJbaSwgbnJocywgcmhzXVxcbiAgICAgIGZvciBqIDo9IGkgKyAxLCBuXFxuICAgICAgICBz
IDo9IHMgLSBsdVtpLCBuLCBqXSAqIGJbaiwgbnJocywgcmhzXVxcbiAgICAgIGVuZCBmb3JcXG4g
ICAgICBiW2ksIG5yaHMsIHJoc10gOj0gcyAvIGx1W2ksIG4sIGldXFxuICAgIGVuZCBmb3JcXG4g
IGVuZCBmb3JcXG5lbmRcXG5cXG4hIHNvbHZlIEEqWCA9IEIgIChjb252ZW5pZW5jZTogZGdldHJm
ICsgZGdldHJzKVxcbiEgQSBpcyBvdmVyd3JpdHRlbiB3aXRoIExVLCBCIGlzIG92ZXJ3cml0dGVu
IHdpdGggWFxcbiEgc2NyYXRjaDogaTMyIGFycmF5IG9mIGxlbmd0aCBuIGZvciBwaXZvdHNcXG5z
dWJyb3V0aW5lIGFscGFjay5kZ2VzdihcXG4gIGE6IGFycmF5IGY2NDsgYjogYXJyYXkgZjY0O1xc
biAgbiwgbnJoczogaTMyO1xcbiAgaXBpdjogYXJyYXkgaTMyOyBpbmZvOiBhcnJheSBpMzJcXG4p
XFxuYmVnaW5cXG4gIGNhbGwgYWxwYWNrLmRnZXRyZihhLCBuLCBpcGl2LCBpbmZvKVxcbiAgaWYg
KGluZm9bMF0gLz0gMCkgdGhlblxcbiAgICBjYWxsIHJldHVybigpXFxuICBlbmQgaWZcXG4gIGNh
bGwgYWxwYWNrLmRnZXRycyhhLCBpcGl2LCBiLCBuLCBucmhzKVxcbmVuZFxcblxcbiEg4pSA4pSA
IFRyaWFuZ3VsYXIgaW52ZXJzZSDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDi
lIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDi
lIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIBcXG5cXG4hIGludmVy
dCBhIGxvd2VyIHRyaWFuZ3VsYXIgbWF0cml4IGluLXBsYWNlXFxuISBpbmZvWzBdID0gMCBvbiBz
dWNjZXNzLCBrID4gMCBpZiBkaWFnb25hbCBlbGVtZW50IGsgaXMgemVyb1xcbnN1YnJvdXRpbmUg
YWxwYWNrLmR0cnRyaShhOiBhcnJheSBmNjQ7IG46IGkzMjsgaW5mbzogYXJyYXkgaTMyKVxcbnZh
ciBpLCBqLCBrOiBpMzI7IHM6IGY2NFxcbmJlZ2luXFxuICBpbmZvWzBdIDo9IDBcXG4gIGZvciBq
IDo9IDAsIG5cXG4gICAgaWYgKGFbaiwgbiwgal0gPT0gMC4wKSB0aGVuXFxuICAgICAgaW5mb1sw
XSA6PSBqICsgMVxcbiAgICAgIGNhbGwgcmV0dXJuKClcXG4gICAgZW5kIGlmXFxuICAgIGFbaiwg
biwgal0gOj0gMS4wIC8gYVtqLCBuLCBqXVxcbiAgICBmb3IgaSA6PSBqICsgMSwgblxcbiAgICAg
IHMgOj0gMC4wXFxuICAgICAgZm9yIGsgOj0gaiwgaVxcbiAgICAgICAgcyA6PSBzIC0gYVtpLCBu
LCBrXSAqIGFbaywgbiwgal1cXG4gICAgICBlbmQgZm9yXFxuICAgICAgYVtpLCBuLCBqXSA6PSBz
IC8gYVtpLCBuLCBpXVxcbiAgICBlbmQgZm9yXFxuICBlbmQgZm9yXFxuZW5kXFxuXFxuISDilIDi
lIAgRWlnZW5kZWNvbXBvc2l0aW9uOiAzeDMgYW5hbHl0aWNhbCDilIDilIDilIDilIDilIDilIDi
lIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDi
lIDilIDilIDilIDilIBcXG5cXG4hIGVpZ2VudmFsdWVzIG9mIGEgM3gzIHN5bW1ldHJpYyBtYXRy
aXggKGFuYWx5dGljYWwsIENhcmRhbm8ncyBtZXRob2QpXFxuISBhIGlzIDN4MyBzeW1tZXRyaWMg
KDkgZjY0KSwgdyByZWNlaXZlcyAzIGVpZ2VudmFsdWVzIChzb3J0ZWQgZGVzY2VuZGluZylcXG5z
dWJyb3V0aW5lIGFscGFjay5kc3lldjMoYTogYXJyYXkgZjY0OyB3OiBhcnJheSBmNjQpXFxudmFy
XFxuICBhMDAsIGEwMSwgYTAyLCBhMTEsIGExMiwgYTIyOiBmNjRcXG4gIHAxLCBxLCBwMiwgcCwg
YjAwLCBiMTEsIGIyMiwgZGV0X2IsIGhhbGZfZGV0OiBmNjRcXG4gIHBoaSwgciwgZTEsIGUyLCBl
MzogZjY0XFxuICBtOiBmNjRcXG4gIHBpOiBmNjRcXG5iZWdpblxcbiAgcGkgOj0gMy4xNDE1OTI2
NTM1ODk3OTMyMzg0NlxcblxcbiAgYTAwIDo9IGFbMCwgMywgMF1cXG4gIGEwMSA6PSBhWzAsIDMs
IDFdXFxuICBhMDIgOj0gYVswLCAzLCAyXVxcbiAgYTExIDo9IGFbMSwgMywgMV1cXG4gIGExMiA6
PSBhWzEsIDMsIDJdXFxuICBhMjIgOj0gYVsyLCAzLCAyXVxcblxcbiAgISB0cmFjZSAvIDNcXG4g
IG0gOj0gKGEwMCArIGExMSArIGEyMikgLyAzLjBcXG5cXG4gICEgc3VtIG9mIHNxdWFyZXMgb2Yg
b2ZmLWRpYWdvbmFsIGVsZW1lbnRzXFxuICBwMSA6PSBhMDEgKiBhMDEgKyBhMDIgKiBhMDIgKyBh
MTIgKiBhMTJcXG5cXG4gIGlmIChwMSA8PSAxZS0zMCkgdGhlblxcbiAgICAhIGRpYWdvbmFsIG1h
dHJpeCDigJQgZWlnZW52YWx1ZXMgYXJlIHRoZSBkaWFnb25hbCBlbnRyaWVzLCBzb3J0IGRlc2Nl
bmRpbmdcXG4gICAgZTEgOj0gYTAwXFxuICAgIGUyIDo9IGExMVxcbiAgICBlMyA6PSBhMjJcXG4g
ICAgISBzb3J0IDMgdmFsdWVzIGRlc2NlbmRpbmcgKGJ1YmJsZSBzb3J0KVxcbiAgICBpZiAoZTIg
PiBlMSkgdGhlblxcbiAgICAgIHIgOj0gZTFcXG4gICAgICBlMSA6PSBlMlxcbiAgICAgIGUyIDo9
IHJcXG4gICAgZW5kIGlmXFxuICAgIGlmIChlMyA+IGUyKSB0aGVuXFxuICAgICAgciA6PSBlMlxc
biAgICAgIGUyIDo9IGUzXFxuICAgICAgZTMgOj0gclxcbiAgICBlbmQgaWZcXG4gICAgaWYgKGUy
ID4gZTEpIHRoZW5cXG4gICAgICByIDo9IGUxXFxuICAgICAgZTEgOj0gZTJcXG4gICAgICBlMiA6
PSByXFxuICAgIGVuZCBpZlxcbiAgICB3WzBdIDo9IGUxXFxuICAgIHdbMV0gOj0gZTJcXG4gICAg
d1syXSA6PSBlM1xcbiAgICBjYWxsIHJldHVybigpXFxuICBlbmQgaWZcXG5cXG4gIHEgOj0gbVxc
biAgcDIgOj0gKGEwMCAtIHEpICogKGEwMCAtIHEpICsgKGExMSAtIHEpICogKGExMSAtIHEpICsg
KGEyMiAtIHEpICogKGEyMiAtIHEpICsgMi4wICogcDFcXG4gIHAgOj0gc3FydChwMiAvIDYuMClc
XG5cXG4gICEgQiA9IChBIC0gcSpJKSAvIHAgIOKAlCBvbmx5IG5lZWQgZGV0ZXJtaW5hbnRcXG4g
IGIwMCA6PSAoYTAwIC0gcSkgLyBwXFxuICBiMTEgOj0gKGExMSAtIHEpIC8gcFxcbiAgYjIyIDo9
IChhMjIgLSBxKSAvIHBcXG4gICEgZGV0KEIpIGZvciBzeW1tZXRyaWMgM3gzXFxuICBkZXRfYiA6
PSBiMDAgKiAoYjExICogYjIyIC0gKGExMiAvIHApICogKGExMiAvIHApKVxcbiAgICAgICAgIC0g
KGEwMSAvIHApICogKChhMDEgLyBwKSAqIGIyMiAtIChhMTIgLyBwKSAqIChhMDIgLyBwKSlcXG4g
ICAgICAgICArIChhMDIgLyBwKSAqICgoYTAxIC8gcCkgKiAoYTEyIC8gcCkgLSBiMTEgKiAoYTAy
IC8gcCkpXFxuICBoYWxmX2RldCA6PSBkZXRfYiAvIDIuMFxcblxcbiAgISBjbGFtcCB0byBbLTEs
IDFdIGZvciBhY29zXFxuICBpZiAoaGFsZl9kZXQgPD0gLTEuMCkgdGhlblxcbiAgICBwaGkgOj0g
cGkgLyAzLjBcXG4gIGVsc2UgaWYgKGhhbGZfZGV0ID49IDEuMCkgdGhlblxcbiAgICBwaGkgOj0g
MC4wXFxuICBlbHNlXFxuICAgIHBoaSA6PSBhdGFuMihzcXJ0KDEuMCAtIGhhbGZfZGV0ICogaGFs
Zl9kZXQpLCBoYWxmX2RldCkgLyAzLjBcXG4gIGVuZCBpZlxcblxcbiAgISBlaWdlbnZhbHVlcyBp
biBkZXNjZW5kaW5nIG9yZGVyXFxuICBlMSA6PSBxICsgMi4wICogcCAqIGNvcyhwaGkpXFxuICBl
MyA6PSBxICsgMi4wICogcCAqIGNvcyhwaGkgKyAyLjAgKiBwaSAvIDMuMClcXG4gIGUyIDo9IDMu
MCAqIHEgLSBlMSAtIGUzXFxuXFxuICB3WzBdIDo9IGUxXFxuICB3WzFdIDo9IGUyXFxuICB3WzJd
IDo9IGUzXFxuZW5kXFxuXFxuISDilIDilIAgRWlnZW5kZWNvbXBvc2l0aW9uOiBnZW5lcmFsIHN5
bW1ldHJpYyAoSmFjb2JpKSDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDi
lIDilIDilIDilIDilIBcXG5cXG4hIGVpZ2VudmFsdWVzIG9mIGFuIG4geCBuIHN5bW1ldHJpYyBt
YXRyaXggdmlhIGN5Y2xpYyBKYWNvYmkgcm90YXRpb25zXFxuISBhIGlzIG92ZXJ3cml0dGVuIHdp
dGggdGhlIGVpZ2VudmVjdG9yIG1hdHJpeCAoY29sdW1ucyBhcmUgZWlnZW52ZWN0b3JzKVxcbiEg
dyByZWNlaXZlcyBuIGVpZ2VudmFsdWVzICh1bnNvcnRlZClcXG4hIGluZm9bMF0gPSAwIG9uIHN1
Y2Nlc3MsIDEgaWYgbm90IGNvbnZlcmdlZFxcbnN1YnJvdXRpbmUgYWxwYWNrLmRzeWV2KFxcbiAg
YTogYXJyYXkgZjY0OyB3OiBhcnJheSBmNjQ7XFxuICBuOiBpMzI7IGluZm86IGFycmF5IGkzMlxc
bilcXG52YXJcXG4gIGksIGosIHAsIHEsIGl0ZXIsIG1heEl0ZXI6IGkzMlxcbiAgb2ZmLCB0aHJl
c2gsIGFwcCwgYXFxLCBhcHE6IGY2NFxcbiAgdGF1LCB0LCBjLCBzLCB0bXA6IGY2NFxcbmJlZ2lu
XFxuICBpbmZvWzBdIDo9IDBcXG4gIG1heEl0ZXIgOj0gMTAwXFxuXFxuICAhIGluaXRpYWxpemUg
dyB0byBkaWFnb25hbCBvZiBhXFxuICBmb3IgaSA6PSAwLCBuXFxuICAgIHdbaV0gOj0gYVtpLCBu
LCBpXVxcbiAgZW5kIGZvclxcblxcbiAgZm9yIGl0ZXIgOj0gMCwgbWF4SXRlclxcbiAgICAhIGNv
bXB1dGUgb2ZmLWRpYWdvbmFsIG5vcm1cXG4gICAgb2ZmIDo9IDAuMFxcbiAgICBmb3IgcCA6PSAw
LCBuXFxuICAgICAgZm9yIHEgOj0gcCArIDEsIG5cXG4gICAgICAgIG9mZiA6PSBvZmYgKyBhW3As
IG4sIHFdICogYVtwLCBuLCBxXVxcbiAgICAgIGVuZCBmb3JcXG4gICAgZW5kIGZvclxcbiAgICBp
ZiAob2ZmIDwgMWUtMjgpIHRoZW5cXG4gICAgICBjYWxsIHJldHVybigpXFxuICAgIGVuZCBpZlxc
blxcbiAgICB0aHJlc2ggOj0gaWYgKGl0ZXIgPCA0KSB0aGVuIDAuMiAqIG9mZiAvIGY2NChuICog
bikgZWxzZSAwLjBcXG5cXG4gICAgZm9yIHAgOj0gMCwgblxcbiAgICAgIGZvciBxIDo9IHAgKyAx
LCBuXFxuICAgICAgICBhcHEgOj0gYVtwLCBuLCBxXVxcbiAgICAgICAgaWYgKGFicyhhcHEpIDw9
IHRocmVzaCkgdGhlblxcbiAgICAgICAgICAhIHNraXAgc21hbGwgZWxlbWVudHMgaW4gZWFybHkg
c3dlZXBzXFxuICAgICAgICBlbHNlXFxuICAgICAgICAgIGFwcCA6PSB3W3BdXFxuICAgICAgICAg
IGFxcSA6PSB3W3FdXFxuICAgICAgICAgICEgSmFjb2JpIHJvdGF0aW9uIGFuZ2xlXFxuICAgICAg
ICAgIHRhdSA6PSAoYXFxIC0gYXBwKSAvICgyLjAgKiBhcHEpXFxuICAgICAgICAgIGlmICh0YXUg
Pj0gMC4wKSB0aGVuXFxuICAgICAgICAgICAgdCA6PSAxLjAgLyAodGF1ICsgc3FydCgxLjAgKyB0
YXUgKiB0YXUpKVxcbiAgICAgICAgICBlbHNlXFxuICAgICAgICAgICAgdCA6PSAwLjAgLSAxLjAg
LyAoMC4wIC0gdGF1ICsgc3FydCgxLjAgKyB0YXUgKiB0YXUpKVxcbiAgICAgICAgICBlbmQgaWZc
XG4gICAgICAgICAgYyA6PSAxLjAgLyBzcXJ0KDEuMCArIHQgKiB0KVxcbiAgICAgICAgICBzIDo9
IHQgKiBjXFxuXFxuICAgICAgICAgICEgdXBkYXRlIGVpZ2VudmFsdWVzXFxuICAgICAgICAgIHdb
cF0gOj0gYXBwIC0gdCAqIGFwcVxcbiAgICAgICAgICB3W3FdIDo9IGFxcSArIHQgKiBhcHFcXG4g
ICAgICAgICAgYVtwLCBuLCBxXSA6PSAwLjBcXG5cXG4gICAgICAgICAgISByb3RhdGUgcm93cy9j
b2x1bW5zIHAgYW5kIHFcXG4gICAgICAgICAgZm9yIGkgOj0gMCwgcFxcbiAgICAgICAgICAgIHRt
cCA6PSBhW2ksIG4sIHBdXFxuICAgICAgICAgICAgYVtpLCBuLCBwXSA6PSBjICogdG1wIC0gcyAq
IGFbaSwgbiwgcV1cXG4gICAgICAgICAgICBhW2ksIG4sIHFdIDo9IHMgKiB0bXAgKyBjICogYVtp
LCBuLCBxXVxcbiAgICAgICAgICBlbmQgZm9yXFxuICAgICAgICAgIGZvciBpIDo9IHAgKyAxLCBx
XFxuICAgICAgICAgICAgdG1wIDo9IGFbcCwgbiwgaV1cXG4gICAgICAgICAgICBhW3AsIG4sIGld
IDo9IGMgKiB0bXAgLSBzICogYVtpLCBuLCBxXVxcbiAgICAgICAgICAgIGFbaSwgbiwgcV0gOj0g
cyAqIHRtcCArIGMgKiBhW2ksIG4sIHFdXFxuICAgICAgICAgIGVuZCBmb3JcXG4gICAgICAgICAg
Zm9yIGkgOj0gcSArIDEsIG5cXG4gICAgICAgICAgICB0bXAgOj0gYVtwLCBuLCBpXVxcbiAgICAg
ICAgICAgIGFbcCwgbiwgaV0gOj0gYyAqIHRtcCAtIHMgKiBhW3EsIG4sIGldXFxuICAgICAgICAg
ICAgYVtxLCBuLCBpXSA6PSBzICogdG1wICsgYyAqIGFbcSwgbiwgaV1cXG4gICAgICAgICAgZW5k
IGZvclxcbiAgICAgICAgZW5kIGlmXFxuICAgICAgZW5kIGZvclxcbiAgICBlbmQgZm9yXFxuICBl
bmQgZm9yXFxuICBpbmZvWzBdIDo9IDFcXG5lbmRcXG5cIjtcblxuZXhwb3J0IGNvbnN0IGFsYXNf
ZHNjYWwgPSBcInN1YnJvdXRpbmUgYWxhcy5kc2NhbCh4OiBhcnJheSBmNjQ7IG46IGkzMjsgYWxw
aGE6IGY2NClcXG52YXIgaTogaTMyXFxuYmVnaW5cXG4gIGZvciBpIDo9IDAsIG5cXG4gICAgeFtp
XSA6PSBhbHBoYSAqIHhbaV1cXG4gIGVuZCBmb3JcXG5lbmRcIjtcblxuZXhwb3J0IGNvbnN0IGFs
YXNfZGNvcHkgPSBcInN1YnJvdXRpbmUgYWxhcy5kY29weSh4OiBhcnJheSBmNjQ7IHk6IGFycmF5
IGY2NDsgbjogaTMyKVxcbnZhciBpOiBpMzJcXG5iZWdpblxcbiAgZm9yIGkgOj0gMCwgblxcbiAg
ICB5W2ldIDo9IHhbaV1cXG4gIGVuZCBmb3JcXG5lbmRcIjtcblxuZXhwb3J0IGNvbnN0IGFsYXNf
ZGF4cHkgPSBcInN1YnJvdXRpbmUgYWxhcy5kYXhweSh4OiBhcnJheSBmNjQ7IHk6IGFycmF5IGY2
NDsgbjogaTMyOyBhbHBoYTogZjY0KVxcbnZhclxcbiAgaSwgbjI6IGkzMlxcbiAgdmEsIHZ4LCB2
eTogZjY0eDJcXG5iZWdpblxcbiAgISBzY2FsYXIgdmVyc2lvbiAoZm9yIHJlZmVyZW5jZSk6XFxu
ICAhICAgZm9yIGkgOj0gMCwgblxcbiAgISAgICAgeVtpXSA6PSBhbHBoYSAqIHhbaV0gKyB5W2ld
XFxuICAhICAgZW5kIGZvclxcbiAgdmEgOj0gZjY0eDIuc3BsYXQoYWxwaGEpXFxuICBuMiA6PSBu
IC8gMlxcbiAgZm9yIGkgOj0gMCwgbjJcXG4gICAgdnggOj0gdjEyOC5sb2FkKHgsIGkpXFxuICAg
IHZ5IDo9IHYxMjgubG9hZCh5LCBpKVxcbiAgICB2eSA6PSB2YSAqIHZ4ICsgdnlcXG4gICAgY2Fs
bCB2MTI4LnN0b3JlKHksIGksIHZ5KVxcbiAgZW5kIGZvclxcbiAgISBzY2FsYXIgdGFpbCBmb3Ig
b2RkIGVsZW1lbnRcXG4gIGlmIChuMiAqIDIgPCBuKSB0aGVuXFxuICAgIGkgOj0gbjIgKiAyXFxu
ICAgIHlbaV0gOj0gYWxwaGEgKiB4W2ldICsgeVtpXVxcbiAgZW5kIGlmXFxuZW5kXCI7XG5cbmV4
cG9ydCBjb25zdCBhbGFzX2Rkb3QgPSBcImZ1bmN0aW9uIGFsYXMuZGRvdCh4OiBhcnJheSBmNjQ7
IHk6IGFycmF5IGY2NDsgbjogaTMyKTogZjY0XFxudmFyXFxuICBpLCBuMjogaTMyXFxuICB2eCwg
dnksIHZzOiBmNjR4MlxcbmJlZ2luXFxuICAhIHNjYWxhciB2ZXJzaW9uOlxcbiAgISAgIGFsYXMu
ZGRvdCA6PSAwLjBcXG4gICEgICBmb3IgaSA6PSAwLCBuXFxuICAhICAgICBhbGFzLmRkb3QgOj0g
YWxhcy5kZG90ICsgeFtpXSAqIHlbaV1cXG4gICEgICBlbmQgZm9yXFxuICB2cyA6PSBmNjR4Mi5z
cGxhdCgwLjApXFxuICBuMiA6PSBuIC8gMlxcbiAgZm9yIGkgOj0gMCwgbjJcXG4gICAgdnggOj0g
djEyOC5sb2FkKHgsIGkpXFxuICAgIHZ5IDo9IHYxMjgubG9hZCh5LCBpKVxcbiAgICB2cyA6PSB2
cyArIHZ4ICogdnlcXG4gIGVuZCBmb3JcXG4gIGFsYXMuZGRvdCA6PSBmNjR4Mi5leHRyYWN0X2xh
bmUodnMsIDApICsgZjY0eDIuZXh0cmFjdF9sYW5lKHZzLCAxKVxcbiAgISBzY2FsYXIgdGFpbFxc
biAgaWYgKG4yICogMiA8IG4pIHRoZW5cXG4gICAgaSA6PSBuMiAqIDJcXG4gICAgYWxhcy5kZG90
IDo9IGFsYXMuZGRvdCArIHhbaV0gKiB5W2ldXFxuICBlbmQgaWZcXG5lbmRcIjtcblxuZXhwb3J0
IGNvbnN0IGFsYXNfZG5ybTIgPSBcImZ1bmN0aW9uIGFsYXMuZG5ybTIoeDogYXJyYXkgZjY0OyBu
OiBpMzIpOiBmNjRcXG52YXJcXG4gIGksIG4yOiBpMzJcXG4gIHZ4LCB2czogZjY0eDJcXG5iZWdp
blxcbiAgdnMgOj0gZjY0eDIuc3BsYXQoMC4wKVxcbiAgbjIgOj0gbiAvIDJcXG4gIGZvciBpIDo9
IDAsIG4yXFxuICAgIHZ4IDo9IHYxMjgubG9hZCh4LCBpKVxcbiAgICB2cyA6PSB2cyArIHZ4ICog
dnhcXG4gIGVuZCBmb3JcXG4gIGFsYXMuZG5ybTIgOj0gZjY0eDIuZXh0cmFjdF9sYW5lKHZzLCAw
KSArIGY2NHgyLmV4dHJhY3RfbGFuZSh2cywgMSlcXG4gIGlmIChuMiAqIDIgPCBuKSB0aGVuXFxu
ICAgIGkgOj0gbjIgKiAyXFxuICAgIGFsYXMuZG5ybTIgOj0gYWxhcy5kbnJtMiArIHhbaV0gKiB4
W2ldXFxuICBlbmQgaWZcXG4gIGFsYXMuZG5ybTIgOj0gc3FydChhbGFzLmRucm0yKVxcbmVuZFwi
O1xuXG5leHBvcnQgY29uc3QgYWxhc19kc3dhcCA9IFwic3Vicm91dGluZSBhbGFzLmRzd2FwKHg6
IGFycmF5IGY2NDsgeTogYXJyYXkgZjY0OyBuOiBpMzIpXFxudmFyIGk6IGkzMjsgdDogZjY0XFxu
YmVnaW5cXG4gIGZvciBpIDo9IDAsIG5cXG4gICAgdCA6PSB4W2ldXFxuICAgIHhbaV0gOj0geVtp
XVxcbiAgICB5W2ldIDo9IHRcXG4gIGVuZCBmb3JcXG5lbmRcIjtcblxuZXhwb3J0IGNvbnN0IGFs
YXNfaWRhbWF4ID0gXCJmdW5jdGlvbiBhbGFzLmlkYW1heCh4OiBhcnJheSBmNjQ7IG46IGkzMik6
IGkzMlxcbnZhciBpOiBpMzI7IG14OiBmNjQ7IHY6IGY2NFxcbmJlZ2luXFxuICBhbGFzLmlkYW1h
eCA6PSAwXFxuICBteCA6PSBhYnMoeFswXSlcXG4gIGZvciBpIDo9IDEsIG5cXG4gICAgdiA6PSBh
YnMoeFtpXSlcXG4gICAgaWYgKHYgPiBteCkgdGhlblxcbiAgICAgIG14IDo9IHZcXG4gICAgICBh
bGFzLmlkYW1heCA6PSBpXFxuICAgIGVuZCBpZlxcbiAgZW5kIGZvclxcbmVuZFwiO1xuXG5leHBv
cnQgY29uc3QgYWxhc19kZ2VtdiA9IFwic3Vicm91dGluZSBhbGFzLmRnZW12KFxcbiAgYTogYXJy
YXkgZjY0OyB4OiBhcnJheSBmNjQ7IHk6IGFycmF5IGY2NDtcXG4gIG0sIG46IGkzMjsgYWxwaGEs
IGJldGE6IGY2NFxcbilcXG52YXIgaSwgajogaTMyOyBzOiBmNjRcXG5iZWdpblxcbiAgZm9yIGkg
Oj0gMCwgbVxcbiAgICBzIDo9IDAuMFxcbiAgICBmb3IgaiA6PSAwLCBuXFxuICAgICAgcyA6PSBz
ICsgYVtpLCBuLCBqXSAqIHhbal1cXG4gICAgZW5kIGZvclxcbiAgICB5W2ldIDo9IGFscGhhICog
cyArIGJldGEgKiB5W2ldXFxuICBlbmQgZm9yXFxuZW5kXCI7XG5cbmV4cG9ydCBjb25zdCBhbGFz
X2R0cnN2ID0gXCJzdWJyb3V0aW5lIGFsYXMuZHRyc3YoXFxuICBhOiBhcnJheSBmNjQ7IHg6IGFy
cmF5IGY2NDtcXG4gIG4sIHVwbG8sIHRyYW5zOiBpMzJcXG4pXFxudmFyIGksIGo6IGkzMjsgczog
ZjY0XFxuYmVnaW5cXG4gIGlmICh1cGxvID09IDAgYW5kIHRyYW5zID09IDApIHRoZW5cXG4gICAg
ISBsb3dlciwgbm8gdHJhbnNwb3NlOiBmb3J3YXJkIHN1YnN0aXR1dGlvblxcbiAgICBmb3IgaSA6
PSAwLCBuXFxuICAgICAgcyA6PSB4W2ldXFxuICAgICAgZm9yIGogOj0gMCwgaVxcbiAgICAgICAg
cyA6PSBzIC0gYVtpLCBuLCBqXSAqIHhbal1cXG4gICAgICBlbmQgZm9yXFxuICAgICAgeFtpXSA6
PSBzIC8gYVtpLCBuLCBpXVxcbiAgICBlbmQgZm9yXFxuICBlbHNlIGlmICh1cGxvID09IDAgYW5k
IHRyYW5zID09IDEpIHRoZW5cXG4gICAgISBsb3dlciwgdHJhbnNwb3NlICg9IHVwcGVyKTogYmFj
ayBzdWJzdGl0dXRpb25cXG4gICAgZm9yIGkgOj0gbiAtIDEsIC0xLCAtMVxcbiAgICAgIHMgOj0g
eFtpXVxcbiAgICAgIGZvciBqIDo9IGkgKyAxLCBuXFxuICAgICAgICBzIDo9IHMgLSBhW2osIG4s
IGldICogeFtqXVxcbiAgICAgIGVuZCBmb3JcXG4gICAgICB4W2ldIDo9IHMgLyBhW2ksIG4sIGld
XFxuICAgIGVuZCBmb3JcXG4gIGVsc2UgaWYgKHVwbG8gPT0gMSBhbmQgdHJhbnMgPT0gMCkgdGhl
blxcbiAgICAhIHVwcGVyLCBubyB0cmFuc3Bvc2U6IGJhY2sgc3Vic3RpdHV0aW9uXFxuICAgIGZv
ciBpIDo9IG4gLSAxLCAtMSwgLTFcXG4gICAgICBzIDo9IHhbaV1cXG4gICAgICBmb3IgaiA6PSBp
ICsgMSwgblxcbiAgICAgICAgcyA6PSBzIC0gYVtpLCBuLCBqXSAqIHhbal1cXG4gICAgICBlbmQg
Zm9yXFxuICAgICAgeFtpXSA6PSBzIC8gYVtpLCBuLCBpXVxcbiAgICBlbmQgZm9yXFxuICBlbHNl
XFxuICAgICEgdXBwZXIsIHRyYW5zcG9zZSAoPSBsb3dlcik6IGZvcndhcmQgc3Vic3RpdHV0aW9u
XFxuICAgIGZvciBpIDo9IDAsIG5cXG4gICAgICBzIDo9IHhbaV1cXG4gICAgICBmb3IgaiA6PSAw
LCBpXFxuICAgICAgICBzIDo9IHMgLSBhW2osIG4sIGldICogeFtqXVxcbiAgICAgIGVuZCBmb3Jc
XG4gICAgICB4W2ldIDo9IHMgLyBhW2ksIG4sIGldXFxuICAgIGVuZCBmb3JcXG4gIGVuZCBpZlxc
bmVuZFwiO1xuXG5leHBvcnQgY29uc3QgYWxhc19kZ2VyID0gXCJzdWJyb3V0aW5lIGFsYXMuZGdl
cihcXG4gIGE6IGFycmF5IGY2NDsgeDogYXJyYXkgZjY0OyB5OiBhcnJheSBmNjQ7XFxuICBtLCBu
OiBpMzI7IGFscGhhOiBmNjRcXG4pXFxudmFyIGksIGo6IGkzMjsgdDogZjY0XFxuYmVnaW5cXG4g
IGZvciBpIDo9IDAsIG1cXG4gICAgdCA6PSBhbHBoYSAqIHhbaV1cXG4gICAgZm9yIGogOj0gMCwg
blxcbiAgICAgIGFbaSwgbiwgal0gOj0gYVtpLCBuLCBqXSArIHQgKiB5W2pdXFxuICAgIGVuZCBm
b3JcXG4gIGVuZCBmb3JcXG5lbmRcIjtcblxuZXhwb3J0IGNvbnN0IGFsYXNfZHN5bXYgPSBcInN1
YnJvdXRpbmUgYWxhcy5kc3ltdihcXG4gIGE6IGFycmF5IGY2NDsgeDogYXJyYXkgZjY0OyB5OiBh
cnJheSBmNjQ7XFxuICBuOiBpMzI7IGFscGhhLCBiZXRhOiBmNjRcXG4pXFxudmFyIGksIGo6IGkz
MjsgcywgdDogZjY0XFxuYmVnaW5cXG4gICEgc2NhbGUgeSBieSBiZXRhXFxuICBmb3IgaSA6PSAw
LCBuXFxuICAgIHlbaV0gOj0gYmV0YSAqIHlbaV1cXG4gIGVuZCBmb3JcXG4gICEgYWNjdW11bGF0
ZTogZGlhZ29uYWwgKyBvZmYtZGlhZ29uYWwgKHN5bW1ldHJpYylcXG4gIGZvciBpIDo9IDAsIG5c
XG4gICAgcyA6PSAwLjBcXG4gICAgZm9yIGogOj0gMCwgaVxcbiAgICAgIHQgOj0gYWxwaGEgKiBh
W2ksIG4sIGpdXFxuICAgICAgcyA6PSBzICsgdCAqIHhbal1cXG4gICAgICB5W2pdIDo9IHlbal0g
KyB0ICogeFtpXVxcbiAgICBlbmQgZm9yXFxuICAgIHlbaV0gOj0geVtpXSArIHMgKyBhbHBoYSAq
IGFbaSwgbiwgaV0gKiB4W2ldXFxuICBlbmQgZm9yXFxuZW5kXCI7XG5cbmV4cG9ydCBjb25zdCBh
bGFzX2RnZW1tID0gXCJzdWJyb3V0aW5lIGFsYXMuZGdlbW0oXFxuICBhOiBhcnJheSBmNjQ7IGI6
IGFycmF5IGY2NDsgYzogYXJyYXkgZjY0O1xcbiAgbSwgbiwgazogaTMyOyBhbHBoYSwgYmV0YTog
ZjY0XFxuKVxcbnZhclxcbiAgaSwgaiwgcDogaTMyXFxuICBzOiBmNjRcXG5iZWdpblxcbiAgZm9y
IGkgOj0gMCwgbVxcbiAgICBmb3IgaiA6PSAwLCBuXFxuICAgICAgcyA6PSAwLjBcXG4gICAgICBm
b3IgcCA6PSAwLCBrXFxuICAgICAgICBzIDo9IHMgKyBhW2ksIGssIHBdICogYltwLCBuLCBqXVxc
biAgICAgIGVuZCBmb3JcXG4gICAgICBjW2ksIG4sIGpdIDo9IGFscGhhICogcyArIGJldGEgKiBj
W2ksIG4sIGpdXFxuICAgIGVuZCBmb3JcXG4gIGVuZCBmb3JcXG5lbmRcIjtcblxuZXhwb3J0IGNv
bnN0IGFscGFja19kcG90cmYgPSBcInN1YnJvdXRpbmUgYWxwYWNrLmRwb3RyZihhOiBhcnJheSBm
NjQ7IG46IGkzMjsgaW5mbzogYXJyYXkgaTMyKVxcbnZhciBpLCBqLCBrOiBpMzI7IHM6IGY2NFxc
bmJlZ2luXFxuICBpbmZvWzBdIDo9IDBcXG4gIGZvciBqIDo9IDAsIG5cXG4gICAgcyA6PSBhW2os
IG4sIGpdXFxuICAgIGZvciBrIDo9IDAsIGpcXG4gICAgICBzIDo9IHMgLSBhW2osIG4sIGtdICog
YVtqLCBuLCBrXVxcbiAgICBlbmQgZm9yXFxuICAgIGlmIChzIDw9IDAuMCkgdGhlblxcbiAgICAg
IGluZm9bMF0gOj0gaiArIDFcXG4gICAgICBjYWxsIHJldHVybigpXFxuICAgIGVuZCBpZlxcbiAg
ICBhW2osIG4sIGpdIDo9IHNxcnQocylcXG4gICAgZm9yIGkgOj0gaiArIDEsIG5cXG4gICAgICBz
IDo9IGFbaSwgbiwgal1cXG4gICAgICBmb3IgayA6PSAwLCBqXFxuICAgICAgICBzIDo9IHMgLSBh
W2ksIG4sIGtdICogYVtqLCBuLCBrXVxcbiAgICAgIGVuZCBmb3JcXG4gICAgICBhW2ksIG4sIGpd
IDo9IHMgLyBhW2osIG4sIGpdXFxuICAgIGVuZCBmb3JcXG4gIGVuZCBmb3JcXG5lbmRcIjtcblxu
ZXhwb3J0IGNvbnN0IGFscGFja19kcG90cnMgPSBcInN1YnJvdXRpbmUgYWxwYWNrLmRwb3Rycyhc
XG4gIGw6IGFycmF5IGY2NDsgYjogYXJyYXkgZjY0O1xcbiAgbiwgbnJoczogaTMyXFxuKVxcbnZh
ciByaHMsIGksIGo6IGkzMjsgczogZjY0XFxuYmVnaW5cXG4gIGZvciByaHMgOj0gMCwgbnJoc1xc
biAgICAhIGZvcndhcmQgc3Vic3RpdHV0aW9uOiBMICogeSA9IGJcXG4gICAgZm9yIGkgOj0gMCwg
blxcbiAgICAgIHMgOj0gYltpLCBucmhzLCByaHNdXFxuICAgICAgZm9yIGogOj0gMCwgaVxcbiAg
ICAgICAgcyA6PSBzIC0gbFtpLCBuLCBqXSAqIGJbaiwgbnJocywgcmhzXVxcbiAgICAgIGVuZCBm
b3JcXG4gICAgICBiW2ksIG5yaHMsIHJoc10gOj0gcyAvIGxbaSwgbiwgaV1cXG4gICAgZW5kIGZv
clxcbiAgICAhIGJhY2sgc3Vic3RpdHV0aW9uOiBMXlQgKiB4ID0geVxcbiAgICBmb3IgaSA6PSBu
IC0gMSwgLTEsIC0xXFxuICAgICAgcyA6PSBiW2ksIG5yaHMsIHJoc11cXG4gICAgICBmb3IgaiA6
PSBpICsgMSwgblxcbiAgICAgICAgcyA6PSBzIC0gbFtqLCBuLCBpXSAqIGJbaiwgbnJocywgcmhz
XVxcbiAgICAgIGVuZCBmb3JcXG4gICAgICBiW2ksIG5yaHMsIHJoc10gOj0gcyAvIGxbaSwgbiwg
aV1cXG4gICAgZW5kIGZvclxcbiAgZW5kIGZvclxcbmVuZFwiO1xuXG5leHBvcnQgY29uc3QgYWxw
YWNrX2RnZXRyZiA9IFwic3Vicm91dGluZSBhbHBhY2suZGdldHJmKFxcbiAgYTogYXJyYXkgZjY0
OyBuOiBpMzI7XFxuICBpcGl2OiBhcnJheSBpMzI7IGluZm86IGFycmF5IGkzMlxcbilcXG52YXIg
aSwgaiwgaywgcGl2b3Q6IGkzMjsgdCwgaW52OiBmNjRcXG5iZWdpblxcbiAgaW5mb1swXSA6PSAw
XFxuICBmb3IgayA6PSAwLCBuXFxuICAgICEgZmluZCBwaXZvdCBpbiBjb2x1bW4gayBmcm9tIHJv
dyBrLi5uLTFcXG4gICAgISB1c2UgaW5saW5lIHNlYXJjaCAoaWRhbWF4IG9wZXJhdGVzIG9uIGNv
bnRpZ3VvdXMgdmVjdG9yKVxcbiAgICBwaXZvdCA6PSBrXFxuICAgIHQgOj0gYWJzKGFbaywgbiwg
a10pXFxuICAgIGZvciBpIDo9IGsgKyAxLCBuXFxuICAgICAgaWYgKGFicyhhW2ksIG4sIGtdKSA+
IHQpIHRoZW5cXG4gICAgICAgIHBpdm90IDo9IGlcXG4gICAgICAgIHQgOj0gYWJzKGFbaSwgbiwg
a10pXFxuICAgICAgZW5kIGlmXFxuICAgIGVuZCBmb3JcXG4gICAgaXBpdltrXSA6PSBwaXZvdFxc
blxcbiAgICAhIHN3YXAgcm93cyBrIGFuZCBwaXZvdFxcbiAgICBpZiAocGl2b3QgLz0gaykgdGhl
blxcbiAgICAgIGZvciBqIDo9IDAsIG5cXG4gICAgICAgIHQgOj0gYVtrLCBuLCBqXVxcbiAgICAg
ICAgYVtrLCBuLCBqXSA6PSBhW3Bpdm90LCBuLCBqXVxcbiAgICAgICAgYVtwaXZvdCwgbiwgal0g
Oj0gdFxcbiAgICAgIGVuZCBmb3JcXG4gICAgZW5kIGlmXFxuXFxuICAgIGlmIChhW2ssIG4sIGtd
ID09IDAuMCkgdGhlblxcbiAgICAgIGluZm9bMF0gOj0gayArIDFcXG4gICAgICBjYWxsIHJldHVy
bigpXFxuICAgIGVuZCBpZlxcblxcbiAgICAhIGVsaW1pbmF0ZSBiZWxvdyBkaWFnb25hbFxcbiAg
ICBpbnYgOj0gMS4wIC8gYVtrLCBuLCBrXVxcbiAgICBmb3IgaSA6PSBrICsgMSwgblxcbiAgICAg
IGFbaSwgbiwga10gOj0gYVtpLCBuLCBrXSAqIGludlxcbiAgICAgIGZvciBqIDo9IGsgKyAxLCBu
XFxuICAgICAgICBhW2ksIG4sIGpdIDo9IGFbaSwgbiwgal0gLSBhW2ksIG4sIGtdICogYVtrLCBu
LCBqXVxcbiAgICAgIGVuZCBmb3JcXG4gICAgZW5kIGZvclxcbiAgZW5kIGZvclxcbmVuZFwiO1xu
XG5leHBvcnQgY29uc3QgYWxwYWNrX2RnZXRycyA9IFwic3Vicm91dGluZSBhbHBhY2suZGdldHJz
KFxcbiAgbHU6IGFycmF5IGY2NDsgaXBpdjogYXJyYXkgaTMyO1xcbiAgYjogYXJyYXkgZjY0OyBu
LCBucmhzOiBpMzJcXG4pXFxudmFyIHJocywgaSwgaiwgcDogaTMyOyBzLCB0OiBmNjRcXG5iZWdp
blxcbiAgZm9yIHJocyA6PSAwLCBucmhzXFxuICAgICEgYXBwbHkgcm93IHBlcm11dGF0aW9uXFxu
ICAgIGZvciBpIDo9IDAsIG5cXG4gICAgICBwIDo9IGlwaXZbaV1cXG4gICAgICBpZiAocCAvPSBp
KSB0aGVuXFxuICAgICAgICB0IDo9IGJbaSwgbnJocywgcmhzXVxcbiAgICAgICAgYltpLCBucmhz
LCByaHNdIDo9IGJbcCwgbnJocywgcmhzXVxcbiAgICAgICAgYltwLCBucmhzLCByaHNdIDo9IHRc
XG4gICAgICBlbmQgaWZcXG4gICAgZW5kIGZvclxcbiAgICAhIGZvcndhcmQgc3Vic3RpdHV0aW9u
IChMIHdpdGggdW5pdCBkaWFnb25hbClcXG4gICAgZm9yIGkgOj0gMSwgblxcbiAgICAgIHMgOj0g
YltpLCBucmhzLCByaHNdXFxuICAgICAgZm9yIGogOj0gMCwgaVxcbiAgICAgICAgcyA6PSBzIC0g
bHVbaSwgbiwgal0gKiBiW2osIG5yaHMsIHJoc11cXG4gICAgICBlbmQgZm9yXFxuICAgICAgYltp
LCBucmhzLCByaHNdIDo9IHNcXG4gICAgZW5kIGZvclxcbiAgICAhIGJhY2sgc3Vic3RpdHV0aW9u
IChVKVxcbiAgICBmb3IgaSA6PSBuIC0gMSwgLTEsIC0xXFxuICAgICAgcyA6PSBiW2ksIG5yaHMs
IHJoc11cXG4gICAgICBmb3IgaiA6PSBpICsgMSwgblxcbiAgICAgICAgcyA6PSBzIC0gbHVbaSwg
biwgal0gKiBiW2osIG5yaHMsIHJoc11cXG4gICAgICBlbmQgZm9yXFxuICAgICAgYltpLCBucmhz
LCByaHNdIDo9IHMgLyBsdVtpLCBuLCBpXVxcbiAgICBlbmQgZm9yXFxuICBlbmQgZm9yXFxuZW5k
XCI7XG5cbmV4cG9ydCBjb25zdCBhbHBhY2tfZGdlc3YgPSBcInN1YnJvdXRpbmUgYWxwYWNrLmRn
ZXN2KFxcbiAgYTogYXJyYXkgZjY0OyBiOiBhcnJheSBmNjQ7XFxuICBuLCBucmhzOiBpMzI7XFxu
ICBpcGl2OiBhcnJheSBpMzI7IGluZm86IGFycmF5IGkzMlxcbilcXG5iZWdpblxcbiAgY2FsbCBh
bHBhY2suZGdldHJmKGEsIG4sIGlwaXYsIGluZm8pXFxuICBpZiAoaW5mb1swXSAvPSAwKSB0aGVu
XFxuICAgIGNhbGwgcmV0dXJuKClcXG4gIGVuZCBpZlxcbiAgY2FsbCBhbHBhY2suZGdldHJzKGEs
IGlwaXYsIGIsIG4sIG5yaHMpXFxuZW5kXCI7XG5cbmV4cG9ydCBjb25zdCBhbHBhY2tfZHRydHJp
ID0gXCJzdWJyb3V0aW5lIGFscGFjay5kdHJ0cmkoYTogYXJyYXkgZjY0OyBuOiBpMzI7IGluZm86
IGFycmF5IGkzMilcXG52YXIgaSwgaiwgazogaTMyOyBzOiBmNjRcXG5iZWdpblxcbiAgaW5mb1sw
XSA6PSAwXFxuICBmb3IgaiA6PSAwLCBuXFxuICAgIGlmIChhW2osIG4sIGpdID09IDAuMCkgdGhl
blxcbiAgICAgIGluZm9bMF0gOj0gaiArIDFcXG4gICAgICBjYWxsIHJldHVybigpXFxuICAgIGVu
ZCBpZlxcbiAgICBhW2osIG4sIGpdIDo9IDEuMCAvIGFbaiwgbiwgal1cXG4gICAgZm9yIGkgOj0g
aiArIDEsIG5cXG4gICAgICBzIDo9IDAuMFxcbiAgICAgIGZvciBrIDo9IGosIGlcXG4gICAgICAg
IHMgOj0gcyAtIGFbaSwgbiwga10gKiBhW2ssIG4sIGpdXFxuICAgICAgZW5kIGZvclxcbiAgICAg
IGFbaSwgbiwgal0gOj0gcyAvIGFbaSwgbiwgaV1cXG4gICAgZW5kIGZvclxcbiAgZW5kIGZvclxc
bmVuZFwiO1xuXG5leHBvcnQgY29uc3QgYWxwYWNrX2RzeWV2MyA9IFwic3Vicm91dGluZSBhbHBh
Y2suZHN5ZXYzKGE6IGFycmF5IGY2NDsgdzogYXJyYXkgZjY0KVxcbnZhclxcbiAgYTAwLCBhMDEs
IGEwMiwgYTExLCBhMTIsIGEyMjogZjY0XFxuICBwMSwgcSwgcDIsIHAsIGIwMCwgYjExLCBiMjIs
IGRldF9iLCBoYWxmX2RldDogZjY0XFxuICBwaGksIHIsIGUxLCBlMiwgZTM6IGY2NFxcbiAgbTog
ZjY0XFxuICBwaTogZjY0XFxuYmVnaW5cXG4gIHBpIDo9IDMuMTQxNTkyNjUzNTg5NzkzMjM4NDZc
XG5cXG4gIGEwMCA6PSBhWzAsIDMsIDBdXFxuICBhMDEgOj0gYVswLCAzLCAxXVxcbiAgYTAyIDo9
IGFbMCwgMywgMl1cXG4gIGExMSA6PSBhWzEsIDMsIDFdXFxuICBhMTIgOj0gYVsxLCAzLCAyXVxc
biAgYTIyIDo9IGFbMiwgMywgMl1cXG5cXG4gICEgdHJhY2UgLyAzXFxuICBtIDo9IChhMDAgKyBh
MTEgKyBhMjIpIC8gMy4wXFxuXFxuICAhIHN1bSBvZiBzcXVhcmVzIG9mIG9mZi1kaWFnb25hbCBl
bGVtZW50c1xcbiAgcDEgOj0gYTAxICogYTAxICsgYTAyICogYTAyICsgYTEyICogYTEyXFxuXFxu
ICBpZiAocDEgPD0gMWUtMzApIHRoZW5cXG4gICAgISBkaWFnb25hbCBtYXRyaXgg4oCUIGVpZ2Vu
dmFsdWVzIGFyZSB0aGUgZGlhZ29uYWwgZW50cmllcywgc29ydCBkZXNjZW5kaW5nXFxuICAgIGUx
IDo9IGEwMFxcbiAgICBlMiA6PSBhMTFcXG4gICAgZTMgOj0gYTIyXFxuICAgICEgc29ydCAzIHZh
bHVlcyBkZXNjZW5kaW5nIChidWJibGUgc29ydClcXG4gICAgaWYgKGUyID4gZTEpIHRoZW5cXG4g
ICAgICByIDo9IGUxXFxuICAgICAgZTEgOj0gZTJcXG4gICAgICBlMiA6PSByXFxuICAgIGVuZCBp
ZlxcbiAgICBpZiAoZTMgPiBlMikgdGhlblxcbiAgICAgIHIgOj0gZTJcXG4gICAgICBlMiA6PSBl
M1xcbiAgICAgIGUzIDo9IHJcXG4gICAgZW5kIGlmXFxuICAgIGlmIChlMiA+IGUxKSB0aGVuXFxu
ICAgICAgciA6PSBlMVxcbiAgICAgIGUxIDo9IGUyXFxuICAgICAgZTIgOj0gclxcbiAgICBlbmQg
aWZcXG4gICAgd1swXSA6PSBlMVxcbiAgICB3WzFdIDo9IGUyXFxuICAgIHdbMl0gOj0gZTNcXG4g
ICAgY2FsbCByZXR1cm4oKVxcbiAgZW5kIGlmXFxuXFxuICBxIDo9IG1cXG4gIHAyIDo9IChhMDAg
LSBxKSAqIChhMDAgLSBxKSArIChhMTEgLSBxKSAqIChhMTEgLSBxKSArIChhMjIgLSBxKSAqIChh
MjIgLSBxKSArIDIuMCAqIHAxXFxuICBwIDo9IHNxcnQocDIgLyA2LjApXFxuXFxuICAhIEIgPSAo
QSAtIHEqSSkgLyBwICDigJQgb25seSBuZWVkIGRldGVybWluYW50XFxuICBiMDAgOj0gKGEwMCAt
IHEpIC8gcFxcbiAgYjExIDo9IChhMTEgLSBxKSAvIHBcXG4gIGIyMiA6PSAoYTIyIC0gcSkgLyBw
XFxuICAhIGRldChCKSBmb3Igc3ltbWV0cmljIDN4M1xcbiAgZGV0X2IgOj0gYjAwICogKGIxMSAq
IGIyMiAtIChhMTIgLyBwKSAqIChhMTIgLyBwKSlcXG4gICAgICAgICAtIChhMDEgLyBwKSAqICgo
YTAxIC8gcCkgKiBiMjIgLSAoYTEyIC8gcCkgKiAoYTAyIC8gcCkpXFxuICAgICAgICAgKyAoYTAy
IC8gcCkgKiAoKGEwMSAvIHApICogKGExMiAvIHApIC0gYjExICogKGEwMiAvIHApKVxcbiAgaGFs
Zl9kZXQgOj0gZGV0X2IgLyAyLjBcXG5cXG4gICEgY2xhbXAgdG8gWy0xLCAxXSBmb3IgYWNvc1xc
biAgaWYgKGhhbGZfZGV0IDw9IC0xLjApIHRoZW5cXG4gICAgcGhpIDo9IHBpIC8gMy4wXFxuICBl
bHNlIGlmIChoYWxmX2RldCA+PSAxLjApIHRoZW5cXG4gICAgcGhpIDo9IDAuMFxcbiAgZWxzZVxc
biAgICBwaGkgOj0gYXRhbjIoc3FydCgxLjAgLSBoYWxmX2RldCAqIGhhbGZfZGV0KSwgaGFsZl9k
ZXQpIC8gMy4wXFxuICBlbmQgaWZcXG5cXG4gICEgZWlnZW52YWx1ZXMgaW4gZGVzY2VuZGluZyBv
cmRlclxcbiAgZTEgOj0gcSArIDIuMCAqIHAgKiBjb3MocGhpKVxcbiAgZTMgOj0gcSArIDIuMCAq
IHAgKiBjb3MocGhpICsgMi4wICogcGkgLyAzLjApXFxuICBlMiA6PSAzLjAgKiBxIC0gZTEgLSBl
M1xcblxcbiAgd1swXSA6PSBlMVxcbiAgd1sxXSA6PSBlMlxcbiAgd1syXSA6PSBlM1xcbmVuZFwi
O1xuXG5leHBvcnQgY29uc3QgYWxwYWNrX2RzeWV2ID0gXCJzdWJyb3V0aW5lIGFscGFjay5kc3ll
dihcXG4gIGE6IGFycmF5IGY2NDsgdzogYXJyYXkgZjY0O1xcbiAgbjogaTMyOyBpbmZvOiBhcnJh
eSBpMzJcXG4pXFxudmFyXFxuICBpLCBqLCBwLCBxLCBpdGVyLCBtYXhJdGVyOiBpMzJcXG4gIG9m
ZiwgdGhyZXNoLCBhcHAsIGFxcSwgYXBxOiBmNjRcXG4gIHRhdSwgdCwgYywgcywgdG1wOiBmNjRc
XG5iZWdpblxcbiAgaW5mb1swXSA6PSAwXFxuICBtYXhJdGVyIDo9IDEwMFxcblxcbiAgISBpbml0
aWFsaXplIHcgdG8gZGlhZ29uYWwgb2YgYVxcbiAgZm9yIGkgOj0gMCwgblxcbiAgICB3W2ldIDo9
IGFbaSwgbiwgaV1cXG4gIGVuZCBmb3JcXG5cXG4gIGZvciBpdGVyIDo9IDAsIG1heEl0ZXJcXG4g
ICAgISBjb21wdXRlIG9mZi1kaWFnb25hbCBub3JtXFxuICAgIG9mZiA6PSAwLjBcXG4gICAgZm9y
IHAgOj0gMCwgblxcbiAgICAgIGZvciBxIDo9IHAgKyAxLCBuXFxuICAgICAgICBvZmYgOj0gb2Zm
ICsgYVtwLCBuLCBxXSAqIGFbcCwgbiwgcV1cXG4gICAgICBlbmQgZm9yXFxuICAgIGVuZCBmb3Jc
XG4gICAgaWYgKG9mZiA8IDFlLTI4KSB0aGVuXFxuICAgICAgY2FsbCByZXR1cm4oKVxcbiAgICBl
bmQgaWZcXG5cXG4gICAgdGhyZXNoIDo9IGlmIChpdGVyIDwgNCkgdGhlbiAwLjIgKiBvZmYgLyBm
NjQobiAqIG4pIGVsc2UgMC4wXFxuXFxuICAgIGZvciBwIDo9IDAsIG5cXG4gICAgICBmb3IgcSA6
PSBwICsgMSwgblxcbiAgICAgICAgYXBxIDo9IGFbcCwgbiwgcV1cXG4gICAgICAgIGlmIChhYnMo
YXBxKSA8PSB0aHJlc2gpIHRoZW5cXG4gICAgICAgICAgISBza2lwIHNtYWxsIGVsZW1lbnRzIGlu
IGVhcmx5IHN3ZWVwc1xcbiAgICAgICAgZWxzZVxcbiAgICAgICAgICBhcHAgOj0gd1twXVxcbiAg
ICAgICAgICBhcXEgOj0gd1txXVxcbiAgICAgICAgICAhIEphY29iaSByb3RhdGlvbiBhbmdsZVxc
biAgICAgICAgICB0YXUgOj0gKGFxcSAtIGFwcCkgLyAoMi4wICogYXBxKVxcbiAgICAgICAgICBp
ZiAodGF1ID49IDAuMCkgdGhlblxcbiAgICAgICAgICAgIHQgOj0gMS4wIC8gKHRhdSArIHNxcnQo
MS4wICsgdGF1ICogdGF1KSlcXG4gICAgICAgICAgZWxzZVxcbiAgICAgICAgICAgIHQgOj0gMC4w
IC0gMS4wIC8gKDAuMCAtIHRhdSArIHNxcnQoMS4wICsgdGF1ICogdGF1KSlcXG4gICAgICAgICAg
ZW5kIGlmXFxuICAgICAgICAgIGMgOj0gMS4wIC8gc3FydCgxLjAgKyB0ICogdClcXG4gICAgICAg
ICAgcyA6PSB0ICogY1xcblxcbiAgICAgICAgICAhIHVwZGF0ZSBlaWdlbnZhbHVlc1xcbiAgICAg
ICAgICB3W3BdIDo9IGFwcCAtIHQgKiBhcHFcXG4gICAgICAgICAgd1txXSA6PSBhcXEgKyB0ICog
YXBxXFxuICAgICAgICAgIGFbcCwgbiwgcV0gOj0gMC4wXFxuXFxuICAgICAgICAgICEgcm90YXRl
IHJvd3MvY29sdW1ucyBwIGFuZCBxXFxuICAgICAgICAgIGZvciBpIDo9IDAsIHBcXG4gICAgICAg
ICAgICB0bXAgOj0gYVtpLCBuLCBwXVxcbiAgICAgICAgICAgIGFbaSwgbiwgcF0gOj0gYyAqIHRt
cCAtIHMgKiBhW2ksIG4sIHFdXFxuICAgICAgICAgICAgYVtpLCBuLCBxXSA6PSBzICogdG1wICsg
YyAqIGFbaSwgbiwgcV1cXG4gICAgICAgICAgZW5kIGZvclxcbiAgICAgICAgICBmb3IgaSA6PSBw
ICsgMSwgcVxcbiAgICAgICAgICAgIHRtcCA6PSBhW3AsIG4sIGldXFxuICAgICAgICAgICAgYVtw
LCBuLCBpXSA6PSBjICogdG1wIC0gcyAqIGFbaSwgbiwgcV1cXG4gICAgICAgICAgICBhW2ksIG4s
IHFdIDo9IHMgKiB0bXAgKyBjICogYVtpLCBuLCBxXVxcbiAgICAgICAgICBlbmQgZm9yXFxuICAg
ICAgICAgIGZvciBpIDo9IHEgKyAxLCBuXFxuICAgICAgICAgICAgdG1wIDo9IGFbcCwgbiwgaV1c
XG4gICAgICAgICAgICBhW3AsIG4sIGldIDo9IGMgKiB0bXAgLSBzICogYVtxLCBuLCBpXVxcbiAg
ICAgICAgICAgIGFbcSwgbiwgaV0gOj0gcyAqIHRtcCArIGMgKiBhW3EsIG4sIGldXFxuICAgICAg
ICAgIGVuZCBmb3JcXG4gICAgICAgIGVuZCBpZlxcbiAgICAgIGVuZCBmb3JcXG4gICAgZW5kIGZv
clxcbiAgZW5kIGZvclxcbiAgaW5mb1swXSA6PSAxXFxuZW5kXCI7XG5cbmV4cG9ydCBjb25zdCBz
b3VyY2VzID0ge1xuICBcImFsYXMuZHNjYWxcIjogXCJzdWJyb3V0aW5lIGFsYXMuZHNjYWwoeDog
YXJyYXkgZjY0OyBuOiBpMzI7IGFscGhhOiBmNjQpXFxudmFyIGk6IGkzMlxcbmJlZ2luXFxuICBm
b3IgaSA6PSAwLCBuXFxuICAgIHhbaV0gOj0gYWxwaGEgKiB4W2ldXFxuICBlbmQgZm9yXFxuZW5k
XCIsXG4gIFwiYWxhcy5kY29weVwiOiBcInN1YnJvdXRpbmUgYWxhcy5kY29weSh4OiBhcnJheSBm
NjQ7IHk6IGFycmF5IGY2NDsgbjogaTMyKVxcbnZhciBpOiBpMzJcXG5iZWdpblxcbiAgZm9yIGkg
Oj0gMCwgblxcbiAgICB5W2ldIDo9IHhbaV1cXG4gIGVuZCBmb3JcXG5lbmRcIixcbiAgXCJhbGFz
LmRheHB5XCI6IFwic3Vicm91dGluZSBhbGFzLmRheHB5KHg6IGFycmF5IGY2NDsgeTogYXJyYXkg
ZjY0OyBuOiBpMzI7IGFscGhhOiBmNjQpXFxudmFyXFxuICBpLCBuMjogaTMyXFxuICB2YSwgdngs
IHZ5OiBmNjR4MlxcbmJlZ2luXFxuICAhIHNjYWxhciB2ZXJzaW9uIChmb3IgcmVmZXJlbmNlKTpc
XG4gICEgICBmb3IgaSA6PSAwLCBuXFxuICAhICAgICB5W2ldIDo9IGFscGhhICogeFtpXSArIHlb
aV1cXG4gICEgICBlbmQgZm9yXFxuICB2YSA6PSBmNjR4Mi5zcGxhdChhbHBoYSlcXG4gIG4yIDo9
IG4gLyAyXFxuICBmb3IgaSA6PSAwLCBuMlxcbiAgICB2eCA6PSB2MTI4LmxvYWQoeCwgaSlcXG4g
ICAgdnkgOj0gdjEyOC5sb2FkKHksIGkpXFxuICAgIHZ5IDo9IHZhICogdnggKyB2eVxcbiAgICBj
YWxsIHYxMjguc3RvcmUoeSwgaSwgdnkpXFxuICBlbmQgZm9yXFxuICAhIHNjYWxhciB0YWlsIGZv
ciBvZGQgZWxlbWVudFxcbiAgaWYgKG4yICogMiA8IG4pIHRoZW5cXG4gICAgaSA6PSBuMiAqIDJc
XG4gICAgeVtpXSA6PSBhbHBoYSAqIHhbaV0gKyB5W2ldXFxuICBlbmQgaWZcXG5lbmRcIixcbiAg
XCJhbGFzLmRkb3RcIjogXCJmdW5jdGlvbiBhbGFzLmRkb3QoeDogYXJyYXkgZjY0OyB5OiBhcnJh
eSBmNjQ7IG46IGkzMik6IGY2NFxcbnZhclxcbiAgaSwgbjI6IGkzMlxcbiAgdngsIHZ5LCB2czog
ZjY0eDJcXG5iZWdpblxcbiAgISBzY2FsYXIgdmVyc2lvbjpcXG4gICEgICBhbGFzLmRkb3QgOj0g
MC4wXFxuICAhICAgZm9yIGkgOj0gMCwgblxcbiAgISAgICAgYWxhcy5kZG90IDo9IGFsYXMuZGRv
dCArIHhbaV0gKiB5W2ldXFxuICAhICAgZW5kIGZvclxcbiAgdnMgOj0gZjY0eDIuc3BsYXQoMC4w
KVxcbiAgbjIgOj0gbiAvIDJcXG4gIGZvciBpIDo9IDAsIG4yXFxuICAgIHZ4IDo9IHYxMjgubG9h
ZCh4LCBpKVxcbiAgICB2eSA6PSB2MTI4LmxvYWQoeSwgaSlcXG4gICAgdnMgOj0gdnMgKyB2eCAq
IHZ5XFxuICBlbmQgZm9yXFxuICBhbGFzLmRkb3QgOj0gZjY0eDIuZXh0cmFjdF9sYW5lKHZzLCAw
KSArIGY2NHgyLmV4dHJhY3RfbGFuZSh2cywgMSlcXG4gICEgc2NhbGFyIHRhaWxcXG4gIGlmIChu
MiAqIDIgPCBuKSB0aGVuXFxuICAgIGkgOj0gbjIgKiAyXFxuICAgIGFsYXMuZGRvdCA6PSBhbGFz
LmRkb3QgKyB4W2ldICogeVtpXVxcbiAgZW5kIGlmXFxuZW5kXCIsXG4gIFwiYWxhcy5kbnJtMlwi
OiBcImZ1bmN0aW9uIGFsYXMuZG5ybTIoeDogYXJyYXkgZjY0OyBuOiBpMzIpOiBmNjRcXG52YXJc
XG4gIGksIG4yOiBpMzJcXG4gIHZ4LCB2czogZjY0eDJcXG5iZWdpblxcbiAgdnMgOj0gZjY0eDIu
c3BsYXQoMC4wKVxcbiAgbjIgOj0gbiAvIDJcXG4gIGZvciBpIDo9IDAsIG4yXFxuICAgIHZ4IDo9
IHYxMjgubG9hZCh4LCBpKVxcbiAgICB2cyA6PSB2cyArIHZ4ICogdnhcXG4gIGVuZCBmb3JcXG4g
IGFsYXMuZG5ybTIgOj0gZjY0eDIuZXh0cmFjdF9sYW5lKHZzLCAwKSArIGY2NHgyLmV4dHJhY3Rf
bGFuZSh2cywgMSlcXG4gIGlmIChuMiAqIDIgPCBuKSB0aGVuXFxuICAgIGkgOj0gbjIgKiAyXFxu
ICAgIGFsYXMuZG5ybTIgOj0gYWxhcy5kbnJtMiArIHhbaV0gKiB4W2ldXFxuICBlbmQgaWZcXG4g
IGFsYXMuZG5ybTIgOj0gc3FydChhbGFzLmRucm0yKVxcbmVuZFwiLFxuICBcImFsYXMuZHN3YXBc
IjogXCJzdWJyb3V0aW5lIGFsYXMuZHN3YXAoeDogYXJyYXkgZjY0OyB5OiBhcnJheSBmNjQ7IG46
IGkzMilcXG52YXIgaTogaTMyOyB0OiBmNjRcXG5iZWdpblxcbiAgZm9yIGkgOj0gMCwgblxcbiAg
ICB0IDo9IHhbaV1cXG4gICAgeFtpXSA6PSB5W2ldXFxuICAgIHlbaV0gOj0gdFxcbiAgZW5kIGZv
clxcbmVuZFwiLFxuICBcImFsYXMuaWRhbWF4XCI6IFwiZnVuY3Rpb24gYWxhcy5pZGFtYXgoeDog
YXJyYXkgZjY0OyBuOiBpMzIpOiBpMzJcXG52YXIgaTogaTMyOyBteDogZjY0OyB2OiBmNjRcXG5i
ZWdpblxcbiAgYWxhcy5pZGFtYXggOj0gMFxcbiAgbXggOj0gYWJzKHhbMF0pXFxuICBmb3IgaSA6
PSAxLCBuXFxuICAgIHYgOj0gYWJzKHhbaV0pXFxuICAgIGlmICh2ID4gbXgpIHRoZW5cXG4gICAg
ICBteCA6PSB2XFxuICAgICAgYWxhcy5pZGFtYXggOj0gaVxcbiAgICBlbmQgaWZcXG4gIGVuZCBm
b3JcXG5lbmRcIixcbiAgXCJhbGFzLmRnZW12XCI6IFwic3Vicm91dGluZSBhbGFzLmRnZW12KFxc
biAgYTogYXJyYXkgZjY0OyB4OiBhcnJheSBmNjQ7IHk6IGFycmF5IGY2NDtcXG4gIG0sIG46IGkz
MjsgYWxwaGEsIGJldGE6IGY2NFxcbilcXG52YXIgaSwgajogaTMyOyBzOiBmNjRcXG5iZWdpblxc
biAgZm9yIGkgOj0gMCwgbVxcbiAgICBzIDo9IDAuMFxcbiAgICBmb3IgaiA6PSAwLCBuXFxuICAg
ICAgcyA6PSBzICsgYVtpLCBuLCBqXSAqIHhbal1cXG4gICAgZW5kIGZvclxcbiAgICB5W2ldIDo9
IGFscGhhICogcyArIGJldGEgKiB5W2ldXFxuICBlbmQgZm9yXFxuZW5kXCIsXG4gIFwiYWxhcy5k
dHJzdlwiOiBcInN1YnJvdXRpbmUgYWxhcy5kdHJzdihcXG4gIGE6IGFycmF5IGY2NDsgeDogYXJy
YXkgZjY0O1xcbiAgbiwgdXBsbywgdHJhbnM6IGkzMlxcbilcXG52YXIgaSwgajogaTMyOyBzOiBm
NjRcXG5iZWdpblxcbiAgaWYgKHVwbG8gPT0gMCBhbmQgdHJhbnMgPT0gMCkgdGhlblxcbiAgICAh
IGxvd2VyLCBubyB0cmFuc3Bvc2U6IGZvcndhcmQgc3Vic3RpdHV0aW9uXFxuICAgIGZvciBpIDo9
IDAsIG5cXG4gICAgICBzIDo9IHhbaV1cXG4gICAgICBmb3IgaiA6PSAwLCBpXFxuICAgICAgICBz
IDo9IHMgLSBhW2ksIG4sIGpdICogeFtqXVxcbiAgICAgIGVuZCBmb3JcXG4gICAgICB4W2ldIDo9
IHMgLyBhW2ksIG4sIGldXFxuICAgIGVuZCBmb3JcXG4gIGVsc2UgaWYgKHVwbG8gPT0gMCBhbmQg
dHJhbnMgPT0gMSkgdGhlblxcbiAgICAhIGxvd2VyLCB0cmFuc3Bvc2UgKD0gdXBwZXIpOiBiYWNr
IHN1YnN0aXR1dGlvblxcbiAgICBmb3IgaSA6PSBuIC0gMSwgLTEsIC0xXFxuICAgICAgcyA6PSB4
W2ldXFxuICAgICAgZm9yIGogOj0gaSArIDEsIG5cXG4gICAgICAgIHMgOj0gcyAtIGFbaiwgbiwg
aV0gKiB4W2pdXFxuICAgICAgZW5kIGZvclxcbiAgICAgIHhbaV0gOj0gcyAvIGFbaSwgbiwgaV1c
XG4gICAgZW5kIGZvclxcbiAgZWxzZSBpZiAodXBsbyA9PSAxIGFuZCB0cmFucyA9PSAwKSB0aGVu
XFxuICAgICEgdXBwZXIsIG5vIHRyYW5zcG9zZTogYmFjayBzdWJzdGl0dXRpb25cXG4gICAgZm9y
IGkgOj0gbiAtIDEsIC0xLCAtMVxcbiAgICAgIHMgOj0geFtpXVxcbiAgICAgIGZvciBqIDo9IGkg
KyAxLCBuXFxuICAgICAgICBzIDo9IHMgLSBhW2ksIG4sIGpdICogeFtqXVxcbiAgICAgIGVuZCBm
b3JcXG4gICAgICB4W2ldIDo9IHMgLyBhW2ksIG4sIGldXFxuICAgIGVuZCBmb3JcXG4gIGVsc2Vc
XG4gICAgISB1cHBlciwgdHJhbnNwb3NlICg9IGxvd2VyKTogZm9yd2FyZCBzdWJzdGl0dXRpb25c
XG4gICAgZm9yIGkgOj0gMCwgblxcbiAgICAgIHMgOj0geFtpXVxcbiAgICAgIGZvciBqIDo9IDAs
IGlcXG4gICAgICAgIHMgOj0gcyAtIGFbaiwgbiwgaV0gKiB4W2pdXFxuICAgICAgZW5kIGZvclxc
biAgICAgIHhbaV0gOj0gcyAvIGFbaSwgbiwgaV1cXG4gICAgZW5kIGZvclxcbiAgZW5kIGlmXFxu
ZW5kXCIsXG4gIFwiYWxhcy5kZ2VyXCI6IFwic3Vicm91dGluZSBhbGFzLmRnZXIoXFxuICBhOiBh
cnJheSBmNjQ7IHg6IGFycmF5IGY2NDsgeTogYXJyYXkgZjY0O1xcbiAgbSwgbjogaTMyOyBhbHBo
YTogZjY0XFxuKVxcbnZhciBpLCBqOiBpMzI7IHQ6IGY2NFxcbmJlZ2luXFxuICBmb3IgaSA6PSAw
LCBtXFxuICAgIHQgOj0gYWxwaGEgKiB4W2ldXFxuICAgIGZvciBqIDo9IDAsIG5cXG4gICAgICBh
W2ksIG4sIGpdIDo9IGFbaSwgbiwgal0gKyB0ICogeVtqXVxcbiAgICBlbmQgZm9yXFxuICBlbmQg
Zm9yXFxuZW5kXCIsXG4gIFwiYWxhcy5kc3ltdlwiOiBcInN1YnJvdXRpbmUgYWxhcy5kc3ltdihc
XG4gIGE6IGFycmF5IGY2NDsgeDogYXJyYXkgZjY0OyB5OiBhcnJheSBmNjQ7XFxuICBuOiBpMzI7
IGFscGhhLCBiZXRhOiBmNjRcXG4pXFxudmFyIGksIGo6IGkzMjsgcywgdDogZjY0XFxuYmVnaW5c
XG4gICEgc2NhbGUgeSBieSBiZXRhXFxuICBmb3IgaSA6PSAwLCBuXFxuICAgIHlbaV0gOj0gYmV0
YSAqIHlbaV1cXG4gIGVuZCBmb3JcXG4gICEgYWNjdW11bGF0ZTogZGlhZ29uYWwgKyBvZmYtZGlh
Z29uYWwgKHN5bW1ldHJpYylcXG4gIGZvciBpIDo9IDAsIG5cXG4gICAgcyA6PSAwLjBcXG4gICAg
Zm9yIGogOj0gMCwgaVxcbiAgICAgIHQgOj0gYWxwaGEgKiBhW2ksIG4sIGpdXFxuICAgICAgcyA6
PSBzICsgdCAqIHhbal1cXG4gICAgICB5W2pdIDo9IHlbal0gKyB0ICogeFtpXVxcbiAgICBlbmQg
Zm9yXFxuICAgIHlbaV0gOj0geVtpXSArIHMgKyBhbHBoYSAqIGFbaSwgbiwgaV0gKiB4W2ldXFxu
ICBlbmQgZm9yXFxuZW5kXCIsXG4gIFwiYWxhcy5kZ2VtbVwiOiBcInN1YnJvdXRpbmUgYWxhcy5k
Z2VtbShcXG4gIGE6IGFycmF5IGY2NDsgYjogYXJyYXkgZjY0OyBjOiBhcnJheSBmNjQ7XFxuICBt
LCBuLCBrOiBpMzI7IGFscGhhLCBiZXRhOiBmNjRcXG4pXFxudmFyXFxuICBpLCBqLCBwOiBpMzJc
XG4gIHM6IGY2NFxcbmJlZ2luXFxuICBmb3IgaSA6PSAwLCBtXFxuICAgIGZvciBqIDo9IDAsIG5c
XG4gICAgICBzIDo9IDAuMFxcbiAgICAgIGZvciBwIDo9IDAsIGtcXG4gICAgICAgIHMgOj0gcyAr
IGFbaSwgaywgcF0gKiBiW3AsIG4sIGpdXFxuICAgICAgZW5kIGZvclxcbiAgICAgIGNbaSwgbiwg
al0gOj0gYWxwaGEgKiBzICsgYmV0YSAqIGNbaSwgbiwgal1cXG4gICAgZW5kIGZvclxcbiAgZW5k
IGZvclxcbmVuZFwiLFxuICBcImFscGFjay5kcG90cmZcIjogXCJzdWJyb3V0aW5lIGFscGFjay5k
cG90cmYoYTogYXJyYXkgZjY0OyBuOiBpMzI7IGluZm86IGFycmF5IGkzMilcXG52YXIgaSwgaiwg
azogaTMyOyBzOiBmNjRcXG5iZWdpblxcbiAgaW5mb1swXSA6PSAwXFxuICBmb3IgaiA6PSAwLCBu
XFxuICAgIHMgOj0gYVtqLCBuLCBqXVxcbiAgICBmb3IgayA6PSAwLCBqXFxuICAgICAgcyA6PSBz
IC0gYVtqLCBuLCBrXSAqIGFbaiwgbiwga11cXG4gICAgZW5kIGZvclxcbiAgICBpZiAocyA8PSAw
LjApIHRoZW5cXG4gICAgICBpbmZvWzBdIDo9IGogKyAxXFxuICAgICAgY2FsbCByZXR1cm4oKVxc
biAgICBlbmQgaWZcXG4gICAgYVtqLCBuLCBqXSA6PSBzcXJ0KHMpXFxuICAgIGZvciBpIDo9IGog
KyAxLCBuXFxuICAgICAgcyA6PSBhW2ksIG4sIGpdXFxuICAgICAgZm9yIGsgOj0gMCwgalxcbiAg
ICAgICAgcyA6PSBzIC0gYVtpLCBuLCBrXSAqIGFbaiwgbiwga11cXG4gICAgICBlbmQgZm9yXFxu
ICAgICAgYVtpLCBuLCBqXSA6PSBzIC8gYVtqLCBuLCBqXVxcbiAgICBlbmQgZm9yXFxuICBlbmQg
Zm9yXFxuZW5kXCIsXG4gIFwiYWxwYWNrLmRwb3Ryc1wiOiBcInN1YnJvdXRpbmUgYWxwYWNrLmRw
b3RycyhcXG4gIGw6IGFycmF5IGY2NDsgYjogYXJyYXkgZjY0O1xcbiAgbiwgbnJoczogaTMyXFxu
KVxcbnZhciByaHMsIGksIGo6IGkzMjsgczogZjY0XFxuYmVnaW5cXG4gIGZvciByaHMgOj0gMCwg
bnJoc1xcbiAgICAhIGZvcndhcmQgc3Vic3RpdHV0aW9uOiBMICogeSA9IGJcXG4gICAgZm9yIGkg
Oj0gMCwgblxcbiAgICAgIHMgOj0gYltpLCBucmhzLCByaHNdXFxuICAgICAgZm9yIGogOj0gMCwg
aVxcbiAgICAgICAgcyA6PSBzIC0gbFtpLCBuLCBqXSAqIGJbaiwgbnJocywgcmhzXVxcbiAgICAg
IGVuZCBmb3JcXG4gICAgICBiW2ksIG5yaHMsIHJoc10gOj0gcyAvIGxbaSwgbiwgaV1cXG4gICAg
ZW5kIGZvclxcbiAgICAhIGJhY2sgc3Vic3RpdHV0aW9uOiBMXlQgKiB4ID0geVxcbiAgICBmb3Ig
aSA6PSBuIC0gMSwgLTEsIC0xXFxuICAgICAgcyA6PSBiW2ksIG5yaHMsIHJoc11cXG4gICAgICBm
b3IgaiA6PSBpICsgMSwgblxcbiAgICAgICAgcyA6PSBzIC0gbFtqLCBuLCBpXSAqIGJbaiwgbnJo
cywgcmhzXVxcbiAgICAgIGVuZCBmb3JcXG4gICAgICBiW2ksIG5yaHMsIHJoc10gOj0gcyAvIGxb
aSwgbiwgaV1cXG4gICAgZW5kIGZvclxcbiAgZW5kIGZvclxcbmVuZFwiLFxuICBcImFscGFjay5k
Z2V0cmZcIjogXCJzdWJyb3V0aW5lIGFscGFjay5kZ2V0cmYoXFxuICBhOiBhcnJheSBmNjQ7IG46
IGkzMjtcXG4gIGlwaXY6IGFycmF5IGkzMjsgaW5mbzogYXJyYXkgaTMyXFxuKVxcbnZhciBpLCBq
LCBrLCBwaXZvdDogaTMyOyB0LCBpbnY6IGY2NFxcbmJlZ2luXFxuICBpbmZvWzBdIDo9IDBcXG4g
IGZvciBrIDo9IDAsIG5cXG4gICAgISBmaW5kIHBpdm90IGluIGNvbHVtbiBrIGZyb20gcm93IGsu
Lm4tMVxcbiAgICAhIHVzZSBpbmxpbmUgc2VhcmNoIChpZGFtYXggb3BlcmF0ZXMgb24gY29udGln
dW91cyB2ZWN0b3IpXFxuICAgIHBpdm90IDo9IGtcXG4gICAgdCA6PSBhYnMoYVtrLCBuLCBrXSlc
XG4gICAgZm9yIGkgOj0gayArIDEsIG5cXG4gICAgICBpZiAoYWJzKGFbaSwgbiwga10pID4gdCkg
dGhlblxcbiAgICAgICAgcGl2b3QgOj0gaVxcbiAgICAgICAgdCA6PSBhYnMoYVtpLCBuLCBrXSlc
XG4gICAgICBlbmQgaWZcXG4gICAgZW5kIGZvclxcbiAgICBpcGl2W2tdIDo9IHBpdm90XFxuXFxu
ICAgICEgc3dhcCByb3dzIGsgYW5kIHBpdm90XFxuICAgIGlmIChwaXZvdCAvPSBrKSB0aGVuXFxu
ICAgICAgZm9yIGogOj0gMCwgblxcbiAgICAgICAgdCA6PSBhW2ssIG4sIGpdXFxuICAgICAgICBh
W2ssIG4sIGpdIDo9IGFbcGl2b3QsIG4sIGpdXFxuICAgICAgICBhW3Bpdm90LCBuLCBqXSA6PSB0
XFxuICAgICAgZW5kIGZvclxcbiAgICBlbmQgaWZcXG5cXG4gICAgaWYgKGFbaywgbiwga10gPT0g
MC4wKSB0aGVuXFxuICAgICAgaW5mb1swXSA6PSBrICsgMVxcbiAgICAgIGNhbGwgcmV0dXJuKClc
XG4gICAgZW5kIGlmXFxuXFxuICAgICEgZWxpbWluYXRlIGJlbG93IGRpYWdvbmFsXFxuICAgIGlu
diA6PSAxLjAgLyBhW2ssIG4sIGtdXFxuICAgIGZvciBpIDo9IGsgKyAxLCBuXFxuICAgICAgYVtp
LCBuLCBrXSA6PSBhW2ksIG4sIGtdICogaW52XFxuICAgICAgZm9yIGogOj0gayArIDEsIG5cXG4g
ICAgICAgIGFbaSwgbiwgal0gOj0gYVtpLCBuLCBqXSAtIGFbaSwgbiwga10gKiBhW2ssIG4sIGpd
XFxuICAgICAgZW5kIGZvclxcbiAgICBlbmQgZm9yXFxuICBlbmQgZm9yXFxuZW5kXCIsXG4gIFwi
YWxwYWNrLmRnZXRyc1wiOiBcInN1YnJvdXRpbmUgYWxwYWNrLmRnZXRycyhcXG4gIGx1OiBhcnJh
eSBmNjQ7IGlwaXY6IGFycmF5IGkzMjtcXG4gIGI6IGFycmF5IGY2NDsgbiwgbnJoczogaTMyXFxu
KVxcbnZhciByaHMsIGksIGosIHA6IGkzMjsgcywgdDogZjY0XFxuYmVnaW5cXG4gIGZvciByaHMg
Oj0gMCwgbnJoc1xcbiAgICAhIGFwcGx5IHJvdyBwZXJtdXRhdGlvblxcbiAgICBmb3IgaSA6PSAw
LCBuXFxuICAgICAgcCA6PSBpcGl2W2ldXFxuICAgICAgaWYgKHAgLz0gaSkgdGhlblxcbiAgICAg
ICAgdCA6PSBiW2ksIG5yaHMsIHJoc11cXG4gICAgICAgIGJbaSwgbnJocywgcmhzXSA6PSBiW3As
IG5yaHMsIHJoc11cXG4gICAgICAgIGJbcCwgbnJocywgcmhzXSA6PSB0XFxuICAgICAgZW5kIGlm
XFxuICAgIGVuZCBmb3JcXG4gICAgISBmb3J3YXJkIHN1YnN0aXR1dGlvbiAoTCB3aXRoIHVuaXQg
ZGlhZ29uYWwpXFxuICAgIGZvciBpIDo9IDEsIG5cXG4gICAgICBzIDo9IGJbaSwgbnJocywgcmhz
XVxcbiAgICAgIGZvciBqIDo9IDAsIGlcXG4gICAgICAgIHMgOj0gcyAtIGx1W2ksIG4sIGpdICog
YltqLCBucmhzLCByaHNdXFxuICAgICAgZW5kIGZvclxcbiAgICAgIGJbaSwgbnJocywgcmhzXSA6
PSBzXFxuICAgIGVuZCBmb3JcXG4gICAgISBiYWNrIHN1YnN0aXR1dGlvbiAoVSlcXG4gICAgZm9y
IGkgOj0gbiAtIDEsIC0xLCAtMVxcbiAgICAgIHMgOj0gYltpLCBucmhzLCByaHNdXFxuICAgICAg
Zm9yIGogOj0gaSArIDEsIG5cXG4gICAgICAgIHMgOj0gcyAtIGx1W2ksIG4sIGpdICogYltqLCBu
cmhzLCByaHNdXFxuICAgICAgZW5kIGZvclxcbiAgICAgIGJbaSwgbnJocywgcmhzXSA6PSBzIC8g
bHVbaSwgbiwgaV1cXG4gICAgZW5kIGZvclxcbiAgZW5kIGZvclxcbmVuZFwiLFxuICBcImFscGFj
ay5kZ2VzdlwiOiBcInN1YnJvdXRpbmUgYWxwYWNrLmRnZXN2KFxcbiAgYTogYXJyYXkgZjY0OyBi
OiBhcnJheSBmNjQ7XFxuICBuLCBucmhzOiBpMzI7XFxuICBpcGl2OiBhcnJheSBpMzI7IGluZm86
IGFycmF5IGkzMlxcbilcXG5iZWdpblxcbiAgY2FsbCBhbHBhY2suZGdldHJmKGEsIG4sIGlwaXYs
IGluZm8pXFxuICBpZiAoaW5mb1swXSAvPSAwKSB0aGVuXFxuICAgIGNhbGwgcmV0dXJuKClcXG4g
IGVuZCBpZlxcbiAgY2FsbCBhbHBhY2suZGdldHJzKGEsIGlwaXYsIGIsIG4sIG5yaHMpXFxuZW5k
XCIsXG4gIFwiYWxwYWNrLmR0cnRyaVwiOiBcInN1YnJvdXRpbmUgYWxwYWNrLmR0cnRyaShhOiBh
cnJheSBmNjQ7IG46IGkzMjsgaW5mbzogYXJyYXkgaTMyKVxcbnZhciBpLCBqLCBrOiBpMzI7IHM6
IGY2NFxcbmJlZ2luXFxuICBpbmZvWzBdIDo9IDBcXG4gIGZvciBqIDo9IDAsIG5cXG4gICAgaWYg
KGFbaiwgbiwgal0gPT0gMC4wKSB0aGVuXFxuICAgICAgaW5mb1swXSA6PSBqICsgMVxcbiAgICAg
IGNhbGwgcmV0dXJuKClcXG4gICAgZW5kIGlmXFxuICAgIGFbaiwgbiwgal0gOj0gMS4wIC8gYVtq
LCBuLCBqXVxcbiAgICBmb3IgaSA6PSBqICsgMSwgblxcbiAgICAgIHMgOj0gMC4wXFxuICAgICAg
Zm9yIGsgOj0gaiwgaVxcbiAgICAgICAgcyA6PSBzIC0gYVtpLCBuLCBrXSAqIGFbaywgbiwgal1c
XG4gICAgICBlbmQgZm9yXFxuICAgICAgYVtpLCBuLCBqXSA6PSBzIC8gYVtpLCBuLCBpXVxcbiAg
ICBlbmQgZm9yXFxuICBlbmQgZm9yXFxuZW5kXCIsXG4gIFwiYWxwYWNrLmRzeWV2M1wiOiBcInN1
YnJvdXRpbmUgYWxwYWNrLmRzeWV2MyhhOiBhcnJheSBmNjQ7IHc6IGFycmF5IGY2NClcXG52YXJc
XG4gIGEwMCwgYTAxLCBhMDIsIGExMSwgYTEyLCBhMjI6IGY2NFxcbiAgcDEsIHEsIHAyLCBwLCBi
MDAsIGIxMSwgYjIyLCBkZXRfYiwgaGFsZl9kZXQ6IGY2NFxcbiAgcGhpLCByLCBlMSwgZTIsIGUz
OiBmNjRcXG4gIG06IGY2NFxcbiAgcGk6IGY2NFxcbmJlZ2luXFxuICBwaSA6PSAzLjE0MTU5MjY1
MzU4OTc5MzIzODQ2XFxuXFxuICBhMDAgOj0gYVswLCAzLCAwXVxcbiAgYTAxIDo9IGFbMCwgMywg
MV1cXG4gIGEwMiA6PSBhWzAsIDMsIDJdXFxuICBhMTEgOj0gYVsxLCAzLCAxXVxcbiAgYTEyIDo9
IGFbMSwgMywgMl1cXG4gIGEyMiA6PSBhWzIsIDMsIDJdXFxuXFxuICAhIHRyYWNlIC8gM1xcbiAg
bSA6PSAoYTAwICsgYTExICsgYTIyKSAvIDMuMFxcblxcbiAgISBzdW0gb2Ygc3F1YXJlcyBvZiBv
ZmYtZGlhZ29uYWwgZWxlbWVudHNcXG4gIHAxIDo9IGEwMSAqIGEwMSArIGEwMiAqIGEwMiArIGEx
MiAqIGExMlxcblxcbiAgaWYgKHAxIDw9IDFlLTMwKSB0aGVuXFxuICAgICEgZGlhZ29uYWwgbWF0
cml4IOKAlCBlaWdlbnZhbHVlcyBhcmUgdGhlIGRpYWdvbmFsIGVudHJpZXMsIHNvcnQgZGVzY2Vu
ZGluZ1xcbiAgICBlMSA6PSBhMDBcXG4gICAgZTIgOj0gYTExXFxuICAgIGUzIDo9IGEyMlxcbiAg
ICAhIHNvcnQgMyB2YWx1ZXMgZGVzY2VuZGluZyAoYnViYmxlIHNvcnQpXFxuICAgIGlmIChlMiA+
IGUxKSB0aGVuXFxuICAgICAgciA6PSBlMVxcbiAgICAgIGUxIDo9IGUyXFxuICAgICAgZTIgOj0g
clxcbiAgICBlbmQgaWZcXG4gICAgaWYgKGUzID4gZTIpIHRoZW5cXG4gICAgICByIDo9IGUyXFxu
ICAgICAgZTIgOj0gZTNcXG4gICAgICBlMyA6PSByXFxuICAgIGVuZCBpZlxcbiAgICBpZiAoZTIg
PiBlMSkgdGhlblxcbiAgICAgIHIgOj0gZTFcXG4gICAgICBlMSA6PSBlMlxcbiAgICAgIGUyIDo9
IHJcXG4gICAgZW5kIGlmXFxuICAgIHdbMF0gOj0gZTFcXG4gICAgd1sxXSA6PSBlMlxcbiAgICB3
WzJdIDo9IGUzXFxuICAgIGNhbGwgcmV0dXJuKClcXG4gIGVuZCBpZlxcblxcbiAgcSA6PSBtXFxu
ICBwMiA6PSAoYTAwIC0gcSkgKiAoYTAwIC0gcSkgKyAoYTExIC0gcSkgKiAoYTExIC0gcSkgKyAo
YTIyIC0gcSkgKiAoYTIyIC0gcSkgKyAyLjAgKiBwMVxcbiAgcCA6PSBzcXJ0KHAyIC8gNi4wKVxc
blxcbiAgISBCID0gKEEgLSBxKkkpIC8gcCAg4oCUIG9ubHkgbmVlZCBkZXRlcm1pbmFudFxcbiAg
YjAwIDo9IChhMDAgLSBxKSAvIHBcXG4gIGIxMSA6PSAoYTExIC0gcSkgLyBwXFxuICBiMjIgOj0g
KGEyMiAtIHEpIC8gcFxcbiAgISBkZXQoQikgZm9yIHN5bW1ldHJpYyAzeDNcXG4gIGRldF9iIDo9
IGIwMCAqIChiMTEgKiBiMjIgLSAoYTEyIC8gcCkgKiAoYTEyIC8gcCkpXFxuICAgICAgICAgLSAo
YTAxIC8gcCkgKiAoKGEwMSAvIHApICogYjIyIC0gKGExMiAvIHApICogKGEwMiAvIHApKVxcbiAg
ICAgICAgICsgKGEwMiAvIHApICogKChhMDEgLyBwKSAqIChhMTIgLyBwKSAtIGIxMSAqIChhMDIg
LyBwKSlcXG4gIGhhbGZfZGV0IDo9IGRldF9iIC8gMi4wXFxuXFxuICAhIGNsYW1wIHRvIFstMSwg
MV0gZm9yIGFjb3NcXG4gIGlmIChoYWxmX2RldCA8PSAtMS4wKSB0aGVuXFxuICAgIHBoaSA6PSBw
aSAvIDMuMFxcbiAgZWxzZSBpZiAoaGFsZl9kZXQgPj0gMS4wKSB0aGVuXFxuICAgIHBoaSA6PSAw
LjBcXG4gIGVsc2VcXG4gICAgcGhpIDo9IGF0YW4yKHNxcnQoMS4wIC0gaGFsZl9kZXQgKiBoYWxm
X2RldCksIGhhbGZfZGV0KSAvIDMuMFxcbiAgZW5kIGlmXFxuXFxuICAhIGVpZ2VudmFsdWVzIGlu
IGRlc2NlbmRpbmcgb3JkZXJcXG4gIGUxIDo9IHEgKyAyLjAgKiBwICogY29zKHBoaSlcXG4gIGUz
IDo9IHEgKyAyLjAgKiBwICogY29zKHBoaSArIDIuMCAqIHBpIC8gMy4wKVxcbiAgZTIgOj0gMy4w
ICogcSAtIGUxIC0gZTNcXG5cXG4gIHdbMF0gOj0gZTFcXG4gIHdbMV0gOj0gZTJcXG4gIHdbMl0g
Oj0gZTNcXG5lbmRcIixcbiAgXCJhbHBhY2suZHN5ZXZcIjogXCJzdWJyb3V0aW5lIGFscGFjay5k
c3lldihcXG4gIGE6IGFycmF5IGY2NDsgdzogYXJyYXkgZjY0O1xcbiAgbjogaTMyOyBpbmZvOiBh
cnJheSBpMzJcXG4pXFxudmFyXFxuICBpLCBqLCBwLCBxLCBpdGVyLCBtYXhJdGVyOiBpMzJcXG4g
IG9mZiwgdGhyZXNoLCBhcHAsIGFxcSwgYXBxOiBmNjRcXG4gIHRhdSwgdCwgYywgcywgdG1wOiBm
NjRcXG5iZWdpblxcbiAgaW5mb1swXSA6PSAwXFxuICBtYXhJdGVyIDo9IDEwMFxcblxcbiAgISBp
bml0aWFsaXplIHcgdG8gZGlhZ29uYWwgb2YgYVxcbiAgZm9yIGkgOj0gMCwgblxcbiAgICB3W2ld
IDo9IGFbaSwgbiwgaV1cXG4gIGVuZCBmb3JcXG5cXG4gIGZvciBpdGVyIDo9IDAsIG1heEl0ZXJc
XG4gICAgISBjb21wdXRlIG9mZi1kaWFnb25hbCBub3JtXFxuICAgIG9mZiA6PSAwLjBcXG4gICAg
Zm9yIHAgOj0gMCwgblxcbiAgICAgIGZvciBxIDo9IHAgKyAxLCBuXFxuICAgICAgICBvZmYgOj0g
b2ZmICsgYVtwLCBuLCBxXSAqIGFbcCwgbiwgcV1cXG4gICAgICBlbmQgZm9yXFxuICAgIGVuZCBm
b3JcXG4gICAgaWYgKG9mZiA8IDFlLTI4KSB0aGVuXFxuICAgICAgY2FsbCByZXR1cm4oKVxcbiAg
ICBlbmQgaWZcXG5cXG4gICAgdGhyZXNoIDo9IGlmIChpdGVyIDwgNCkgdGhlbiAwLjIgKiBvZmYg
LyBmNjQobiAqIG4pIGVsc2UgMC4wXFxuXFxuICAgIGZvciBwIDo9IDAsIG5cXG4gICAgICBmb3Ig
cSA6PSBwICsgMSwgblxcbiAgICAgICAgYXBxIDo9IGFbcCwgbiwgcV1cXG4gICAgICAgIGlmIChh
YnMoYXBxKSA8PSB0aHJlc2gpIHRoZW5cXG4gICAgICAgICAgISBza2lwIHNtYWxsIGVsZW1lbnRz
IGluIGVhcmx5IHN3ZWVwc1xcbiAgICAgICAgZWxzZVxcbiAgICAgICAgICBhcHAgOj0gd1twXVxc
biAgICAgICAgICBhcXEgOj0gd1txXVxcbiAgICAgICAgICAhIEphY29iaSByb3RhdGlvbiBhbmds
ZVxcbiAgICAgICAgICB0YXUgOj0gKGFxcSAtIGFwcCkgLyAoMi4wICogYXBxKVxcbiAgICAgICAg
ICBpZiAodGF1ID49IDAuMCkgdGhlblxcbiAgICAgICAgICAgIHQgOj0gMS4wIC8gKHRhdSArIHNx
cnQoMS4wICsgdGF1ICogdGF1KSlcXG4gICAgICAgICAgZWxzZVxcbiAgICAgICAgICAgIHQgOj0g
MC4wIC0gMS4wIC8gKDAuMCAtIHRhdSArIHNxcnQoMS4wICsgdGF1ICogdGF1KSlcXG4gICAgICAg
ICAgZW5kIGlmXFxuICAgICAgICAgIGMgOj0gMS4wIC8gc3FydCgxLjAgKyB0ICogdClcXG4gICAg
ICAgICAgcyA6PSB0ICogY1xcblxcbiAgICAgICAgICAhIHVwZGF0ZSBlaWdlbnZhbHVlc1xcbiAg
ICAgICAgICB3W3BdIDo9IGFwcCAtIHQgKiBhcHFcXG4gICAgICAgICAgd1txXSA6PSBhcXEgKyB0
ICogYXBxXFxuICAgICAgICAgIGFbcCwgbiwgcV0gOj0gMC4wXFxuXFxuICAgICAgICAgICEgcm90
YXRlIHJvd3MvY29sdW1ucyBwIGFuZCBxXFxuICAgICAgICAgIGZvciBpIDo9IDAsIHBcXG4gICAg
ICAgICAgICB0bXAgOj0gYVtpLCBuLCBwXVxcbiAgICAgICAgICAgIGFbaSwgbiwgcF0gOj0gYyAq
IHRtcCAtIHMgKiBhW2ksIG4sIHFdXFxuICAgICAgICAgICAgYVtpLCBuLCBxXSA6PSBzICogdG1w
ICsgYyAqIGFbaSwgbiwgcV1cXG4gICAgICAgICAgZW5kIGZvclxcbiAgICAgICAgICBmb3IgaSA6
PSBwICsgMSwgcVxcbiAgICAgICAgICAgIHRtcCA6PSBhW3AsIG4sIGldXFxuICAgICAgICAgICAg
YVtwLCBuLCBpXSA6PSBjICogdG1wIC0gcyAqIGFbaSwgbiwgcV1cXG4gICAgICAgICAgICBhW2ks
IG4sIHFdIDo9IHMgKiB0bXAgKyBjICogYVtpLCBuLCBxXVxcbiAgICAgICAgICBlbmQgZm9yXFxu
ICAgICAgICAgIGZvciBpIDo9IHEgKyAxLCBuXFxuICAgICAgICAgICAgdG1wIDo9IGFbcCwgbiwg
aV1cXG4gICAgICAgICAgICBhW3AsIG4sIGldIDo9IGMgKiB0bXAgLSBzICogYVtxLCBuLCBpXVxc
biAgICAgICAgICAgIGFbcSwgbiwgaV0gOj0gcyAqIHRtcCArIGMgKiBhW3EsIG4sIGldXFxuICAg
ICAgICAgIGVuZCBmb3JcXG4gICAgICAgIGVuZCBpZlxcbiAgICAgIGVuZCBmb3JcXG4gICAgZW5k
IGZvclxcbiAgZW5kIGZvclxcbiAgaW5mb1swXSA6PSAxXFxuZW5kXCIsXG59O1xuXG5leHBvcnQg
Y29uc3QgZGVwcyA9IHtcbiAgXCJhbGFzLmRzY2FsXCI6IFtdLFxuICBcImFsYXMuZGNvcHlcIjog
W10sXG4gIFwiYWxhcy5kYXhweVwiOiBbXSxcbiAgXCJhbGFzLmRkb3RcIjogW10sXG4gIFwiYWxh
cy5kbnJtMlwiOiBbXSxcbiAgXCJhbGFzLmRzd2FwXCI6IFtdLFxuICBcImFsYXMuaWRhbWF4XCI6
IFtdLFxuICBcImFsYXMuZGdlbXZcIjogW10sXG4gIFwiYWxhcy5kdHJzdlwiOiBbXSxcbiAgXCJh
bGFzLmRnZXJcIjogW10sXG4gIFwiYWxhcy5kc3ltdlwiOiBbXSxcbiAgXCJhbGFzLmRnZW1tXCI6
IFtdLFxuICBcImFscGFjay5kcG90cmZcIjogW10sXG4gIFwiYWxwYWNrLmRwb3Ryc1wiOiBbXSxc
biAgXCJhbHBhY2suZGdldHJmXCI6IFtdLFxuICBcImFscGFjay5kZ2V0cnNcIjogW10sXG4gIFwi
YWxwYWNrLmRnZXN2XCI6IFtcImFscGFjay5kZ2V0cmZcIixcImFscGFjay5kZ2V0cnNcIl0sXG4g
IFwiYWxwYWNrLmR0cnRyaVwiOiBbXSxcbiAgXCJhbHBhY2suZHN5ZXYzXCI6IFtdLFxuICBcImFs
cGFjay5kc3lldlwiOiBbXSxcbn07XG4iLCJjZWxsSWQiOm51bGx9fQ==
AUDITABLE-MODULES-->
<!-- notebook settings: JSON {theme, fontSize, width, ...} -->
<!--AUDITABLE-SETTINGS
{"theme":"dark","fontSize":13,"width":"860"}
AUDITABLE-SETTINGS-->

<script>
// -- state.js --

// ═══════════════════════════════════════════════════
// AUDITABLE — reactive notebook runtime
// Geoscientific Chaos Union, 2025
// ═══════════════════════════════════════════════════

const $ = s => document.querySelector(s);
const $$ = s => [...document.querySelectorAll(s)];

// ── STATE ──
const S = {
  cells: [],        // { id, type, code, el, defines, uses, output, error }
  scope: {},        // shared variable scope
  cellId: 0,        // unique cell ID counter
  editTimer: null,  // debounce timer for autorun
  autorun: true,    // reactive mode flag
  selectedId: null, // currently selected cell
  pendingD: false,  // for "dd" double-tap delete
  pendingDTimer: null,
  clipboard: null,  // copied cell data
  trash: [],        // undo stack for deleted cells
  findActive: false,
  findQuery: '',
  findCase: false,
  findRegex: false,
  findMatches: [],   // { cellId, index, length }
  findCurrent: -1,
  initialized: false, // set after loadFromEmbed/init completes
};

const JS_KEYWORDS = new Set([
  'const','let','var','function','return','if','else','for','while','do',
  'switch','case','break','continue','new','this','class','extends','import',
  'export','default','from','of','in','typeof','instanceof','void','delete',
  'throw','try','catch','finally','async','await','yield','true','false',
  'null','undefined','NaN','Infinity'
]);

const JS_BUILTINS = new Set([
  'Math','Array','Object','String','Number','Float64Array','Float32Array',
  'Int32Array','Uint8Array','Map','Set','Promise','console','JSON',
  'ui','std','load','install','print',
  'workshop','notebook','md','html','css'
]);


// -- stdlib.js --

// ── STDLIB ──
// Bundled standard library for notebook work.
// Module-level — no per-cell state needed.

// ── Provider Registry ──

const _providers = { file: null, download: null };

function registerProvider(name, fn) {
  if (name in _providers) _providers[name] = fn;
}

// ── Data ──

function csv(text, opts = {}) {
  const sep = opts.separator || ',';
  const typed = !!opts.typed;
  const lines = [];
  let i = 0;
  const len = text.length;

  while (i < len) {
    const row = [];
    while (i < len) {
      if (text[i] === '"') {
        // quoted field
        i++;
        let field = '';
        while (i < len) {
          if (text[i] === '"') {
            if (text[i + 1] === '"') { field += '"'; i += 2; }
            else { i++; break; }
          } else { field += text[i]; i++; }
        }
        row.push(field);
        if (text[i] === sep) i++;
        else if (text[i] === '\r') { i++; if (text[i] === '\n') i++; break; }
        else if (text[i] === '\n') { i++; break; }
        else if (i >= len) break;
      } else {
        // unquoted field
        let field = '';
        while (i < len && text[i] !== sep && text[i] !== '\n' && text[i] !== '\r') {
          field += text[i]; i++;
        }
        row.push(field);
        if (text[i] === sep) i++;
        else if (text[i] === '\r') { i++; if (text[i] === '\n') i++; break; }
        else if (text[i] === '\n') { i++; break; }
        else break;
      }
    }
    if (row.length > 0 && !(row.length === 1 && row[0] === '')) lines.push(row);
  }

  if (lines.length < 2) return [];
  const headers = lines[0];
  const result = [];
  for (let r = 1; r < lines.length; r++) {
    const obj = {};
    for (let c = 0; c < headers.length; c++) {
      let val = lines[r][c] !== undefined ? lines[r][c] : '';
      if (typed) {
        const num = Number(val);
        if (val !== '' && !isNaN(num)) val = num;
        else if (val === 'true') val = true;
        else if (val === 'false') val = false;
        else if (val === '') val = null;
      }
      obj[headers[c]] = val;
    }
    result.push(obj);
  }
  return result;
}

async function fetchJSON(url) {
  const resp = await fetch(url);
  if (!resp.ok) throw new Error(`fetchJSON: ${resp.status} ${resp.statusText}`);
  return resp.json();
}

// ── Math / Stats ──

function _acc(arr, fn) {
  return fn ? arr.map(fn) : arr;
}

function sum(arr, fn) {
  const vals = _acc(arr, fn);
  let s = 0;
  for (let i = 0; i < vals.length; i++) s += vals[i];
  return s;
}

function mean(arr, fn) {
  if (!arr.length) return NaN;
  return sum(arr, fn) / arr.length;
}

function median(arr, fn) {
  const vals = _acc(arr, fn).slice().sort((a, b) => a - b);
  const n = vals.length;
  if (n === 0) return NaN;
  if (n % 2 === 1) return vals[(n - 1) / 2];
  return (vals[n / 2 - 1] + vals[n / 2]) / 2;
}

function extent(arr, fn) {
  const vals = _acc(arr, fn);
  let lo = Infinity, hi = -Infinity;
  for (let i = 0; i < vals.length; i++) {
    if (vals[i] < lo) lo = vals[i];
    if (vals[i] > hi) hi = vals[i];
  }
  return [lo, hi];
}

function bin(arr, n = 10, fn) {
  const vals = _acc(arr, fn);
  const [lo, hi] = extent(vals);
  const range = hi - lo || 1;
  const step = range / n;
  const bins = [];
  for (let i = 0; i < n; i++) {
    bins.push({ x0: lo + i * step, x1: lo + (i + 1) * step, values: [] });
  }
  for (const v of vals) {
    let idx = Math.floor((v - lo) / step);
    if (idx >= n) idx = n - 1;
    if (idx < 0) idx = 0;
    bins[idx].values.push(v);
  }
  return bins;
}

function linspace(start, stop, n) {
  if (n < 2) return n === 1 ? [start] : [];
  const result = new Array(n);
  const step = (stop - start) / (n - 1);
  for (let i = 0; i < n; i++) result[i] = start + i * step;
  result[n - 1] = stop; // exact endpoint
  return result;
}

// ── Array ──

function unique(arr, fn) {
  if (!fn) return [...new Set(arr)];
  const seen = new Set();
  const result = [];
  for (const item of arr) {
    const key = fn(item);
    if (!seen.has(key)) { seen.add(key); result.push(item); }
  }
  return result;
}

function zip(...arrays) {
  const len = Math.min(...arrays.map(a => a.length));
  const result = new Array(len);
  for (let i = 0; i < len; i++) {
    result[i] = arrays.map(a => a[i]);
  }
  return result;
}

function cross(...arrays) {
  if (arrays.length === 0) return [[]];
  const [first, ...rest] = arrays;
  const sub = cross(...rest);
  const result = [];
  for (const item of first) {
    for (const tail of sub) {
      result.push([item, ...tail]);
    }
  }
  return result;
}

// ── DOM / IO ──

async function file(accept) {
  if (_providers.file) return _providers.file(accept);
  return new Promise((resolve, reject) => {
    const input = document.createElement('input');
    input.type = 'file';
    if (accept) input.accept = accept;
    input.onchange = async () => {
      const f = input.files[0];
      if (!f) { reject(new Error('no file selected')); return; }
      const text = await f.text();
      resolve({ name: f.name, text, size: f.size });
    };
    input.click();
  });
}

function download(data, filename, mimeType) {
  if (_providers.download) return _providers.download(data, filename, mimeType);
  const str = typeof data === 'string' ? data : JSON.stringify(data, null, 2);
  const mime = mimeType || (typeof data === 'string' ? 'text/plain' : 'application/json');
  const blob = new Blob([str], { type: mime });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename || 'download';
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  setTimeout(() => URL.revokeObjectURL(url), 1000);
}

function el(tag, attrs, ...children) {
  const elem = document.createElement(tag);
  if (attrs && typeof attrs === 'object' && !(attrs instanceof Node)) {
    for (const [k, v] of Object.entries(attrs)) {
      if (k === 'style' && typeof v === 'object') {
        Object.assign(elem.style, v);
      } else if (k.startsWith('on') && typeof v === 'function') {
        elem.addEventListener(k.slice(2), v);
      } else {
        elem.setAttribute(k, v);
      }
    }
  } else if (attrs != null) {
    // attrs is actually a child
    children.unshift(attrs);
  }
  for (const child of children) {
    if (child instanceof Node) elem.appendChild(child);
    else if (child != null) elem.appendChild(document.createTextNode(String(child)));
  }
  return elem;
}

async function copy(text) {
  await navigator.clipboard.writeText(text);
}

function fmt(number, opts = {}) {
  const { decimals, prefix, suffix } = opts;
  let s = decimals != null ? number.toFixed(decimals)
    : new Intl.NumberFormat(undefined, { maximumFractionDigits: 6 }).format(number);
  if (prefix) s = prefix + s;
  if (suffix) s = s + suffix;
  return s;
}

// ── Source inclusion with dependency resolution ──

function include(libs, ...names) {
  // accept single library or array of libraries
  const list = Array.isArray(libs) && libs[0] && libs[0].sources ? libs : [libs];
  // merge all libraries into unified sources + deps
  const sources = {}, deps = {};
  for (const lib of list) {
    if (!lib || !lib.sources || !lib.deps)
      throw new Error('include: expected library with sources and deps');
    Object.assign(sources, lib.sources);
    Object.assign(deps, lib.deps);
  }
  const needed = new Set();
  function walk(name) {
    if (needed.has(name)) return;
    if (!sources[name]) throw new Error(`include: unknown routine '${name}'`);
    needed.add(name);
    for (const dep of deps[name] || []) walk(dep);
  }
  names.forEach(walk);
  // topological sort: deps before dependents
  const sorted = [];
  const visited = new Set();
  function visit(name) {
    if (visited.has(name)) return;
    visited.add(name);
    for (const dep of deps[name] || []) visit(dep);
    sorted.push(name);
  }
  needed.forEach(visit);
  return sorted.map(n => sources[n]).join('\n\n');
}

// ── Export ──

const std = {
  csv, fetchJSON,
  sum, mean, median, extent, bin, linspace,
  unique, zip, cross,
  file, download, el, copy, fmt,
  include,
};

// -- python.js --

// ── @python COMPAT HELPERS ──
// Python-familiar functions for users transitioning from Python.
// Each has a .help property showing the idiomatic JS equivalent.

function range(a, b, step) {
  let start, stop, s;
  if (b === undefined) { start = 0; stop = a; s = 1; }
  else { start = a; stop = b; s = step || 1; }
  const result = [];
  if (s > 0) { for (let i = start; i < stop; i += s) result.push(i); }
  else if (s < 0) { for (let i = start; i > stop; i += s) result.push(i); }
  return result;
}
range.help = 'JS: Array.from({length: n}, (_, i) => start + i * step)';

function enumerate(arr) {
  return arr.map((v, i) => [i, v]);
}
enumerate.help = 'JS: arr.map((v, i) => [i, v]) or arr.entries()';

function len(x) {
  if (x == null) throw new TypeError('len() of unsized object');
  if (x.size !== undefined) return x.size;
  return x.length;
}
len.help = 'JS: x.length or x.size';

function sorted(arr, key, reverse) {
  const copy = [...arr];
  if (key) copy.sort((a, b) => {
    const ka = key(a), kb = key(b);
    return ka < kb ? -1 : ka > kb ? 1 : 0;
  });
  else copy.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
  if (reverse) copy.reverse();
  return copy;
}
sorted.help = 'JS: arr.toSorted((a, b) => ...)';

function reversed(arr) {
  return [...arr].reverse();
}
reversed.help = 'JS: arr.toReversed()';

function isinstance(obj, cls) {
  return obj instanceof cls;
}
isinstance.help = 'JS: obj instanceof cls';

function type(x) {
  if (x === null) return 'null';
  if (Array.isArray(x)) return 'array';
  return typeof x;
}
type.help = 'JS: typeof x';

const python = {
  range, enumerate, len, sorted, reversed,
  isinstance, type,
};

function zenOfPython() {
  return [
    'The Zen of Python, by Tim Peters',
    '',
    'Beautiful is better than ugly.',
    'Explicit is better than implicit.',
    'Simple is better than complex.',
    'Complex is better than complicated.',
    'Flat is better than nested.',
    'Sparse is better than dense.',
    'Readability counts.',
    "Special cases aren't special enough to break the rules.",
    'Although practicality beats purity.',
    'Errors should never pass silently.',
    'Unless explicitly silenced.',
    'In the face of ambiguity, refuse the temptation to guess.',
    'There should be one-- and preferably only one --obvious way to do it.',
    "Although that way may not be obvious at first unless you're Dutch.",
    'Now is better than never.',
    'Although never is often better than *right* now.',
    "If the implementation is hard to explain, it's a bad idea.",
    'If the implementation is easy to explain, it may be a good idea.',
    "Namespaces are one honking great idea -- let's do more of those!",
  ].join('\n');
}

// -- syntax.js --

// ── SYNTAX HIGHLIGHTING ──

const CSS_NAMED_COLORS = new Set([
  'black','silver','gray','white','maroon','red','purple','fuchsia',
  'green','lime','olive','yellow','navy','blue','teal','aqua','orange'
]);

// detect curried tagged template: scan back through tokens for lang({...})`
function detectCurriedTag(tokens) {
  // last non-whitespace token must be )
  let j = tokens.length - 1;
  while (j >= 0 && tokens[j].type === '') j--;
  if (j < 0 || tokens[j].text !== ')') return null;
  // scan back to matching (
  let depth = 1;
  j--;
  while (j >= 0 && depth > 0) {
    if (tokens[j].text === ')') depth++;
    else if (tokens[j].text === '(') depth--;
    j--;
  }
  // token before ( should be the language name
  while (j >= 0 && tokens[j].type === '') j--;
  if (j < 0) return null;
  const name = tokens[j].text;
  if (window._taggedLanguages && window._taggedLanguages[name]) {
    return window._taggedLanguages[name];
  }
  return null;
}

// tokenize a tagged template literal starting at the opening backtick
function tokenizeTaggedTemplate(code, i, len, lang, tokens) {
  tokens.push({ type: 'punc', text: '`' });
  i++; // skip opening backtick
  let strBuf = '';
  while (i < len && code[i] !== '`') {
    if (code[i] === '\\') {
      strBuf += code[i] + (i + 1 < len ? code[i + 1] : '');
      i += 2;
      continue;
    }
    if (code[i] === '$' && i + 1 < len && code[i + 1] === '{') {
      if (strBuf) {
        tokens.push(...lang.tokenize(strBuf));
        strBuf = '';
      }
      tokens.push({ type: 'punc', text: '${' });
      i += 2;
      let depth = 1;
      let exprStart = i;
      while (i < len && depth > 0) {
        if (code[i] === '{') depth++;
        else if (code[i] === '}') { depth--; if (depth === 0) break; }
        else if (code[i] === '`') {
          i++;
          while (i < len && code[i] !== '`') {
            if (code[i] === '\\') i++;
            i++;
          }
        } else if (code[i] === '"' || code[i] === "'") {
          const q = code[i]; i++;
          while (i < len && code[i] !== q) {
            if (code[i] === '\\') i++;
            i++;
          }
        }
        i++;
      }
      const expr = code.slice(exprStart, i);
      if (expr) tokens.push(...tokenize(expr));
      if (i < len && code[i] === '}') {
        tokens.push({ type: 'punc', text: '}' });
        i++;
      }
      continue;
    }
    strBuf += code[i];
    i++;
  }
  if (strBuf) tokens.push(...lang.tokenize(strBuf));
  if (i < len && code[i] === '`') {
    tokens.push({ type: 'punc', text: '`' });
    i++;
  }
  return i;
}

function tokenize(code) {
  const tokens = [];
  let i = 0;
  const len = code.length;

  while (i < len) {
    // line comment
    if (code[i] === '/' && code[i+1] === '/') {
      const start = i;
      while (i < len && code[i] !== '\n') i++;
      tokens.push({ type: 'cmt', text: code.slice(start, i) });
      continue;
    }
    // block comment
    if (code[i] === '/' && code[i+1] === '*') {
      const start = i;
      i += 2;
      while (i < len && !(code[i-1] === '*' && code[i] === '/')) i++;
      if (i < len) i++;
      tokens.push({ type: 'cmt', text: code.slice(start, i) });
      continue;
    }
    // strings
    if (code[i] === '"' || code[i] === "'" || code[i] === '`') {
      // curried tagged template: lang({...})`...` — detect before treating as plain string
      if (code[i] === '`' && typeof window !== 'undefined' && window._taggedLanguages) {
        const lang = detectCurriedTag(tokens);
        if (lang) {
          i = tokenizeTaggedTemplate(code, i, len, lang, tokens);
          continue;
        }
      }
      const q = code[i];
      const start = i;
      i++;
      while (i < len && code[i] !== q) {
        if (code[i] === '\\') i++;
        i++;
      }
      if (i < len) i++;
      tokens.push({ type: 'str', text: code.slice(start, i) });
      continue;
    }
    // numbers
    if (/\d/.test(code[i]) || (code[i] === '.' && i+1 < len && /\d/.test(code[i+1]))) {
      const start = i;
      if (code[i] === '0' && (code[i+1] === 'x' || code[i+1] === 'X')) {
        i += 2;
        while (i < len && /[0-9a-fA-F_]/.test(code[i])) i++;
      } else {
        while (i < len && /[0-9._eE+-]/.test(code[i])) i++;
      }
      tokens.push({ type: 'num', text: code.slice(start, i) });
      continue;
    }
    // identifiers / keywords
    if (/[a-zA-Z_$]/.test(code[i])) {
      const start = i;
      while (i < len && /\w/.test(code[i])) i++;
      const word = code.slice(start, i);

      // tagged template literal — delegate to registered language tokenizer
      if (i < len && code[i] === '`' && typeof window !== 'undefined'
          && window._taggedLanguages && window._taggedLanguages[word]) {
        tokens.push({ type: 'fn', text: word });
        i = tokenizeTaggedTemplate(code, i, len, window._taggedLanguages[word], tokens);
        continue;
      }

      if (JS_KEYWORDS.has(word)) {
        tokens.push({ type: 'kw', text: word });
      } else if (JS_BUILTINS.has(word)) {
        tokens.push({ type: 'const', text: word });
      } else if (i < len && code[i] === '(') {
        tokens.push({ type: 'fn', text: word });
      } else {
        tokens.push({ type: 'id', text: word });
      }
      continue;
    }
    // operators
    if ('=+-*/<>!&|^~%?:'.includes(code[i])) {
      tokens.push({ type: 'op', text: code[i] });
      i++;
      continue;
    }
    // punctuation
    if ('(){}[];,.'.includes(code[i])) {
      tokens.push({ type: 'punc', text: code[i] });
      i++;
      continue;
    }
    // whitespace / other — pass through
    tokens.push({ type: '', text: code[i] });
    i++;
  }

  return tokens;
}

function highlightCode(ta, hl) {
  const code = ta.value;
  if (!code) { hl.innerHTML = '\n'; return; }

  const tokens = tokenize(code);
  let html = '';
  for (const t of tokens) {
    const escaped = t.text
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;');
    if (t.type && t.type !== 'id') {
      html += `<span class="hl-${t.type}">${escaped}</span>`;
    } else {
      html += escaped;
    }
  }
  // trailing newline so highlight layer matches textarea height
  hl.innerHTML = html + '\n';
}

// ── CSS SYNTAX HIGHLIGHTING ──

function tokenizeCss(code) {
  const tokens = [];
  let i = 0;
  const len = code.length;
  let ctx = 'sel'; // 'sel' | 'prop' | 'val'
  let depth = 0;

  while (i < len) {
    // block comment
    if (code[i] === '/' && code[i+1] === '*') {
      const start = i;
      i += 2;
      while (i < len && !(code[i-1] === '*' && code[i] === '/')) i++;
      if (i < len) i++;
      tokens.push({ type: 'cmt', text: code.slice(start, i) });
      continue;
    }
    // strings
    if (code[i] === '"' || code[i] === "'") {
      const q = code[i];
      const start = i;
      i++;
      while (i < len && code[i] !== q) {
        if (code[i] === '\\') i++;
        i++;
      }
      if (i < len) i++;
      tokens.push({ type: 'str', text: code.slice(start, i) });
      continue;
    }
    // punctuation with context transitions
    if (code[i] === '{') {
      tokens.push({ type: 'punc', text: '{' });
      depth++;
      ctx = 'prop';
      i++;
      continue;
    }
    if (code[i] === '}') {
      tokens.push({ type: 'punc', text: '}' });
      depth--;
      ctx = depth > 0 ? 'prop' : 'sel';
      i++;
      continue;
    }
    if (code[i] === ':' && ctx === 'prop') {
      tokens.push({ type: 'punc', text: ':' });
      ctx = 'val';
      i++;
      continue;
    }
    if (code[i] === ';') {
      tokens.push({ type: 'punc', text: ';' });
      ctx = 'prop';
      i++;
      continue;
    }
    if ('(),'.includes(code[i])) {
      tokens.push({ type: 'punc', text: code[i] });
      i++;
      continue;
    }
    // @-rules
    if (code[i] === '@') {
      const start = i;
      i++;
      while (i < len && /[a-zA-Z-]/.test(code[i])) i++;
      tokens.push({ type: 'atrule', text: code.slice(start, i) });
      continue;
    }
    // !important
    if (code[i] === '!' && ctx === 'val') {
      const start = i;
      i++;
      while (i < len && /[a-zA-Z]/.test(code[i])) i++;
      tokens.push({ type: 'important', text: code.slice(start, i) });
      continue;
    }
    // # — hex color in val, ID selector in sel
    if (code[i] === '#') {
      if (ctx === 'val') {
        const start = i;
        i++;
        while (i < len && /[0-9a-fA-F]/.test(code[i])) i++;
        tokens.push({ type: 'color', text: code.slice(start, i) });
      } else {
        // ID selector
        const start = i;
        i++;
        while (i < len && /[\w-]/.test(code[i])) i++;
        tokens.push({ type: 'sel', text: code.slice(start, i) });
      }
      continue;
    }
    // : in selector context = pseudo-class
    if (code[i] === ':' && ctx === 'sel') {
      const start = i;
      i++;
      if (i < len && code[i] === ':') i++; // ::
      while (i < len && /[a-zA-Z-]/.test(code[i])) i++;
      // handle pseudo with parens like :nth-child(...)
      if (i < len && code[i] === '(') {
        i++;
        let pdepth = 1;
        while (i < len && pdepth > 0) {
          if (code[i] === '(') pdepth++;
          else if (code[i] === ')') pdepth--;
          if (pdepth > 0) i++;
        }
        if (i < len) i++;
      }
      tokens.push({ type: 'sel', text: code.slice(start, i) });
      continue;
    }
    // . in selector context = class selector
    if (code[i] === '.' && ctx === 'sel') {
      const start = i;
      i++;
      while (i < len && /[\w-]/.test(code[i])) i++;
      tokens.push({ type: 'sel', text: code.slice(start, i) });
      continue;
    }
    // numbers (with units)
    if (ctx === 'val' && (/\d/.test(code[i]) || (code[i] === '.' && i+1 < len && /\d/.test(code[i+1])))) {
      const start = i;
      while (i < len && /[0-9.]/.test(code[i])) i++;
      // units
      while (i < len && /[a-zA-Z%]/.test(code[i])) i++;
      tokens.push({ type: 'num', text: code.slice(start, i) });
      continue;
    }
    // identifiers
    if (/[a-zA-Z_-]/.test(code[i])) {
      const start = i;
      while (i < len && /[\w-]/.test(code[i])) i++;
      const word = code.slice(start, i);
      // function call
      if (i < len && code[i] === '(') {
        tokens.push({ type: 'fn', text: word });
        continue;
      }
      if (ctx === 'val' && CSS_NAMED_COLORS.has(word.toLowerCase())) {
        tokens.push({ type: 'color', text: word });
      } else if (ctx === 'prop') {
        tokens.push({ type: 'prop', text: word });
      } else if (ctx === 'sel') {
        tokens.push({ type: 'sel', text: word });
      } else {
        tokens.push({ type: '', text: word });
      }
      continue;
    }
    // whitespace / other
    tokens.push({ type: '', text: code[i] });
    i++;
  }

  return tokens;
}

function resolveToHex(colorStr) {
  const d = document.createElement('div');
  d.style.color = colorStr;
  document.body.appendChild(d);
  const rgb = getComputedStyle(d).color;
  d.remove();
  const m = rgb.match(/(\d+)/g);
  if (!m || m.length < 3) return colorStr;
  return '#' + m.slice(0, 3).map(n => parseInt(n).toString(16).padStart(2, '0')).join('');
}

let _colorPicker = null;
let _pickerTarget = null; // { ta, offset, len }

function ensureColorPicker() {
  if (_colorPicker) return _colorPicker;
  _colorPicker = document.createElement('input');
  _colorPicker.type = 'color';
  _colorPicker.style.cssText = 'position:absolute;visibility:hidden;width:0;height:0;';
  document.body.appendChild(_colorPicker);
  _colorPicker.addEventListener('input', () => {
    if (!_pickerTarget) return;
    const { ta, offset, len } = _pickerTarget;
    const newColor = _colorPicker.value;
    ta.focus();
    ta.selectionStart = offset;
    ta.selectionEnd = offset + len;
    document.execCommand('insertText', false, newColor);
    ta.dispatchEvent(new Event('input'));
    // update offset for new length
    _pickerTarget.len = newColor.length;
  });
  return _colorPicker;
}

function highlightCss(ta, hl) {
  const code = ta.value;
  if (!code) { hl.innerHTML = '\n'; return; }

  const tokens = tokenizeCss(code);
  let html = '';
  let offset = 0;
  for (const t of tokens) {
    const escaped = t.text
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;');
    if (t.type === 'color') {
      const hex = resolveToHex(t.text);
      html += `<span class="hl-color"><span class="hl-swatch" style="background:${hex}" data-offset="${offset}" data-len="${t.text.length}"></span>${escaped}</span>`;
    } else if (t.type && t.type !== 'id') {
      html += `<span class="hl-${t.type}">${escaped}</span>`;
    } else {
      html += escaped;
    }
    offset += t.text.length;
  }
  hl.innerHTML = html + '\n';

  // wire swatch clicks (only add once per highlight layer)
  if (!hl._swatchWired) {
    hl._swatchWired = true;
    hl.addEventListener('click', (e) => {
      const swatch = e.target.closest('.hl-swatch');
      if (!swatch) return;
      const off = parseInt(swatch.dataset.offset);
      const len = parseInt(swatch.dataset.len);
      const picker = ensureColorPicker();
      _pickerTarget = { ta, offset: off, len };
      const hex = resolveToHex(ta.value.slice(off, off + len));
      picker.value = hex;
      picker.click();
    });
  }
}

// ── HTML SYNTAX HIGHLIGHTING ──

function tokenizeHtml(code) {
  const tokens = [];
  let i = 0;
  const len = code.length;

  while (i < len) {
    // template expression ${...}
    if (code[i] === '$' && i + 1 < len && code[i + 1] === '{') {
      const start = i;
      i += 2;
      let depth = 1;
      while (i < len && depth > 0) {
        if (code[i] === '{') depth++;
        else if (code[i] === '}') depth--;
        if (depth > 0) i++;
      }
      if (i < len) i++;
      tokens.push({ type: 'expr', text: code.slice(start, i) });
      continue;
    }
    // comment <!-- ... -->
    if (code[i] === '<' && code[i + 1] === '!' && code[i + 2] === '-' && code[i + 3] === '-') {
      const start = i;
      i += 4;
      while (i < len) {
        if (code[i] === '-' && code[i + 1] === '-' && code[i + 2] === '>') { i += 3; break; }
        i++;
      }
      tokens.push({ type: 'cmt', text: code.slice(start, i) });
      continue;
    }
    // tag
    if (code[i] === '<') {
      tokens.push({ type: 'tag', text: '<' });
      i++;
      // closing slash
      if (i < len && code[i] === '/') { tokens.push({ type: 'tag', text: '/' }); i++; }
      // tag name
      const ns = i;
      while (i < len && /[a-zA-Z0-9-]/.test(code[i])) i++;
      if (i > ns) tokens.push({ type: 'tag', text: code.slice(ns, i) });
      // attributes until >
      while (i < len && code[i] !== '>') {
        // template expression inside tag
        if (code[i] === '$' && i + 1 < len && code[i + 1] === '{') {
          const start = i;
          i += 2;
          let depth = 1;
          while (i < len && depth > 0) {
            if (code[i] === '{') depth++;
            else if (code[i] === '}') depth--;
            if (depth > 0) i++;
          }
          if (i < len) i++;
          tokens.push({ type: 'expr', text: code.slice(start, i) });
          continue;
        }
        if (/\s/.test(code[i])) { tokens.push({ type: '', text: code[i] }); i++; continue; }
        if (code[i] === '/') { tokens.push({ type: 'tag', text: '/' }); i++; continue; }
        if (code[i] === '=') { tokens.push({ type: 'punc', text: '=' }); i++; continue; }
        // quoted attribute value
        if (code[i] === '"' || code[i] === "'") {
          const q = code[i];
          const start = i;
          i++;
          while (i < len && code[i] !== q) { if (code[i] === '\\') i++; i++; }
          if (i < len) i++;
          tokens.push({ type: 'str', text: code.slice(start, i) });
          continue;
        }
        // attribute name or unquoted value
        const as = i;
        while (i < len && !/[\s=>/"']/.test(code[i])) i++;
        if (i > as) {
          let j = i;
          while (j < len && /\s/.test(code[j])) j++;
          tokens.push({ type: (j < len && code[j] === '=') ? 'attr' : 'attr', text: code.slice(as, i) });
        }
      }
      if (i < len && code[i] === '>') { tokens.push({ type: 'tag', text: '>' }); i++; }
      continue;
    }
    // plain text
    tokens.push({ type: '', text: code[i] });
    i++;
  }

  return tokens;
}

function highlightHtml(ta, hl) {
  const code = ta.value;
  if (!code) { hl.innerHTML = '\n'; return; }

  const tokens = tokenizeHtml(code);
  let html = '';
  for (const t of tokens) {
    const escaped = t.text
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;');
    if (t.type) {
      html += `<span class="hl-${t.type}">${escaped}</span>`;
    } else {
      html += escaped;
    }
  }
  hl.innerHTML = html + '\n';
}

// -- dag.js --

// ── REACTIVE DAG ──

// ── directive helpers ──

function hasDirective(code, name) {
  return new RegExp(String.raw`^\s*\/\/\s*%${name}\b`, 'm').test(code);
}

function getDirective(code, name) {
  const m = code.match(new RegExp(String.raw`^\s*\/\/\s*%${name}\s+(.+)`, 'm'));
  return m ? m[1].trim() : null;
}

const isManual    = code => hasDirective(code, 'manual');
const isHidden    = code => hasDirective(code, 'hide');
const isNorun     = code => hasDirective(code, 'norun');
const isCollapsed = code => hasDirective(code, 'collapsed');
const parseCellName    = code => getDirective(code, 'cellName');
const parseOutputId    = code => { const v = getDirective(code, 'outputId'); return v ? v.split(/\s+/)[0] : null; };
const parseOutputClass = code => getDirective(code, 'outputClass');

// ── code analysis ──

function stripCommentsAndStrings(code) {
  // single-pass: strings take precedence over comments (// inside "..." is not a comment)
  let out = '', i = 0;
  while (i < code.length) {
    // single-quoted string
    if (code[i] === "'") {
      out += '""';
      i++;
      while (i < code.length && code[i] !== "'") { if (code[i] === '\\') i++; i++; }
      i++; // skip closing quote
      continue;
    }
    // double-quoted string
    if (code[i] === '"') {
      out += '""';
      i++;
      while (i < code.length && code[i] !== '"') { if (code[i] === '\\') i++; i++; }
      i++; // skip closing quote
      continue;
    }
    // template literal: replace string parts with spaces but keep ${expr} content
    if (code[i] === '`') {
      i++;
      while (i < code.length && code[i] !== '`') {
        if (code[i] === '\\') { i += 2; continue; }
        if (code[i] === '$' && code[i + 1] === '{') {
          i += 2;
          let depth = 1;
          out += ' ';
          while (i < code.length && depth > 0) {
            if (code[i] === '{') depth++;
            else if (code[i] === '}') { depth--; if (depth === 0) break; }
            out += code[i];
            i++;
          }
          out += ' ';
          i++; // skip closing }
          continue;
        }
        i++;
      }
      i++; // skip closing backtick
      continue;
    }
    // line comment
    if (code[i] === '/' && code[i + 1] === '/') {
      while (i < code.length && code[i] !== '\n') i++;
      continue;
    }
    // block comment
    if (code[i] === '/' && code[i + 1] === '*') {
      i += 2;
      while (i < code.length && !(code[i - 1] === '*' && code[i] === '/')) i++;
      i++;
      continue;
    }
    out += code[i];
    i++;
  }
  return out;
}

function parseNames(code) {
  // extract ONLY top-level variable definitions (brace depth 0)
  const defines = new Set();

  const stripped = stripCommentsAndStrings(code);

  let depth = 0;
  let parenDepth = 0;
  let i = 0;
  while (i < stripped.length) {
    const ch = stripped[i];
    if (ch === '{') { depth++; i++; continue; }
    if (ch === '}') { depth--; i++; continue; }
    if (ch === '(') { parenDepth++; i++; continue; }
    if (ch === ')') { parenDepth--; i++; continue; }

    if (depth === 0 && parenDepth === 0) {
      // check for const/let/var
      const rest = stripped.slice(i);
      const dm = rest.match(/^(?:const|let|var)\s+(\w+)/);
      if (dm) {
        defines.add(dm[1]);
        // scan forward for comma-separated declarations: const W = 80, H = 60
        // skip initializer expressions tracking depth, grab identifiers after commas
        let j = dm[0].length;
        let d = 0, pd = 0, bd = 0;
        while (j < rest.length) {
          const ch = rest[j];
          if (ch === '{') d++;
          else if (ch === '}') d--;
          else if (ch === '(') pd++;
          else if (ch === ')') pd--;
          else if (ch === '[') bd++;
          else if (ch === ']') bd--;
          else if (ch === ';' || ch === '\n') {
            if (d === 0 && pd === 0 && bd === 0) break;
          }
          else if (ch === ',' && d === 0 && pd === 0 && bd === 0) {
            // next identifier after comma
            const after = rest.slice(j + 1).match(/^\s*(\w+)/);
            if (after) defines.add(after[1]);
          }
          j++;
        }
        i += j;
        continue;
      }
      // destructuring: const { a, b } = ... or const [ a, b ] = ...
      const destruct = rest.match(/^(?:const|let|var)\s*[\{\[]/);
      if (destruct) {
        // find the closing } or ] then extract identifiers
        const opener = rest[destruct[0].length - 1];
        const closer = opener === '{' ? '}' : ']';
        const closeIdx = rest.indexOf(closer, destruct[0].length);
        if (closeIdx > 0) {
          const inner = rest.slice(destruct[0].length, closeIdx);
          // split on commas, take last word of each part (handles renaming)
          inner.split(',').forEach(part => {
            const parts = part.trim().split(/\s*:\s*/);
            const name = (parts.length > 1 ? parts[1] : parts[0]).trim().match(/^\w+/);
            if (name) defines.add(name[0]);
          });
          i += closeIdx + 1;
          continue;
        }
      }
      // check for function declarations
      const fm = rest.match(/^function\s+(\w+)/);
      if (fm) {
        defines.add(fm[1]);
        i += fm[0].length;
        continue;
      }
    }
    i++;
  }

  return { defines };
}

function findUses(code, allDefined, selfDefined) {
  // find identifiers that reference other cells' definitions
  const uses = new Set();
  const stripped = stripCommentsAndStrings(code);
  if (!selfDefined) selfDefined = parseNames(code).defines;

  const idRe = /\b([a-zA-Z_$]\w*)\b/g;
  let m;
  while ((m = idRe.exec(stripped))) {
    if (allDefined.has(m[1]) && !selfDefined.has(m[1])) {
      uses.add(m[1]);
    }
  }
  return uses;
}

function findHtmlUses(code, allDefined) {
  const uses = new Set();
  const re = /\$\{([^}]+)\}/g;
  let m;
  while ((m = re.exec(code))) {
    const expr = m[1];
    const idRe = /\b([a-zA-Z_$]\w*)\b/g;
    let im;
    while ((im = idRe.exec(expr))) {
      if (allDefined.has(im[1])) uses.add(im[1]);
    }
  }
  return uses;
}

function buildDAG() {
  // collect all defined names globally (only re-parse changed cells)
  const allDefined = new Map(); // name -> cell id
  for (const c of S.cells) {
    if (c.type !== 'code') continue;
    if (c.code !== c._parsedCode) {
      const { defines } = parseNames(c.code);
      c.defines = defines;
      c._parsedCode = c.code;
    }
    for (const name of c.defines) {
      allDefined.set(name, c.id);
    }
  }

  // find uses for each cell (invalidate if code changed or global names changed)
  const definedNames = new Set(allDefined.keys());
  const definedKey = [...definedNames].sort().join(',');
  for (const c of S.cells) {
    if (c.type === 'code') {
      if (c.code !== c._usesCode || c._definedKey !== definedKey) {
        c.uses = findUses(c.code, definedNames, c.defines);
        c._usesCode = c.code;
        c._definedKey = definedKey;
      }
    } else if (c.type === 'html') {
      if (c.code !== c._usesCode || c._definedKey !== definedKey) {
        c.uses = findHtmlUses(c.code, definedNames);
        c._usesCode = c.code;
        c._definedKey = definedKey;
      }
    }
  }

  return allDefined;
}

function topoSort(dirtyIds) {
  // BFS from dirty cells to find all downstream dependents
  const dependents = new Map(); // varName -> Set<cellId>
  for (const c of S.cells) {
    if (!c.uses) continue;
    for (const name of c.uses) {
      if (!dependents.has(name)) dependents.set(name, new Set());
      dependents.get(name).add(c.id);
    }
  }

  const needsRun = new Set(dirtyIds);
  const queue = [...dirtyIds];
  while (queue.length) {
    const id = queue.shift();
    const cell = S.cells.find(c => c.id === id);
    if (!cell || !cell.defines) continue;
    for (const name of cell.defines) {
      const deps = dependents.get(name);
      if (!deps) continue;
      for (const depId of deps) {
        if (!needsRun.has(depId)) {
          needsRun.add(depId);
          queue.push(depId);
        }
      }
    }
  }

  // return in document order
  return S.cells.filter(c => needsRun.has(c.id)).map(c => c.id);
}

// -- exec.js --

// ── EXECUTION ENGINE ──
//
// Scope model: each cell runs inside an AsyncFunction where upstream variables
// are passed as parameters. This is pass-by-value for primitives — reassigning
// a variable in cell A (e.g. `grid = next`) does NOT propagate to cell B.
// Mutable state that needs to survive across callbacks belongs in %manual cells
// using DOM elements, objects, or closures.
//
// Cell builtins (display, canvas, slider, load, install, installBinary, etc.)
// are injected as additional parameters — listed in _injected, not in scope.
// They are NOT propagated to downstream cells.

// ── BINARY HELPERS ──

function uint8ToBase64(bytes) {
  let bin = '';
  for (let i = 0; i < bytes.length; i++) bin += String.fromCharCode(bytes[i]);
  return btoa(bin);
}

async function decodeBinary(entry) {
  const type = entry.type || 'application/octet-stream';
  const bytes = Uint8Array.from(atob(entry.source), c => c.charCodeAt(0));
  if (entry.compressed) {
    const ds = new DecompressionStream('gzip');
    const stream = new Blob([bytes]).stream().pipeThrough(ds);
    const decompressed = new Uint8Array(await new Response(stream).arrayBuffer());
    return URL.createObjectURL(new Blob([decompressed], { type }));
  }
  return URL.createObjectURL(new Blob([bytes], { type }));
}

// ── TAGGED CONTENT ──

class TaggedContent {
  constructor(type, content) { this.type = type; this.content = content; }
  toString() { return this.content; }
}

function taggedTemplate(type) {
  return (strings, ...values) => {
    let result = strings[0];
    for (let i = 0; i < values.length; i++) result += String(values[i]) + strings[i + 1];
    return new TaggedContent(type, result);
  };
}

// ── EXECUTION ──

function renderHtmlCell(cell) {
  const viewEl = cell.el.querySelector('.cell-html-view');
  const outputEl = cell.el.querySelector('.cell-output');
  if (!viewEl) return;
  if (outputEl) { outputEl.textContent = ''; outputEl.className = 'cell-output'; }

  // use only variables this cell references for stable function signatures
  const scopeKeys = cell.uses ? [...cell.uses].sort() : [];
  const scopeVals = scopeKeys.map(k => S.scope[k]);

  // cache compiled template functions per expression
  if (!cell._tplCache) cell._tplCache = {};
  const scopeSig = scopeKeys.join(',');
  if (cell._tplScopeSig !== scopeSig) {
    cell._tplCache = {};  // scope signature changed, invalidate all
    cell._tplScopeSig = scopeSig;
  }

  let rendered = cell.code.replace(/\$\{([^}]+)\}/g, (match, expr) => {
    try {
      let fn = cell._tplCache[expr];
      if (!fn) {
        fn = new Function(...scopeKeys, '"use strict"; return (' + expr + ')');
        cell._tplCache[expr] = fn;
      }
      const val = fn(...scopeVals);
      return val === undefined ? '' : String(val);
    } catch (e) {
      return '[Error: ' + e.message + ']';
    }
  });

  viewEl.innerHTML = rendered;
  cell.el.classList.remove('stale', 'error');
  cell.el.classList.add('fresh');
  setTimeout(() => cell.el.classList.remove('fresh'), 800);
}

async function execCell(cell) {
  // fire invalidation promise from previous run (cleanup resources)
  if (cell._invalidate) { cell._invalidate(); cell._invalidate = null; }

  const outputEl = cell.el.querySelector('.cell-output');
  const widgetEl = cell.el.querySelector('.cell-widgets');

  // preserve canvases before clearing output
  const prevCanvases = [...outputEl.querySelectorAll('canvas')];
  outputEl.textContent = '';
  outputEl.className = 'cell-output';
  const outClass = parseOutputClass(cell.code);
  if (outClass) outputEl.classList.add(...outClass.split(/\s+/));
  const outId = parseOutputId(cell.code);
  outputEl.id = outId || '';
  cell.el.classList.toggle('present-hidden', isHidden(cell.code));
  cell.error = null;

  // create invalidation promise for this run
  let invalidationResolve;
  const invalidation = new Promise(r => { invalidationResolve = r; });
  cell._invalidate = invalidationResolve;

  // track which widgets are used this run
  const usedWidgets = new Set();
  let canvasIdx = 0;

  // build display function for this cell
  const display = (...args) => {
    for (const arg of args) {
      if (arg instanceof Element) {
        outputEl.appendChild(arg);
      } else if (typeof arg === 'object' && arg !== null) {
        const pre = document.createElement('span');
        try { pre.textContent = JSON.stringify(arg, null, 2); }
        catch { pre.textContent = String(arg); }
        outputEl.appendChild(pre);
        outputEl.appendChild(document.createTextNode('\n'));
      } else {
        outputEl.appendChild(document.createTextNode(String(arg) + '\n'));
      }
    }
  };

  // canvas helper — reuses existing canvas if dimensions match
  const canvas = (w = 400, h = 300) => {
    const prev = prevCanvases[canvasIdx++];
    if (prev && prev.width === w && prev.height === h) {
      outputEl.appendChild(prev);
      return prev;
    }
    const c = document.createElement('canvas');
    c.width = w; c.height = h;
    c.style.background = '#000';
    outputEl.appendChild(c);
    return c;
  };

  // table helper
  const table = (data, columns) => {
    if (!data || !data.length) return;
    const cols = columns || Object.keys(data[0]);

    // detect numeric columns by scanning first 10 rows
    const isNumCol = {};
    for (const c of cols) {
      let allNum = true;
      const scanRows = data.slice(0, 10);
      for (const row of scanRows) {
        const v = row[c];
        if (v !== null && v !== undefined && typeof v !== 'number') { allNum = false; break; }
      }
      isNumCol[c] = allNum;
    }

    const t = document.createElement('table');
    const thead = document.createElement('thead');
    const hr = document.createElement('tr');
    for (const c of cols) {
      const th = document.createElement('th');
      th.textContent = c;
      th.style.textAlign = isNumCol[c] ? 'right' : 'left';
      hr.appendChild(th);
    }
    thead.appendChild(hr);
    t.appendChild(thead);
    const tbody = document.createElement('tbody');
    for (const row of data) {
      const tr = document.createElement('tr');
      for (const c of cols) {
        const td = document.createElement('td');
        const v = row[c];
        td.textContent = typeof v === 'number' ? (Number.isInteger(v) ? v : v.toFixed(4)) : String(v ?? '');
        td.style.textAlign = isNumCol[c] ? 'right' : 'left';
        tr.appendChild(td);
      }
      tbody.appendChild(tr);
    }
    t.appendChild(tbody);
    outputEl.appendChild(t);
  };

  // input widget helpers — persist state and DOM across re-runs
  if (!cell._inputs) cell._inputs = {};
  if (!cell._callbacks) cell._callbacks = {};

  const mkInput = (label, type, defaultVal, opts = {}) => {
    const key = label;
    const prev = cell._inputs[key];
    let val = prev !== undefined ? prev : defaultVal;
    usedWidgets.add(key);
    cell._callbacks[key] = { onInput: opts.onInput, onChange: opts.onChange };

    // check if widget DOM already exists
    const existing = widgetEl.querySelector(`[data-widget-key="${CSS.escape(key)}"]`);
    if (existing) {
      // update id/class in case they changed on re-run
      existing.id = opts.id || '';
      existing.className = 'cell-widget' + (opts.class ? ' ' + opts.class : '');
      // just return current value, DOM stays — callbacks already updated above
      cell._inputs[key] = type === 'slider' ? parseFloat(val)
                         : type === 'checkbox' ? !!val
                         : val;
      return cell._inputs[key];
    }

    // create new widget
    const wrap = document.createElement('div');
    wrap.dataset.widgetKey = key;
    wrap.className = 'cell-widget' + (opts.class ? ' ' + opts.class : '');
    if (opts.id) wrap.id = opts.id;

    const lbl = document.createElement('span');
    lbl.textContent = label;
    lbl.className = 'cell-widget-label';
    wrap.appendChild(lbl);

    let input;
    if (type === 'slider') {
      input = document.createElement('input');
      input.type = 'range';
      input.min = opts.min ?? 0;
      input.max = opts.max ?? 100;
      input.step = opts.step ?? 1;
      input.value = val;
      const valSpan = document.createElement('span');
      valSpan.textContent = val;
      valSpan.className = 'cell-widget-val';
      input.oninput = () => {
        const n = parseFloat(input.value);
        cell._inputs[key] = n;
        valSpan.textContent = n;
        const cb = cell._callbacks[key];
        if (cb.onInput) { cb.onInput(n); }
        else if (!cb.onChange) { clearTimeout(cell._inputTimer); cell._inputTimer = setTimeout(() => runDAG([cell.id], true), 80); }
      };
      input.onchange = () => { const cb = cell._callbacks[key]; if (cb.onChange) cb.onChange(parseFloat(input.value)); };
      wrap.appendChild(input);
      wrap.appendChild(valSpan);
    } else if (type === 'dropdown') {
      input = document.createElement('select');
      for (const o of (opts.options || [])) {
        const opt = document.createElement('option');
        opt.value = o;
        opt.textContent = o;
        if (o === val) opt.selected = true;
        input.appendChild(opt);
      }
      input.onchange = () => {
        cell._inputs[key] = input.value;
        const cb = cell._callbacks[key];
        if (cb.onInput || cb.onChange) {
          if (cb.onInput) cb.onInput(input.value);
          if (cb.onChange) cb.onChange(input.value);
        } else { runDAG([cell.id], true); }
      };
      wrap.appendChild(input);
    } else if (type === 'checkbox') {
      input = document.createElement('input');
      input.type = 'checkbox';
      input.checked = !!val;
      input.onchange = () => {
        cell._inputs[key] = input.checked;
        const cb = cell._callbacks[key];
        if (cb.onInput || cb.onChange) {
          if (cb.onInput) cb.onInput(input.checked);
          if (cb.onChange) cb.onChange(input.checked);
        } else { runDAG([cell.id], true); }
      };
      wrap.appendChild(input);
    } else if (type === 'text') {
      input = document.createElement('input');
      input.type = 'text';
      input.value = val;
      input.oninput = () => {
        cell._inputs[key] = input.value;
        const cb = cell._callbacks[key];
        if (cb.onInput) { cb.onInput(input.value); }
        else if (!cb.onChange) { clearTimeout(cell._inputTimer); cell._inputTimer = setTimeout(() => runDAG([cell.id], true), 300); }
      };
      input.onchange = () => { const cb = cell._callbacks[key]; if (cb.onChange) cb.onChange(input.value); };
      wrap.appendChild(input);
    }

    widgetEl.appendChild(wrap);
    cell._inputs[key] = type === 'slider' ? parseFloat(val)
                       : type === 'checkbox' ? !!val
                       : val;
    return cell._inputs[key];
  };

  const slider = (label, defaultVal = 50, opts = {}) => mkInput(label, 'slider', defaultVal, opts);
  const dropdown = (label, options, defaultVal, opts = {}) => mkInput(label, 'dropdown', defaultVal || options[0], { ...opts, options });
  const checkbox = (label, defaultVal = false, opts = {}) => mkInput(label, 'checkbox', defaultVal, opts);
  const textInput = (label, defaultVal = '', opts = {}) => mkInput(label, 'text', defaultVal, opts);

  // execute with scoped parameters (only what this cell uses, for stable V8 JIT)
  // filter out injected names — they're per-cell params, not scope-propagated
  const _injected = ['ui', 'std', 'load', 'install', 'installBinary', 'invalidation', 'print', 'md', 'html', 'css', 'workshop', 'notebook'];
  const scopeKeys = cell.uses ? [...cell.uses].filter(k => !_injected.includes(k)).sort() : [];
  const defNames = cell.defines ? [...cell.defines].sort().join(', ') : '';

  // import cache — shared across all cells
  if (!window._importCache) window._importCache = {};
  if (!window._installedModules) window._installedModules = {}; // url -> { source, cellId }

  const load = async (url) => {
    // virtual modules
    if (url === '@std') return std;
    if (url === '@python') return python;
    if (url === '@python/this') { display(zenOfPython()); return python; }

    // @atra/<name> — atra library binary distributions
    // if pre-installed (via /// module: directive or install()), the existing
    // _installedModules[url] check below handles it. this fallback covers
    // development mode where the file is available at a relative path.
    if (url.startsWith('@atra/')) {
      if (!window._importCache[url] && !window._installedModules[url]) {
        const name = url.slice(6);
        const mod = await import('./ext/atra/lib/' + name + '.js');
        window._importCache[url] = mod;
        return mod;
      }
      // fall through to normal _importCache / _installedModules handling below
    }

    if (window._importCache[url]) return window._importCache[url];

    // binary assets — return blob URL
    if (window._installedModules[url]?.binary) {
      const blobUrl = await decodeBinary(window._installedModules[url]);
      window._importCache[url] = blobUrl;
      return blobUrl;
    }

    const langsBefore = window._taggedLanguages ? Object.keys(window._taggedLanguages).length : 0;

    let mod;
    // check installed (offline) modules first
    if (window._installedModules[url]) {
      const entry = window._installedModules[url];
      let src = typeof entry === 'string' ? entry : entry.source;
      // resolve root-relative paths for legacy saved modules
      try { src = resolveModulePaths(src, url); } catch {}
      const blob = new Blob([src], { type: 'application/javascript' });
      const blobUrl = URL.createObjectURL(blob);
      mod = await import(blobUrl);
    } else {
      mod = await import(url);
    }
    window._importCache[url] = mod;

    // if the module registered new tagged languages, re-highlight all code cells
    const langsAfter = window._taggedLanguages ? Object.keys(window._taggedLanguages).length : 0;
    if (langsAfter > langsBefore) {
      for (const c of S.cells) {
        if (c.type !== 'code') continue;
        const ta = c.el.querySelector('textarea');
        const hl = c.el.querySelector('.highlight-layer');
        if (ta && hl) highlightCode(ta, hl);
      }
    }

    return mod;
  };

  // resolve root-relative paths in module source so blob URLs work
  const resolveModulePaths = (source, responseUrl) => {
    const origin = new URL(responseUrl).origin;
    return source.replace(/(from\s+["'])(\/[^"']+)(["'])/g, '$1' + origin + '$2$3')
                 .replace(/(import\s*\(["'])(\/[^"']+)(["']\))/g, '$1' + origin + '$2$3')
                 .replace(/(export\s+\*\s+from\s+["'])(\/[^"']+)(["'])/g, '$1' + origin + '$2$3')
                 .replace(/(export\s*\{[^}]*\}\s*from\s+["'])(\/[^"']+)(["'])/g, '$1' + origin + '$2$3');
  };

  const install = async (url) => {
    // @atra/<name> — resolve to CDN URL, store under virtual key
    if (url.startsWith('@atra/')) {
      const name = url.slice(6);
      const realUrl = __AUDITABLE_PAGES_URL__ + '/ext/atra/lib/' + name + '.js';
      const resp = await fetch(realUrl);
      if (!resp.ok) throw new Error(`Failed to fetch ${realUrl}: ${resp.status}`);
      const source = await resp.text();
      window._installedModules[url] = { source, cellId: cell.id };
      const blob = new Blob([source], { type: 'application/javascript' });
      const blobUrl = URL.createObjectURL(blob);
      const mod = await import(blobUrl);
      window._importCache[url] = mod;
      display(`installed ${url} (${(source.length / 1024).toFixed(1)} KB)`);
      return mod;
    }
    // normalize: add ?bundle for esm.sh if not present
    let bundleUrl = url;
    if (bundleUrl.includes('esm.sh') && !bundleUrl.includes('?bundle') && !bundleUrl.includes('&bundle')) {
      bundleUrl += (bundleUrl.includes('?') ? '&' : '?') + 'bundle';
    }
    // fetch source
    const resp = await fetch(bundleUrl);
    if (!resp.ok) throw new Error(`Failed to fetch ${bundleUrl}: ${resp.status}`);
    let source = await resp.text();
    // resolve root-relative paths to absolute so blob URLs work
    source = resolveModulePaths(source, resp.url);
    // store under original url with cell reference
    window._installedModules[url] = { source, cellId: cell.id };
    // also load it into cache
    const blob = new Blob([source], { type: 'application/javascript' });
    const blobUrl = URL.createObjectURL(blob);
    const mod = await import(blobUrl);
    window._importCache[url] = mod;
    display(`installed ${url} (${(source.length / 1024).toFixed(1)} KB)`);
    return mod;
  };

  const installBinary = async (url, opts = {}) => {
    const compress = opts.compress !== false;
    // if already installed, decode and return blob URL
    if (window._installedModules[url]?.binary) {
      return decodeBinary(window._installedModules[url]);
    }
    const resp = await fetch(url);
    if (!resp.ok) throw new Error(`Failed to fetch ${url}: ${resp.status}`);
    const contentType = resp.headers.get('content-type')?.split(';')[0] || 'application/octet-stream';
    const buf = await resp.arrayBuffer();
    const raw = new Uint8Array(buf);
    let stored, isCompressed = false;
    if (compress) {
      const cs = new CompressionStream('gzip');
      const stream = new Blob([raw]).stream().pipeThrough(cs);
      const compressed = new Uint8Array(await new Response(stream).arrayBuffer());
      stored = uint8ToBase64(compressed);
      isCompressed = true;
    } else {
      stored = uint8ToBase64(raw);
    }
    window._installedModules[url] = { source: stored, cellId: cell.id, binary: true, compressed: isCompressed, type: contentType };
    const ratio = isCompressed ? ` \u2192 ${(stored.length / 1024).toFixed(1)} KB compressed` : '';
    display(`installed binary ${url} (${(buf.byteLength / 1024).toFixed(1)} KB${ratio})`);
    return URL.createObjectURL(new Blob([raw], { type: contentType }));
  };

  // ui object — constructed per-cell (closes over cell context)
  const ui = { display, print: display, canvas, table, slider, dropdown, checkbox, textInput };

  // tagged template builtins
  const md = taggedTemplate('md');
  const html = taggedTemplate('html');
  const css = taggedTemplate('css');

  // workshop builtin — slide-out side panel with navigable pages
  const workshop = (pages, opts) => {
    const key = '__workshop__';
    usedWidgets.add(key);
    const useOverlay = !!(opts && opts.overlay);

    // persist page index across re-runs
    if (cell._inputs[key] === undefined) cell._inputs[key] = 0;
    let currentPage = cell._inputs[key];

    // get or create panel DOM
    let panel = document.getElementById('workshopPanel');
    let overlay = document.getElementById('workshopOverlay');
    if (!panel) {
      overlay = document.createElement('div');
      overlay.id = 'workshopOverlay';
      overlay.className = 'workshop-overlay';
      overlay.onclick = () => toggleWorkshop(false);
      document.body.appendChild(overlay);

      panel = document.createElement('div');
      panel.id = 'workshopPanel';
      panel.className = 'workshop-panel';
      document.body.appendChild(panel);
    }

    // side tab attached to the panel edge
    let toggleBtn = document.getElementById('workshopToggle');
    if (!toggleBtn) {
      toggleBtn = document.createElement('button');
      toggleBtn.id = 'workshopToggle';
      toggleBtn.className = 'workshop-tab';
      toggleBtn.title = 'toggle workshop panel';
      toggleBtn.textContent = 'workshop';
      document.body.appendChild(toggleBtn);
      toggleBtn.onclick = () => toggleWorkshop();
    }

    function toggleWorkshop(show) {
      const isOpen = panel.classList.contains('open');
      const shouldOpen = show !== undefined ? show : !isOpen;
      panel.classList.toggle('open', shouldOpen);
      if (useOverlay) overlay.classList.toggle('visible', shouldOpen);
    }

    function renderPage(idx) {
      idx = Math.max(0, Math.min(idx, pages.length - 1));
      currentPage = idx;
      cell._inputs[key] = idx;
      const page = pages[idx];

      panel.innerHTML = '';

      // header with close button
      const header = document.createElement('div');
      header.className = 'workshop-header';
      const title = document.createElement('span');
      title.className = 'workshop-title';
      title.textContent = page.title || `Page ${idx + 1}`;
      header.appendChild(title);
      const closeBtn = document.createElement('button');
      closeBtn.className = 'workshop-close';
      closeBtn.textContent = '\u00d7';
      closeBtn.onclick = () => toggleWorkshop(false);
      header.appendChild(closeBtn);
      panel.appendChild(header);

      // content
      const body = document.createElement('div');
      body.className = 'workshop-body';
      if (page.content instanceof Element) {
        body.appendChild(page.content);
      } else if (page.content instanceof TaggedContent) {
        if (page.content.type === 'md') {
          body.innerHTML = renderMd(page.content.content);
        } else if (page.content.type === 'css') {
          const pre = document.createElement('pre');
          pre.textContent = page.content.content;
          body.appendChild(pre);
        } else {
          body.innerHTML = page.content.content;
        }
      } else {
        body.textContent = String(page.content ?? '');
      }
      panel.appendChild(body);

      // progress pips
      const pips = document.createElement('div');
      pips.className = 'workshop-pips';
      for (let i = 0; i < pages.length; i++) {
        const pip = document.createElement('span');
        pip.className = 'workshop-pip' + (i === idx ? ' active' : '') + (i < idx ? ' done' : '');
        pip.onclick = () => navigate(i);
        pips.appendChild(pip);
      }
      panel.appendChild(pips);

      // nav buttons
      const nav = document.createElement('div');
      nav.className = 'workshop-nav';
      if (idx > 0) {
        const prev = document.createElement('button');
        prev.textContent = '\u2190 prev';
        prev.onclick = () => navigate(idx - 1);
        nav.appendChild(prev);
      }
      const spacer = document.createElement('span');
      spacer.style.flex = '1';
      nav.appendChild(spacer);
      const counter = document.createElement('span');
      counter.className = 'workshop-counter';
      counter.textContent = `${idx + 1} / ${pages.length}`;
      nav.appendChild(counter);
      if (idx < pages.length - 1) {
        const next = document.createElement('button');
        next.className = 'workshop-next';
        next.textContent = 'next \u2192';
        if (page.canAdvance && !page.canAdvance()) {
          next.disabled = true;
          next.title = 'complete the task to continue';
        }
        next.onclick = () => navigate(idx + 1);
        nav.appendChild(next);
      }
      panel.appendChild(nav);

      // fire onEnter
      if (page.onEnter) page.onEnter();
    }

    function navigate(idx) {
      const prevPage = pages[currentPage];
      if (prevPage?.onLeave) prevPage.onLeave();
      renderPage(idx);
    }

    // store re-check function for canAdvance gating
    cell._workshopRecheck = () => {
      const page = pages[currentPage];
      if (!page?.canAdvance) return;
      const nextBtn = panel.querySelector('.workshop-next');
      if (nextBtn) {
        nextBtn.disabled = !page.canAdvance();
      }
    };

    renderPage(currentPage);

    // auto-open on first creation
    if (!panel.classList.contains('open') && !cell._workshopShown) {
      toggleWorkshop(true);
      cell._workshopShown = true;
    }

    // store cleanup so deleteCell can tear down workshop DOM
    cell._workshopCleanup = () => {
      panel.remove();
      overlay.remove();
      toggleBtn.remove();
      cell._workshopRecheck = null;
    };
    // on re-run, just clear the recheck — DOM is reused by ID
    invalidation.then(() => {
      cell._workshopRecheck = null;
    });

    return { goto: navigate, toggle: toggleWorkshop, recheck: cell._workshopRecheck };
  };

  // notebook API — programmatic notebook control
  const notebook = {
    get cells() { return S.cells.map(c => ({ id: c.id, type: c.type, code: c.code })); },
    get scope() { return { ...S.scope }; },
    addCell: (type, code, afterId) => addCell(type, code, afterId),
    scrollTo: (id) => {
      const c = S.cells.find(c => c.id === id);
      if (c?.el) c.el.scrollIntoView({ behavior: 'smooth', block: 'center' });
    },
    focus: (id) => {
      const c = S.cells.find(c => c.id === id);
      if (c?.el) {
        c.el.scrollIntoView({ behavior: 'smooth', block: 'center' });
        const ta = c.el.querySelector('textarea');
        if (ta) ta.focus();
      }
    },
    collapse: (id) => {
      const c = S.cells.find(c => c.id === id);
      if (c?.el) c.el.classList.add('collapsed');
    },
    expand: (id) => {
      const c = S.cells.find(c => c.id === id);
      if (c?.el) c.el.classList.remove('collapsed');
    },
    run: (ids) => runDAG(Array.isArray(ids) ? ids : [ids], true),
  };

  // function caching — reuse compiled function if code/uses/defines unchanged
  const cacheKey = scopeKeys.join(',') + '|' + defNames + '|' + cell.code;

  try {
    let fn;
    if (cell._cacheKey === cacheKey && cell._cachedFn) {
      fn = cell._cachedFn;
    } else {
      const AsyncFunction = Object.getPrototypeOf(async function(){}).constructor;
      const cellName = parseCellName(cell.code);
      const slug = cellName ? '-' + cellName.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/(^-|-$)/g, '') : '';
      fn = new AsyncFunction(
        ...scopeKeys,
        'ui', 'std', 'load', 'install', 'installBinary', 'invalidation', 'print',
        'md', 'html', 'css', 'workshop', 'notebook',
        `"use strict";\n${cell.code}\n\n` +
        `return { ${defNames} };\n` +
        `//# sourceURL=auditable://cell-${cell.id}${slug}.js`
      );
      cell._cachedFn = fn;
      cell._cacheKey = cacheKey;
    }

    const scopeVals = scopeKeys.map(k => S.scope[k]);
    const result = await fn(...scopeVals, ui, std, load, install, installBinary, invalidation, display,
      md, html, css, workshop, notebook);

    // update scope with defined variables
    if (result && typeof result === 'object') {
      cell._lastResult = result;
      for (const [k, v] of Object.entries(result)) {
        if (v !== undefined) S.scope[k] = v;
      }
    }

    cell.el.classList.remove('stale', 'error');
    cell.el.classList.add('fresh');
    setTimeout(() => cell.el.classList.remove('fresh'), 800);

    // remove widgets no longer referenced by code
    for (const w of widgetEl.querySelectorAll('[data-widget-key]')) {
      if (!usedWidgets.has(w.dataset.widgetKey)) {
        delete cell._inputs[w.dataset.widgetKey];
        delete cell._callbacks[w.dataset.widgetKey];
        w.remove();
      }
    }

  } catch (e) {
    cell.error = e.message;
    outputEl.textContent = e.message;
    outputEl.className = 'cell-output error';
    cell.el.classList.remove('stale', 'fresh');
    cell.el.classList.add('error');
  }
}

async function runDAG(dirtyIds, force = false) {
  buildDAG();
  const isAutorun = S.autorun && !force;

  // determine which cells need execution via topo sort
  const runSet = new Set(topoSort(dirtyIds));

  if (window._dagStart) window._dagStart();

  // rebuild scope in document order, only executing cells in runSet
  S.scope = {};
  const poisoned = new Set(); // variable names defined by errored cells
  for (let i = 0; i < S.cells.length; i++) {
    const cell = S.cells[i];

    if (cell.type === 'html') {
      if (runSet.has(cell.id)) {
        // check if any used variable is poisoned
        if (cell.uses && [...cell.uses].some(n => poisoned.has(n))) {
          cell.el.classList.remove('fresh');
          cell.el.classList.add('stale');
        } else {
          renderHtmlCell(cell);
        }
      }
      continue;
    }
    if (cell.type !== 'code') continue;

    // skip norun cells (unless explicitly triggered)
    if (isNorun(cell.code) && !dirtyIds.includes(cell.id)) {
      if (cell._lastResult) {
        for (const [k, v] of Object.entries(cell._lastResult)) {
          if (v !== undefined) S.scope[k] = v;
        }
      }
      continue;
    }

    // skip manual cells unless force or explicitly triggered
    if (!force && isManual(cell.code) && !dirtyIds.includes(cell.id)) {
      if (cell._lastResult) {
        for (const [k, v] of Object.entries(cell._lastResult)) {
          if (v !== undefined) S.scope[k] = v;
        }
      }
      cell.el.classList.add('stale');
      continue;
    }

    // not in run set — restore cached results, skip execution
    if (!runSet.has(cell.id)) {
      if (cell._lastResult) {
        for (const [k, v] of Object.entries(cell._lastResult)) {
          if (v !== undefined) S.scope[k] = v;
        }
      }
      continue;
    }

    // error isolation: if any upstream dependency is poisoned, skip this cell
    if (cell.uses && cell.uses.size > 0) {
      let blocked = false;
      for (const name of cell.uses) {
        if (poisoned.has(name)) { blocked = true; break; }
      }
      if (blocked) {
        const outputEl = cell.el.querySelector('.cell-output');
        if (outputEl && !cell.error) {
          outputEl.textContent = 'blocked by upstream error';
          outputEl.className = 'cell-output error';
        }
        cell.el.classList.remove('stale', 'fresh');
        cell.el.classList.add('error');
        // poison our own defines so downstream also blocks
        if (cell.defines) for (const name of cell.defines) poisoned.add(name);
        continue;
      }
    }

    // value-equality gating: if this cell is a downstream dependent (not directly
    // dirty) and all its input values are unchanged, skip re-execution entirely
    if (!dirtyIds.includes(cell.id) && cell._lastResult && cell.uses && cell.uses.size > 0) {
      let inputsChanged = false;
      for (const name of cell.uses) {
        if (S.scope[name] !== cell._prevInputs?.[name]) { inputsChanged = true; break; }
      }
      if (!inputsChanged) {
        // inputs identical — restore previous results, skip execution
        for (const [k, v] of Object.entries(cell._lastResult)) {
          if (v !== undefined) S.scope[k] = v;
        }
        continue;
      }
    }

    if (window._beforeExec) window._beforeExec(cell);
    await execCell(cell);

    // if the cell errored, poison its defines
    if (cell.error) {
      if (cell.defines) for (const name of cell.defines) poisoned.add(name);
    }

    // snapshot input values for future equality checks
    if (cell.uses) {
      cell._prevInputs = {};
      for (const name of cell.uses) cell._prevInputs[name] = S.scope[name];
    }

    if (window._afterExec && !isAutorun) {
      const jump = window._afterExec(cell, i);
      if (jump >= 0) { i = jump - 1; continue; }
    }
  }

  updateStatus();

  // recheck workshop canAdvance gates after scope changes
  for (const c of S.cells) {
    if (c._workshopRecheck) c._workshopRecheck();
  }
}

async function runAll() {
  const ids = S.cells.filter(c => c.type === 'code' || c.type === 'html').map(c => c.id);
  if (ids.length === 0) return;
  await runDAG(ids, true);
  setMsg('ran all cells', 'ok');
}

// late import to avoid circular dependency at module load time

// -- markdown.js --

// ── MARKDOWN RENDERING (minimal) ──

function renderMd(src) {
  let html = src
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;');

  // headings
  html = html.replace(/^### (.+)$/gm, '<h3>$1</h3>');
  html = html.replace(/^## (.+)$/gm, '<h2>$1</h2>');
  html = html.replace(/^# (.+)$/gm, '<h1>$1</h1>');

  // bold/italic
  html = html.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
  html = html.replace(/\*(.+?)\*/g, '<em>$1</em>');

  // inline code
  html = html.replace(/`(.+?)`/g, '<code>$1</code>');

  // links
  html = html.replace(/\[(.+?)\]\((.+?)\)/g, '<a href="$2">$1</a>');

  // tables — detect pipe-delimited blocks before paragraph wrapping
  html = html.replace(
    /((?:^\|.+\|[ \t]*$\n?)+)/gm,
    (block) => {
      const rows = block.trim().split('\n').map(r =>
        r.trim().replace(/^\|/, '').replace(/\|$/, '').split('|').map(c => c.trim())
      );
      if (rows.length < 2) return block;
      // check for separator row (--- or :--- etc)
      const sep = rows[1];
      if (!sep.every(c => /^:?-{1,}:?$/.test(c))) return block;
      const hdr = rows[0];
      const body = rows.slice(2);
      let t = '<table><thead><tr>' +
        hdr.map(c => `<th>${c}</th>`).join('') +
        '</tr></thead><tbody>';
      for (const row of body) {
        t += '<tr>' + row.map(c => `<td>${c}</td>`).join('') + '</tr>';
      }
      t += '</tbody></table>';
      return t;
    }
  );

  // paragraphs
  html = html.replace(/\n\n/g, '</p><p>');
  if (!html.startsWith('<h') && !html.startsWith('<p') && !html.startsWith('<table')) html = '<p>' + html + '</p>';

  return html;
}

// -- cell-dom.js --

// ── CELL DOM ──

function cssSummary(code) {
  if (!code || !code.trim()) return '';
  const rules = (code.match(/[^{}]+\{/g) || []).length;
  const lines = code.split('\n').length;
  return `${rules} rule${rules !== 1 ? 's' : ''} \u00b7 ${lines} line${lines !== 1 ? 's' : ''}`;
}

function cellHeaderHTML(type, id) {
  return `<div class="cell-header">
    <span class="cell-type">${type}</span>
    <button class="cell-btn cell-convert" onclick="toggleTypePicker(${id})" title="convert type">\u21c4</button>
    <div class="cell-type-picker" data-cell-id="${id}">
      <button onclick="convertCell(${id},'code')">code</button>
      <button onclick="convertCell(${id},'md')">md</button>
      <button onclick="convertCell(${id},'css')">css</button>
      <button onclick="convertCell(${id},'html')">html</button>
    </div>
    <button class="cell-btn cell-insert" onclick="showInsertPicker(${id},'before')" title="insert above">+\u2191</button>
    <button class="cell-btn cell-insert" onclick="showInsertPicker(${id},'after')" title="insert below">+\u2193</button>
    <button class="cell-btn" onclick="moveCell(${id},-1)" title="move up">\u2191</button>
    <button class="cell-btn" onclick="moveCell(${id},1)" title="move down">\u2193</button>
    <button class="cell-btn del" onclick="deleteCellWithUndo(${id})" title="delete">\u00d7</button>
  </div>`;
}

function createCellEl(type, id) {
  const div = document.createElement('div');
  div.className = 'cell';
  div.dataset.id = id;
  div.dataset.type = type;

  if (type === 'code') {
    div.innerHTML = `
      ${cellHeaderHTML('code', id)}
      <div class="cell-code">
        <div class="editor-wrap">
          <div class="line-numbers" aria-hidden="true">1</div>
          <textarea rows="3" spellcheck="false" wrap="off" placeholder="// code"></textarea>
          <div class="highlight-layer" aria-hidden="true"></div>
        </div>
      </div>
      <div class="cell-widgets"></div>
      <div class="cell-output"></div>
    `;

    const ta = div.querySelector('textarea');
    const hl = div.querySelector('.highlight-layer');
    div.querySelector('.cell-type').addEventListener('click', () => div.classList.toggle('collapsed'));
    const ln = div.querySelector('.line-numbers');
    ta.addEventListener('input', () => { highlightCode(ta, hl); onCodeEdit(id); });
    ta.addEventListener('scroll', () => { hl.scrollTop = ta.scrollTop; hl.scrollLeft = ta.scrollLeft; ln.scrollTop = ta.scrollTop; });
    attachAutocomplete(ta, id);
    ta.addEventListener('keydown', handleTab);
    ta.addEventListener('input', autoResize);
  } else if (type === 'css') {
    div.innerHTML = `
      ${cellHeaderHTML('css', id)}
      <div class="cell-css-view"></div>
      <div class="cell-css-edit" style="display:none">
        <div class="editor-wrap">
          <div class="line-numbers" aria-hidden="true">1</div>
          <textarea rows="3" spellcheck="false" wrap="off" placeholder="/* css */"></textarea>
          <div class="highlight-layer" aria-hidden="true"></div>
        </div>
      </div>
    `;

    const cssView = div.querySelector('.cell-css-view');
    const cssEditWrap = div.querySelector('.cell-css-edit');
    const ta = div.querySelector('textarea');
    const hl = div.querySelector('.highlight-layer');
    div.querySelector('.cell-type').addEventListener('click', () => div.classList.toggle('collapsed'));

    cssView.addEventListener('click', () => {
      cssEditWrap.style.display = '';
      cssView.style.display = 'none';
      ta.focus();
      autoResize({ target: ta });
    });

    ta.addEventListener('blur', () => {
      if (S.findActive) return;
      const cell = S.cells.find(c => c.id === id);
      if (cell) {
        cell.code = ta.value;
        cssView.textContent = cssSummary(ta.value);
      }
      cssEditWrap.style.display = 'none';
      cssView.style.display = '';
    });

    const ln = div.querySelector('.line-numbers');
    ta.addEventListener('input', () => { highlightCss(ta, hl); onCssEdit(id); });
    ta.addEventListener('scroll', () => { hl.scrollTop = ta.scrollTop; hl.scrollLeft = ta.scrollLeft; ln.scrollTop = ta.scrollTop; });
    ta.addEventListener('input', autoResize);
    ta.addEventListener('keydown', handleTab);
  } else if (type === 'html') {
    div.innerHTML = `
      ${cellHeaderHTML('html', id)}
      <div class="cell-html-view"></div>
      <div class="cell-html-edit" style="display:none">
        <div class="editor-wrap">
          <div class="line-numbers" aria-hidden="true">1</div>
          <textarea rows="2" spellcheck="false" wrap="off" placeholder="<html template>"></textarea>
          <div class="highlight-layer" aria-hidden="true"></div>
        </div>
      </div>
      <div class="cell-output"></div>
    `;

    const view = div.querySelector('.cell-html-view');
    const editWrap = div.querySelector('.cell-html-edit');
    const ta = div.querySelector('.cell-html-edit textarea');
    const hl = div.querySelector('.highlight-layer');
    div.querySelector('.cell-type').addEventListener('click', () => div.classList.toggle('collapsed'));

    view.addEventListener('click', () => {
      editWrap.style.display = '';
      view.style.display = 'none';
      ta.focus();
      autoResize({ target: ta });
    });

    ta.addEventListener('blur', () => {
      if (S.findActive) return;
      const cell = S.cells.find(c => c.id === id);
      if (cell) {
        cell.code = ta.value;
        renderHtmlCell(cell);
      }
      editWrap.style.display = 'none';
      view.style.display = '';
    });

    const ln = div.querySelector('.line-numbers');
    ta.addEventListener('input', () => { highlightHtml(ta, hl); onHtmlEdit(id); });
    ta.addEventListener('scroll', () => { hl.scrollTop = ta.scrollTop; hl.scrollLeft = ta.scrollLeft; ln.scrollTop = ta.scrollTop; });
    ta.addEventListener('input', autoResize);
    ta.addEventListener('keydown', handleTab);
  } else {
    div.innerHTML = `
      ${cellHeaderHTML('md', id)}
      <div class="cell-md-view"></div>
      <div class="cell-md-edit" style="display:none">
        <textarea rows="2" spellcheck="false" placeholder="markdown"></textarea>
      </div>
    `;

    const view = div.querySelector('.cell-md-view');
    const editWrap = div.querySelector('.cell-md-edit');
    const ta = div.querySelector('.cell-md-edit textarea');
    div.querySelector('.cell-type').addEventListener('click', () => div.classList.toggle('collapsed'));

    view.addEventListener('click', () => {
      editWrap.style.display = '';
      view.style.display = 'none';
      ta.focus();
      autoResize({ target: ta });
    });

    ta.addEventListener('blur', () => {
      if (S.findActive) return;
      const cell = S.cells.find(c => c.id === id);
      if (cell) {
        cell.code = ta.value;
        view.innerHTML = renderMd(ta.value);
      }
      editWrap.style.display = 'none';
      view.style.display = '';
    });

    ta.addEventListener('input', autoResize);
    ta.addEventListener('keydown', handleTab);
  }

  return div;
}

// undoable text replacement — uses execCommand so the browser records it in the undo stack
function replaceRange(ta, from, to, text) {
  ta.focus();
  ta.selectionStart = from;
  ta.selectionEnd = to;
  document.execCommand('insertText', false, text);
}

function handleTab(e) {
  const ta = e.target;
  const start = ta.selectionStart;
  const end = ta.selectionEnd;

  if (e.key === 'Tab') {
    e.preventDefault();

    if (start === end) {
      // no selection — insert 2 spaces
      replaceRange(ta, start, end, '  ');
    } else {
      // selection — indent/unindent lines
      const val = ta.value;
      const lineStart = val.lastIndexOf('\n', start - 1) + 1;
      const lineEnd = val.indexOf('\n', end);
      const blockEnd = lineEnd === -1 ? val.length : lineEnd;
      const block = val.slice(lineStart, blockEnd);
      let newBlock;
      if (e.shiftKey) {
        newBlock = block.replace(/^  /gm, '');
      } else {
        newBlock = block.replace(/^/gm, '  ');
      }
      replaceRange(ta, lineStart, blockEnd, newBlock);
      ta.selectionStart = lineStart;
      ta.selectionEnd = lineStart + newBlock.length;
    }
    ta.dispatchEvent(new Event('input'));
    return;
  }

  // Enter — auto-indent
  if (e.key === 'Enter') {
    e.preventDefault();
    const val = ta.value;
    const before = val.slice(0, start);
    const after = val.slice(end);

    // find current line's leading whitespace
    const lineStart = before.lastIndexOf('\n') + 1;
    const line = before.slice(lineStart);
    const indent = line.match(/^(\s*)/)[1];

    // check if the character before cursor is an opener
    const charBefore = before.trimEnd().slice(-1);
    const extra = '{(['.includes(charBefore) ? '  ' : '';

    // check if the character after cursor is a matching closer
    const charAfter = after.trimStart()[0];
    const pairs = { '{': '}', '(': ')', '[': ']' };
    const needClose = extra && charAfter === pairs[charBefore];

    if (needClose) {
      // cursor between brackets: add indented line + closing line
      const insert = '\n' + indent + extra + '\n' + indent;
      replaceRange(ta, start, end, insert);
      ta.selectionStart = ta.selectionEnd = start + 1 + indent.length + extra.length;
    } else {
      const insert = '\n' + indent + extra;
      replaceRange(ta, start, end, insert);
    }
    ta.dispatchEvent(new Event('input'));
    return;
  }

  // Ctrl+X / Ctrl+C with no selection — whole-line cut/copy
  if ((e.key === 'x' || e.key === 'c') && (e.ctrlKey || e.metaKey) && !e.shiftKey && !e.altKey && start === end) {
    e.preventDefault();
    const val = ta.value;
    const lineStart = val.lastIndexOf('\n', start - 1) + 1;
    let lineEnd = val.indexOf('\n', start);
    if (lineEnd === -1) lineEnd = val.length;
    else lineEnd++; // include the newline

    const lineText = val.slice(lineStart, lineEnd);
    navigator.clipboard.writeText(lineText);

    if (e.key === 'x') {
      replaceRange(ta, lineStart, lineEnd, '');
      ta.dispatchEvent(new Event('input'));
    }
    return;
  }
}

function toggleComment(ta) {
  const val = ta.value;
  const start = ta.selectionStart;
  const end = ta.selectionEnd;

  // find affected line range
  const lineStart = val.lastIndexOf('\n', start - 1) + 1;
  let lineEnd = val.indexOf('\n', end);
  if (lineEnd === -1) lineEnd = val.length;

  const block = val.slice(lineStart, lineEnd);
  const lines = block.split('\n');

  // check if all lines are commented
  const allCommented = lines.every(l => /^\s*\/\//.test(l) || l.trim() === '');

  let newLines;
  if (allCommented) {
    // uncomment: remove first // (and one trailing space if present)
    newLines = lines.map(l => l.replace(/^(\s*)\/\/ ?/, '$1'));
  } else {
    // comment: add // at the minimum indent level
    const indents = lines.filter(l => l.trim()).map(l => l.match(/^(\s*)/)[1].length);
    const minIndent = indents.length ? Math.min(...indents) : 0;
    newLines = lines.map(l => {
      if (l.trim() === '') return l;
      return l.slice(0, minIndent) + '// ' + l.slice(minIndent);
    });
  }

  const newBlock = newLines.join('\n');
  replaceRange(ta, lineStart, lineEnd, newBlock);
  ta.selectionStart = lineStart;
  ta.selectionEnd = lineStart + newBlock.length;
  ta.dispatchEvent(new Event('input'));
}

function updateLineNumbers(ta) {
  const wrap = ta.closest('.editor-wrap');
  if (!wrap) return;
  const gutter = wrap.querySelector('.line-numbers');
  if (!gutter) return;
  const count = ta.value.split('\n').length;
  const lines = [];
  for (let i = 1; i <= count; i++) lines.push(i);
  gutter.textContent = lines.join('\n');
}

function autoResize(e) {
  const ta = e.target || e;
  ta.style.height = 'auto';
  ta.style.height = ta.scrollHeight + 'px';
  // sync highlight layer if present
  const hl = ta.parentElement && ta.parentElement.querySelector('.highlight-layer');
  if (hl) { hl.style.height = ta.style.height; }
  updateLineNumbers(ta);
}

// -- cell-ops.js --

// ── CELL OPERATIONS ──

function addCell(type, code = '', afterId = null, beforeId = null) {
  const id = S.cellId++;
  const cell = {
    id, type, code,
    defines: new Set(),
    uses: new Set(),
    error: null,
    el: createCellEl(type, id)
  };

  const nb = $('#notebook');
  if (beforeId !== null) {
    const idx = S.cells.findIndex(c => c.id === beforeId);
    if (idx >= 0) {
      S.cells.splice(idx, 0, cell);
      S.cells[idx + 1].el.before(cell.el);
    } else {
      S.cells.push(cell);
      nb.appendChild(cell.el);
    }
  } else if (afterId !== null) {
    const idx = S.cells.findIndex(c => c.id === afterId);
    if (idx >= 0) {
      S.cells.splice(idx + 1, 0, cell);
      if (idx < S.cells.length - 2) {
        S.cells[idx + 2].el.before(cell.el);
      } else {
        nb.appendChild(cell.el);
      }
    } else {
      S.cells.push(cell);
      nb.appendChild(cell.el);
    }
  } else {
    S.cells.push(cell);
    nb.appendChild(cell.el);
  }

  // set code
  const ta = cell.el.querySelector('textarea');
  if (code) {
    ta.value = code;
    autoResize({ target: ta });
    if (type === 'code') {
      const hl = cell.el.querySelector('.highlight-layer');
      if (hl) highlightCode(ta, hl);
      if (isManual(code)) cell.el.classList.add('manual');
    }
    if (type === 'md') {
      cell.el.querySelector('.cell-md-view').innerHTML = renderMd(code);
    }
  }

  // CSS cell: create <style> element in <head>
  if (type === 'css') {
    const hl = cell.el.querySelector('.highlight-layer');
    if (hl && code) highlightCss(ta, hl);
    const cssView = cell.el.querySelector('.cell-css-view');
    if (cssView && code) cssView.textContent = cssSummary(code);
    const styleEl = document.createElement('style');
    styleEl.dataset.cellId = id;
    styleEl.textContent = code;
    document.head.appendChild(styleEl);
    cell._styleEl = styleEl;
  }

  // HTML cell: render template
  if (type === 'html' && code) {
    renderHtmlCell(cell);
  }

  if (S.initialized) ta.focus();
  updateStatus();
  notifyDirty();
  return cell;
}

function deleteCell(id) {
  const idx = S.cells.findIndex(c => c.id === id);
  if (idx < 0) return;
  // fire invalidation so cell resources (timers, etc.) clean up
  if (S.cells[idx]._invalidate) { S.cells[idx]._invalidate(); S.cells[idx]._invalidate = null; }
  // tear down workshop DOM if this cell had one
  if (S.cells[idx]._workshopCleanup) { S.cells[idx]._workshopCleanup(); S.cells[idx]._workshopCleanup = null; }
  if (S.cells[idx]._styleEl) {
    S.cells[idx]._styleEl.remove();
    S.cells[idx]._styleEl = null;
  }
  S.cells[idx].el.remove();
  S.cells.splice(idx, 1);
  // re-run to clean scope
  if (S.cells.some(c => c.type === 'code' || c.type === 'html')) runAll();
  updateStatus();
  notifyDirty();
}

function convertCell(id, newType) {
  const cell = S.cells.find(c => c.id === id);
  if (!cell || cell.type === newType) return;

  const code = cell.code;

  // cleanup old type
  if (cell._styleEl) {
    cell._styleEl.remove();
    cell._styleEl = null;
  }

  // create new cell element
  const newEl = createCellEl(newType, id);
  cell.el.replaceWith(newEl);
  cell.el = newEl;
  cell.type = newType;

  // set code
  const ta = newEl.querySelector('textarea');
  ta.value = code;
  cell.code = code;
  autoResize({ target: ta });

  if (newType === 'code') {
    const hl = newEl.querySelector('.highlight-layer');
    if (hl) highlightCode(ta, hl);
  }
  if (newType === 'md') {
    newEl.querySelector('.cell-md-view').innerHTML = renderMd(code);
  }
  if (newType === 'css') {
    const hl = newEl.querySelector('.highlight-layer');
    if (hl) highlightCss(ta, hl);
    const cssView = newEl.querySelector('.cell-css-view');
    if (cssView && code) cssView.textContent = cssSummary(code);
    const styleEl = document.createElement('style');
    styleEl.dataset.cellId = id;
    styleEl.textContent = code;
    document.head.appendChild(styleEl);
    cell._styleEl = styleEl;
  }
  if (newType === 'html') {
    renderHtmlCell(cell);
  }

  selectCell(id);
  updateStatus();
  notifyDirty();
  if (S.cells.some(c => c.type === 'code' || c.type === 'html')) runAll();
}

function moveCell(id, dir) {
  const idx = S.cells.findIndex(c => c.id === id);
  const newIdx = idx + dir;
  if (newIdx < 0 || newIdx >= S.cells.length) return;

  const [cell] = S.cells.splice(idx, 1);
  S.cells.splice(newIdx, 0, cell);

  // re-order DOM
  const nb = $('#notebook');
  nb.innerHTML = '';
  for (const c of S.cells) nb.appendChild(c.el);

  // re-order CSS <style> elements in <head> to match cell order
  for (const c of S.cells) {
    if (c._styleEl) document.head.appendChild(c._styleEl);
  }

  notifyDirty();
  if (S.cells.some(c => c.type === 'code' || c.type === 'html')) runAll();
}

// -- editor.js --

// ── EDITING ──

function notifyDirty() {
  if (S.initialized && window.__AF_BRIDGE__) window.parent.postMessage({ type: 'af:dirty' }, '*');
}

function toggleAutorun() {
  S.autorun = !S.autorun;
  const btn = $('#autorunBtn');
  const btnMobile = document.getElementById('autorunBtnMobile');
  const cls = S.autorun ? 'autorun-on' : 'autorun-off';
  const text = S.autorun ? '\u25b6' : '\u2016';
  btn.textContent = text;
  btn.title = S.autorun ? 'reactive mode \u2014 cells auto-run on edit' : 'manual mode \u2014 only Run All or Ctrl+Enter';
  btn.className = cls;
  if (btnMobile) {
    btnMobile.textContent = text;
    btnMobile.className = cls;
  }
  const sel = $('#setExecMode');
  if (sel) sel.value = S.autorun ? 'reactive' : 'manual';
  setMsg(S.autorun ? 'autorun on' : 'autorun off', 'ok');
}

function onCssEdit(id) {
  const cell = S.cells.find(c => c.id === id);
  if (!cell) return;
  cell.code = cell.el.querySelector('textarea').value;
  if (cell._styleEl) cell._styleEl.textContent = cell.code;
  notifyDirty();
}

function onHtmlEdit(id) {
  const cell = S.cells.find(c => c.id === id);
  if (!cell) return;
  cell.code = cell.el.querySelector('textarea').value;
  cell.el.classList.add('stale');
  notifyDirty();

  if (S.autorun) {
    clearTimeout(S.editTimer);
    S.editTimer = setTimeout(() => runDAG([id], false), 400);
  }
}

function onCodeEdit(id) {
  const cell = S.cells.find(c => c.id === id);
  if (!cell) return;
  const ta = cell.el.querySelector('textarea');
  cell.code = ta.value;

  // update manual state
  if (isManual(cell.code)) {
    cell.el.classList.add('manual');
  } else {
    cell.el.classList.remove('manual');
  }

  cell.el.classList.add('stale');
  notifyDirty();

  if (S.autorun) {
    clearTimeout(S.editTimer);
    S.editTimer = setTimeout(() => runDAG([id], false), 400);
  }
}

// -- settings.js --

// ── SETTINGS ──

// Safe localStorage access — blob URL iframes have opaque origins where localStorage throws
function lsGet(key) { try { return localStorage.getItem(key); } catch { return null; } }
function lsSet(key, val) { try { localStorage.setItem(key, val); } catch {} }
function lsRemove(key) { try { localStorage.removeItem(key); } catch {} }

function toggleSettings() {
  const overlay = $('#settingsOverlay');
  const panel = $('#settingsPanel');
  const open = !overlay.classList.contains('visible');
  overlay.classList.toggle('visible');
  panel.style.display = open ? 'block' : 'none';
  if (open) refreshModuleList();
}

function applyTheme(theme) {
  if (theme === 'light') {
    document.documentElement.classList.add('light');
  } else {
    document.documentElement.classList.remove('light');
  }
  $('#setTheme').value = theme;
}

function applyFontSize(size) {
  size = parseInt(size);
  document.documentElement.style.setProperty('--editor-font-size', size + 'px');
  $('#setFontSize').value = size;
  $('#setFontSizeVal').textContent = size;
}

function applyWidth(w) {
  const nb = $('#notebook');
  nb.style.maxWidth = w;
  $('#setWidth').value = w;
}

function applyLineNumbers(show) {
  const on = show === true || show === 'true' || show === 'on';
  document.documentElement.classList.toggle('hide-line-numbers', !on);
  const el = $('#setLineNumbers');
  if (el) el.value = on ? 'on' : 'off';
}

function applyHeader(mode) {
  const root = document.documentElement;
  root.classList.remove('header-always', 'header-hover', 'header-compact');
  if (mode === 'always') root.classList.add('header-always');
  else if (mode === 'hover') root.classList.add('header-hover');
  else if (mode === 'compact') root.classList.add('header-compact');
  // 'auto' = no class, CSS media queries handle it
  $('#setHeader').value = mode;
}

// ── EXECUTION MODE ──

const __AUDITABLE_DEFAULT_EXEC_MODE__ = 'reactive';
const __AUDITABLE_DEFAULT_RUN_ON_LOAD__ = 'yes';

let _runOnLoad = 'yes';
let _showToggle = 'yes';

function applyExecMode(mode) {
  S.autorun = (mode === 'reactive');
  const btn = $('#autorunBtn');
  const btnMobile = document.getElementById('autorunBtnMobile');
  const cls = S.autorun ? 'autorun-on' : 'autorun-off';
  const text = S.autorun ? '\u25b6' : '\u2016';
  if (btn) { btn.textContent = text; btn.className = cls; btn.title = S.autorun ? 'reactive mode \u2014 cells auto-run on edit' : 'manual mode \u2014 only Run All or Ctrl+Enter'; }
  if (btnMobile) { btnMobile.textContent = text; btnMobile.className = cls; }
  const sel = $('#setExecMode');
  if (sel) sel.value = mode;
}

function applyRunOnLoad(val) {
  _runOnLoad = val;
  const sel = $('#setRunOnLoad');
  if (sel) sel.value = val;
}

function applyShowToggle(val) {
  _showToggle = val;
  document.documentElement.classList.toggle('hide-run-toggle', val === 'no');
  const sel = $('#setShowToggle');
  if (sel) sel.value = val;
}

function applyGlobalExecMode(val) {
  if (val) lsSet('auditable-exec-mode', val);
  else lsRemove('auditable-exec-mode');
}

function applyGlobalRunOnLoad(val) {
  if (val) lsSet('auditable-run-on-load', val);
  else lsRemove('auditable-run-on-load');
}

function resolveExecMode() {
  return lsGet('auditable-exec-mode')
    || $('#setExecMode')?.value
    || __AUDITABLE_DEFAULT_EXEC_MODE__;
}

function resolveRunOnLoad() {
  return lsGet('auditable-run-on-load')
    || _runOnLoad
    || __AUDITABLE_DEFAULT_RUN_ON_LOAD__;
}

function getSettings() {
  const s = {
    theme: document.documentElement.classList.contains('light') ? 'light' : 'dark',
    fontSize: parseInt($('#setFontSize').value),
    width: $('#setWidth').value,
    header: $('#setHeader').value,
    lineNumbers: document.documentElement.classList.contains('hide-line-numbers') ? 'off' : 'on',
    execMode: S.autorun ? 'reactive' : 'manual',
    runOnLoad: _runOnLoad,
    showToggle: _showToggle,
  };
  if (window._sizeCompare) s.sizeCompare = true;
  if (window._sizeCompareRef === 'content') s.sizeCompareRef = 'content';
  return s;
}

function applySettings(s) {
  if (!s) return;
  if (s.theme) applyTheme(s.theme);
  if (s.fontSize) applyFontSize(s.fontSize);
  if (s.width) applyWidth(s.width);
  if (s.header) applyHeader(s.header);
  if (s.lineNumbers) applyLineNumbers(s.lineNumbers);
  if (s.execMode) applyExecMode(s.execMode);
  if (s.runOnLoad) applyRunOnLoad(s.runOnLoad);
  if (s.showToggle) applyShowToggle(s.showToggle);
  // optional: size-compare.js (typeof guards for --lean builds without it)
  if (s.sizeCompare !== undefined && typeof applySizeCompare === 'function') applySizeCompare(s.sizeCompare);
  if (s.sizeCompareRef !== undefined && typeof applySizeCompareRef === 'function') applySizeCompareRef(s.sizeCompareRef);
}

function togglePresent() {
  document.body.classList.toggle('presenting');
}

// ── ABOUT ──

const __AUDITABLE_VERSION__ = '0.3.0';
const __AUDITABLE_RELEASE__ = 'dev';
const __AUDITABLE_BUILD_DATE__ = '2026-02-24';
const __AUDITABLE_BASE_SIZE__ = 254544;

(function() {
  const ver = $('#aboutVersion');
  const build = $('#aboutBuild');
  const rt = $('#aboutRuntime');
  if (ver) ver.textContent = 'auditable v' + __AUDITABLE_VERSION__;
  if (build) build.textContent = (__AUDITABLE_RELEASE__ !== 'dev' ? __AUDITABLE_RELEASE__ + ' \u00b7 ' : '') + 'built ' + __AUDITABLE_BUILD_DATE__;
  if (rt && __AUDITABLE_BASE_SIZE__ > 0) rt.textContent = 'runtime ' + (__AUDITABLE_BASE_SIZE__ / 1024).toFixed(1) + ' KB';
})();

// ── EXECUTION SETTINGS INIT ──

(function() {
  const gm = lsGet('auditable-exec-mode') || '';
  const gr = lsGet('auditable-run-on-load') || '';
  const selGm = $('#setGlobalExecMode');
  const selGr = $('#setGlobalRunOnLoad');
  if (selGm) selGm.value = gm;
  if (selGr) selGr.value = gr;
})();

// ── MODULE MANAGEMENT ──

function formatSize(bytes) {
  return (bytes / 1024).toFixed(1) + ' KB';
}

function renderEntryRow(url, entry) {
  const src = typeof entry === 'string' ? entry : entry.source;
  const cellId = typeof entry === 'string' ? null : entry.cellId;
  const isBinary = typeof entry === 'object' && entry.binary;
  const size = src ? src.length : 0;
  const displaySize = isBinary ? Math.floor(size * 3 / 4) : size;

  const row = document.createElement('div');
  row.className = 'module-row';

  const urlSpan = document.createElement('span');
  urlSpan.className = 'module-url';
  urlSpan.textContent = url;
  urlSpan.title = url;
  row.appendChild(urlSpan);

  const info = document.createElement('span');
  info.className = 'module-info';
  info.textContent = (cellId != null ? 'cell ' + cellId + '  ' : '')
    + (isBinary && entry.compressed ? 'gzipped  ' : '')
    + formatSize(displaySize);
  row.appendChild(info);

  const btn = document.createElement('button');
  btn.className = 'module-remove';
  btn.textContent = '\u00d7';
  btn.title = isBinary ? 'remove binary' : 'remove module';
  btn.onclick = () => removeModule(url);
  row.appendChild(btn);

  return { row, size };
}

function renderSection(list, urls, mods, emptyText) {
  list.innerHTML = '';
  if (urls.length === 0) {
    const empty = document.createElement('div');
    empty.className = 'module-empty';
    empty.textContent = emptyText;
    list.appendChild(empty);
    return 0;
  }
  let totalSize = 0;
  for (const url of urls) {
    const { row, size } = renderEntryRow(url, mods[url]);
    list.appendChild(row);
    totalSize += size;
  }
  const total = document.createElement('div');
  total.className = 'module-total';
  total.textContent = 'total  ' + formatSize(totalSize);
  list.appendChild(total);
  return totalSize;
}

function refreshModuleList() {
  const modList = $('#moduleList');
  const binList = $('#binaryList');
  if (!modList) return;

  const mods = window._installedModules || {};
  const modUrls = [];
  const binUrls = [];
  for (const url of Object.keys(mods)) {
    const entry = mods[url];
    if (typeof entry === 'object' && entry.binary) binUrls.push(url);
    else modUrls.push(url);
  }

  renderSection(modList, modUrls, mods, 'no modules installed');
  if (binList) renderSection(binList, binUrls, mods, 'no binaries installed');
}

function removeModule(url) {
  const entry = window._installedModules?.[url];
  const cellId = entry && typeof entry === 'object' ? entry.cellId : null;
  const kind = entry?.binary ? 'binary' : 'module';
  if (window._installedModules) delete window._installedModules[url];
  if (window._importCache) delete window._importCache[url];
  refreshModuleList();
  updateStatus();
  if (cellId != null) {
    setMsg(`removed ${kind} \u2014 cell ${cellId} will re-install it on next run`, 'warn');
  }
}

// -- update.js --

// ── UPDATE PANEL ──

function toggleUpdate() {
  const overlay = $('#updateOverlay');
  const panel = $('#updatePanel');
  const open = !overlay.classList.contains('visible');
  overlay.classList.toggle('visible');
  panel.style.display = open ? 'block' : 'none';
}

// ── SELF-UPDATE SYSTEM ──

const __AUDITABLE_PUBLIC_KEY__ = '';
const __AUDITABLE_REPO__ = 'endarthur/auditable';
const __AUDITABLE_PAGES_URL__ = 'https://endarthur.github.io/auditable';

// ── SIGNATURE EXTRACTION ──

function extractSignature(html) {
  const m = html.match(/<!--AUDITABLE-SIGNATURE\n([\s\S]*?)\nAUDITABLE-SIGNATURE-->/);
  if (!m) return null;
  try { return JSON.parse(m[1]); } catch { return null; }
}

// ── RUNTIME EXTRACTION ──

function extractRuntime(html) {
  const style = html.match(/<style>([\s\S]*?)<\/style>/);
  const script = html.match(/<script>([\s\S]*?)<\/script>/);
  if (!style || !script) return null;
  return { style: style[1], script: script[1] };
}

// ── DATA EXTRACTION ──

function extractData(html) {
  const data = html.match(/<!--AUDITABLE-DATA\n([\s\S]*?)\nAUDITABLE-DATA-->/);
  const settings = html.match(/<!--AUDITABLE-SETTINGS\n([\s\S]*?)\nAUDITABLE-SETTINGS-->/);
  const modules = html.match(/<!--AUDITABLE-MODULES\n([\s\S]*?)\nAUDITABLE-MODULES-->/);
  const title = html.match(/<title>([^<]*)<\/title>/);
  return {
    data: data ? data[0] : null,
    settings: settings ? settings[0] : null,
    modules: modules ? modules[0] : null,
    title: title ? title[1].replace(/^Auditable\s*\u2014\s*/, '') : 'untitled',
  };
}

// ── SIGNED CONTENT CONSTRUCTION ──

function buildSignedContent(style, script) {
  return 'AUDITABLE-SIGNED-CONTENT\n'
    + style + '\n'
    + 'AUDITABLE-STYLE-SCRIPT-BOUNDARY\n'
    + script;
}

// ── SIGNATURE VERIFICATION (Web Crypto) ──

async function verifySignature(html) {
  const sig = extractSignature(html);
  if (!sig) return { status: 'unsigned' };

  const pubKeyB64 = __AUDITABLE_PUBLIC_KEY__;
  if (!pubKeyB64) return { status: 'no-key', sig };

  // Check if the signature's public key matches ours
  if (sig.pub !== pubKeyB64) return { status: 'wrong-key', sig };

  const runtime = extractRuntime(html);
  if (!runtime) return { status: 'error', message: 'could not extract runtime' };

  const content = buildSignedContent(runtime.style, runtime.script);

  try {
    const pubBytes = Uint8Array.from(atob(pubKeyB64), c => c.charCodeAt(0));
    const key = await crypto.subtle.importKey(
      'raw', pubBytes, { name: 'Ed25519' }, false, ['verify']
    );
    const sigBytes = Uint8Array.from(atob(sig.sig), c => c.charCodeAt(0));
    const msgBytes = new TextEncoder().encode(content);
    const valid = await crypto.subtle.verify('Ed25519', key, sigBytes, msgBytes);
    return { status: valid ? 'valid' : 'invalid', sig };
  } catch (e) {
    if (e.name === 'NotSupportedError') {
      return { status: 'unsupported', message: 'browser does not support Ed25519 verification' };
    }
    return { status: 'error', message: e.message };
  }
}

// ── REASSEMBLE ──

function reassemble(newHtml, oldData) {
  let html = newHtml;

  // Remove any existing data/settings/modules comments (and their description comments) from the new template
  html = html.replace(/(?:<!-- [^\n]*-->\n)?<!--AUDITABLE-DATA\n[\s\S]*?\nAUDITABLE-DATA-->\n?/g, '');
  html = html.replace(/(?:<!-- [^\n]*-->\n)?<!--AUDITABLE-SETTINGS\n[\s\S]*?\nAUDITABLE-SETTINGS-->\n?/g, '');
  html = html.replace(/(?:<!-- [^\n]*-->\n)?<!--AUDITABLE-MODULES\n[\s\S]*?\nAUDITABLE-MODULES-->\n?/g, '');

  // Build data block to inject
  const parts = [];
  if (oldData.data) parts.push(oldData.data);
  if (oldData.modules) parts.push(oldData.modules);
  if (oldData.settings) parts.push(oldData.settings);
  const dataBlock = parts.length ? '\n' + parts.join('\n') + '\n' : '';

  // Inject before the signature comment or before <script>
  const sigIdx = html.indexOf('<!--AUDITABLE-SIGNATURE');
  const scriptIdx = html.indexOf('<script>');
  const insertIdx = sigIdx >= 0 ? sigIdx : scriptIdx;
  if (insertIdx >= 0) {
    html = html.slice(0, insertIdx) + dataBlock + html.slice(insertIdx);
  }

  // Update title
  if (oldData.title && oldData.title !== 'untitled') {
    html = html.replace(/<title>[^<]*<\/title>/, '<title>Auditable \u2014 ' + escHtml(oldData.title) + '</title>');
    // Also update the docTitle input value
    html = html.replace(/(<input[^>]*id="docTitle"[^>]*value=")[^"]*"/, '$1' + escHtml(oldData.title) + '"');
  }

  return html;
}

function escHtml(s) {
  return s.replace(/&/g, '&amp;').replace(/"/g, '&quot;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
}

// ── VERSION COMPARISON ──

function compareVersions(a, b) {
  // compare semver strings like "0.1.0" vs "0.2.0"
  const pa = a.replace(/^v/, '').split('.').map(Number);
  const pb = b.replace(/^v/, '').split('.').map(Number);
  for (let i = 0; i < Math.max(pa.length, pb.length); i++) {
    const na = pa[i] || 0, nb = pb[i] || 0;
    if (na < nb) return -1;
    if (na > nb) return 1;
  }
  return 0;
}

// ── TOOLBAR BADGES ──

function setBadge(id, label, cls) {
  const container = $('#toolbarBadges');
  if (!container) return;
  let el = container.querySelector('[data-badge="' + id + '"]');
  if (!label) {
    if (el) el.remove();
    return;
  }
  if (!el) {
    el = document.createElement('span');
    el.className = 'toolbar-badge toolbar-badge-' + id;
    el.setAttribute('data-badge', id);
    container.appendChild(el);
  }
  el.textContent = label;
  if (cls) el.className = 'toolbar-badge ' + cls;
}

// ── UPDATE STATUS UI ──

function setUpdateStatus(html, cls) {
  const el = $('#updateStatus');
  if (el) {
    el.innerHTML = html;
    el.className = 'update-status' + (cls ? ' update-' + cls : '');
  }
}

// ── CHECK FOR UPDATE (GitHub API) ──

async function checkForUpdate() {
  const btn = $('#updateCheckBtn');
  if (btn) btn.disabled = true;
  setUpdateStatus('checking...', '');

  try {
    // Fetch version.json from GitHub Pages (CORS-friendly)
    const vResp = await fetch(__AUDITABLE_PAGES_URL__ + '/version.json');
    if (!vResp.ok) throw new Error('version check failed: ' + vResp.status);
    const vData = await vResp.json();
    const remoteVersion = vData.version || '';
    const currentRelease = $('#updateRelease')?.textContent || 'dev';

    if (currentRelease === 'dev') {
      // Dev builds always offer the latest release
    } else if (compareVersions(currentRelease, remoteVersion) >= 0) {
      setUpdateStatus('up to date (' + currentRelease + ')', 'ok');
      if (btn) btn.disabled = false;
      return;
    }

    const notes = vData.notes || '';
    const notesHtml = notes
      ? '<div class="update-notes">' + renderMd(notes) + '</div>'
      : '';

    setUpdateStatus(
      '<strong>' + remoteVersion + '</strong> available'
      + notesHtml
      + '<button id="updateApplyBtn" onclick="applyOnlineUpdate()">update</button>',
      'available'
    );

    window._updateVersion = remoteVersion;
  } catch (e) {
    setUpdateStatus('error: ' + escHtml(e.message), 'err');
  }
  if (btn) btn.disabled = false;
}

// ── APPLY ONLINE UPDATE ──

async function applyOnlineUpdate() {
  setUpdateStatus('downloading...', '');

  try {
    // Download signed build from GitHub Pages (CORS-friendly)
    const resp = await fetch(__AUDITABLE_PAGES_URL__ + '/auditable.html');
    if (!resp.ok) throw new Error('download failed: ' + resp.status);
    const newHtml = await resp.text();
    await applyUpdate(newHtml, window._updateVersion);
  } catch (e) {
    setUpdateStatus('error: ' + escHtml(e.message), 'err');
  }
}

// ── APPLY UPDATE (verify + reassemble + download) ──

async function applyUpdate(newHtml, version) {
  setUpdateStatus('verifying signature...', '');

  const result = await verifySignature(newHtml);

  if (result.status === 'invalid') {
    setUpdateStatus('signature verification FAILED \u2014 update rejected', 'err');
    return;
  }

  const warnMessages = {
    'unsigned': 'this file is not signed',
    'no-key': 'no public key configured \u2014 cannot verify signature',
    'wrong-key': 'signed with an unknown key',
  };
  if (warnMessages[result.status]) {
    setUpdateStatus(
      'warning: ' + warnMessages[result.status]
      + '<div class="update-confirm">'
      + '<button onclick="proceedUpdate()">proceed anyway</button>'
      + '<button onclick="cancelUpdate()">cancel</button>'
      + '</div>',
      'warn'
    );
    window._pendingUpdateHtml = newHtml;
    window._pendingUpdateVersion = version;
    return;
  }

  if (result.status === 'unsupported') {
    setUpdateStatus(
      result.message
      + '<div class="update-confirm">'
      + '<button onclick="proceedUpdate()">proceed without verification</button>'
      + '<button onclick="cancelUpdate()">cancel</button>'
      + '</div>',
      'warn'
    );
    window._pendingUpdateHtml = newHtml;
    window._pendingUpdateVersion = version;
    return;
  }

  if (result.status === 'error') {
    setUpdateStatus('verification error: ' + escHtml(result.message), 'err');
    return;
  }

  // Valid signature — proceed
  finishUpdate(newHtml, version);
}

function proceedUpdate() {
  if (window._pendingUpdateHtml) {
    finishUpdate(window._pendingUpdateHtml, window._pendingUpdateVersion);
    delete window._pendingUpdateHtml;
    delete window._pendingUpdateVersion;
  }
}

function cancelUpdate() {
  delete window._pendingUpdateHtml;
  delete window._pendingUpdateVersion;
  setUpdateStatus('update cancelled', '');
}

function finishUpdate(newHtml, version) {
  setUpdateStatus('reassembling...', '');

  // Extract current document as HTML to get data comments
  const currentHtml = document.documentElement.outerHTML;
  // But the data comments are in the body innerHTML at load time; grab from live source
  const bodyHtml = document.body.innerHTML;
  const fullHtml = '<!DOCTYPE html>\n<html>' + document.head.outerHTML + '<body>' + bodyHtml + '</body></html>';

  const oldData = extractData(fullHtml);
  // Override title from live doc
  const titleInput = $('#docTitle');
  if (titleInput) oldData.title = titleInput.value || 'untitled';

  // Build fresh data comments from live state (more reliable than regex from DOM)
  if (S.cells.length) {
    const cellData = S.cells.map(c => ({
      type: c.type,
      code: c.code,
      collapsed: c.el?.classList.contains('collapsed') || undefined
    }));
    oldData.data = '<!-- cell data: JSON array of {type, code, collapsed?} -->\n<!--AUDITABLE-DATA\n' + JSON.stringify(cellData) + '\nAUDITABLE-DATA-->';
  }
  if (window._installedModules && Object.keys(window._installedModules).length) {
    oldData.modules = '<!-- installed modules: base64-encoded JSON mapping URLs to {source, cellId} -->\n<!--AUDITABLE-MODULES\n' + encodeModules(window._installedModules) + '\nAUDITABLE-MODULES-->';
  }
  oldData.settings = '<!-- notebook settings: JSON {theme, fontSize, width, ...} -->\n<!--AUDITABLE-SETTINGS\n' + JSON.stringify(getSettings()) + '\nAUDITABLE-SETTINGS-->';

  const result = reassemble(newHtml, oldData);

  // Offer as download
  const title = (titleInput ? titleInput.value : 'untitled') || 'untitled';
  const blob = new Blob([result], { type: 'text/html' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = title.replace(/[^a-zA-Z0-9_-]/g, '_') + '.html';
  a.click();
  URL.revokeObjectURL(url);

  const vLabel = version ? ' to ' + version : '';
  setUpdateStatus('updated' + vLabel + ' \u2014 saved as ' + a.download, 'ok');
  setMsg('updated' + vLabel, 'ok');
}

// ── UPDATE FROM FILE ──

function updateFromFile() {
  const input = document.createElement('input');
  input.type = 'file';
  input.accept = '.html';
  input.onchange = async () => {
    const file = input.files[0];
    if (!file) return;
    setUpdateStatus('reading file...', '');
    const text = await file.text();

    // Try to extract version from the file
    const vMatch = text.match(/__AUDITABLE_VERSION__\s*=\s*'([^']+)'/);
    const version = vMatch ? 'v' + vMatch[1] : null;

    await applyUpdate(text, version);
  };
  input.click();
}

// ── VERIFY CURRENT DOCUMENT ──

async function verifySelf() {
  const el = $('#updateSigStatus');
  if (!el) return;

  // Reconstruct from live DOM
  const styleEl = document.querySelector('style');
  const scriptEl = document.querySelector('script');
  if (!styleEl || !scriptEl) {
    el.textContent = 'error: no style/script';
    el.className = 'update-sig update-err';
    return;
  }

  const raw = document.body.innerHTML;
  const sigMatch = raw.match(/<!--AUDITABLE-SIGNATURE\n([\s\S]*?)\nAUDITABLE-SIGNATURE-->/);
  if (!sigMatch) {
    el.textContent = 'unsigned';
    el.className = 'update-sig update-warn';
    return;
  }

  let sig;
  try { sig = JSON.parse(sigMatch[1]); } catch {
    el.textContent = 'invalid signature format';
    el.className = 'update-sig update-err';
    return;
  }

  const pubKeyB64 = __AUDITABLE_PUBLIC_KEY__;
  if (!pubKeyB64) {
    el.textContent = 'no public key configured';
    el.className = 'update-sig update-warn';
    return;
  }

  if (sig.pub !== pubKeyB64) {
    el.textContent = 'signed with unknown key';
    el.className = 'update-sig update-warn';
    return;
  }

  const content = buildSignedContent(styleEl.textContent, scriptEl.textContent);

  try {
    const pubBytes = Uint8Array.from(atob(pubKeyB64), c => c.charCodeAt(0));
    const key = await crypto.subtle.importKey(
      'raw', pubBytes, { name: 'Ed25519' }, false, ['verify']
    );
    const sigBytes = Uint8Array.from(atob(sig.sig), c => c.charCodeAt(0));
    const msgBytes = new TextEncoder().encode(content);
    const valid = await crypto.subtle.verify('Ed25519', key, sigBytes, msgBytes);
    if (valid) {
      el.textContent = 'signed \u2713';
      el.className = 'update-sig update-ok';
      setBadge('signed', 'signed', 'toolbar-badge toolbar-badge-signed');
    } else {
      el.textContent = 'signature invalid';
      el.className = 'update-sig update-err';
    }
  } catch (e) {
    if (e.name === 'NotSupportedError') {
      el.textContent = 'Ed25519 not supported';
      el.className = 'update-sig update-warn';
    } else {
      el.textContent = 'error: ' + e.message;
      el.className = 'update-sig update-err';
    }
  }
}

// ── INIT ──
(function() {
  const ver = $('#updateCurrentVer');
  if (ver) ver.textContent = 'v' + __AUDITABLE_VERSION__;
  const rel = $('#updateRelease');
  if (rel) {
    rel.textContent = __AUDITABLE_RELEASE__;
    if (__AUDITABLE_RELEASE__ === 'dev') rel.className = 'update-sig update-warn';
  }
  // Show public key status
  const keyEl = $('#updatePubKey');
  if (keyEl) {
    if (__AUDITABLE_PUBLIC_KEY__) {
      keyEl.textContent = __AUDITABLE_PUBLIC_KEY__.slice(0, 8) + '...';
      keyEl.className = 'update-sig update-key-truncated';
      keyEl.onclick = () => {
        if (keyEl.classList.contains('update-key-expanded')) {
          keyEl.textContent = __AUDITABLE_PUBLIC_KEY__.slice(0, 8) + '...';
          keyEl.classList.remove('update-key-expanded');
          keyEl.classList.add('update-key-truncated');
        } else {
          keyEl.textContent = __AUDITABLE_PUBLIC_KEY__;
          keyEl.classList.remove('update-key-truncated');
          keyEl.classList.add('update-key-expanded');
        }
      };
    } else {
      keyEl.textContent = 'not configured';
      keyEl.className = 'update-sig update-warn';
    }
  }
  // Run self-verification on load
  verifySelf();
})();

// -- save.js --

// ── MODULES ENCODING ──
// base64-encode modules JSON to avoid HTML comment / String.replace issues
// (source code can contain --, $', etc.)

function encodeModules(obj) {
  const b64 = btoa(unescape(encodeURIComponent(JSON.stringify(obj))));
  return b64.replace(/.{1,76}/g, '$&\n').trimEnd();
}

function decodeModules(raw) {
  const b64 = raw.replace(/\s/g, '');
  // detect legacy format: starts with { means raw JSON (not base64)
  if (b64.startsWith('{') || b64.startsWith('%7B')) return JSON.parse(raw);
  return JSON.parse(decodeURIComponent(escape(atob(b64))));
}

// ── SAVE / LOAD ──

// save mode: 'normal' or 'packed'
let _saveMode = 'normal';

function getSaveMode() { return _saveMode; }

function toggleSaveTray() {
  const tray = $('#saveTray');
  if (tray) tray.classList.toggle('open');
}

function setSaveMode(mode) {
  _saveMode = mode;
  // update UI
  const label = $('#saveLabel');
  if (label) label.textContent = mode === 'packed' ? 'pack' : 'save';
  const tray = $('#saveTray');
  if (tray) tray.classList.remove('open');
  // update mobile buttons
  const mobSave = $('#mobileSaveBtn');
  const mobPack = $('#mobilePackBtn');
  if (mobSave) mobSave.classList.toggle('active-mode', mode === 'normal');
  if (mobPack) mobPack.classList.toggle('active-mode', mode === 'packed');
}

function buildNotebookHtml() {
  // serialize current state back to a self-contained HTML file
  const title = $('#docTitle').value || 'untitled';

  // collect cells as data
  const cellData = S.cells.map(c => ({
    type: c.type,
    code: c.code,
    collapsed: c.el.classList.contains('collapsed') || undefined
  }));

  // get the runtime and styles from current document
  const styleEl = document.querySelector('style');
  const styles = styleEl.textContent;

  // get the script
  const scriptEl = document.querySelector('script');
  const script = scriptEl.textContent;

  // read static elements from live DOM
  const helpHTML = $('#helpOverlay').outerHTML;
  const settingsOvHTML = $('#settingsOverlay').outerHTML;
  const settingsPanHTML = $('#settingsPanel').outerHTML.replace(/display:\s*block;?/, '');
  const updateOvHTML = $('#updateOverlay').outerHTML.replace(/\bvisible\b/, '').replace(/class="\s*"/, 'class=""');
  const updatePanEl = $('#updatePanel').cloneNode(true);
  updatePanEl.style.display = '';
  // reset update status and dynamic text
  const uStatus = updatePanEl.querySelector('#updateStatus');
  if (uStatus) { uStatus.innerHTML = ''; uStatus.className = 'update-status'; }
  const updatePanHTML = updatePanEl.outerHTML.replace(/display:\s*block;?/, '');
  const statusbarHTML = document.querySelector('.statusbar').outerHTML;

  // read toolbar from live DOM and patch the title value
  const toolbarEl = document.querySelector('.toolbar').cloneNode(true);
  toolbarEl.querySelector('#docTitle').value = title;
  toolbarEl.querySelector('#toolbarStatus').textContent = '';
  // reset autorun button state to match saved mode
  const autoBtn = toolbarEl.querySelector('#autorunBtn');
  const savedMode = S.autorun ? 'reactive' : 'manual';
  if (autoBtn) {
    autoBtn.className = savedMode === 'reactive' ? 'autorun-on' : 'autorun-off';
    autoBtn.textContent = savedMode === 'reactive' ? '\u25b6' : '\u2016';
  }
  // close overflow and save tray if open
  const overflow = toolbarEl.querySelector('.toolbar-overflow');
  if (overflow) overflow.classList.remove('open');
  const saveTray = toolbarEl.querySelector('#saveTray');
  if (saveTray) saveTray.classList.remove('open');
  // reset save label to default
  const saveLabel = toolbarEl.querySelector('#saveLabel');
  if (saveLabel) saveLabel.textContent = 'save';
  // clear badges (they get set dynamically on load)
  const badges = toolbarEl.querySelector('.toolbar-badges');
  if (badges) badges.innerHTML = '';
  const toolbarHTML = toolbarEl.outerHTML;

  // capture find bar and reset to default state
  const findBarEl = $('#findBar').cloneNode(true);
  findBarEl.style.display = '';
  findBarEl.classList.remove('show-replace');
  findBarEl.querySelector('#findInput').value = '';
  findBarEl.querySelector('#replaceInput').value = '';
  findBarEl.querySelector('#findCount').textContent = '';
  findBarEl.querySelector('#findCaseBtn').classList.remove('active');
  findBarEl.querySelector('#findRegexBtn').classList.remove('active');
  const findBarHTML = findBarEl.outerHTML;

  // build output HTML
  return `<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Auditable \u2014 ${esc(title)}</title>
<style>\n${styles}\n</style>
</head>
<body>

${helpHTML}

${settingsOvHTML}
${settingsPanHTML}

${updateOvHTML}
${updatePanHTML}

${toolbarHTML}

${findBarHTML}

<button class="present-exit" onclick="togglePresent()">\u2715 exit</button>

<div class="notebook" id="notebook">
</div>

${statusbarHTML}

${'<!-- cell data: JSON array of {type, code, collapsed?} -->\n<!--AUDITABLE-DATA\n' + JSON.stringify(cellData) + '\nAUDITABLE-DATA-->'}
${Object.keys(window._installedModules || {}).length ? '<!-- installed modules: base64-encoded JSON mapping URLs to {source, cellId} -->\n<!--AUDITABLE-MODULES\n' + encodeModules(window._installedModules) + '\nAUDITABLE-MODULES-->' : ''}
${'<!-- notebook settings: JSON {theme, fontSize, width, ...} -->\n<!--AUDITABLE-SETTINGS\n' + JSON.stringify(getSettings()) + '\nAUDITABLE-SETTINGS-->'}

<script>\n${script}\n<\/script>
</body>
</html>`;
}

function downloadHtml(html, title) {
  const blob = new Blob([html], { type: 'text/html' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = title.replace(/[^a-zA-Z0-9_-]/g, '_') + '.html';
  a.click();
  URL.revokeObjectURL(url);
  return a.download;
}

function saveNotebook() {
  if (_saveMode === 'packed') {
    savePackedNotebook();
    return;
  }
  const title = $('#docTitle').value || 'untitled';
  const html = buildNotebookHtml();

  // AF bridge: send serialized HTML to parent shell instead of downloading
  if (window.__AF_BRIDGE__) {
    window.parent.postMessage({ type: 'af:serialized', payload: { html } }, '*');
    setMsg('saved', 'ok');
    return;
  }

  const fn = downloadHtml(html, title);
  setMsg('saved ' + fn, 'ok');
}

async function savePackedNotebook() {
  const title = $('#docTitle').value || 'untitled';
  const html = buildNotebookHtml();

  try {
    // compress via CompressionStream
    const blob = new Blob([html]);
    const cs = new CompressionStream('gzip');
    const stream = blob.stream().pipeThrough(cs);
    const compressed = await new Response(stream).arrayBuffer();
    const b64 = btoa(String.fromCharCode(...new Uint8Array(compressed)));
    const b64Lines = b64.replace(/.{1,76}/g, '$&\n');

    const loader = `<!DOCTYPE html>
<!-- packed auditable notebook -->
<!-- the full notebook is gzip-compressed and base64-encoded in the <pre> block below. -->
<!-- on load, the script decodes and decompresses it, then replaces the page contents. -->
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Auditable \u2014 ${esc(title)}</title>
  <style>
    html { background: #1a1a1a }
    body { color: #999; font: 14px/1.5 monospace; display: flex; justify-content: center; align-items: center; height: 100vh; margin: 0 }
    #_d { display: none }
  </style>
</head>
<body>
<div id="_l">unpacking\u2026</div>

<!-- base64-encoded gzip payload (76-char lines) -->
<pre id="_d">
${b64Lines}</pre>

<script>
(async () => {
  // 1. read base64 from the hidden <pre>, strip whitespace from line wrapping
  var b64 = document.getElementById('_d').textContent.replace(/\\s/g, '');

  // 2. decode base64 to binary
  var bytes = Uint8Array.from(atob(b64), c => c.charCodeAt(0));

  // 3. decompress gzip via DecompressionStream
  var stream = new Response(new Blob([bytes])).body.pipeThrough(new DecompressionStream('gzip'));
  var html = await new Response(stream).text();

  // 4. mark as packed (so the notebook knows it was loaded from a packed save)
  html = html.replace('<head>', '<head><meta name="auditable-packed">');

  // 5. replace the current page with the full notebook
  document.open();
  document.write(html);
  document.close();
})().catch(function(e) {
  document.getElementById('_l').textContent = 'error: ' + e.message;
});
<\/script>
</body>
</html>`;


    const fn = downloadHtml(loader, title);
    const kb = (loader.length / 1024).toFixed(0);
    setMsg('packed ' + fn + ' (' + kb + ' KB)', 'ok');
  } catch (e) {
    setMsg('pack failed: ' + e.message, 'err');
  }
}

function esc(s) {
  return s.replace(/"/g, '&quot;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
}

function exportAsTxt() {
  const title = $('#docTitle').value || 'untitled';
  const html = buildNotebookHtml();

  // extract notebook data from HTML
  const dataMatch = html.match(/<!--AUDITABLE-DATA\n([\s\S]*?)\nAUDITABLE-DATA-->/);
  let cells = [];
  if (dataMatch) {
    try { cells = JSON.parse(dataMatch[1]); } catch {}
  }

  const setMatch = html.match(/<!--AUDITABLE-SETTINGS\n([\s\S]*?)\nAUDITABLE-SETTINGS-->/);
  let settings = {};
  if (setMatch) {
    try { settings = JSON.parse(setMatch[1]); } catch {}
  }

  // extract module URLs (without sources — standalone export just records URLs)
  const modMatch = html.match(/<!--AUDITABLE-MODULES\n([\s\S]*?)\nAUDITABLE-MODULES-->/);
  let moduleUrls = [];
  if (modMatch) {
    try {
      const decoded = decodeModules(modMatch[1]);
      moduleUrls = Object.keys(decoded);
    } catch {}
  }

  // build /// formatted text
  const lines = ['/// auditable'];
  if (title && title !== 'untitled') {
    lines.push('/// title: ' + title);
  }
  const defaultSettings = { theme: 'dark', fontSize: 13, width: '860' };
  if (JSON.stringify(settings) !== JSON.stringify(defaultSettings)) {
    lines.push('/// settings: ' + JSON.stringify(settings));
  }
  for (const url of moduleUrls) {
    lines.push('/// module: ' + url);
  }
  for (const cell of cells) {
    lines.push('');
    const flags = cell.collapsed ? ' collapsed' : '';
    lines.push('/// ' + cell.type + flags);
    lines.push(cell.code || '');
  }
  const txt = lines.join('\n') + '\n';

  // download
  if (window.__AF_BRIDGE__) {
    window.parent.postMessage({ type: 'af:download', payload: { data: txt, filename: title.replace(/[^a-zA-Z0-9_-]/g, '_') + '.txt', mime: 'text/plain' } }, '*');
  } else {
    const blob = new Blob([txt], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = title.replace(/[^a-zA-Z0-9_-]/g, '_') + '.txt';
    a.click();
    URL.revokeObjectURL(url);
  }
  setMsg('exported .txt', 'ok');
}

function loadFromEmbed() {
  // look for embedded cell data in HTML comments
  const raw = document.body.innerHTML;

  // restore installed modules first (before cells run)
  const modMatch = raw.match(/<!--AUDITABLE-MODULES\n([\s\S]*?)\nAUDITABLE-MODULES-->/);
  if (modMatch) {
    try {
      window._installedModules = decodeModules(modMatch[1]);
    } catch (e) {
      console.error('Failed to parse installed modules:', e);
    }
  }

  // restore settings
  const setMatch = raw.match(/<!--AUDITABLE-SETTINGS\n([\s\S]*?)\nAUDITABLE-SETTINGS-->/);
  if (setMatch) {
    try {
      applySettings(JSON.parse(setMatch[1]));
    } catch (e) {
      console.error('Failed to parse settings:', e);
    }
  }

  // apply execution mode priority chain (localStorage > notebook > build default)
  const effectiveMode = resolveExecMode();
  const effectiveRun = resolveRunOnLoad();
  if (effectiveMode === 'manual') {
    S.autorun = false;
    const btn = document.getElementById('autorunBtn');
    const btnMobile = document.getElementById('autorunBtnMobile');
    if (btn) { btn.className = 'autorun-off'; btn.textContent = '\u2016'; btn.title = 'manual mode \u2014 only Run All or Ctrl+Enter'; }
    if (btnMobile) { btnMobile.className = 'autorun-off'; btnMobile.textContent = '\u2016'; }
    const sel = document.getElementById('setExecMode');
    if (sel) sel.value = 'manual';
  }

  const match = raw.match(/<!--AUDITABLE-DATA\n([\s\S]*?)\nAUDITABLE-DATA-->/);
  if (match) {
    try {
      const data = JSON.parse(match[1]);
      for (const c of data) {
        const cell = addCell(c.type, c.code);
        if (c.collapsed || isCollapsed(c.code)) cell.el.classList.add('collapsed');
      }
      // run after load (gated on resolved runOnLoad)
      if (effectiveRun === 'yes' && S.cells.some(c => c.type === 'code')) {
        setTimeout(runAll, 50);
      }
      return true;
    } catch (e) {
      console.error('Failed to parse embedded data:', e);
    }
  }
  return false;
}

// -- ui.js --

// ── STATUS ──

function estimateContentSize() {
  let modules = 0;
  for (const v of Object.values(window._installedModules || {})) {
    modules += typeof v === 'string' ? v.length : (v.source?.length || 0);
  }
  const cells = JSON.stringify(S.cells.map(c => ({ type: c.type, code: c.code }))).length;
  return modules + cells;
}

function estimateFileSize() {
  const style = document.querySelector('style')?.textContent.length || 0;
  const script = document.querySelector('script')?.textContent.length || 0;
  return style + script + estimateContentSize() + 2000; // ~2KB HTML boilerplate
}

function updateStatus() {
  const counts = { code: 0, md: 0, css: 0, html: 0 };
  for (const c of S.cells) if (counts[c.type] !== undefined) counts[c.type]++;
  const parts = [];
  for (const [t, n] of Object.entries(counts)) if (n > 0) parts.push(`${n} ${t}`);
  const statusText = parts.join(' \u00b7 ') || '0 cells';
  const totalBytes = estimateFileSize();
  const contentBytes = estimateContentSize();
  const useContent = window._sizeCompareRef === 'content';
  const displayBytes = useContent ? contentBytes : totalBytes;
  const sizeKB = displayBytes >= 1024 ? Math.round(displayBytes / 1024) : 1;
  const sizeText = '~' + sizeKB + ' KB' + (useContent ? ' content' : '');
  $('#statusCells').textContent = statusText;
  const compare = typeof sizeCompare === 'function' ? sizeCompare(displayBytes) : '';
  const sizeEl = document.getElementById('statusSize');
  if (sizeEl) sizeEl.textContent = (compare ? sizeText + ' \u00b7 ' + compare : sizeText) + ' \u00b7 ';
  // mirror to toolbar for mobile
  const toolbarStatus = document.getElementById('toolbarStatus');
  if (toolbarStatus) toolbarStatus.textContent = (compare || sizeText) + ' \u00b7 ' + statusText;
  updateInsertBars();
}

function updateInsertBars() {
  const nb = $('#notebook');
  // remove existing insert bars
  nb.querySelectorAll('.insert-bar').forEach(b => b.remove());

  // add one before first cell and between each pair
  for (let i = 0; i <= S.cells.length; i++) {
    const bar = document.createElement('div');
    bar.className = 'insert-bar';
    const afterId = i > 0 ? S.cells[i - 1].id : null;
    bar.innerHTML = `<div class="insert-btns">
      <button onclick="insertAt(${afterId},'code')">+ code</button>
      <button onclick="insertAt(${afterId},'md')">+ md</button>
      <button onclick="insertAt(${afterId},'css')">+ css</button>
      <button onclick="insertAt(${afterId},'html')">+ html</button>
    </div>`;
    if (i < S.cells.length) {
      S.cells[i].el.before(bar);
    } else {
      nb.appendChild(bar);
    }
  }
}

function insertAt(afterId, type) {
  let cell;
  if (afterId === null && S.cells.length > 0) {
    // insert before first cell
    cell = addCellWithUndo(type, '', null, S.cells[0].id);
  } else {
    cell = addCellWithUndo(type, '', afterId);
  }
  selectCell(cell.id);
  editCell(cell.id);
}

function setMsg(msg, cls = '') {
  const el = $('#statusMsg');
  el.textContent = msg;
  el.className = 'status-msg' + (cls ? ' ' + cls : '');
  if (cls) setTimeout(() => { el.textContent = ''; el.className = 'status-msg'; }, 3000);
}

// -- find.js --

// ── FIND / REPLACE ──

function openFind(showReplace) {
  const bar = $('#findBar');
  bar.style.display = 'flex';
  S.findActive = true;
  if (showReplace) bar.classList.add('show-replace');
  else bar.classList.remove('show-replace');
  const inp = $('#findInput');
  // pre-fill from textarea selection
  const active = document.activeElement;
  if (active && active.tagName === 'TEXTAREA') {
    const sel = active.value.substring(active.selectionStart, active.selectionEnd);
    if (sel && sel.indexOf('\n') === -1) inp.value = sel;
  }
  inp.focus();
  inp.select();
  if (inp.value) findComputeMatches();
}

function closeFind() {
  const bar = $('#findBar');
  bar.style.display = '';
  bar.classList.remove('show-replace');
  S.findActive = false;
  S.findQuery = '';
  S.findMatches = [];
  S.findCurrent = -1;
  $('#findCount').textContent = '';
  // remove all overlays
  document.querySelectorAll('.search-overlay').forEach(el => el.remove());
  document.querySelectorAll('.md-search-wrap').forEach(wrap => {
    const ta = wrap.querySelector('textarea');
    if (ta) wrap.parentNode.insertBefore(ta, wrap);
    wrap.remove();
  });
}

function escapeRegex(s) {
  return s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

function findComputeMatches() {
  const query = $('#findInput').value;
  S.findQuery = query;
  S.findMatches = [];
  if (!query) {
    S.findCurrent = -1;
    findUpdateCount();
    document.querySelectorAll('.search-overlay').forEach(el => el.remove());
    document.querySelectorAll('.md-search-wrap').forEach(wrap => {
      const ta = wrap.querySelector('textarea');
      if (ta) wrap.parentNode.insertBefore(ta, wrap);
      wrap.remove();
    });
    return;
  }
  const flags = S.findCase ? 'g' : 'gi';
  const pattern = S.findRegex ? query : escapeRegex(query);
  let re;
  try { re = new RegExp(pattern, flags); }
  catch (e) {
    S.findCurrent = -1;
    $('#findCount').textContent = 'bad regex';
    return;
  }

  for (const cell of S.cells) {
    let m;
    re.lastIndex = 0;
    while ((m = re.exec(cell.code)) !== null) {
      S.findMatches.push({ cellId: cell.id, index: m.index, length: m[0].length });
      if (m[0].length === 0) re.lastIndex++;  // prevent infinite loop on zero-length match
    }
  }
  // keep findCurrent in range
  if (S.findMatches.length === 0) S.findCurrent = -1;
  else if (S.findCurrent < 0 || S.findCurrent >= S.findMatches.length) S.findCurrent = 0;
  findUpdateOverlays();
  findUpdateCount();
}

function findNext() {
  if (!S.findMatches.length) return;
  S.findCurrent = (S.findCurrent + 1) % S.findMatches.length;
  findUpdateOverlays();
  findUpdateCount();
  findScrollToMatch();
}

function findPrev() {
  if (!S.findMatches.length) return;
  S.findCurrent = (S.findCurrent - 1 + S.findMatches.length) % S.findMatches.length;
  findUpdateOverlays();
  findUpdateCount();
  findScrollToMatch();
}

function findReplace() {
  if (S.findCurrent < 0 || S.findCurrent >= S.findMatches.length) return;
  const match = S.findMatches[S.findCurrent];
  const cell = S.cells.find(c => c.id === match.cellId);
  if (!cell) return;
  const replaceVal = $('#replaceInput').value;
  if (S.findRegex) {
    const flags = S.findCase ? '' : 'i';
    try {
      const re = new RegExp(S.findQuery, flags);
      const matched = cell.code.substring(match.index, match.index + match.length);
      const replaced = matched.replace(re, replaceVal);
      cell.code = cell.code.substring(0, match.index) + replaced + cell.code.substring(match.index + match.length);
    } catch (e) { return; }
  } else {
    cell.code = cell.code.substring(0, match.index) + replaceVal + cell.code.substring(match.index + match.length);
  }
  // update textarea
  const ta = cell.el.querySelector('textarea');
  if (ta) {
    ta.value = cell.code;
    ta.dispatchEvent(new Event('input'));
  }
  findComputeMatches();
}

function findReplaceAll() {
  const query = S.findQuery;
  if (!query) return;
  const replaceVal = $('#replaceInput').value;
  const flags = S.findCase ? 'g' : 'gi';
  const pattern = S.findRegex ? query : escapeRegex(query);
  let re;
  try { re = new RegExp(pattern, flags); }
  catch (e) { return; }
  let count = 0;
  for (const cell of S.cells) {
    const before = cell.code;
    if (S.findRegex) {
      cell.code = cell.code.replace(re, (...args) => { count++; return replaceVal.replace(/\$(\d+)/g, (_, n) => args[+n] != null ? args[+n] : ''); });
    } else {
      cell.code = cell.code.replace(re, () => { count++; return replaceVal; });
    }
    if (cell.code !== before) {
      const ta = cell.el.querySelector('textarea');
      if (ta) {
        ta.value = cell.code;
        ta.dispatchEvent(new Event('input'));
      }
    }
  }
  findComputeMatches();
}

function findUpdateOverlays() {
  // remove existing overlays
  document.querySelectorAll('.search-overlay').forEach(el => el.remove());
  // unwrap md-search-wraps
  document.querySelectorAll('.md-search-wrap').forEach(wrap => {
    const ta = wrap.querySelector('textarea');
    if (ta) wrap.parentNode.insertBefore(ta, wrap);
    wrap.remove();
  });

  if (!S.findQuery || !S.findMatches.length) return;

  // group matches by cellId
  const byCell = {};
  S.findMatches.forEach((m, i) => {
    if (!byCell[m.cellId]) byCell[m.cellId] = [];
    byCell[m.cellId].push({ ...m, globalIdx: i });
  });

  for (const cellId of Object.keys(byCell)) {
    const cell = S.cells.find(c => c.id === parseInt(cellId));
    if (!cell) continue;
    const matches = byCell[cellId];
    const code = cell.code;

    // build overlay content
    let html = '';
    let pos = 0;
    for (const m of matches) {
      // text before match
      html += escHtml(code.substring(pos, m.index));
      const cls = m.globalIdx === S.findCurrent ? 'search-match search-match-current' : 'search-match';
      html += `<mark class="${cls}">${escHtml(code.substring(m.index, m.index + m.length))}</mark>`;
      pos = m.index + m.length;
    }
    html += escHtml(code.substring(pos));

    const overlay = document.createElement('div');

    if (cell.type === 'md') {
      // markdown cells: wrap textarea in md-search-wrap
      overlay.className = 'search-overlay search-overlay-md';
      overlay.innerHTML = html;
      const editWrap = cell.el.querySelector('.cell-md-edit');
      const ta = editWrap.querySelector('textarea');
      let wrap = editWrap.querySelector('.md-search-wrap');
      if (!wrap) {
        wrap = document.createElement('div');
        wrap.className = 'md-search-wrap';
        ta.parentNode.insertBefore(wrap, ta);
        wrap.appendChild(ta);
      }
      wrap.appendChild(overlay);
      wireScrollSync(ta, overlay);
    } else {
      // code, css, html cells: insert in editor-wrap
      overlay.className = 'search-overlay';
      overlay.innerHTML = html;
      let editorWrap;
      if (cell.type === 'code') editorWrap = cell.el.querySelector('.cell-code .editor-wrap');
      else if (cell.type === 'css') editorWrap = cell.el.querySelector('.cell-css-edit .editor-wrap');
      else if (cell.type === 'html') editorWrap = cell.el.querySelector('.cell-html-edit .editor-wrap');
      if (editorWrap) {
        editorWrap.appendChild(overlay);
        const ta = editorWrap.querySelector('textarea');
        if (ta) wireScrollSync(ta, overlay);
      }
    }
  }
}

function wireScrollSync(ta, overlay) {
  if (ta._searchScrollWired) return;
  ta._searchScrollWired = true;
  ta.addEventListener('scroll', () => {
    const ov = ta.closest('.editor-wrap, .md-search-wrap');
    if (!ov) return;
    const so = ov.querySelector('.search-overlay');
    if (so) {
      so.scrollTop = ta.scrollTop;
      so.scrollLeft = ta.scrollLeft;
    }
  });
}

function findUpdateCount() {
  const el = $('#findCount');
  if (!S.findQuery) { el.textContent = ''; return; }
  if (S.findMatches.length === 0) { el.textContent = 'no results'; return; }
  el.textContent = `${S.findCurrent + 1}/${S.findMatches.length}`;
}

function findScrollToMatch() {
  if (S.findCurrent < 0) return;
  const match = S.findMatches[S.findCurrent];
  if (!match) return;
  const cell = S.cells.find(c => c.id === match.cellId);
  if (!cell) return;

  // open editor for non-code cells if needed
  if (cell.type === 'css') {
    const editWrap = cell.el.querySelector('.cell-css-edit');
    const view = cell.el.querySelector('.cell-css-view');
    if (editWrap.style.display === 'none') {
      const ta = editWrap.querySelector('textarea');
      editWrap.style.display = '';
      view.style.display = 'none';
      ta.value = cell.code;
      autoResize({ target: ta });
    }
  } else if (cell.type === 'html') {
    const editWrap = cell.el.querySelector('.cell-html-edit');
    const view = cell.el.querySelector('.cell-html-view');
    if (editWrap.style.display === 'none') {
      const ta = editWrap.querySelector('textarea');
      editWrap.style.display = '';
      view.style.display = 'none';
      ta.value = cell.code;
      autoResize({ target: ta });
    }
  } else if (cell.type === 'md') {
    const editWrap = cell.el.querySelector('.cell-md-edit');
    const view = cell.el.querySelector('.cell-md-view');
    if (editWrap.style.display === 'none') {
      const ta = editWrap.querySelector('textarea');
      editWrap.style.display = '';
      view.style.display = 'none';
      ta.value = cell.code;
      autoResize({ target: ta });
    }
  }

  // uncollapse if collapsed
  cell.el.classList.remove('collapsed');

  // scroll cell into view
  cell.el.scrollIntoView({ block: 'nearest', behavior: 'smooth' });

  // scroll textarea to match line
  const ta = cell.type === 'md'
    ? cell.el.querySelector('.cell-md-edit textarea')
    : cell.type === 'css'
    ? cell.el.querySelector('.cell-css-edit textarea')
    : cell.type === 'html'
    ? cell.el.querySelector('.cell-html-edit textarea')
    : cell.el.querySelector('textarea');
  if (ta) {
    const textBefore = cell.code.substring(0, match.index);
    const lineNum = textBefore.split('\n').length - 1;
    const lineHeight = parseFloat(getComputedStyle(ta).lineHeight) || 20;
    ta.scrollTop = Math.max(0, lineNum * lineHeight - ta.clientHeight / 2);
  }
}

function escHtml(s) {
  return s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
}

// ── EVENT WIRING ──
(function () {
  const findInput = $('#findInput');
  const replaceInput = $('#replaceInput');
  if (!findInput) return;

  findInput.addEventListener('input', () => findComputeMatches());

  findInput.addEventListener('keydown', (e) => {
    if (e.key === 'Enter' && e.shiftKey) { e.preventDefault(); findPrev(); }
    else if (e.key === 'Enter') { e.preventDefault(); findNext(); }
    else if (e.key === 'Escape') { e.preventDefault(); closeFind(); }
  });

  if (replaceInput) {
    replaceInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') { e.preventDefault(); findReplace(); }
      else if (e.key === 'Escape') { e.preventDefault(); closeFind(); }
    });
  }

  const nextBtn = $('#findNextBtn');
  const prevBtn = $('#findPrevBtn');
  const replBtn = $('#findReplaceBtn');
  const replAllBtn = $('#findReplaceAllBtn');
  const caseBtn = $('#findCaseBtn');
  const regexBtn = $('#findRegexBtn');
  const closeBtn = $('#findCloseBtn');

  if (nextBtn) nextBtn.addEventListener('click', findNext);
  if (prevBtn) prevBtn.addEventListener('click', findPrev);
  if (replBtn) replBtn.addEventListener('click', findReplace);
  if (replAllBtn) replAllBtn.addEventListener('click', findReplaceAll);
  if (closeBtn) closeBtn.addEventListener('click', closeFind);
  if (caseBtn) caseBtn.addEventListener('click', () => {
    S.findCase = !S.findCase;
    caseBtn.classList.toggle('active', S.findCase);
    findComputeMatches();
  });
  if (regexBtn) regexBtn.addEventListener('click', () => {
    S.findRegex = !S.findRegex;
    regexBtn.classList.toggle('active', S.findRegex);
    findComputeMatches();
  });

  // live recompute on edit — delegation
  let recomputeTimer = null;
  document.getElementById('notebook').addEventListener('input', (e) => {
    if (!S.findActive) return;
    if (e.target.tagName !== 'TEXTAREA') return;
    clearTimeout(recomputeTimer);
    recomputeTimer = setTimeout(findComputeMatches, 150);
  });
})();

// -- complete.js --

// ── AUTOCOMPLETE ENGINE ──

// well-known property lists for dot completion on builtins
const KNOWN_PROPS = {
  Math: ['abs','acos','asin','atan','atan2','ceil','cos','exp','floor','hypot',
         'log','log2','log10','max','min','pow','random','round','sign','sin',
         'sqrt','tan','trunc','PI','E','LN2','LN10'],
  Array: ['from','isArray','of'],
  Object: ['keys','values','entries','assign','freeze','create','defineProperty','fromEntries','hasOwn'],
  JSON: ['parse','stringify'],
  console: ['log','warn','error','info','table','time','timeEnd','clear'],
  Promise: ['all','allSettled','any','race','resolve','reject'],
  Number: ['isFinite','isInteger','isNaN','parseFloat','parseInt','MAX_SAFE_INTEGER','MIN_SAFE_INTEGER','EPSILON'],
  String: ['fromCharCode','fromCodePoint','raw'],
  ui: ['display','print','canvas','table','slider','dropdown','checkbox','textInput'],
  std: ['csv','fetchJSON','sum','mean','median','extent','bin','linspace',
        'unique','zip','cross','file','download','el','copy','fmt'],
};

// common prototype methods by type
const PROTO_PROPS = {
  array: ['push','pop','shift','unshift','splice','slice','concat','join','reverse',
          'sort','map','filter','reduce','reduceRight','find','findIndex','indexOf',
          'includes','every','some','flat','flatMap','fill','forEach','at','length'],
  string: ['charAt','charCodeAt','codePointAt','concat','endsWith','includes',
           'indexOf','lastIndexOf','match','matchAll','padEnd','padStart','repeat',
           'replace','replaceAll','search','slice','split','startsWith','substring',
           'toLowerCase','toUpperCase','trim','trimEnd','trimStart','at','length'],
  number: ['toFixed','toPrecision','toString','valueOf'],
};

// ── BUILTIN HELP (injected by build.js from src/builtins.json) ──

const BUILTIN_HELP = {
  "ui.display": {
    "sig": "ui.display(...values)",
    "desc": "output values to cell"
  },
  "ui.canvas": {
    "sig": "ui.canvas(w?, h?)",
    "desc": "create/reuse canvas (default 400\u00d7300)"
  },
  "ui.table": {
    "sig": "ui.table(data, columns?)",
    "desc": "render array of objects as table"
  },
  "ui.slider": {
    "sig": "ui.slider(label, default?, {min,max,step,onInput,onChange}?)",
    "desc": "range input \u2014 reactive, or callback via onInput/onChange"
  },
  "ui.dropdown": {
    "sig": "ui.dropdown(label, options, default?, {onInput,onChange}?)",
    "desc": "select menu \u2014 reactive, or callback via onInput/onChange"
  },
  "ui.checkbox": {
    "sig": "ui.checkbox(label, default?, {onInput,onChange}?)",
    "desc": "toggle \u2014 reactive, or callback via onInput/onChange"
  },
  "ui.textInput": {
    "sig": "ui.textInput(label, default?, {onInput,onChange}?)",
    "desc": "text field \u2014 reactive, or callback via onInput/onChange"
  },
  "std.csv": {
    "sig": "std.csv(text, {separator?, typed?}?)",
    "desc": "parse CSV text to array of objects"
  },
  "std.fetchJSON": {
    "sig": "std.fetchJSON(url)",
    "desc": "fetch URL and parse JSON"
  },
  "std.sum": {
    "sig": "std.sum(arr, fn?)",
    "desc": "sum array values"
  },
  "std.mean": {
    "sig": "std.mean(arr, fn?)",
    "desc": "arithmetic mean"
  },
  "std.median": {
    "sig": "std.median(arr, fn?)",
    "desc": "median value"
  },
  "std.extent": {
    "sig": "std.extent(arr, fn?)",
    "desc": "returns [min, max]"
  },
  "std.bin": {
    "sig": "std.bin(arr, n?, fn?)",
    "desc": "histogram bins (default 10)"
  },
  "std.linspace": {
    "sig": "std.linspace(start, stop, n)",
    "desc": "evenly-spaced numbers"
  },
  "std.unique": {
    "sig": "std.unique(arr, fn?)",
    "desc": "unique values with optional key fn"
  },
  "std.zip": {
    "sig": "std.zip(...arrays)",
    "desc": "zip arrays together"
  },
  "std.cross": {
    "sig": "std.cross(...arrays)",
    "desc": "cartesian product"
  },
  "std.file": {
    "sig": "std.file(accept?)",
    "desc": "open file picker"
  },
  "std.download": {
    "sig": "std.download(data, filename, mimeType?)",
    "desc": "download data as file"
  },
  "std.el": {
    "sig": "std.el(tag, attrs?, ...children)",
    "desc": "create DOM element"
  },
  "std.copy": {
    "sig": "std.copy(text)",
    "desc": "copy text to clipboard"
  },
  "std.fmt": {
    "sig": "std.fmt(number, {decimals?, prefix?, suffix?}?)",
    "desc": "format number to string"
  },
  "print": {
    "sig": "print(...values)",
    "desc": "output values to cell (alias for ui.display)"
  },
  "load": {
    "sig": "load(url)",
    "desc": "import ES module (cached). @std, @python supported."
  },
  "install": {
    "sig": "install(url)",
    "desc": "fetch & embed module for offline"
  },
  "invalidation": {
    "sig": "invalidation",
    "desc": "promise \u2014 resolves when cell re-runs"
  },
  "atra": {
    "sig": "atra`...` or atra({imports})`...`",
    "desc": "compile Fortran/Pascal to Wasm (load ext/atra/index.js)"
  }
};

// ── FUZZY MATCHING ──

// returns { score, indices } or null if no match
// indices = positions in `text` that matched characters from `query`
function fuzzyMatch(query, text) {
  const qLen = query.length;
  const tLen = text.length;
  if (qLen === 0) return { score: 0, indices: [] };
  if (qLen > tLen) return null;

  const qLower = query.toLowerCase();
  const tLower = text.toLowerCase();

  // fast check: all query chars exist in text in order
  let qi = 0;
  for (let ti = 0; ti < tLen && qi < qLen; ti++) {
    if (qLower[qi] === tLower[ti]) qi++;
  }
  if (qi < qLen) return null;

  // find best match using a greedy approach that prefers word boundaries
  // word boundaries: start of string, after _ or $, camelCase transitions
  const indices = [];
  qi = 0;

  // first pass: try to match at word boundaries
  const boundaryIndices = [];
  let bqi = 0;
  for (let ti = 0; ti < tLen && bqi < qLen; ti++) {
    if (qLower[bqi] !== tLower[ti]) continue;
    const isBoundary = ti === 0
      || text[ti - 1] === '_' || text[ti - 1] === '$'
      || (text[ti] >= 'A' && text[ti] <= 'Z' && (ti === 0 || text[ti - 1] < 'A' || text[ti - 1] > 'Z'));
    if (isBoundary) {
      boundaryIndices.push(ti);
      bqi++;
    }
  }

  if (bqi === qLen) {
    // all chars matched at boundaries — use those indices
    indices.push(...boundaryIndices);
  } else {
    // fallback: greedy left-to-right match, prefer consecutive runs
    qi = 0;
    for (let ti = 0; ti < tLen && qi < qLen; ti++) {
      if (qLower[qi] === tLower[ti]) {
        indices.push(ti);
        qi++;
      }
    }
  }

  // score the match
  let score = 0;

  // bonus for matching at start of string
  if (indices[0] === 0) score += 10;

  // bonus for consecutive characters
  for (let i = 1; i < indices.length; i++) {
    if (indices[i] === indices[i - 1] + 1) score += 5;
  }

  // bonus for word boundary matches
  for (const idx of indices) {
    if (idx === 0) { score += 3; continue; }
    const prev = text[idx - 1];
    if (prev === '_' || prev === '$') { score += 3; continue; }
    if (text[idx] >= 'A' && text[idx] <= 'Z' && (prev < 'A' || prev > 'Z')) score += 3;
  }

  // bonus for exact case match
  for (let i = 0; i < indices.length; i++) {
    if (query[i] === text[indices[i]]) score += 1;
  }

  // penalty for spread-out matches (large gaps between indices)
  const span = indices[indices.length - 1] - indices[0];
  score -= span * 0.5;

  // slight penalty for longer names (prefer shorter completions)
  score -= tLen * 0.1;

  return { score, indices };
}

// determine cursor context: is it inside a string or comment?
function cursorContext(code, cursor) {
  let i = 0;
  while (i < cursor) {
    const ch = code[i];
    // single-line comment
    if (ch === '/' && code[i + 1] === '/') {
      const nl = code.indexOf('\n', i);
      if (nl === -1 || nl >= cursor) return 'comment';
      i = nl + 1;
      continue;
    }
    // block comment
    if (ch === '/' && code[i + 1] === '*') {
      const end = code.indexOf('*/', i + 2);
      if (end === -1 || end + 2 > cursor) return 'comment';
      i = end + 2;
      continue;
    }
    // single-quoted string
    if (ch === "'") {
      i++;
      while (i < code.length) {
        if (code[i] === '\\') { i += 2; continue; }
        if (code[i] === "'") { i++; break; }
        if (i >= cursor) return 'string';
        i++;
      }
      continue;
    }
    // double-quoted string
    if (ch === '"') {
      i++;
      while (i < code.length) {
        if (code[i] === '\\') { i += 2; continue; }
        if (code[i] === '"') { i++; break; }
        if (i >= cursor) return 'string';
        i++;
      }
      continue;
    }
    // template literal (possibly tagged)
    if (ch === '`') {
      // look back for a tag name: identifier immediately before the backtick,
      // or curried form: identifier(...) before the backtick
      let tagName = null;
      if (i > 0 && typeof window !== 'undefined' && window._taggedLanguages) {
        let te = i;
        let ts = te;
        // direct form: ident`
        while (ts > 0 && /\w/.test(code[ts - 1])) ts--;
        if (ts < te) {
          const candidate = code.slice(ts, te);
          if (window._taggedLanguages[candidate]) tagName = candidate;
        }
        // curried form: ident(...)`
        if (!tagName && code[i - 1] === ')') {
          let p = i - 2, depth = 1;
          while (p >= 0 && depth > 0) {
            if (code[p] === ')') depth++;
            else if (code[p] === '(') depth--;
            p--;
          }
          // p now points one before the (
          let ne = p + 1;
          let ns = ne;
          while (ns > 0 && /\w/.test(code[ns - 1])) ns--;
          if (ns < ne) {
            const candidate = code.slice(ns, ne);
            if (window._taggedLanguages[candidate]) tagName = candidate;
          }
        }
      }

      i++;
      let depth = 0;
      while (i < code.length) {
        if (code[i] === '\\') { i += 2; continue; }
        if (code[i] === '$' && code[i + 1] === '{') {
          depth++;
          i += 2;
          // inside ${...} — this is code context
          let braces = 1;
          while (i < code.length && braces > 0) {
            if (code[i] === '{') braces++;
            else if (code[i] === '}') { braces--; if (braces === 0) break; }
            if (i >= cursor) return 'code'; // inside template expression = code
            i++;
          }
          if (i >= cursor) return 'code';
          i++; // skip closing }
          continue;
        }
        if (code[i] === '`') { i++; break; }
        if (i >= cursor) return tagName ? { type: 'tagged', lang: tagName } : 'string';
        i++;
      }
      continue;
    }
    i++;
  }
  return 'code';
}

// extract the word being typed at cursor position
function extractPrefix(code, cursor) {
  let end = cursor;
  let start = cursor;
  while (start > 0 && /[a-zA-Z0-9_$]/.test(code[start - 1])) start--;
  return { prefix: code.slice(start, end), start };
}

// detect dot access: returns the expression before the dot, or null
function detectDot(code, cursor) {
  // cursor is right after a dot or after dot + partial word
  const before = code.slice(0, cursor);
  // match patterns like "identifier." or "identifier.par" at end
  const m = before.match(/([a-zA-Z_$][\w$]*)\.\s*([a-zA-Z_$][\w$]*)?$/);
  if (m) return { obj: m[1], prefix: m[2] || '' };
  return null;
}

function getPropsForValue(val) {
  if (val == null) return [];
  const props = new Set();
  // own properties
  const own = Object.getOwnPropertyNames(val);
  for (const p of own) {
    if (/^[a-zA-Z_$]/.test(p)) props.add(p);
  }
  // prototype chain (1 level)
  const proto = Object.getPrototypeOf(val);
  if (proto && proto !== Object.prototype) {
    try {
      const pNames = Object.getOwnPropertyNames(proto);
      for (const p of pNames) {
        if (p !== 'constructor' && /^[a-zA-Z_$]/.test(p)) props.add(p);
      }
    } catch {}
  }
  return [...props];
}

function getCompletions(code, cursor, cellId) {
  const ctx = cursorContext(code, cursor);

  // tagged template literal — delegate to extension completions
  if (ctx && typeof ctx === 'object' && ctx.type === 'tagged') {
    const lang = typeof window !== 'undefined' && window._taggedLanguages
      && window._taggedLanguages[ctx.lang];
    if (lang && lang.completions) {
      const { prefix, start } = extractPrefix(code, cursor);
      if (!prefix) return { prefix: '', items: [] };
      const extItems = lang.completions(prefix);
      // score and annotate items
      const items = [];
      for (const it of extItems) {
        const m = fuzzyMatch(prefix, it.text);
        if (m) items.push({ text: it.text, kind: it.kind || 'var', score: m.score, indices: m.indices });
      }
      items.sort((a, b) => b.score - a.score || a.text.localeCompare(b.text));
      return { prefix, items: items.slice(0, 30) };
    }
    return { prefix: '', items: [] };
  }

  if (ctx !== 'code') return { prefix: '', items: [] };

  // check for dot completion
  const dot = detectDot(code, cursor);
  if (dot) {
    const items = [];
    const prefix = dot.prefix;
    let propList = [];

    // check known builtins
    if (KNOWN_PROPS[dot.obj]) {
      propList = KNOWN_PROPS[dot.obj];
    } else if (dot.obj in S.scope) {
      // live value inspection
      const val = S.scope[dot.obj];
      if (val != null) {
        propList = getPropsForValue(val);
        // also add type-based suggestions
        if (Array.isArray(val)) propList = [...new Set([...propList, ...PROTO_PROPS.array])];
        else if (typeof val === 'string') propList = [...new Set([...propList, ...PROTO_PROPS.string])];
        else if (typeof val === 'number') propList = [...new Set([...propList, ...PROTO_PROPS.number])];
      }
    }

    for (const p of propList) {
      if (!prefix) {
        items.push({ text: p, kind: 'prop', score: 0, indices: [] });
        continue;
      }
      const m = fuzzyMatch(prefix, p);
      if (m) items.push({ text: p, kind: 'prop', score: m.score, indices: m.indices });
    }

    items.sort((a, b) => b.score - a.score || a.text.localeCompare(b.text));
    return { prefix, items: items.slice(0, 30) };
  }

  // word prefix completion
  const { prefix, start } = extractPrefix(code, cursor);
  if (!prefix) return { prefix: '', items: [] };

  const items = [];
  const seen = new Set();

  // collect candidates from all sources with their kind
  const candidates = [];

  // 1. scope variables
  for (const name of Object.keys(S.scope)) {
    if (!seen.has(name)) { seen.add(name); candidates.push({ text: name, kind: 'var' }); }
  }

  // 2. own cell defines
  const cell = S.cells.find(c => c.id === cellId);
  if (cell && cell.defines) {
    for (const name of cell.defines) {
      if (!seen.has(name)) { seen.add(name); candidates.push({ text: name, kind: 'def' }); }
    }
  }

  // 3. builtin functions (with help detail)
  for (const name of Object.keys(BUILTIN_HELP)) {
    if (!seen.has(name)) {
      seen.add(name);
      const h = BUILTIN_HELP[name];
      candidates.push({ text: name, kind: 'fn', detail: h.sig });
    }
  }

  // 4. JS builtins
  for (const name of JS_BUILTINS) {
    if (!seen.has(name)) { seen.add(name); candidates.push({ text: name, kind: 'const' }); }
  }

  // 5. JS keywords (min 2 chars to avoid noise)
  if (prefix.length >= 2) {
    for (const name of JS_KEYWORDS) {
      if (!seen.has(name)) { seen.add(name); candidates.push({ text: name, kind: 'kw' }); }
    }
  }

  // fuzzy match all candidates
  for (const c of candidates) {
    if (c.text === prefix) continue; // skip exact match (already typed)
    const m = fuzzyMatch(prefix, c.text);
    if (m) {
      const item = { text: c.text, kind: c.kind, score: m.score, indices: m.indices };
      if (c.detail) item.detail = c.detail;
      items.push(item);
    }
  }

  // sort by score descending, then alphabetical
  items.sort((a, b) => b.score - a.score || a.text.localeCompare(b.text));

  return { prefix, items: items.slice(0, 30) };
}

// ── TEXTAREA ADAPTER ──

const KIND_LABELS = { var: 'v', fn: 'f', kw: 'k', const: 'c', prop: 'p', def: 'd' };

let activeMenu = null;
let activeState = null;
let activeSigHint = null;

function dismissAutocomplete() {
  if (activeMenu) {
    activeMenu.remove();
    activeMenu = null;
    activeState = null;
  }
}

function dismissSigHint() {
  if (activeSigHint) {
    activeSigHint.remove();
    activeSigHint = null;
  }
}

// detect if cursor is inside a function call's arguments for a known builtin
function detectCallContext(code, cursor) {
  // scan backwards from cursor to find an unmatched (
  let depth = 0;
  let i = cursor - 1;
  while (i >= 0) {
    const ch = code[i];
    if (ch === ')') depth++;
    else if (ch === '(') {
      if (depth === 0) {
        // found the opening paren — extract the function name before it (including dot for ui.slider etc.)
        let end = i;
        let start = end - 1;
        while (start >= 0 && /[a-zA-Z0-9_$.]/.test(code[start])) start--;
        start++;
        const fnName = code.slice(start, end);
        if (BUILTIN_HELP[fnName]) {
          // figure out which parameter we're on by counting commas at depth 0
          let paramIdx = 0;
          let d = 0;
          for (let j = i + 1; j < cursor; j++) {
            if (code[j] === '(' || code[j] === '[' || code[j] === '{') d++;
            else if (code[j] === ')' || code[j] === ']' || code[j] === '}') d--;
            else if (code[j] === ',' && d === 0) paramIdx++;
          }
          return { fnName, parenPos: i, paramIdx };
        }
        return null;
      }
      depth--;
    }
    i--;
  }
  return null;
}

function showSigHint(ta) {
  const code = ta.value;
  const cursor = ta.selectionStart;
  if (ta.selectionStart !== ta.selectionEnd) { dismissSigHint(); return; }

  const ctx = cursorContext(code, cursor);
  if (ctx !== 'code') { dismissSigHint(); return; }

  const call = detectCallContext(code, cursor);
  if (!call) { dismissSigHint(); return; }

  const wrap = ta.closest('.editor-wrap');
  if (!wrap) { dismissSigHint(); return; }

  const help = BUILTIN_HELP[call.fnName];
  const pos = measureCursorPos(ta, call.parenPos);

  if (!activeSigHint) {
    activeSigHint = document.createElement('div');
    activeSigHint.className = 'ac-sig-hint';
    wrap.appendChild(activeSigHint);
  } else if (activeSigHint.parentElement !== wrap) {
    activeSigHint.remove();
    wrap.appendChild(activeSigHint);
  }

  // highlight current parameter in the signature
  const sigHtml = highlightParam(help.sig, call.paramIdx);
  activeSigHint.innerHTML = `<span class="ac-sig-fn">${sigHtml}</span><span class="ac-sig-desc">${esc(help.desc)}</span>`;

  const cs = getComputedStyle(ta);
  const padLeft = parseFloat(cs.paddingLeft) || 0;
  const padTop = parseFloat(cs.paddingTop) || 0;
  const lineHeight = parseFloat(cs.lineHeight) || parseFloat(cs.fontSize) * 1.5;

  const left = pos.x + padLeft - ta.scrollLeft;

  // place above the current line; pos.y is bottom of the line
  // so subtract lineHeight (to get top of line) then the hint's own height
  activeSigHint.style.left = left + 'px';
  activeSigHint.style.top = '0px'; // render off-screen first to measure
  activeSigHint.style.visibility = 'hidden';
  const hintH = activeSigHint.offsetHeight || lineHeight;
  activeSigHint.style.visibility = '';

  let top = pos.y + padTop - ta.scrollTop - lineHeight - hintH;

  // if it would go above the editor, show below the current line instead
  const wrapRect = wrap.getBoundingClientRect();
  const taRect = ta.getBoundingClientRect();
  const absTop = taRect.top + top;
  if (absTop < wrapRect.top) {
    top = pos.y + padTop - ta.scrollTop;
  }

  activeSigHint.style.top = top + 'px';
}

function highlightParam(sig, paramIdx) {
  // find the params inside parens
  const openParen = sig.indexOf('(');
  if (openParen === -1) return esc(sig);
  const closeParen = sig.lastIndexOf(')');
  if (closeParen === -1) return esc(sig);

  const before = sig.slice(0, openParen + 1);
  const params = sig.slice(openParen + 1, closeParen);
  const after = sig.slice(closeParen);

  // split on commas (respecting nested braces)
  const parts = [];
  let depth = 0;
  let start = 0;
  for (let i = 0; i < params.length; i++) {
    if (params[i] === '{' || params[i] === '(' || params[i] === '[') depth++;
    else if (params[i] === '}' || params[i] === ')' || params[i] === ']') depth--;
    else if (params[i] === ',' && depth === 0) {
      parts.push(params.slice(start, i));
      start = i + 1;
    }
  }
  parts.push(params.slice(start));

  let html = esc(before);
  for (let i = 0; i < parts.length; i++) {
    if (i > 0) html += esc(',');
    if (i === paramIdx) {
      html += '<span class="ac-sig-active">' + esc(parts[i]) + '</span>';
    } else {
      html += esc(parts[i]);
    }
  }
  html += esc(after);
  return html;
}

function measureCursorPos(ta, cursor) {
  const text = ta.value.substring(0, cursor);
  const lines = text.split('\n');
  const lineNum = lines.length - 1;
  const colText = lines[lineNum];

  // measure column offset using a hidden span
  let measurer = ta._acMeasurer;
  if (!measurer) {
    measurer = document.createElement('span');
    measurer.style.cssText = 'position:absolute;visibility:hidden;white-space:pre;pointer-events:none;';
    document.body.appendChild(measurer);
    ta._acMeasurer = measurer;
  }
  const cs = getComputedStyle(ta);
  measurer.style.font = cs.font;
  measurer.style.fontSize = cs.fontSize;
  measurer.style.fontFamily = cs.fontFamily;
  measurer.style.letterSpacing = cs.letterSpacing;
  measurer.style.tabSize = cs.tabSize;
  measurer.textContent = colText;

  const lineHeight = parseFloat(cs.lineHeight) || parseFloat(cs.fontSize) * 1.5;
  const x = measurer.offsetWidth;
  const y = (lineNum + 1) * lineHeight;

  return { x, y, lineHeight };
}

function highlightMatches(text, indices) {
  if (!indices || !indices.length) return esc(text);
  const set = new Set(indices);
  let html = '';
  let inMatch = false;
  for (let i = 0; i < text.length; i++) {
    if (set.has(i)) {
      if (!inMatch) { html += '<span class="ac-match">'; inMatch = true; }
      html += esc(text[i]);
    } else {
      if (inMatch) { html += '</span>'; inMatch = false; }
      html += esc(text[i]);
    }
  }
  if (inMatch) html += '</span>';
  return html;
}

function renderMenu(items, prefix, selectedIdx) {
  let html = '';
  const max = Math.min(items.length, 30);
  for (let i = 0; i < max; i++) {
    const it = items[i];
    const cls = i === selectedIdx ? 'ac-item active' : 'ac-item';
    const kindCls = 'ac-kind ac-kind-' + it.kind;
    const label = KIND_LABELS[it.kind] || '?';
    const textHtml = highlightMatches(it.text, it.indices);
    const detailHtml = it.detail ? `<span class="ac-detail">${esc(it.detail)}</span>` : '';
    html += `<div class="${cls}" data-index="${i}"><span class="${kindCls}">${label}</span><span class="ac-text">${textHtml}</span>${detailHtml}</div>`;
  }
  return html;
}

function esc(s) {
  return s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
}

function showMenu(ta, cellId) {
  const code = ta.value;
  const cursor = ta.selectionStart;
  if (ta.selectionStart !== ta.selectionEnd) { dismissAutocomplete(); return; }

  const result = getCompletions(code, cursor, cellId);
  if (!result.items.length) { dismissAutocomplete(); return; }

  const wrap = ta.closest('.editor-wrap');
  if (!wrap) { dismissAutocomplete(); return; }

  const pos = measureCursorPos(ta, cursor);

  if (!activeMenu) {
    activeMenu = document.createElement('div');
    activeMenu.className = 'ac-menu';
    wrap.appendChild(activeMenu);
  } else if (activeMenu.parentElement !== wrap) {
    activeMenu.remove();
    wrap.appendChild(activeMenu);
  }

  activeState = {
    items: result.items,
    prefix: result.prefix,
    selected: 0,
    ta,
    cellId,
    cursorStart: cursor - result.prefix.length
  };

  activeMenu.innerHTML = renderMenu(result.items, result.prefix, 0);

  // position: account for padding and scroll
  const cs = getComputedStyle(ta);
  const padLeft = parseFloat(cs.paddingLeft) || 0;
  const padTop = parseFloat(cs.paddingTop) || 0;

  const left = pos.x + padLeft - ta.scrollLeft;
  const top = pos.y + padTop - ta.scrollTop;

  activeMenu.style.left = left + 'px';
  activeMenu.style.top = top + 'px';

  // flip above if it would overflow viewport
  const menuRect = activeMenu.getBoundingClientRect();
  if (menuRect.bottom > window.innerHeight - 20) {
    activeMenu.style.top = (top - pos.lineHeight - activeMenu.offsetHeight) + 'px';
  }

  // mouse interaction
  activeMenu.onmousedown = (e) => {
    e.preventDefault(); // don't blur textarea
    const item = e.target.closest('.ac-item');
    if (item) {
      activeState.selected = parseInt(item.dataset.index);
      acceptCompletion();
    }
  };
}

function updateSelection(idx) {
  if (!activeMenu || !activeState) return;
  activeState.selected = idx;
  const items = activeMenu.querySelectorAll('.ac-item');
  items.forEach((el, i) => el.classList.toggle('active', i === idx));
  // scroll into view
  if (items[idx]) items[idx].scrollIntoView({ block: 'nearest' });
}

function acceptCompletion() {
  if (!activeState) return;
  const { items, selected, ta, prefix, cursorStart } = activeState;
  const item = items[selected];
  if (!item) return;

  ta.focus();
  ta.selectionStart = cursorStart;
  ta.selectionEnd = cursorStart + prefix.length;
  document.execCommand('insertText', false, item.text);

  dismissAutocomplete();
  ta.dispatchEvent(new Event('input'));
}

function attachAutocomplete(textarea, cellId) {
  // keydown handler — must be added BEFORE handleTab so stopImmediatePropagation works
  textarea.addEventListener('keydown', (e) => {
    // Ctrl+Shift+Space — manual signature hint trigger
    if (e.key === ' ' && (e.ctrlKey || e.metaKey) && e.shiftKey) {
      e.preventDefault();
      e.stopImmediatePropagation();
      dismissAutocomplete();
      showSigHint(textarea);
      return;
    }

    if (!activeMenu || !activeState) return;

    if (e.key === 'ArrowDown') {
      e.preventDefault();
      e.stopImmediatePropagation();
      const next = (activeState.selected + 1) % activeState.items.length;
      updateSelection(next);
      return;
    }
    if (e.key === 'ArrowUp') {
      e.preventDefault();
      e.stopImmediatePropagation();
      const prev = (activeState.selected - 1 + activeState.items.length) % activeState.items.length;
      updateSelection(prev);
      return;
    }
    if (e.key === 'Tab' || e.key === 'Enter') {
      e.preventDefault();
      e.stopImmediatePropagation();
      acceptCompletion();
      return;
    }
    if (e.key === 'Escape') {
      e.preventDefault();
      e.stopImmediatePropagation();
      dismissAutocomplete();
      dismissSigHint();
      return;
    }
  });

  // input handler — show/update completions + signature hints
  textarea.addEventListener('input', () => {
    // use a microtask so the value is settled
    Promise.resolve().then(() => {
      showMenu(textarea, cellId);
      // show sig hint only when autocomplete menu is not visible
      if (!activeMenu) showSigHint(textarea);
      else dismissSigHint();
    });
  });

  // dismiss on blur
  textarea.addEventListener('blur', () => {
    // delay so mousedown on menu can fire first
    setTimeout(() => { dismissAutocomplete(); dismissSigHint(); }, 150);
  });

  // dismiss on scroll (position goes stale)
  textarea.addEventListener('scroll', () => {
    dismissAutocomplete();
    dismissSigHint();
  });
}

// -- keyboard.js --

// ── KEYBOARD / SELECTION ──

function addCellWithUndo(type, code, afterId, beforeId) {
  const cell = addCell(type, code, afterId, beforeId);
  S.trash.push({ action: 'add', id: cell.id });
  return cell;
}

function deleteCellWithUndo(id) {
  const idx = S.cells.findIndex(c => c.id === id);
  if (idx < 0) return;
  const cell = S.cells[idx];
  const afterId = idx > 0 ? S.cells[idx - 1].id : null;
  const beforeId = afterId === null && idx < S.cells.length - 1 ? S.cells[idx + 1].id : null;
  S.trash.push({ action: 'delete', type: cell.type, code: cell.code, afterId, beforeId, collapsed: !!cell.el.classList.contains('collapsed') });
  deleteCell(id);
  setMsg('deleted cell (z to undo)', 'ok');
}

function undo() {
  if (!S.trash.length) { setMsg('nothing to undo', ''); return; }
  const entry = S.trash.pop();

  if (entry.action === 'add') {
    // undo add = delete the cell (without pushing to undo stack)
    deleteCell(entry.id);
    setMsg('undid add', 'ok');
  } else {
    // undo delete = restore the cell
    const { type, code, afterId, beforeId, collapsed } = entry;
    const validAfter = afterId !== null && S.cells.find(c => c.id === afterId) ? afterId : null;
    const validBefore = beforeId !== null && S.cells.find(c => c.id === beforeId) ? beforeId : null;
    const newCell = addCell(type, code, validAfter, validBefore);
    if (collapsed) newCell.el.classList.add('collapsed');
    selectCell(newCell.id);
    if ((type === 'code' || type === 'html') && S.cells.some(c => c.type === 'code' || c.type === 'html')) runAll();
    setMsg('restored cell', 'ok');
  }
}

function selectCell(id, scroll) {
  // deselect previous
  $$('.cell.selected').forEach(el => el.classList.remove('selected'));
  S.selectedId = id;
  if (id === null) return;
  const cell = S.cells.find(c => c.id === id);
  if (cell) {
    cell.el.classList.add('selected');
    if (scroll) cell.el.scrollIntoView({ block: 'nearest' });
  }
}

function getEditingCell() {
  const active = document.activeElement;
  if (active && active.tagName === 'TEXTAREA') {
    const cellEl = active.closest('.cell');
    if (cellEl) {
      const id = parseInt(cellEl.dataset.id);
      return S.cells.find(c => c.id === id) || null;
    }
  }
  return null;
}

function editCell(id) {
  const cell = S.cells.find(c => c.id === id);
  if (!cell) return;
  selectCell(id);

  if (cell.type === 'md') {
    // open md editor
    const view = cell.el.querySelector('.cell-md-view');
    const editWrap = cell.el.querySelector('.cell-md-edit');
    const ta = cell.el.querySelector('.cell-md-edit textarea');
    editWrap.style.display = '';
    view.style.display = 'none';
    ta.value = cell.code;
    ta.focus();
    autoResize({ target: ta });
  } else if (cell.type === 'css') {
    // open css editor
    const view = cell.el.querySelector('.cell-css-view');
    const editWrap = cell.el.querySelector('.cell-css-edit');
    const ta = cell.el.querySelector('.cell-css-edit textarea');
    editWrap.style.display = '';
    view.style.display = 'none';
    ta.value = cell.code;
    ta.focus();
    autoResize({ target: ta });
  } else if (cell.type === 'html') {
    // open html editor
    const view = cell.el.querySelector('.cell-html-view');
    const editWrap = cell.el.querySelector('.cell-html-edit');
    const ta = cell.el.querySelector('.cell-html-edit textarea');
    editWrap.style.display = '';
    view.style.display = 'none';
    ta.value = cell.code;
    ta.focus();
    autoResize({ target: ta });
  } else {
    cell.el.querySelector('textarea').focus();
  }
}

function exitEdit() {
  const active = document.activeElement;
  if (active && active.tagName === 'TEXTAREA') {
    active.blur();
  }
}

function runSelected() {
  if (S.selectedId === null && S.cells.length) selectCell(S.cells[0].id);
  const cell = S.cells.find(c => c.id === S.selectedId);
  if (!cell) return;
  if (cell.type === 'code') {
    cell.code = cell.el.querySelector('.cell-code textarea').value;
    runDAG([cell.id]);
  } else if (cell.type === 'html') {
    renderHtmlCell(cell);
  }
}

// ── MOBILE TRAY TOGGLES ──

function closeAllTrays() {
  document.querySelectorAll('.action-add-tray.open, .action-more-tray.open, .cell-type-picker.open, .cell-insert-picker.open').forEach(el => el.classList.remove('open'));
}

function toggleToolbarMenu() {
  const menu = document.querySelector('.toolbar-overflow');
  if (!menu) return;
  menu.classList.toggle('open');
}

function toggleAddTray() {
  const tray = document.querySelector('.action-add-tray');
  if (!tray) return;
  const wasOpen = tray.classList.contains('open');
  closeAllTrays();
  if (!wasOpen) tray.classList.add('open');
}

function toggleMoreTray() {
  const tray = document.querySelector('.action-more-tray');
  if (!tray) return;
  const wasOpen = tray.classList.contains('open');
  closeAllTrays();
  if (!wasOpen) tray.classList.add('open');
}

function showInsertPicker(id, dir) {
  closeAllTrays();
  const cell = S.cells.find(c => c.id === id);
  if (!cell) return;
  document.querySelectorAll('.cell-insert-picker').forEach(el => el.remove());
  const picker = document.createElement('div');
  picker.className = 'cell-insert-picker open';
  let afterId;
  if (dir === 'after') {
    afterId = id;
  } else {
    const idx = S.cells.findIndex(c => c.id === id);
    afterId = idx > 0 ? S.cells[idx - 1].id : null;
  }
  picker.innerHTML = ['code', 'md', 'css', 'html'].map(t =>
    `<button onclick="insertAt(${afterId !== null ? afterId : 'null'},'${t}');this.closest('.cell-insert-picker').remove()">${t}</button>`
  ).join('');
  const header = cell.el.querySelector('.cell-header');
  header.style.position = 'relative';
  picker.style.top = '100%';
  picker.style.left = dir === 'before' ? '0' : 'auto';
  picker.style.right = dir === 'after' ? '0' : 'auto';
  header.appendChild(picker);
}

function toggleTypePicker(id) {
  closeAllTrays();
  const picker = document.querySelector(`.cell-type-picker[data-cell-id="${id}"]`);
  if (picker) picker.classList.toggle('open');
}

function collapseAll() {
  S.cells.forEach(c => c.el.classList.add('collapsed'));
  setMsg('collapsed all', 'ok');
}

function expandAll() {
  S.cells.forEach(c => c.el.classList.remove('collapsed'));
  setMsg('expanded all', 'ok');
}

function newNotebook() {
  if (!confirm('Clear all cells?')) return;
  while (S.cells.length) {
    const cell = S.cells[0];
    if (cell._styleEl) { cell._styleEl.remove(); cell._styleEl = null; }
    cell.el.remove();
    S.cells.shift();
  }
  S.scope = {};
  S.selectedId = null;
  S.clipboard = null;
  S.trash = [];
  $('#docTitle').value = 'untitled';
  updateStatus();
  setMsg('new notebook', 'ok');
}

function runSelectedCell() { runSelectedAndAdvance(); }

function runSelectedAndAdvance() {
  runSelected();
  if (S.selectedId === null) return;
  // respect goto target if set
  const gotoIdx = window._lastGotoTarget;
  if (gotoIdx != null && gotoIdx >= 0 && gotoIdx < S.cells.length) {
    editCell(S.cells[gotoIdx].id);
  } else {
    const idx = S.cells.findIndex(c => c.id === S.selectedId);
    if (idx < S.cells.length - 1) {
      editCell(S.cells[idx + 1].id);
    } else {
      const newCell = addCellWithUndo('code', '', S.selectedId);
      selectCell(newCell.id);
    }
  }
}

function navigateCell(dir) {
  if (!S.cells.length) return;
  if (S.selectedId === null) {
    selectCell(S.cells[0].id, true);
    return;
  }
  const idx = S.cells.findIndex(c => c.id === S.selectedId);
  const newIdx = idx + dir;
  if (newIdx >= 0 && newIdx < S.cells.length) {
    selectCell(S.cells[newIdx].id, true);
  }
}

document.addEventListener('keydown', (e) => {
  // find bar shortcuts (must be before edit/command branches)
  if ((e.key === 'f') && (e.ctrlKey || e.metaKey) && !e.altKey) {
    e.preventDefault(); openFind(false); return;
  }
  if ((e.key === 'h') && (e.ctrlKey || e.metaKey) && !e.altKey) {
    e.preventDefault(); openFind(true); return;
  }
  if (e.key === 'Escape' && S.findActive) {
    e.preventDefault(); closeFind(); return;
  }

  const editing = getEditingCell();

  if (editing) {
    // ── EDIT MODE ──
    if (e.key === '/' && (e.ctrlKey || e.metaKey)) {
      e.preventDefault();
      toggleComment(document.activeElement);
      return;
    }
    if (e.key === 'Escape') {
      e.preventDefault();
      exitEdit();
      selectCell(editing.id);
      return;
    }
    if (e.key === 'Enter' && e.ctrlKey) {
      e.preventDefault();
      editing.code = editing.el.querySelector('textarea').value;
      if (editing.type === 'code') runDAG([editing.id], true);
      return;
    }
    if (e.key === 'Enter' && e.shiftKey) {
      e.preventDefault();
      editing.code = editing.el.querySelector('textarea').value;
      if (editing.type === 'code') runDAG([editing.id], true);
      // advance — respect goto target if set
      const gotoIdx = window._lastGotoTarget;
      if (gotoIdx != null && gotoIdx >= 0 && gotoIdx < S.cells.length) {
        editCell(S.cells[gotoIdx].id);
      } else {
        const idx = S.cells.findIndex(c => c.id === editing.id);
        if (idx < S.cells.length - 1) {
          editCell(S.cells[idx + 1].id);
        } else {
          const newCell = addCellWithUndo('code', '', editing.id);
          selectCell(newCell.id);
          editCell(newCell.id);
        }
      }
      return;
    }
  } else {
    // ── COMMAND MODE ──
    // ignore if typing in any input field (title, find bar, etc.)
    if (document.activeElement && (document.activeElement.tagName === 'INPUT' || document.activeElement.id === 'docTitle')) return;

    // let browser shortcuts through (Ctrl+J downloads, etc.)
    if (e.ctrlKey || e.metaKey || e.altKey) return;

    if (e.key === 'ArrowUp' || e.key === 'k') {
      e.preventDefault();
      navigateCell(-1);
      return;
    }
    if (e.key === 'ArrowDown' || e.key === 'j') {
      e.preventDefault();
      navigateCell(1);
      return;
    }
    if (e.key === 'Enter') {
      e.preventDefault();
      if (S.selectedId !== null) editCell(S.selectedId);
      return;
    }
    if (e.key === 'a') {
      e.preventDefault();
      const newCell = addCellWithUndo('code', '', null, S.selectedId);
      selectCell(newCell.id);
      editCell(newCell.id);
      return;
    }
    if (e.key === 'b') {
      e.preventDefault();
      const newCell = addCellWithUndo('code', '', S.selectedId);
      selectCell(newCell.id);
      editCell(newCell.id);
      return;
    }
    if (e.key === 'd') {
      e.preventDefault();
      if (S.pendingD) {
        // dd — delete
        clearTimeout(S.pendingDTimer);
        S.pendingD = false;
        if (S.selectedId !== null) {
          const idx = S.cells.findIndex(c => c.id === S.selectedId);
          const nextId = idx < S.cells.length - 1 ? S.cells[idx + 1].id
                       : idx > 0 ? S.cells[idx - 1].id : null;
          deleteCellWithUndo(S.selectedId);
          if (nextId !== null) selectCell(nextId);
        }
      } else {
        S.pendingD = true;
        S.pendingDTimer = setTimeout(() => { S.pendingD = false; }, 600);
      }
      return;
    }
    if (e.key !== 'd' && S.pendingD) { S.pendingD = false; clearTimeout(S.pendingDTimer); }
    if (e.key === 'z') {
      e.preventDefault();
      undo();
      return;
    }
    if (e.key === 'c' && S.selectedId !== null) {
      e.preventDefault();
      const cell = S.cells.find(c => c.id === S.selectedId);
      if (cell) S.clipboard = { type: cell.type, code: cell.code };
      setMsg('copied cell', 'ok');
      return;
    }
    if (e.key === 'v' && S.clipboard) {
      e.preventDefault();
      const newCell = addCellWithUndo(S.clipboard.type, S.clipboard.code, S.selectedId);
      selectCell(newCell.id);
      if (S.clipboard.type === 'code' && S.cells.some(c => c.type === 'code')) runAll();
      return;
    }
    if (e.key === 'x' && S.selectedId !== null) {
      // cut = copy + delete
      e.preventDefault();
      const cell = S.cells.find(c => c.id === S.selectedId);
      if (cell) S.clipboard = { type: cell.type, code: cell.code };
      const idx = S.cells.findIndex(c => c.id === S.selectedId);
      const nextId = idx < S.cells.length - 1 ? S.cells[idx + 1].id
                   : idx > 0 ? S.cells[idx - 1].id : null;
      deleteCellWithUndo(S.selectedId);
      if (nextId !== null) selectCell(nextId);
      setMsg('cut cell', 'ok');
      return;
    }
    if (e.key === 'h' && S.selectedId !== null) {
      e.preventDefault();
      const cell = S.cells.find(c => c.id === S.selectedId);
      if (cell) cell.el.classList.toggle('collapsed');
      return;
    }
    if (e.key === 'l') {
      e.preventDefault();
      const on = getSettings().lineNumbers === 'on';
      applyLineNumbers(!on);
      setMsg(on ? 'line numbers off' : 'line numbers on', 'ok');
      return;
    }
    if (e.key === 'p') {
      e.preventDefault();
      togglePresent();
      return;
    }
    if (e.key === 'm' && S.selectedId !== null) {
      e.preventDefault();
      convertCell(S.selectedId, 'md');
      return;
    }
    if (e.key === 'y' && S.selectedId !== null) {
      e.preventDefault();
      convertCell(S.selectedId, 'code');
      return;
    }
    if (e.key === 's' && S.selectedId !== null) {
      e.preventDefault();
      convertCell(S.selectedId, 'css');
      return;
    }
    if (e.key === 't' && S.selectedId !== null) {
      e.preventDefault();
      convertCell(S.selectedId, 'html');
      return;
    }
  }

  // global: F1 help overlay
  if (e.key === 'F1') {
    e.preventDefault();
    $('#helpOverlay').classList.toggle('visible');
    return;
  }

  // close presentation mode on Escape
  if (e.key === 'Escape' && document.body.classList.contains('presenting')) {
    togglePresent();
    e.stopImmediatePropagation();
    return;
  }

  // close settings on Escape if visible
  if (e.key === 'Escape' && $('#settingsOverlay').classList.contains('visible')) {
    toggleSettings();
    e.stopImmediatePropagation();
    return;
  }

  // close help on Escape if visible
  if (e.key === 'Escape' && $('#helpOverlay').classList.contains('visible')) {
    $('#helpOverlay').classList.remove('visible');
    e.stopImmediatePropagation();
    return;
  }

  // global: Ctrl+S / Cmd+S
  if (e.key === 's' && (e.ctrlKey || e.metaKey)) {
    e.preventDefault();
    saveNotebook();
  }
});

// click to dismiss help
$('#helpOverlay').addEventListener('click', (e) => {
  if (e.target === $('#helpOverlay')) $('#helpOverlay').classList.remove('visible');
});

// click to select + close trays
document.addEventListener('click', (e) => {
  // close action trays if clicking outside their wrapper (wrapper = parent div with tray + button)
  const addTray = document.querySelector('.action-add-tray');
  const moreTray = document.querySelector('.action-more-tray');
  if (addTray && addTray.classList.contains('open') && !addTray.parentElement.contains(e.target)) {
    addTray.classList.remove('open');
  }
  if (moreTray && moreTray.classList.contains('open') && !moreTray.parentElement.contains(e.target)) {
    moreTray.classList.remove('open');
  }
  // close cell type pickers if clicking outside
  if (!e.target.closest('.cell-type-picker') && !e.target.closest('.cell-type')) {
    document.querySelectorAll('.cell-type-picker.open').forEach(el => el.classList.remove('open'));
  }
  // close cell insert pickers if clicking outside
  if (!e.target.closest('.cell-insert-picker')) {
    document.querySelectorAll('.cell-insert-picker').forEach(el => el.remove());
  }
  // close toolbar overflow menu if clicking outside
  const tbOverflow = document.querySelector('.toolbar-overflow');
  if (tbOverflow && tbOverflow.classList.contains('open') && !tbOverflow.contains(e.target)) {
    tbOverflow.classList.remove('open');
  }
  // close save tray if clicking outside
  const saveTray = document.getElementById('saveTray');
  if (saveTray && saveTray.classList.contains('open') && !saveTray.parentElement.contains(e.target)) {
    saveTray.classList.remove('open');
  }

  const cellEl = e.target.closest('.cell');
  if (cellEl) {
    const id = parseInt(cellEl.dataset.id);
    selectCell(id);
  }
});

// late import to avoid circular dependency at module load time

// -- goto.js --

// ── GOTO ── @optional

function parseGoto(code) {
  const m = code.match(/^\s*\/\/\s*%goto\b\s*(.*)/m);
  if (!m) return null;
  return m[1].trim() || '';
}

const MAX_VISITS = 1000;
let visits = {};

window._dagStart = function() {
  visits = {};
  window._lastGotoTarget = null;
};

window._beforeExec = function(cell) {
  const target = parseGoto(cell.code);
  if (target !== null) {
    S.scope.__goto = target;
    cell.defines.add('__goto');
  } else {
    delete S.scope.__goto;
  }
};

window._afterExec = function(cell, index) {
  const gotoTarget = S.scope.__goto;
  delete S.scope.__goto;
  window._lastGotoTarget = null;

  if (!gotoTarget) return -1;

  // resolve by cellName
  const targetIdx = S.cells.findIndex(c => parseCellName(c.code) === gotoTarget);
  if (targetIdx < 0) {
    const out = cell.el.querySelector('.cell-output');
    if (out) {
      out.appendChild(document.createTextNode('\ngoto: cell \u201c' + gotoTarget + '\u201d not found'));
      out.classList.add('error');
    }
    return -1;
  }

  // loop protection
  const key = index + ':' + targetIdx;
  visits[key] = (visits[key] || 0) + 1;
  if (visits[key] > MAX_VISITS) {
    const out = cell.el.querySelector('.cell-output');
    if (out) {
      out.appendChild(document.createTextNode('\ngoto: loop limit reached (' + MAX_VISITS + ' iterations)'));
      out.classList.add('error');
    }
    return -1;
  }

  window._lastGotoTarget = targetIdx;
  return targetIdx;
};

// -- size-compare.js --

// ── SIZE COMPARISON ── @optional

const SIZE_MEDIA = [
  [4096, 'an Atari 2600 cartridge'],
  [49152, 'a ZX Spectrum tape'],
  [73728, 'Apollo AGC rope memory'],
  [81920, 'an 8\u2033 floppy (SS/SD)'],
  [262144, 'an NES cartridge'],
  [368640, 'a 5.25\u2033 floppy (DS/DD)'],
  [737280, 'a 3.5\u2033 floppy (DS/DD)'],
  [1228800, 'a 5.25\u2033 floppy (DS/HD)'],
  [1474560, 'a 3.5\u2033 floppy (DS/HD)'],
];

function sizeCompare(bytes) {
  if (!window._sizeCompare) return '';
  for (const [size, name] of SIZE_MEDIA) {
    if (bytes <= size) return 'fits on ' + name;
  }
  const n = Math.ceil(bytes / 1474560);
  return n + '\u00d7 3.5\u2033 floppies';
}

function applySizeCompare(val) {
  const on = val === true || val === 'true' || val === 'on';
  window._sizeCompare = on;
  const el = $('#setSizeCompare');
  if (el) el.value = on ? 'on' : 'off';
  updateStatus();
}

function applySizeCompareRef(val) {
  window._sizeCompareRef = val === 'content' ? 'content' : 'total';
  const el = $('#setSizeCompareRef');
  if (el) el.value = window._sizeCompareRef;
  updateStatus();
}

// inject settings rows before modules section
(function() {
  const panel = $('#settingsPanel');
  if (!panel) return;
  const headings = panel.querySelectorAll('h2');
  const modulesH2 = headings[headings.length - 1];
  if (!modulesH2) return;

  const h2 = document.createElement('h2');
  h2.textContent = 'status bar';
  modulesH2.before(h2);

  const refRow = document.createElement('div');
  refRow.className = 'settings-row';
  refRow.innerHTML = '<label>size reference</label>' +
    '<select id="setSizeCompareRef" onchange="applySizeCompareRef(this.value)">' +
    '<option value="total" selected>total file</option>' +
    '<option value="content">content only</option></select>';
  modulesH2.before(refRow);

  const row = document.createElement('div');
  row.className = 'settings-row';
  row.innerHTML = '<label>size comparison</label>' +
    '<select id="setSizeCompare" onchange="applySizeCompare(this.value)">' +
    '<option value="off">off</option><option value="on" selected>on</option></select>';
  modulesH2.before(row);

  window._sizeCompare = true;
  window._sizeCompareRef = 'total';
})();

// -- globals.js --

// ── GLOBAL BINDINGS ──
// This module wires exported functions to window.* for use by onclick/onchange
// handlers in template HTML and dynamically generated markup.
// Modules stay pure (no side effects, no window assignments).











// state
window.$ = $;
window.S = S;

// editor
window.toggleAutorun = toggleAutorun;

// settings
window.toggleSettings = toggleSettings;
window.togglePresent = togglePresent;
window.applyTheme = applyTheme;
window.applyFontSize = applyFontSize;
window.applyWidth = applyWidth;
window.applyLineNumbers = applyLineNumbers;
window.applyHeader = applyHeader;
window.applyExecMode = applyExecMode;
window.applyRunOnLoad = applyRunOnLoad;
window.applyShowToggle = applyShowToggle;
window.applyGlobalExecMode = applyGlobalExecMode;
window.applyGlobalRunOnLoad = applyGlobalRunOnLoad;

// update
window.toggleUpdate = toggleUpdate;
window.checkForUpdate = checkForUpdate;
window.applyOnlineUpdate = applyOnlineUpdate;
window.proceedUpdate = proceedUpdate;
window.cancelUpdate = cancelUpdate;
window.updateFromFile = updateFromFile;

// save
window.saveNotebook = saveNotebook;
window.savePackedNotebook = savePackedNotebook;
window.setSaveMode = setSaveMode;
window.toggleSaveTray = toggleSaveTray;
window.exportAsTxt = exportAsTxt;

// exec
window.runAll = runAll;

// ui
window.insertAt = insertAt;

// find
window.openFind = openFind;
window.closeFind = closeFind;

// stdlib
window.__auditable_registerProvider = registerProvider;

// keyboard / toolbar
window.addCellWithUndo = addCellWithUndo;
window.deleteCellWithUndo = deleteCellWithUndo;
window.runSelectedCell = runSelectedCell;
window.toggleToolbarMenu = toggleToolbarMenu;
window.toggleAddTray = toggleAddTray;
window.toggleMoreTray = toggleMoreTray;
window.showInsertPicker = showInsertPicker;
window.toggleTypePicker = toggleTypePicker;
window.collapseAll = collapseAll;
window.expandAll = expandAll;
window.newNotebook = newNotebook;

// -- init.js --

// ── INIT ──

(function init() {
  // detect packed format (meta tag injected by loader)
  const packedMeta = document.querySelector('meta[name="auditable-packed"]');
  if (packedMeta) {
    packedMeta.remove();
    setBadge('packed', 'packed', 'toolbar-badge toolbar-badge-packed');
    setSaveMode('packed');
  }

  if (!loadFromEmbed()) {
    addCell('md', '');
    addCell('code', '');
  }
  S.initialized = true;
})();

// ── AF BRIDGE ──
// When running inside AF shell (iframe), establish postMessage communication.
// No-op when running standalone (window.parent === window).
//
// Message protocol (notebook ↔ AF shell):
//   af:ready          → sent on init with { title }
//   af:serialize      ← received to trigger saveNotebook()
//   af:saved          ← received after save (shows "saved" status)
//   af:setTitle       ← received to update docTitle input
//   af:resize         ← received when iframe becomes visible (recalc textareas)
//   af:titleChanged   → sent when user edits the title
//   af:fileRequest    → sent to request file picker { id, accept }
//   af:fileResult     ← received with picked file { id, file }
//   af:download       → sent to request download { data, filename, mimeType }
//   af:dirty          → sent when notebook has unsaved changes

(function afBridge() {
  if (window.parent === window) return;
  window.__AF_BRIDGE__ = true;

  // register AF-specific providers for file/download
  registerProvider('file', (accept) => {
    return new Promise((resolve) => {
      const id = 'af_file_' + Date.now();
      function handler(e) {
        if (e.data?.type === 'af:fileResult' && e.data.payload?.id === id) {
          window.removeEventListener('message', handler);
          resolve(e.data.payload.file);
        }
      }
      window.addEventListener('message', handler);
      window.parent.postMessage({ type: 'af:fileRequest', payload: { id, accept } }, '*');
    });
  });

  registerProvider('download', (data, filename, mimeType) => {
    const str = typeof data === 'string' ? data : JSON.stringify(data, null, 2);
    const mime = mimeType || (typeof data === 'string' ? 'text/plain' : 'application/json');
    window.parent.postMessage({
      type: 'af:download',
      payload: { data: str, filename, mimeType: mime }
    }, '*');
  });

  const title = document.getElementById('docTitle')?.value || 'untitled';
  window.parent.postMessage({ type: 'af:ready', payload: { title } }, '*');

  window.addEventListener('message', (e) => {
    const msg = e.data;
    if (!msg?.type) return;
    if (msg.type === 'af:serialize') saveNotebook();
    else if (msg.type === 'af:saved') setMsg('saved', 'ok');
    else if (msg.type === 'af:setTitle') {
      const input = document.getElementById('docTitle');
      if (input && msg.payload?.title) input.value = msg.payload.title;
    } else if (msg.type === 'af:resize') {
      // recalculate textarea heights after becoming visible
      document.querySelectorAll('textarea').forEach(ta => {
        ta.style.height = 'auto';
        ta.style.height = ta.scrollHeight + 'px';
        const hl = ta.parentElement?.querySelector('.highlight-layer');
        if (hl) hl.style.height = ta.style.height;
      });
    }
  });

  document.getElementById('docTitle')?.addEventListener('input', () => {
    window.parent.postMessage({
      type: 'af:titleChanged',
      payload: { title: document.getElementById('docTitle').value }
    }, '*');
  });
})();
</script>
</body>
<!-- good luck out there -->
</html>
