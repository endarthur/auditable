{
  "format": "auditable-notebook",
  "v": 1,
  "title": "shader playground",
  "cells": [
    {
      "type": "code",
      "collapsed": true,
      "code": "// %collapsed\nworkshop([\n  {\n    title: 'Shader playground',\n    content: md`This is a guided **workshop** for this notebook.\nUse the **prev** and **next** buttons below to navigate\nbetween pages, or click the progress dots to jump directly.\n\nClose this panel with the **\\u00d7** button. Reopen it\nanytime with the **workshop** tab on the right edge\nof the screen.`\n  },\n  {\n    title: 'Manual cells & glsl tag',\n    content: md`This cell is \\`// %manual\\` because the\nshader runs a continuous animation loop. Re-running\non every slider drag would destroy and recreate the\nWebGL context.\n\nThe \\`glsl\\` tag from \\`@auditable/shader\\` provides\n**syntax highlighting** and **completions** for GLSL\ncode inside the template literal. It\\u2019s a tagged\nlanguage extension, like \\`sql\\`.`\n  },\n  {\n    title: 'Real-time uniforms',\n    content: md`The sliders use \\`onInput\\` callbacks to\ncall \\`s.set(name, value)\\` directly. This updates\nthe shader uniform **on the GPU** without recompiling\nthe shader or re-running the cell.\n\nThis is the fastest feedback path: slider event\n\\u2192 callback \\u2192 \\`gl.uniform*()\\` \\u2192 next frame\nrenders with new value. No DAG, no scope rebuild,\nno JavaScript re-execution.`\n  },\n  {\n    title: 'Cleanup with invalidation',\n    content: md`\\`invalidation.then(() => s.destroy())\\`\nensures the WebGL context and animation loop are\ncleaned up before any re-run.\n\nThe \\`shader()\\` helper manages Shadertoy-compatible\nbuiltins (\\`iTime\\`, \\`iResolution\\`, \\`iMouse\\`) and\nthe render loop. \\`s.destroy()\\` stops the\n\\`requestAnimationFrame\\` loop and releases GPU\nresources. Always pair long-lived resources with\n\\`invalidation\\`.`\n  },\n])"
    },
    {
      "type": "md",
      "code": "# shader playground\n\na Shadertoy-compatible WebGL 2 shader running in a single cell. the `@auditable/shader` extension injects `iTime`, `iResolution`, `iMouse` and other builtins automatically â€” just write `mainImage`. the `glsl` tag provides syntax highlighting and completions inside the template literal.\n\nthe sliders use `onInput` callbacks to update custom uniforms in real time, with zero DAG overhead."
    },
    {
      "type": "code",
      "code": "// %manual\nconst { shader, glsl } = await load(\"./ext/shader/index.js\");\n\nconst c = ui.canvas(600, 400);\nconst col = [0.78, 0.61, 0.24];\n\nconst s = shader(c, glsl`\n  void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    float t = iTime * speed;\n\n    // layered sine waves\n    float r = 0.5 + 0.5 * sin(uv.x * 6.0 + t);\n    float g = 0.5 + 0.5 * sin(uv.y * 6.0 + t * 1.3 + 2.0);\n    float b = 0.5 + 0.5 * sin((uv.x + uv.y) * 4.0 + t * 0.7 + 4.0);\n\n    // mix with custom color\n    vec3 base = vec3(r, g, b);\n    fragColor = vec4(mix(base, color, 0.4), 1.0);\n  }\n`, {\n  uniforms: { speed: 1.0, color: col }\n});\n\nui.slider(\"speed\", 1.0, {min: 0.1, max: 5.0, step: 0.1, onInput: v => s.set(\"speed\", v)});\nui.slider(\"red\",   0.78, {min: 0, max: 1, step: 0.01, onInput: v => { col[0] = v; s.set(\"color\", col); }});\nui.slider(\"green\", 0.61, {min: 0, max: 1, step: 0.01, onInput: v => { col[1] = v; s.set(\"color\", col); }});\nui.slider(\"blue\",  0.24, {min: 0, max: 1, step: 0.01, onInput: v => { col[2] = v; s.set(\"color\", col); }});\n\ninvalidation.then(() => s.destroy());"
    }
  ],
  "settings": {
    "theme": "dark",
    "fontSize": 13,
    "width": "860"
  },
  "modules": {
    "./ext/shader/index.js": {
      "ref": "ext/shader/index.js"
    }
  }
}
