/// auditable
/// title: atra — Wasm kernels
/// module: ./ext/atra/index.js ext/atra/index.js

/// md
# atra — WebAssembly numerical kernels

[atra](ext/atra/SPEC.md) is a Fortran/Pascal hybrid that compiles to WebAssembly bytecode via tagged template literals. no toolchain, no build step — one JS file turns formulas into bytecode.

this notebook computes a **spherical variogram model** and uses it to evaluate an **IDW-like weighted interpolation** over a grid, with the heavy loop running entirely in Wasm.

/// code
const { atra } = await load("./ext/atra/index.js");

/// code
// spherical variogram model + grid evaluator
// compiled to WebAssembly — all loops run as native Wasm

const range0 = ui.slider("range", 60, {min:10, max:200, step:1});
const sill0 = ui.slider("sill", 1.0, {min:0.1, max:3.0, step:0.1});
const nugget0 = ui.slider("nugget", 0.1, {min:0.0, max:1.0, step:0.05});
const nPts = ui.slider("samples", 30, {min:5, max:100, step:1});
const gridN = ui.slider("grid", 120, {min:40, max:250, step:10});

/// code
// compile atra kernels to Wasm
const mem = new WebAssembly.Memory({ initial: 4 }); // 256 KB

const wasm = atra({ memory: mem })`
  const PI: f64 = 3.141592653589793

  ! spherical variogram model: γ(h) = c0 + c1 * (1.5h/a - 0.5(h/a)^3)
  function spherical(h, a, c1, c0: f64): f64
  begin
    if (h <= 0.0) then
      spherical := 0.0
    else if (h >= a) then
      spherical := c0 + c1
    else
      spherical := c0 + c1 * (1.5 * h / a - 0.5 * (h / a) ** 3)
    end if
  end

  ! weighted interpolation over a grid using variogram-based weights
  ! samples: [x0, y0, v0, x1, y1, v1, ...] (f64 triples)
  ! grid: row-major f64 output, gridN * gridN entries
  subroutine eval_grid(
    samples: array f64; nSamples: i32;
    grid: array f64; gridN: i32;
    a, c1, c0: f64
  )
  var
    ix, iy, k: i32
    gx, gy, dx, dy, dist, gamma, w, wsum, vsum: f64
  begin
    for iy := 0, gridN
      for ix := 0, gridN
        gx := f64(ix) / f64(gridN)
        gy := f64(iy) / f64(gridN)
        wsum := 0.0
        vsum := 0.0
        for k := 0, nSamples
          dx := gx - samples[k * 3]
          dy := gy - samples[k * 3 + 1]
          dist := sqrt(dx * dx + dy * dy)
          if (dist < 1e-10) then
            wsum := 1.0
            vsum := samples[k * 3 + 2]
            break
          end if
          gamma := spherical(dist, a, c1, c0)
          if (gamma > 0.0) then
            w := 1.0 / gamma
          else
            w := 1e10
          end if
          wsum += w
          vsum += w * samples[k * 3 + 2]
        end for
        grid[iy * gridN + ix] := vsum / wsum
      end for
    end for
  end
`;

/// code
// generate seeded samples + run Wasm kernel
function mulberry32(a) {
  return function() {
    a |= 0; a = a + 0x6D2B79F5 | 0;
    let t = Math.imul(a ^ a >>> 15, 1 | a);
    t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
    return ((t ^ t >>> 14) >>> 0) / 4294967296;
  };
}
const rng = mulberry32(42);

// pack samples into Wasm memory as f64 triples
const buf = new Float64Array(mem.buffer);
const samplesPtr = 0;
for (let i = 0; i < nPts; i++) {
  const x = rng(), y = rng();
  const trend = 0.5 * Math.sin(x * 4.0) * Math.cos(y * 3.0) + 0.5;
  buf[i * 3 + 0] = x;
  buf[i * 3 + 1] = y;
  buf[i * 3 + 2] = 0.3 * rng() + 0.7 * trend;
}

const gridPtr = nPts * 3 * 8; // after sample data

const t0 = performance.now();
wasm.eval_grid(samplesPtr, nPts, gridPtr, gridN, range0 / 200, sill0, nugget0);
const elapsed = (performance.now() - t0).toFixed(2);

// read grid back
const grid = new Float64Array(mem.buffer, gridPtr, gridN * gridN);

/// code
// render
const size = Math.min(500, window.innerWidth - 80);
const c = ui.canvas(size, size);
const ctx = c.getContext("2d");

function viridis(t) {
  t = Math.max(0, Math.min(1, t));
  const r = Math.round(255 * Math.max(0, Math.min(1,
    0.267 + t * (0.004 + t * (5.294 + t * (-14.05 + t * 8.5))))));
  const g = Math.round(255 * Math.max(0, Math.min(1,
    0.004 + t * (1.384 + t * (0.098 + t * (-2.74 + t * 2.23))))));
  const b = Math.round(255 * Math.max(0, Math.min(1,
    0.329 + t * (1.44 + t * (-5.11 + t * (6.87 + t * -3.57))))));
  return `rgb(${r},${g},${b})`;
}

let vmin = Infinity, vmax = -Infinity;
for (let i = 0; i < grid.length; i++) {
  if (grid[i] < vmin) vmin = grid[i];
  if (grid[i] > vmax) vmax = grid[i];
}
const vrange = vmax - vmin || 1;

const cellW = size / gridN;
for (let iy = 0; iy < gridN; iy++) {
  for (let ix = 0; ix < gridN; ix++) {
    const t = (grid[iy * gridN + ix] - vmin) / vrange;
    ctx.fillStyle = viridis(t);
    ctx.fillRect(ix * cellW, iy * cellW, cellW + 0.5, cellW + 0.5);
  }
}

// overlay sample points
for (let i = 0; i < nPts; i++) {
  const x = buf[i * 3] * size, y = buf[i * 3 + 1] * size;
  ctx.beginPath();
  ctx.arc(x, y, 4, 0, Math.PI * 2);
  ctx.fillStyle = "#fff";
  ctx.fill();
  ctx.lineWidth = 1.5;
  ctx.strokeStyle = "#000";
  ctx.stroke();
}

ui.display(`${gridN}\u00d7${gridN} grid \u00b7 ${nPts} samples \u00b7 Wasm kernel: ${elapsed} ms`);

/// code
// variogram curve plot
const cvs = ui.canvas(500, 200);
const cx = cvs.getContext("2d");
const w = 500, h = 200, pad = 40;

cx.fillStyle = "#181818";
cx.fillRect(0, 0, w, h);

// axes
cx.strokeStyle = "#555";
cx.lineWidth = 1;
cx.beginPath();
cx.moveTo(pad, h - pad); cx.lineTo(w - 10, h - pad);
cx.moveTo(pad, h - pad); cx.lineTo(pad, 10);
cx.stroke();

cx.fillStyle = "#999";
cx.font = "11px monospace";
cx.fillText("h", w - 20, h - pad + 4);
cx.fillText("\u03b3(h)", pad - 4, 14);

// plot spherical model curve
const maxH = 1.2;
const maxG = nugget0 + sill0 * 1.15;
cx.strokeStyle = "#c89b3c";
cx.lineWidth = 2;
cx.beginPath();
for (let i = 0; i <= 200; i++) {
  const hv = (i / 200) * maxH;
  const gv = wasm.spherical(hv, range0 / 200, sill0, nugget0);
  const px = pad + (hv / maxH) * (w - pad - 10);
  const py = (h - pad) - (gv / maxG) * (h - pad - 20);
  if (i === 0) cx.moveTo(px, py); else cx.lineTo(px, py);
}
cx.stroke();

// tick labels
cx.fillStyle = "#888";
for (let i = 0; i <= 4; i++) {
  const hv = (i / 4) * maxH;
  const px = pad + (hv / maxH) * (w - pad - 10);
  cx.fillText(hv.toFixed(2), px - 12, h - pad + 14);
}
for (let i = 0; i <= 3; i++) {
  const gv = (i / 3) * maxG;
  const py = (h - pad) - (gv / maxG) * (h - pad - 20);
  cx.fillText(gv.toFixed(2), 2, py + 4);
}

/// md
**how it works:** the `atra` tagged template compiles a spherical variogram model and a grid evaluator to WebAssembly bytecode — no toolchain, just `atra\`...\``. sample data is packed into Wasm linear memory as `f64` triples, and the nested loop runs as native Wasm instructions. the resulting grid is rendered with a viridis colormap.
