/// auditable
/// title: atra layouts — N-body gravity
/// module: ./ext/atra/index.js ext/atra/index.js

/// md
# atra layouts — N-body gravity

**layouts** define struct-like memory layouts that both JS and atra agree on. field offsets are computed at compile time — zero Wasm instructions, zero runtime cost. this notebook simulates N-body gravitational attraction using a `Body` layout with position, velocity, and mass fields.

/// code
const { atra } = await load("./ext/atra/index.js");

/// code
const N = ui.slider("bodies", 80, {min: 10, max: 300, step: 5});
const dt = ui.slider("dt", 0.0003, {min: 0.0001, max: 0.001, step: 0.0001});
const softening = ui.slider("softening", 0.005, {min: 0.001, max: 0.02, step: 0.001});
const G = ui.slider("G", 1.0, {min: 0.1, max: 5.0, step: 0.1});

/// code
// compile N-body kernel — layouts define the memory format
const mem = new WebAssembly.Memory({ initial: 4 });

const wasm = atra({ memory: mem })`
  ! a Body has position, velocity, and mass
  layout Body
    px, py: f64
    vx, vy: f64
    mass: f64
  end layout

  ! compute gravitational forces and integrate all bodies
  ! body 0 is the fixed central mass — skip its integration
  subroutine step(bodies: i32, n: i32, dt, softening, G: f64)
  var i, j: i32, b, o: layout Body
      dx, dy, r2, r, f, fx, fy: f64
  begin
    for i := 1, n
      b := bodies + i * Body.__size
      fx := 0.0
      fy := 0.0
      for j := 0, n
        if (i /= j) then
          o := bodies + j * Body.__size
          dx := o.px - b.px
          dy := o.py - b.py
          r2 := dx * dx + dy * dy + softening
          r := sqrt(r2)
          f := G * o.mass / (r2 * r)
          fx += f * dx
          fy += f * dy
        end if
      end for
      b.vx := b.vx + fx * dt
      b.vy := b.vy + fy * dt
      b.px := b.px + b.vx * dt
      b.py := b.py + b.vy * dt
    end for
  end

  ! compute total kinetic energy
  function kinetic(bodies: i32, n: i32): f64
  var i: i32, b: layout Body, v2: f64
  begin
    kinetic := 0.0
    for i := 0, n
      b := bodies + i * Body.__size
      v2 := b.vx * b.vx + b.vy * b.vy
      kinetic := kinetic + 0.5 * b.mass * v2
    end for
  end
`;

// the compiler exposes layout metadata — JS and Wasm agree on offsets
const { Body } = wasm.__layouts;
ui.display(`Body layout: __size=${Body.__size}, px@${Body.px}, py@${Body.py}, vx@${Body.vx}, vy@${Body.vy}, mass@${Body.mass}`);

/// code
// %manual
// initialize bodies in a disk with orbital velocities
const f64 = new Float64Array(mem.buffer);

function mulberry32(a) {
  return function() {
    a |= 0; a = a + 0x6D2B79F5 | 0;
    let t = Math.imul(a ^ a >>> 15, 1 | a);
    t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
    return ((t ^ t >>> 14) >>> 0) / 4294967296;
  };
}
const rng = mulberry32(1337);

const STRIDE = Body.__size / 8; // stride in f64 units
const bodiesPtr = 0;

// central massive body
const cx = 0.5, cy = 0.5;
f64[0 * STRIDE + Body.px / 8] = cx;
f64[0 * STRIDE + Body.py / 8] = cy;
f64[0 * STRIDE + Body.vx / 8] = 0;
f64[0 * STRIDE + Body.vy / 8] = 0;
f64[0 * STRIDE + Body.mass / 8] = 500;

// orbiting bodies
for (let i = 1; i < N; i++) {
  const angle = rng() * Math.PI * 2;
  const r = 0.08 + rng() * 0.35;
  const px = cx + r * Math.cos(angle);
  const py = cy + r * Math.sin(angle);
  // orbital velocity (tangential)
  const speed = Math.sqrt(G * 500 / r) * (0.8 + 0.4 * rng());
  const vx = -speed * Math.sin(angle);
  const vy = speed * Math.cos(angle);
  const mass = 0.5 + rng() * 2;
  f64[i * STRIDE + Body.px / 8] = px;
  f64[i * STRIDE + Body.py / 8] = py;
  f64[i * STRIDE + Body.vx / 8] = vx;
  f64[i * STRIDE + Body.vy / 8] = vy;
  f64[i * STRIDE + Body.mass / 8] = mass;
}

// render loop
const W = Math.min(560, window.innerWidth - 80), H = W;
const c = ui.canvas(W, H);
const ctx = c.getContext("2d");

const trail = ui.canvas(W, H);
trail.style.display = "none";
const tctx = trail.getContext("2d");
tctx.fillStyle = "rgba(10, 10, 10, 1)";
tctx.fillRect(0, 0, W, H);

let stepsPerFrame = 8;
let raf;
function frame() {
  for (let s = 0; s < stepsPerFrame; s++) {
    wasm.step(bodiesPtr, N, dt, softening, G);
  }

  // fade trails
  tctx.fillStyle = "rgba(10, 10, 10, 0.06)";
  tctx.fillRect(0, 0, W, H);

  // draw bodies on trail canvas
  const buf = new Float64Array(mem.buffer);
  for (let i = 0; i < N; i++) {
    const px = buf[i * STRIDE + Body.px / 8];
    const py = buf[i * STRIDE + Body.py / 8];
    const mass = buf[i * STRIDE + Body.mass / 8];
    const x = px * W, y = py * H;
    if (x < -50 || x > W + 50 || y < -50 || y > H + 50) continue;
    const radius = i === 0 ? 4 : Math.max(1, Math.sqrt(mass) * 0.8);
    const hue = i === 0 ? 45 : (180 + i * 137.508) % 360;
    const lum = i === 0 ? 70 : 55;
    tctx.fillStyle = `hsl(${hue}, 75%, ${lum}%)`;
    tctx.beginPath();
    tctx.arc(x, y, radius, 0, Math.PI * 2);
    tctx.fill();
  }

  // copy to display canvas
  ctx.drawImage(trail, 0, 0);

  raf = requestAnimationFrame(frame);
}
frame();
invalidation.then(() => cancelAnimationFrame(raf));

/// md
**how it works:** the `Body` layout defines five f64 fields (px, py, vx, vy, mass). atra computes field offsets at compile time and exposes them via `__layouts` — JS uses these same offsets to initialize memory and read positions for rendering. the Wasm kernel accesses fields with `b.px`, `b.vx` etc., which compile to `i32.load`/`f64.load` at the correct byte offset. both sides stay in sync from a single `layout` declaration.
