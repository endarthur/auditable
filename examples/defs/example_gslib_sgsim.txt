/// auditable
/// title: SGSIM — Gaussian simulation
/// module: @atra/gslib ext/atra/lib/gslib.js

/// md
# SGSIM — sequential Gaussian simulation

unconditional Gaussian simulation on a 2D grid, using the GSLIB `sgsim` program compiled to WebAssembly. each realization is a random field with the spatial correlation structure defined by the variogram. press **play** to cycle through realizations — every frame is a new seed.

/// code
// parameters — changing these re-initializes the simulation engine
const gridN = ui.slider("grid", 50, {min: 20, max: 80, step: 5});
const range0 = ui.slider("range", 10, {min: 2, max: 40, step: 1});

/// code collapsed
// initialize sgsim engine
const { sgsim } = await load("@atra/gslib");
const engine = sgsim({
  grid: { nx: gridN, ny: gridN, xsiz: 1, ysiz: 1 },
  variogram: { structures: [{ type: "spherical", contribution: 1.0, range: range0 }] },
  search: { radius: Math.max(range0 * 2, 20), ndmax: 10, nodmax: 12 },
});

/// code
// %manual
// simulation loop with play/pause controls
const NX_ = gridN, NY_ = gridN;

// canvas
const size = Math.min(500, window.innerWidth - 80);
const c = ui.canvas(size, size);
const ctx = c.getContext("2d");

// viridis colormap
function viridis(t) {
  t = Math.max(0, Math.min(1, t));
  const r = Math.round(255 * Math.max(0, Math.min(1,
    0.267 + t * (0.004 + t * (5.294 + t * (-14.05 + t * 8.5))))));
  const g = Math.round(255 * Math.max(0, Math.min(1,
    0.004 + t * (1.384 + t * (0.098 + t * (-2.74 + t * 2.23))))));
  const b = Math.round(255 * Math.max(0, Math.min(1,
    0.329 + t * (1.44 + t * (-5.11 + t * (6.87 + t * -3.57))))));
  return `rgb(${r},${g},${b})`;
}

let seed = 69069;
let realNum = 0;
let playing = false, timer = null;

function runOne() {
  const t0 = performance.now();
  const sim = engine.run(seed);
  const elapsed = performance.now() - t0;

  // compute range
  let vmin = Infinity, vmax = -Infinity;
  for (let i = 0; i < sim.length; i++) {
    if (sim[i] < vmin) vmin = sim[i];
    if (sim[i] > vmax) vmax = sim[i];
  }
  const vrange = vmax - vmin || 1;

  // render grid
  const cellW = size / NX_;
  for (let iy = 0; iy < NY_; iy++) {
    for (let ix = 0; ix < NX_; ix++) {
      const v = sim[iy * NX_ + ix];
      ctx.fillStyle = viridis((v - vmin) / vrange);
      ctx.fillRect(ix * cellW, iy * cellW, cellW + 0.5, cellW + 0.5);
    }
  }

  realNum++;
  seed = (seed * 69069 + 1) & 0x7fffffff;
  genLabel.textContent = `realization ${realNum} \u00b7 ${elapsed.toFixed(1)} ms \u00b7 seed ${seed}`;
}

// controls
const genLabel = document.createElement("span");
genLabel.style.fontFamily = "monospace";

const btnStep = document.createElement("button");
btnStep.textContent = "step";
btnStep.onclick = () => { runOne(); };

const btnPlay = document.createElement("button");
btnPlay.textContent = "\u25b6 play";
btnPlay.onclick = () => {
  playing = !playing;
  btnPlay.textContent = playing ? "\u23f8 pause" : "\u25b6 play";
  if (playing) {
    timer = setInterval(runOne, 50);
  } else clearInterval(timer);
};

const btnReset = document.createElement("button");
btnReset.textContent = "reset";
btnReset.onclick = () => {
  playing = false; clearInterval(timer);
  btnPlay.textContent = "\u25b6 play";
  seed = 69069; realNum = 0;
  runOne();
};

const bar = document.createElement("div");
bar.style.cssText = "display:flex;gap:8px;margin:8px 0;align-items:center";
bar.append(btnStep, btnPlay, btnReset, genLabel);
ui.display(bar);

// cleanup on cell re-run
invalidation.then(() => { engine.dispose(); clearInterval(timer); });

// render first realization
runOne();

/// md
**how it works:** `sgsim` visits each grid node in a random order and draws a value from the conditional distribution given all previously simulated neighbors. the variogram defines the spatial correlation — longer **range** produces smoother fields. each realization is equally probable and honors the same two-point statistics (variogram model).

the engine initialization (super block search, covariance lookup table) runs once in a reactive cell. the simulation loop is a `// %manual` cell with play/pause controls — each frame calls `sgsim` with a new seed, generating a fresh realization entirely in WebAssembly.
