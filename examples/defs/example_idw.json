{
  "format": "auditable-notebook",
  "v": 1,
  "title": "IDW interpolation",
  "cells": [
    {
      "type": "code",
      "collapsed": true,
      "code": "// %collapsed\nworkshop([\n  {\n    title: 'IDW interpolation',\n    content: md`This is a guided **workshop** for this notebook.\nUse the **prev** and **next** buttons below to navigate\nbetween pages, or click the progress dots to jump directly.\n\nClose this panel with the **\\u00d7** button. Reopen it\nanytime with the **workshop** tab on the right edge\nof the screen.`\n  },\n  {\n    title: 'Multi-cell pipeline',\n    content: md`This notebook splits the work into four cells:\n**parameters \\u2192 samples \\u2192 interpolation \\u2192 rendering**.\nEach cell defines \\`const\\` values consumed by the next.\n\nThe DAG engine traces these dependencies automatically.\nChange the \\`power\\` slider \\u2192 parameter cell re-runs\n\\u2192 interpolation re-runs \\u2192 render re-runs. The sample\ngeneration cell is skipped because \\`power\\` isn\\u2019t\nin its dependency set.`\n  },\n  {\n    title: 'Seeded RNG',\n    content: md`The sample cell uses a **seeded** pseudo-random\nnumber generator (Mulberry32) instead of\n\\`Math.random()\\`. This ensures the same samples\nappear every time the cell runs with the same\n\\`nSamples\\` value.\n\nWithout a seeded RNG, changing the \\`power\\` slider\nwould regenerate random samples (because the samples\ncell would re-run), making it impossible to compare\ninterpolation results.`\n  },\n  {\n    title: 'Canvas rendering',\n    content: md`The render cell iterates over a grid and fills\nrectangles with a colormap. \\`ui.canvas(size, size)\\`\ncreates the canvas, then standard Canvas 2D API calls\ndo the drawing.\n\nThe \\`showPts\\` checkbox conditionally overlays sample\npoints. Since it\\u2019s a reactive widget (no \\`onInput\\`),\ntoggling it re-runs only the render cell \\u2014 the\nexpensive interpolation is skipped because its inputs\ndidn\\u2019t change.`\n  },\n])"
    },
    {
      "type": "md",
      "code": "# inverse distance weighting\n\nan interactive IDW interpolation demo. drag the sliders to see the effect of **power** and **sample count** on the estimated surface."
    },
    {
      "type": "code",
      "code": "// parameters\nconst nSamples = ui.slider(\"samples\", 20, {min:5, max:80, step:1});\nconst power = ui.slider(\"power\", 2, {min:0.5, max:6, step:0.25});\nconst gridRes = ui.slider(\"grid size\", 100, {min:30, max:200, step:10});\nconst showPts = ui.checkbox(\"show samples\", true);"
    },
    {
      "type": "code",
      "code": "// seeded RNG + spatially structured samples\nfunction mulberry32(a) {\n  return function() {\n    a |= 0; a = a + 0x6D2B79F5 | 0;\n    let t = Math.imul(a ^ a >>> 15, 1 | a);\n    t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;\n    return ((t ^ t >>> 14) >>> 0) / 4294967296;\n  };\n}\nconst rng = mulberry32(42);\n\nconst samples = Array.from({length: nSamples}, () => {\n  const x = rng(), y = rng();\n  const trend = 0.5 * Math.sin(x * 3.5) * Math.cos(y * 2.8) + 0.5;\n  return { x, y, v: 0.4 * rng() + 0.6 * trend };\n});"
    },
    {
      "type": "code",
      "code": "// IDW interpolation\nfunction idw(px, py, pts, p) {\n  let wsum = 0, vsum = 0;\n  for (const s of pts) {\n    const dx = px - s.x, dy = py - s.y;\n    const d2 = dx * dx + dy * dy;\n    if (d2 < 1e-12) return s.v;\n    const w = 1 / Math.pow(Math.sqrt(d2), p);\n    wsum += w;\n    vsum += w * s.v;\n  }\n  return vsum / wsum;\n}\n\nconst grid = new Float64Array(gridRes * gridRes);\nfor (let iy = 0; iy < gridRes; iy++) {\n  for (let ix = 0; ix < gridRes; ix++) {\n    grid[iy * gridRes + ix] = idw(\n      (ix + 0.5) / gridRes,\n      (iy + 0.5) / gridRes,\n      samples, power\n    );\n  }\n}"
    },
    {
      "type": "code",
      "code": "// render\nconst size = Math.min(500, window.innerWidth - 80);\nconst c = ui.canvas(size, size);\nconst ctx = c.getContext(\"2d\");\n\n// viridis-ish colormap\nfunction viridis(t) {\n  t = Math.max(0, Math.min(1, t));\n  const r = Math.round(255 * Math.max(0, Math.min(1,\n    0.267 + t * (0.004 + t * (5.294 + t * (-14.05 + t * 8.5))))));\n  const g = Math.round(255 * Math.max(0, Math.min(1,\n    0.004 + t * (1.384 + t * (0.098 + t * (-2.74 + t * 2.23))))));\n  const b = Math.round(255 * Math.max(0, Math.min(1,\n    0.329 + t * (1.44 + t * (-5.11 + t * (6.87 + t * -3.57))))));\n  return `rgb(${r},${g},${b})`;\n}\n\nlet vmin = Infinity, vmax = -Infinity;\nfor (let i = 0; i < grid.length; i++) {\n  if (grid[i] < vmin) vmin = grid[i];\n  if (grid[i] > vmax) vmax = grid[i];\n}\nconst vrange = vmax - vmin || 1;\n\nconst cellW = size / gridRes;\nfor (let iy = 0; iy < gridRes; iy++) {\n  for (let ix = 0; ix < gridRes; ix++) {\n    const t = (grid[iy * gridRes + ix] - vmin) / vrange;\n    ctx.fillStyle = viridis(t);\n    ctx.fillRect(ix * cellW, iy * cellW, cellW + 0.5, cellW + 0.5);\n  }\n}\n\nif (showPts) {\n  for (const s of samples) {\n    ctx.beginPath();\n    ctx.arc(s.x * size, s.y * size, 4, 0, Math.PI * 2);\n    ctx.fillStyle = \"#fff\";\n    ctx.fill();\n    ctx.lineWidth = 1.5;\n    ctx.strokeStyle = \"#000\";\n    ctx.stroke();\n  }\n}\n\nui.display(`${gridRes}\\u00d7${gridRes} grid \\u00b7 ${nSamples} samples \\u00b7 p=${power} \\u00b7 range [${vmin.toFixed(3)}, ${vmax.toFixed(3)}]`);"
    }
  ],
  "settings": {
    "theme": "dark",
    "fontSize": 13,
    "width": "860"
  }
}
