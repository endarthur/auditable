/// title: python mode

/// code collapsed
// %collapsed
workshop([
  {
    title: 'Python mode',
    content: md`This is a guided **workshop** for this notebook.
Use the **prev** and **next** buttons below to navigate
between pages, or click the progress dots to jump directly.

Close this panel with the **\u00d7** button. Reopen it
anytime with the **workshop** tab on the right edge
of the screen.`
  },
  {
    title: 'Virtual modules',
    content: md`\`load("@python")\` imports a **virtual
module** \u2014 it\u2019s not a URL, it\u2019s a built-in module
bundled with auditable. Virtual modules use the
\`@\` prefix: \`@python\`, \`@std\`, \`@python/this\`.

The Python module provides \`range\`, \`enumerate\`,
\`sorted\`, \`reversed\`, \`len\`, and other Python-like
utilities that work on JavaScript arrays and
iterables.`
  },
  {
    title: 'Pythonic JavaScript',
    content: md`The imported functions make JS read like
Python: \`for (const [i, x] of enumerate(arr))\`,
\`sorted(data, key)\`, \`range(0, 10, 2)\`.

Semicolons are optional in JS (the engine inserts
them via ASI). This example omits them for a more
Pythonic feel. \`print\` is a built-in alias for
\`ui.display\` \u2014 no import needed.`
  },
  {
    title: 'The std library',
    content: md`Every cell receives \`std\` as an injected
parameter. It provides statistical functions:
\`std.mean\`, \`std.median\`, \`std.extent\`,
\`std.sum\`, \`std.bin\`, \`std.linspace\`, and more.

You can also \`load("@std")\` to destructure specific
functions. The \`std\` object and \`@python\`
complement each other \u2014 Python-style iteration
plus statistical aggregation.`
  },
])

/// md
# python mode

`load("@python")` gives you `range`, `enumerate`, `sorted`, `reversed`, `len` and more — so your JS can read like Python. `print` is a built-in alias for `ui.display`.

note: semicolons are idiomatic JS but not required — the browser engine inserts them automatically (ASI). this example skips them for a more pythonic feel.

/// code
const { range, enumerate, sorted, reversed, len } = await load("@python")

/// code
// generate some fake sensor data
const sensors = []
for (const i of range(20)) {
  sensors.push({
    id: `sensor-${i}`,
    temp: 18 + Math.random() * 15,
    humidity: 30 + Math.random() * 60,
    active: Math.random() > 0.2
  })
}

print(`generated ${len(sensors)} sensors`)

/// code
// filter & sort — pythonic style
const active = sensors.filter(s => s.active)
const by_temp = sorted(active, s => s.temp)
const by_temp_desc = reversed(by_temp)

print(`${len(active)} of ${len(sensors)} sensors active`)
print(`coldest: ${by_temp[0].id} at ${by_temp[0].temp.toFixed(1)}\u00b0C`)
print(`hottest: ${by_temp_desc[0].id} at ${by_temp_desc[0].temp.toFixed(1)}\u00b0C`)

/// code
// enumerate for indexed iteration
const top5 = by_temp_desc.slice(0, 5)

print("\n\u2014 top 5 hottest sensors \u2014")
for (const [i, s] of enumerate(top5)) {
  print(`  ${i + 1}. ${s.id}  ${s.temp.toFixed(1)}\u00b0C  ${s.humidity.toFixed(0)}% RH`)
}

/// code
// combine with std for stats
print(`\nmean temp:   ${std.mean(active, s => s.temp).toFixed(1)}\u00b0C`)
print(`median temp: ${std.median(active, s => s.temp).toFixed(1)}\u00b0C`)

const [lo, hi] = std.extent(active, s => s.humidity)
print(`humidity range: ${lo.toFixed(0)}% \u2013 ${hi.toFixed(0)}%`)

/// code
// range for quick sequences
print("range(5):         " + range(5))
print("range(2, 8):      " + range(2, 8))
print("range(0, 20, 3):  " + range(0, 20, 3))
print("range(10, 0, -2): " + range(10, 0, -2))

/// code
// the easter egg
await load("@python/this")
