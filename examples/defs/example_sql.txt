/// title: SQL notebook
/// module: ./ext/sql/index.js ext/sql/index.js

/// code collapsed
// %collapsed
workshop([
  {
    title: 'SQL notebook',
    content: md`This is a guided **workshop** for this notebook.
Use the **prev** and **next** buttons below to navigate
between pages, or click the progress dots to jump directly.

Close this panel with the **\u00d7** button. Reopen it
anytime with the **workshop** tab on the right edge
of the screen.`
  },
  {
    title: 'installBinary()',
    content: md`\`installBinary(url)\` fetches a binary
asset (here, the SQLite WASM file), gzip-compresses
it, and stores it as base64 in the notebook HTML.

On subsequent loads, the binary is decoded from the
embedded data \u2014 no network fetch needed. This is
how a 1+ MB WASM file loads instantly from a saved
notebook. The returned blob URL has the correct MIME
type for \`fetch()\`.`
  },
  {
    title: 'Tagged language extensions',
    content: md`The \`sql\` tag from \`@auditable/sql\`
provides **syntax highlighting** and **completions**
inside template literals. When you type
\`sql\`\`SELECT ...\`\`, the editor highlights SQL
keywords, types, and functions.

Language extensions register via
\`window._taggedLanguages\`. Each provides
\`tokenize(code)\` for highlighting and
\`completions()\` for autocomplete. The \`glsl\` tag
from \`@auditable/shader\` works the same way.`
  },
  {
    title: 'Reactive queries',
    content: md`The slider and dropdown define
\`minPop\` and \`sortBy\`. The query cells use these
values via template interpolation:
\`sql\`WHERE pop >= \${minPop}\`\`.

Change a filter \u2192 the query cell re-runs \u2192
results update \u2192 the table re-renders. The database
itself (\`db\`) is defined upstream and persists
across re-executions. Only the queries re-run, not
the table creation.`
  },
])

/// md
# SQL notebook

SQLite running entirely in the browser via **sql.js** (WebAssembly). the `sql` language tag from `@auditable/sql` provides syntax highlighting and completions inside template literals.

`installBinary()` embeds the WASM binary (gzip-compressed) — after saving, the 1+ MB asset loads instantly with no network fetch.

create tables, insert data, and query it — all reactive. change the filter and downstream cells re-run.

/// code
const { sql } = await load("./ext/sql/index.js");
const wasmUrl = await installBinary("https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.12.0/sql-wasm.wasm");
const wasmBinary = new Uint8Array(await fetch(wasmUrl).then(r => r.arrayBuffer()));
const initSqlJs = await load("https://esm.sh/sql.js@1.12.0");
const SQL = await initSqlJs.default({ wasmBinary });
const db = new SQL.Database();

/// code
db.run(sql`
  CREATE TABLE IF NOT EXISTS cities (
    name    TEXT PRIMARY KEY,
    country TEXT NOT NULL,
    pop     REAL,
    lat     REAL,
    lon     REAL
  )
`);

db.run(sql`DELETE FROM cities`);

const data = [
  ['Tokyo',        'Japan',      37.4,  35.68,  139.69],
  ['Delhi',        'India',      32.9,  28.61,   77.23],
  ['Shanghai',     'China',      29.2,  31.23,  121.47],
  ['S\u00e3o Paulo',    'Brazil',     22.6, -23.55,  -46.63],
  ['Mexico City',  'Mexico',     22.1,  19.43,  -99.13],
  ['Cairo',        'Egypt',      21.8,  30.04,   31.24],
  ['Mumbai',       'India',      21.7,  19.08,   72.88],
  ['Beijing',      'China',      21.5,  39.90,  116.41],
  ['Osaka',        'Japan',      19.1,  34.69,  135.50],
  ['New York',     'USA',        18.8,  40.71,  -74.01],
  ['Buenos Aires', 'Argentina',  15.4, -34.60,  -58.38],
  ['Lagos',        'Nigeria',    15.3,   6.52,    3.38],
  ['Istanbul',     'Turkey',     15.6,  41.01,   28.98],
  ['Manila',       'Philippines', 14.4, 14.60,  120.98],
  ['Guangzhou',    'China',      13.9,  23.13,  113.26],
];

const stmt = db.prepare(sql`INSERT INTO cities VALUES (?, ?, ?, ?, ?)`);
for (const row of data) { stmt.run(row); }
stmt.free();

ui.display(`loaded ${data.length} cities`);

/// code
const minPop = ui.slider("min population (M)", 15, {min: 5, max: 35, step: 0.5});
const sortBy = ui.dropdown("sort by", ["pop DESC", "name ASC", "lat DESC", "lon ASC"]);

/// code
const results = db.exec(sql`
  SELECT name, country, pop, lat, lon
  FROM cities
  WHERE pop >= ${minPop}
  ORDER BY ` + sortBy);

const rows = results[0] ? results[0].values.map(r => ({
  city: r[0], country: r[1], pop: r[2], lat: r[3], lon: r[4]
})) : [];

ui.table(rows);
ui.display(`${rows.length} cities with pop \u2265 ${minPop}M`);

/// code
// aggregate query
const stats = db.exec(sql`
  SELECT
    country,
    COUNT(*)       AS n,
    ROUND(SUM(pop), 1) AS total_pop,
    ROUND(AVG(pop), 1) AS avg_pop
  FROM cities
  WHERE pop >= ${minPop}
  GROUP BY country
  ORDER BY total_pop DESC
`);

const agg = stats[0] ? stats[0].values.map(r => ({
  country: r[0], cities: r[1], total_pop: r[2], avg_pop: r[3]
})) : [];

ui.table(agg);
