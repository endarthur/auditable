/// auditable
/// title: Lorenz attractor

/// code collapsed
// %collapsed
workshop([
  {
    title: 'Lorenz attractor',
    content: md`This is a guided **workshop** for this notebook.
Use the **prev** and **next** buttons below to navigate
between pages, or click the progress dots to jump directly.

Close this panel with the **\u00d7** button. Reopen it
anytime with the **workshop** tab on the right edge
of the screen.`
  },
  {
    title: 'Reactive DAG',
    content: md`This notebook has three cells: **parameters**,
**integration**, and **rendering**. They form a dependency
chain \u2014 the DAG (directed acyclic graph).

When you drag a slider, auditable detects which variables
changed, finds all downstream cells, and re-executes them
in topological order. You don\u2019t wire anything up \u2014
the DAG engine does it automatically.`
  },
  {
    title: 'Reactive widgets',
    content: md`\`ui.slider(label, default, opts)\` returns
the current numeric value. Without an \`onInput\` callback,
it\u2019s a **reactive widget**: changing it re-runs the cell
and all dependents.

The five sliders here (\u03c3, \u03c1, \u03b2, steps, rotation)
each define a \`const\`. Downstream cells that reference
those names are automatically re-executed when any
slider moves.`
  },
  {
    title: 'Multi-cell data flow',
    content: md`Cell 2 produces \`pts\` (the trajectory array).
Cell 3 consumes \`pts\`, \`rotation\`, \`steps\`, etc.
The DAG ensures cell 3 always sees fresh data.

Scope is passed **by value** \u2014 each cell gets its
upstream variables as function parameters. This means
you can\u2019t mutate a variable in one cell and see the
change in another. Design your data flow as immutable
pipelines.`
  },
])

/// md
# lorenz attractor

a 3D chaotic system rendered as a 2D projection. adjust the parameters and watch the butterfly change shape.

/// code
// parameters
const sigma = ui.slider("\u03c3 (sigma)", 10, {min:1, max:30, step:0.5});
const rho = ui.slider("\u03c1 (rho)", 28, {min:1, max:50, step:0.5});
const beta = ui.slider("\u03b2 (beta)", 2.667, {min:0.5, max:8, step:0.1});
const steps = ui.slider("steps", 8000, {min:1000, max:20000, step:500});
const rotation = ui.slider("rotation", 0, {min:0, max:360, step:1});

/// code
// integrate lorenz system
const dt = 0.005;
const pts = [];
let x = 0.1, y = 0, z = 0;

for (let i = 0; i < steps; i++) {
  const dx = sigma * (y - x);
  const dy = x * (rho - z) - y;
  const dz = x * y - beta * z;
  x += dx * dt;
  y += dy * dt;
  z += dz * dt;
  pts.push([x, y, z]);
}

/// code
// render with rotation and color gradient
const size = Math.min(600, window.innerWidth - 80);
const c = ui.canvas(size, size);
const ctx = c.getContext("2d");
ctx.fillStyle = "#0a0a0a";
ctx.fillRect(0, 0, size, size);

const rad = rotation * Math.PI / 180;
const cosR = Math.cos(rad), sinR = Math.sin(rad);

// project 3D to 2D with rotation around Z axis
function project(p) {
  const rx = p[0] * cosR - p[1] * sinR;
  const ry = p[0] * sinR + p[1] * cosR;
  return [rx, p[2]];
}

// find bounds
let xmin = Infinity, xmax = -Infinity;
let ymin = Infinity, ymax = -Infinity;
for (const p of pts) {
  const [px, py] = project(p);
  if (px < xmin) xmin = px;
  if (px > xmax) xmax = px;
  if (py < ymin) ymin = py;
  if (py > ymax) ymax = py;
}

const margin = 40;
const w = size - 2 * margin;
const scx = w / (xmax - xmin);
const scy = w / (ymax - ymin);
const sc = Math.min(scx, scy);

ctx.lineWidth = 0.5;
ctx.globalAlpha = 0.6;

for (let i = 1; i < pts.length; i++) {
  const [ax, ay] = project(pts[i - 1]);
  const [bx, by] = project(pts[i]);

  const t = i / pts.length;
  const r = Math.round(40 + 180 * t);
  const g = Math.round(100 + 100 * Math.sin(t * Math.PI));
  const b = Math.round(220 - 160 * t);

  ctx.strokeStyle = `rgb(${r},${g},${b})`;
  ctx.beginPath();
  ctx.moveTo(
    margin + (ax - xmin) * sc,
    margin + (ymax - ay) * sc
  );
  ctx.lineTo(
    margin + (bx - xmin) * sc,
    margin + (ymax - by) * sc
  );
  ctx.stroke();
}

ctx.globalAlpha = 1;
ui.display(`${steps} steps \u00b7 \u03c3=${sigma} \u03c1=${rho} \u03b2=${beta}`);
