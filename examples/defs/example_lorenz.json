{
  "format": "auditable-notebook",
  "v": 1,
  "title": "Lorenz attractor",
  "cells": [
    {
      "type": "code",
      "collapsed": true,
      "code": "// %collapsed\nworkshop([\n  {\n    title: 'Lorenz attractor',\n    content: md`This is a guided **workshop** for this notebook.\nUse the **prev** and **next** buttons below to navigate\nbetween pages, or click the progress dots to jump directly.\n\nClose this panel with the **\\u00d7** button. Reopen it\nanytime with the **workshop** tab on the right edge\nof the screen.`\n  },\n  {\n    title: 'Reactive DAG',\n    content: md`This notebook has three cells: **parameters**,\n**integration**, and **rendering**. They form a dependency\nchain \\u2014 the DAG (directed acyclic graph).\n\nWhen you drag a slider, auditable detects which variables\nchanged, finds all downstream cells, and re-executes them\nin topological order. You don\\u2019t wire anything up \\u2014\nthe DAG engine does it automatically.`\n  },\n  {\n    title: 'Reactive widgets',\n    content: md`\\`ui.slider(label, default, opts)\\` returns\nthe current numeric value. Without an \\`onInput\\` callback,\nit\\u2019s a **reactive widget**: changing it re-runs the cell\nand all dependents.\n\nThe five sliders here (\\u03c3, \\u03c1, \\u03b2, steps, rotation)\neach define a \\`const\\`. Downstream cells that reference\nthose names are automatically re-executed when any\nslider moves.`\n  },\n  {\n    title: 'Multi-cell data flow',\n    content: md`Cell 2 produces \\`pts\\` (the trajectory array).\nCell 3 consumes \\`pts\\`, \\`rotation\\`, \\`steps\\`, etc.\nThe DAG ensures cell 3 always sees fresh data.\n\nScope is passed **by value** \\u2014 each cell gets its\nupstream variables as function parameters. This means\nyou can\\u2019t mutate a variable in one cell and see the\nchange in another. Design your data flow as immutable\npipelines.`\n  },\n])"
    },
    {
      "type": "md",
      "code": "# lorenz attractor\n\na 3D chaotic system rendered as a 2D projection. adjust the parameters and watch the butterfly change shape."
    },
    {
      "type": "code",
      "code": "// parameters\nconst sigma = ui.slider(\"\\u03c3 (sigma)\", 10, {min:1, max:30, step:0.5});\nconst rho = ui.slider(\"\\u03c1 (rho)\", 28, {min:1, max:50, step:0.5});\nconst beta = ui.slider(\"\\u03b2 (beta)\", 2.667, {min:0.5, max:8, step:0.1});\nconst steps = ui.slider(\"steps\", 8000, {min:1000, max:20000, step:500});\nconst rotation = ui.slider(\"rotation\", 0, {min:0, max:360, step:1});"
    },
    {
      "type": "code",
      "code": "// integrate lorenz system\nconst dt = 0.005;\nconst pts = [];\nlet x = 0.1, y = 0, z = 0;\n\nfor (let i = 0; i < steps; i++) {\n  const dx = sigma * (y - x);\n  const dy = x * (rho - z) - y;\n  const dz = x * y - beta * z;\n  x += dx * dt;\n  y += dy * dt;\n  z += dz * dt;\n  pts.push([x, y, z]);\n}"
    },
    {
      "type": "code",
      "code": "// render with rotation and color gradient\nconst size = Math.min(600, window.innerWidth - 80);\nconst c = ui.canvas(size, size);\nconst ctx = c.getContext(\"2d\");\nctx.fillStyle = \"#0a0a0a\";\nctx.fillRect(0, 0, size, size);\n\nconst rad = rotation * Math.PI / 180;\nconst cosR = Math.cos(rad), sinR = Math.sin(rad);\n\n// project 3D to 2D with rotation around Z axis\nfunction project(p) {\n  const rx = p[0] * cosR - p[1] * sinR;\n  const ry = p[0] * sinR + p[1] * cosR;\n  return [rx, p[2]];\n}\n\n// find bounds\nlet xmin = Infinity, xmax = -Infinity;\nlet ymin = Infinity, ymax = -Infinity;\nfor (const p of pts) {\n  const [px, py] = project(p);\n  if (px < xmin) xmin = px;\n  if (px > xmax) xmax = px;\n  if (py < ymin) ymin = py;\n  if (py > ymax) ymax = py;\n}\n\nconst margin = 40;\nconst w = size - 2 * margin;\nconst scx = w / (xmax - xmin);\nconst scy = w / (ymax - ymin);\nconst sc = Math.min(scx, scy);\n\nctx.lineWidth = 0.5;\nctx.globalAlpha = 0.6;\n\nfor (let i = 1; i < pts.length; i++) {\n  const [ax, ay] = project(pts[i - 1]);\n  const [bx, by] = project(pts[i]);\n\n  const t = i / pts.length;\n  const r = Math.round(40 + 180 * t);\n  const g = Math.round(100 + 100 * Math.sin(t * Math.PI));\n  const b = Math.round(220 - 160 * t);\n\n  ctx.strokeStyle = `rgb(${r},${g},${b})`;\n  ctx.beginPath();\n  ctx.moveTo(\n    margin + (ax - xmin) * sc,\n    margin + (ymax - ay) * sc\n  );\n  ctx.lineTo(\n    margin + (bx - xmin) * sc,\n    margin + (ymax - by) * sc\n  );\n  ctx.stroke();\n}\n\nctx.globalAlpha = 1;\nui.display(`${steps} steps \\u00b7 \\u03c3=${sigma} \\u03c1=${rho} \\u03b2=${beta}`);"
    }
  ],
  "settings": {
    "theme": "dark",
    "fontSize": 13,
    "width": "860"
  }
}
