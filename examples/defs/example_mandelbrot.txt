/// title: Mandelbrot explorer

/// code collapsed
// %collapsed
workshop([
  {
    title: 'Mandelbrot explorer',
    content: md`This is a guided **workshop** for this notebook.
Use the **prev** and **next** buttons below to navigate
between pages, or click the progress dots to jump directly.

Close this panel with the **\u00d7** button. Reopen it
anytime with the **workshop** tab on the right edge
of the screen.`
  },
  {
    title: 'Reactive widgets',
    content: md`Five \`ui.slider\` calls define the exploration
parameters. Each returns a numeric \`const\` \u2014 when the
user drags a slider, the cell re-runs and all downstream
cells re-execute automatically.

This is the **reactive** widget pattern: no \`onInput\`
callback, so the DAG handles propagation. Contrast this
with the synth or shader examples that use callbacks
for real-time control.`
  },
  {
    title: 'Pixel-level canvas',
    content: md`The render cell creates an \`ImageData\`
buffer and writes RGBA values pixel by pixel. This is
the fastest way to do per-pixel computation on a
canvas \u2014 no draw calls, just array writes followed
by a single \`putImageData\`.

\`ui.canvas(w, h)\` creates the canvas element in the
cell output. The computation runs synchronously \u2014
for very high iterations or resolution, consider
\`// %manual\` to avoid blocking on every slider drag.`
  },
  {
    title: 'Computed dependencies',
    content: md`Both cells live in the same notebook scope.
The render cell references \`maxIter\`, \`zoom\`,
\`centerX\`, \`centerY\`, and \`colorShift\` \u2014 all
defined by the slider cell.

The DAG engine sees these references via
\`findUses()\` and builds the dependency edge
automatically. Change any slider \u2192 parameter cell
re-runs \u2192 render cell re-runs. No manual wiring
needed.`
  },
])

/// md
# mandelbrot set

explore the fractal. adjust iterations for detail, zoom and pan to find interesting regions.

/// code
const maxIter = ui.slider("iterations", 100, {min:20, max:500, step:10});
const zoom = ui.slider("zoom", 1, {min:0.5, max:500, step:0.5});
const centerX = ui.slider("center x", -0.5, {min:-2.5, max:1.5, step:0.01});
const centerY = ui.slider("center y", 0, {min:-1.5, max:1.5, step:0.01});
const colorShift = ui.slider("color shift", 0, {min:0, max:360, step:5});

/// code
const size = Math.min(500, window.innerWidth - 80);
const c = ui.canvas(size, size);
const ctx = c.getContext("2d");
const img = ctx.createImageData(size, size);

const scale = 3 / (size * zoom);
const ox = centerX - (size / 2) * scale;
const oy = centerY - (size / 2) * scale;

for (let py = 0; py < size; py++) {
  for (let px = 0; px < size; px++) {
    let x0 = ox + px * scale;
    let y0 = oy + py * scale;
    let x = 0, y = 0, i = 0;
    while (x * x + y * y <= 4 && i < maxIter) {
      const tmp = x * x - y * y + x0;
      y = 2 * x * y + y0;
      x = tmp;
      i++;
    }

    const idx = (py * size + px) * 4;
    if (i === maxIter) {
      img.data[idx] = img.data[idx+1] = img.data[idx+2] = 0;
    } else {
      const t = i / maxIter;
      const hue = (colorShift + 360 * t) % 360;
      const s = 0.8, l = 0.15 + 0.35 * t;
      // HSL to RGB
      const c2 = (1 - Math.abs(2 * l - 1)) * s;
      const x2 = c2 * (1 - Math.abs((hue / 60) % 2 - 1));
      const m = l - c2 / 2;
      let r, g, b;
      if (hue < 60)       { r = c2; g = x2; b = 0; }
      else if (hue < 120) { r = x2; g = c2; b = 0; }
      else if (hue < 180) { r = 0;  g = c2; b = x2; }
      else if (hue < 240) { r = 0;  g = x2; b = c2; }
      else if (hue < 300) { r = x2; g = 0;  b = c2; }
      else                { r = c2; g = 0;  b = x2; }
      img.data[idx]   = Math.round((r + m) * 255);
      img.data[idx+1] = Math.round((g + m) * 255);
      img.data[idx+2] = Math.round((b + m) * 255);
    }
    img.data[idx+3] = 255;
  }
}

ctx.putImageData(img, 0, 0);
ui.display(`${size}\u00d7${size} \u00b7 ${maxIter} iterations \u00b7 zoom ${zoom}x \u00b7 center (${centerX}, ${centerY})`);
