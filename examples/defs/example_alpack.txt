/// auditable
/// title: ALPACK — dense linear algebra in Wasm
/// module: @atra/alpack ext/atra/lib/alpack.js

/// md
# ALPACK — dense linear algebra in WebAssembly

**ALAS** (Auditable Linear Algebra Subprograms) + **ALPACK** (Auditable Linear Algebra PACKage) — ~21 routines for vector operations, matrix factorization, linear solvers, and eigendecomposition, pre-compiled from [atra](ext/atra/SPEC.md) to WebAssembly.

designed for the sizes geoscientists encounter (3–200): covariance matrices, orientation tensors, spatial interpolation.

/// code collapsed
// load pre-compiled ALPACK binary distribution
const { instantiate } = await load("@atra/alpack");
const mem = new WebAssembly.Memory({ initial: 16 }); // 1 MB
const lib = instantiate({ memory: mem });
const f64 = new Float64Array(mem.buffer);
const i32 = new Int32Array(mem.buffer);
const F = i => i * 8; // f64 byte offset
const I = i => i * 4; // i32 byte offset

/// md
## Level 1 — vector operations

ALAS Level 1: SIMD-accelerated `daxpy` (y := αx + y) and `ddot` (dot product). the `f64x2` SIMD instructions process two doubles per cycle; the scalar tail handles odd-length vectors.

/// code
// Level 1 demo: daxpy and ddot
const n1 = ui.slider("vector length", 8, {min: 2, max: 64, step: 1});
const alpha = ui.slider("\u03b1 (scale)", 2.0, {min: -5.0, max: 5.0, step: 0.1});

// set up vectors at known offsets
const xOff = 0, yOff = 100, zOff = 200;
for (let i = 0; i < n1; i++) {
  f64[xOff + i] = i + 1;           // x = [1, 2, 3, ...]
  f64[yOff + i] = (i + 1) * 10;    // y = [10, 20, 30, ...]
  f64[zOff + i] = f64[yOff + i];   // z = copy of y (for daxpy)
}

const dot = lib.alas.ddot(F(xOff), F(yOff), n1);
const nrm = lib.alas.dnrm2(F(xOff), n1);

lib.alas.daxpy(F(xOff), F(zOff), n1, alpha);
const z = Array.from(f64.subarray(zOff, zOff + n1));

const tbl = [];
for (let i = 0; i < n1; i++) {
  tbl.push({ i, x: f64[xOff + i], y: f64[yOff + i], [`\u03b1x+y`]: z[i] });
}
ui.table(tbl);
ui.display(`dot(x, y) = ${dot.toFixed(2)} \u00b7 ||x|| = ${nrm.toFixed(4)}`);

/// md
## Kriging — spatial interpolation via LU solve

ordinary kriging builds a covariance matrix from sample point distances, factorizes it with `alpack.dgetrf` (LU), and solves for weights with `alpack.dgetrs`. the weights interpolate values across a grid.

/// code
// kriging demo: generate samples, build covariance, solve, interpolate
const nPts = ui.slider("samples", 15, {min: 5, max: 40, step: 1});
const range0 = ui.slider("range", 0.4, {min: 0.1, max: 1.0, step: 0.05});
const gridN = ui.slider("grid", 80, {min: 30, max: 150, step: 10});

function mulberry32(a) {
  return function() {
    a |= 0; a = a + 0x6D2B79F5 | 0;
    let t = Math.imul(a ^ a >>> 15, 1 | a);
    t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
    return ((t ^ t >>> 14) >>> 0) / 4294967296;
  };
}
const rng = mulberry32(42);

// sample points: (x, y, value)
const samples = [];
for (let i = 0; i < nPts; i++) {
  const sx = rng(), sy = rng();
  const v = 0.5 * Math.sin(sx * 4) * Math.cos(sy * 3) + 0.5 + 0.2 * rng();
  samples.push({ x: sx, y: sy, v });
}

// exponential covariance: C(h) = exp(-3h/a)
function cov(d) { return Math.exp(-3 * d / range0); }

// build (nPts+1) x (nPts+1) kriging system (ordinary kriging with Lagrange multiplier)
const N = nPts + 1;
const aOff = 0;  // covariance matrix: N*N f64
const bOff = N * N;  // RHS vectors

// fill covariance matrix
for (let i = 0; i < nPts; i++) {
  for (let j = 0; j < nPts; j++) {
    const dx = samples[i].x - samples[j].x;
    const dy = samples[i].y - samples[j].y;
    f64[aOff + i * N + j] = cov(Math.sqrt(dx * dx + dy * dy));
  }
  // Lagrange row/col
  f64[aOff + i * N + nPts] = 1;
  f64[aOff + nPts * N + i] = 1;
}
f64[aOff + nPts * N + nPts] = 0;

// LU factorize (ordinary kriging matrix is indefinite — Cholesky won't work)
const infoOff = 50000; // i32 index, far from f64 data
const ipivOff = 50010; // i32 pivot array
lib.alpack.dgetrf(F(aOff), N, I(ipivOff), I(infoOff));

const t0 = performance.now();

// interpolate grid
const gridData = new Float64Array(gridN * gridN);
for (let gy = 0; gy < gridN; gy++) {
  for (let gx = 0; gx < gridN; gx++) {
    const px = gx / gridN, py = gy / gridN;
    // build RHS: covariance from grid point to each sample
    for (let i = 0; i < nPts; i++) {
      const dx = px - samples[i].x, dy = py - samples[i].y;
      f64[bOff + i] = cov(Math.sqrt(dx * dx + dy * dy));
    }
    f64[bOff + nPts] = 1; // Lagrange constraint

    // solve using pre-factored LU
    lib.alpack.dgetrs(F(aOff), I(ipivOff), F(bOff), N, 1);

    // weighted sum of sample values
    let val = 0;
    for (let i = 0; i < nPts; i++) val += f64[bOff + i] * samples[i].v;
    gridData[gy * gridN + gx] = val;
  }
}

const elapsed = (performance.now() - t0).toFixed(2);

/// code
// render kriging result
const size = Math.min(480, window.innerWidth - 80);
const c = ui.canvas(size, size);
const ctx = c.getContext("2d");

let vmin = Infinity, vmax = -Infinity;
for (let i = 0; i < gridData.length; i++) {
  if (gridData[i] < vmin) vmin = gridData[i];
  if (gridData[i] > vmax) vmax = gridData[i];
}
const vrange = vmax - vmin || 1;

const cellW = size / gridN;
for (let iy = 0; iy < gridN; iy++) {
  for (let ix = 0; ix < gridN; ix++) {
    const t = (gridData[iy * gridN + ix] - vmin) / vrange;
    ctx.fillStyle = std.viridis(t);
    ctx.fillRect(ix * cellW, iy * cellW, cellW + 0.5, cellW + 0.5);
  }
}

// overlay sample points
for (const s of samples) {
  const x = s.x * size, y = s.y * size;
  ctx.beginPath();
  ctx.arc(x, y, 4, 0, Math.PI * 2);
  ctx.fillStyle = "#fff";
  ctx.fill();
  ctx.lineWidth = 1.5;
  ctx.strokeStyle = "#000";
  ctx.stroke();
}

ui.display(`ordinary kriging \u00b7 ${gridN}\u00d7${gridN} grid \u00b7 ${nPts} samples \u00b7 ${elapsed} ms`);

/// md
## Eigendecomposition — orientation tensor analysis

structural geologists characterize fabric shape using the eigenvalues of a 3×3 orientation tensor. `alpack.dsyev3` computes eigenvalues analytically via Cardano's method. the ratios classify the fabric as **cluster** (prolate), **girdle** (oblate), or **isotropic**.

/// code
// orientation tensor eigendecomposition
// normalized eigenvalues: S1 >= S2 >= S3, S1+S2+S3 = 1
// Woodcock parameters: K = ln(S1/S2) / ln(S2/S3), C = ln(S1/S3)

const s1w = ui.slider("S\u2081 weight", 0.7, {min: 0.01, max: 0.98, step: 0.01});
const s2w = ui.slider("S\u2082 weight", 0.2, {min: 0.01, max: 0.98, step: 0.01});

// build symmetric orientation tensor with desired eigenvalue ratios
const s3w = Math.max(0.01, 1 - s1w - s2w);
const total = s1w + s2w + s3w;
const S = [s1w / total, s2w / total, s3w / total].sort((a, b) => b - a);

// reconstruct tensor T = R * diag(S) * R^T with arbitrary rotation
const angle = 0.7;
const ca = Math.cos(angle), sa = Math.sin(angle);
// simple rotation in xy-plane
const R = [
  [ca, -sa, 0],
  [sa,  ca, 0],
  [0,   0,  1]
];
const tOff = 0; // 3x3 tensor
for (let i = 0; i < 3; i++) {
  for (let j = 0; j < 3; j++) {
    let v = 0;
    for (let k = 0; k < 3; k++) v += R[i][k] * S[k] * R[j][k];
    f64[tOff + i * 3 + j] = v;
  }
}

// eigendecomposition
const wOff = 20;
lib.alpack.dsyev3(F(tOff), F(wOff));
const eigs = [f64[wOff], f64[wOff + 1], f64[wOff + 2]].sort((a, b) => b - a);
const eigSum = eigs[0] + eigs[1] + eigs[2];
const e = eigs.map(v => v / eigSum);

const K = (e[1] > e[2] && e[2] > 0)
  ? Math.log(e[0] / e[1]) / Math.log(e[1] / e[2])
  : Infinity;
const C = (e[2] > 0) ? Math.log(e[0] / e[2]) : Infinity;

let fabric = "isotropic";
if (C > 1.5) fabric = K > 1 ? "cluster (prolate)" : "girdle (oblate)";
else if (C > 0.5) fabric = K > 1 ? "weak cluster" : "weak girdle";

ui.display(`eigenvalues: [${e.map(v => v.toFixed(4)).join(", ")}]`);
ui.display(`K = ${K.toFixed(3)}, C = ${C.toFixed(3)} \u2192 **${fabric}**`);
ui.display(`trace check: ${eigSum.toFixed(6)} (should \u2248 1.0)`);

/// md
**routines used:**

| routine | section | what it does |
|---------|---------|-------------|
| `alas.daxpy` | Level 1 | SIMD y := αx + y |
| `alas.ddot` | Level 1 | SIMD dot product |
| `alas.dnrm2` | Level 1 | SIMD Euclidean norm |
| `alpack.dgetrf` | Kriging | LU factorization of kriging system |
| `alpack.dgetrs` | Kriging | triangular solve for kriging weights |
| `alpack.dsyev3` | Eigendecomposition | analytical 3×3 eigenvalues (Cardano) |

all computation runs in pre-compiled WebAssembly via shared linear memory. JS orchestrates allocation and rendering. no compiler needed — `load("@atra/alpack")` provides ready-to-use routines.
