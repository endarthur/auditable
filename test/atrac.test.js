import { describe, it } from 'node:test';
import assert from 'node:assert/strict';
import { readFileSync, writeFileSync, unlinkSync, existsSync } from 'node:fs';
import { join } from 'node:path';
import { tmpdir } from 'node:os';
import { execFileSync } from 'node:child_process';
import { compile, buildSrc, formatSrcJs, bundle } from '../ext/atra/atrac.js';

const alpackSource = readFileSync(
  new URL('../ext/atra/lib/alpack.atra', import.meta.url), 'utf8'
);

const trivialSource = `
function add(a: f64; b: f64): f64
begin
  add := a + b
end

function mul(a: f64; b: f64): f64
begin
  mul := a * b
end

function muladd(a: f64; b: f64; c: f64): f64
begin
  muladd := mul(a, b) + c
end
`;

// ═════════════════════════════════════════════════════════════════════
// compile()
// ═════════════════════════════════════════════════════════════════════

describe('compile()', () => {
  it('returns a Uint8Array', () => {
    const bytes = compile(trivialSource);
    assert.ok(bytes instanceof Uint8Array);
  });

  it('produces valid Wasm magic number', () => {
    const bytes = compile(trivialSource);
    // Wasm magic: \0asm
    assert.equal(bytes[0], 0x00);
    assert.equal(bytes[1], 0x61); // 'a'
    assert.equal(bytes[2], 0x73); // 's'
    assert.equal(bytes[3], 0x6d); // 'm'
  });

  it('compiles alpack without errors', () => {
    const bytes = compile(alpackSource);
    assert.ok(bytes instanceof Uint8Array);
    assert.ok(bytes.length > 100);
  });
});

// ═════════════════════════════════════════════════════════════════════
// buildSrc()
// ═════════════════════════════════════════════════════════════════════

describe('buildSrc()', () => {
  it('extracts routines from trivial source', () => {
    const lib = buildSrc(trivialSource);
    assert.ok('add' in lib.sources);
    assert.ok('mul' in lib.sources);
    assert.ok('muladd' in lib.sources);
  });

  it('computes dependency map', () => {
    const lib = buildSrc(trivialSource);
    assert.deepStrictEqual(lib.deps.add, []);
    assert.deepStrictEqual(lib.deps.mul, []);
    assert.ok(lib.deps.muladd.includes('mul'));
    assert.ok(!lib.deps.muladd.includes('add'));
  });

  it('extracts all alpack routines', () => {
    const lib = buildSrc(alpackSource);
    assert.ok('alas.dscal' in lib.sources);
    assert.ok('alas.ddot' in lib.sources);
    assert.ok('alpack.dgetrf' in lib.sources);
    assert.ok('alpack.dgesv' in lib.sources);
  });

  it('detects alpack dependencies', () => {
    const lib = buildSrc(alpackSource);
    // dgesv calls dgetrf and dgetrs
    assert.ok(lib.deps['alpack.dgesv'].includes('alpack.dgetrf'));
    assert.ok(lib.deps['alpack.dgesv'].includes('alpack.dgetrs'));
    // dscal has no deps
    assert.deepStrictEqual(lib.deps['alas.dscal'], []);
  });

  it('preserves full source as all', () => {
    const lib = buildSrc(alpackSource);
    assert.equal(lib.all, alpackSource);
  });

  it('handles routines with no deps', () => {
    const src = `
function f(x: f64): f64
begin
  f := x + 1.0
end
`;
    const lib = buildSrc(src);
    assert.ok('f' in lib.sources);
    assert.deepStrictEqual(lib.deps.f, []);
  });
});

// ═════════════════════════════════════════════════════════════════════
// formatSrcJs()
// ═════════════════════════════════════════════════════════════════════

describe('formatSrcJs()', () => {
  it('generates valid JS module syntax', () => {
    const lib = buildSrc(trivialSource);
    const js = formatSrcJs(lib);
    assert.ok(js.includes('export const all ='));
    assert.ok(js.includes('export const add ='));
    assert.ok(js.includes('export const mul ='));
    assert.ok(js.includes('export const muladd ='));
    assert.ok(js.includes('export const sources ='));
    assert.ok(js.includes('export const deps ='));
  });

  it('flattens dotted names to underscores', () => {
    const lib = buildSrc(alpackSource);
    const js = formatSrcJs(lib);
    assert.ok(js.includes('export const alas_dscal ='));
    assert.ok(js.includes('export const alpack_dgetrf ='));
  });

  it('matches existing alpack.src.js header', () => {
    const lib = buildSrc(alpackSource);
    const js = formatSrcJs(lib);
    assert.ok(js.startsWith('// Generated by atrac'));
  });
});

// ═════════════════════════════════════════════════════════════════════
// bundle()
// ═════════════════════════════════════════════════════════════════════

describe('bundle()', () => {
  it('produces JS with embedded Wasm bytes', () => {
    const js = bundle(trivialSource, { name: 'test' });
    assert.ok(js.includes('const _bytes = new Uint8Array(['));
    assert.ok(js.includes('export function instantiate('));
    assert.ok(js.includes('// test — compiled by atrac'));
  });

  it('uses default name when none provided', () => {
    const js = bundle(trivialSource);
    assert.ok(js.includes('// atra module — compiled by atrac'));
  });

  it('bundle output instantiates and runs correctly', async () => {
    const js = bundle(trivialSource, { name: 'test' });
    const tmpPath = join(tmpdir(), `atrac_test_${Date.now()}.js`);
    try {
      writeFileSync(tmpPath, js);
      const mod = await import('file://' + tmpPath.replace(/\\/g, '/'));
      const memory = new WebAssembly.Memory({ initial: 1 });
      const exports = mod.instantiate({ memory });
      assert.equal(exports.add(2, 3), 5);
      assert.equal(exports.mul(4, 5), 20);
      assert.equal(exports.muladd(2, 3, 10), 16);
    } finally {
      try { unlinkSync(tmpPath); } catch {}
    }
  });

  it('bundle handles dotted exports', async () => {
    const src = `
function math.add(a: f64; b: f64): f64
begin
  math.add := a + b
end
`;
    const js = bundle(src, { name: 'dotted' });
    const tmpPath = join(tmpdir(), `atrac_dot_${Date.now()}.js`);
    try {
      writeFileSync(tmpPath, js);
      const mod = await import('file://' + tmpPath.replace(/\\/g, '/'));
      const exports = mod.instantiate();
      assert.equal(exports.math.add(10, 20), 30);
    } finally {
      try { unlinkSync(tmpPath); } catch {}
    }
  });
});

// ═════════════════════════════════════════════════════════════════════
// build output: alpack.js
// ═════════════════════════════════════════════════════════════════════

describe('build output: alpack.js', () => {
  const alpackJsPath = new URL('../ext/atra/lib/alpack.js', import.meta.url).pathname
    .replace(/^\/([A-Z]:)/, '$1');

  it('exists after ext/atra/build.js', () => {
    assert.ok(existsSync(alpackJsPath));
  });

  it('contains instantiate export and embedded Wasm', () => {
    const content = readFileSync(alpackJsPath, 'utf8');
    assert.ok(content.includes('export function instantiate('));
    assert.ok(content.includes('const _bytes = new Uint8Array(['));
    assert.ok(content.includes('// alpack — compiled by atrac'));
  });

  it('instantiates and exposes alpack routines', async () => {
    const mod = await import('file://' + alpackJsPath.replace(/\\/g, '/'));
    const memory = new WebAssembly.Memory({ initial: 4 });
    const exports = mod.instantiate({ memory });
    // check nested namespaces
    assert.ok(exports.alas, 'should have alas namespace');
    assert.ok(exports.alpack, 'should have alpack namespace');
    assert.ok(typeof exports.alas.ddot === 'function', 'alas.ddot should be a function');
    assert.ok(typeof exports.alpack.dgesv === 'function', 'alpack.dgesv should be a function');
  });

  it('shares memory with caller (bundle imports env.memory)', async () => {
    const mod = await import('file://' + alpackJsPath.replace(/\\/g, '/'));
    const memory = new WebAssembly.Memory({ initial: 4 });
    const f64 = new Float64Array(memory.buffer);
    const lib = mod.instantiate({ memory });
    // write data to shared memory and verify Wasm reads it
    f64[0] = 3.0; f64[1] = 4.0; // x = [3, 4]
    f64[2] = 3.0; f64[3] = 4.0; // y = [3, 4]
    const dot = lib.alas.ddot(0, 16, 2); // byte offsets: 0, 16
    assert.equal(dot, 25); // 3*3 + 4*4 = 25
  });
});

// ═════════════════════════════════════════════════════════════════════
// Layout extraction in buildSrc / formatSrcJs / bundle
// ═════════════════════════════════════════════════════════════════════

const layoutSource = `
layout Vec3
  x, y, z: f64
end layout

layout packed Rec
  id: i32
  value: f64
end layout

function dot(a: layout Vec3, b: layout Vec3): f64
begin
  dot := a.x * b.x + a.y * b.y + a.z * b.z
end
`;

describe('buildSrc() with layouts', () => {
  it('extracts layout blocks from source', () => {
    const lib = buildSrc(layoutSource);
    assert.ok(lib.layouts);
    assert.ok('Vec3' in lib.layouts);
    assert.ok('Rec' in lib.layouts);
  });

  it('layout blocks contain correct source text', () => {
    const lib = buildSrc(layoutSource);
    assert.ok(lib.layouts.Vec3.includes('x, y, z: f64'));
    assert.ok(lib.layouts.Rec.includes('layout packed Rec'));
    assert.ok(lib.layouts.Rec.includes('id: i32'));
  });

  it('routines are still extracted alongside layouts', () => {
    const lib = buildSrc(layoutSource);
    assert.ok('dot' in lib.sources);
  });

  it('no layouts property when source has no layouts', () => {
    const lib = buildSrc(trivialSource);
    assert.equal(lib.layouts, undefined);
  });
});

describe('formatSrcJs() with layouts', () => {
  it('includes layout export when layouts present', () => {
    const lib = buildSrc(layoutSource);
    const js = formatSrcJs(lib);
    assert.ok(js.includes('export const layouts ='));
    assert.ok(js.includes('"Vec3"'));
    assert.ok(js.includes('"Rec"'));
  });

  it('does not include layout export when no layouts', () => {
    const lib = buildSrc(trivialSource);
    const js = formatSrcJs(lib);
    assert.ok(!js.includes('export const layouts ='));
  });
});

describe('bundle() with layouts', () => {
  it('embeds layout metadata when layouts are present', () => {
    const js = bundle(layoutSource, { name: 'layout-test' });
    assert.ok(js.includes('const _layouts ='));
    assert.ok(js.includes('__layouts'));
  });

  it('no layout metadata when no layouts', () => {
    const js = bundle(trivialSource, { name: 'no-layout' });
    assert.ok(!js.includes('const _layouts ='));
  });

  it('bundle with layouts instantiates and exposes __layouts', async () => {
    const js = bundle(layoutSource, { name: 'layout-bundle' });
    const tmpPath = join(tmpdir(), `atrac_layout_${Date.now()}.js`);
    try {
      writeFileSync(tmpPath, js);
      const mod = await import('file://' + tmpPath.replace(/\\/g, '/'));
      const memory = new WebAssembly.Memory({ initial: 1 });
      const exports = mod.instantiate({ memory });
      assert.ok(exports.__layouts);
      assert.ok(exports.__layouts.Vec3);
      assert.equal(exports.__layouts.Vec3.__size, 24);
      assert.equal(exports.__layouts.Rec.__size, 12);
    } finally {
      try { unlinkSync(tmpPath); } catch {}
    }
  });
});

// ═════════════════════════════════════════════════════════════════════
// CLI (via child process)
// ═════════════════════════════════════════════════════════════════════

describe('CLI', () => {
  const atracPath = new URL('../ext/atra/atrac.js', import.meta.url).pathname
    .replace(/^\/([A-Z]:)/, '$1');
  const alpackPath = new URL('../ext/atra/lib/alpack.atra', import.meta.url).pathname
    .replace(/^\/([A-Z]:)/, '$1');

  it('shows help with --help', () => {
    const out = execFileSync('node', [atracPath, '--help'], { encoding: 'utf8' });
    assert.ok(out.includes('atrac'));
    assert.ok(out.includes('Usage'));
  });

  it('compiles to JS bundle', () => {
    const dest = join(tmpdir(), `alpack_cli_${Date.now()}.js`);
    try {
      execFileSync('node', [atracPath, alpackPath, '-o', dest], { encoding: 'utf8' });
      assert.ok(existsSync(dest));
      const content = readFileSync(dest, 'utf8');
      assert.ok(content.includes('const _bytes = new Uint8Array(['));
      assert.ok(content.includes('export function instantiate('));
    } finally {
      try { unlinkSync(dest); } catch {}
    }
  });

  it('compiles to raw Wasm', () => {
    const dest = join(tmpdir(), `alpack_cli_${Date.now()}.wasm`);
    try {
      execFileSync('node', [atracPath, '-o', dest, alpackPath], { encoding: 'utf8' });
      assert.ok(existsSync(dest));
      const bytes = readFileSync(dest);
      // Wasm magic
      assert.equal(bytes[0], 0x00);
      assert.equal(bytes[1], 0x61);
    } finally {
      try { unlinkSync(dest); } catch {}
    }
  });

  it('generates source distribution with --src', () => {
    const dest = join(tmpdir(), `alpack_cli_${Date.now()}.src.js`);
    try {
      execFileSync('node', [atracPath, '--src', alpackPath, '-o', dest], { encoding: 'utf8' });
      assert.ok(existsSync(dest));
      const content = readFileSync(dest, 'utf8');
      assert.ok(content.includes('export const all ='));
      assert.ok(content.includes('export const sources ='));
      assert.ok(content.includes('export const deps ='));
    } finally {
      try { unlinkSync(dest); } catch {}
    }
  });
});
