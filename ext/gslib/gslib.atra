! ══════════════════════════════════════════════════════════════════════
! GSLIB — geostatistical library for atra
!
! faithful transcription of Stanford's GSLIB (Deutsch & Journel, 1998).
! same algorithms, same variable names, same accumulation order.
! the Fortran is the spec.
!
! all f64 throughout. Fortran f32 truncation points noted with
! "! NOTE: Fortran uses f32 here" for future bit-identity work.
!
! rotation matrix storage:
!   Fortran: rotmat(MAXROT, 3, 3) with rotmat(ind, i, j)
!   atra:    flat f64 array, matrix ind at rotmat[ind*9 + i*3 + j]
!            (0-indexed, row-major per block)
! ══════════════════════════════════════════════════════════════════════

! ── acorni — ACORN random number generator ────────────────────────────
!
! order 12, modulus 2^30 = 1073741824.
! state: ixv[0] = seed, ixv[1..12] = 0 initially.
! each call advances state and returns uniform [0, 1).
!
! Fortran ref: gslib/acorni.for (Wikramaratna, 1990)

function gslib.acorni(ixv: array i32): f64
var i: i32
begin
  for i := 0, 12
    ixv[i + 1] := ixv[i + 1] + ixv[i]
    if (ixv[i + 1] >= 1073741824) then
      ixv[i + 1] := ixv[i + 1] - 1073741824
    end if
  end for
  gslib.acorni := f64(ixv[12]) / 1073741824.0
end

! ── gauinv — inverse standard normal CDF ──────────────────────────────
!
! Kennedy & Gentle (1980) rational approximation.
! xp[0] receives the result, ierr[0] = 1 on error (p out of range).
!
! NOTE: Fortran truncates xp to f32 via real(...) — we skip this.
! Fortran ref: gslib/gauinv.for

subroutine gslib.gauinv(p: f64; xp: array f64; ierr: array i32)
var pp, y: f64
begin
  ! coefficients
  ! p0..p4 and q0..q4 are hardcoded below (Kennedy & Gentle)

  ierr[0] := 1
  if (p < 1.0e-10) then
    xp[0] := -1.0e10
    call return()
  end if
  if (p > 1.0 - 1.0e-10) then
    xp[0] := 1.0e10
    call return()
  end if
  ierr[0] := 0

  pp := p
  if (p > 0.5) then
    pp := 1.0 - pp
  end if
  xp[0] := 0.0
  if (p == 0.5) then
    call return()
  end if

  ! rational approximation
  y := sqrt(ln(1.0 / (pp * pp)))
  ! NOTE: Fortran uses f32 here (xp = real(...))
  xp[0] := y + ((((y * (-0.0000453642210148) + (-0.0204231210245)) * y
    + (-0.342242088547)) * y + (-1.0)) * y + (-0.322232431088))
    / ((((y * 0.0038560700634 + 0.103537752850) * y
    + 0.531103462366) * y + 0.588581570495) * y + 0.0993484626060)
  if (p <= 0.5) then
    xp[0] := 0.0 - xp[0]
  end if
end

! ── gcum — standard normal CDF ────────────────────────────────────────
!
! Abramowitz & Stegun polynomial approximation (~5 decimal places).
! all f64 (NOTE: Fortran is entirely f32).
!
! Fortran ref: gslib/gcum.for

function gslib.gcum(x: f64): f64
var z, t, e2: f64
begin
  z := x
  if (z < 0.0) then
    z := 0.0 - z
  end if
  t := 1.0 / (1.0 + 0.2316419 * z)
  gslib.gcum := t * (0.31938153 + t * (-0.356563782 + t * (1.781477937
    + t * (-1.821255978 + t * 1.330274429))))
  e2 := 0.0

  ! 6 standard deviations out gets treated as infinity
  if (z <= 6.0) then
    e2 := exp(0.0 - z * z / 2.0) * 0.3989422803
  end if
  gslib.gcum := 1.0 - e2 * gslib.gcum
  if (x >= 0.0) then
    call return(gslib.gcum)
  end if
  gslib.gcum := 1.0 - gslib.gcum
end

! ── powint — power interpolation ──────────────────────────────────────
!
! interpolates y between (xlow,ylow) and (xhigh,yhigh) with power pow.
! EPSLON guard for degenerate intervals.
!
! Fortran ref: gslib/powint.for

function gslib.powint(xlow: f64; xhigh: f64; ylow: f64; yhigh: f64;
  xval: f64; pow: f64): f64
begin
  if (xhigh - xlow < 1.0e-20) then
    gslib.powint := (yhigh + ylow) / 2.0
  else
    gslib.powint := ylow + (yhigh - ylow)
      * ((xval - xlow) / (xhigh - xlow)) ** pow
  end if
end

! ── locate — bisection search in sorted array ─────────────────────────
!
! given sorted xx[n], find j such that xx[j] <= x < xx[j+1].
! 0-indexed. returns j = -1 or j = n-1 for out-of-range.
!
! Fortran ref: gslib/locate.for (adapted from Numerical Recipes)

subroutine gslib.locate(xx: array f64; n, is, ie: i32; x: f64;
  j: array i32)
var jl, ju, jm: i32
begin
  jl := is - 1
  ju := ie
  if (xx[n - 1] <= x) then
    j[0] := ie
    call return()
  end if

  ! bisection loop
  while (ju - jl > 1)
    jm := (ju + jl) / 2
    if ((xx[ie - 1] > xx[is - 1]) == (x > xx[jm - 1])) then
      jl := jm
    else
      ju := jm
    end if
  end while

  j[0] := jl
end

! ── getindx — grid cell index from coordinate ─────────────────────────
!
! maps a point location to grid cell index (0-indexed).
! returns index in idx[0] and inflag in idx[1] (1=in grid, 0=out).
!
! Fortran ref: gslib/getindx.for

subroutine gslib.getindx(n: i32; gmin, siz, loc: f64; idx: array i32)
var index: i32
begin
  ! Fortran uses int((loc-min)/siz + 1.5), 1-indexed
  ! 0-indexed: int((loc-min)/siz + 0.5)
  index := i32(floor((loc - gmin) / siz + 0.5))

  if (index < 0) then
    idx[0] := 0
    idx[1] := 0
  else if (index >= n) then
    idx[0] := n - 1
    idx[1] := 0
  else
    idx[0] := index
    idx[1] := 1
  end if
end

! ── setrot — build anisotropic rotation matrix ────────────────────────
!
! GSLIB angle convention: ang1=azimuth (CW from N), ang2=dip, ang3=rake.
! writes 9 f64 values to rotmat[ind*9 .. ind*9+8].
! anisotropy ratios applied to rows 2 and 3.
!
! Fortran ref: gslib/setrot.for

subroutine gslib.setrot(ang1, ang2, ang3, anis1, anis2: f64;
  ind: i32; rotmat: array f64)
var
  alpha, beta, theta: f64
  sina, sinb, sint, cosa, cosb, cost: f64
  afac1, afac2: f64
  base: i32
begin
  ! convert GSLIB angles to mathematical angles
  if (ang1 >= 0.0 and ang1 < 270.0) then
    alpha := (90.0 - ang1) * 3.141592654 / 180.0
  else
    alpha := (450.0 - ang1) * 3.141592654 / 180.0
  end if
  beta := -1.0 * ang2 * 3.141592654 / 180.0
  theta := ang3 * 3.141592654 / 180.0

  ! sines and cosines
  sina := sin(alpha)
  sinb := sin(beta)
  sint := sin(theta)
  cosa := cos(alpha)
  cosb := cos(beta)
  cost := cos(theta)

  ! anisotropy factors
  afac1 := 1.0 / max(anis1, 1.0e-20)
  afac2 := 1.0 / max(anis2, 1.0e-20)

  ! build rotation matrix at rotmat[ind*9 .. ind*9+8]
  base := ind * 9
  rotmat[base + 0] := cosb * cosa
  rotmat[base + 1] := cosb * sina
  rotmat[base + 2] := 0.0 - sinb
  rotmat[base + 3] := afac1 * (0.0 - cost * sina + sint * sinb * cosa)
  rotmat[base + 4] := afac1 * (cost * cosa + sint * sinb * sina)
  rotmat[base + 5] := afac1 * (sint * cosb)
  rotmat[base + 6] := afac2 * (sint * sina + cost * sinb * cosa)
  rotmat[base + 7] := afac2 * (0.0 - sint * cosa + cost * sinb * sina)
  rotmat[base + 8] := afac2 * (cost * cosb)
end

! ── sqdist — squared anisotropic distance ─────────────────────────────
!
! applies rotation matrix, returns sum of squared transformed components.
! reads from rotmat[ind*9..].
!
! Fortran ref: gslib/sqdist.for

function gslib.sqdist(x1, y1, z1, x2, y2, z2: f64;
  ind: i32; rotmat: array f64): f64
var
  dx, dy, dz, cont: f64
  i, base: i32
begin
  dx := x1 - x2
  dy := y1 - y2
  dz := z1 - z2
  base := ind * 9
  gslib.sqdist := 0.0
  for i := 0, 3
    cont := rotmat[base + i * 3 + 0] * dx
      + rotmat[base + i * 3 + 1] * dy
      + rotmat[base + i * 3 + 2] * dz
    gslib.sqdist := gslib.sqdist + cont * cont
  end for
end

! ── sortem — quickersort with companion arrays ────────────────────────
!
! sorts a[ib..ie-1] in ascending order (0-indexed).
! simultaneously permutes companion arrays b and c.
! nperm = 0: sort a only
! nperm = 1: permute b with a
! nperm = 2: permute b and c with a
!
! Quickersort algorithm (Scowen, ACM 271). explicit stack, no recursion.
! stack depth 64 handles up to 2^64 elements.
!
! Fortran ref: gslib/sortem.for, gslib/dsortem.for

subroutine gslib.sortem(ib, ie: i32; a, b, c: array f64; nperm: i32;
  lt, ut: array i32)
var
  i, j, k, m, p, q: i32
  ta, xa, tb, xb, tc, xc: f64
begin
  ! Quickersort (Scowen, ACM 271). 0-indexed: sorts a[ib..ie-1].
  ! lt/ut are scratch arrays of at least 64 i32 each (stack depth).
  j := ie - 1
  m := 1
  i := ib
  lt[0] := i
  ut[0] := j

  while (m > 0)
    m := m - 1
    i := lt[m]
    j := ut[m]

    ! keep splitting until segment is small
    while (j - i > 1)
      ! segment has 3+ elements — partition
      p := (j + i) / 2
      ta := a[p]
      a[p] := a[i]
      if (nperm >= 1) then
        tb := b[p]
        b[p] := b[i]
      end if
      if (nperm >= 2) then
        tc := c[p]
        c[p] := c[i]
      end if

      ! Hoare partition: scan from both ends
      q := j
      k := i + 1

      ! scan forward for a[k] > ta, backward for a[q] < ta, swap
      while (k <= q)
        ! forward scan
        while (k <= q and a[k] <= ta)
          k := k + 1
        end while
        if (k > q) then
          break
        end if
        ! backward scan
        while (q >= k and a[q] >= ta)
          q := q - 1
        end while
        if (q < k) then
          break
        end if
        ! swap a[k] and a[q]
        xa := a[k]
        a[k] := a[q]
        a[q] := xa
        if (nperm >= 1) then
          xb := b[k]
          b[k] := b[q]
          b[q] := xb
        end if
        if (nperm >= 2) then
          xc := c[k]
          c[k] := c[q]
          c[q] := xc
        end if
        k := k + 1
        q := q - 1
      end while

      ! place pivot: q = k - 1 is the partition point
      q := k - 1
      a[i] := a[q]
      a[q] := ta
      if (nperm >= 1) then
        b[i] := b[q]
        b[q] := tb
      end if
      if (nperm >= 2) then
        c[i] := c[q]
        c[q] := tc
      end if

      ! push larger segment, continue with smaller
      if (q - i > j - q) then
        lt[m] := i
        ut[m] := q - 1
        i := q + 1
      else
        lt[m] := q + 1
        ut[m] := j
        j := q - 1
      end if
      m := m + 1
    end while

    ! segment has 0 or 1 or 2 elements
    if (j > i) then
      if (a[i] > a[j]) then
        xa := a[i]
        a[i] := a[j]
        a[j] := xa
        if (nperm >= 1) then
          xb := b[i]
          b[i] := b[j]
          b[j] := xb
        end if
        if (nperm >= 2) then
          xc := c[i]
          c[i] := c[j]
          c[j] := xc
        end if
      end if
    end if
  end while
end

! ── nscore — normal score transform ───────────────────────────────────
!
! transforms nd data values to standard normal scores N(0,1).
! uses sortem internally.
!
! a[0..nd-1]     = data values (modified: sorted then restored)
! wt[0..nd-1]    = weights (iwt=1) or unused (iwt=0). modified.
! tmp[0..nd-1]   = scratch (stores original indices)
! vrg[0..nd-1]   = output normal scores
! xp[0]          = scratch for gauinv output
! ierr[0]        = scratch for gauinv error flag
! result[0]      = 0 on success, 1 on error
!
! Fortran ref: gslib/nscore.for

subroutine gslib.nscore(nd: i32; a, wt, tmp, vrg, xp: array f64;
  ierr, result, lt, ut: array i32; tmin, tmax: f64; iwt: i32)
var
  i: i32
  twt, oldcp, cp: f64
begin
  result[0] := 0
  twt := 0.0

  ! store original indices and compute total weight
  for i := 0, nd
    tmp[i] := f64(i)
    if (a[i] >= tmin and a[i] < tmax) then
      if (iwt == 0) then
        twt := twt + 1.0
      else
        twt := twt + wt[i]
      end if
    end if
  end for

  if (nd < 1 or twt < 1.0e-20) then
    result[0] := 1
    call return()
  end if

  ! sort data ascending, permuting wt and tmp
  call gslib.sortem(0, nd, a, wt, tmp, 2, lt, ut)

  ! compute cumulative probabilities and normal scores
  oldcp := 0.0
  cp := 0.0
  for i := 0, nd
    if (iwt == 0) then
      cp := cp + 1.0 / twt
    else
      cp := cp + wt[i] / twt
    end if
    wt[i] := (cp + oldcp) / 2.0
    oldcp := cp
    call gslib.gauinv(wt[i], xp, ierr)
    vrg[i] := xp[0]
  end for

  ! restore original order: sort by tmp (original indices), carrying a and vrg.
  ! Fortran uses iperm=3 (tmp, wt, vr, vrg) but we only need a and vrg back.
  ! wt is consumed — not needed after this point.
  call gslib.sortem(0, nd, tmp, a, vrg, 2, lt, ut)
end

! ── backtr — back-transform from normal scores ────────────────────────
!
! back-transforms a standard normal deviate using a transform table
! (vr, vrg) and tail options.
!
! vrgs           = normal score to back-transform
! nt             = number of entries in transform table
! vr[0..nt-1]   = original data values (sorted ascending)
! vrg[0..nt-1]  = corresponding normal scores (sorted ascending)
! zmin, zmax     = limits for tail extrapolation
! ltail          = lower tail option (1=linear, 2=power)
! ltpar          = lower tail parameter
! utail          = upper tail option (1=linear, 2=power, 4=hyperbolic)
! utpar          = upper tail parameter
! j[0]           = scratch for locate output
!
! Fortran ref: gslib/backtr.for

function gslib.backtr(vrgs: f64; nt: i32; vr, vrg: array f64;
  zmin, zmax: f64; ltail: i32; ltpar: f64;
  utail: i32; utpar: f64; j: array i32): f64
var
  cdflo, cdfhi, cdfbt, cpow, lambda: f64
  jj: i32
begin
  ! value in the lower tail?
  if (vrgs <= vrg[0]) then
    gslib.backtr := vr[0]
    cdflo := gslib.gcum(vrg[0])
    cdfbt := gslib.gcum(vrgs)
    if (ltail == 1) then
      gslib.backtr := gslib.powint(0.0, cdflo, zmin, vr[0], cdfbt, 1.0)
    else if (ltail == 2) then
      cpow := 1.0 / ltpar
      gslib.backtr := gslib.powint(0.0, cdflo, zmin, vr[0], cdfbt, cpow)
    end if

  ! value in the upper tail?
  else if (vrgs >= vrg[nt - 1]) then
    gslib.backtr := vr[nt - 1]
    cdfhi := gslib.gcum(vrg[nt - 1])
    cdfbt := gslib.gcum(vrgs)
    if (utail == 1) then
      gslib.backtr := gslib.powint(cdfhi, 1.0, vr[nt - 1], zmax, cdfbt, 1.0)
    else if (utail == 2) then
      cpow := 1.0 / utpar
      gslib.backtr := gslib.powint(cdfhi, 1.0, vr[nt - 1], zmax, cdfbt, cpow)
    else if (utail == 4) then
      lambda := (vr[nt - 1] ** utpar) * (1.0 - gslib.gcum(vrg[nt - 1]))
      gslib.backtr := (lambda / (1.0 - gslib.gcum(vrgs))) ** (1.0 / utpar)
    end if

  ! value within the transformation table
  else
    call gslib.locate(vrg, nt, 1, nt, vrgs, j)
    jj := j[0]
    if (jj < 1) then
      jj := 1
    end if
    if (jj > nt - 1) then
      jj := nt - 1
    end if
    ! locate returns 1-indexed j; vrg/vr are 0-indexed
    gslib.backtr := gslib.powint(vrg[jj - 1], vrg[jj], vr[jj - 1], vr[jj],
      vrgs, 1.0)
  end if
end

! ── cova3 — nested covariance model evaluation ────────────────────────
!
! 5 model types: 1=spherical, 2=exponential, 3=Gaussian,
!                4=power, 5=hole effect.
!
! simplified interface (single variogram):
!   nst     = number of nested structures
!   c0      = nugget effect
!   it[is]  = model type for structure is (0-indexed)
!   cc[is]  = sill increment for structure is
!   aa[is]  = range/parameter for structure is
!   irot    = base rotation matrix index
!
! result[0] = cmax, result[1] = cova.
!
! Fortran ref: gslib/cova3.for

subroutine gslib.cova3(x1, y1, z1, x2, y2, z2: f64;
  nst: i32; c0: f64;
  it: array i32; cc, aa: array f64;
  irot: i32; rotmat: array f64;
  result: array f64)
var
  is, ir: i32
  cmax, cova, hsqd, h, hr: f64
begin
  ! calculate maximum covariance
  cmax := c0
  for is := 0, nst
    if (it[is] == 4) then
      cmax := cmax + 999.0
    else
      cmax := cmax + cc[is]
    end if
  end for

  ! check for zero distance
  hsqd := gslib.sqdist(x1, y1, z1, x2, y2, z2, irot, rotmat)
  if (hsqd < 1.0e-5) then
    result[0] := cmax
    result[1] := cmax
    call return()
  end if

  ! loop over nested structures
  cova := 0.0
  for is := 0, nst
    ! compute distance for this structure
    if (is /= 0) then
      ir := irot + is
      hsqd := gslib.sqdist(x1, y1, z1, x2, y2, z2, ir, rotmat)
    end if
    h := sqrt(hsqd)

    ! spherical model
    if (it[is] == 1) then
      hr := h / aa[is]
      if (hr < 1.0) then
        cova := cova + cc[is] * (1.0 - hr * (1.5 - 0.5 * hr * hr))
      end if

    ! exponential model
    else if (it[is] == 2) then
      cova := cova + cc[is] * exp(-3.0 * h / aa[is])

    ! Gaussian model
    else if (it[is] == 3) then
      cova := cova + cc[is] * exp(-3.0 * (h / aa[is]) * (h / aa[is]))

    ! power model
    else if (it[is] == 4) then
      cova := cova + cmax - cc[is] * h ** aa[is]

    ! hole effect model
    else if (it[is] == 5) then
      cova := cova + cc[is] * cos(h / aa[is] * 3.14159265)
    end if
  end for

  result[0] := cmax
  result[1] := cova
end

! ── setsupr — establish super block search limits and sort data ──────
!
! builds a 3D "super block" network and orders data by super block index.
! super block grid spans the kriging/simulation grid.
! data outside the grid are clamped to the nearest edge block.
!
! nd         = number of data points
! x, y, z   = data coordinates (reordered by super block)
! vr         = data values (reordered with coordinates)
! tmp        = scratch array (stores super block index per datum)
! nisb       = cumulative data count per super block (i32 array)
! idx        = scratch i32[2] for getindx
! ixarr      = scratch i32[nd] for index permutation
! lt, ut     = scratch i32[64] each for sortem
!
! outputs:
!   out[0..5] = nxsup, nysup, nzsup, xmnsup, ymnsup, zmnsup
!   out[6..8] = xsizsup, ysizsup, zsizsup  (stored as f64)
!   data arrays x, y, z, vr are reordered by super block.
!   nisb[i] = cumulative number of data up to super block i.
!
! NOTE: Fortran's sortem handles nsort=4+ companions. We use an index-
! based permutation: sort super block index with original indices,
! then permute x, y, z, vr via a copy pass.
!
! Fortran ref: gslib/setsupr.for

subroutine gslib.setsupr(nx: i32; xmn, xsiz: f64; ny: i32; ymn, ysiz: f64;
  nz: i32; zmn, zsiz: f64;
  nd: i32; x, y, z, vr, tmp: array f64;
  nisb, idx, ixarr, lt, ut: array i32;
  maxsbx, maxsby, maxsbz: i32;
  out: array f64)
var
  nxsup, nysup, nzsup: i32
  xsizsup, ysizsup, zsizsup, xmnsup, ymnsup, zmnsup: f64
  i, ii, ix, iy, iz: i32
  nstot: i32
  oi, src: i32
begin
  ! establish number and size of super blocks
  nxsup := min(nx, maxsbx)
  nysup := min(ny, maxsby)
  nzsup := min(nz, maxsbz)
  xsizsup := f64(nx) * xsiz / f64(nxsup)
  ysizsup := f64(ny) * ysiz / f64(nysup)
  zsizsup := f64(nz) * zsiz / f64(nzsup)
  xmnsup := (xmn - 0.5 * xsiz) + 0.5 * xsizsup
  ymnsup := (ymn - 0.5 * ysiz) + 0.5 * ysizsup
  zmnsup := (zmn - 0.5 * zsiz) + 0.5 * zsizsup

  ! initialize super block counts to zero
  nstot := nxsup * nysup * nzsup
  for i := 0, nstot
    nisb[i] := 0
  end for

  ! assign each datum to a super block and count
  for i := 0, nd
    call gslib.getindx(nxsup, xmnsup, xsizsup, x[i], idx)
    ix := idx[0]
    call gslib.getindx(nysup, ymnsup, ysizsup, y[i], idx)
    iy := idx[0]
    call gslib.getindx(nzsup, zmnsup, zsizsup, z[i], idx)
    iz := idx[0]
    ! 0-indexed super block linear index
    ii := ix + iy * nxsup + iz * nxsup * nysup
    tmp[i] := f64(ii)
    nisb[ii] := nisb[ii] + 1
  end for

  ! Build source permutation: ixarr[j] = which original element goes to position j.
  ! Uses counting sort (O(n)) instead of Fortran's sortem with 4+ companions.

  ! Exclusive prefix sum: nisb[i] = start position for block i
  ii := 0
  for i := 0, nstot
    ix := nisb[i]
    nisb[i] := ii
    ii := ii + ix
  end for

  ! Compute source permutation
  for i := 0, nd
    ii := i32(tmp[i])
    ixarr[nisb[ii]] := i
    nisb[ii] := nisb[ii] + 1
  end for

  ! Now nisb[i] = cumulative count up to and including block i (what Fortran returns)

  ! Apply source permutation via cycle-following.
  ! ixarr[j] = source index for position j.
  ! Mark visited by setting ixarr[j] = -1 after processing.
  for i := 0, nd
    if (ixarr[i] /= i and ixarr[i] >= 0) then
      ! start of a cycle: save element at position i
      out[9] := x[i]
      out[10] := y[i]
      out[11] := z[i]
      out[12] := vr[i]

      oi := i
      src := ixarr[i]
      while (src /= i)
        x[oi] := x[src]
        y[oi] := y[src]
        z[oi] := z[src]
        vr[oi] := vr[src]
        ixarr[oi] := -1
        oi := src
        src := ixarr[oi]
      end while

      ! close cycle: place saved element at the last position
      x[oi] := out[9]
      y[oi] := out[10]
      z[oi] := out[11]
      vr[oi] := out[12]
      ixarr[oi] := -1
    end if
  end for

  ! store output grid parameters
  out[0] := f64(nxsup)
  out[1] := f64(nysup)
  out[2] := f64(nzsup)
  out[3] := xmnsup
  out[4] := ymnsup
  out[5] := zmnsup
  out[6] := xsizsup
  out[7] := ysizsup
  out[8] := zsizsup
end

! ── picksup — determine which super blocks to search ─────────────────
!
! given a search radius and rotation matrix, determines which super
! blocks could contain data within the search ellipsoid.
!
! tests all super block offset combinations (i,j,k), checks if the
! closest corner-to-corner distance is within the search radius.
!
! outputs:
!   nsbtosr[0]          = number of super blocks to search
!   ixsbtosr, iysbtosr, izsbtosr = offset arrays
!
! Fortran ref: gslib/picksupr.for (picksup)

subroutine gslib.picksup(nxsup: i32; xsizsup: f64;
  nysup: i32; ysizsup: f64;
  nzsup: i32; zsizsup: f64;
  irot: i32; rotmat: array f64; radsqd: f64;
  nsbtosr: array i32;
  ixsbtosr, iysbtosr, izsbtosr: array i32)
var
  i, j, k, i1, j1, k1, i2, j2, k2: i32
  xo, yo, zo, xdis, ydis, zdis: f64
  shortest, hsqd: f64
  ns: i32
begin
  ns := 0

  for i := -(nxsup - 1), nxsup
    for j := -(nysup - 1), nysup
      for k := -(nzsup - 1), nzsup
        xo := f64(i) * xsizsup
        yo := f64(j) * ysizsup
        zo := f64(k) * zsizsup

        ! find closest distance between corners of the two super blocks
        shortest := 1.0e21
        for i1 := -1, 2
          for j1 := -1, 2
            for k1 := -1, 2
              for i2 := -1, 2
                for j2 := -1, 2
                  for k2 := -1, 2
                    if (i1 /= 0 and j1 /= 0 and k1 /= 0
                        and i2 /= 0 and j2 /= 0 and k2 /= 0) then
                      xdis := f64(i1 - i2) * 0.5 * xsizsup + xo
                      ydis := f64(j1 - j2) * 0.5 * ysizsup + yo
                      zdis := f64(k1 - k2) * 0.5 * zsizsup + zo
                      hsqd := gslib.sqdist(0.0, 0.0, 0.0,
                        xdis, ydis, zdis, irot, rotmat)
                      if (hsqd < shortest) then
                        shortest := hsqd
                      end if
                    end if
                  end for
                end for
              end for
            end for
          end for
        end for

        ! keep this super block if close enough
        if (shortest <= radsqd) then
          ixsbtosr[ns] := i
          iysbtosr[ns] := j
          izsbtosr[ns] := k
          ns := ns + 1
        end if
      end for
    end for
  end for

  nsbtosr[0] := ns
end

! ── srchsupr — search within super blocks for nearby data ────────────
!
! searches data sorted by setsupr for points within the search radius.
! returns indices of close data sorted by distance.
! optional octant search (noct > 0) limits data per octant.
!
! close[0..nclose-1]   = indices (f64) of nearby data, sorted by distance
! tmp[0..nclose-1]     = squared distances (reused from setsupr's tmp)
! result[0]            = nclose
! result[1]            = infoct (number of informed octants)
! idx                  = scratch i32[2] for getindx
! inoct                = scratch i32[8] for octant counts
! lt, ut               = scratch i32[64] each for sortem
!
! Fortran ref: gslib/srchsupr.for

subroutine gslib.srchsupr(xloc, yloc, zloc, radsqd: f64;
  irot: i32; rotmat: array f64;
  nsbtosr: i32; ixsbtosr, iysbtosr, izsbtosr: array i32;
  noct, nd: i32;
  x, y, z, tmp, close: array f64;
  nisb: array i32;
  nxsup: i32; xmnsup, xsizsup: f64;
  nysup: i32; ymnsup, ysizsup: f64;
  nzsup: i32; zmnsup, zsizsup: f64;
  result: array f64;
  idx, inoct, lt, ut: array i32)
var
  ix, iy, iz: i32
  isup, ixsup, iysup, izsup: i32
  ii, nums, nc, i, j: i32
  hsqd: f64
  na, nt, iq: i32
  dx, dy, dz, h: f64
  ci: i32
begin
  ! determine super block of estimation point
  call gslib.getindx(nxsup, xmnsup, xsizsup, xloc, idx)
  ix := idx[0]
  call gslib.getindx(nysup, ymnsup, ysizsup, yloc, idx)
  iy := idx[0]
  call gslib.getindx(nzsup, zmnsup, zsizsup, zloc, idx)
  iz := idx[0]

  nc := 0

  ! loop over super blocks to search
  for isup := 0, nsbtosr
    ixsup := ix + ixsbtosr[isup]
    iysup := iy + iysbtosr[isup]
    izsup := iz + izsbtosr[isup]

    ! skip if outside grid (0-indexed: valid range [0, n-1])
    if (ixsup < 0 or ixsup >= nxsup
        or iysup < 0 or iysup >= nysup
        or izsup < 0 or izsup >= nzsup) then
      ! continue to next isup (use else-if to skip rest)
    else
      ! linear index of super block (0-indexed)
      ii := ixsup + iysup * nxsup + izsup * nxsup * nysup

      ! figure out data range in this super block
      if (ii == 0) then
        nums := nisb[0]
        i := 0
      else
        nums := nisb[ii] - nisb[ii - 1]
        i := nisb[ii - 1]
      end if

      ! check each datum in this super block
      for j := 0, nums
        hsqd := gslib.sqdist(xloc, yloc, zloc,
          x[i], y[i], z[i], irot, rotmat)
        if (hsqd <= radsqd) then
          close[nc] := f64(i)
          tmp[nc] := hsqd
          nc := nc + 1
        end if
        i := i + 1
      end for
    end if
  end for

  ! sort nearby samples by distance
  if (nc > 1) then
    call gslib.sortem(0, nc, tmp, close, close, 1, lt, ut)
  end if

  ! if not doing octant search, return
  if (noct <= 0) then
    result[0] := f64(nc)
    result[1] := 0.0
    call return()
  end if

  ! octant search: partition data into octants
  for i := 0, 8
    inoct[i] := 0
  end for

  nt := 8 * noct
  na := 0
  for j := 0, nc
    ci := i32(close[j])
    h := tmp[j]
    dx := x[ci] - xloc
    dy := y[ci] - yloc
    dz := z[ci] - zloc

    ! determine octant (0-indexed: 0-7)
    if (dz >= 0.0) then
      iq := 3
      if (dx <= 0.0 and dy > 0.0) then
        iq := 0
      end if
      if (dx > 0.0 and dy >= 0.0) then
        iq := 1
      end if
      if (dx < 0.0 and dy <= 0.0) then
        iq := 2
      end if
    else
      iq := 7
      if (dx <= 0.0 and dy > 0.0) then
        iq := 4
      end if
      if (dx > 0.0 and dy >= 0.0) then
        iq := 5
      end if
      if (dx < 0.0 and dy <= 0.0) then
        iq := 6
      end if
    end if

    inoct[iq] := inoct[iq] + 1

    ! keep if octant not yet full
    if (inoct[iq] <= noct) then
      close[na] := f64(ci)
      tmp[na] := h
      na := na + 1
      if (na == nt) then
        break
      end if
    end if
  end for

  nc := na
  result[1] := 0.0
  for i := 0, 8
    if (inoct[i] > 0) then
      result[1] := result[1] + 1.0
    end if
  end for
  result[0] := f64(nc)
end

! ── ksol — kriging system solver (upper triangular) ─────────────────
!
! solves a system of linear equations stored as an upper triangular
! packed matrix (columnwise). pivots on the diagonal, no pivot search.
!
! for ordinary/simple kriging only — NOT for universal kriging.
! use ktsol (Gaussian elimination with pivoting) for UK.
!
! a[0..nn-1]    = upper triangular packed LHS matrix (modified)
!                 nn = neq*(neq+1)/2
! r[0..neq-1]   = right hand side vector (modified)
! s[0..neq-1]   = solution vector (output)
! result[0]      = ising: 0=ok, -1=neq<=1, k=null pivot at iteration k
!
! Fortran ref: gslib/ksol.for
! NOTE: simplified to nright=1, nsb=1 (the kb2d case).

subroutine gslib.ksol(neq: i32; a, r, s, result: array f64)
var
  m1, k, i, j: i32
  kk, ii, ij, ll, lp: i32
  ak, piv, ap: f64
  tol: f64
begin
  ! Translated from Fortran ksol.for. Uses 1-indexed internal arithmetic
  ! (k, i, j, kk, ii, ij, ll are 1-based positions into packed array).
  ! a[], r[], s[] are 0-indexed — we subtract 1 when accessing them.
  !
  ! Packed upper triangular columnwise (1-indexed):
  !   element (i,j), j>=i, is at position i + j*(j-1)/2

  tol := 1.0e-7

  if (neq <= 1) then
    result[0] := -1.0
    call return()
  end if

  result[0] := 0.0
  m1 := neq - 1
  kk := 0

  ! forward elimination (triangulation)
  ! Note: all loop variables (k, i, j, kk, ii, ij, ll) use 1-based indexing
  ! to match Fortran ksol.for exactly. Array accesses subtract 1.
  ! atra for loops are half-open [start, end), so Fortran "do k=1,m1"
  ! becomes "for k := 1, m1+1".
  for k := 1, m1 + 1
    kk := kk + k
    ak := a[kk - 1]
    if (abs(ak) < tol) then
      result[0] := f64(k)
      call return()
    end if
    piv := 1.0 / ak
    lp := 0
    ii := kk
    for i := k, m1 + 1
      ll := ii
      ii := ii + i
      ap := a[ii - 1] * piv
      lp := lp + 1
      ij := ii - k + 1
      for j := i, m1 + 1
        ij := ij + j
        ll := ll + j
        a[ij - 1] := a[ij - 1] - ap * a[ll - 1]
      end for
      ! modify RHS
      r[k + lp - 1] := r[k + lp - 1] - ap * r[k - 1]
    end for
  end for

  ! check last pivot (nn = neq*(neq+1)/2, 1-indexed)
  ij := neq * (neq + 1) / 2
  if (abs(a[ij - 1]) < tol) then
    result[0] := f64(neq)
    call return()
  end if

  ! back substitution
  piv := 1.0 / a[ij - 1]
  s[neq - 1] := r[neq - 1] * piv
  i := neq
  kk := ij
  for ii := 1, m1 + 1
    kk := kk - i
    piv := 1.0 / a[kk - 1]
    i := i - 1
    ap := r[i - 1]
    ij := kk
    for j := i, m1 + 1
      ij := ij + j
      ap := ap - a[ij - 1] * s[j]
    end for
    s[i - 1] := ap * piv
  end for
end

! ── kb2d — 2D ordinary/simple kriging ──────────────────────────────
!
! estimates point or block values on a 2D grid by ordinary or simple
! kriging. uses cova3/setrot for covariance evaluation and ksol for
! the kriging system. brute-force neighbor search (all data scanned).
!
! parameters:
!   nx, ny           grid dimensions
!   xmn, ymn         grid origin (center of first cell)
!   xsiz, ysiz       cell sizes
!   nxdis, nydis      block discretization (1x1 = point kriging)
!   nd               number of data
!   x, y, vr         data coordinates and values
!   ndmin, ndmax      min/max neighbors
!   radius            search radius
!   ktype             0=simple, 1=ordinary kriging
!   skmean            simple kriging mean
!   nst               number of nested structures
!   c0                nugget
!   it                model types (i32[nst])
!   cc, aa            sill/range arrays (f64[nst])
!   irot              base rotation index (setrot already called)
!   rotmat            rotation matrices (9*f64 per structure)
!   est               output estimates (f64[nx*ny])
!   estv              output variances (f64[nx*ny])
!
! scratch arrays:
!   xa, ya, vra      neighbor coords/values (f64[ndmax+1])
!   dist             neighbor distances (f64[ndmax+1])
!   nums             neighbor indices (f64[ndmax+1]) — f64 for sortem compat
!   r, rr, s         kriging vectors (f64[ndmax+2])
!   a                kriging matrix packed (f64[(ndmax+2)*(ndmax+3)/2])
!   xdb, ydb         discretization offsets (f64[nxdis*nydis])
!   covres           scratch for cova3 result (f64[2])
!   ksolres          scratch for ksol result (f64[1])
!
! NOTE: unlike Fortran kb2d which uses cova2 (2D, inline rotation),
! this uses our existing cova3 + setrot (3D, z=0). the rotation
! matrices must be set up before calling kb2d.
!
! Fortran ref: gslib/kb2d.for

subroutine gslib.kb2d(
  nx, ny: i32; xmn, ymn, xsiz, ysiz: f64;
  nxdis, nydis: i32;
  nd: i32; x, y, vr: array f64;
  ndmin, ndmax: i32; radius: f64;
  ktype: i32; skmean: f64;
  nst: i32; c0: f64;
  it: array i32; cc, aa: array f64;
  irot: i32; rotmat: array f64;
  est, estv: array f64;
  xa, ya, vra, dist, nums: array f64;
  r, rr, s, a: array f64;
  xdb, ydb, covres, ksolres: array f64)
var
  ix, iy, id, ia, isam: i32
  xloc, yloc, dx, dy, h2, rad2: f64
  ndb, na, neq, nn: i32
  cbb, cov, cb, unbias, cb1: f64
  xx, yy, sumw: f64
  xdis, ydis: f64
  i, j, k, n1, jk, j1, jj: i32
  in, gi: i32
  ising: f64
begin
  ! set up discretization offsets
  ndb := nxdis * nydis
  xdis := xsiz / max(f64(nxdis), 1.0)
  ydis := ysiz / max(f64(nydis), 1.0)
  xloc := -0.5 * (xsiz + xdis)
  i := 0
  for ix := 0, nxdis
    xloc := xloc + xdis
    yloc := -0.5 * (ysiz + ydis)
    for iy := 0, nydis
      yloc := yloc + ydis
      xdb[i] := xloc
      ydb[i] := yloc
      i := i + 1
    end for
  end for

  rad2 := radius * radius

  ! compute block covariance
  call gslib.cova3(xdb[0], ydb[0], 0.0, xdb[0], ydb[0], 0.0,
    nst, c0, it, cc, aa, irot, rotmat, covres)
  unbias := covres[0]

  if (ndb <= 1) then
    cbb := covres[0]
  else
    cbb := 0.0
    for i := 0, ndb
      for j := 0, ndb
        call gslib.cova3(xdb[i], ydb[i], 0.0, xdb[j], ydb[j], 0.0,
          nst, c0, it, cc, aa, irot, rotmat, covres)
        cov := covres[1]
        if (i == j) then
          cov := cov - c0
        end if
        cbb := cbb + cov
      end for
    end for
    cbb := cbb / f64(ndb * ndb)
  end if

  ! main loop over grid
  for iy := 0, ny
    yloc := ymn + f64(iy) * ysiz
    for ix := 0, nx
      xloc := xmn + f64(ix) * xsiz
      gi := ix + iy * nx

      ! scan all data for nearby samples (brute-force, insertion sort by distance)
      na := 0
      for isam := 0, ndmax
        dist[isam] := 1.0e20
        nums[isam] := 0.0
      end for

      for id := 0, nd
        dx := x[id] - xloc
        dy := y[id] - yloc
        h2 := dx * dx + dy * dy
        ! skip if outside search radius
        k := 0
        if (h2 > rad2) then
          k := 1
        end if
        ! skip if already have enough closer samples
        if (k == 0 and na == ndmax) then
          if (h2 > dist[na - 1]) then
            k := 1
          end if
        end if
        if (k == 0) then
          ! accept this sample
          if (na < ndmax) then
            na := na + 1
          end if
          nums[na - 1] := f64(id)
          dist[na - 1] := h2
          ! insertion sort: shift larger distances right
          n1 := na - 1
          for k := 0, n1
            if (h2 < dist[k]) then
              for jk := 0, n1 - k - 1
                j := n1 - 1 - jk
                dist[j + 1] := dist[j]
                nums[j + 1] := nums[j]
              end for
              dist[k] := h2
              nums[k] := f64(id)
              break
            end if
          end for
        end if
      end for

      ! not enough samples?
      if (na < ndmin) then
        est[gi] := -999.0
        estv[gi] := -999.0
      ! single sample
      else if (na == 1) then
        jj := i32(nums[0])
        call gslib.cova3(xa[0], ya[0], 0.0, xa[0], ya[0], 0.0,
          nst, c0, it, cc, aa, irot, rotmat, covres)
        cb1 := covres[0]
        xx := x[jj] - xloc
        yy := y[jj] - yloc
        if (ndb <= 1) then
          call gslib.cova3(xx, yy, 0.0, xdb[0], ydb[0], 0.0,
            nst, c0, it, cc, aa, irot, rotmat, covres)
          cb := covres[1]
        else
          cb := 0.0
          for i := 0, ndb
            call gslib.cova3(xx, yy, 0.0, xdb[i], ydb[i], 0.0,
              nst, c0, it, cc, aa, irot, rotmat, covres)
            cb := cb + covres[1]
            dx := xx - xdb[i]
            dy := yy - ydb[i]
            if (dx * dx + dy * dy < 1.0e-10) then
              cb := cb - c0
            end if
          end for
          cb := cb / f64(ndb)
        end if
        if (ktype == 0) then
          s[0] := cb / cbb
          est[gi] := s[0] * vr[jj] + (1.0 - s[0]) * skmean
          estv[gi] := cbb - s[0] * cb
        else
          est[gi] := vr[jj]
          estv[gi] := cbb - 2.0 * cb + cb1
        end if
      ! multiple samples — solve kriging system
      else
        ! copy neighbor data
        for ia := 0, na
          jj := i32(nums[ia])
          xa[ia] := x[jj]
          ya[ia] := y[jj]
          vra[ia] := vr[jj]
        end for

        neq := na + ktype
        nn := (neq + 1) * neq / 2

        ! build LHS matrix (upper triangular, packed columnwise)
        in := 0
        for j := 0, na
          for i := 0, j + 1
            call gslib.cova3(xa[i], ya[i], 0.0, xa[j], ya[j], 0.0,
              nst, c0, it, cc, aa, irot, rotmat, covres)
            a[in] := covres[1]
            in := in + 1
          end for
          ! build RHS vector
          xx := xa[j] - xloc
          yy := ya[j] - yloc
          if (ndb <= 1) then
            call gslib.cova3(xx, yy, 0.0, xdb[0], ydb[0], 0.0,
              nst, c0, it, cc, aa, irot, rotmat, covres)
            cb := covres[1]
          else
            cb := 0.0
            for i := 0, ndb
              call gslib.cova3(xx, yy, 0.0, xdb[i], ydb[i], 0.0,
                nst, c0, it, cc, aa, irot, rotmat, covres)
              cb := cb + covres[1]
              dx := xx - xdb[i]
              dy := yy - ydb[i]
              if (dx * dx + dy * dy < 1.0e-10) then
                cb := cb - c0
              end if
            end for
            cb := cb / f64(ndb)
          end if
          r[j] := cb
          rr[j] := cb
        end for

        ! unbiasedness constraint for ordinary kriging
        if (ktype == 1) then
          for i := 0, na
            a[in] := unbias
            in := in + 1
          end for
          a[in] := 0.0
          r[neq - 1] := unbias
          rr[neq - 1] := unbias
        end if

        ! solve
        call gslib.ksol(neq, a, r, s, ksolres)
        ising := ksolres[0]
        if (ising /= 0.0) then
          est[gi] := -999.0
          estv[gi] := -999.0
        else
          ! compute estimate and variance
          sumw := 0.0
          est[gi] := 0.0
          estv[gi] := cbb
          if (ktype == 1) then
            estv[gi] := estv[gi] - s[na] * unbias
          end if
          for i := 0, na
            sumw := sumw + s[i]
            est[gi] := est[gi] + s[i] * vra[i]
            estv[gi] := estv[gi] - s[i] * rr[i]
          end for
          if (ktype == 0) then
            est[gi] := est[gi] + (1.0 - sumw) * skmean
          end if
        end if
      end if
    end for
  end for
end
