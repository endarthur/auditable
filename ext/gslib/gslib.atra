! ══════════════════════════════════════════════════════════════════════
! GSLIB — geostatistical library for atra
!
! faithful transcription of Stanford's GSLIB (Deutsch & Journel, 1998).
! same algorithms, same variable names, same accumulation order.
! the Fortran is the spec.
!
! all f64 throughout. Fortran f32 truncation points noted with
! "! NOTE: Fortran uses f32 here" for future bit-identity work.
!
! rotation matrix storage:
!   Fortran: rotmat(MAXROT, 3, 3) with rotmat(ind, i, j)
!   atra:    flat f64 array, matrix ind at rotmat[ind*9 + i*3 + j]
!            (0-indexed, row-major per block)
! ══════════════════════════════════════════════════════════════════════

! ── acorni — ACORN random number generator ────────────────────────────
!
! order 12, modulus 2^30 = 1073741824.
! state: ixv[0] = seed, ixv[1..12] = 0 initially.
! each call advances state and returns uniform [0, 1).
!
! Fortran ref: gslib/acorni.for (Wikramaratna, 1990)

function gslib.acorni(ixv: array i32): f64
var i: i32
begin
  for i := 0, 12
    ixv[i + 1] := ixv[i + 1] + ixv[i]
    if (ixv[i + 1] >= 1073741824) then
      ixv[i + 1] := ixv[i + 1] - 1073741824
    end if
  end for
  gslib.acorni := f64(ixv[12]) / 1073741824.0
end

! ── gauinv — inverse standard normal CDF ──────────────────────────────
!
! Kennedy & Gentle (1980) rational approximation.
! xp[0] receives the result, ierr[0] = 1 on error (p out of range).
!
! NOTE: Fortran truncates xp to f32 via real(...) — we skip this.
! Fortran ref: gslib/gauinv.for

subroutine gslib.gauinv(p: f64; xp: array f64; ierr: array i32)
var pp, y: f64
begin
  ! coefficients
  ! p0..p4 and q0..q4 are hardcoded below (Kennedy & Gentle)

  ierr[0] := 1
  if (p < 1.0e-10) then
    xp[0] := -1.0e10
    call return()
  end if
  if (p > 1.0 - 1.0e-10) then
    xp[0] := 1.0e10
    call return()
  end if
  ierr[0] := 0

  pp := p
  if (p > 0.5) then
    pp := 1.0 - pp
  end if
  xp[0] := 0.0
  if (p == 0.5) then
    call return()
  end if

  ! rational approximation
  y := sqrt(ln(1.0 / (pp * pp)))
  ! NOTE: Fortran uses f32 here (xp = real(...))
  xp[0] := y + ((((y * (-0.0000453642210148) + (-0.0204231210245)) * y
    + (-0.342242088547)) * y + (-1.0)) * y + (-0.322232431088))
    / ((((y * 0.0038560700634 + 0.103537752850) * y
    + 0.531103462366) * y + 0.588581570495) * y + 0.0993484626060)
  if (p <= 0.5) then
    xp[0] := 0.0 - xp[0]
  end if
end

! ── gcum — standard normal CDF ────────────────────────────────────────
!
! Abramowitz & Stegun polynomial approximation (~5 decimal places).
! all f64 (NOTE: Fortran is entirely f32).
!
! Fortran ref: gslib/gcum.for

function gslib.gcum(x: f64): f64
var z, t, e2: f64
begin
  z := x
  if (z < 0.0) then
    z := 0.0 - z
  end if
  t := 1.0 / (1.0 + 0.2316419 * z)
  gslib.gcum := t * (0.31938153 + t * (-0.356563782 + t * (1.781477937
    + t * (-1.821255978 + t * 1.330274429))))
  e2 := 0.0

  ! 6 standard deviations out gets treated as infinity
  if (z <= 6.0) then
    e2 := exp(0.0 - z * z / 2.0) * 0.3989422803
  end if
  gslib.gcum := 1.0 - e2 * gslib.gcum
  if (x >= 0.0) then
    call return(gslib.gcum)
  end if
  gslib.gcum := 1.0 - gslib.gcum
end

! ── powint — power interpolation ──────────────────────────────────────
!
! interpolates y between (xlow,ylow) and (xhigh,yhigh) with power pow.
! EPSLON guard for degenerate intervals.
!
! Fortran ref: gslib/powint.for

function gslib.powint(xlow: f64; xhigh: f64; ylow: f64; yhigh: f64;
  xval: f64; pow: f64): f64
begin
  if (xhigh - xlow < 1.0e-20) then
    gslib.powint := (yhigh + ylow) / 2.0
  else
    gslib.powint := ylow + (yhigh - ylow)
      * ((xval - xlow) / (xhigh - xlow)) ** pow
  end if
end

! ── locate — bisection search in sorted array ─────────────────────────
!
! given sorted xx[n], find j such that xx[j] <= x < xx[j+1].
! 0-indexed. returns j = -1 or j = n-1 for out-of-range.
!
! Fortran ref: gslib/locate.for (adapted from Numerical Recipes)

subroutine gslib.locate(xx: array f64; n, is, ie: i32; x: f64;
  j: array i32)
var jl, ju, jm: i32
begin
  jl := is - 1
  ju := ie
  if (xx[n - 1] <= x) then
    j[0] := ie
    call return()
  end if

  ! bisection loop
  while (ju - jl > 1)
    jm := (ju + jl) / 2
    if ((xx[ie - 1] > xx[is - 1]) == (x > xx[jm - 1])) then
      jl := jm
    else
      ju := jm
    end if
  end while

  j[0] := jl
end

! ── getindx — grid cell index from coordinate ─────────────────────────
!
! maps a point location to grid cell index (0-indexed).
! returns index in idx[0] and inflag in idx[1] (1=in grid, 0=out).
!
! Fortran ref: gslib/getindx.for

subroutine gslib.getindx(n: i32; gmin, siz, loc: f64; idx: array i32)
var index: i32
begin
  ! Fortran uses int((loc-min)/siz + 1.5), 1-indexed
  ! 0-indexed: int((loc-min)/siz + 0.5)
  index := i32(floor((loc - gmin) / siz + 0.5))

  if (index < 0) then
    idx[0] := 0
    idx[1] := 0
  else if (index >= n) then
    idx[0] := n - 1
    idx[1] := 0
  else
    idx[0] := index
    idx[1] := 1
  end if
end

! ── setrot — build anisotropic rotation matrix ────────────────────────
!
! GSLIB angle convention: ang1=azimuth (CW from N), ang2=dip, ang3=rake.
! writes 9 f64 values to rotmat[ind*9 .. ind*9+8].
! anisotropy ratios applied to rows 2 and 3.
!
! Fortran ref: gslib/setrot.for

subroutine gslib.setrot(ang1, ang2, ang3, anis1, anis2: f64;
  ind: i32; rotmat: array f64)
var
  alpha, beta, theta: f64
  sina, sinb, sint, cosa, cosb, cost: f64
  afac1, afac2: f64
  base: i32
begin
  ! convert GSLIB angles to mathematical angles
  if (ang1 >= 0.0 and ang1 < 270.0) then
    alpha := (90.0 - ang1) * 3.141592654 / 180.0
  else
    alpha := (450.0 - ang1) * 3.141592654 / 180.0
  end if
  beta := -1.0 * ang2 * 3.141592654 / 180.0
  theta := ang3 * 3.141592654 / 180.0

  ! sines and cosines
  sina := sin(alpha)
  sinb := sin(beta)
  sint := sin(theta)
  cosa := cos(alpha)
  cosb := cos(beta)
  cost := cos(theta)

  ! anisotropy factors
  afac1 := 1.0 / max(anis1, 1.0e-20)
  afac2 := 1.0 / max(anis2, 1.0e-20)

  ! build rotation matrix at rotmat[ind*9 .. ind*9+8]
  base := ind * 9
  rotmat[base + 0] := cosb * cosa
  rotmat[base + 1] := cosb * sina
  rotmat[base + 2] := 0.0 - sinb
  rotmat[base + 3] := afac1 * (0.0 - cost * sina + sint * sinb * cosa)
  rotmat[base + 4] := afac1 * (cost * cosa + sint * sinb * sina)
  rotmat[base + 5] := afac1 * (sint * cosb)
  rotmat[base + 6] := afac2 * (sint * sina + cost * sinb * cosa)
  rotmat[base + 7] := afac2 * (0.0 - sint * cosa + cost * sinb * sina)
  rotmat[base + 8] := afac2 * (cost * cosb)
end

! ── sqdist — squared anisotropic distance ─────────────────────────────
!
! applies rotation matrix, returns sum of squared transformed components.
! reads from rotmat[ind*9..].
!
! Fortran ref: gslib/sqdist.for

function gslib.sqdist(x1, y1, z1, x2, y2, z2: f64;
  ind: i32; rotmat: array f64): f64
var
  dx, dy, dz, cont: f64
  i, base: i32
begin
  dx := x1 - x2
  dy := y1 - y2
  dz := z1 - z2
  base := ind * 9
  gslib.sqdist := 0.0
  for i := 0, 3
    cont := rotmat[base + i * 3 + 0] * dx
      + rotmat[base + i * 3 + 1] * dy
      + rotmat[base + i * 3 + 2] * dz
    gslib.sqdist := gslib.sqdist + cont * cont
  end for
end

! ── cova3 — nested covariance model evaluation ────────────────────────
!
! 5 model types: 1=spherical, 2=exponential, 3=Gaussian,
!                4=power, 5=hole effect.
!
! simplified interface (single variogram):
!   nst     = number of nested structures
!   c0      = nugget effect
!   it[is]  = model type for structure is (0-indexed)
!   cc[is]  = sill increment for structure is
!   aa[is]  = range/parameter for structure is
!   irot    = base rotation matrix index
!
! result[0] = cmax, result[1] = cova.
!
! Fortran ref: gslib/cova3.for

subroutine gslib.cova3(x1, y1, z1, x2, y2, z2: f64;
  nst: i32; c0: f64;
  it: array i32; cc, aa: array f64;
  irot: i32; rotmat: array f64;
  result: array f64)
var
  is, ir: i32
  cmax, cova, hsqd, h, hr: f64
begin
  ! calculate maximum covariance
  cmax := c0
  for is := 0, nst
    if (it[is] == 4) then
      cmax := cmax + 999.0
    else
      cmax := cmax + cc[is]
    end if
  end for

  ! check for zero distance
  hsqd := gslib.sqdist(x1, y1, z1, x2, y2, z2, irot, rotmat)
  if (hsqd < 1.0e-5) then
    result[0] := cmax
    result[1] := cmax
    call return()
  end if

  ! loop over nested structures
  cova := 0.0
  for is := 0, nst
    ! compute distance for this structure
    if (is /= 0) then
      ir := irot + is
      hsqd := gslib.sqdist(x1, y1, z1, x2, y2, z2, ir, rotmat)
    end if
    h := sqrt(hsqd)

    ! spherical model
    if (it[is] == 1) then
      hr := h / aa[is]
      if (hr < 1.0) then
        cova := cova + cc[is] * (1.0 - hr * (1.5 - 0.5 * hr * hr))
      end if

    ! exponential model
    else if (it[is] == 2) then
      cova := cova + cc[is] * exp(-3.0 * h / aa[is])

    ! Gaussian model
    else if (it[is] == 3) then
      cova := cova + cc[is] * exp(-3.0 * (h / aa[is]) * (h / aa[is]))

    ! power model
    else if (it[is] == 4) then
      cova := cova + cmax - cc[is] * h ** aa[is]

    ! hole effect model
    else if (it[is] == 5) then
      cova := cova + cc[is] * cos(h / aa[is] * 3.14159265)
    end if
  end for

  result[0] := cmax
  result[1] := cova
end
