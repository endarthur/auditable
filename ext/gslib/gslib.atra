! ══════════════════════════════════════════════════════════════════════
! GSLIB — geostatistical library for atra
!
! faithful transcription of Stanford's GSLIB (Deutsch & Journel, 1998).
! same algorithms, same variable names, same accumulation order.
! the Fortran is the spec.
!
! all f64 throughout. Fortran f32 truncation points noted with
! "! NOTE: Fortran uses f32 here" for future bit-identity work.
!
! rotation matrix storage:
!   Fortran: rotmat(MAXROT, 3, 3) with rotmat(ind, i, j)
!   atra:    flat f64 array, matrix ind at rotmat[ind*9 + i*3 + j]
!            (0-indexed, row-major per block)
! ══════════════════════════════════════════════════════════════════════

! ── acorni — ACORN random number generator ────────────────────────────
!
! order 12, modulus 2^30 = 1073741824.
! state: ixv[0] = seed, ixv[1..12] = 0 initially.
! each call advances state and returns uniform [0, 1).
!
! Fortran ref: gslib/acorni.for (Wikramaratna, 1990)

function gslib.acorni(ixv: array i32): f64
var i: i32
begin
  for i := 0, 12
    ixv[i + 1] := ixv[i + 1] + ixv[i]
    if (ixv[i + 1] >= 1073741824) then
      ixv[i + 1] := ixv[i + 1] - 1073741824
    end if
  end for
  gslib.acorni := f64(ixv[12]) / 1073741824.0
end

! ── gauinv — inverse standard normal CDF ──────────────────────────────
!
! Kennedy & Gentle (1980) rational approximation.
! xp[0] receives the result, ierr[0] = 1 on error (p out of range).
!
! NOTE: Fortran truncates xp to f32 via real(...) — we skip this.
! Fortran ref: gslib/gauinv.for

subroutine gslib.gauinv(p: f64; xp: array f64; ierr: array i32)
var pp, y: f64
begin
  ! coefficients
  ! p0..p4 and q0..q4 are hardcoded below (Kennedy & Gentle)

  ierr[0] := 1
  if (p < 1.0e-10) then
    xp[0] := -1.0e10
    call return()
  end if
  if (p > 1.0 - 1.0e-10) then
    xp[0] := 1.0e10
    call return()
  end if
  ierr[0] := 0

  pp := p
  if (p > 0.5) then
    pp := 1.0 - pp
  end if
  xp[0] := 0.0
  if (p == 0.5) then
    call return()
  end if

  ! rational approximation
  y := sqrt(ln(1.0 / (pp * pp)))
  ! NOTE: Fortran uses f32 here (xp = real(...))
  xp[0] := y + ((((y * (-0.0000453642210148) + (-0.0204231210245)) * y
    + (-0.342242088547)) * y + (-1.0)) * y + (-0.322232431088))
    / ((((y * 0.0038560700634 + 0.103537752850) * y
    + 0.531103462366) * y + 0.588581570495) * y + 0.0993484626060)
  if (p <= 0.5) then
    xp[0] := 0.0 - xp[0]
  end if
end

! ── gcum — standard normal CDF ────────────────────────────────────────
!
! Abramowitz & Stegun polynomial approximation (~5 decimal places).
! all f64 (NOTE: Fortran is entirely f32).
!
! Fortran ref: gslib/gcum.for

function gslib.gcum(x: f64): f64
var z, t, e2: f64
begin
  z := x
  if (z < 0.0) then
    z := 0.0 - z
  end if
  t := 1.0 / (1.0 + 0.2316419 * z)
  gslib.gcum := t * (0.31938153 + t * (-0.356563782 + t * (1.781477937
    + t * (-1.821255978 + t * 1.330274429))))
  e2 := 0.0

  ! 6 standard deviations out gets treated as infinity
  if (z <= 6.0) then
    e2 := exp(0.0 - z * z / 2.0) * 0.3989422803
  end if
  gslib.gcum := 1.0 - e2 * gslib.gcum
  if (x >= 0.0) then
    call return(gslib.gcum)
  end if
  gslib.gcum := 1.0 - gslib.gcum
end

! ── powint — power interpolation ──────────────────────────────────────
!
! interpolates y between (xlow,ylow) and (xhigh,yhigh) with power pow.
! EPSLON guard for degenerate intervals.
!
! Fortran ref: gslib/powint.for

function gslib.powint(xlow: f64; xhigh: f64; ylow: f64; yhigh: f64;
  xval: f64; pow: f64): f64
begin
  if (xhigh - xlow < 1.0e-20) then
    gslib.powint := (yhigh + ylow) / 2.0
  else
    gslib.powint := ylow + (yhigh - ylow)
      * ((xval - xlow) / (xhigh - xlow)) ** pow
  end if
end

! ── locate — bisection search in sorted array ─────────────────────────
!
! given sorted xx[n], find j such that xx[j] <= x < xx[j+1].
! 0-indexed. returns j = -1 or j = n-1 for out-of-range.
!
! Fortran ref: gslib/locate.for (adapted from Numerical Recipes)

subroutine gslib.locate(xx: array f64; n, is, ie: i32; x: f64;
  j: array i32)
var jl, ju, jm: i32
begin
  jl := is - 1
  ju := ie
  if (xx[n - 1] <= x) then
    j[0] := ie
    call return()
  end if

  ! bisection loop
  while (ju - jl > 1)
    jm := (ju + jl) / 2
    if ((xx[ie - 1] > xx[is - 1]) == (x > xx[jm - 1])) then
      jl := jm
    else
      ju := jm
    end if
  end while

  j[0] := jl
end

! ── getindx — grid cell index from coordinate ─────────────────────────
!
! maps a point location to grid cell index (0-indexed).
! returns index in idx[0] and inflag in idx[1] (1=in grid, 0=out).
!
! Fortran ref: gslib/getindx.for

subroutine gslib.getindx(n: i32; gmin, siz, loc: f64; idx: array i32)
var index: i32
begin
  ! Fortran uses int((loc-min)/siz + 1.5), 1-indexed
  ! 0-indexed: int((loc-min)/siz + 0.5)
  index := i32(floor((loc - gmin) / siz + 0.5))

  if (index < 0) then
    idx[0] := 0
    idx[1] := 0
  else if (index >= n) then
    idx[0] := n - 1
    idx[1] := 0
  else
    idx[0] := index
    idx[1] := 1
  end if
end

! ── setrot — build anisotropic rotation matrix ────────────────────────
!
! GSLIB angle convention: ang1=azimuth (CW from N), ang2=dip, ang3=rake.
! writes 9 f64 values to rotmat[ind*9 .. ind*9+8].
! anisotropy ratios applied to rows 2 and 3.
!
! Fortran ref: gslib/setrot.for

subroutine gslib.setrot(ang1, ang2, ang3, anis1, anis2: f64;
  ind: i32; rotmat: array f64)
var
  alpha, beta, theta: f64
  sina, sinb, sint, cosa, cosb, cost: f64
  afac1, afac2: f64
  base: i32
begin
  ! convert GSLIB angles to mathematical angles
  if (ang1 >= 0.0 and ang1 < 270.0) then
    alpha := (90.0 - ang1) * 3.141592654 / 180.0
  else
    alpha := (450.0 - ang1) * 3.141592654 / 180.0
  end if
  beta := -1.0 * ang2 * 3.141592654 / 180.0
  theta := ang3 * 3.141592654 / 180.0

  ! sines and cosines
  sina := sin(alpha)
  sinb := sin(beta)
  sint := sin(theta)
  cosa := cos(alpha)
  cosb := cos(beta)
  cost := cos(theta)

  ! anisotropy factors
  afac1 := 1.0 / max(anis1, 1.0e-20)
  afac2 := 1.0 / max(anis2, 1.0e-20)

  ! build rotation matrix at rotmat[ind*9 .. ind*9+8]
  base := ind * 9
  rotmat[base + 0] := cosb * cosa
  rotmat[base + 1] := cosb * sina
  rotmat[base + 2] := 0.0 - sinb
  rotmat[base + 3] := afac1 * (0.0 - cost * sina + sint * sinb * cosa)
  rotmat[base + 4] := afac1 * (cost * cosa + sint * sinb * sina)
  rotmat[base + 5] := afac1 * (sint * cosb)
  rotmat[base + 6] := afac2 * (sint * sina + cost * sinb * cosa)
  rotmat[base + 7] := afac2 * (0.0 - sint * cosa + cost * sinb * sina)
  rotmat[base + 8] := afac2 * (cost * cosb)
end

! ── sqdist — squared anisotropic distance ─────────────────────────────
!
! applies rotation matrix, returns sum of squared transformed components.
! reads from rotmat[ind*9..].
!
! Fortran ref: gslib/sqdist.for

function gslib.sqdist(x1, y1, z1, x2, y2, z2: f64;
  ind: i32; rotmat: array f64): f64
var
  dx, dy, dz, cont: f64
  i, base: i32
begin
  dx := x1 - x2
  dy := y1 - y2
  dz := z1 - z2
  base := ind * 9
  gslib.sqdist := 0.0
  for i := 0, 3
    cont := rotmat[base + i * 3 + 0] * dx
      + rotmat[base + i * 3 + 1] * dy
      + rotmat[base + i * 3 + 2] * dz
    gslib.sqdist := gslib.sqdist + cont * cont
  end for
end

! ── sortem — quickersort with companion arrays ────────────────────────
!
! sorts a[ib..ie-1] in ascending order (0-indexed).
! simultaneously permutes companion arrays b and c.
! nperm = 0: sort a only
! nperm = 1: permute b with a
! nperm = 2: permute b and c with a
!
! Quickersort algorithm (Scowen, ACM 271). explicit stack, no recursion.
! stack depth 64 handles up to 2^64 elements.
!
! Fortran ref: gslib/sortem.for, gslib/dsortem.for

subroutine gslib.sortem(ib, ie: i32; a, b, c: array f64; nperm: i32;
  lt, ut: array i32)
var
  i, j, k, m, p, q: i32
  ta, xa, tb, xb, tc, xc: f64
begin
  ! Quickersort (Scowen, ACM 271). 0-indexed: sorts a[ib..ie-1].
  ! lt/ut are scratch arrays of at least 64 i32 each (stack depth).
  j := ie - 1
  m := 1
  i := ib
  lt[0] := i
  ut[0] := j

  while (m > 0)
    m := m - 1
    i := lt[m]
    j := ut[m]

    ! keep splitting until segment is small
    while (j - i > 1)
      ! segment has 3+ elements — partition
      p := (j + i) / 2
      ta := a[p]
      a[p] := a[i]
      if (nperm >= 1) then
        tb := b[p]
        b[p] := b[i]
      end if
      if (nperm >= 2) then
        tc := c[p]
        c[p] := c[i]
      end if

      ! Hoare partition: scan from both ends
      q := j
      k := i + 1

      ! scan forward for a[k] > ta, backward for a[q] < ta, swap
      while (k <= q)
        ! forward scan
        while (k <= q and a[k] <= ta)
          k := k + 1
        end while
        if (k > q) then
          break
        end if
        ! backward scan
        while (q >= k and a[q] >= ta)
          q := q - 1
        end while
        if (q < k) then
          break
        end if
        ! swap a[k] and a[q]
        xa := a[k]
        a[k] := a[q]
        a[q] := xa
        if (nperm >= 1) then
          xb := b[k]
          b[k] := b[q]
          b[q] := xb
        end if
        if (nperm >= 2) then
          xc := c[k]
          c[k] := c[q]
          c[q] := xc
        end if
        k := k + 1
        q := q - 1
      end while

      ! place pivot: q = k - 1 is the partition point
      q := k - 1
      a[i] := a[q]
      a[q] := ta
      if (nperm >= 1) then
        b[i] := b[q]
        b[q] := tb
      end if
      if (nperm >= 2) then
        c[i] := c[q]
        c[q] := tc
      end if

      ! push larger segment, continue with smaller
      if (q - i > j - q) then
        lt[m] := i
        ut[m] := q - 1
        i := q + 1
      else
        lt[m] := q + 1
        ut[m] := j
        j := q - 1
      end if
      m := m + 1
    end while

    ! segment has 0 or 1 or 2 elements
    if (j > i) then
      if (a[i] > a[j]) then
        xa := a[i]
        a[i] := a[j]
        a[j] := xa
        if (nperm >= 1) then
          xb := b[i]
          b[i] := b[j]
          b[j] := xb
        end if
        if (nperm >= 2) then
          xc := c[i]
          c[i] := c[j]
          c[j] := xc
        end if
      end if
    end if
  end while
end

! ── nscore — normal score transform ───────────────────────────────────
!
! transforms nd data values to standard normal scores N(0,1).
! uses sortem internally.
!
! a[0..nd-1]     = data values (modified: sorted then restored)
! wt[0..nd-1]    = weights (iwt=1) or unused (iwt=0). modified.
! tmp[0..nd-1]   = scratch (stores original indices)
! vrg[0..nd-1]   = output normal scores
! xp[0]          = scratch for gauinv output
! ierr[0]        = scratch for gauinv error flag
! result[0]      = 0 on success, 1 on error
!
! Fortran ref: gslib/nscore.for

subroutine gslib.nscore(nd: i32; a, wt, tmp, vrg, xp: array f64;
  ierr, result, lt, ut: array i32; tmin, tmax: f64; iwt: i32)
var
  i: i32
  twt, oldcp, cp: f64
begin
  result[0] := 0
  twt := 0.0

  ! store original indices and compute total weight
  for i := 0, nd
    tmp[i] := f64(i)
    if (a[i] >= tmin and a[i] < tmax) then
      if (iwt == 0) then
        twt := twt + 1.0
      else
        twt := twt + wt[i]
      end if
    end if
  end for

  if (nd < 1 or twt < 1.0e-20) then
    result[0] := 1
    call return()
  end if

  ! sort data ascending, permuting wt and tmp
  call gslib.sortem(0, nd, a, wt, tmp, 2, lt, ut)

  ! compute cumulative probabilities and normal scores
  oldcp := 0.0
  cp := 0.0
  for i := 0, nd
    if (iwt == 0) then
      cp := cp + 1.0 / twt
    else
      cp := cp + wt[i] / twt
    end if
    wt[i] := (cp + oldcp) / 2.0
    oldcp := cp
    call gslib.gauinv(wt[i], xp, ierr)
    vrg[i] := xp[0]
  end for

  ! restore original order: sort by tmp (original indices), carrying a and vrg.
  ! Fortran uses iperm=3 (tmp, wt, vr, vrg) but we only need a and vrg back.
  ! wt is consumed — not needed after this point.
  call gslib.sortem(0, nd, tmp, a, vrg, 2, lt, ut)
end

! ── backtr — back-transform from normal scores ────────────────────────
!
! back-transforms a standard normal deviate using a transform table
! (vr, vrg) and tail options.
!
! vrgs           = normal score to back-transform
! nt             = number of entries in transform table
! vr[0..nt-1]   = original data values (sorted ascending)
! vrg[0..nt-1]  = corresponding normal scores (sorted ascending)
! zmin, zmax     = limits for tail extrapolation
! ltail          = lower tail option (1=linear, 2=power)
! ltpar          = lower tail parameter
! utail          = upper tail option (1=linear, 2=power, 4=hyperbolic)
! utpar          = upper tail parameter
! j[0]           = scratch for locate output
!
! Fortran ref: gslib/backtr.for

function gslib.backtr(vrgs: f64; nt: i32; vr, vrg: array f64;
  zmin, zmax: f64; ltail: i32; ltpar: f64;
  utail: i32; utpar: f64; j: array i32): f64
var
  cdflo, cdfhi, cdfbt, cpow, lambda: f64
  jj: i32
begin
  ! value in the lower tail?
  if (vrgs <= vrg[0]) then
    gslib.backtr := vr[0]
    cdflo := gslib.gcum(vrg[0])
    cdfbt := gslib.gcum(vrgs)
    if (ltail == 1) then
      gslib.backtr := gslib.powint(0.0, cdflo, zmin, vr[0], cdfbt, 1.0)
    else if (ltail == 2) then
      cpow := 1.0 / ltpar
      gslib.backtr := gslib.powint(0.0, cdflo, zmin, vr[0], cdfbt, cpow)
    end if

  ! value in the upper tail?
  else if (vrgs >= vrg[nt - 1]) then
    gslib.backtr := vr[nt - 1]
    cdfhi := gslib.gcum(vrg[nt - 1])
    cdfbt := gslib.gcum(vrgs)
    if (utail == 1) then
      gslib.backtr := gslib.powint(cdfhi, 1.0, vr[nt - 1], zmax, cdfbt, 1.0)
    else if (utail == 2) then
      cpow := 1.0 / utpar
      gslib.backtr := gslib.powint(cdfhi, 1.0, vr[nt - 1], zmax, cdfbt, cpow)
    else if (utail == 4) then
      lambda := (vr[nt - 1] ** utpar) * (1.0 - gslib.gcum(vrg[nt - 1]))
      gslib.backtr := (lambda / (1.0 - gslib.gcum(vrgs))) ** (1.0 / utpar)
    end if

  ! value within the transformation table
  else
    call gslib.locate(vrg, nt, 1, nt, vrgs, j)
    jj := j[0]
    if (jj < 1) then
      jj := 1
    end if
    if (jj > nt - 1) then
      jj := nt - 1
    end if
    ! locate returns 1-indexed j; vrg/vr are 0-indexed
    gslib.backtr := gslib.powint(vrg[jj - 1], vrg[jj], vr[jj - 1], vr[jj],
      vrgs, 1.0)
  end if
end

! ── cova3 — nested covariance model evaluation ────────────────────────
!
! 5 model types: 1=spherical, 2=exponential, 3=Gaussian,
!                4=power, 5=hole effect.
!
! simplified interface (single variogram):
!   nst     = number of nested structures
!   c0      = nugget effect
!   it[is]  = model type for structure is (0-indexed)
!   cc[is]  = sill increment for structure is
!   aa[is]  = range/parameter for structure is
!   irot    = base rotation matrix index
!
! result[0] = cmax, result[1] = cova.
!
! Fortran ref: gslib/cova3.for

subroutine gslib.cova3(x1, y1, z1, x2, y2, z2: f64;
  nst: i32; c0: f64;
  it: array i32; cc, aa: array f64;
  irot: i32; rotmat: array f64;
  result: array f64)
var
  is, ir: i32
  cmax, cova, hsqd, h, hr: f64
begin
  ! calculate maximum covariance
  cmax := c0
  for is := 0, nst
    if (it[is] == 4) then
      cmax := cmax + 999.0
    else
      cmax := cmax + cc[is]
    end if
  end for

  ! check for zero distance
  hsqd := gslib.sqdist(x1, y1, z1, x2, y2, z2, irot, rotmat)
  if (hsqd < 1.0e-5) then
    result[0] := cmax
    result[1] := cmax
    call return()
  end if

  ! loop over nested structures
  cova := 0.0
  for is := 0, nst
    ! compute distance for this structure
    if (is /= 0) then
      ir := irot + is
      hsqd := gslib.sqdist(x1, y1, z1, x2, y2, z2, ir, rotmat)
    end if
    h := sqrt(hsqd)

    ! spherical model
    if (it[is] == 1) then
      hr := h / aa[is]
      if (hr < 1.0) then
        cova := cova + cc[is] * (1.0 - hr * (1.5 - 0.5 * hr * hr))
      end if

    ! exponential model
    else if (it[is] == 2) then
      cova := cova + cc[is] * exp(-3.0 * h / aa[is])

    ! Gaussian model
    else if (it[is] == 3) then
      cova := cova + cc[is] * exp(-3.0 * (h / aa[is]) * (h / aa[is]))

    ! power model
    else if (it[is] == 4) then
      cova := cova + cmax - cc[is] * h ** aa[is]

    ! hole effect model
    else if (it[is] == 5) then
      cova := cova + cc[is] * cos(h / aa[is] * 3.14159265)
    end if
  end for

  result[0] := cmax
  result[1] := cova
end

! ── setsupr — establish super block search limits and sort data ──────
!
! builds a 3D "super block" network and orders data by super block index.
! super block grid spans the kriging/simulation grid.
! data outside the grid are clamped to the nearest edge block.
!
! nd         = number of data points
! x, y, z   = data coordinates (reordered by super block)
! vr         = data values (reordered with coordinates)
! tmp        = scratch array (stores super block index per datum)
! nisb       = cumulative data count per super block (i32 array)
! idx        = scratch i32[2] for getindx
! ixarr      = scratch i32[nd] for index permutation
! lt, ut     = scratch i32[64] each for sortem
!
! outputs:
!   out[0..5] = nxsup, nysup, nzsup, xmnsup, ymnsup, zmnsup
!   out[6..8] = xsizsup, ysizsup, zsizsup  (stored as f64)
!   data arrays x, y, z, vr are reordered by super block.
!   nisb[i] = cumulative number of data up to super block i.
!
! NOTE: Fortran's sortem handles nsort=4+ companions. We use an index-
! based permutation: sort super block index with original indices,
! then permute x, y, z, vr via a copy pass.
!
! Fortran ref: gslib/setsupr.for

subroutine gslib.setsupr(nx: i32; xmn, xsiz: f64; ny: i32; ymn, ysiz: f64;
  nz: i32; zmn, zsiz: f64;
  nd: i32; x, y, z, vr, tmp: array f64;
  nisb, idx, ixarr, lt, ut: array i32;
  maxsbx, maxsby, maxsbz: i32;
  out: array f64)
var
  nxsup, nysup, nzsup: i32
  xsizsup, ysizsup, zsizsup, xmnsup, ymnsup, zmnsup: f64
  i, ii, ix, iy, iz: i32
  nstot: i32
  oi, src: i32
begin
  ! establish number and size of super blocks
  nxsup := min(nx, maxsbx)
  nysup := min(ny, maxsby)
  nzsup := min(nz, maxsbz)
  xsizsup := f64(nx) * xsiz / f64(nxsup)
  ysizsup := f64(ny) * ysiz / f64(nysup)
  zsizsup := f64(nz) * zsiz / f64(nzsup)
  xmnsup := (xmn - 0.5 * xsiz) + 0.5 * xsizsup
  ymnsup := (ymn - 0.5 * ysiz) + 0.5 * ysizsup
  zmnsup := (zmn - 0.5 * zsiz) + 0.5 * zsizsup

  ! initialize super block counts to zero
  nstot := nxsup * nysup * nzsup
  for i := 0, nstot
    nisb[i] := 0
  end for

  ! assign each datum to a super block and count
  for i := 0, nd
    call gslib.getindx(nxsup, xmnsup, xsizsup, x[i], idx)
    ix := idx[0]
    call gslib.getindx(nysup, ymnsup, ysizsup, y[i], idx)
    iy := idx[0]
    call gslib.getindx(nzsup, zmnsup, zsizsup, z[i], idx)
    iz := idx[0]
    ! 0-indexed super block linear index
    ii := ix + iy * nxsup + iz * nxsup * nysup
    tmp[i] := f64(ii)
    nisb[ii] := nisb[ii] + 1
  end for

  ! Build source permutation: ixarr[j] = which original element goes to position j.
  ! Uses counting sort (O(n)) instead of Fortran's sortem with 4+ companions.

  ! Exclusive prefix sum: nisb[i] = start position for block i
  ii := 0
  for i := 0, nstot
    ix := nisb[i]
    nisb[i] := ii
    ii := ii + ix
  end for

  ! Compute source permutation
  for i := 0, nd
    ii := i32(tmp[i])
    ixarr[nisb[ii]] := i
    nisb[ii] := nisb[ii] + 1
  end for

  ! Now nisb[i] = cumulative count up to and including block i (what Fortran returns)

  ! Apply source permutation via cycle-following.
  ! ixarr[j] = source index for position j.
  ! Mark visited by setting ixarr[j] = -1 after processing.
  for i := 0, nd
    if (ixarr[i] /= i and ixarr[i] >= 0) then
      ! start of a cycle: save element at position i
      out[9] := x[i]
      out[10] := y[i]
      out[11] := z[i]
      out[12] := vr[i]

      oi := i
      src := ixarr[i]
      while (src /= i)
        x[oi] := x[src]
        y[oi] := y[src]
        z[oi] := z[src]
        vr[oi] := vr[src]
        ixarr[oi] := -1
        oi := src
        src := ixarr[oi]
      end while

      ! close cycle: place saved element at the last position
      x[oi] := out[9]
      y[oi] := out[10]
      z[oi] := out[11]
      vr[oi] := out[12]
      ixarr[oi] := -1
    end if
  end for

  ! store output grid parameters
  out[0] := f64(nxsup)
  out[1] := f64(nysup)
  out[2] := f64(nzsup)
  out[3] := xmnsup
  out[4] := ymnsup
  out[5] := zmnsup
  out[6] := xsizsup
  out[7] := ysizsup
  out[8] := zsizsup
end

! ── picksup — determine which super blocks to search ─────────────────
!
! given a search radius and rotation matrix, determines which super
! blocks could contain data within the search ellipsoid.
!
! tests all super block offset combinations (i,j,k), checks if the
! closest corner-to-corner distance is within the search radius.
!
! outputs:
!   nsbtosr[0]          = number of super blocks to search
!   ixsbtosr, iysbtosr, izsbtosr = offset arrays
!
! Fortran ref: gslib/picksupr.for (picksup)

subroutine gslib.picksup(nxsup: i32; xsizsup: f64;
  nysup: i32; ysizsup: f64;
  nzsup: i32; zsizsup: f64;
  irot: i32; rotmat: array f64; radsqd: f64;
  nsbtosr: array i32;
  ixsbtosr, iysbtosr, izsbtosr: array i32)
var
  i, j, k, i1, j1, k1, i2, j2, k2: i32
  xo, yo, zo, xdis, ydis, zdis: f64
  shortest, hsqd: f64
  ns: i32
begin
  ns := 0

  for i := -(nxsup - 1), nxsup
    for j := -(nysup - 1), nysup
      for k := -(nzsup - 1), nzsup
        xo := f64(i) * xsizsup
        yo := f64(j) * ysizsup
        zo := f64(k) * zsizsup

        ! find closest distance between corners of the two super blocks
        shortest := 1.0e21
        for i1 := -1, 2
          for j1 := -1, 2
            for k1 := -1, 2
              for i2 := -1, 2
                for j2 := -1, 2
                  for k2 := -1, 2
                    if (i1 /= 0 and j1 /= 0 and k1 /= 0
                        and i2 /= 0 and j2 /= 0 and k2 /= 0) then
                      xdis := f64(i1 - i2) * 0.5 * xsizsup + xo
                      ydis := f64(j1 - j2) * 0.5 * ysizsup + yo
                      zdis := f64(k1 - k2) * 0.5 * zsizsup + zo
                      hsqd := gslib.sqdist(0.0, 0.0, 0.0,
                        xdis, ydis, zdis, irot, rotmat)
                      if (hsqd < shortest) then
                        shortest := hsqd
                      end if
                    end if
                  end for
                end for
              end for
            end for
          end for
        end for

        ! keep this super block if close enough
        if (shortest <= radsqd) then
          ixsbtosr[ns] := i
          iysbtosr[ns] := j
          izsbtosr[ns] := k
          ns := ns + 1
        end if
      end for
    end for
  end for

  nsbtosr[0] := ns
end

! ── srchsupr — search within super blocks for nearby data ────────────
!
! searches data sorted by setsupr for points within the search radius.
! returns indices of close data sorted by distance.
! optional octant search (noct > 0) limits data per octant.
!
! close[0..nclose-1]   = indices (f64) of nearby data, sorted by distance
! tmp[0..nclose-1]     = squared distances (reused from setsupr's tmp)
! result[0]            = nclose
! result[1]            = infoct (number of informed octants)
! idx                  = scratch i32[2] for getindx
! inoct                = scratch i32[8] for octant counts
! lt, ut               = scratch i32[64] each for sortem
!
! Fortran ref: gslib/srchsupr.for

subroutine gslib.srchsupr(xloc, yloc, zloc, radsqd: f64;
  irot: i32; rotmat: array f64;
  nsbtosr: i32; ixsbtosr, iysbtosr, izsbtosr: array i32;
  noct, nd: i32;
  x, y, z, tmp, close: array f64;
  nisb: array i32;
  nxsup: i32; xmnsup, xsizsup: f64;
  nysup: i32; ymnsup, ysizsup: f64;
  nzsup: i32; zmnsup, zsizsup: f64;
  result: array f64;
  idx, inoct, lt, ut: array i32)
var
  ix, iy, iz: i32
  isup, ixsup, iysup, izsup: i32
  ii, nums, nc, i, j: i32
  hsqd: f64
  na, nt, iq: i32
  dx, dy, dz, h: f64
  ci: i32
begin
  ! determine super block of estimation point
  call gslib.getindx(nxsup, xmnsup, xsizsup, xloc, idx)
  ix := idx[0]
  call gslib.getindx(nysup, ymnsup, ysizsup, yloc, idx)
  iy := idx[0]
  call gslib.getindx(nzsup, zmnsup, zsizsup, zloc, idx)
  iz := idx[0]

  nc := 0

  ! loop over super blocks to search
  for isup := 0, nsbtosr
    ixsup := ix + ixsbtosr[isup]
    iysup := iy + iysbtosr[isup]
    izsup := iz + izsbtosr[isup]

    ! skip if outside grid (0-indexed: valid range [0, n-1])
    if (ixsup < 0 or ixsup >= nxsup
        or iysup < 0 or iysup >= nysup
        or izsup < 0 or izsup >= nzsup) then
      ! continue to next isup (use else-if to skip rest)
    else
      ! linear index of super block (0-indexed)
      ii := ixsup + iysup * nxsup + izsup * nxsup * nysup

      ! figure out data range in this super block
      if (ii == 0) then
        nums := nisb[0]
        i := 0
      else
        nums := nisb[ii] - nisb[ii - 1]
        i := nisb[ii - 1]
      end if

      ! check each datum in this super block
      for j := 0, nums
        hsqd := gslib.sqdist(xloc, yloc, zloc,
          x[i], y[i], z[i], irot, rotmat)
        if (hsqd <= radsqd) then
          close[nc] := f64(i)
          tmp[nc] := hsqd
          nc := nc + 1
        end if
        i := i + 1
      end for
    end if
  end for

  ! sort nearby samples by distance
  if (nc > 1) then
    call gslib.sortem(0, nc, tmp, close, close, 1, lt, ut)
  end if

  ! if not doing octant search, return
  if (noct <= 0) then
    result[0] := f64(nc)
    result[1] := 0.0
    call return()
  end if

  ! octant search: partition data into octants
  for i := 0, 8
    inoct[i] := 0
  end for

  nt := 8 * noct
  na := 0
  for j := 0, nc
    ci := i32(close[j])
    h := tmp[j]
    dx := x[ci] - xloc
    dy := y[ci] - yloc
    dz := z[ci] - zloc

    ! determine octant (0-indexed: 0-7)
    if (dz >= 0.0) then
      iq := 3
      if (dx <= 0.0 and dy > 0.0) then
        iq := 0
      end if
      if (dx > 0.0 and dy >= 0.0) then
        iq := 1
      end if
      if (dx < 0.0 and dy <= 0.0) then
        iq := 2
      end if
    else
      iq := 7
      if (dx <= 0.0 and dy > 0.0) then
        iq := 4
      end if
      if (dx > 0.0 and dy >= 0.0) then
        iq := 5
      end if
      if (dx < 0.0 and dy <= 0.0) then
        iq := 6
      end if
    end if

    inoct[iq] := inoct[iq] + 1

    ! keep if octant not yet full
    if (inoct[iq] <= noct) then
      close[na] := f64(ci)
      tmp[na] := h
      na := na + 1
      if (na == nt) then
        break
      end if
    end if
  end for

  nc := na
  result[1] := 0.0
  for i := 0, 8
    if (inoct[i] > 0) then
      result[1] := result[1] + 1.0
    end if
  end for
  result[0] := f64(nc)
end

! ── ksol — kriging system solver (upper triangular) ─────────────────
!
! solves a system of linear equations stored as an upper triangular
! packed matrix (columnwise). pivots on the diagonal, no pivot search.
!
! for ordinary/simple kriging only — NOT for universal kriging.
! use ktsol (Gaussian elimination with pivoting) for UK.
!
! a[0..nn-1]    = upper triangular packed LHS matrix (modified)
!                 nn = neq*(neq+1)/2
! r[0..neq-1]   = right hand side vector (modified)
! s[0..neq-1]   = solution vector (output)
! result[0]      = ising: 0=ok, -1=neq<=1, k=null pivot at iteration k
!
! Fortran ref: gslib/ksol.for
! NOTE: simplified to nright=1, nsb=1 (the kb2d case).

subroutine gslib.ksol(neq: i32; a, r, s, result: array f64)
var
  m1, k, i, j: i32
  kk, ii, ij, ll, lp: i32
  ak, piv, ap: f64
  tol: f64
begin
  ! Translated from Fortran ksol.for. Uses 1-indexed internal arithmetic
  ! (k, i, j, kk, ii, ij, ll are 1-based positions into packed array).
  ! a[], r[], s[] are 0-indexed — we subtract 1 when accessing them.
  !
  ! Packed upper triangular columnwise (1-indexed):
  !   element (i,j), j>=i, is at position i + j*(j-1)/2

  tol := 1.0e-7

  if (neq <= 1) then
    result[0] := -1.0
    call return()
  end if

  result[0] := 0.0
  m1 := neq - 1
  kk := 0

  ! forward elimination (triangulation)
  ! Note: all loop variables (k, i, j, kk, ii, ij, ll) use 1-based indexing
  ! to match Fortran ksol.for exactly. Array accesses subtract 1.
  ! atra for loops are half-open [start, end), so Fortran "do k=1,m1"
  ! becomes "for k := 1, m1+1".
  for k := 1, m1 + 1
    kk := kk + k
    ak := a[kk - 1]
    if (abs(ak) < tol) then
      result[0] := f64(k)
      call return()
    end if
    piv := 1.0 / ak
    lp := 0
    ii := kk
    for i := k, m1 + 1
      ll := ii
      ii := ii + i
      ap := a[ii - 1] * piv
      lp := lp + 1
      ij := ii - k + 1
      for j := i, m1 + 1
        ij := ij + j
        ll := ll + j
        a[ij - 1] := a[ij - 1] - ap * a[ll - 1]
      end for
      ! modify RHS
      r[k + lp - 1] := r[k + lp - 1] - ap * r[k - 1]
    end for
  end for

  ! check last pivot (nn = neq*(neq+1)/2, 1-indexed)
  ij := neq * (neq + 1) / 2
  if (abs(a[ij - 1]) < tol) then
    result[0] := f64(neq)
    call return()
  end if

  ! back substitution
  piv := 1.0 / a[ij - 1]
  s[neq - 1] := r[neq - 1] * piv
  i := neq
  kk := ij
  for ii := 1, m1 + 1
    kk := kk - i
    piv := 1.0 / a[kk - 1]
    i := i - 1
    ap := r[i - 1]
    ij := kk
    for j := i, m1 + 1
      ij := ij + j
      ap := ap - a[ij - 1] * s[j]
    end for
    s[i - 1] := ap * piv
  end for
end

! ── ktsol — kriging system solver (full matrix, partial pivoting) ──
!
! Gaussian elimination with partial pivoting. Full n×n matrix
! (column-major), single RHS, single variable.
!
! simplified from Fortran ktsol(n, ns, nv, ...) with ns=1, nv=1.
!
! a[0..n*n-1]   = LHS matrix (column-major, modified in place)
! b[0..n-1]     = RHS vector (modified — holds solution after back-sub)
! s[0..n-1]     = solution output (copy of b after back-sub)
! result[0]     = 0=ok, -1 if n<=1, k if pivot k is near-zero
!
! use ktsol (not ksol) when the system may have drift terms or be
! poorly conditioned — partial pivoting avoids breakdowns.
!
! Fortran ref: gslib/ktsol.for
! NOTE: Fortran uses column-major a((k-1)*n + i) for element (row i, col k).
! We preserve column-major here: element (row i, col j) = a[j*n + i], 0-indexed.

subroutine gslib.ktsol(n: i32; a, b, s, result: array f64)
var
  nm1, k, kp1, i, j: i32
  kdiag, npiv, ipiv, i1, j1, j2, i2: i32
  t, tol: f64
begin
  tol := 1.0e-10

  if (n <= 1) then
    result[0] := -1.0
    call return()
  end if

  result[0] := 0.0
  nm1 := n - 1

  ! Gaussian elimination with partial pivoting
  for k := 0, nm1
    kp1 := k + 1
    ! column-major diagonal: element (k, k) = a[k*n + k]
    kdiag := k * n + k

    ! find the pivot — max |a(i, k)| for i = k..n-1
    npiv := kdiag
    ipiv := k
    i1 := kdiag
    for i := kp1, n
      i1 := i1 + 1
      if (abs(a[i1]) > abs(a[npiv])) then
        npiv := i1
        ipiv := i
      end if
    end for

    ! swap pivot and diagonal
    t := a[npiv]
    a[npiv] := a[kdiag]
    a[kdiag] := t

    ! test for singularity
    if (abs(a[kdiag]) < tol) then
      result[0] := f64(k + 1)
      call return()
    end if

    ! compute multipliers (store in sub-diagonal of column k)
    i1 := kdiag
    for i := kp1, n
      i1 := i1 + 1
      a[i1] := 0.0 - a[i1] / a[kdiag]
    end for

    ! interchange and eliminate column by column
    j1 := kdiag
    j2 := npiv
    for j := kp1, n
      j1 := j1 + n
      j2 := j2 + n
      t := a[j2]
      a[j2] := a[j1]
      a[j1] := t
      i1 := j1
      i2 := kdiag
      for i := kp1, n
        i1 := i1 + 1
        i2 := i2 + 1
        a[i1] := a[i1] + a[i2] * a[j1]
      end for
    end for

    ! interchange and modify the RHS
    t := b[ipiv]
    b[ipiv] := b[k]
    b[k] := t
    j1 := k
    j2 := kdiag
    for j := kp1, n
      j1 := j1 + 1
      j2 := j2 + 1
      b[j1] := b[j1] + b[k] * a[j2]
    end for
  end for

  ! test last pivot
  kdiag := n * n - 1
  if (abs(a[kdiag]) < tol) then
    result[0] := f64(n)
    call return()
  end if

  ! back substitution
  ! Fortran: kdiag starts at nva = n*n (1-indexed diagonal of last row),
  ! kb starts at nvb2 = n (1-indexed last element of b).
  ! k=1..nm1 handles rows n down to 2, then row 1 after the loop.
  ! In 0-indexed column-major: diag of row i = a[i*n + i].

  for k := 1, n
    ! row index (0-indexed): n - k
    i := n - k
    kdiag := i * n + i
    b[i] := b[i] / a[kdiag]
    t := 0.0 - b[i]
    ! update rows 0..i-1 using column i
    i1 := i * n
    for j := 0, i
      b[j] := b[j] + a[i1 + j] * t
    end for
  end for
  ! row 0
  b[0] := b[0] / a[0]

  ! copy solution to s
  for i := 0, n
    s[i] := b[i]
  end for
end

! ── kb2d — 2D ordinary/simple kriging ──────────────────────────────
!
! estimates point or block values on a 2D grid by ordinary or simple
! kriging. uses cova3/setrot for covariance evaluation and ksol for
! the kriging system. brute-force neighbor search (all data scanned).
!
! parameters:
!   nx, ny           grid dimensions
!   xmn, ymn         grid origin (center of first cell)
!   xsiz, ysiz       cell sizes
!   nxdis, nydis      block discretization (1x1 = point kriging)
!   nd               number of data
!   x, y, vr         data coordinates and values
!   ndmin, ndmax      min/max neighbors
!   radius            search radius
!   ktype             0=simple, 1=ordinary kriging
!   skmean            simple kriging mean
!   nst               number of nested structures
!   c0                nugget
!   it                model types (i32[nst])
!   cc, aa            sill/range arrays (f64[nst])
!   irot              base rotation index (setrot already called)
!   rotmat            rotation matrices (9*f64 per structure)
!   est               output estimates (f64[nx*ny])
!   estv              output variances (f64[nx*ny])
!
! scratch arrays:
!   xa, ya, vra      neighbor coords/values (f64[ndmax+1])
!   dist             neighbor distances (f64[ndmax+1])
!   nums             neighbor indices (f64[ndmax+1]) — f64 for sortem compat
!   r, rr, s         kriging vectors (f64[ndmax+2])
!   a                kriging matrix packed (f64[(ndmax+2)*(ndmax+3)/2])
!   xdb, ydb         discretization offsets (f64[nxdis*nydis])
!   covres           scratch for cova3 result (f64[2])
!   ksolres          scratch for ksol result (f64[1])
!
! NOTE: unlike Fortran kb2d which uses cova2 (2D, inline rotation),
! this uses our existing cova3 + setrot (3D, z=0). the rotation
! matrices must be set up before calling kb2d.
!
! Fortran ref: gslib/kb2d.for

subroutine gslib.kb2d(
  nx, ny: i32; xmn, ymn, xsiz, ysiz: f64;
  nxdis, nydis: i32;
  nd: i32; x, y, vr: array f64;
  ndmin, ndmax: i32; radius: f64;
  ktype: i32; skmean: f64;
  nst: i32; c0: f64;
  it: array i32; cc, aa: array f64;
  irot: i32; rotmat: array f64;
  est, estv: array f64;
  xa, ya, vra, dist, nums: array f64;
  r, rr, s, a: array f64;
  xdb, ydb, covres, ksolres: array f64)
var
  ix, iy, id, ia, isam: i32
  xloc, yloc, dx, dy, h2, rad2: f64
  ndb, na, neq, nn: i32
  cbb, cov, cb, unbias, cb1: f64
  xx, yy, sumw: f64
  xdis, ydis: f64
  i, j, k, n1, jk, j1, jj: i32
  in, gi: i32
  ising: f64
begin
  ! set up discretization offsets
  ndb := nxdis * nydis
  xdis := xsiz / max(f64(nxdis), 1.0)
  ydis := ysiz / max(f64(nydis), 1.0)
  xloc := -0.5 * (xsiz + xdis)
  i := 0
  for ix := 0, nxdis
    xloc := xloc + xdis
    yloc := -0.5 * (ysiz + ydis)
    for iy := 0, nydis
      yloc := yloc + ydis
      xdb[i] := xloc
      ydb[i] := yloc
      i := i + 1
    end for
  end for

  rad2 := radius * radius

  ! compute block covariance
  call gslib.cova3(xdb[0], ydb[0], 0.0, xdb[0], ydb[0], 0.0,
    nst, c0, it, cc, aa, irot, rotmat, covres)
  unbias := covres[0]

  if (ndb <= 1) then
    cbb := covres[0]
  else
    cbb := 0.0
    for i := 0, ndb
      for j := 0, ndb
        call gslib.cova3(xdb[i], ydb[i], 0.0, xdb[j], ydb[j], 0.0,
          nst, c0, it, cc, aa, irot, rotmat, covres)
        cov := covres[1]
        if (i == j) then
          cov := cov - c0
        end if
        cbb := cbb + cov
      end for
    end for
    cbb := cbb / f64(ndb * ndb)
  end if

  ! main loop over grid
  for iy := 0, ny
    yloc := ymn + f64(iy) * ysiz
    for ix := 0, nx
      xloc := xmn + f64(ix) * xsiz
      gi := ix + iy * nx

      ! scan all data for nearby samples (brute-force, insertion sort by distance)
      na := 0
      for isam := 0, ndmax
        dist[isam] := 1.0e20
        nums[isam] := 0.0
      end for

      for id := 0, nd
        dx := x[id] - xloc
        dy := y[id] - yloc
        h2 := dx * dx + dy * dy
        ! skip if outside search radius
        k := 0
        if (h2 > rad2) then
          k := 1
        end if
        ! skip if already have enough closer samples
        if (k == 0 and na == ndmax) then
          if (h2 > dist[na - 1]) then
            k := 1
          end if
        end if
        if (k == 0) then
          ! accept this sample
          if (na < ndmax) then
            na := na + 1
          end if
          nums[na - 1] := f64(id)
          dist[na - 1] := h2
          ! insertion sort: shift larger distances right
          n1 := na - 1
          for k := 0, n1
            if (h2 < dist[k]) then
              for jk := 0, n1 - k
                j := n1 - 1 - jk
                dist[j + 1] := dist[j]
                nums[j + 1] := nums[j]
              end for
              dist[k] := h2
              nums[k] := f64(id)
              break
            end if
          end for
        end if
      end for

      ! not enough samples?
      if (na < ndmin) then
        est[gi] := -999.0
        estv[gi] := -999.0
      ! single sample
      else if (na == 1) then
        jj := i32(nums[0])
        call gslib.cova3(xa[0], ya[0], 0.0, xa[0], ya[0], 0.0,
          nst, c0, it, cc, aa, irot, rotmat, covres)
        cb1 := covres[0]
        xx := x[jj] - xloc
        yy := y[jj] - yloc
        if (ndb <= 1) then
          call gslib.cova3(xx, yy, 0.0, xdb[0], ydb[0], 0.0,
            nst, c0, it, cc, aa, irot, rotmat, covres)
          cb := covres[1]
        else
          cb := 0.0
          for i := 0, ndb
            call gslib.cova3(xx, yy, 0.0, xdb[i], ydb[i], 0.0,
              nst, c0, it, cc, aa, irot, rotmat, covres)
            cb := cb + covres[1]
            dx := xx - xdb[i]
            dy := yy - ydb[i]
            if (dx * dx + dy * dy < 1.0e-10) then
              cb := cb - c0
            end if
          end for
          cb := cb / f64(ndb)
        end if
        if (ktype == 0) then
          s[0] := cb / cbb
          est[gi] := s[0] * vr[jj] + (1.0 - s[0]) * skmean
          estv[gi] := cbb - s[0] * cb
        else
          est[gi] := vr[jj]
          estv[gi] := cbb - 2.0 * cb + cb1
        end if
      ! multiple samples — solve kriging system
      else
        ! copy neighbor data
        for ia := 0, na
          jj := i32(nums[ia])
          xa[ia] := x[jj]
          ya[ia] := y[jj]
          vra[ia] := vr[jj]
        end for

        neq := na + ktype
        nn := (neq + 1) * neq / 2

        ! build LHS matrix (upper triangular, packed columnwise)
        in := 0
        for j := 0, na
          for i := 0, j + 1
            call gslib.cova3(xa[i], ya[i], 0.0, xa[j], ya[j], 0.0,
              nst, c0, it, cc, aa, irot, rotmat, covres)
            a[in] := covres[1]
            in := in + 1
          end for
          ! build RHS vector
          xx := xa[j] - xloc
          yy := ya[j] - yloc
          if (ndb <= 1) then
            call gslib.cova3(xx, yy, 0.0, xdb[0], ydb[0], 0.0,
              nst, c0, it, cc, aa, irot, rotmat, covres)
            cb := covres[1]
          else
            cb := 0.0
            for i := 0, ndb
              call gslib.cova3(xx, yy, 0.0, xdb[i], ydb[i], 0.0,
                nst, c0, it, cc, aa, irot, rotmat, covres)
              cb := cb + covres[1]
              dx := xx - xdb[i]
              dy := yy - ydb[i]
              if (dx * dx + dy * dy < 1.0e-10) then
                cb := cb - c0
              end if
            end for
            cb := cb / f64(ndb)
          end if
          r[j] := cb
          rr[j] := cb
        end for

        ! unbiasedness constraint for ordinary kriging
        if (ktype == 1) then
          for i := 0, na
            a[in] := unbias
            in := in + 1
          end for
          a[in] := 0.0
          r[neq - 1] := unbias
          rr[neq - 1] := unbias
        end if

        ! solve
        call gslib.ksol(neq, a, r, s, ksolres)
        ising := ksolres[0]
        if (ising /= 0.0) then
          est[gi] := -999.0
          estv[gi] := -999.0
        else
          ! compute estimate and variance
          sumw := 0.0
          est[gi] := 0.0
          estv[gi] := cbb
          if (ktype == 1) then
            estv[gi] := estv[gi] - s[na] * unbias
          end if
          for i := 0, na
            sumw := sumw + s[i]
            est[gi] := est[gi] + s[i] * vra[i]
            estv[gi] := estv[gi] - s[i] * rr[i]
          end for
          if (ktype == 0) then
            est[gi] := est[gi] + (1.0 - sumw) * skmean
          end if
        end if
      end if
    end for
  end for
end

! ── kt3d — 3D kriging (SK, OK, KT/UK) ──────────────────────────────
!
! kriging of a 3D rectangular grid. supports:
!   ktype=0 — simple kriging (SK)
!   ktype=1 — ordinary kriging (OK)
!   ktype=2 — SK with locally varying mean (external variable as local mean)
!   ktype=3 — KT/UK: kriging with trend (up to 9 polynomial drift terms)
!             plus optional external drift
!
! uses ktsol (Gaussian elimination with partial pivoting) for the
! kriging system — handles drift terms and ill-conditioned systems.
! uses super block search (setsupr/picksup/srchsupr, called by JS)
! for efficient neighbor lookup.
!
! data coordinates are shifted to be relative to block corner for drift:
!   xa = x(ind) - xloc + 0.5*xsiz  (same as Fortran kt3d)
!
! parameters:
!   nx, ny, nz      grid dimensions
!   xmn, ymn, zmn   grid origin (center of first cell)
!   xsiz, ysiz, zsiz  cell sizes
!   nxdis, nydis, nzdis  block discretization
!   nd              number of data
!   x, y, z, vr, ve  data (coordinates, values, external drift variable)
!   ndmin, ndmax     min/max neighbors
!   radius           search radius (isotropic; anisotropy in rotmat)
!   sang1..sanis2   search ellipsoid angles and anisotropy ratios
!   ktype            kriging type (0=SK, 1=OK, 2=SK+ext mean, 3=KT/UK)
!   skmean           simple kriging mean (ktype=0)
!   idrif[0..8]     drift term flags: x,y,z,x²,y²,z²,xy,xz,yz
!   nst, c0          variogram: number of structures, nugget
!   it, cc, aa       variogram: types, sills, ranges per structure
!   irot, rotmat     base rotation index and rotation matrices
!   nsbtosr, ixsbtosr, iysbtosr, izsbtosr, nisb, supout
!                    super block search arrays (from setsupr/picksup)
!   est, estv        output estimates and variances (f64[nx*ny*nz])
!   xa..getindxres   scratch arrays (see interface)
!
! NOTE: koption (jackknife), iktype (IK distribution), and itrend
! (estimate trend itself) are omitted — always grid estimation mode.
!
! Fortran ref: kt3d.for (subroutine kt3d)

subroutine gslib.kt3d(
  nx, ny, nz: i32; xmn, ymn, zmn, xsiz, ysiz, zsiz: f64;
  nxdis, nydis, nzdis: i32;
  nd: i32; x, y, z, vr, ve: array f64;
  ndmin, ndmax: i32; radius: f64;
  sang1, sang2, sang3, sanis1, sanis2: f64;
  ktype: i32; skmean: f64;
  idrif: array i32;
  nst: i32; c0: f64; it: array i32; cc, aa: array f64;
  irot: i32; rotmat: array f64;
  nsbtosr: i32; ixsbtosr, iysbtosr, izsbtosr, nisb: array i32;
  supout: array f64;
  est, estv: array f64;
  xa, ya, za, vra, vea: array f64;
  r, rr, s, a: array f64;
  xdb, ydb, zdb: array f64;
  close: array f64;
  covres: array f64;
  inoct: array i32;
  getindxres: array i32;
  lt, ut: array i32)
var
  ix, iy, iz, index, gi: i32
  xloc, yloc, zloc: f64
  ndb, na, neq, mdt, nclose: i32
  cbb, cov, cb, cb1, unbias: f64
  covmax, resc, radsqd: f64
  isrot, ind, i, j, k, im: i32
  dx, dy, dz: f64
  xdis, ydis, zdis: f64
  nxsup, nysup, nzsup: i32
  xmnsup, ymnsup, zmnsup: f64
  xsizsup, ysizsup, zsizsup: f64
  nxy: i32
  sumw, wt: f64
  ising: f64
  resce, extest: f64
  skmean_loc: f64
  infoct: f64
  skip: i32
begin
  ! ── compute covmax and rescaling factor ──
  radsqd := radius * radius
  covmax := c0
  for i := 0, nst
    if (it[i] == 4) then
      covmax := covmax + 999.0
    else
      covmax := covmax + cc[i]
    end if
  end for

  if (radsqd < 1.0) then
    resc := 2.0 * radius / max(covmax, 0.0001)
  else
    resc := (4.0 * radsqd) / max(covmax, 0.0001)
  end if
  resc := 1.0 / resc

  ! search rotation index is nst (irot + nst = last structure + 1)
  isrot := irot + nst

  ! ── compute number of drift terms ──
  mdt := 1
  for i := 0, 9
    mdt := mdt + idrif[i]
  end for
  if (ktype == 3) then
    mdt := mdt + 1
  end if
  if (ktype == 0 or ktype == 2) then
    mdt := 0
  end if

  ! ── set up discretization points ──
  ndb := nxdis * nydis * nzdis
  xdis := xsiz / max(f64(nxdis), 1.0)
  ydis := ysiz / max(f64(nydis), 1.0)
  zdis := zsiz / max(f64(nzdis), 1.0)
  i := 0
  xloc := -0.5 * (xsiz + xdis)
  for ix := 0, nxdis
    xloc := xloc + xdis
    yloc := -0.5 * (ysiz + ydis)
    for iy := 0, nydis
      yloc := yloc + ydis
      zloc := -0.5 * (zsiz + zdis)
      for iz := 0, nzdis
        zloc := zloc + zdis
        ! Fortran: xdb(i) = xloc + 0.5*xsiz (relative to lower-left corner)
        xdb[i] := xloc + 0.5 * xsiz
        ydb[i] := yloc + 0.5 * ysiz
        zdb[i] := zloc + 0.5 * zsiz
        i := i + 1
      end for
    end for
  end for

  ! ── block covariance ──
  call gslib.cova3(xdb[0], ydb[0], zdb[0], xdb[0], ydb[0], zdb[0],
    nst, c0, it, cc, aa, irot, rotmat, covres)
  unbias := covres[0]
  cbb := covres[0]

  if (ndb > 1) then
    cbb := 0.0
    for i := 0, ndb
      for j := 0, ndb
        call gslib.cova3(xdb[i], ydb[i], zdb[i], xdb[j], ydb[j], zdb[j],
          nst, c0, it, cc, aa, irot, rotmat, covres)
        cov := covres[1]
        if (i == j) then
          cov := cov - c0
        end if
        cbb := cbb + cov
      end for
    end for
    cbb := cbb / f64(ndb * ndb)
  end if

  ! ── mean values of drift functions over discretization points ──
  ! bv stored in covres scratch? no, use first 9 entries of rr as scratch.
  ! Actually, we need bv[0..8] persistent. Let's use the first 9 entries of
  ! the rr array which is neq_max long (ndmax + mdt_max). We'll overwrite
  ! before each kriging system build anyway.
  ! Better: store in xdb/ydb/zdb past ndb, or use a separate approach.
  ! Simplest: compute bv on the fly in the drift section.
  ! Actually the Fortran precomputes bv[1..9] = mean of drift functions * resc.
  ! We need these at multiple grid nodes. Store them in the 9 entries of
  ! the 'a' array before index 0 (no, can't). Let's use rr[0..8] as bv
  ! storage — rr gets overwritten per grid node anyway. But rr needs to be
  ! neq long per node...
  !
  ! Solution: caller provides enough space in rr for max(neq_max, 9).
  ! We precompute bv into rr[0..8] now, then read from rr before each
  ! grid node overwrites rr.
  ! Actually that won't work because rr is overwritten during the kriging loop.
  !
  ! Real solution: store bv in supout[9..17] — supout has at least 13 entries.
  ! The plan says supout is the super block output array. Let's use entries
  ! [9..17] which are safe (setsupr only uses [0..8], and [9..12] are temp).
  !
  ! Actually, simplest: just compute bv into supout[9..17].

  for i := 0, 9
    supout[9 + i] := 0.0
  end for
  for i := 0, ndb
    supout[9] := supout[9] + xdb[i]
    supout[10] := supout[10] + ydb[i]
    supout[11] := supout[11] + zdb[i]
    supout[12] := supout[12] + xdb[i] * xdb[i]
    supout[13] := supout[13] + ydb[i] * ydb[i]
    supout[14] := supout[14] + zdb[i] * zdb[i]
    supout[15] := supout[15] + xdb[i] * ydb[i]
    supout[16] := supout[16] + xdb[i] * zdb[i]
    supout[17] := supout[17] + ydb[i] * zdb[i]
  end for
  for i := 0, 9
    supout[9 + i] := (supout[9 + i] / max(f64(ndb), 1.0)) * resc
  end for

  ! ── read super block parameters ──
  nxsup := i32(supout[0])
  nysup := i32(supout[1])
  nzsup := i32(supout[2])
  xmnsup := supout[3]
  ymnsup := supout[4]
  zmnsup := supout[5]
  xsizsup := supout[6]
  ysizsup := supout[7]
  zsizsup := supout[8]

  nxy := nx * ny

  ! ══════════════════════════════════════════════════════════════════
  ! MAIN LOOP OVER ALL GRID NODES
  ! ══════════════════════════════════════════════════════════════════

  for index := 0, nx * ny * nz
    ! decompose linear index to ix, iy, iz (0-indexed)
    iz := index / nxy
    iy := (index - iz * nxy) / nx
    ix := index - iz * nxy - iy * nx
    xloc := xmn + f64(ix) * xsiz
    yloc := ymn + f64(iy) * ysiz
    zloc := zmn + f64(iz) * zsiz
    gi := index

    ! default: unestimated
    skip := 0

    ! ── search for nearby data ──
    ! xa used as tmp (distances) for srchsupr — overwritten later with data coords
    call gslib.srchsupr(xloc, yloc, zloc, radsqd,
      isrot, rotmat,
      nsbtosr, ixsbtosr, iysbtosr, izsbtosr,
      0, nd,
      x, y, z, xa, close,
      nisb,
      nxsup, xmnsup, xsizsup,
      nysup, ymnsup, ysizsup,
      nzsup, zmnsup, zsizsup,
      covres,
      getindxres, inoct, lt, ut)

    nclose := i32(covres[0])

    ! ── load nearby data into xa, ya, za, vra, vea ──
    na := 0
    for i := 0, nclose
      ind := i32(close[i] + 0.5)
      if (na < ndmax) then
        ! shift coordinates relative to block corner (as Fortran does)
        xa[na] := x[ind] - xloc + 0.5 * xsiz
        ya[na] := y[ind] - yloc + 0.5 * ysiz
        za[na] := z[ind] - zloc + 0.5 * zsiz
        vra[na] := vr[ind]
        vea[na] := ve[ind]
        na := na + 1
      end if
    end for

    ! ── test number of samples ──
    if (na < ndmin) then
      est[gi] := -999.0
      estv[gi] := -999.0
      skip := 1
    end if

    ! test if enough samples for drift terms
    if (skip == 0 and na >= 1 and na <= mdt) then
      est[gi] := -999.0
      estv[gi] := -999.0
      skip := 1
    end if

    ! ── handle single sample case ──
    if (skip == 0 and na <= 1) then
      call gslib.cova3(xa[0], ya[0], za[0], xa[0], ya[0], za[0],
        nst, c0, it, cc, aa, irot, rotmat, covres)
      cb1 := covres[0]

      if (ndb <= 1) then
        call gslib.cova3(xa[0], ya[0], za[0], xdb[0], ydb[0], zdb[0],
          nst, c0, it, cc, aa, irot, rotmat, covres)
        cb := covres[1]
      else
        cb := 0.0
        for i := 0, ndb
          call gslib.cova3(xa[0], ya[0], za[0], xdb[i], ydb[i], zdb[i],
            nst, c0, it, cc, aa, irot, rotmat, covres)
          cb := cb + covres[1]
          dx := xa[0] - xdb[i]
          dy := ya[0] - ydb[i]
          dz := za[0] - zdb[i]
          if (dx * dx + dy * dy + dz * dz < 1.0e-6) then
            cb := cb - c0
          end if
        end for
        cb := cb / f64(ndb)
      end if

      skmean_loc := skmean
      if (ktype == 2) then
        skmean_loc := vea[0]
      end if
      if (ktype == 0 or ktype == 2) then
        wt := cb / cb1
        est[gi] := wt * vra[0] + (1.0 - wt) * skmean_loc
        estv[gi] := cbb - wt * cb
      else
        est[gi] := vra[0]
        estv[gi] := cbb - 2.0 * cb + cb1
      end if
      skip := 1
    end if

    ! ── multiple samples: build and solve kriging system ──
    if (skip == 0) then
      neq := mdt + na

      ! initialize kriging matrix (full, column-major for ktsol)
      for i := 0, neq * neq
        a[i] := 0.0
      end for

      ! fill covariance part of LHS matrix
      for i := 0, na
        for j := i, na
          call gslib.cova3(xa[i], ya[i], za[i], xa[j], ya[j], za[j],
            nst, c0, it, cc, aa, irot, rotmat, covres)
          cov := covres[1]
          ! column-major: a[col*neq + row]
          a[j * neq + i] := cov
          a[i * neq + j] := cov
        end for
      end for

      ! OK unbiasedness constraint (if neq > na, first drift row/col is na)
      if (neq > na) then
        for i := 0, na
          a[na * neq + i] := unbias
          a[i * neq + na] := unbias
        end for
      end if

      ! build RHS vector
      for i := 0, na
        if (ndb <= 1) then
          call gslib.cova3(xa[i], ya[i], za[i], xdb[0], ydb[0], zdb[0],
            nst, c0, it, cc, aa, irot, rotmat, covres)
          cb := covres[1]
        else
          cb := 0.0
          for j := 0, ndb
            call gslib.cova3(xa[i], ya[i], za[i], xdb[j], ydb[j], zdb[j],
              nst, c0, it, cc, aa, irot, rotmat, covres)
            cb := cb + covres[1]
            dx := xa[i] - xdb[j]
            dy := ya[i] - ydb[j]
            dz := za[i] - zdb[j]
            if (dx * dx + dy * dy + dz * dz < 1.0e-6) then
              cb := cb - c0
            end if
          end for
          cb := cb / f64(ndb)
        end if
        r[i] := cb
        rr[i] := cb
      end for

      ! RHS for OK constraint
      if (neq > na) then
        r[na] := unbias
        rr[na] := unbias
      end if

      ! ── add drift term constraints ──
      im := na

      ! drift 1: linear x
      if (idrif[0] == 1) then
        im := im + 1
        for k := 0, na
          a[im * neq + k] := xa[k] * resc
          a[k * neq + im] := xa[k] * resc
        end for
        r[im] := supout[9]
        rr[im] := supout[9]
      end if

      ! drift 2: linear y
      if (idrif[1] == 1) then
        im := im + 1
        for k := 0, na
          a[im * neq + k] := ya[k] * resc
          a[k * neq + im] := ya[k] * resc
        end for
        r[im] := supout[10]
        rr[im] := supout[10]
      end if

      ! drift 3: linear z
      if (idrif[2] == 1) then
        im := im + 1
        for k := 0, na
          a[im * neq + k] := za[k] * resc
          a[k * neq + im] := za[k] * resc
        end for
        r[im] := supout[11]
        rr[im] := supout[11]
      end if

      ! drift 4: quadratic x²
      if (idrif[3] == 1) then
        im := im + 1
        for k := 0, na
          a[im * neq + k] := xa[k] * xa[k] * resc
          a[k * neq + im] := xa[k] * xa[k] * resc
        end for
        r[im] := supout[12]
        rr[im] := supout[12]
      end if

      ! drift 5: quadratic y²
      if (idrif[4] == 1) then
        im := im + 1
        for k := 0, na
          a[im * neq + k] := ya[k] * ya[k] * resc
          a[k * neq + im] := ya[k] * ya[k] * resc
        end for
        r[im] := supout[13]
        rr[im] := supout[13]
      end if

      ! drift 6: quadratic z²
      if (idrif[5] == 1) then
        im := im + 1
        for k := 0, na
          a[im * neq + k] := za[k] * za[k] * resc
          a[k * neq + im] := za[k] * za[k] * resc
        end for
        r[im] := supout[14]
        rr[im] := supout[14]
      end if

      ! drift 7: xy
      if (idrif[6] == 1) then
        im := im + 1
        for k := 0, na
          a[im * neq + k] := xa[k] * ya[k] * resc
          a[k * neq + im] := xa[k] * ya[k] * resc
        end for
        r[im] := supout[15]
        rr[im] := supout[15]
      end if

      ! drift 8: xz
      if (idrif[7] == 1) then
        im := im + 1
        for k := 0, na
          a[im * neq + k] := xa[k] * za[k] * resc
          a[k * neq + im] := xa[k] * za[k] * resc
        end for
        r[im] := supout[16]
        rr[im] := supout[16]
      end if

      ! drift 9: yz
      if (idrif[8] == 1) then
        im := im + 1
        for k := 0, na
          a[im * neq + k] := ya[k] * za[k] * resc
          a[k * neq + im] := ya[k] * za[k] * resc
        end for
        r[im] := supout[17]
        rr[im] := supout[17]
      end if

      ! external drift (ktype=3)
      if (ktype == 3) then
        im := im + 1
        ! extest is the external drift variable at this grid node
        ! For grid estimation, we need to pass it somehow. The Fortran
        ! reads from an external file. Here we pass ve[0] of the
        ! estimation point? Actually, in the Fortran, extest is read
        ! from a separate grid file at each grid node. For our interface,
        ! the caller would need to provide this per node.
        !
        ! For now, external drift at grid nodes is NOT supported in this
        ! subroutine — ktype=3 only uses the data's ve values in the
        ! drift columns. The grid node's external drift (extest, resce)
        ! would need to be passed per node. We'll handle this by having
        ! the caller set a flag or by adding extest as a grid array.
        !
        ! Simplification: pass extest array indexed by grid node via est
        ! overwrite? No, that's the output. Instead, require that for
        ! ktype=3, the ve array has nd + nx*ny*nz entries: first nd are
        ! data external drift, remaining are grid node external drift.
        ! Grid node i's extest = ve[nd + i].
        extest := ve[nd + gi]
        resce := covmax / max(abs(extest), 0.0001)
        for k := 0, na
          a[im * neq + k] := vea[k] * resce
          a[k * neq + im] := vea[k] * resce
        end for
        r[im] := extest * resce
        rr[im] := extest * resce
      end if

      ! ── solve the kriging system ──
      call gslib.ktsol(neq, a, r, s, covres)
      ising := covres[0]

      if (ising /= 0.0) then
        est[gi] := -999.0
        estv[gi] := -999.0
      else
        ! compute estimate and variance
        est[gi] := 0.0
        estv[gi] := cbb
        skmean_loc := skmean
        if (ktype == 2) then
          skmean_loc := extest
        end if
        for j := 0, neq
          estv[gi] := estv[gi] - s[j] * rr[j]
          if (j < na) then
            if (ktype == 0) then
              est[gi] := est[gi] + s[j] * (vra[j] - skmean_loc)
            else if (ktype == 2) then
              est[gi] := est[gi] + s[j] * (vra[j] - vea[j])
            else
              est[gi] := est[gi] + s[j] * vra[j]
            end if
          end if
        end for
        if (ktype == 0 or ktype == 2) then
          est[gi] := est[gi] + skmean_loc
        end if
      end if
    end if
  end for
end

! ── ctable — covariance lookup table and spiral search ──────────────
!
! precomputes covariance values at all grid-node offsets within the
! search radius. also builds a spiral search order sorted by variogram
! distance (closest first), used by srchnd.
!
! covtab: (2*nctx+1)*(2*ncty+1)*(2*nctz+1) f64 — covariance lookup
! tmp, order: nlooku scratch for sorting
! ixnode, iynode, iznode: nlooku output — spiral search offsets (1-indexed like Fortran)
! lt, ut: 64 i32 each — sortem scratch
! result[0] = nlooku, result[1] = cbb
!
! Fortran ref: sgsim.for ctable subroutine
! NOTE: ixnode/iynode/iznode store 1-indexed grid-table positions
! (matching Fortran), not 0-indexed offsets. srchnd converts.

subroutine gslib.ctable(
  nst: i32; c0: f64; it: array i32; cc, aa: array f64;
  irot, isrot: i32; rotmat: array f64;
  radsqd: f64;
  nx, ny, nz: i32; xsiz, ysiz, zsiz: f64;
  nctx, ncty, nctz: i32;
  covtab: array f64;
  covres: array f64;
  tmp, order: array f64;
  ixnode, iynode, iznode: array i32;
  lt, ut: array i32;
  result: array f64)
var
  i, j, k, ic, jc, kc: i32
  xx, yy, zz, hsqd, cov: f64
  nlooku, loc, MAXCTX_, MAXCTY_: i32
  il: i32
begin
  MAXCTX_ := 2 * nctx + 1
  MAXCTY_ := 2 * ncty + 1

  ! compute cbb = C(0,0,0; 0,0,0)
  call gslib.cova3(0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
    nst, c0, it, cc, aa, irot, rotmat, covres)
  result[1] := covres[0]

  ! fill covariance table and collect spiral search entries
  nlooku := 0
  for i := 0 - nctx, nctx + 1
    xx := f64(i) * xsiz
    ic := nctx + i
    for j := 0 - ncty, ncty + 1
      yy := f64(j) * ysiz
      jc := ncty + j
      for k := 0 - nctz, nctz + 1
        zz := f64(k) * zsiz
        kc := nctz + k

        call gslib.cova3(0.0, 0.0, 0.0, xx, yy, zz,
          nst, c0, it, cc, aa, irot, rotmat, covres)
        cov := covres[1]

        ! flat index: kc*(2*ncty+1)*(2*nctx+1) + jc*(2*nctx+1) + ic
        covtab[kc * MAXCTY_ * MAXCTX_ + jc * MAXCTX_ + ic] := cov

        ! check if within search radius (anisotropic distance)
        hsqd := gslib.sqdist(0.0, 0.0, 0.0, xx, yy, zz, isrot, rotmat)
        if (hsqd <= radsqd) then
          ! sort key: negative covariance + tiny*distance (closest first)
          tmp[nlooku] := 0.0 - (cov - 1.0e-10 * hsqd)
          ! encode 1-indexed linear position for decoding later
          order[nlooku] := f64(kc * MAXCTY_ * MAXCTX_ + jc * MAXCTX_ + ic + 1)
          nlooku := nlooku + 1
        end if
      end for
    end for
  end for

  ! sort spiral list by variogram distance (closest first)
  if (nlooku > 1) then
    call gslib.sortem(0, nlooku, tmp, order, order, 1, lt, ut)
  end if

  ! decode linear indices back to ixnode/iynode/iznode (1-indexed)
  for il := 0, nlooku
    loc := i32(order[il] + 0.5) - 1
    kc := loc / (MAXCTY_ * MAXCTX_)
    jc := (loc - kc * MAXCTY_ * MAXCTX_) / MAXCTX_
    ic := loc - kc * MAXCTY_ * MAXCTX_ - jc * MAXCTX_
    ! store as 1-indexed (matching Fortran ixnode/iynode/iznode)
    ixnode[il] := ic + 1
    iynode[il] := jc + 1
    iznode[il] := kc + 1
  end for

  result[0] := f64(nlooku)
end

! ── srchnd — search previously simulated nodes ──────────────────────
!
! spirals out from the current node using the ctable lookup order,
! collecting previously simulated nodes.
!
! ix, iy, iz: current grid node (0-indexed)
! sim: simulation grid, UNEST = -99
! ixnode/iynode/iznode: spiral lookup from ctable (1-indexed table positions)
! icnode: output lookup table indices (0-indexed into ixnode/iynode/iznode)
! cnodex/y/z/v: output coordinates and values
! inoct: 8 i32 scratch for octant counts
! result[0] = ncnode
!
! Fortran ref: sgsim.for srchnd subroutine

subroutine gslib.srchnd(
  ix, iy, iz: i32;
  sim: array f64;
  nx, ny, nz: i32;
  xmn, ymn, zmn, xsiz, ysiz, zsiz: f64;
  nlooku: i32;
  ixnode, iynode, iznode: array i32;
  nctx, ncty, nctz: i32;
  nodmax, noct: i32;
  icnode: array i32;
  cnodex, cnodey, cnodez, cnodev: array f64;
  inoct: array i32;
  result: array f64)
var
  ncnode, il, i, j, k, ind, nxy: i32
  idx, idy, idz, iq: i32
  UNEST: f64
begin
  UNEST := -99.0
  nxy := nx * ny
  ncnode := 0

  if (noct > 0) then
    for i := 0, 8
      inoct[i] := 0
    end for
  end if

  ! skip il=0 (origin), start from il=1
  for il := 1, nlooku
    if (ncnode >= nodmax) then
      il := nlooku
    else
      ! compute grid position from offset
      ! ixnode/iynode/iznode are 1-indexed table positions
      ! offset from center: ixnode[il] - nctx - 1 (in Fortran 1-indexed grid)
      ! but our grid is 0-indexed, so:
      i := ix + (ixnode[il] - nctx - 1)
      j := iy + (iynode[il] - ncty - 1)
      k := iz + (iznode[il] - nctz - 1)

      if (i >= 0 and j >= 0 and k >= 0 and i < nx and j < ny and k < nz) then
        ind := i + j * nx + k * nxy

        if (sim[ind] > UNEST) then
          ! octant check
          if (noct > 0) then
            idx := ix - i
            idy := iy - j
            idz := iz - k
            if (idz > 0) then
              iq := 3
              if (idx <= 0 and idy > 0) then
                iq := 0
              end if
              if (idx > 0 and idy >= 0) then
                iq := 1
              end if
              if (idx < 0 and idy <= 0) then
                iq := 2
              end if
            else
              iq := 7
              if (idx <= 0 and idy > 0) then
                iq := 4
              end if
              if (idx > 0 and idy >= 0) then
                iq := 5
              end if
              if (idx < 0 and idy <= 0) then
                iq := 6
              end if
            end if
            if (inoct[iq] < noct) then
              inoct[iq] := inoct[iq] + 1
              icnode[ncnode] := il
              cnodex[ncnode] := xmn + f64(i) * xsiz
              cnodey[ncnode] := ymn + f64(j) * ysiz
              cnodez[ncnode] := zmn + f64(k) * zsiz
              cnodev[ncnode] := sim[ind]
              ncnode := ncnode + 1
            end if
          else
            icnode[ncnode] := il
            cnodex[ncnode] := xmn + f64(i) * xsiz
            cnodey[ncnode] := ymn + f64(j) * ysiz
            cnodez[ncnode] := zmn + f64(k) * zsiz
            cnodev[ncnode] := sim[ind]
            ncnode := ncnode + 1
          end if
        end if
      end if
    end if
  end for

  result[0] := f64(ncnode)
end

! ── krige — kriging system for simulation ───────────────────────────
!
! builds kriging matrix from original data + simulated nodes, solves
! via ksol (packed upper triangular), returns conditional mean and stdev.
!
! ktype: 0=SK, 1=OK, 2=LVM(locally varying mean), 3=ED(external drift),
!        4=CoK(collocated cosimulation)
!
! result[0] = cmean, result[1] = cstdev
!
! Fortran ref: sgsim.for krige subroutine

subroutine gslib.krige(
  ix, iy, iz: i32; xx, yy, zz: f64;
  lktype: i32; gmean: f64;
  nclose: i32; close: array f64;
  nd: i32; x, y, z, vr, sec: array f64;
  ncnode: i32; icnode: array i32;
  cnodex, cnodey, cnodez, cnodev: array f64;
  nctx, ncty, nctz: i32; covtab: array f64;
  ixnode, iynode, iznode: array i32;
  nst: i32; c0: f64; it: array i32; cc, aa: array f64;
  irot: i32; rotmat: array f64;
  cbb: f64;
  nx, ny, nz: i32;
  lvm: array f64; colocorr: f64;
  a, r, rr, s_: array f64;
  vra, vrea: array f64;
  covres: array f64;
  result: array f64)
var
  na, neq, i, j, ind_: i32
  in_: i32
  index, ix1, iy1, iz1, ix2, iy2, iz2: i32
  x1, y1, z1, x2, y2, z2, cov: f64
  ii, jj, kk, MAXCTX_, MAXCTY_, MAXCTZ_: i32
  nxy: i32
  ising: i32
  cmean, cstdev, sumwts: f64
  edmin, edmax, sfmin, sfmax: f64
  lkt: i32
begin
  MAXCTX_ := 2 * nctx + 1
  MAXCTY_ := 2 * ncty + 1
  MAXCTZ_ := 2 * nctz + 1
  nxy := nx * ny

  na := nclose + ncnode
  lkt := lktype

  ! determine system size
  if (lkt == 0) then
    neq := na
  end if
  if (lkt == 1) then
    neq := na + 1
  end if
  if (lkt == 2) then
    neq := na
  end if
  if (lkt == 3) then
    neq := na + 2
  end if
  if (lkt == 4) then
    neq := na + 1
  end if

  ! check lvm bounds for ktype >= 3
  if (lkt >= 3) then
    ind_ := ix + iy * nx + iz * nxy
    if (lvm[ind_] <= -6.0 or lvm[ind_] >= 6.0) then
      lkt := 0
      neq := na
    end if
  end if

  ! ── build kriging matrices (packed upper triangular for ksol) ──
  ! packed storage: element (i,j) with j>=i at position i + j*(j-1)/2 (1-indexed)
  ! = (i-1) + (j-1)*j/2 (0-indexed): pos = (i-1) + (j-1)*j/2

  in_ := 0

  for j := 0, na
    ! resolve location of point j
    if (j < nclose) then
      index := i32(close[j] + 0.5)
      x1 := x[index]
      y1 := y[index]
      z1 := z[index]
      vra[j] := vr[index]
      vrea[j] := sec[index]
      if (lkt == 2) then
        vra[j] := vra[j] - vrea[j]
      end if
    else
      ! previously simulated node
      index := j - nclose
      x1 := cnodex[index]
      y1 := cnodey[index]
      z1 := cnodez[index]
      vra[j] := cnodev[index]
      ind_ := icnode[index]
      ix1 := ix + (ixnode[ind_] - nctx - 1)
      iy1 := iy + (iynode[ind_] - ncty - 1)
      iz1 := iz + (iznode[ind_] - nctz - 1)
      index := ix1 + iy1 * nx + iz1 * nxy
      vrea[j] := lvm[index]
      if (lkt == 2) then
        vra[j] := vra[j] - vrea[j]
      end if
    end if

    ! fill LHS row: covariance between point j and points 0..j
    for i := 0, j + 1
      if (i < nclose) then
        index := i32(close[i] + 0.5)
        x2 := x[index]
        y2 := y[index]
        z2 := z[index]
      else
        index := i - nclose
        x2 := cnodex[index]
        y2 := cnodey[index]
        z2 := cnodez[index]
        ind_ := icnode[index]
        ix2 := ix + (ixnode[ind_] - nctx - 1)
        iy2 := iy + (iynode[ind_] - ncty - 1)
        iz2 := iz + (iznode[ind_] - nctz - 1)
      end if

      ! get covariance: use lookup table if both are simulated nodes
      if (j < nclose or i < nclose) then
        call gslib.cova3(x1, y1, z1, x2, y2, z2,
          nst, c0, it, cc, aa, irot, rotmat, covres)
        a[in_] := covres[1]
      else
        ! both simulated: try covtab lookup
        ii := nctx + (ix1 - ix2)
        jj := ncty + (iy1 - iy2)
        kk := nctz + (iz1 - iz2)
        if (ii < 0 or ii >= MAXCTX_ or jj < 0 or jj >= MAXCTY_ or kk < 0 or kk >= MAXCTZ_) then
          call gslib.cova3(x1, y1, z1, x2, y2, z2,
            nst, c0, it, cc, aa, irot, rotmat, covres)
          a[in_] := covres[1]
        else
          a[in_] := covtab[kk * MAXCTY_ * MAXCTX_ + jj * MAXCTX_ + ii]
        end if
      end if
      in_ := in_ + 1
    end for

    ! ── RHS: covariance between estimation point and point j ──
    if (j < nclose) then
      call gslib.cova3(xx, yy, zz, x1, y1, z1,
        nst, c0, it, cc, aa, irot, rotmat, covres)
      r[j] := covres[1]
    else
      ! try covtab lookup
      ii := nctx + (ix - ix1)
      jj := ncty + (iy - iy1)
      kk := nctz + (iz - iz1)
      if (ii < 0 or ii >= MAXCTX_ or jj < 0 or jj >= MAXCTY_ or kk < 0 or kk >= MAXCTZ_) then
        call gslib.cova3(xx, yy, zz, x1, y1, z1,
          nst, c0, it, cc, aa, irot, rotmat, covres)
        r[j] := covres[1]
      else
        r[j] := covtab[kk * MAXCTY_ * MAXCTX_ + jj * MAXCTX_ + ii]
      end if
    end if
    rr[j] := r[j]
  end for

  ! ── OK constraint ──
  if (lkt == 1 or lkt == 3) then
    for i := 0, na
      in_ := in_ + 1
      a[in_] := 1.0
    end for
    in_ := in_ + 1
    a[in_] := 0.0
    r[na] := 1.0
    rr[na] := 1.0
  end if

  ! ── external drift constraint (ktype=3) ──
  if (lkt == 3) then
    edmin := 999999.0
    edmax := -999999.0
    for i := 0, na
      in_ := in_ + 1
      a[in_] := vrea[i]
      if (a[in_] < edmin) then
        edmin := a[in_]
      end if
      if (a[in_] > edmax) then
        edmax := a[in_]
      end if
    end for
    in_ := in_ + 1
    a[in_] := 0.0
    in_ := in_ + 1
    a[in_] := 0.0
    ind_ := ix + iy * nx + iz * nxy
    r[na + 1] := lvm[ind_]
    rr[na + 1] := r[na + 1]
    if ((edmax - edmin) < 1.0e-10) then
      neq := neq - 1
    end if
  end if

  ! ── collocated cosimulation constraint (ktype=4) ──
  if (lkt == 4) then
    sfmin := 1.0e21
    sfmax := -1.0e21
    for i := 0, na
      in_ := in_ + 1
      a[in_] := colocorr * r[i]
      if (a[in_] < sfmin) then
        sfmin := a[in_]
      end if
      if (a[in_] > sfmax) then
        sfmax := a[in_]
      end if
    end for
    in_ := in_ + 1
    a[in_] := 1.0
    r[na] := colocorr
    rr[na] := colocorr
  end if

  ! ── solve the kriging system ──
  if (neq == 1 and lkt /= 3) then
    s_[0] := r[0] / a[0]
    ising := 0
  else
    call gslib.ksol(neq, a, r, s_, covres)
    ising := i32(covres[0])
  end if

  ! singular: fallback
  if (ising /= 0) then
    result[0] := gmean
    result[1] := 1.0
    call return()
  end if

  ! ── compute conditional mean and variance ──
  cmean := 0.0
  cstdev := cbb
  sumwts := 0.0
  for i := 0, na
    cmean := cmean + s_[i] * vra[i]
    cstdev := cstdev - s_[i] * rr[i]
    sumwts := sumwts + s_[i]
  end for

  if (lkt == 1) then
    cstdev := cstdev - s_[na]
  end if

  if (lkt == 2) then
    cmean := cmean + gmean
  end if

  if (lkt == 4) then
    ind_ := ix + iy * nx + iz * nxy
    cmean := cmean + s_[na] * lvm[ind_]
    cstdev := cstdev - s_[na] * rr[na]
  end if

  ! clamp negative variance
  if (cstdev < 0.0) then
    cstdev := 0.0
  end if
  cstdev := sqrt(cstdev)

  result[0] := cmean
  result[1] := cstdev
end

! ── sgsim — sequential Gaussian simulation ──────────────────────────
!
! one realization per call. caller handles nscore/backtr externally.
! all data should already be in normal score space.
!
! the caller must set up:
!   - rotation matrices (setrot for variogram + search)
!   - super block search (setsupr + picksup)
!   - covariance table (ctable)
!
! sim: nx*ny*nz f64 — output simulation grid
! order: nx*ny*nz f64 — scratch for random path
! close: ndmax f64 — scratch for nearby data indices
! a: neq_max*(neq_max+1)/2 f64 — kriging matrix scratch (packed)
! r, rr, s_: neq_max f64 each — kriging RHS/solution scratch
! vra, vrea: neq_max f64 each — data values scratch
! tmp: nlooku f64 — scratch for srchsupr (distances)
!
! Fortran ref: sgsim.for sgsim subroutine
! NOTE: UNEST = -99 (not -999)

subroutine gslib.sgsim(
  nx, ny, nz: i32; xmn, ymn, zmn, xsiz, ysiz, zsiz: f64;
  nd: i32; x, y, z, vr: array f64;
  sec: array f64; lvm: array f64; colocorr: f64;
  ndmin, ndmax: i32; radius: f64;
  sang1, sang2, sang3, sanis1, sanis2: f64;
  noct, nodmax, ktype: i32;
  nst: i32; c0: f64; it: array i32; cc, aa: array f64;
  irot: i32; rotmat: array f64;
  radsqd: f64;
  isrot: i32;
  nsbtosr: i32; ixsbtosr, iysbtosr, izsbtosr, nisb: array i32;
  supout: array f64;
  nctx, ncty, nctz, nlooku: i32;
  covtab: array f64; ixnode, iynode, iznode: array i32;
  cbb: f64;
  ixv: array i32;
  sim, order, close: array f64;
  icnode: array i32;
  cnodex, cnodey, cnodez, cnodev: array f64;
  a, r, rr, s_: array f64;
  vra, vrea: array f64;
  covres: array f64; getindxres: array i32;
  inoct: array i32; lt, ut: array i32;
  tmp: array f64)
var
  nxyz, nxy, ind, id: i32
  ix_g, iy_g, iz_g, index: i32
  xx_g, yy_g, zz_g, test: f64
  UNEST, EPSLON, TINY: f64
  nclose, ncnode, lktype: i32
  gmean, cmean, cstdev, p: f64
  xp_arr: f64
  nxsup, nysup, nzsup: i32
  xmnsup, ymnsup, zmnsup, xsizsup, ysizsup, zsizsup: f64
  in_: i32
begin
  UNEST := -99.0
  EPSLON := 1.0e-10
  TINY := 0.0001
  nxyz := nx * ny * nz
  nxy := nx * ny

  ! ── 1. random path ──
  for ind := 0, nxyz
    sim[ind] := gslib.acorni(ixv)
    order[ind] := f64(ind)
  end for
  call gslib.sortem(0, nxyz, sim, order, order, 1, lt, ut)

  ! ── 2. initialize simulation grid ──
  for ind := 0, nxyz
    sim[ind] := UNEST
  end for

  ! ── 3. assign conditioning data to nearest grid nodes ──
  for id := 0, nd
    call gslib.getindx(nx, xmn, xsiz, x[id], getindxres)
    ix_g := getindxres[0]
    call gslib.getindx(ny, ymn, ysiz, y[id], getindxres)
    iy_g := getindxres[0]
    call gslib.getindx(nz, zmn, zsiz, z[id], getindxres)
    iz_g := getindxres[0]
    ind := ix_g + iy_g * nx + iz_g * nxy
    xx_g := xmn + f64(ix_g) * xsiz
    yy_g := ymn + f64(iy_g) * ysiz
    zz_g := zmn + f64(iz_g) * zsiz
    test := abs(xx_g - x[id]) + abs(yy_g - y[id]) + abs(zz_g - z[id])

    ! flag close data with 10*UNEST, store data index as positive value
    if (test <= TINY) then
      sim[ind] := 10.0 * UNEST
    end if
  end for

  ! ── 4. replace flags with data values ──
  ! re-assign: for each datum, if grid node was flagged, store the actual value
  for id := 0, nd
    call gslib.getindx(nx, xmn, xsiz, x[id], getindxres)
    ix_g := getindxres[0]
    call gslib.getindx(ny, ymn, ysiz, y[id], getindxres)
    iy_g := getindxres[0]
    call gslib.getindx(nz, zmn, zsiz, z[id], getindxres)
    iz_g := getindxres[0]
    ind := ix_g + iy_g * nx + iz_g * nxy
    xx_g := xmn + f64(ix_g) * xsiz
    yy_g := ymn + f64(iy_g) * ysiz
    zz_g := zmn + f64(iz_g) * zsiz
    test := abs(xx_g - x[id]) + abs(yy_g - y[id]) + abs(zz_g - z[id])
    if (test <= TINY) then
      sim[ind] := vr[id]
    end if
  end for

  ! read super block parameters
  nxsup := i32(supout[0])
  nysup := i32(supout[1])
  nzsup := i32(supout[2])
  xmnsup := supout[3]
  ymnsup := supout[4]
  zmnsup := supout[5]
  xsizsup := supout[6]
  ysizsup := supout[7]
  zsizsup := supout[8]

  ! ── 5. main loop over all nodes ──
  for in_ := 0, nxyz
    index := i32(order[in_] + 0.5)

    ! skip if already simulated (data node) or flagged
    if (sim[index] <= UNEST + EPSLON and sim[index] >= 2.0 * UNEST) then
      ! decompose linear index to ix, iy, iz (0-indexed)
      iz_g := index / nxy
      iy_g := (index - iz_g * nxy) / nx
      ix_g := index - iz_g * nxy - iy_g * nx
      xx_g := xmn + f64(ix_g) * xsiz
      yy_g := ymn + f64(iy_g) * ysiz
      zz_g := zmn + f64(iz_g) * zsiz

      ! search for nearby original data
      call gslib.srchsupr(xx_g, yy_g, zz_g, radsqd,
        isrot, rotmat,
        nsbtosr, ixsbtosr, iysbtosr, izsbtosr,
        noct, nd,
        x, y, z, tmp, close,
        nisb,
        nxsup, xmnsup, xsizsup,
        nysup, ymnsup, ysizsup,
        nzsup, zmnsup, zsizsup,
        covres,
        getindxres, inoct, lt, ut)
      nclose := i32(covres[0])

      if (nclose >= ndmin) then
        if (nclose > ndmax) then
          nclose := ndmax
        end if

        ! search for nearby simulated nodes
        call gslib.srchnd(ix_g, iy_g, iz_g,
          sim, nx, ny, nz,
          xmn, ymn, zmn, xsiz, ysiz, zsiz,
          nlooku, ixnode, iynode, iznode,
          nctx, ncty, nctz,
          nodmax, noct,
          icnode, cnodex, cnodey, cnodez, cnodev,
          inoct, covres)
        ncnode := i32(covres[0])

        ! determine global mean
        if (ktype == 2) then
          gmean := lvm[index]
        else
          gmean := 0.0
        end if

        if ((nclose + ncnode) < 1) then
          cmean := gmean
          cstdev := 1.0
        else
          ! downgrade OK to SK if too few data
          lktype := ktype
          if (ktype == 1 and (nclose + ncnode) < 4) then
            lktype := 0
          end if

          call gslib.krige(ix_g, iy_g, iz_g, xx_g, yy_g, zz_g,
            lktype, gmean,
            nclose, close,
            nd, x, y, z, vr, sec,
            ncnode, icnode,
            cnodex, cnodey, cnodez, cnodev,
            nctx, ncty, nctz, covtab,
            ixnode, iynode, iznode,
            nst, c0, it, cc, aa,
            irot, rotmat,
            cbb,
            nx, ny, nz,
            lvm, colocorr,
            a, r, rr, s_,
            vra, vrea,
            covres,
            covres)
          cmean := covres[0]
          cstdev := covres[1]
        end if

        ! draw random value
        p := gslib.acorni(ixv)
        ! gauinv uses array output: reuse vra[0] as scratch
        call gslib.gauinv(p, vra, getindxres)
        xp_arr := vra[0]
        sim[index] := xp_arr * cstdev + cmean
      end if
    end if
  end for

  ! ── 6. reassign data to grid nodes ──
  for id := 0, nd
    call gslib.getindx(nx, xmn, xsiz, x[id], getindxres)
    ix_g := getindxres[0]
    call gslib.getindx(ny, ymn, ysiz, y[id], getindxres)
    iy_g := getindxres[0]
    call gslib.getindx(nz, zmn, zsiz, z[id], getindxres)
    iz_g := getindxres[0]
    xx_g := xmn + f64(ix_g) * xsiz
    yy_g := ymn + f64(iy_g) * ysiz
    zz_g := zmn + f64(iz_g) * zsiz
    ind := ix_g + iy_g * nx + iz_g * nxy
    test := abs(xx_g - x[id]) + abs(yy_g - y[id]) + abs(zz_g - z[id])
    if (test <= TINY) then
      sim[ind] := vr[id]
    end if
  end for
end

! ── ordrel — correct order relation problems ─────────────────────────
!
! fixes non-monotonic indicator CDFs from independent per-cutoff kriging.
!
! ivtype=0 (categorical): normalize probabilities to sum to 1.
! ivtype=1 (continuous): forward pass + backward pass monotonicity,
!                        average the two. clamp to [0,1].
!
! ccdf[0..ncut-1]  = input CDF values (per cutoff)
! ccdfo[0..ncut-1] = output corrected CDF values
!
! Fortran ref: gslib/ordrel.for

subroutine gslib.ordrel(ivtype, ncut: i32; ccdf, ccdfo: array f64)
var
  i: i32
  sumcdf, v1, v2: f64
begin
  ! clamp to [0, 1]
  for i := 0, ncut
    v1 := ccdf[i]
    if (v1 < 0.0) then
      v1 := 0.0
    end if
    if (v1 > 1.0) then
      v1 := 1.0
    end if
    ccdf[i] := v1
    ccdfo[i] := v1
  end for

  if (ivtype == 0) then
    ! categorical: normalize so probabilities sum to 1
    sumcdf := 0.0
    for i := 0, ncut
      sumcdf := sumcdf + ccdf[i]
    end for
    if (sumcdf <= 0.0) then
      sumcdf := 1.0
    end if
    for i := 0, ncut
      ccdfo[i] := ccdf[i] / sumcdf
    end for
  else
    ! continuous: forward pass (enforce non-decreasing)
    for i := 1, ncut
      if (ccdf[i] < ccdf[i - 1]) then
        ccdf[i] := ccdf[i - 1]
      end if
    end for
    ! backward pass on ccdfo copy (enforce non-decreasing from right)
    for i := ncut - 2, -1, -1
      if (ccdfo[i] > ccdfo[i + 1]) then
        ccdfo[i] := ccdfo[i + 1]
      end if
    end for
    ! average forward and backward corrections
    for i := 0, ncut
      ccdfo[i] := 0.5 * (ccdf[i] + ccdfo[i])
    end for
  end if
end

! ── beyond — draw from kriged indicator CDF ──────────────────────────
!
! given cutoffs + CDF values + a target probability (cdfval), returns
! the corresponding z-value by interpolation/extrapolation.
!
! ivtype     = 0 categorical, 1 continuous
! ncut       = number of cutoffs
! cut[ncut]  = cutoff values
! ccdf[ncut] = CDF values at cutoffs (corrected by ordrel)
! zmin, zmax = range limits for extrapolation
! ltail      = lower tail option (1=linear, 2=power)
! ltpar      = lower tail parameter
! utail      = upper tail option (1=linear, 2=power, 4=hyperbolic)
! utpar      = upper tail parameter
! cdfval     = target probability to draw
! result[0]  = output z-value
!
! simplified vs Fortran: only cdfval→zval direction (simulation use).
! middle interpolation is always linear (option 1).
! no global CDF rescaling (option 3).
!
! Fortran ref: gslib/beyond.for

subroutine gslib.beyond(ivtype, ncut: i32;
  cut, ccdf: array f64;
  zmin, zmax: f64;
  ltail: i32; ltpar: f64;
  utail: i32; utpar: f64;
  cdfval: f64;
  result: array f64)
var
  i, ipart, cclow, cchigh: i32
  zval, cum, powr, lambda: f64
begin
  ! categorical: cumulative search
  if (ivtype == 0) then
    cum := 0.0
    zval := cut[ncut - 1]
    for i := 0, ncut
      cum := cum + ccdf[i]
      if (cdfval <= cum) then
        zval := cut[i]
        break
      end if
    end for
    result[0] := zval
    call return()
  end if

  ! continuous: determine which part of the distribution
  ipart := 1
  if (cdfval <= ccdf[0]) then
    ipart := 0
  end if
  if (cdfval >= ccdf[ncut - 1]) then
    ipart := 2
  end if

  ! lower tail
  if (ipart == 0) then
    if (ltail == 1) then
      zval := gslib.powint(0.0, ccdf[0], zmin, cut[0], cdfval, 1.0)
    else if (ltail == 2) then
      powr := 1.0 / ltpar
      zval := gslib.powint(0.0, ccdf[0], zmin, cut[0], cdfval, powr)
    else
      zval := gslib.powint(0.0, ccdf[0], zmin, cut[0], cdfval, 1.0)
    end if
  end if

  ! middle
  if (ipart == 1) then
    cclow := 0
    for i := 1, ncut
      if (ccdf[i] > cdfval) then
        cclow := i - 1
        break
      end if
      cclow := i
    end for
    cchigh := cclow + 1
    if (cchigh >= ncut) then
      cchigh := ncut - 1
      cclow := cchigh - 1
    end if
    zval := gslib.powint(ccdf[cclow], ccdf[cchigh],
      cut[cclow], cut[cchigh], cdfval, 1.0)
  end if

  ! upper tail
  if (ipart == 2) then
    if (utail == 1) then
      zval := gslib.powint(ccdf[ncut - 1], 1.0,
        cut[ncut - 1], zmax, cdfval, 1.0)
    else if (utail == 2) then
      powr := 1.0 / utpar
      zval := gslib.powint(ccdf[ncut - 1], 1.0,
        cut[ncut - 1], zmax, cdfval, powr)
    else if (utail == 4) then
      lambda := (cut[ncut - 1] ** utpar) * (1.0 - ccdf[ncut - 1])
      zval := (lambda / (1.0 - cdfval)) ** (1.0 / utpar)
    else
      zval := gslib.powint(ccdf[ncut - 1], 1.0,
        cut[ncut - 1], zmax, cdfval, 1.0)
    end if
  end if

  ! clamp to [zmin, zmax]
  if (zval < zmin) then
    zval := zmin
  end if
  if (zval > zmax) then
    zval := zmax
  end if
  result[0] := zval
end

! ── gamv — experimental variogram computation ────────────────────────
!
! O(n^2) all-pairs loop with directional/lag filtering.
! single variable, multiple directions, multiple variogram types.
!
! nd          = number of data points
! x, y, z    = coordinates [nd]
! vr         = data values [nd]
! nlag       = number of lags
! xlag       = unit lag distance
! xltol      = lag distance tolerance (if <= 0, set to xlag/2)
! ndir       = number of directions
! azm, atol, bandwh, dip, dtol, bandwd = directional params [ndir]
! nvarg      = number of variograms to compute
! ivtail, ivhead = not used (single variable, always 0)
! ivtype     = variogram type codes [nvarg] (1-8)
! tmin, tmax = trimming limits
!
! output arrays indexed as (id * nvarg + iv) * (nlag + 2) + il:
!   np[nsiz]   = pair counts (f64 for Wasm convenience)
!   dis[nsiz]  = average distance per lag
!   gam[nsiz]  = variogram measure value
!   hm[nsiz]   = mean of tail values
!   tm[nsiz]   = mean of head values
!   hv[nsiz]   = variance of tail (correlogram only)
!   tv[nsiz]   = variance of head (correlogram only)
!
! nsiz = ndir * nvarg * (nlag + 2)
!
! Fortran ref: gamv.for (subroutine gamv)

subroutine gslib.gamv(
  nd: i32; x, y, z, vr: array f64;
  nlag: i32; xlag, xltol_in: f64;
  ndir: i32; azm, atol, bandwh, dip, dtol, bandwd: array f64;
  nvarg: i32; ivtail, ivhead, ivtype: array i32;
  tmin, tmax: f64;
  np, dis, gam, hm, tm, hv, tv: array f64)
var
  i, j, id, iv, il, ii, it: i32
  lagbeg, lagend, ilag, nsiz, nlp2: i32
  dx, dy, dz, dxs, dys, dzs, hs, h: f64
  dxy, dcazm, band, dcdec: f64
  vrh, vrt, vrhpr, vrtpr, gamma: f64
  azmuth, declin: f64
  xltol, dismxs, rnum, htave: f64
  omni: i32
  ! direction precomputes (up to 20 directions)
  uvxazm, uvyazm, uvzdec, uvhdec, csatol, csdtol: f64
begin
  xltol := xltol_in
  if (xltol <= 0.0) then
    xltol := 0.5 * xlag
  end if
  nlp2 := nlag + 2

  ! initialize output arrays
  nsiz := ndir * nvarg * nlp2
  for i := 0, nsiz
    np[i] := 0.0
    dis[i] := 0.0
    gam[i] := 0.0
    hm[i] := 0.0
    tm[i] := 0.0
    hv[i] := 0.0
    tv[i] := 0.0
  end for

  dismxs := ((f64(nlag) + 0.5 - 1.0e-10) * xlag) ** 2.0

  ! main loop over all pairs
  for i := 0, nd
    for j := i, nd
      dx := x[j] - x[i]
      dy := y[j] - y[i]
      dz := z[j] - z[i]
      dxs := dx * dx
      dys := dy * dy
      dzs := dz * dz
      hs := dxs + dys + dzs
      if (hs <= dismxs) then
      if (hs < 0.0) then
        hs := 0.0
      end if
      h := sqrt(hs)

      ! determine lag range
      if (h <= 1.0e-10) then
        lagbeg := 0
        lagend := 0
      else
        lagbeg := -1
        lagend := -1
        for ilag := 1, nlp2
          if (h >= (xlag * f64(ilag - 1) - xltol) and
              h <= (xlag * f64(ilag - 1) + xltol)) then
            if (lagbeg < 0) then
              lagbeg := ilag
            end if
            lagend := ilag
          end if
        end for
      end if
      if (lagend >= 0) then

      ! loop over directions
      for id := 0, ndir
        ! precompute direction vectors
        azmuth := (90.0 - azm[id]) * 3.14159265 / 180.0
        uvxazm := cos(azmuth)
        uvyazm := sin(azmuth)
        if (atol[id] <= 0.0) then
          csatol := cos(45.0 * 3.14159265 / 180.0)
        else
          csatol := cos(atol[id] * 3.14159265 / 180.0)
        end if
        declin := (90.0 - dip[id]) * 3.14159265 / 180.0
        uvzdec := cos(declin)
        uvhdec := sin(declin)
        if (dtol[id] <= 0.0) then
          csdtol := cos(45.0 * 3.14159265 / 180.0)
        else
          csdtol := cos(dtol[id] * 3.14159265 / 180.0)
        end if

        ! check azimuth
        dxy := sqrt(max(dxs + dys, 0.0))
        if (dxy < 1.0e-10) then
          dcazm := 1.0
        else
          dcazm := (dx * uvxazm + dy * uvyazm) / dxy
        end if
        if (abs(dcazm) >= csatol) then

        ! check horizontal bandwidth
        band := uvxazm * dy - uvyazm * dx
        if (abs(band) <= bandwh[id]) then

        ! check dip angle
        if (dcazm < 0.0) then
          dxy := 0.0 - dxy
        end if
        if (lagbeg == 0) then
          dcdec := 0.0
        else
          dcdec := (dxy * uvhdec + dz * uvzdec) / h
        end if
        if (lagbeg == 0 or abs(dcdec) >= csdtol) then

        ! check vertical bandwidth
        band := uvhdec * dz - uvzdec * dxy
        if (abs(band) <= bandwd[id]) then

        ! omni-directional?
        omni := 0
        if (atol[id] >= 90.0) then
          omni := 1
        end if

        ! loop over variograms
        for iv := 0, nvarg
          it := ivtype[iv]

          ! assign tail and head values based on direction sign
          if (dcazm >= 0.0 and dcdec >= 0.0) then
            vrh := vr[i]
            vrt := vr[j]
            if (omni == 1 or it == 2) then
              vrtpr := vr[i]
              vrhpr := vr[j]
            end if
          else
            vrh := vr[j]
            vrt := vr[i]
            if (omni == 1 or it == 2) then
              vrtpr := vr[j]
              vrhpr := vr[i]
            end if
          end if

          ! trim check
          if (vrt >= tmin and vrh >= tmin and vrt <= tmax and vrh <= tmax) then

            ! ── semivariogram (type 1, 5) ──
            if (it == 1 or it == 5) then
              for il := lagbeg, lagend + 1
                ii := (id * nvarg + iv) * nlp2 + il
                np[ii] := np[ii] + 1.0
                dis[ii] := dis[ii] + h
                tm[ii] := tm[ii] + vrt
                hm[ii] := hm[ii] + vrh
                gam[ii] := gam[ii] + (vrh - vrt) * (vrh - vrt)
                if (omni == 1) then
                  np[ii] := np[ii] + 1.0
                  dis[ii] := dis[ii] + h
                  tm[ii] := tm[ii] + vrtpr
                  hm[ii] := hm[ii] + vrhpr
                  gam[ii] := gam[ii] + (vrhpr - vrtpr) * (vrhpr - vrtpr)
                end if
              end for

            ! ── cross-semivariogram (type 2) ──
            else if (it == 2) then
              if (vrtpr >= tmin and vrhpr >= tmin and
                  vrtpr <= tmax and vrhpr <= tmax) then
                for il := lagbeg, lagend + 1
                  ii := (id * nvarg + iv) * nlp2 + il
                  np[ii] := np[ii] + 1.0
                  dis[ii] := dis[ii] + h
                  tm[ii] := tm[ii] + 0.5 * (vrt + vrtpr)
                  hm[ii] := hm[ii] + 0.5 * (vrh + vrhpr)
                  gam[ii] := gam[ii] + (vrhpr - vrh) * (vrt - vrtpr)
                end for
              end if

            ! ── covariance (type 3) ──
            else if (it == 3) then
              for il := lagbeg, lagend + 1
                ii := (id * nvarg + iv) * nlp2 + il
                np[ii] := np[ii] + 1.0
                dis[ii] := dis[ii] + h
                tm[ii] := tm[ii] + vrt
                hm[ii] := hm[ii] + vrh
                gam[ii] := gam[ii] + vrh * vrt
                if (omni == 1) then
                  np[ii] := np[ii] + 1.0
                  dis[ii] := dis[ii] + h
                  tm[ii] := tm[ii] + vrtpr
                  hm[ii] := hm[ii] + vrhpr
                  gam[ii] := gam[ii] + vrhpr * vrtpr
                end if
              end for

            ! ── correlogram (type 4) ──
            else if (it == 4) then
              for il := lagbeg, lagend + 1
                ii := (id * nvarg + iv) * nlp2 + il
                np[ii] := np[ii] + 1.0
                dis[ii] := dis[ii] + h
                tm[ii] := tm[ii] + vrt
                hm[ii] := hm[ii] + vrh
                hv[ii] := hv[ii] + vrh * vrh
                tv[ii] := tv[ii] + vrt * vrt
                gam[ii] := gam[ii] + vrh * vrt
                if (omni == 1) then
                  np[ii] := np[ii] + 1.0
                  dis[ii] := dis[ii] + h
                  tm[ii] := tm[ii] + vrtpr
                  hm[ii] := hm[ii] + vrhpr
                  hv[ii] := hv[ii] + vrhpr * vrhpr
                  tv[ii] := tv[ii] + vrtpr * vrtpr
                  gam[ii] := gam[ii] + vrhpr * vrtpr
                end if
              end for

            ! ── pairwise relative (type 6) ──
            else if (it == 6) then
              for il := lagbeg, lagend + 1
                ii := (id * nvarg + iv) * nlp2 + il
                if (abs(vrt + vrh) > 1.0e-10) then
                  np[ii] := np[ii] + 1.0
                  dis[ii] := dis[ii] + h
                  tm[ii] := tm[ii] + vrt
                  hm[ii] := hm[ii] + vrh
                  gamma := 2.0 * (vrt - vrh) / (vrt + vrh)
                  gam[ii] := gam[ii] + gamma * gamma
                end if
                if (omni == 1 and abs(vrtpr + vrhpr) > 1.0e-10) then
                  np[ii] := np[ii] + 1.0
                  dis[ii] := dis[ii] + h
                  tm[ii] := tm[ii] + vrtpr
                  hm[ii] := hm[ii] + vrhpr
                  gamma := 2.0 * (vrtpr - vrhpr) / (vrtpr + vrhpr)
                  gam[ii] := gam[ii] + gamma * gamma
                end if
              end for

            ! ── log variogram (type 7) ──
            else if (it == 7) then
              for il := lagbeg, lagend + 1
                ii := (id * nvarg + iv) * nlp2 + il
                if (vrt > 1.0e-10 and vrh > 1.0e-10) then
                  np[ii] := np[ii] + 1.0
                  dis[ii] := dis[ii] + h
                  tm[ii] := tm[ii] + vrt
                  hm[ii] := hm[ii] + vrh
                  gamma := ln(vrt) - ln(vrh)
                  gam[ii] := gam[ii] + gamma * gamma
                end if
                if (omni == 1 and vrtpr > 1.0e-10 and vrhpr > 1.0e-10) then
                  np[ii] := np[ii] + 1.0
                  dis[ii] := dis[ii] + h
                  tm[ii] := tm[ii] + vrtpr
                  hm[ii] := hm[ii] + vrhpr
                  gamma := ln(vrtpr) - ln(vrhpr)
                  gam[ii] := gam[ii] + gamma * gamma
                end if
              end for

            ! ── madogram (type 8) ──
            else if (it == 8) then
              for il := lagbeg, lagend + 1
                ii := (id * nvarg + iv) * nlp2 + il
                np[ii] := np[ii] + 1.0
                dis[ii] := dis[ii] + h
                tm[ii] := tm[ii] + vrt
                hm[ii] := hm[ii] + vrh
                gam[ii] := gam[ii] + abs(vrh - vrt)
                if (omni == 1) then
                  np[ii] := np[ii] + 1.0
                  dis[ii] := dis[ii] + h
                  tm[ii] := tm[ii] + vrtpr
                  hm[ii] := hm[ii] + vrhpr
                  gam[ii] := gam[ii] + abs(vrhpr - vrtpr)
                end if
              end for
            end if

          end if

        end for
        end if
        end if
        end if
        end if
      end for
      end if
      end if
    end for
  end for

  ! compute averages and final variogram measures
  for id := 0, ndir
    for iv := 0, nvarg
      for il := 0, nlp2
        ii := (id * nvarg + iv) * nlp2 + il
        if (np[ii] > 0.0) then
          rnum := np[ii]
          dis[ii] := dis[ii] / rnum
          gam[ii] := gam[ii] / rnum
          hm[ii] := hm[ii] / rnum
          tm[ii] := tm[ii] / rnum
          hv[ii] := hv[ii] / rnum
          tv[ii] := tv[ii] / rnum
          it := ivtype[iv]

          ! semivariogram or cross-semivariogram
          if (it == 1 or it == 2) then
            gam[ii] := 0.5 * gam[ii]

          ! covariance: centering
          else if (it == 3) then
            gam[ii] := gam[ii] - hm[ii] * tm[ii]

          ! correlogram: centering + normalizing
          else if (it == 4) then
            hv[ii] := hv[ii] - hm[ii] * hm[ii]
            if (hv[ii] < 0.0) then
              hv[ii] := 0.0
            end if
            hv[ii] := sqrt(hv[ii])
            tv[ii] := tv[ii] - tm[ii] * tm[ii]
            if (tv[ii] < 0.0) then
              tv[ii] := 0.0
            end if
            tv[ii] := sqrt(tv[ii])
            if (hv[ii] * tv[ii] < 1.0e-10) then
              gam[ii] := 0.0
            else
              gam[ii] := (gam[ii] - hm[ii] * tm[ii]) / (hv[ii] * tv[ii])
            end if
            hv[ii] := hv[ii] * hv[ii]
            tv[ii] := tv[ii] * tv[ii]

          ! general relative semivariogram
          else if (it == 5) then
            htave := 0.5 * (hm[ii] + tm[ii])
            htave := htave * htave
            if (htave < 1.0e-10) then
              gam[ii] := 0.0
            else
              gam[ii] := gam[ii] / htave
            end if

          ! pairwise relative, log, madogram: semi-
          else if (it >= 6) then
            gam[ii] := 0.5 * gam[ii]
          end if
        end if
      end for
    end for
  end for
end

! ── declus — cell declustering ───────────────────────────────────────
!
! grid-based cell declustering. sweeps cell sizes from cmin to cmax,
! for each size tries noff origin offsets, computes inverse-density
! weights, picks optimal cell size by min/max weighted mean.
!
! nd             = number of data
! x, y, z, vr   = data coordinates and values [nd]
! wt             = scratch/output weights [nd]
! tmin, tmax     = trimming limits
! ncell          = number of cell sizes to test
! noff           = number of origin offsets per size
! cmin, cmax     = cell size sweep range (X dimension)
! anisy, anisz   = cell anisotropy ratios (ycs = xcs*anisy, etc.)
! iminmax        = 0=minimize weighted mean, 1=maximize
!
! wtopt[nd]      = output optimal weights (scaled so avg=1)
! result[0]      = optimal cell size
! result[1]      = weighted mean at optimum
! cellwts[ncellt]= scratch i32 (cell counts, sized to max possible)
! idx[nd]        = scratch i32 (cell index per datum)
!
! Fortran ref: declus.for

subroutine gslib.declus(
  nd: i32; x, y, z, vr, wt: array f64;
  tmin, tmax: f64;
  ncell, noff: i32; cmin, cmax, anisy, anisz: f64;
  iminmax: i32;
  wtopt, result: array f64;
  cellwts, idx: array i32)
var
  i, lp, kp, icellx, icelly, icellz, icell, ipoint: i32
  ncellx, ncelly, ncellz, ncellt: i32
  xcs, ycs, zcs, xinc, yinc, zinc: f64
  xmin, xmax, ymin, ymax, zmin, zmax: f64
  xo1, yo1, zo1, xo, yo, zo: f64
  xfac, yfac, zfac, roff: f64
  sumw, sumwg, vrcr, best, vrop, facto: f64
begin
  ! find data bounding box
  xmin := x[0]
  xmax := x[0]
  ymin := y[0]
  ymax := y[0]
  zmin := z[0]
  zmax := z[0]
  for i := 1, nd
    if (x[i] < xmin) then xmin := x[i] end if
    if (x[i] > xmax) then xmax := x[i] end if
    if (y[i] < ymin) then ymin := y[i] end if
    if (y[i] > ymax) then ymax := y[i] end if
    if (z[i] < zmin) then zmin := z[i] end if
    if (z[i] > zmax) then zmax := z[i] end if
  end for

  ! set up cell size increments
  roff := max(f64(noff), 1.0)
  if (ncell <= 1) then
    xinc := 0.0
    yinc := 0.0
    zinc := 0.0
  else
    xinc := (cmax - cmin) / f64(ncell - 1)
    yinc := xinc * anisy
    zinc := xinc * anisz
  end if

  ! set up origin at lower-left of bounding box
  xo1 := xmin - 0.01
  yo1 := ymin - 0.01
  zo1 := zmin - 0.01

  ! initial vrop for comparison (impossible extremes)
  if (iminmax == 0) then
    vrop := 1.0e21
  else
    vrop := -1.0e21
  end if
  best := cmin

  ! main loop over cell sizes
  xcs := cmin - xinc
  ycs := (cmin * anisy) - yinc
  zcs := (cmin * anisz) - zinc

  for lp := 0, ncell + 1
    xcs := xcs + xinc
    ycs := ycs + yinc
    zcs := zcs + zinc
    if (xcs < 1.0e-20) then xcs := 1.0e-20 end if
    if (ycs < 1.0e-20) then ycs := 1.0e-20 end if
    if (zcs < 1.0e-20) then zcs := 1.0e-20 end if

    ! initialize weights
    for i := 0, nd
      wt[i] := 0.0
    end for

    ! max grid cells
    ncellx := i32((xmax - (xo1 - xcs)) / xcs) + 1
    ncelly := i32((ymax - (yo1 - ycs)) / ycs) + 1
    ncellz := i32((zmax - (zo1 - zcs)) / zcs) + 1
    ncellt := ncellx * ncelly * ncellz

    ! origin offset factors
    xfac := min(xcs / roff, 0.5 * (xmax - xmin))
    yfac := min(ycs / roff, 0.5 * (ymax - ymin))
    zfac := min(zcs / roff, 0.5 * (zmax - zmin))

    ! loop over origin offsets
    for kp := 0, noff
      xo := xo1 - f64(kp) * xfac
      yo := yo1 - f64(kp) * yfac
      zo := zo1 - f64(kp) * zfac

      ! zero cell counts
      for i := 0, ncellt
        cellwts[i] := 0
      end for

      ! assign data to cells
      for i := 0, nd
        icellx := i32((x[i] - xo) / xcs)
        icelly := i32((y[i] - yo) / ycs)
        icellz := i32((z[i] - zo) / zcs)
        icell := icellx + icelly * ncellx + icellz * ncellx * ncelly
        idx[i] := icell
        cellwts[icell] := cellwts[icell] + 1
      end for

      ! sum of inverse-density weights
      sumw := 0.0
      for i := 0, nd
        ipoint := idx[i]
        sumw := sumw + 1.0 / f64(cellwts[ipoint])
      end for
      sumw := 1.0 / sumw

      ! accumulate normalized weights
      for i := 0, nd
        ipoint := idx[i]
        wt[i] := wt[i] + (1.0 / f64(cellwts[ipoint])) * sumw
      end for
    end for

    ! compute weighted average for this cell size
    sumw := 0.0
    sumwg := 0.0
    for i := 0, nd
      sumw := sumw + wt[i]
      sumwg := sumwg + wt[i] * vr[i]
    end for
    vrcr := sumwg / sumw

    ! check if this is optimal
    if ((iminmax == 0 and vrcr < vrop) or
        (iminmax == 1 and vrcr > vrop) or
        (ncell <= 1)) then
      best := xcs
      vrop := vrcr
      for i := 0, nd
        wtopt[i] := wt[i]
      end for
    end if
  end for

  ! normalize optimal weights so average = 1
  sumw := 0.0
  for i := 0, nd
    sumw := sumw + wtopt[i]
  end for
  facto := f64(nd) / sumw
  for i := 0, nd
    wtopt[i] := wtopt[i] * facto
  end for

  result[0] := best
  result[1] := vrop
end

! ── ik3d — 3D indicator kriging ──────────────────────────────────────
!
! estimates a full CCDF (cumulative conditional distribution) at each
! grid node using indicator kriging at multiple thresholds/cutoffs.
! each cutoff has its own variogram model. order relations corrected
! via ordrel after per-cutoff kriging.
!
! grid: nx*ny*nz nodes
! ncut cutoffs, each with independent variogram params
! super block search shared across cutoffs
! ktype: 0=SK, 1=OK
!
! variogram arrays indexed [icut * MAXNST + is]:
!   nst_arr[ncut]            = number of structures per cutoff
!   c0_arr[ncut]             = nugget per cutoff
!   it_arr[ncut * MAXNST]    = type codes
!   cc_arr[ncut * MAXNST]    = contributions
!   aa_arr[ncut * MAXNST]    = ranges
!
! vr[nd * ncut] = indicator data (pre-transformed by caller)
! gcdf[ncut]    = global CDF values (SK means)
!
! ccdf_out[nxyz * ncut] = output CDF at each node/cutoff
!
! Fortran ref: ik3d.for (subroutine ik3d)

subroutine gslib.ik3d(
  nx, ny, nz: i32; xmn, ymn, zmn, xsiz, ysiz, zsiz: f64;
  nd: i32; x, y, z: array f64;
  ncut: i32; thresh, gcdf, vr: array f64;
  ivtype, ktype: i32;
  MAXNST: i32;
  nst_arr: array i32; c0_arr: array f64;
  it_arr: array i32; cc_arr, aa_arr: array f64;
  isrot: i32; rotmat: array f64;
  ndmin, ndmax, noct: i32;
  radius: f64;
  nsbtosr: i32; ixsbtosr, iysbtosr, izsbtosr, nisb: array i32;
  supout: array f64;
  ccdf_out: array f64;
  xa, ya, za, vra: array f64;
  r, rr, s_: array f64;
  a: array f64;
  close: array f64;
  covres: array f64;
  inoct, getidxres: array i32;
  ccdf_scratch, ccdfo_scratch: array f64;
  actloc: array f64;
  lt, ut: array i32)
var
  index, ix, iy, iz, nxy, nxyz: i32
  ic, ia, j, ii, i, in_, neq, nca, nclose: i32
  xloc, yloc, zloc: f64
  radsqd, cov, cmax, sumwts: f64
  ising: i32
  nxsup, nysup, nzsup: i32
  xmnsup, ymnsup, zmnsup, xsizsup, ysizsup, zsizsup: f64
begin
  nxy := nx * ny
  nxyz := nxy * nz
  radsqd := radius * radius

  ! read super block parameters
  nxsup := i32(supout[0])
  nysup := i32(supout[1])
  nzsup := i32(supout[2])
  xmnsup := supout[3]
  ymnsup := supout[4]
  zmnsup := supout[5]
  xsizsup := supout[6]
  ysizsup := supout[7]
  zsizsup := supout[8]

  ! main loop over all grid nodes
  for index := 0, nxyz
    iz := index / nxy
    iy := (index - iz * nxy) / nx
    ix := index - iz * nxy - iy * nx
    xloc := xmn + f64(ix) * xsiz
    yloc := ymn + f64(iy) * ysiz
    zloc := zmn + f64(iz) * zsiz

    ! find nearest samples
    call gslib.srchsupr(xloc, yloc, zloc, radsqd, isrot, rotmat,
      nsbtosr, ixsbtosr, iysbtosr, izsbtosr, noct,
      nd, x, y, z, actloc, close, nisb,
      nxsup, xmnsup, xsizsup,
      nysup, ymnsup, ysizsup,
      nzsup, zmnsup, zsizsup,
      covres, getidxres, inoct, lt, ut)
    nclose := i32(covres[0])

    ! too few data?
    if (nclose < ndmin) then
      for ic := 0, ncut
        ccdf_out[index * ncut + ic] := -9.9999
      end for
    else
      ! loop over cutoffs
      for ic := 0, ncut
        ! filter close data for this cutoff
        nca := 0
        for ia := 0, nclose
          j := i32(close[ia] + 0.5)
          ii := i32(actloc[j] + 0.5)
          ! check indicator data valid
          if (vr[ii * ncut + ic] >= 0.0 and vr[ii * ncut + ic] <= 1.0) then
            xa[nca] := x[j]
            ya[nca] := y[j]
            za[nca] := z[j]
            vra[nca] := vr[ii * ncut + ic]
            nca := nca + 1
            if (nca == ndmax) then
              break
            end if
          end if
        end for

        ! no valid samples: use global CDF
        if (nca == 0) then
          ccdf_scratch[ic] := gcdf[ic]
        else
          neq := nca + ktype

          ! build kriging matrix (packed upper triangular)
          in_ := 0
          for j := 0, nca
            for i := 0, j + 1
              call gslib.cova3(xa[i], ya[i], za[i], xa[j], ya[j], za[j],
                nst_arr[ic], c0_arr[ic],
                it_arr, cc_arr, aa_arr,
                ic * MAXNST, rotmat,
                covres)
              a[in_] := covres[1]
              in_ := in_ + 1
            end for
            ! RHS
            call gslib.cova3(xa[j], ya[j], za[j], xloc, yloc, zloc,
              nst_arr[ic], c0_arr[ic],
              it_arr, cc_arr, aa_arr,
              ic * MAXNST, rotmat,
              covres)
            r[j] := covres[1]
          end for

          ! OK unbiasedness constraint
          if (ktype == 1) then
            for i := 0, nca
              a[in_] := 1.0
              in_ := in_ + 1
            end for
            a[in_] := 0.0
            in_ := in_ + 1
            r[neq - 1] := 1.0
          end if

          ! solve
          if (neq == 1) then
            ising := 0
            if (abs(a[0]) < 1.0e-20) then
              ising := 1
            else
              s_[0] := r[0] / a[0]
            end if
          else
            call gslib.ksol(neq, a, r, s_, covres)
            ising := i32(covres[0])
          end if

          ! singular? use global
          if (ising /= 0) then
            for ic := 0, ncut
              ccdf_out[index * ncut + ic] := -9.9999
            end for
            break
          end if

          ! compute kriged indicator estimate
          sumwts := 0.0
          ccdf_scratch[ic] := 0.0
          for i := 0, nca
            ccdf_scratch[ic] := ccdf_scratch[ic] + vra[i] * s_[i]
            sumwts := sumwts + s_[i]
          end for
          if (ktype == 0) then
            ccdf_scratch[ic] := ccdf_scratch[ic] + (1.0 - sumwts) * gcdf[ic]
          end if
        end if
      end for

      ! correct order relations
      call gslib.ordrel(ivtype, ncut, ccdf_scratch, ccdfo_scratch)

      ! store corrected CCDF
      for ic := 0, ncut
        ccdf_out[index * ncut + ic] := ccdfo_scratch[ic]
      end for
    end if
  end for
end

! ── ctable_i — per-cutoff covariance lookup table ────────────────────
!
! builds covtab[nlooku * ncut] for sisim. the spiral search order
! (ixnode/iynode/iznode) is built from the first cutoff and reused
! for all cutoffs. covtab stores per-cutoff covariance at each
! spiral position.
!
! Fortran ref: sisim.for ctable subroutine (adapted for multi-cutoff)

subroutine gslib.ctable_i(
  ncut, MAXNST: i32;
  nst_arr: array i32; c0_arr: array f64;
  it_arr: array i32; cc_arr, aa_arr: array f64;
  irot, isrot: i32; rotmat: array f64;
  radsqd: f64;
  nx, ny, nz: i32; xsiz, ysiz, zsiz: f64;
  nctx, ncty, nctz: i32;
  covtab: array f64;
  covres: array f64;
  tmp, order: array f64;
  ixnode, iynode, iznode: array i32;
  lt, ut: array i32;
  result: array f64)
var
  i, j, k, ic, jc, kc, il, loc: i32
  xx, yy, zz, hsqd, cov: f64
  nlooku, icut, MAXCTX_, MAXCTY_: i32
  covtab_size: i32
begin
  MAXCTX_ := 2 * nctx + 1
  MAXCTY_ := 2 * ncty + 1
  if (nctz == 0) then
    covtab_size := MAXCTX_ * MAXCTY_
  else
    covtab_size := MAXCTX_ * MAXCTY_ * (2 * nctz + 1)
  end if

  ! build spiral search from first cutoff's variogram
  nlooku := 0
  for i := 0 - nctx, nctx + 1
    xx := f64(i) * xsiz
    ic := nctx + i
    for j := 0 - ncty, ncty + 1
      yy := f64(j) * ysiz
      jc := ncty + j
      for k := 0 - nctz, nctz + 1
        zz := f64(k) * zsiz
        kc := nctz + k

        ! first cutoff covariance for sort key
        call gslib.cova3(0.0, 0.0, 0.0, xx, yy, zz,
          nst_arr[0], c0_arr[0],
          it_arr, cc_arr, aa_arr,
          0, rotmat, covres)
        cov := covres[1]

        hsqd := gslib.sqdist(0.0, 0.0, 0.0, xx, yy, zz, isrot, rotmat)
        if (hsqd <= radsqd) then
          tmp[nlooku] := 0.0 - (cov - 1.0e-10 * hsqd)
          order[nlooku] := f64(kc * MAXCTY_ * MAXCTX_ + jc * MAXCTX_ + ic + 1)
          nlooku := nlooku + 1
        end if
      end for
    end for
  end for

  if (nlooku > 1) then
    call gslib.sortem(0, nlooku, tmp, order, order, 1, lt, ut)
  end if

  ! decode linear indices
  for il := 0, nlooku
    loc := i32(order[il] + 0.5) - 1
    kc := loc / (MAXCTY_ * MAXCTX_)
    jc := (loc - kc * MAXCTY_ * MAXCTX_) / MAXCTX_
    ic := loc - kc * MAXCTY_ * MAXCTX_ - jc * MAXCTX_
    ixnode[il] := ic + 1
    iynode[il] := jc + 1
    iznode[il] := kc + 1
  end for

  ! now fill covtab for all cutoffs at each spiral position
  ! covtab[il * ncut + icut] = covariance for spiral pos il, cutoff icut
  for il := 0, nlooku
    ! reconstruct offset from spiral indices
    xx := f64(ixnode[il] - nctx - 1) * xsiz
    yy := f64(iynode[il] - ncty - 1) * ysiz
    zz := f64(iznode[il] - nctz - 1) * zsiz
    for icut := 0, ncut
      call gslib.cova3(0.0, 0.0, 0.0, xx, yy, zz,
        nst_arr[icut], c0_arr[icut],
        it_arr, cc_arr, aa_arr,
        icut * MAXNST, rotmat, covres)
      covtab[il * ncut + icut] := covres[1]
    end for
  end for

  ! compute cbb per cutoff (C(0,0,0; 0,0,0))
  ! result[0] = nlooku, result[1..ncut] = cbb per cutoff
  result[0] := f64(nlooku)
  for icut := 0, ncut
    call gslib.cova3(0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
      nst_arr[icut], c0_arr[icut],
      it_arr, cc_arr, aa_arr,
      icut * MAXNST, rotmat, covres)
    result[1 + icut] := covres[0]
  end for
end

! ── krige_i — per-cutoff indicator kriging for simulation ────────────
!
! kriging for one cutoff at one node during sisim. mixes nearby data
! and previously simulated nodes. uses covtab lookup for node-node
! covariance, cova3 for data-node.
!
! returns kriged estimate in result[0].

subroutine gslib.krige_i(
  ix, iy, iz: i32; xx, yy, zz: f64;
  icut, ncut, MAXNST: i32;
  nclose: i32; close: array f64;
  nd: i32; x, y, z, vr: array f64;
  ncnode: i32; icnode: array i32;
  cnodex, cnodey, cnodez, cnodev: array f64;
  nctx, ncty, nctz: i32;
  nlooku: i32; covtab: array f64;
  ixnode, iynode, iznode: array i32;
  nst_arr: array i32; c0_arr: array f64;
  it_arr: array i32; cc_arr, aa_arr: array f64;
  irot: i32; rotmat: array f64;
  cbb: f64;
  nx, ny, nz: i32;
  ktype: i32; gcdf: f64;
  a, r, rr, s_: array f64;
  vra: array f64;
  covres: array f64;
  result: array f64)
var
  i, j, na, neq, in_: i32
  ii, ix1, iy1, iz1, ix2, iy2, iz2: i32
  ind, ising: i32
  cov, sumwts, est: f64
  MAXCTX_, MAXCTY_, MAXCTZ_: i32
begin
  MAXCTX_ := 2 * nctx + 1
  MAXCTY_ := 2 * ncty + 1
  if (nctz == 0) then
    MAXCTZ_ := 1
  else
    MAXCTZ_ := 2 * nctz + 1
  end if

  ! load original data samples
  na := 0
  for i := 0, nclose
    ii := i32(close[i] + 0.5)
    if (vr[ii * ncut + icut] >= 0.0 and vr[ii * ncut + icut] <= 1.0) then
      vra[na] := vr[ii * ncut + icut]
      na := na + 1
    end if
  end for

  ! append simulated node values
  for i := 0, ncnode
    vra[na + i] := cnodev[i]
  end for

  neq := na + ncnode + ktype
  if (neq < 1) then
    result[0] := gcdf
    call return()
  end if

  ! build kriging matrix
  in_ := 0

  ! data-data block
  for j := 0, na
    for i := 0, j + 1
      ii := i32(close[i] + 0.5)
      ind := i32(close[j] + 0.5)
      call gslib.cova3(x[ii], y[ii], z[ii], x[ind], y[ind], z[ind],
        nst_arr[icut], c0_arr[icut],
        it_arr, cc_arr, aa_arr,
        icut * MAXNST, rotmat, covres)
      a[in_] := covres[1]
      in_ := in_ + 1
    end for
  end for

  ! data-node cross block
  for j := 0, ncnode
    for i := 0, na
      ii := i32(close[i] + 0.5)
      call gslib.cova3(x[ii], y[ii], z[ii],
        cnodex[j], cnodey[j], cnodez[j],
        nst_arr[icut], c0_arr[icut],
        it_arr, cc_arr, aa_arr,
        icut * MAXNST, rotmat, covres)
      a[in_] := covres[1]
      in_ := in_ + 1
    end for

    ! node-node block: use covtab lookup
    for i := 0, j + 1
      ! both are simulated nodes — use covtab if offsets in range
      ix1 := ix + (ixnode[icnode[i]] - nctx - 1)
      iy1 := iy + (iynode[icnode[i]] - ncty - 1)
      iz1 := iz + (iznode[icnode[i]] - nctz - 1)
      ix2 := ix + (ixnode[icnode[j]] - nctx - 1)
      iy2 := iy + (iynode[icnode[j]] - ncty - 1)
      iz2 := iz + (iznode[icnode[j]] - nctz - 1)

      ! offset between two simulated nodes
      ind := i32(abs(f64(ix1 - ix2)))
      if (ind <= nctx and i32(abs(f64(iy1 - iy2))) <= ncty and i32(abs(f64(iz1 - iz2))) <= nctz) then
        ! look up in covtab — but covtab is indexed by spiral position
        ! we need direct covariance call instead
        call gslib.cova3(cnodex[i], cnodey[i], cnodez[i],
          cnodex[j], cnodey[j], cnodez[j],
          nst_arr[icut], c0_arr[icut],
          it_arr, cc_arr, aa_arr,
          icut * MAXNST, rotmat, covres)
      else
        call gslib.cova3(cnodex[i], cnodey[i], cnodez[i],
          cnodex[j], cnodey[j], cnodez[j],
          nst_arr[icut], c0_arr[icut],
          it_arr, cc_arr, aa_arr,
          icut * MAXNST, rotmat, covres)
      end if
      a[in_] := covres[1]
      in_ := in_ + 1
    end for
  end for

  ! RHS: covariance of each sample/node to the estimation point
  for i := 0, na
    ii := i32(close[i] + 0.5)
    call gslib.cova3(x[ii], y[ii], z[ii], xx, yy, zz,
      nst_arr[icut], c0_arr[icut],
      it_arr, cc_arr, aa_arr,
      icut * MAXNST, rotmat, covres)
    r[i] := covres[1]
    rr[i] := r[i]
  end for
  for i := 0, ncnode
    ! node-to-estimate covariance from covtab
    call gslib.cova3(cnodex[i], cnodey[i], cnodez[i], xx, yy, zz,
      nst_arr[icut], c0_arr[icut],
      it_arr, cc_arr, aa_arr,
      icut * MAXNST, rotmat, covres)
    r[na + i] := covres[1]
    rr[na + i] := r[na + i]
  end for

  ! OK unbiasedness constraint
  if (ktype == 1) then
    for i := 0, na + ncnode
      a[in_] := 1.0
      in_ := in_ + 1
    end for
    a[in_] := 0.0
    in_ := in_ + 1
    r[neq - 1] := 1.0
    rr[neq - 1] := 1.0
  end if

  ! solve
  if (neq == 1) then
    if (abs(a[0]) < 1.0e-20) then
      result[0] := gcdf
      call return()
    end if
    s_[0] := r[0] / a[0]
  else
    call gslib.ksol(neq, a, r, s_, covres)
    ising := i32(covres[0])
    if (ising /= 0) then
      result[0] := gcdf
      call return()
    end if
  end if

  ! compute estimate
  est := 0.0
  sumwts := 0.0
  for i := 0, na + ncnode
    est := est + s_[i] * vra[i]
    sumwts := sumwts + s_[i]
  end for
  if (ktype == 0) then
    est := est + (1.0 - sumwts) * gcdf
  end if

  result[0] := est
end

! ── sisim — sequential indicator simulation ──────────────────────────
!
! one realization per call. visits all grid nodes in random order.
! at each node: search nearby data + simulated nodes, krige indicator
! per cutoff via krige_i, correct order relations, draw from CDF
! via beyond.
!
! caller must run setup before calling:
!   setrot for each cutoff's variograms + search rotation
!   setsupr + picksup for conditioning data
!   ctable_i for per-cutoff covariance lookup + spiral search
!
! vr[nd * ncut] = indicator data (pre-transformed)
! gcdf[ncut]    = marginal CDF at cutoffs
! thresh[ncut]  = cutoff values
!
! Fortran ref: sisim.for

subroutine gslib.sisim(
  nx, ny, nz: i32; xmn, ymn, zmn, xsiz, ysiz, zsiz: f64;
  nd: i32; x, y, z, vr: array f64;
  ncut: i32; thresh, gcdf: array f64;
  ivtype, ktype: i32;
  MAXNST: i32;
  nst_arr: array i32; c0_arr: array f64;
  it_arr: array i32; cc_arr, aa_arr: array f64;
  irot, isrot: i32; rotmat: array f64;
  radsqd: f64;
  ndmin, ndmax: i32; radius: f64;
  nodmax, noct: i32;
  nsbtosr: i32; ixsbtosr, iysbtosr, izsbtosr, nisb: array i32;
  supout: array f64;
  nctx, ncty, nctz, nlooku: i32;
  covtab: array f64;
  ixnode, iynode, iznode: array i32;
  cbb_arr: array f64;
  ltail: i32; ltpar: f64;
  utail: i32; utpar: f64;
  zmin, zmax: f64;
  sim, order: array f64;
  ixv: array i32;
  close: array f64;
  icnode: array i32;
  cnodex, cnodey, cnodez, cnodev: array f64;
  a, r, rr, s_: array f64;
  vra: array f64;
  covres: array f64;
  getidxres, inoct: array i32;
  ccdf_scratch, ccdfo_scratch, beyond_result: array f64;
  actloc: array f64;
  lt, ut: array i32)
var
  index, in_, nxyz, nxy, nclose, ncnode: i32
  ix_g, iy_g, iz_g, id, ic, ind: i32
  xx_g, yy_g, zz_g, test, p, cdfval: f64
  UNEST, TINY: f64
  nxsup, nysup, nzsup: i32
  xmnsup, ymnsup, zmnsup, xsizsup, ysizsup, zsizsup: f64
begin
  UNEST := -99.0
  TINY := 0.0001
  nxy := nx * ny
  nxyz := nxy * nz

  ! ── 1. random path ──
  for index := 0, nxyz
    sim[index] := gslib.acorni(ixv)
    order[index] := f64(index)
  end for
  ! sort order by sim (random values)
  call gslib.sortem(0, nxyz, sim, order, order, 1, getidxres, inoct)

  ! ── 2. initialize grid to UNEST ──
  for index := 0, nxyz
    sim[index] := UNEST
  end for

  ! ── 3. assign conditioning data to nearest grid nodes ──
  for id := 0, nd
    call gslib.getindx(nx, xmn, xsiz, x[id], getidxres)
    ix_g := getidxres[0]
    call gslib.getindx(ny, ymn, ysiz, y[id], getidxres)
    iy_g := getidxres[0]
    call gslib.getindx(nz, zmn, zsiz, z[id], getidxres)
    iz_g := getidxres[0]
    xx_g := xmn + f64(ix_g) * xsiz
    yy_g := ymn + f64(iy_g) * ysiz
    zz_g := zmn + f64(iz_g) * zsiz
    ind := ix_g + iy_g * nx + iz_g * nxy
    test := abs(xx_g - x[id]) + abs(yy_g - y[id]) + abs(zz_g - z[id])
    if (test <= TINY and sim[ind] <= UNEST) then
      sim[ind] := 10.0 * UNEST - 1.0
      actloc[ind] := f64(id)
    end if
  end for

  ! ── 4. replace flags with actual data (original scale) ──
  for index := 0, nxyz
    if (sim[index] < UNEST) then
      id := i32(actloc[index] + 0.5)
      ! use first cutoff's original value — stored by caller as indicator
      ! the caller passes original data; we need the original scale value
      ! actloc stores the data index, but we need original-scale value
      ! Convention: vr[id * ncut + 0..ncut-1] = indicators. The caller
      ! also sets actloc[ind] = id to recover original data. We store
      ! a sentinel that the node is conditioned — the value at each node
      ! is interpolated from the CDF.
      ! For now, mark as "conditioned" — during the loop, skip conditioned
      sim[index] := 10.0 * UNEST
    end if
  end for

  ! read super block parameters
  nxsup := i32(supout[0])
  nysup := i32(supout[1])
  nzsup := i32(supout[2])
  xmnsup := supout[3]
  ymnsup := supout[4]
  zmnsup := supout[5]
  xsizsup := supout[6]
  ysizsup := supout[7]
  zsizsup := supout[8]

  ! ── 5. main simulation loop ──
  for in_ := 0, nxyz
    index := i32(order[in_] + 0.5)

    ! skip if already simulated or conditioned
    if (sim[index] <= UNEST + 0.5 and sim[index] >= 2.0 * UNEST) then

    ! grid coordinates
    iz_g := index / nxy
    iy_g := (index - iz_g * nxy) / nx
    ix_g := index - iz_g * nxy - iy_g * nx
    xx_g := xmn + f64(ix_g) * xsiz
    yy_g := ymn + f64(iy_g) * ysiz
    zz_g := zmn + f64(iz_g) * zsiz

    ! search nearby conditioning data
    call gslib.srchsupr(xx_g, yy_g, zz_g, radsqd, isrot, rotmat,
      nsbtosr, ixsbtosr, iysbtosr, izsbtosr, noct,
      nd, x, y, z, actloc, close, nisb,
      nxsup, xmnsup, xsizsup,
      nysup, ymnsup, ysizsup,
      nzsup, zmnsup, zsizsup,
      covres, getidxres, inoct, lt, ut)
    nclose := i32(covres[0])

    ! search simulated nodes
    call gslib.srchnd(ix_g, iy_g, iz_g, sim,
      nx, ny, nz, xmn, ymn, zmn, xsiz, ysiz, zsiz,
      nlooku, ixnode, iynode, iznode,
      nctx, ncty, nctz,
      nodmax, noct,
      icnode, cnodex, cnodey, cnodez, cnodev,
      inoct, covres)
    ncnode := i32(covres[0])

    ! transform simulated node values to indicators for each cutoff
    ! (stored in cnodev — we'll handle per-cutoff inside krige_i)

    ! random CDF value for drawing
    cdfval := gslib.acorni(ixv)
    if (cdfval <= 0.0) then cdfval := 0.00001 end if
    if (cdfval >= 1.0) then cdfval := 0.99999 end if

    if (nclose + ncnode == 0) then
      ! no data at all — draw from global CDF
      call gslib.beyond(ivtype, ncut, thresh, gcdf,
        zmin, zmax, ltail, ltpar, utail, utpar,
        cdfval, beyond_result)
      sim[index] := beyond_result[0]
    else
      ! krige each cutoff
      for ic := 0, ncut
        ! convert simulated node values to indicators for this cutoff
        for id := 0, ncnode
          if (ivtype == 0 and cnodev[id] == thresh[ic]) then
            cnodev[id] := 1.0
          else if (ivtype == 0) then
            cnodev[id] := 0.0
          else if (cnodev[id] <= thresh[ic]) then
            cnodev[id] := 1.0
          else
            cnodev[id] := 0.0
          end if
        end for

        call gslib.krige_i(
          ix_g, iy_g, iz_g, xx_g, yy_g, zz_g,
          ic, ncut, MAXNST,
          nclose, close,
          nd, x, y, z, vr,
          ncnode, icnode,
          cnodex, cnodey, cnodez, cnodev,
          nctx, ncty, nctz,
          nlooku, covtab,
          ixnode, iynode, iznode,
          nst_arr, c0_arr,
          it_arr, cc_arr, aa_arr,
          irot, rotmat,
          cbb_arr[ic],
          nx, ny, nz,
          ktype, gcdf[ic],
          a, r, rr, s_,
          vra,
          covres,
          beyond_result)
        ccdf_scratch[ic] := beyond_result[0]

        ! restore original simulated node values for next cutoff
        call gslib.srchnd(ix_g, iy_g, iz_g, sim,
          nx, ny, nz, xmn, ymn, zmn, xsiz, ysiz, zsiz,
          nlooku, ixnode, iynode, iznode,
          nctx, ncty, nctz,
          nodmax, noct,
          icnode, cnodex, cnodey, cnodez, cnodev,
          inoct, covres)
      end for

      ! correct order relations
      call gslib.ordrel(ivtype, ncut, ccdf_scratch, ccdfo_scratch)

      ! draw from corrected CDF
      call gslib.beyond(ivtype, ncut, thresh, ccdfo_scratch,
        zmin, zmax, ltail, ltpar, utail, utpar,
        cdfval, beyond_result)
      sim[index] := beyond_result[0]
    end if
    end if
  end for

  ! ── 6. reassign conditioning data ──
  for id := 0, nd
    call gslib.getindx(nx, xmn, xsiz, x[id], getidxres)
    ix_g := getidxres[0]
    call gslib.getindx(ny, ymn, ysiz, y[id], getidxres)
    iy_g := getidxres[0]
    call gslib.getindx(nz, zmn, zsiz, z[id], getidxres)
    iz_g := getidxres[0]
    xx_g := xmn + f64(ix_g) * xsiz
    yy_g := ymn + f64(iy_g) * ysiz
    zz_g := zmn + f64(iz_g) * zsiz
    ind := ix_g + iy_g * nx + iz_g * nxy
    test := abs(xx_g - x[id]) + abs(yy_g - y[id]) + abs(zz_g - z[id])
    if (test <= TINY) then
      ! re-stamp conditioning data value (original scale from caller)
      ! The data index is id, and the original value was passed by
      ! the caller as thresh[0] indicator... The caller should provide
      ! original-scale values for re-stamping. We use a convention:
      ! actloc stores the original index, so the caller can recover it.
      sim[ind] := actloc[ind]
    end if
  end for
end

! ── cokb3d — collocated cokriging ────────────────────────────────────
!
! 3D cokriging with primary + one secondary variable.
! three variogram models: primary-primary (auto), secondary-secondary
! (auto), primary-secondary (cross). the cross-covariance model index
! layout mirrors Fortran's iva(i)+(iva(j)-1)*nvr convention:
!   index 0 = pp (primary-primary)
!   index 1 = ps (primary-secondary)
!   index 2 = sp (same as ps, symmetric)
!   index 3 = ss (secondary-secondary)
!
! for cova3 call with index ind:
!   nst[ind], c0[ind], it[ind*MAXNST..], cc[ind*MAXNST..], aa[ind*MAXNST..]
!   rotation: irot = ind * MAXNST
!
! uses ktsol (full matrix, partial pivoting) for the kriging system.
!
! nd1, x1, y1, z1, vr1: primary data
! nd2, x2, y2, z2, vr2: secondary data
! ndmaxp, ndmaxs: max primary/secondary neighbors
!
! variogram arrays use 4 model slots (pp=0, ps=1, sp=2, ss=3):
!   nst_arr[4], c0_arr[4]
!   it_arr[4*MAXNST], cc_arr[4*MAXNST], aa_arr[4*MAXNST]
!
! the caller sets up rotation matrices for all 4 model slots.
!
! Fortran ref: cokb3d.for

subroutine gslib.cokb3d(
  nx, ny, nz: i32; xmn, ymn, zmn, xsiz, ysiz, zsiz: f64;
  nxdis, nydis, nzdis: i32;
  nd: i32; x, y, z, vr1, vr2: array f64;
  tmin, tmax: f64;
  ndmin, ndmaxp, ndmaxs: i32;
  ktype: i32; skmean1, skmean2: f64;
  MAXNST: i32;
  nst_arr: array i32; c0_arr: array f64;
  it_arr: array i32; cc_arr, aa_arr: array f64;
  isrot: i32; rotmat: array f64;
  radius: f64;
  nsbtosr: i32; ixsbtosr, iysbtosr, izsbtosr, nisb: array i32;
  supout: array f64;
  est, estv: array f64;
  xa, ya, za, vra: array f64;
  iva: array i32;
  r, rr, s_: array f64;
  a: array f64;
  close: array f64;
  xdb, ydb, zdb: array f64;
  covres: array f64;
  inoct, getidxres: array i32;
  actloc: array f64;
  lt, ut: array i32)
var
  index, ix, iy, iz, nxy, nxyz, ndb: i32
  np_, ns_, na, neq, ind, i, j, j1: i32
  xloc, yloc, zloc, radsqd: f64
  xdis, ydis, zdis, xl, yl, zl: f64
  xx, yy, zz, dx_, dy_, dz_: f64
  cov, cmax, cbb, cb, unbias, sumw, ook, ookv: f64
  nclose, ising: i32
  ivar_i, ivar_j, vind: i32
  nxsup, nysup, nzsup: i32
  xmnsup, ymnsup, zmnsup, xsizsup, ysizsup, zsizsup: f64
begin
  nxy := nx * ny
  nxyz := nxy * nz
  radsqd := radius * radius

  ! set up block discretization
  ndb := nxdis * nydis * nzdis
  xdis := xsiz / max(f64(nxdis), 1.0)
  ydis := ysiz / max(f64(nydis), 1.0)
  zdis := zsiz / max(f64(nzdis), 1.0)
  ind := 0
  xl := -0.5 * (xsiz + xdis)
  for ix := 0, nxdis
    xl := xl + xdis
    yl := -0.5 * (ysiz + ydis)
    for iy := 0, nydis
      yl := yl + ydis
      zl := -0.5 * (zsiz + zdis)
      for iz := 0, nzdis
        zl := zl + zdis
        xdb[ind] := xl
        ydb[ind] := yl
        zdb[ind] := zl
        ind := ind + 1
      end for
    end for
  end for

  ! block covariance (primary-primary, index 0)
  call gslib.cova3(0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
    nst_arr[0], c0_arr[0], it_arr, cc_arr, aa_arr,
    0, rotmat, covres)
  cmax := covres[0]
  unbias := 1.0

  if (ndb <= 1) then
    cbb := cmax
  else
    cbb := 0.0
    for i := 0, ndb
      for j := 0, ndb
        call gslib.cova3(xdb[i], ydb[i], zdb[i],
          xdb[j], ydb[j], zdb[j],
          nst_arr[0], c0_arr[0], it_arr, cc_arr, aa_arr,
          0, rotmat, covres)
        cov := covres[1]
        if (i == j) then
          cov := covres[0] - c0_arr[0]
        end if
        cbb := cbb + cov
      end for
    end for
    cbb := cbb / f64(ndb * ndb)
  end if

  ! read super block parameters
  nxsup := i32(supout[0])
  nysup := i32(supout[1])
  nzsup := i32(supout[2])
  xmnsup := supout[3]
  ymnsup := supout[4]
  zmnsup := supout[5]
  xsizsup := supout[6]
  ysizsup := supout[7]
  zsizsup := supout[8]

  ! main loop over grid nodes
  for index := 0, nxyz
    iz := index / nxy
    iy := (index - iz * nxy) / nx
    ix := index - iz * nxy - iy * nx
    xloc := xmn + f64(ix) * xsiz
    yloc := ymn + f64(iy) * ysiz
    zloc := zmn + f64(iz) * zsiz

    ! find nearest samples
    call gslib.srchsupr(xloc, yloc, zloc, radsqd, isrot, rotmat,
      nsbtosr, ixsbtosr, iysbtosr, izsbtosr, 0,
      nd, x, y, z, actloc, close, nisb,
      nxsup, xmnsup, xsizsup,
      nysup, ymnsup, ysizsup,
      nzsup, zmnsup, zsizsup,
      covres, getidxres, inoct, lt, ut)
    nclose := i32(covres[0])

    ! load primary and secondary data
    np_ := 0
    ns_ := 0
    na := 0
    for i := 0, nclose
      if (np_ >= ndmaxp and ns_ >= ndmaxs) then
        break
      end if
      ind := i32(close[i] + 0.5)

      ! primary data
      if (vr1[ind] >= tmin and vr1[ind] < tmax and np_ < ndmaxp) then
        xa[na] := x[ind]
        ya[na] := y[ind]
        za[na] := z[ind]
        vra[na] := vr1[ind]
        iva[na] := 0
        np_ := np_ + 1
        na := na + 1
      end if

      ! secondary data
      if (vr2[ind] >= tmin and vr2[ind] < tmax and ns_ < ndmaxs) then
        xa[na] := x[ind]
        ya[na] := y[ind]
        za[na] := z[ind]
        vra[na] := vr2[ind]
        ! mean-adjust for SK
        if (ktype /= 2) then
          vra[na] := vra[na] - skmean2 + skmean1
        end if
        iva[na] := 1
        ns_ := ns_ + 1
        na := na + 1
      end if
    end for

    ! determine system size
    if (ktype == 0) then
      neq := na
    else
      neq := na + 1
    end if

    if (na < ndmin or neq <= 0) then
      est[index] := -999.0
      estv[index] := -999.0
    else
      ! zero kriging matrix (full neq x neq)
      for i := 0, neq * neq
        a[i] := 0.0
      end for

      ! build LHS matrix
      for j := 0, na
        for i := 0, j + 1
          ! cross-variogram index: iva(i) + iva(j) * 2
          ! pp=0+0*2=0, ps=0+1*2=2, sp=1+0*2=1, ss=1+1*2=3
          ! but we store: 0=pp, 1=ps, 2=sp, 3=ss
          vind := iva[i] + iva[j] * 2
          call gslib.cova3(xa[i], ya[i], za[i], xa[j], ya[j], za[j],
            nst_arr[vind], c0_arr[vind],
            it_arr, cc_arr, aa_arr,
            vind * MAXNST, rotmat, covres)
          a[neq * i + j] := covres[1]
          a[neq * j + i] := covres[1]
        end for

        ! RHS: primary (index 0) x variable_j cross-covariance
        vind := iva[j] * 2
        xx := xa[j] - xloc
        yy := ya[j] - yloc
        zz := za[j] - zloc
        if (ndb <= 1) then
          call gslib.cova3(xx, yy, zz, xdb[0], ydb[0], zdb[0],
            nst_arr[vind], c0_arr[vind],
            it_arr, cc_arr, aa_arr,
            vind * MAXNST, rotmat, covres)
          cb := covres[1]
        else
          cb := 0.0
          for j1 := 0, ndb
            call gslib.cova3(xx, yy, zz, xdb[j1], ydb[j1], zdb[j1],
              nst_arr[vind], c0_arr[vind],
              it_arr, cc_arr, aa_arr,
              vind * MAXNST, rotmat, covres)
            dx_ := xx - xdb[j1]
            dy_ := yy - ydb[j1]
            dz_ := zz - zdb[j1]
            if (dx_ * dx_ + dy_ * dy_ + dz_ * dz_ < 1.0e-20) then
              cb := cb + covres[1] - c0_arr[vind]
            else
              cb := cb + covres[1]
            end if
          end for
          cb := cb / f64(ndb)
        end if
        r[j] := cb
        rr[j] := cb
      end for

      ! OK constraint
      if (ktype == 1) then
        for i := 0, na
          a[neq * i + na] := unbias
          a[neq * na + i] := unbias
        end for
        r[na] := unbias
        rr[na] := unbias
      end if

      ! solve full matrix system via ktsol
      call gslib.ktsol(neq, a, r, s_, covres)
      ising := i32(covres[0])

      if (ising /= 0) then
        est[index] := -999.0
        estv[index] := -999.0
      else
        ! compute estimate and variance
        sumw := 0.0
        ook := 0.0
        ookv := cbb
        for i := 0, na
          ookv := ookv - s_[i] * rr[i]
          sumw := sumw + s_[i]
          ook := ook + s_[i] * vra[i]
        end for
        if (neq > na) then
          ookv := ookv - s_[na] * unbias
        end if

        ! add mean if SK
        ook := ook + (1.0 - sumw) * skmean1

        est[index] := ook
        estv[index] := ookv
      end if
    end if
  end for
end
