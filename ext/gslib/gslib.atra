! ══════════════════════════════════════════════════════════════════════
! GSLIB — geostatistical library for atra
!
! faithful transcription of Stanford's GSLIB (Deutsch & Journel, 1998).
! same algorithms, same variable names, same accumulation order.
! the Fortran is the spec.
!
! all f64 throughout. Fortran f32 truncation points noted with
! "! NOTE: Fortran uses f32 here" for future bit-identity work.
!
! rotation matrix storage:
!   Fortran: rotmat(MAXROT, 3, 3) with rotmat(ind, i, j)
!   atra:    flat f64 array, matrix ind at rotmat[ind*9 + i*3 + j]
!            (0-indexed, row-major per block)
! ══════════════════════════════════════════════════════════════════════

! ── acorni — ACORN random number generator ────────────────────────────
!
! order 12, modulus 2^30 = 1073741824.
! state: ixv[0] = seed, ixv[1..12] = 0 initially.
! each call advances state and returns uniform [0, 1).
!
! Fortran ref: gslib/acorni.for (Wikramaratna, 1990)

function gslib.acorni(ixv: array i32): f64
var i: i32
begin
  for i := 0, 12
    ixv[i + 1] := ixv[i + 1] + ixv[i]
    if (ixv[i + 1] >= 1073741824) then
      ixv[i + 1] := ixv[i + 1] - 1073741824
    end if
  end for
  gslib.acorni := f64(ixv[12]) / 1073741824.0
end

! ── gauinv — inverse standard normal CDF ──────────────────────────────
!
! Kennedy & Gentle (1980) rational approximation.
! xp[0] receives the result, ierr[0] = 1 on error (p out of range).
!
! NOTE: Fortran truncates xp to f32 via real(...) — we skip this.
! Fortran ref: gslib/gauinv.for

subroutine gslib.gauinv(p: f64; xp: array f64; ierr: array i32)
var pp, y: f64
begin
  ! coefficients
  ! p0..p4 and q0..q4 are hardcoded below (Kennedy & Gentle)

  ierr[0] := 1
  if (p < 1.0e-10) then
    xp[0] := -1.0e10
    call return()
  end if
  if (p > 1.0 - 1.0e-10) then
    xp[0] := 1.0e10
    call return()
  end if
  ierr[0] := 0

  pp := p
  if (p > 0.5) then
    pp := 1.0 - pp
  end if
  xp[0] := 0.0
  if (p == 0.5) then
    call return()
  end if

  ! rational approximation
  y := sqrt(ln(1.0 / (pp * pp)))
  ! NOTE: Fortran uses f32 here (xp = real(...))
  xp[0] := y + ((((y * (-0.0000453642210148) + (-0.0204231210245)) * y
    + (-0.342242088547)) * y + (-1.0)) * y + (-0.322232431088))
    / ((((y * 0.0038560700634 + 0.103537752850) * y
    + 0.531103462366) * y + 0.588581570495) * y + 0.0993484626060)
  if (p <= 0.5) then
    xp[0] := 0.0 - xp[0]
  end if
end

! ── gcum — standard normal CDF ────────────────────────────────────────
!
! Abramowitz & Stegun polynomial approximation (~5 decimal places).
! all f64 (NOTE: Fortran is entirely f32).
!
! Fortran ref: gslib/gcum.for

function gslib.gcum(x: f64): f64
var z, t, e2: f64
begin
  z := x
  if (z < 0.0) then
    z := 0.0 - z
  end if
  t := 1.0 / (1.0 + 0.2316419 * z)
  gslib.gcum := t * (0.31938153 + t * (-0.356563782 + t * (1.781477937
    + t * (-1.821255978 + t * 1.330274429))))
  e2 := 0.0

  ! 6 standard deviations out gets treated as infinity
  if (z <= 6.0) then
    e2 := exp(0.0 - z * z / 2.0) * 0.3989422803
  end if
  gslib.gcum := 1.0 - e2 * gslib.gcum
  if (x >= 0.0) then
    call return(gslib.gcum)
  end if
  gslib.gcum := 1.0 - gslib.gcum
end

! ── powint — power interpolation ──────────────────────────────────────
!
! interpolates y between (xlow,ylow) and (xhigh,yhigh) with power pow.
! EPSLON guard for degenerate intervals.
!
! Fortran ref: gslib/powint.for

function gslib.powint(xlow: f64; xhigh: f64; ylow: f64; yhigh: f64;
  xval: f64; pow: f64): f64
begin
  if (xhigh - xlow < 1.0e-20) then
    gslib.powint := (yhigh + ylow) / 2.0
  else
    gslib.powint := ylow + (yhigh - ylow)
      * ((xval - xlow) / (xhigh - xlow)) ** pow
  end if
end

! ── locate — bisection search in sorted array ─────────────────────────
!
! given sorted xx[n], find j such that xx[j] <= x < xx[j+1].
! 0-indexed. returns j = -1 or j = n-1 for out-of-range.
!
! Fortran ref: gslib/locate.for (adapted from Numerical Recipes)

subroutine gslib.locate(xx: array f64; n, is, ie: i32; x: f64;
  j: array i32)
var jl, ju, jm: i32
begin
  jl := is - 1
  ju := ie
  if (xx[n - 1] <= x) then
    j[0] := ie
    call return()
  end if

  ! bisection loop
  while (ju - jl > 1)
    jm := (ju + jl) / 2
    if ((xx[ie - 1] > xx[is - 1]) == (x > xx[jm - 1])) then
      jl := jm
    else
      ju := jm
    end if
  end while

  j[0] := jl
end

! ── getindx — grid cell index from coordinate ─────────────────────────
!
! maps a point location to grid cell index (0-indexed).
! returns index in idx[0] and inflag in idx[1] (1=in grid, 0=out).
!
! Fortran ref: gslib/getindx.for

subroutine gslib.getindx(n: i32; gmin, siz, loc: f64; idx: array i32)
var index: i32
begin
  ! Fortran uses int((loc-min)/siz + 1.5), 1-indexed
  ! 0-indexed: int((loc-min)/siz + 0.5)
  index := i32(floor((loc - gmin) / siz + 0.5))

  if (index < 0) then
    idx[0] := 0
    idx[1] := 0
  else if (index >= n) then
    idx[0] := n - 1
    idx[1] := 0
  else
    idx[0] := index
    idx[1] := 1
  end if
end

! ── setrot — build anisotropic rotation matrix ────────────────────────
!
! GSLIB angle convention: ang1=azimuth (CW from N), ang2=dip, ang3=rake.
! writes 9 f64 values to rotmat[ind*9 .. ind*9+8].
! anisotropy ratios applied to rows 2 and 3.
!
! Fortran ref: gslib/setrot.for

subroutine gslib.setrot(ang1, ang2, ang3, anis1, anis2: f64;
  ind: i32; rotmat: array f64)
var
  alpha, beta, theta: f64
  sina, sinb, sint, cosa, cosb, cost: f64
  afac1, afac2: f64
  base: i32
begin
  ! convert GSLIB angles to mathematical angles
  if (ang1 >= 0.0 and ang1 < 270.0) then
    alpha := (90.0 - ang1) * 3.141592654 / 180.0
  else
    alpha := (450.0 - ang1) * 3.141592654 / 180.0
  end if
  beta := -1.0 * ang2 * 3.141592654 / 180.0
  theta := ang3 * 3.141592654 / 180.0

  ! sines and cosines
  sina := sin(alpha)
  sinb := sin(beta)
  sint := sin(theta)
  cosa := cos(alpha)
  cosb := cos(beta)
  cost := cos(theta)

  ! anisotropy factors
  afac1 := 1.0 / max(anis1, 1.0e-20)
  afac2 := 1.0 / max(anis2, 1.0e-20)

  ! build rotation matrix at rotmat[ind*9 .. ind*9+8]
  base := ind * 9
  rotmat[base + 0] := cosb * cosa
  rotmat[base + 1] := cosb * sina
  rotmat[base + 2] := 0.0 - sinb
  rotmat[base + 3] := afac1 * (0.0 - cost * sina + sint * sinb * cosa)
  rotmat[base + 4] := afac1 * (cost * cosa + sint * sinb * sina)
  rotmat[base + 5] := afac1 * (sint * cosb)
  rotmat[base + 6] := afac2 * (sint * sina + cost * sinb * cosa)
  rotmat[base + 7] := afac2 * (0.0 - sint * cosa + cost * sinb * sina)
  rotmat[base + 8] := afac2 * (cost * cosb)
end

! ── sqdist — squared anisotropic distance ─────────────────────────────
!
! applies rotation matrix, returns sum of squared transformed components.
! reads from rotmat[ind*9..].
!
! Fortran ref: gslib/sqdist.for

function gslib.sqdist(x1, y1, z1, x2, y2, z2: f64;
  ind: i32; rotmat: array f64): f64
var
  dx, dy, dz, cont: f64
  i, base: i32
begin
  dx := x1 - x2
  dy := y1 - y2
  dz := z1 - z2
  base := ind * 9
  gslib.sqdist := 0.0
  for i := 0, 3
    cont := rotmat[base + i * 3 + 0] * dx
      + rotmat[base + i * 3 + 1] * dy
      + rotmat[base + i * 3 + 2] * dz
    gslib.sqdist := gslib.sqdist + cont * cont
  end for
end

! ── sortem — quickersort with companion arrays ────────────────────────
!
! sorts a[ib..ie-1] in ascending order (0-indexed).
! simultaneously permutes companion arrays b and c.
! nperm = 0: sort a only
! nperm = 1: permute b with a
! nperm = 2: permute b and c with a
!
! Quickersort algorithm (Scowen, ACM 271). explicit stack, no recursion.
! stack depth 64 handles up to 2^64 elements.
!
! Fortran ref: gslib/sortem.for, gslib/dsortem.for

subroutine gslib.sortem(ib, ie: i32; a, b, c: array f64; nperm: i32;
  lt, ut: array i32)
var
  i, j, k, m, p, q: i32
  ta, xa, tb, xb, tc, xc: f64
begin
  ! Quickersort (Scowen, ACM 271). 0-indexed: sorts a[ib..ie-1].
  ! lt/ut are scratch arrays of at least 64 i32 each (stack depth).
  j := ie - 1
  m := 1
  i := ib
  lt[0] := i
  ut[0] := j

  while (m > 0)
    m := m - 1
    i := lt[m]
    j := ut[m]

    ! keep splitting until segment is small
    while (j - i > 1)
      ! segment has 3+ elements — partition
      p := (j + i) / 2
      ta := a[p]
      a[p] := a[i]
      if (nperm >= 1) then
        tb := b[p]
        b[p] := b[i]
      end if
      if (nperm >= 2) then
        tc := c[p]
        c[p] := c[i]
      end if

      ! Hoare partition: scan from both ends
      q := j
      k := i + 1

      ! scan forward for a[k] > ta, backward for a[q] < ta, swap
      while (k <= q)
        ! forward scan
        while (k <= q and a[k] <= ta)
          k := k + 1
        end while
        if (k > q) then
          break
        end if
        ! backward scan
        while (q >= k and a[q] >= ta)
          q := q - 1
        end while
        if (q < k) then
          break
        end if
        ! swap a[k] and a[q]
        xa := a[k]
        a[k] := a[q]
        a[q] := xa
        if (nperm >= 1) then
          xb := b[k]
          b[k] := b[q]
          b[q] := xb
        end if
        if (nperm >= 2) then
          xc := c[k]
          c[k] := c[q]
          c[q] := xc
        end if
        k := k + 1
        q := q - 1
      end while

      ! place pivot: q = k - 1 is the partition point
      q := k - 1
      a[i] := a[q]
      a[q] := ta
      if (nperm >= 1) then
        b[i] := b[q]
        b[q] := tb
      end if
      if (nperm >= 2) then
        c[i] := c[q]
        c[q] := tc
      end if

      ! push larger segment, continue with smaller
      if (q - i > j - q) then
        lt[m] := i
        ut[m] := q - 1
        i := q + 1
      else
        lt[m] := q + 1
        ut[m] := j
        j := q - 1
      end if
      m := m + 1
    end while

    ! segment has 0 or 1 or 2 elements
    if (j > i) then
      if (a[i] > a[j]) then
        xa := a[i]
        a[i] := a[j]
        a[j] := xa
        if (nperm >= 1) then
          xb := b[i]
          b[i] := b[j]
          b[j] := xb
        end if
        if (nperm >= 2) then
          xc := c[i]
          c[i] := c[j]
          c[j] := xc
        end if
      end if
    end if
  end while
end

! ── nscore — normal score transform ───────────────────────────────────
!
! transforms nd data values to standard normal scores N(0,1).
! uses sortem internally.
!
! a[0..nd-1]     = data values (modified: sorted then restored)
! wt[0..nd-1]    = weights (iwt=1) or unused (iwt=0). modified.
! tmp[0..nd-1]   = scratch (stores original indices)
! vrg[0..nd-1]   = output normal scores
! xp[0]          = scratch for gauinv output
! ierr[0]        = scratch for gauinv error flag
! result[0]      = 0 on success, 1 on error
!
! Fortran ref: gslib/nscore.for

subroutine gslib.nscore(nd: i32; a, wt, tmp, vrg, xp: array f64;
  ierr, result, lt, ut: array i32; tmin, tmax: f64; iwt: i32)
var
  i: i32
  twt, oldcp, cp: f64
begin
  result[0] := 0
  twt := 0.0

  ! store original indices and compute total weight
  for i := 0, nd
    tmp[i] := f64(i)
    if (a[i] >= tmin and a[i] < tmax) then
      if (iwt == 0) then
        twt := twt + 1.0
      else
        twt := twt + wt[i]
      end if
    end if
  end for

  if (nd < 1 or twt < 1.0e-20) then
    result[0] := 1
    call return()
  end if

  ! sort data ascending, permuting wt and tmp
  call gslib.sortem(0, nd, a, wt, tmp, 2, lt, ut)

  ! compute cumulative probabilities and normal scores
  oldcp := 0.0
  cp := 0.0
  for i := 0, nd
    if (iwt == 0) then
      cp := cp + 1.0 / twt
    else
      cp := cp + wt[i] / twt
    end if
    wt[i] := (cp + oldcp) / 2.0
    oldcp := cp
    call gslib.gauinv(wt[i], xp, ierr)
    vrg[i] := xp[0]
  end for

  ! restore original order: sort by tmp (original indices), carrying a and vrg.
  ! Fortran uses iperm=3 (tmp, wt, vr, vrg) but we only need a and vrg back.
  ! wt is consumed — not needed after this point.
  call gslib.sortem(0, nd, tmp, a, vrg, 2, lt, ut)
end

! ── backtr — back-transform from normal scores ────────────────────────
!
! back-transforms a standard normal deviate using a transform table
! (vr, vrg) and tail options.
!
! vrgs           = normal score to back-transform
! nt             = number of entries in transform table
! vr[0..nt-1]   = original data values (sorted ascending)
! vrg[0..nt-1]  = corresponding normal scores (sorted ascending)
! zmin, zmax     = limits for tail extrapolation
! ltail          = lower tail option (1=linear, 2=power)
! ltpar          = lower tail parameter
! utail          = upper tail option (1=linear, 2=power, 4=hyperbolic)
! utpar          = upper tail parameter
! j[0]           = scratch for locate output
!
! Fortran ref: gslib/backtr.for

function gslib.backtr(vrgs: f64; nt: i32; vr, vrg: array f64;
  zmin, zmax: f64; ltail: i32; ltpar: f64;
  utail: i32; utpar: f64; j: array i32): f64
var
  cdflo, cdfhi, cdfbt, cpow, lambda: f64
  jj: i32
begin
  ! value in the lower tail?
  if (vrgs <= vrg[0]) then
    gslib.backtr := vr[0]
    cdflo := gslib.gcum(vrg[0])
    cdfbt := gslib.gcum(vrgs)
    if (ltail == 1) then
      gslib.backtr := gslib.powint(0.0, cdflo, zmin, vr[0], cdfbt, 1.0)
    else if (ltail == 2) then
      cpow := 1.0 / ltpar
      gslib.backtr := gslib.powint(0.0, cdflo, zmin, vr[0], cdfbt, cpow)
    end if

  ! value in the upper tail?
  else if (vrgs >= vrg[nt - 1]) then
    gslib.backtr := vr[nt - 1]
    cdfhi := gslib.gcum(vrg[nt - 1])
    cdfbt := gslib.gcum(vrgs)
    if (utail == 1) then
      gslib.backtr := gslib.powint(cdfhi, 1.0, vr[nt - 1], zmax, cdfbt, 1.0)
    else if (utail == 2) then
      cpow := 1.0 / utpar
      gslib.backtr := gslib.powint(cdfhi, 1.0, vr[nt - 1], zmax, cdfbt, cpow)
    else if (utail == 4) then
      lambda := (vr[nt - 1] ** utpar) * (1.0 - gslib.gcum(vrg[nt - 1]))
      gslib.backtr := (lambda / (1.0 - gslib.gcum(vrgs))) ** (1.0 / utpar)
    end if

  ! value within the transformation table
  else
    call gslib.locate(vrg, nt, 1, nt, vrgs, j)
    jj := j[0]
    if (jj < 1) then
      jj := 1
    end if
    if (jj > nt - 1) then
      jj := nt - 1
    end if
    ! locate returns 1-indexed j; vrg/vr are 0-indexed
    gslib.backtr := gslib.powint(vrg[jj - 1], vrg[jj], vr[jj - 1], vr[jj],
      vrgs, 1.0)
  end if
end

! ── cova3 — nested covariance model evaluation ────────────────────────
!
! 5 model types: 1=spherical, 2=exponential, 3=Gaussian,
!                4=power, 5=hole effect.
!
! simplified interface (single variogram):
!   nst     = number of nested structures
!   c0      = nugget effect
!   it[is]  = model type for structure is (0-indexed)
!   cc[is]  = sill increment for structure is
!   aa[is]  = range/parameter for structure is
!   irot    = base rotation matrix index
!
! result[0] = cmax, result[1] = cova.
!
! Fortran ref: gslib/cova3.for

subroutine gslib.cova3(x1, y1, z1, x2, y2, z2: f64;
  nst: i32; c0: f64;
  it: array i32; cc, aa: array f64;
  irot: i32; rotmat: array f64;
  result: array f64)
var
  is, ir: i32
  cmax, cova, hsqd, h, hr: f64
begin
  ! calculate maximum covariance
  cmax := c0
  for is := 0, nst
    if (it[is] == 4) then
      cmax := cmax + 999.0
    else
      cmax := cmax + cc[is]
    end if
  end for

  ! check for zero distance
  hsqd := gslib.sqdist(x1, y1, z1, x2, y2, z2, irot, rotmat)
  if (hsqd < 1.0e-5) then
    result[0] := cmax
    result[1] := cmax
    call return()
  end if

  ! loop over nested structures
  cova := 0.0
  for is := 0, nst
    ! compute distance for this structure
    if (is /= 0) then
      ir := irot + is
      hsqd := gslib.sqdist(x1, y1, z1, x2, y2, z2, ir, rotmat)
    end if
    h := sqrt(hsqd)

    ! spherical model
    if (it[is] == 1) then
      hr := h / aa[is]
      if (hr < 1.0) then
        cova := cova + cc[is] * (1.0 - hr * (1.5 - 0.5 * hr * hr))
      end if

    ! exponential model
    else if (it[is] == 2) then
      cova := cova + cc[is] * exp(-3.0 * h / aa[is])

    ! Gaussian model
    else if (it[is] == 3) then
      cova := cova + cc[is] * exp(-3.0 * (h / aa[is]) * (h / aa[is]))

    ! power model
    else if (it[is] == 4) then
      cova := cova + cmax - cc[is] * h ** aa[is]

    ! hole effect model
    else if (it[is] == 5) then
      cova := cova + cc[is] * cos(h / aa[is] * 3.14159265)
    end if
  end for

  result[0] := cmax
  result[1] := cova
end

! ── setsupr — establish super block search limits and sort data ──────
!
! builds a 3D "super block" network and orders data by super block index.
! super block grid spans the kriging/simulation grid.
! data outside the grid are clamped to the nearest edge block.
!
! nd         = number of data points
! x, y, z   = data coordinates (reordered by super block)
! vr         = data values (reordered with coordinates)
! tmp        = scratch array (stores super block index per datum)
! nisb       = cumulative data count per super block (i32 array)
! idx        = scratch i32[2] for getindx
! ixarr      = scratch i32[nd] for index permutation
! lt, ut     = scratch i32[64] each for sortem
!
! outputs:
!   out[0..5] = nxsup, nysup, nzsup, xmnsup, ymnsup, zmnsup
!   out[6..8] = xsizsup, ysizsup, zsizsup  (stored as f64)
!   data arrays x, y, z, vr are reordered by super block.
!   nisb[i] = cumulative number of data up to super block i.
!
! NOTE: Fortran's sortem handles nsort=4+ companions. We use an index-
! based permutation: sort super block index with original indices,
! then permute x, y, z, vr via a copy pass.
!
! Fortran ref: gslib/setsupr.for

subroutine gslib.setsupr(nx: i32; xmn, xsiz: f64; ny: i32; ymn, ysiz: f64;
  nz: i32; zmn, zsiz: f64;
  nd: i32; x, y, z, vr, tmp: array f64;
  nisb, idx, ixarr, lt, ut: array i32;
  maxsbx, maxsby, maxsbz: i32;
  out: array f64)
var
  nxsup, nysup, nzsup: i32
  xsizsup, ysizsup, zsizsup, xmnsup, ymnsup, zmnsup: f64
  i, ii, ix, iy, iz: i32
  nstot: i32
  oi, src: i32
begin
  ! establish number and size of super blocks
  ! NOTE: atra's min/max emit f64.min/f64.max — not valid for i32.
  ! use conditionals instead.
  nxsup := select(nx, maxsbx, nx < maxsbx)
  nysup := select(ny, maxsby, ny < maxsby)
  nzsup := select(nz, maxsbz, nz < maxsbz)
  xsizsup := f64(nx) * xsiz / f64(nxsup)
  ysizsup := f64(ny) * ysiz / f64(nysup)
  zsizsup := f64(nz) * zsiz / f64(nzsup)
  xmnsup := (xmn - 0.5 * xsiz) + 0.5 * xsizsup
  ymnsup := (ymn - 0.5 * ysiz) + 0.5 * ysizsup
  zmnsup := (zmn - 0.5 * zsiz) + 0.5 * zsizsup

  ! initialize super block counts to zero
  nstot := nxsup * nysup * nzsup
  for i := 0, nstot
    nisb[i] := 0
  end for

  ! assign each datum to a super block and count
  for i := 0, nd
    call gslib.getindx(nxsup, xmnsup, xsizsup, x[i], idx)
    ix := idx[0]
    call gslib.getindx(nysup, ymnsup, ysizsup, y[i], idx)
    iy := idx[0]
    call gslib.getindx(nzsup, zmnsup, zsizsup, z[i], idx)
    iz := idx[0]
    ! 0-indexed super block linear index
    ii := ix + iy * nxsup + iz * nxsup * nysup
    tmp[i] := f64(ii)
    nisb[ii] := nisb[ii] + 1
  end for

  ! Build source permutation: ixarr[j] = which original element goes to position j.
  ! Uses counting sort (O(n)) instead of Fortran's sortem with 4+ companions.

  ! Exclusive prefix sum: nisb[i] = start position for block i
  ii := 0
  for i := 0, nstot
    ix := nisb[i]
    nisb[i] := ii
    ii := ii + ix
  end for

  ! Compute source permutation
  for i := 0, nd
    ii := i32(tmp[i])
    ixarr[nisb[ii]] := i
    nisb[ii] := nisb[ii] + 1
  end for

  ! Now nisb[i] = cumulative count up to and including block i (what Fortran returns)

  ! Apply source permutation via cycle-following.
  ! ixarr[j] = source index for position j.
  ! Mark visited by setting ixarr[j] = -1 after processing.
  for i := 0, nd
    if (ixarr[i] /= i and ixarr[i] >= 0) then
      ! start of a cycle: save element at position i
      out[9] := x[i]
      out[10] := y[i]
      out[11] := z[i]
      out[12] := vr[i]

      oi := i
      src := ixarr[i]
      while (src /= i)
        x[oi] := x[src]
        y[oi] := y[src]
        z[oi] := z[src]
        vr[oi] := vr[src]
        ixarr[oi] := -1
        oi := src
        src := ixarr[oi]
      end while

      ! close cycle: place saved element at the last position
      x[oi] := out[9]
      y[oi] := out[10]
      z[oi] := out[11]
      vr[oi] := out[12]
      ixarr[oi] := -1
    end if
  end for

  ! store output grid parameters
  out[0] := f64(nxsup)
  out[1] := f64(nysup)
  out[2] := f64(nzsup)
  out[3] := xmnsup
  out[4] := ymnsup
  out[5] := zmnsup
  out[6] := xsizsup
  out[7] := ysizsup
  out[8] := zsizsup
end

! ── picksup — determine which super blocks to search ─────────────────
!
! given a search radius and rotation matrix, determines which super
! blocks could contain data within the search ellipsoid.
!
! tests all super block offset combinations (i,j,k), checks if the
! closest corner-to-corner distance is within the search radius.
!
! outputs:
!   nsbtosr[0]          = number of super blocks to search
!   ixsbtosr, iysbtosr, izsbtosr = offset arrays
!
! Fortran ref: gslib/picksupr.for (picksup)

subroutine gslib.picksup(nxsup: i32; xsizsup: f64;
  nysup: i32; ysizsup: f64;
  nzsup: i32; zsizsup: f64;
  irot: i32; rotmat: array f64; radsqd: f64;
  nsbtosr: array i32;
  ixsbtosr, iysbtosr, izsbtosr: array i32)
var
  i, j, k, i1, j1, k1, i2, j2, k2: i32
  xo, yo, zo, xdis, ydis, zdis: f64
  shortest, hsqd: f64
  ns: i32
begin
  ns := 0

  for i := -(nxsup - 1), nxsup
    for j := -(nysup - 1), nysup
      for k := -(nzsup - 1), nzsup
        xo := f64(i) * xsizsup
        yo := f64(j) * ysizsup
        zo := f64(k) * zsizsup

        ! find closest distance between corners of the two super blocks
        shortest := 1.0e21
        for i1 := -1, 2
          for j1 := -1, 2
            for k1 := -1, 2
              for i2 := -1, 2
                for j2 := -1, 2
                  for k2 := -1, 2
                    if (i1 /= 0 and j1 /= 0 and k1 /= 0
                        and i2 /= 0 and j2 /= 0 and k2 /= 0) then
                      xdis := f64(i1 - i2) * 0.5 * xsizsup + xo
                      ydis := f64(j1 - j2) * 0.5 * ysizsup + yo
                      zdis := f64(k1 - k2) * 0.5 * zsizsup + zo
                      hsqd := gslib.sqdist(0.0, 0.0, 0.0,
                        xdis, ydis, zdis, irot, rotmat)
                      if (hsqd < shortest) then
                        shortest := hsqd
                      end if
                    end if
                  end for
                end for
              end for
            end for
          end for
        end for

        ! keep this super block if close enough
        if (shortest <= radsqd) then
          ixsbtosr[ns] := i
          iysbtosr[ns] := j
          izsbtosr[ns] := k
          ns := ns + 1
        end if
      end for
    end for
  end for

  nsbtosr[0] := ns
end

! ── srchsupr — search within super blocks for nearby data ────────────
!
! searches data sorted by setsupr for points within the search radius.
! returns indices of close data sorted by distance.
! optional octant search (noct > 0) limits data per octant.
!
! close[0..nclose-1]   = indices (f64) of nearby data, sorted by distance
! tmp[0..nclose-1]     = squared distances (reused from setsupr's tmp)
! result[0]            = nclose
! result[1]            = infoct (number of informed octants)
! idx                  = scratch i32[2] for getindx
! inoct                = scratch i32[8] for octant counts
! lt, ut               = scratch i32[64] each for sortem
!
! Fortran ref: gslib/srchsupr.for

subroutine gslib.srchsupr(xloc, yloc, zloc, radsqd: f64;
  irot: i32; rotmat: array f64;
  nsbtosr: i32; ixsbtosr, iysbtosr, izsbtosr: array i32;
  noct, nd: i32;
  x, y, z, tmp, close: array f64;
  nisb: array i32;
  nxsup: i32; xmnsup, xsizsup: f64;
  nysup: i32; ymnsup, ysizsup: f64;
  nzsup: i32; zmnsup, zsizsup: f64;
  result: array f64;
  idx, inoct, lt, ut: array i32)
var
  ix, iy, iz: i32
  isup, ixsup, iysup, izsup: i32
  ii, nums, nc, i, j: i32
  hsqd: f64
  na, nt, iq: i32
  dx, dy, dz, h: f64
  ci: i32
begin
  ! determine super block of estimation point
  call gslib.getindx(nxsup, xmnsup, xsizsup, xloc, idx)
  ix := idx[0]
  call gslib.getindx(nysup, ymnsup, ysizsup, yloc, idx)
  iy := idx[0]
  call gslib.getindx(nzsup, zmnsup, zsizsup, zloc, idx)
  iz := idx[0]

  nc := 0

  ! loop over super blocks to search
  for isup := 0, nsbtosr
    ixsup := ix + ixsbtosr[isup]
    iysup := iy + iysbtosr[isup]
    izsup := iz + izsbtosr[isup]

    ! skip if outside grid (0-indexed: valid range [0, n-1])
    if (ixsup < 0 or ixsup >= nxsup
        or iysup < 0 or iysup >= nysup
        or izsup < 0 or izsup >= nzsup) then
      ! continue to next isup (use else-if to skip rest)
    else
      ! linear index of super block (0-indexed)
      ii := ixsup + iysup * nxsup + izsup * nxsup * nysup

      ! figure out data range in this super block
      if (ii == 0) then
        nums := nisb[0]
        i := 0
      else
        nums := nisb[ii] - nisb[ii - 1]
        i := nisb[ii - 1]
      end if

      ! check each datum in this super block
      for j := 0, nums
        hsqd := gslib.sqdist(xloc, yloc, zloc,
          x[i], y[i], z[i], irot, rotmat)
        if (hsqd <= radsqd) then
          close[nc] := f64(i)
          tmp[nc] := hsqd
          nc := nc + 1
        end if
        i := i + 1
      end for
    end if
  end for

  ! sort nearby samples by distance
  if (nc > 1) then
    call gslib.sortem(0, nc, tmp, close, close, 1, lt, ut)
  end if

  ! if not doing octant search, return
  if (noct <= 0) then
    result[0] := f64(nc)
    result[1] := 0.0
    call return()
  end if

  ! octant search: partition data into octants
  for i := 0, 8
    inoct[i] := 0
  end for

  nt := 8 * noct
  na := 0
  for j := 0, nc
    ci := i32(close[j])
    h := tmp[j]
    dx := x[ci] - xloc
    dy := y[ci] - yloc
    dz := z[ci] - zloc

    ! determine octant (0-indexed: 0-7)
    if (dz >= 0.0) then
      iq := 3
      if (dx <= 0.0 and dy > 0.0) then
        iq := 0
      end if
      if (dx > 0.0 and dy >= 0.0) then
        iq := 1
      end if
      if (dx < 0.0 and dy <= 0.0) then
        iq := 2
      end if
    else
      iq := 7
      if (dx <= 0.0 and dy > 0.0) then
        iq := 4
      end if
      if (dx > 0.0 and dy >= 0.0) then
        iq := 5
      end if
      if (dx < 0.0 and dy <= 0.0) then
        iq := 6
      end if
    end if

    inoct[iq] := inoct[iq] + 1

    ! keep if octant not yet full
    if (inoct[iq] <= noct) then
      close[na] := f64(ci)
      tmp[na] := h
      na := na + 1
      if (na == nt) then
        break
      end if
    end if
  end for

  nc := na
  result[1] := 0.0
  for i := 0, 8
    if (inoct[i] > 0) then
      result[1] := result[1] + 1.0
    end if
  end for
  result[0] := f64(nc)
end
