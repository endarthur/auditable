! ══════════════════════════════════════════════════════════════════════
! ALAS / ALPACK — dense linear algebra for atra
!
! ALAS  (Auditable Linear Algebra Subprograms) — vector/matrix primitives
! ALPACK (Auditable Linear Algebra PACKage)    — factorizations & solvers
!
! all matrices are row-major, flat in linear memory.
! 2D access: a[i, n, j] where n = number of columns (stride).
! caller provides all buffers. info[0] = 0 on success.
! ══════════════════════════════════════════════════════════════════════

! ── ALAS Level 1: vector-vector ─────────────────────────────────────

! x := alpha * x
subroutine alas.dscal(x: array f64; n: i32; alpha: f64)
var i: i32
begin
  for i := 0, n
    x[i] := alpha * x[i]
  end for
end

! y := x  (copy x into y)
subroutine alas.dcopy(x: array f64; y: array f64; n: i32)
var i: i32
begin
  for i := 0, n
    y[i] := x[i]
  end for
end

! y := alpha * x + y
subroutine alas.daxpy(x: array f64; y: array f64; n: i32; alpha: f64)
var
  i, n2: i32
  va, vx, vy: f64x2
begin
  ! scalar version (for reference):
  !   for i := 0, n
  !     y[i] := alpha * x[i] + y[i]
  !   end for
  va := f64x2.splat(alpha)
  n2 := n / 2
  for i := 0, n2
    vx := v128.load(x, i)
    vy := v128.load(y, i)
    vy := va * vx + vy
    call v128.store(y, i, vy)
  end for
  ! scalar tail for odd element
  if (n2 * 2 < n) then
    i := n2 * 2
    y[i] := alpha * x[i] + y[i]
  end if
end

! returns x^T y  (dot product)
function alas.ddot(x: array f64; y: array f64; n: i32): f64
var
  i, n2: i32
  vx, vy, vs: f64x2
begin
  ! scalar version:
  !   alas.ddot := 0.0
  !   for i := 0, n
  !     alas.ddot := alas.ddot + x[i] * y[i]
  !   end for
  vs := f64x2.splat(0.0)
  n2 := n / 2
  for i := 0, n2
    vx := v128.load(x, i)
    vy := v128.load(y, i)
    vs := vs + vx * vy
  end for
  alas.ddot := f64x2.extract_lane(vs, 0) + f64x2.extract_lane(vs, 1)
  ! scalar tail
  if (n2 * 2 < n) then
    i := n2 * 2
    alas.ddot := alas.ddot + x[i] * y[i]
  end if
end

! returns ||x||_2  (Euclidean norm)
function alas.dnrm2(x: array f64; n: i32): f64
var
  i, n2: i32
  vx, vs: f64x2
begin
  vs := f64x2.splat(0.0)
  n2 := n / 2
  for i := 0, n2
    vx := v128.load(x, i)
    vs := vs + vx * vx
  end for
  alas.dnrm2 := f64x2.extract_lane(vs, 0) + f64x2.extract_lane(vs, 1)
  if (n2 * 2 < n) then
    i := n2 * 2
    alas.dnrm2 := alas.dnrm2 + x[i] * x[i]
  end if
  alas.dnrm2 := sqrt(alas.dnrm2)
end

! swap x and y
subroutine alas.dswap(x: array f64; y: array f64; n: i32)
var i: i32; t: f64
begin
  for i := 0, n
    t := x[i]
    x[i] := y[i]
    y[i] := t
  end for
end

! returns index of element with max absolute value
function alas.idamax(x: array f64; n: i32): i32
var i: i32; mx: f64; v: f64
begin
  alas.idamax := 0
  mx := abs(x[0])
  for i := 1, n
    v := abs(x[i])
    if (v > mx) then
      mx := v
      alas.idamax := i
    end if
  end for
end

! ── ALAS Level 2: matrix-vector ─────────────────────────────────────

! y := alpha * A * x + beta * y   (general matrix-vector multiply)
! A is m x n, x has n elements, y has m elements
subroutine alas.dgemv(
  a: array f64; x: array f64; y: array f64;
  m, n: i32; alpha, beta: f64
)
var i, j: i32; s: f64
begin
  for i := 0, m
    s := 0.0
    for j := 0, n
      s := s + a[i, n, j] * x[j]
    end for
    y[i] := alpha * s + beta * y[i]
  end for
end

! solve L*x = b or L^T*x = b  (triangular solve)
! uplo: 0 = lower, 1 = upper
! trans: 0 = no transpose, 1 = transpose
! x is overwritten with the solution (input is b, output is x)
subroutine alas.dtrsv(
  a: array f64; x: array f64;
  n, uplo, trans: i32
)
var i, j: i32; s: f64
begin
  if (uplo == 0 and trans == 0) then
    ! lower, no transpose: forward substitution
    for i := 0, n
      s := x[i]
      for j := 0, i
        s := s - a[i, n, j] * x[j]
      end for
      x[i] := s / a[i, n, i]
    end for
  else if (uplo == 0 and trans == 1) then
    ! lower, transpose (= upper): back substitution
    for i := n - 1, -1, -1
      s := x[i]
      for j := i + 1, n
        s := s - a[j, n, i] * x[j]
      end for
      x[i] := s / a[i, n, i]
    end for
  else if (uplo == 1 and trans == 0) then
    ! upper, no transpose: back substitution
    for i := n - 1, -1, -1
      s := x[i]
      for j := i + 1, n
        s := s - a[i, n, j] * x[j]
      end for
      x[i] := s / a[i, n, i]
    end for
  else
    ! upper, transpose (= lower): forward substitution
    for i := 0, n
      s := x[i]
      for j := 0, i
        s := s - a[j, n, i] * x[j]
      end for
      x[i] := s / a[i, n, i]
    end for
  end if
end

! A := A + alpha * x * y^T  (rank-1 update)
! A is m x n, x has m elements, y has n elements
subroutine alas.dger(
  a: array f64; x: array f64; y: array f64;
  m, n: i32; alpha: f64
)
var i, j: i32; t: f64
begin
  for i := 0, m
    t := alpha * x[i]
    for j := 0, n
      a[i, n, j] := a[i, n, j] + t * y[j]
    end for
  end for
end

! y := alpha * A * x + beta * y  (symmetric matrix-vector multiply)
! A is n x n symmetric, only lower triangle is read
subroutine alas.dsymv(
  a: array f64; x: array f64; y: array f64;
  n: i32; alpha, beta: f64
)
var i, j: i32; s, t: f64
begin
  ! scale y by beta
  for i := 0, n
    y[i] := beta * y[i]
  end for
  ! accumulate: diagonal + off-diagonal (symmetric)
  for i := 0, n
    s := 0.0
    for j := 0, i
      t := alpha * a[i, n, j]
      s := s + t * x[j]
      y[j] := y[j] + t * x[i]
    end for
    y[i] := y[i] + s + alpha * a[i, n, i] * x[i]
  end for
end

! ── ALAS Level 3: matrix-matrix ─────────────────────────────────────

! C := alpha * A * B + beta * C  (general matrix-matrix multiply)
! A is m x k, B is k x n, C is m x n
subroutine alas.dgemm(
  a: array f64; b: array f64; c: array f64;
  m, n, k: i32; alpha, beta: f64
)
var
  i, j, p: i32
  s: f64
begin
  for i := 0, m
    for j := 0, n
      s := 0.0
      for p := 0, k
        s := s + a[i, k, p] * b[p, n, j]
      end for
      c[i, n, j] := alpha * s + beta * c[i, n, j]
    end for
  end for
end

! ══════════════════════════════════════════════════════════════════════
! ALPACK — factorizations, solvers, eigendecomposition
! ══════════════════════════════════════════════════════════════════════

! ── Cholesky factorization ──────────────────────────────────────────

! A = L * L^T  (in-place, lower triangle overwritten with L)
! info[0] = 0 on success, k > 0 if not positive-definite at column k
subroutine alpack.dpotrf(a: array f64; n: i32; info: array i32)
var i, j, k: i32; s: f64
begin
  info[0] := 0
  for j := 0, n
    s := a[j, n, j]
    for k := 0, j
      s := s - a[j, n, k] * a[j, n, k]
    end for
    if (s <= 0.0) then
      info[0] := j + 1
      call return()
    end if
    a[j, n, j] := sqrt(s)
    for i := j + 1, n
      s := a[i, n, j]
      for k := 0, j
        s := s - a[i, n, k] * a[j, n, k]
      end for
      a[i, n, j] := s / a[j, n, j]
    end for
  end for
end

! solve A*X = B given Cholesky factor L from dpotrf
! B is overwritten with X.  B is n x nrhs (each column is an RHS)
subroutine alpack.dpotrs(
  l: array f64; b: array f64;
  n, nrhs: i32
)
var rhs, i, j: i32; s: f64
begin
  for rhs := 0, nrhs
    ! forward substitution: L * y = b
    for i := 0, n
      s := b[i, nrhs, rhs]
      for j := 0, i
        s := s - l[i, n, j] * b[j, nrhs, rhs]
      end for
      b[i, nrhs, rhs] := s / l[i, n, i]
    end for
    ! back substitution: L^T * x = y
    for i := n - 1, -1, -1
      s := b[i, nrhs, rhs]
      for j := i + 1, n
        s := s - l[j, n, i] * b[j, nrhs, rhs]
      end for
      b[i, nrhs, rhs] := s / l[i, n, i]
    end for
  end for
end

! ── LU factorization with partial pivoting ──────────────────────────

! A = P * L * U  (in-place, L below diagonal with unit diagonal, U on+above)
! ipiv is an n-element i32 array of pivot indices
! info[0] = 0 on success, k > 0 if U(k,k) is zero
subroutine alpack.dgetrf(
  a: array f64; n: i32;
  ipiv: array i32; info: array i32
)
var i, j, k, pivot: i32; t, inv: f64
begin
  info[0] := 0
  for k := 0, n
    ! find pivot in column k from row k..n-1
    ! use inline search (idamax operates on contiguous vector)
    pivot := k
    t := abs(a[k, n, k])
    for i := k + 1, n
      if (abs(a[i, n, k]) > t) then
        pivot := i
        t := abs(a[i, n, k])
      end if
    end for
    ipiv[k] := pivot

    ! swap rows k and pivot
    if (pivot /= k) then
      for j := 0, n
        t := a[k, n, j]
        a[k, n, j] := a[pivot, n, j]
        a[pivot, n, j] := t
      end for
    end if

    if (a[k, n, k] == 0.0) then
      info[0] := k + 1
      call return()
    end if

    ! eliminate below diagonal
    inv := 1.0 / a[k, n, k]
    for i := k + 1, n
      a[i, n, k] := a[i, n, k] * inv
      for j := k + 1, n
        a[i, n, j] := a[i, n, j] - a[i, n, k] * a[k, n, j]
      end for
    end for
  end for
end

! solve A*X = B given LU factorization from dgetrf
! B is n x nrhs, overwritten with X
subroutine alpack.dgetrs(
  lu: array f64; ipiv: array i32;
  b: array f64; n, nrhs: i32
)
var rhs, i, j, p: i32; s, t: f64
begin
  for rhs := 0, nrhs
    ! apply row permutation
    for i := 0, n
      p := ipiv[i]
      if (p /= i) then
        t := b[i, nrhs, rhs]
        b[i, nrhs, rhs] := b[p, nrhs, rhs]
        b[p, nrhs, rhs] := t
      end if
    end for
    ! forward substitution (L with unit diagonal)
    for i := 1, n
      s := b[i, nrhs, rhs]
      for j := 0, i
        s := s - lu[i, n, j] * b[j, nrhs, rhs]
      end for
      b[i, nrhs, rhs] := s
    end for
    ! back substitution (U)
    for i := n - 1, -1, -1
      s := b[i, nrhs, rhs]
      for j := i + 1, n
        s := s - lu[i, n, j] * b[j, nrhs, rhs]
      end for
      b[i, nrhs, rhs] := s / lu[i, n, i]
    end for
  end for
end

! solve A*X = B  (convenience: dgetrf + dgetrs)
! A is overwritten with LU, B is overwritten with X
! scratch: i32 array of length n for pivots
subroutine alpack.dgesv(
  a: array f64; b: array f64;
  n, nrhs: i32;
  ipiv: array i32; info: array i32
)
begin
  call alpack.dgetrf(a, n, ipiv, info)
  if (info[0] /= 0) then
    call return()
  end if
  call alpack.dgetrs(a, ipiv, b, n, nrhs)
end

! ── Triangular inverse ──────────────────────────────────────────────

! invert a lower triangular matrix in-place
! info[0] = 0 on success, k > 0 if diagonal element k is zero
subroutine alpack.dtrtri(a: array f64; n: i32; info: array i32)
var i, j, k: i32; s: f64
begin
  info[0] := 0
  for j := 0, n
    if (a[j, n, j] == 0.0) then
      info[0] := j + 1
      call return()
    end if
    a[j, n, j] := 1.0 / a[j, n, j]
    for i := j + 1, n
      s := 0.0
      for k := j, i
        s := s - a[i, n, k] * a[k, n, j]
      end for
      a[i, n, j] := s / a[i, n, i]
    end for
  end for
end

! ── Eigendecomposition: 3x3 analytical ──────────────────────────────

! eigenvalues of a 3x3 symmetric matrix (analytical, Cardano's method)
! a is 3x3 symmetric (9 f64), w receives 3 eigenvalues (sorted descending)
subroutine alpack.dsyev3(a: array f64; w: array f64)
var
  a00, a01, a02, a11, a12, a22: f64
  p1, q, p2, p, b00, b11, b22, det_b, half_det: f64
  phi, r, e1, e2, e3: f64
  m: f64
  pi: f64
begin
  pi := 3.14159265358979323846

  a00 := a[0, 3, 0]
  a01 := a[0, 3, 1]
  a02 := a[0, 3, 2]
  a11 := a[1, 3, 1]
  a12 := a[1, 3, 2]
  a22 := a[2, 3, 2]

  ! trace / 3
  m := (a00 + a11 + a22) / 3.0

  ! sum of squares of off-diagonal elements
  p1 := a01 * a01 + a02 * a02 + a12 * a12

  if (p1 <= 1e-30) then
    ! diagonal matrix — eigenvalues are the diagonal entries, sort descending
    e1 := a00
    e2 := a11
    e3 := a22
    ! sort 3 values descending (bubble sort)
    if (e2 > e1) then
      r := e1
      e1 := e2
      e2 := r
    end if
    if (e3 > e2) then
      r := e2
      e2 := e3
      e3 := r
    end if
    if (e2 > e1) then
      r := e1
      e1 := e2
      e2 := r
    end if
    w[0] := e1
    w[1] := e2
    w[2] := e3
    call return()
  end if

  q := m
  p2 := (a00 - q) * (a00 - q) + (a11 - q) * (a11 - q) + (a22 - q) * (a22 - q) + 2.0 * p1
  p := sqrt(p2 / 6.0)

  ! B = (A - q*I) / p  — only need determinant
  b00 := (a00 - q) / p
  b11 := (a11 - q) / p
  b22 := (a22 - q) / p
  ! det(B) for symmetric 3x3
  det_b := b00 * (b11 * b22 - (a12 / p) * (a12 / p))
         - (a01 / p) * ((a01 / p) * b22 - (a12 / p) * (a02 / p))
         + (a02 / p) * ((a01 / p) * (a12 / p) - b11 * (a02 / p))
  half_det := det_b / 2.0

  ! clamp to [-1, 1] for acos
  if (half_det <= -1.0) then
    phi := pi / 3.0
  else if (half_det >= 1.0) then
    phi := 0.0
  else
    phi := atan2(sqrt(1.0 - half_det * half_det), half_det) / 3.0
  end if

  ! eigenvalues in descending order
  e1 := q + 2.0 * p * cos(phi)
  e3 := q + 2.0 * p * cos(phi + 2.0 * pi / 3.0)
  e2 := 3.0 * q - e1 - e3

  w[0] := e1
  w[1] := e2
  w[2] := e3
end

! ── Eigendecomposition: general symmetric (Jacobi) ──────────────────

! eigenvalues of an n x n symmetric matrix via cyclic Jacobi rotations
! a is overwritten with the eigenvector matrix (columns are eigenvectors)
! w receives n eigenvalues (unsorted)
! info[0] = 0 on success, 1 if not converged
subroutine alpack.dsyev(
  a: array f64; w: array f64;
  n: i32; info: array i32
)
var
  i, j, p, q, iter, maxIter: i32
  off, thresh, app, aqq, apq: f64
  tau, t, c, s, tmp: f64
begin
  info[0] := 0
  maxIter := 100

  ! initialize w to diagonal of a
  for i := 0, n
    w[i] := a[i, n, i]
  end for

  for iter := 0, maxIter
    ! compute off-diagonal norm
    off := 0.0
    for p := 0, n
      for q := p + 1, n
        off := off + a[p, n, q] * a[p, n, q]
      end for
    end for
    if (off < 1e-28) then
      call return()
    end if

    thresh := if (iter < 4) then 0.2 * off / f64(n * n) else 0.0

    for p := 0, n
      for q := p + 1, n
        apq := a[p, n, q]
        if (abs(apq) <= thresh) then
          ! skip small elements in early sweeps
        else
          app := w[p]
          aqq := w[q]
          ! Jacobi rotation angle
          tau := (aqq - app) / (2.0 * apq)
          if (tau >= 0.0) then
            t := 1.0 / (tau + sqrt(1.0 + tau * tau))
          else
            t := 0.0 - 1.0 / (0.0 - tau + sqrt(1.0 + tau * tau))
          end if
          c := 1.0 / sqrt(1.0 + t * t)
          s := t * c

          ! update eigenvalues
          w[p] := app - t * apq
          w[q] := aqq + t * apq
          a[p, n, q] := 0.0

          ! rotate rows/columns p and q
          for i := 0, p
            tmp := a[i, n, p]
            a[i, n, p] := c * tmp - s * a[i, n, q]
            a[i, n, q] := s * tmp + c * a[i, n, q]
          end for
          for i := p + 1, q
            tmp := a[p, n, i]
            a[p, n, i] := c * tmp - s * a[i, n, q]
            a[i, n, q] := s * tmp + c * a[i, n, q]
          end for
          for i := q + 1, n
            tmp := a[p, n, i]
            a[p, n, i] := c * tmp - s * a[q, n, i]
            a[q, n, i] := s * tmp + c * a[q, n, i]
          end for
        end if
      end for
    end for
  end for
  info[0] := 1
end
