// Generated by atrac — do not edit

export const all = "! ══════════════════════════════════════════════════════════════════════\n! ALAS / ALPACK — dense linear algebra for atra\n!\n! ALAS  (Auditable Linear Algebra Subprograms) — vector/matrix primitives\n! ALPACK (Auditable Linear Algebra PACKage)    — factorizations & solvers\n!\n! all matrices are row-major, flat in linear memory.\n! 2D access: a[i, n, j] where n = number of columns (stride).\n! caller provides all buffers. info[0] = 0 on success.\n! ══════════════════════════════════════════════════════════════════════\n\n! ── ALAS Level 1: vector-vector ─────────────────────────────────────\n\n! x := alpha * x\nsubroutine alas.dscal(x: array f64; n: i32; alpha: f64)\nvar i: i32\nbegin\n  for i := 0, n\n    x[i] := alpha * x[i]\n  end for\nend\n\n! y := x  (copy x into y)\nsubroutine alas.dcopy(x: array f64; y: array f64; n: i32)\nvar i: i32\nbegin\n  for i := 0, n\n    y[i] := x[i]\n  end for\nend\n\n! y := alpha * x + y\nsubroutine alas.daxpy(x: array f64; y: array f64; n: i32; alpha: f64)\nvar\n  i, n2: i32\n  va, vx, vy: f64x2\nbegin\n  ! scalar version (for reference):\n  !   for i := 0, n\n  !     y[i] := alpha * x[i] + y[i]\n  !   end for\n  va := f64x2.splat(alpha)\n  n2 := n / 2\n  for i := 0, n2\n    vx := v128.load(x, i)\n    vy := v128.load(y, i)\n    vy := va * vx + vy\n    call v128.store(y, i, vy)\n  end for\n  ! scalar tail for odd element\n  if (n2 * 2 < n) then\n    i := n2 * 2\n    y[i] := alpha * x[i] + y[i]\n  end if\nend\n\n! returns x^T y  (dot product)\nfunction alas.ddot(x: array f64; y: array f64; n: i32): f64\nvar\n  i, n2: i32\n  vx, vy, vs: f64x2\nbegin\n  ! scalar version:\n  !   alas.ddot := 0.0\n  !   for i := 0, n\n  !     alas.ddot := alas.ddot + x[i] * y[i]\n  !   end for\n  vs := f64x2.splat(0.0)\n  n2 := n / 2\n  for i := 0, n2\n    vx := v128.load(x, i)\n    vy := v128.load(y, i)\n    vs := vs + vx * vy\n  end for\n  alas.ddot := f64x2.extract_lane(vs, 0) + f64x2.extract_lane(vs, 1)\n  ! scalar tail\n  if (n2 * 2 < n) then\n    i := n2 * 2\n    alas.ddot := alas.ddot + x[i] * y[i]\n  end if\nend\n\n! returns ||x||_2  (Euclidean norm)\nfunction alas.dnrm2(x: array f64; n: i32): f64\nvar\n  i, n2: i32\n  vx, vs: f64x2\nbegin\n  vs := f64x2.splat(0.0)\n  n2 := n / 2\n  for i := 0, n2\n    vx := v128.load(x, i)\n    vs := vs + vx * vx\n  end for\n  alas.dnrm2 := f64x2.extract_lane(vs, 0) + f64x2.extract_lane(vs, 1)\n  if (n2 * 2 < n) then\n    i := n2 * 2\n    alas.dnrm2 := alas.dnrm2 + x[i] * x[i]\n  end if\n  alas.dnrm2 := sqrt(alas.dnrm2)\nend\n\n! swap x and y\nsubroutine alas.dswap(x: array f64; y: array f64; n: i32)\nvar i: i32; t: f64\nbegin\n  for i := 0, n\n    t := x[i]\n    x[i] := y[i]\n    y[i] := t\n  end for\nend\n\n! returns sum of |x_i|\nfunction alas.dasum(x: array f64; n: i32): f64\nvar i: i32\nbegin\n  alas.dasum := 0.0\n  for i := 0, n\n    alas.dasum := alas.dasum + abs(x[i])\n  end for\nend\n\n! apply Givens rotation: [x; y] := [c s; -s c] * [x; y]\nsubroutine alas.drot(x: array f64; y: array f64; n: i32; c, s: f64)\nvar i: i32; t: f64\nbegin\n  for i := 0, n\n    t := c * x[i] + s * y[i]\n    y[i] := c * y[i] - s * x[i]\n    x[i] := t\n  end for\nend\n\n! generate Givens rotation: given (a, b), compute (c, s, r)\n! such that [c s; -s c] * [a; b] = [r; 0]\n! writes c to cs[0], s to cs[1]; returns r\nfunction alas.drotg(a, b: f64; cs: array f64): f64\nvar r, z: f64\nbegin\n  r := sqrt(a * a + b * b)\n  if (r == 0.0) then\n    cs[0] := 1.0\n    cs[1] := 0.0\n    alas.drotg := 0.0\n  else\n    cs[0] := a / r\n    cs[1] := b / r\n    alas.drotg := r\n  end if\nend\n\n! returns index of element with max absolute value\nfunction alas.idamax(x: array f64; n: i32): i32\nvar i: i32; mx: f64; v: f64\nbegin\n  alas.idamax := 0\n  mx := abs(x[0])\n  for i := 1, n\n    v := abs(x[i])\n    if (v > mx) then\n      mx := v\n      alas.idamax := i\n    end if\n  end for\nend\n\n! ── ALAS Level 2: matrix-vector ─────────────────────────────────────\n\n! y := alpha * A * x + beta * y   (general matrix-vector multiply)\n! A is m x n, x has n elements, y has m elements\nsubroutine alas.dgemv(\n  a: array f64; x: array f64; y: array f64;\n  m, n: i32; alpha, beta: f64\n)\nvar i, j: i32; s: f64\nbegin\n  for i := 0, m\n    s := 0.0\n    for j := 0, n\n      s := s + a[i, n, j] * x[j]\n    end for\n    y[i] := alpha * s + beta * y[i]\n  end for\nend\n\n! solve L*x = b or L^T*x = b  (triangular solve)\n! uplo: 0 = lower, 1 = upper\n! trans: 0 = no transpose, 1 = transpose\n! x is overwritten with the solution (input is b, output is x)\nsubroutine alas.dtrsv(\n  a: array f64; x: array f64;\n  n, uplo, trans: i32\n)\nvar i, j: i32; s: f64\nbegin\n  if (uplo == 0 and trans == 0) then\n    ! lower, no transpose: forward substitution\n    for i := 0, n\n      s := x[i]\n      for j := 0, i\n        s := s - a[i, n, j] * x[j]\n      end for\n      x[i] := s / a[i, n, i]\n    end for\n  else if (uplo == 0 and trans == 1) then\n    ! lower, transpose (= upper): back substitution\n    for i := n - 1, -1, -1\n      s := x[i]\n      for j := i + 1, n\n        s := s - a[j, n, i] * x[j]\n      end for\n      x[i] := s / a[i, n, i]\n    end for\n  else if (uplo == 1 and trans == 0) then\n    ! upper, no transpose: back substitution\n    for i := n - 1, -1, -1\n      s := x[i]\n      for j := i + 1, n\n        s := s - a[i, n, j] * x[j]\n      end for\n      x[i] := s / a[i, n, i]\n    end for\n  else\n    ! upper, transpose (= lower): forward substitution\n    for i := 0, n\n      s := x[i]\n      for j := 0, i\n        s := s - a[j, n, i] * x[j]\n      end for\n      x[i] := s / a[i, n, i]\n    end for\n  end if\nend\n\n! A := A + alpha * x * y^T  (rank-1 update)\n! A is m x n, x has m elements, y has n elements\nsubroutine alas.dger(\n  a: array f64; x: array f64; y: array f64;\n  m, n: i32; alpha: f64\n)\nvar i, j: i32; t: f64\nbegin\n  for i := 0, m\n    t := alpha * x[i]\n    for j := 0, n\n      a[i, n, j] := a[i, n, j] + t * y[j]\n    end for\n  end for\nend\n\n! y := alpha * A * x + beta * y  (symmetric matrix-vector multiply)\n! A is n x n symmetric, only lower triangle is read\nsubroutine alas.dsymv(\n  a: array f64; x: array f64; y: array f64;\n  n: i32; alpha, beta: f64\n)\nvar i, j: i32; s, t: f64\nbegin\n  ! scale y by beta\n  for i := 0, n\n    y[i] := beta * y[i]\n  end for\n  ! accumulate: diagonal + off-diagonal (symmetric)\n  for i := 0, n\n    s := 0.0\n    for j := 0, i\n      t := alpha * a[i, n, j]\n      s := s + t * x[j]\n      y[j] := y[j] + t * x[i]\n    end for\n    y[i] := y[i] + s + alpha * a[i, n, i] * x[i]\n  end for\nend\n\n! A := A + alpha * x * x^T  (symmetric rank-1 update, lower triangle)\n! A is n x n symmetric, only lower triangle is updated\nsubroutine alas.dsyr(\n  a: array f64; x: array f64;\n  n: i32; alpha: f64\n)\nvar i, j: i32; t: f64\nbegin\n  for i := 0, n\n    t := alpha * x[i]\n    for j := 0, i + 1\n      a[i, n, j] := a[i, n, j] + t * x[j]\n    end for\n  end for\nend\n\n! A := A + alpha * (x * y^T + y * x^T)  (symmetric rank-2 update, lower triangle)\n! A is n x n symmetric, only lower triangle is updated\nsubroutine alas.dsyr2(\n  a: array f64; x: array f64; y: array f64;\n  n: i32; alpha: f64\n)\nvar i, j: i32; tx, ty: f64\nbegin\n  for i := 0, n\n    tx := alpha * x[i]\n    ty := alpha * y[i]\n    for j := 0, i + 1\n      a[i, n, j] := a[i, n, j] + tx * y[j] + ty * x[j]\n    end for\n  end for\nend\n\n! x := A * x  or  x := A^T * x  (triangular matrix-vector multiply)\n! uplo: 0 = lower, 1 = upper\n! trans: 0 = no transpose, 1 = transpose\n! diag: 0 = non-unit, 1 = unit diagonal\nsubroutine alas.dtrmv(\n  a: array f64; x: array f64;\n  n, uplo, trans, diag: i32\n)\nvar i, j: i32; s: f64\nbegin\n  if (uplo == 1 and trans == 0) then\n    ! upper, no transpose: forward\n    for i := 0, n\n      s := 0.0\n      if (diag == 1) then\n        s := x[i]\n      else\n        s := a[i, n, i] * x[i]\n      end if\n      for j := i + 1, n\n        s := s + a[i, n, j] * x[j]\n      end for\n      x[i] := s\n    end for\n  else if (uplo == 0 and trans == 0) then\n    ! lower, no transpose: backward\n    for i := n - 1, -1, -1\n      s := 0.0\n      for j := 0, i\n        s := s + a[i, n, j] * x[j]\n      end for\n      if (diag == 1) then\n        s := s + x[i]\n      else\n        s := s + a[i, n, i] * x[i]\n      end if\n      x[i] := s\n    end for\n  else if (uplo == 1 and trans == 1) then\n    ! upper, transpose (= lower): backward\n    for i := n - 1, -1, -1\n      s := 0.0\n      for j := 0, i\n        s := s + a[j, n, i] * x[j]\n      end for\n      if (diag == 1) then\n        s := s + x[i]\n      else\n        s := s + a[i, n, i] * x[i]\n      end if\n      x[i] := s\n    end for\n  else\n    ! lower, transpose (= upper): forward\n    for i := 0, n\n      s := 0.0\n      if (diag == 1) then\n        s := x[i]\n      else\n        s := a[i, n, i] * x[i]\n      end if\n      for j := i + 1, n\n        s := s + a[j, n, i] * x[j]\n      end for\n      x[i] := s\n    end for\n  end if\nend\n\n! ── ALAS Level 3: matrix-matrix ─────────────────────────────────────\n\n! C := alpha * A * B + beta * C  (general matrix-matrix multiply)\n! A is m x k, B is k x n, C is m x n\nsubroutine alas.dgemm(\n  a: array f64; b: array f64; c: array f64;\n  m, n, k: i32; alpha, beta: f64\n)\nvar\n  i, j, p: i32\n  s: f64\nbegin\n  for i := 0, m\n    for j := 0, n\n      s := 0.0\n      for p := 0, k\n        s := s + a[i, k, p] * b[p, n, j]\n      end for\n      c[i, n, j] := alpha * s + beta * c[i, n, j]\n    end for\n  end for\nend\n\n! ══════════════════════════════════════════════════════════════════════\n! ALPACK — factorizations, solvers, eigendecomposition\n! ══════════════════════════════════════════════════════════════════════\n\n! ── Cholesky factorization ──────────────────────────────────────────\n\n! A = L * L^T  (in-place, lower triangle overwritten with L)\n! info[0] = 0 on success, k > 0 if not positive-definite at column k\nsubroutine alpack.dpotrf(a: array f64; n: i32; info: array i32)\nvar i, j, k: i32; s: f64\nbegin\n  info[0] := 0\n  for j := 0, n\n    s := a[j, n, j]\n    for k := 0, j\n      s := s - a[j, n, k] * a[j, n, k]\n    end for\n    if (s <= 0.0) then\n      info[0] := j + 1\n      call return()\n    end if\n    a[j, n, j] := sqrt(s)\n    for i := j + 1, n\n      s := a[i, n, j]\n      for k := 0, j\n        s := s - a[i, n, k] * a[j, n, k]\n      end for\n      a[i, n, j] := s / a[j, n, j]\n    end for\n  end for\nend\n\n! solve A*X = B given Cholesky factor L from dpotrf\n! B is overwritten with X.  B is n x nrhs (each column is an RHS)\nsubroutine alpack.dpotrs(\n  l: array f64; b: array f64;\n  n, nrhs: i32\n)\nvar rhs, i, j: i32; s: f64\nbegin\n  for rhs := 0, nrhs\n    ! forward substitution: L * y = b\n    for i := 0, n\n      s := b[i, nrhs, rhs]\n      for j := 0, i\n        s := s - l[i, n, j] * b[j, nrhs, rhs]\n      end for\n      b[i, nrhs, rhs] := s / l[i, n, i]\n    end for\n    ! back substitution: L^T * x = y\n    for i := n - 1, -1, -1\n      s := b[i, nrhs, rhs]\n      for j := i + 1, n\n        s := s - l[j, n, i] * b[j, nrhs, rhs]\n      end for\n      b[i, nrhs, rhs] := s / l[i, n, i]\n    end for\n  end for\nend\n\n! ── LU factorization with partial pivoting ──────────────────────────\n\n! A = P * L * U  (in-place, L below diagonal with unit diagonal, U on+above)\n! ipiv is an n-element i32 array of pivot indices\n! info[0] = 0 on success, k > 0 if U(k,k) is zero\nsubroutine alpack.dgetrf(\n  a: array f64; n: i32;\n  ipiv: array i32; info: array i32\n)\nvar i, j, k, pivot: i32; t, inv: f64\nbegin\n  info[0] := 0\n  for k := 0, n\n    ! find pivot in column k from row k..n-1\n    ! use inline search (idamax operates on contiguous vector)\n    pivot := k\n    t := abs(a[k, n, k])\n    for i := k + 1, n\n      if (abs(a[i, n, k]) > t) then\n        pivot := i\n        t := abs(a[i, n, k])\n      end if\n    end for\n    ipiv[k] := pivot\n\n    ! swap rows k and pivot\n    if (pivot /= k) then\n      for j := 0, n\n        t := a[k, n, j]\n        a[k, n, j] := a[pivot, n, j]\n        a[pivot, n, j] := t\n      end for\n    end if\n\n    if (a[k, n, k] == 0.0) then\n      info[0] := k + 1\n      call return()\n    end if\n\n    ! eliminate below diagonal\n    inv := 1.0 / a[k, n, k]\n    for i := k + 1, n\n      a[i, n, k] := a[i, n, k] * inv\n      for j := k + 1, n\n        a[i, n, j] := a[i, n, j] - a[i, n, k] * a[k, n, j]\n      end for\n    end for\n  end for\nend\n\n! solve A*X = B given LU factorization from dgetrf\n! B is n x nrhs, overwritten with X\nsubroutine alpack.dgetrs(\n  lu: array f64; ipiv: array i32;\n  b: array f64; n, nrhs: i32\n)\nvar rhs, i, j, p: i32; s, t: f64\nbegin\n  for rhs := 0, nrhs\n    ! apply row permutation\n    for i := 0, n\n      p := ipiv[i]\n      if (p /= i) then\n        t := b[i, nrhs, rhs]\n        b[i, nrhs, rhs] := b[p, nrhs, rhs]\n        b[p, nrhs, rhs] := t\n      end if\n    end for\n    ! forward substitution (L with unit diagonal)\n    for i := 1, n\n      s := b[i, nrhs, rhs]\n      for j := 0, i\n        s := s - lu[i, n, j] * b[j, nrhs, rhs]\n      end for\n      b[i, nrhs, rhs] := s\n    end for\n    ! back substitution (U)\n    for i := n - 1, -1, -1\n      s := b[i, nrhs, rhs]\n      for j := i + 1, n\n        s := s - lu[i, n, j] * b[j, nrhs, rhs]\n      end for\n      b[i, nrhs, rhs] := s / lu[i, n, i]\n    end for\n  end for\nend\n\n! solve A*X = B  (convenience: dgetrf + dgetrs)\n! A is overwritten with LU, B is overwritten with X\n! scratch: i32 array of length n for pivots\nsubroutine alpack.dgesv(\n  a: array f64; b: array f64;\n  n, nrhs: i32;\n  ipiv: array i32; info: array i32\n)\nbegin\n  call alpack.dgetrf(a, n, ipiv, info)\n  if (info[0] /= 0) then\n    call return()\n  end if\n  call alpack.dgetrs(a, ipiv, b, n, nrhs)\nend\n\n! ── Triangular inverse ──────────────────────────────────────────────\n\n! invert a lower triangular matrix in-place\n! info[0] = 0 on success, k > 0 if diagonal element k is zero\nsubroutine alpack.dtrtri(a: array f64; n: i32; info: array i32)\nvar i, j, k: i32; s: f64\nbegin\n  info[0] := 0\n  for j := 0, n\n    if (a[j, n, j] == 0.0) then\n      info[0] := j + 1\n      call return()\n    end if\n    a[j, n, j] := 1.0 / a[j, n, j]\n    for i := j + 1, n\n      s := 0.0\n      for k := j, i\n        s := s - a[i, n, k] * a[k, n, j]\n      end for\n      a[i, n, j] := s / a[i, n, i]\n    end for\n  end for\nend\n\n! ── Eigendecomposition: 3x3 analytical ──────────────────────────────\n\n! eigenvalues of a 3x3 symmetric matrix (analytical, Cardano's method)\n! a is 3x3 symmetric (9 f64), w receives 3 eigenvalues (sorted descending)\nsubroutine alpack.dsyev3(a: array f64; w: array f64)\nvar\n  a00, a01, a02, a11, a12, a22: f64\n  p1, q, p2, p, b00, b11, b22, det_b, half_det: f64\n  phi, r, e1, e2, e3: f64\n  m: f64\n  pi: f64\nbegin\n  pi := 3.14159265358979323846\n\n  a00 := a[0, 3, 0]\n  a01 := a[0, 3, 1]\n  a02 := a[0, 3, 2]\n  a11 := a[1, 3, 1]\n  a12 := a[1, 3, 2]\n  a22 := a[2, 3, 2]\n\n  ! trace / 3\n  m := (a00 + a11 + a22) / 3.0\n\n  ! sum of squares of off-diagonal elements\n  p1 := a01 * a01 + a02 * a02 + a12 * a12\n\n  if (p1 <= 1e-30) then\n    ! diagonal matrix — eigenvalues are the diagonal entries, sort descending\n    e1 := a00\n    e2 := a11\n    e3 := a22\n    ! sort 3 values descending (bubble sort)\n    if (e2 > e1) then\n      r := e1\n      e1 := e2\n      e2 := r\n    end if\n    if (e3 > e2) then\n      r := e2\n      e2 := e3\n      e3 := r\n    end if\n    if (e2 > e1) then\n      r := e1\n      e1 := e2\n      e2 := r\n    end if\n    w[0] := e1\n    w[1] := e2\n    w[2] := e3\n    call return()\n  end if\n\n  q := m\n  p2 := (a00 - q) * (a00 - q) + (a11 - q) * (a11 - q) + (a22 - q) * (a22 - q) + 2.0 * p1\n  p := sqrt(p2 / 6.0)\n\n  ! B = (A - q*I) / p  — only need determinant\n  b00 := (a00 - q) / p\n  b11 := (a11 - q) / p\n  b22 := (a22 - q) / p\n  ! det(B) for symmetric 3x3\n  det_b := b00 * (b11 * b22 - (a12 / p) * (a12 / p))\n         - (a01 / p) * ((a01 / p) * b22 - (a12 / p) * (a02 / p))\n         + (a02 / p) * ((a01 / p) * (a12 / p) - b11 * (a02 / p))\n  half_det := det_b / 2.0\n\n  ! clamp to [-1, 1] for acos\n  if (half_det <= -1.0) then\n    phi := pi / 3.0\n  else if (half_det >= 1.0) then\n    phi := 0.0\n  else\n    phi := atan2(sqrt(1.0 - half_det * half_det), half_det) / 3.0\n  end if\n\n  ! eigenvalues in descending order\n  e1 := q + 2.0 * p * cos(phi)\n  e3 := q + 2.0 * p * cos(phi + 2.0 * pi / 3.0)\n  e2 := 3.0 * q - e1 - e3\n\n  w[0] := e1\n  w[1] := e2\n  w[2] := e3\nend\n\n! ── Eigendecomposition: 3x3 analytical with eigenvectors ─────────────\n\n! eigenvalues + eigenvectors of a 3x3 symmetric matrix\n! a is 3x3 symmetric (9 f64), w receives 3 eigenvalues (sorted descending),\n! v receives 3x3 eigenvector matrix (columns are eigenvectors, row-major)\n! uses Cardano eigenvalues + cross-product null-space for eigenvectors\nsubroutine alpack.dsyev3v(a: array f64; w: array f64; v: array f64)\nvar\n  a00, a01, a02, a11, a12, a22: f64\n  p1, q, p2, p, b00, b11, b22, det_b, half_det: f64\n  phi, r, e1, e2, e3: f64\n  m: f64\n  pi: f64\n  ! eigenvector computation\n  k, best: i32\n  r0x, r0y, r0z, r1x, r1y, r1z, r2x, r2y, r2z: f64\n  cx, cy, cz: f64\n  n01, n12, n02, nmax, nrm: f64\nbegin\n  pi := 3.14159265358979323846\n\n  a00 := a[0, 3, 0]\n  a01 := a[0, 3, 1]\n  a02 := a[0, 3, 2]\n  a11 := a[1, 3, 1]\n  a12 := a[1, 3, 2]\n  a22 := a[2, 3, 2]\n\n  ! ── compute eigenvalues (same as dsyev3) ──\n  m := (a00 + a11 + a22) / 3.0\n  p1 := a01 * a01 + a02 * a02 + a12 * a12\n\n  if (p1 <= 1e-30) then\n    ! diagonal matrix\n    e1 := a00\n    e2 := a11\n    e3 := a22\n    if (e2 > e1) then\n      r := e1\n      e1 := e2\n      e2 := r\n    end if\n    if (e3 > e2) then\n      r := e2\n      e2 := e3\n      e3 := r\n    end if\n    if (e2 > e1) then\n      r := e1\n      e1 := e2\n      e2 := r\n    end if\n    w[0] := e1\n    w[1] := e2\n    w[2] := e3\n    ! eigenvectors for diagonal: identity (re-ordered to match eigenvalue order)\n    ! Find which diagonal entry maps to which eigenvalue\n    ! For simplicity with the sorted eigenvalues, compute eigenvectors below\n  else\n    q := m\n    p2 := (a00 - q) * (a00 - q) + (a11 - q) * (a11 - q) + (a22 - q) * (a22 - q) + 2.0 * p1\n    p := sqrt(p2 / 6.0)\n\n    b00 := (a00 - q) / p\n    b11 := (a11 - q) / p\n    b22 := (a22 - q) / p\n    det_b := b00 * (b11 * b22 - (a12 / p) * (a12 / p))\n           - (a01 / p) * ((a01 / p) * b22 - (a12 / p) * (a02 / p))\n           + (a02 / p) * ((a01 / p) * (a12 / p) - b11 * (a02 / p))\n    half_det := det_b / 2.0\n\n    if (half_det <= -1.0) then\n      phi := pi / 3.0\n    else if (half_det >= 1.0) then\n      phi := 0.0\n    else\n      phi := atan2(sqrt(1.0 - half_det * half_det), half_det) / 3.0\n    end if\n\n    e1 := q + 2.0 * p * cos(phi)\n    e3 := q + 2.0 * p * cos(phi + 2.0 * pi / 3.0)\n    e2 := 3.0 * q - e1 - e3\n\n    w[0] := e1\n    w[1] := e2\n    w[2] := e3\n  end if\n\n  ! ── compute eigenvectors via cross-product null-space ──\n  ! For each eigenvalue w[k], form B = A - w[k]*I, take cross product\n  ! of two rows with largest cross-product norm\n  for k := 0, 3\n    r0x := a00 - w[k]\n    r0y := a01\n    r0z := a02\n    r1x := a01\n    r1y := a11 - w[k]\n    r1z := a12\n    r2x := a02\n    r2y := a12\n    r2z := a22 - w[k]\n\n    ! cross products of row pairs\n    ! r0 x r1\n    cx := r0y * r1z - r0z * r1y\n    cy := r0z * r1x - r0x * r1z\n    cz := r0x * r1y - r0y * r1x\n    n01 := cx * cx + cy * cy + cz * cz\n\n    nmax := n01\n    ! store best cross product\n    v[0, 3, k] := cx\n    v[1, 3, k] := cy\n    v[2, 3, k] := cz\n\n    ! r1 x r2\n    cx := r1y * r2z - r1z * r2y\n    cy := r1z * r2x - r1x * r2z\n    cz := r1x * r2y - r1y * r2x\n    n12 := cx * cx + cy * cy + cz * cz\n    if (n12 > nmax) then\n      nmax := n12\n      v[0, 3, k] := cx\n      v[1, 3, k] := cy\n      v[2, 3, k] := cz\n    end if\n\n    ! r0 x r2\n    cx := r0y * r2z - r0z * r2y\n    cy := r0z * r2x - r0x * r2z\n    cz := r0x * r2y - r0y * r2x\n    n02 := cx * cx + cy * cy + cz * cz\n    if (n02 > nmax) then\n      nmax := n02\n      v[0, 3, k] := cx\n      v[1, 3, k] := cy\n      v[2, 3, k] := cz\n    end if\n\n    ! normalize\n    nrm := sqrt(nmax)\n    if (nrm > 1e-30) then\n      v[0, 3, k] := v[0, 3, k] / nrm\n      v[1, 3, k] := v[1, 3, k] / nrm\n      v[2, 3, k] := v[2, 3, k] / nrm\n    else\n      ! degenerate: use canonical basis vector\n      v[0, 3, k] := 0.0\n      v[1, 3, k] := 0.0\n      v[2, 3, k] := 0.0\n      v[k, 3, k] := 1.0\n    end if\n  end for\nend\n\n! ── Eigendecomposition: general symmetric (Jacobi) ──────────────────\n\n! eigenvalues of an n x n symmetric matrix via cyclic Jacobi rotations\n! a is overwritten with the eigenvector matrix (columns are eigenvectors)\n! w receives n eigenvalues (unsorted)\n! info[0] = 0 on success, 1 if not converged\nsubroutine alpack.dsyev(\n  a: array f64; w: array f64;\n  n: i32; info: array i32\n)\nvar\n  i, j, p, q, iter, maxIter: i32\n  off, thresh, app, aqq, apq: f64\n  tau, t, c, s, tmp: f64\nbegin\n  info[0] := 0\n  maxIter := 100\n\n  ! initialize w to diagonal of a\n  for i := 0, n\n    w[i] := a[i, n, i]\n  end for\n\n  for iter := 0, maxIter\n    ! compute off-diagonal norm\n    off := 0.0\n    for p := 0, n\n      for q := p + 1, n\n        off := off + a[p, n, q] * a[p, n, q]\n      end for\n    end for\n    if (off < 1e-28) then\n      call return()\n    end if\n\n    thresh := if (iter < 4) then 0.2 * off / f64(n * n) else 0.0\n\n    for p := 0, n\n      for q := p + 1, n\n        apq := a[p, n, q]\n        if (abs(apq) <= thresh) then\n          ! skip small elements in early sweeps\n        else\n          app := w[p]\n          aqq := w[q]\n          ! Jacobi rotation angle\n          tau := (aqq - app) / (2.0 * apq)\n          if (tau >= 0.0) then\n            t := 1.0 / (tau + sqrt(1.0 + tau * tau))\n          else\n            t := 0.0 - 1.0 / (0.0 - tau + sqrt(1.0 + tau * tau))\n          end if\n          c := 1.0 / sqrt(1.0 + t * t)\n          s := t * c\n\n          ! update eigenvalues\n          w[p] := app - t * apq\n          w[q] := aqq + t * apq\n          a[p, n, q] := 0.0\n\n          ! rotate rows/columns p and q\n          for i := 0, p\n            tmp := a[i, n, p]\n            a[i, n, p] := c * tmp - s * a[i, n, q]\n            a[i, n, q] := s * tmp + c * a[i, n, q]\n          end for\n          for i := p + 1, q\n            tmp := a[p, n, i]\n            a[p, n, i] := c * tmp - s * a[i, n, q]\n            a[i, n, q] := s * tmp + c * a[i, n, q]\n          end for\n          for i := q + 1, n\n            tmp := a[p, n, i]\n            a[p, n, i] := c * tmp - s * a[q, n, i]\n            a[q, n, i] := s * tmp + c * a[q, n, i]\n          end for\n        end if\n      end for\n    end for\n  end for\n  info[0] := 1\nend\n\n! ── Eigendecomposition: general symmetric (Jacobi) with eigenvectors ──\n\n! eigenvalues + eigenvectors of an n x n symmetric matrix via cyclic Jacobi\n! a is overwritten (destroyed). w receives n eigenvalues (unsorted).\n! v receives n x n eigenvector matrix (columns are eigenvectors, row-major).\n! info[0] = 0 on success, 1 if not converged\nsubroutine alpack.dsyevv(\n  a: array f64; w: array f64; v: array f64;\n  n: i32; info: array i32\n)\nvar\n  i, j, p, q, iter, maxIter: i32\n  off, thresh, app, aqq, apq: f64\n  tau, t, c, s, tmp: f64\nbegin\n  info[0] := 0\n  maxIter := 100\n\n  ! initialize V = I\n  for i := 0, n\n    for j := 0, n\n      if (i == j) then\n        v[i, n, j] := 1.0\n      else\n        v[i, n, j] := 0.0\n      end if\n    end for\n  end for\n\n  ! initialize w to diagonal of a\n  for i := 0, n\n    w[i] := a[i, n, i]\n  end for\n\n  for iter := 0, maxIter\n    ! compute off-diagonal norm\n    off := 0.0\n    for p := 0, n\n      for q := p + 1, n\n        off := off + a[p, n, q] * a[p, n, q]\n      end for\n    end for\n    if (off < 1e-28) then\n      call return()\n    end if\n\n    thresh := if (iter < 4) then 0.2 * off / f64(n * n) else 0.0\n\n    for p := 0, n\n      for q := p + 1, n\n        apq := a[p, n, q]\n        if (abs(apq) <= thresh) then\n          ! skip small elements in early sweeps\n        else\n          app := w[p]\n          aqq := w[q]\n          tau := (aqq - app) / (2.0 * apq)\n          if (tau >= 0.0) then\n            t := 1.0 / (tau + sqrt(1.0 + tau * tau))\n          else\n            t := 0.0 - 1.0 / (0.0 - tau + sqrt(1.0 + tau * tau))\n          end if\n          c := 1.0 / sqrt(1.0 + t * t)\n          s := t * c\n\n          w[p] := app - t * apq\n          w[q] := aqq + t * apq\n          a[p, n, q] := 0.0\n\n          ! rotate rows/columns p and q\n          for i := 0, p\n            tmp := a[i, n, p]\n            a[i, n, p] := c * tmp - s * a[i, n, q]\n            a[i, n, q] := s * tmp + c * a[i, n, q]\n          end for\n          for i := p + 1, q\n            tmp := a[p, n, i]\n            a[p, n, i] := c * tmp - s * a[i, n, q]\n            a[i, n, q] := s * tmp + c * a[i, n, q]\n          end for\n          for i := q + 1, n\n            tmp := a[p, n, i]\n            a[p, n, i] := c * tmp - s * a[q, n, i]\n            a[q, n, i] := s * tmp + c * a[q, n, i]\n          end for\n\n          ! accumulate into eigenvector matrix V\n          for i := 0, n\n            tmp := v[i, n, p]\n            v[i, n, p] := c * tmp - s * v[i, n, q]\n            v[i, n, q] := s * tmp + c * v[i, n, q]\n          end for\n        end if\n      end for\n    end for\n  end for\n  info[0] := 1\nend\n";

export const alas_dscal = "subroutine alas.dscal(x: array f64; n: i32; alpha: f64)\nvar i: i32\nbegin\n  for i := 0, n\n    x[i] := alpha * x[i]\n  end for\nend";

export const alas_dcopy = "subroutine alas.dcopy(x: array f64; y: array f64; n: i32)\nvar i: i32\nbegin\n  for i := 0, n\n    y[i] := x[i]\n  end for\nend";

export const alas_daxpy = "subroutine alas.daxpy(x: array f64; y: array f64; n: i32; alpha: f64)\nvar\n  i, n2: i32\n  va, vx, vy: f64x2\nbegin\n  ! scalar version (for reference):\n  !   for i := 0, n\n  !     y[i] := alpha * x[i] + y[i]\n  !   end for\n  va := f64x2.splat(alpha)\n  n2 := n / 2\n  for i := 0, n2\n    vx := v128.load(x, i)\n    vy := v128.load(y, i)\n    vy := va * vx + vy\n    call v128.store(y, i, vy)\n  end for\n  ! scalar tail for odd element\n  if (n2 * 2 < n) then\n    i := n2 * 2\n    y[i] := alpha * x[i] + y[i]\n  end if\nend";

export const alas_ddot = "function alas.ddot(x: array f64; y: array f64; n: i32): f64\nvar\n  i, n2: i32\n  vx, vy, vs: f64x2\nbegin\n  ! scalar version:\n  !   alas.ddot := 0.0\n  !   for i := 0, n\n  !     alas.ddot := alas.ddot + x[i] * y[i]\n  !   end for\n  vs := f64x2.splat(0.0)\n  n2 := n / 2\n  for i := 0, n2\n    vx := v128.load(x, i)\n    vy := v128.load(y, i)\n    vs := vs + vx * vy\n  end for\n  alas.ddot := f64x2.extract_lane(vs, 0) + f64x2.extract_lane(vs, 1)\n  ! scalar tail\n  if (n2 * 2 < n) then\n    i := n2 * 2\n    alas.ddot := alas.ddot + x[i] * y[i]\n  end if\nend";

export const alas_dnrm2 = "function alas.dnrm2(x: array f64; n: i32): f64\nvar\n  i, n2: i32\n  vx, vs: f64x2\nbegin\n  vs := f64x2.splat(0.0)\n  n2 := n / 2\n  for i := 0, n2\n    vx := v128.load(x, i)\n    vs := vs + vx * vx\n  end for\n  alas.dnrm2 := f64x2.extract_lane(vs, 0) + f64x2.extract_lane(vs, 1)\n  if (n2 * 2 < n) then\n    i := n2 * 2\n    alas.dnrm2 := alas.dnrm2 + x[i] * x[i]\n  end if\n  alas.dnrm2 := sqrt(alas.dnrm2)\nend";

export const alas_dswap = "subroutine alas.dswap(x: array f64; y: array f64; n: i32)\nvar i: i32; t: f64\nbegin\n  for i := 0, n\n    t := x[i]\n    x[i] := y[i]\n    y[i] := t\n  end for\nend";

export const alas_dasum = "function alas.dasum(x: array f64; n: i32): f64\nvar i: i32\nbegin\n  alas.dasum := 0.0\n  for i := 0, n\n    alas.dasum := alas.dasum + abs(x[i])\n  end for\nend";

export const alas_drot = "subroutine alas.drot(x: array f64; y: array f64; n: i32; c, s: f64)\nvar i: i32; t: f64\nbegin\n  for i := 0, n\n    t := c * x[i] + s * y[i]\n    y[i] := c * y[i] - s * x[i]\n    x[i] := t\n  end for\nend";

export const alas_drotg = "function alas.drotg(a, b: f64; cs: array f64): f64\nvar r, z: f64\nbegin\n  r := sqrt(a * a + b * b)\n  if (r == 0.0) then\n    cs[0] := 1.0\n    cs[1] := 0.0\n    alas.drotg := 0.0\n  else\n    cs[0] := a / r\n    cs[1] := b / r\n    alas.drotg := r\n  end if\nend";

export const alas_idamax = "function alas.idamax(x: array f64; n: i32): i32\nvar i: i32; mx: f64; v: f64\nbegin\n  alas.idamax := 0\n  mx := abs(x[0])\n  for i := 1, n\n    v := abs(x[i])\n    if (v > mx) then\n      mx := v\n      alas.idamax := i\n    end if\n  end for\nend";

export const alas_dgemv = "subroutine alas.dgemv(\n  a: array f64; x: array f64; y: array f64;\n  m, n: i32; alpha, beta: f64\n)\nvar i, j: i32; s: f64\nbegin\n  for i := 0, m\n    s := 0.0\n    for j := 0, n\n      s := s + a[i, n, j] * x[j]\n    end for\n    y[i] := alpha * s + beta * y[i]\n  end for\nend";

export const alas_dtrsv = "subroutine alas.dtrsv(\n  a: array f64; x: array f64;\n  n, uplo, trans: i32\n)\nvar i, j: i32; s: f64\nbegin\n  if (uplo == 0 and trans == 0) then\n    ! lower, no transpose: forward substitution\n    for i := 0, n\n      s := x[i]\n      for j := 0, i\n        s := s - a[i, n, j] * x[j]\n      end for\n      x[i] := s / a[i, n, i]\n    end for\n  else if (uplo == 0 and trans == 1) then\n    ! lower, transpose (= upper): back substitution\n    for i := n - 1, -1, -1\n      s := x[i]\n      for j := i + 1, n\n        s := s - a[j, n, i] * x[j]\n      end for\n      x[i] := s / a[i, n, i]\n    end for\n  else if (uplo == 1 and trans == 0) then\n    ! upper, no transpose: back substitution\n    for i := n - 1, -1, -1\n      s := x[i]\n      for j := i + 1, n\n        s := s - a[i, n, j] * x[j]\n      end for\n      x[i] := s / a[i, n, i]\n    end for\n  else\n    ! upper, transpose (= lower): forward substitution\n    for i := 0, n\n      s := x[i]\n      for j := 0, i\n        s := s - a[j, n, i] * x[j]\n      end for\n      x[i] := s / a[i, n, i]\n    end for\n  end if\nend";

export const alas_dger = "subroutine alas.dger(\n  a: array f64; x: array f64; y: array f64;\n  m, n: i32; alpha: f64\n)\nvar i, j: i32; t: f64\nbegin\n  for i := 0, m\n    t := alpha * x[i]\n    for j := 0, n\n      a[i, n, j] := a[i, n, j] + t * y[j]\n    end for\n  end for\nend";

export const alas_dsymv = "subroutine alas.dsymv(\n  a: array f64; x: array f64; y: array f64;\n  n: i32; alpha, beta: f64\n)\nvar i, j: i32; s, t: f64\nbegin\n  ! scale y by beta\n  for i := 0, n\n    y[i] := beta * y[i]\n  end for\n  ! accumulate: diagonal + off-diagonal (symmetric)\n  for i := 0, n\n    s := 0.0\n    for j := 0, i\n      t := alpha * a[i, n, j]\n      s := s + t * x[j]\n      y[j] := y[j] + t * x[i]\n    end for\n    y[i] := y[i] + s + alpha * a[i, n, i] * x[i]\n  end for\nend";

export const alas_dsyr = "subroutine alas.dsyr(\n  a: array f64; x: array f64;\n  n: i32; alpha: f64\n)\nvar i, j: i32; t: f64\nbegin\n  for i := 0, n\n    t := alpha * x[i]\n    for j := 0, i + 1\n      a[i, n, j] := a[i, n, j] + t * x[j]\n    end for\n  end for\nend";

export const alas_dsyr2 = "subroutine alas.dsyr2(\n  a: array f64; x: array f64; y: array f64;\n  n: i32; alpha: f64\n)\nvar i, j: i32; tx, ty: f64\nbegin\n  for i := 0, n\n    tx := alpha * x[i]\n    ty := alpha * y[i]\n    for j := 0, i + 1\n      a[i, n, j] := a[i, n, j] + tx * y[j] + ty * x[j]\n    end for\n  end for\nend";

export const alas_dtrmv = "subroutine alas.dtrmv(\n  a: array f64; x: array f64;\n  n, uplo, trans, diag: i32\n)\nvar i, j: i32; s: f64\nbegin\n  if (uplo == 1 and trans == 0) then\n    ! upper, no transpose: forward\n    for i := 0, n\n      s := 0.0\n      if (diag == 1) then\n        s := x[i]\n      else\n        s := a[i, n, i] * x[i]\n      end if\n      for j := i + 1, n\n        s := s + a[i, n, j] * x[j]\n      end for\n      x[i] := s\n    end for\n  else if (uplo == 0 and trans == 0) then\n    ! lower, no transpose: backward\n    for i := n - 1, -1, -1\n      s := 0.0\n      for j := 0, i\n        s := s + a[i, n, j] * x[j]\n      end for\n      if (diag == 1) then\n        s := s + x[i]\n      else\n        s := s + a[i, n, i] * x[i]\n      end if\n      x[i] := s\n    end for\n  else if (uplo == 1 and trans == 1) then\n    ! upper, transpose (= lower): backward\n    for i := n - 1, -1, -1\n      s := 0.0\n      for j := 0, i\n        s := s + a[j, n, i] * x[j]\n      end for\n      if (diag == 1) then\n        s := s + x[i]\n      else\n        s := s + a[i, n, i] * x[i]\n      end if\n      x[i] := s\n    end for\n  else\n    ! lower, transpose (= upper): forward\n    for i := 0, n\n      s := 0.0\n      if (diag == 1) then\n        s := x[i]\n      else\n        s := a[i, n, i] * x[i]\n      end if\n      for j := i + 1, n\n        s := s + a[j, n, i] * x[j]\n      end for\n      x[i] := s\n    end for\n  end if\nend";

export const alas_dgemm = "subroutine alas.dgemm(\n  a: array f64; b: array f64; c: array f64;\n  m, n, k: i32; alpha, beta: f64\n)\nvar\n  i, j, p: i32\n  s: f64\nbegin\n  for i := 0, m\n    for j := 0, n\n      s := 0.0\n      for p := 0, k\n        s := s + a[i, k, p] * b[p, n, j]\n      end for\n      c[i, n, j] := alpha * s + beta * c[i, n, j]\n    end for\n  end for\nend";

export const alpack_dpotrf = "subroutine alpack.dpotrf(a: array f64; n: i32; info: array i32)\nvar i, j, k: i32; s: f64\nbegin\n  info[0] := 0\n  for j := 0, n\n    s := a[j, n, j]\n    for k := 0, j\n      s := s - a[j, n, k] * a[j, n, k]\n    end for\n    if (s <= 0.0) then\n      info[0] := j + 1\n      call return()\n    end if\n    a[j, n, j] := sqrt(s)\n    for i := j + 1, n\n      s := a[i, n, j]\n      for k := 0, j\n        s := s - a[i, n, k] * a[j, n, k]\n      end for\n      a[i, n, j] := s / a[j, n, j]\n    end for\n  end for\nend";

export const alpack_dpotrs = "subroutine alpack.dpotrs(\n  l: array f64; b: array f64;\n  n, nrhs: i32\n)\nvar rhs, i, j: i32; s: f64\nbegin\n  for rhs := 0, nrhs\n    ! forward substitution: L * y = b\n    for i := 0, n\n      s := b[i, nrhs, rhs]\n      for j := 0, i\n        s := s - l[i, n, j] * b[j, nrhs, rhs]\n      end for\n      b[i, nrhs, rhs] := s / l[i, n, i]\n    end for\n    ! back substitution: L^T * x = y\n    for i := n - 1, -1, -1\n      s := b[i, nrhs, rhs]\n      for j := i + 1, n\n        s := s - l[j, n, i] * b[j, nrhs, rhs]\n      end for\n      b[i, nrhs, rhs] := s / l[i, n, i]\n    end for\n  end for\nend";

export const alpack_dgetrf = "subroutine alpack.dgetrf(\n  a: array f64; n: i32;\n  ipiv: array i32; info: array i32\n)\nvar i, j, k, pivot: i32; t, inv: f64\nbegin\n  info[0] := 0\n  for k := 0, n\n    ! find pivot in column k from row k..n-1\n    ! use inline search (idamax operates on contiguous vector)\n    pivot := k\n    t := abs(a[k, n, k])\n    for i := k + 1, n\n      if (abs(a[i, n, k]) > t) then\n        pivot := i\n        t := abs(a[i, n, k])\n      end if\n    end for\n    ipiv[k] := pivot\n\n    ! swap rows k and pivot\n    if (pivot /= k) then\n      for j := 0, n\n        t := a[k, n, j]\n        a[k, n, j] := a[pivot, n, j]\n        a[pivot, n, j] := t\n      end for\n    end if\n\n    if (a[k, n, k] == 0.0) then\n      info[0] := k + 1\n      call return()\n    end if\n\n    ! eliminate below diagonal\n    inv := 1.0 / a[k, n, k]\n    for i := k + 1, n\n      a[i, n, k] := a[i, n, k] * inv\n      for j := k + 1, n\n        a[i, n, j] := a[i, n, j] - a[i, n, k] * a[k, n, j]\n      end for\n    end for\n  end for\nend";

export const alpack_dgetrs = "subroutine alpack.dgetrs(\n  lu: array f64; ipiv: array i32;\n  b: array f64; n, nrhs: i32\n)\nvar rhs, i, j, p: i32; s, t: f64\nbegin\n  for rhs := 0, nrhs\n    ! apply row permutation\n    for i := 0, n\n      p := ipiv[i]\n      if (p /= i) then\n        t := b[i, nrhs, rhs]\n        b[i, nrhs, rhs] := b[p, nrhs, rhs]\n        b[p, nrhs, rhs] := t\n      end if\n    end for\n    ! forward substitution (L with unit diagonal)\n    for i := 1, n\n      s := b[i, nrhs, rhs]\n      for j := 0, i\n        s := s - lu[i, n, j] * b[j, nrhs, rhs]\n      end for\n      b[i, nrhs, rhs] := s\n    end for\n    ! back substitution (U)\n    for i := n - 1, -1, -1\n      s := b[i, nrhs, rhs]\n      for j := i + 1, n\n        s := s - lu[i, n, j] * b[j, nrhs, rhs]\n      end for\n      b[i, nrhs, rhs] := s / lu[i, n, i]\n    end for\n  end for\nend";

export const alpack_dgesv = "subroutine alpack.dgesv(\n  a: array f64; b: array f64;\n  n, nrhs: i32;\n  ipiv: array i32; info: array i32\n)\nbegin\n  call alpack.dgetrf(a, n, ipiv, info)\n  if (info[0] /= 0) then\n    call return()\n  end if\n  call alpack.dgetrs(a, ipiv, b, n, nrhs)\nend";

export const alpack_dtrtri = "subroutine alpack.dtrtri(a: array f64; n: i32; info: array i32)\nvar i, j, k: i32; s: f64\nbegin\n  info[0] := 0\n  for j := 0, n\n    if (a[j, n, j] == 0.0) then\n      info[0] := j + 1\n      call return()\n    end if\n    a[j, n, j] := 1.0 / a[j, n, j]\n    for i := j + 1, n\n      s := 0.0\n      for k := j, i\n        s := s - a[i, n, k] * a[k, n, j]\n      end for\n      a[i, n, j] := s / a[i, n, i]\n    end for\n  end for\nend";

export const alpack_dsyev3 = "subroutine alpack.dsyev3(a: array f64; w: array f64)\nvar\n  a00, a01, a02, a11, a12, a22: f64\n  p1, q, p2, p, b00, b11, b22, det_b, half_det: f64\n  phi, r, e1, e2, e3: f64\n  m: f64\n  pi: f64\nbegin\n  pi := 3.14159265358979323846\n\n  a00 := a[0, 3, 0]\n  a01 := a[0, 3, 1]\n  a02 := a[0, 3, 2]\n  a11 := a[1, 3, 1]\n  a12 := a[1, 3, 2]\n  a22 := a[2, 3, 2]\n\n  ! trace / 3\n  m := (a00 + a11 + a22) / 3.0\n\n  ! sum of squares of off-diagonal elements\n  p1 := a01 * a01 + a02 * a02 + a12 * a12\n\n  if (p1 <= 1e-30) then\n    ! diagonal matrix — eigenvalues are the diagonal entries, sort descending\n    e1 := a00\n    e2 := a11\n    e3 := a22\n    ! sort 3 values descending (bubble sort)\n    if (e2 > e1) then\n      r := e1\n      e1 := e2\n      e2 := r\n    end if\n    if (e3 > e2) then\n      r := e2\n      e2 := e3\n      e3 := r\n    end if\n    if (e2 > e1) then\n      r := e1\n      e1 := e2\n      e2 := r\n    end if\n    w[0] := e1\n    w[1] := e2\n    w[2] := e3\n    call return()\n  end if\n\n  q := m\n  p2 := (a00 - q) * (a00 - q) + (a11 - q) * (a11 - q) + (a22 - q) * (a22 - q) + 2.0 * p1\n  p := sqrt(p2 / 6.0)\n\n  ! B = (A - q*I) / p  — only need determinant\n  b00 := (a00 - q) / p\n  b11 := (a11 - q) / p\n  b22 := (a22 - q) / p\n  ! det(B) for symmetric 3x3\n  det_b := b00 * (b11 * b22 - (a12 / p) * (a12 / p))\n         - (a01 / p) * ((a01 / p) * b22 - (a12 / p) * (a02 / p))\n         + (a02 / p) * ((a01 / p) * (a12 / p) - b11 * (a02 / p))\n  half_det := det_b / 2.0\n\n  ! clamp to [-1, 1] for acos\n  if (half_det <= -1.0) then\n    phi := pi / 3.0\n  else if (half_det >= 1.0) then\n    phi := 0.0\n  else\n    phi := atan2(sqrt(1.0 - half_det * half_det), half_det) / 3.0\n  end if\n\n  ! eigenvalues in descending order\n  e1 := q + 2.0 * p * cos(phi)\n  e3 := q + 2.0 * p * cos(phi + 2.0 * pi / 3.0)\n  e2 := 3.0 * q - e1 - e3\n\n  w[0] := e1\n  w[1] := e2\n  w[2] := e3\nend";

export const alpack_dsyev3v = "subroutine alpack.dsyev3v(a: array f64; w: array f64; v: array f64)\nvar\n  a00, a01, a02, a11, a12, a22: f64\n  p1, q, p2, p, b00, b11, b22, det_b, half_det: f64\n  phi, r, e1, e2, e3: f64\n  m: f64\n  pi: f64\n  ! eigenvector computation\n  k, best: i32\n  r0x, r0y, r0z, r1x, r1y, r1z, r2x, r2y, r2z: f64\n  cx, cy, cz: f64\n  n01, n12, n02, nmax, nrm: f64\nbegin\n  pi := 3.14159265358979323846\n\n  a00 := a[0, 3, 0]\n  a01 := a[0, 3, 1]\n  a02 := a[0, 3, 2]\n  a11 := a[1, 3, 1]\n  a12 := a[1, 3, 2]\n  a22 := a[2, 3, 2]\n\n  ! ── compute eigenvalues (same as dsyev3) ──\n  m := (a00 + a11 + a22) / 3.0\n  p1 := a01 * a01 + a02 * a02 + a12 * a12\n\n  if (p1 <= 1e-30) then\n    ! diagonal matrix\n    e1 := a00\n    e2 := a11\n    e3 := a22\n    if (e2 > e1) then\n      r := e1\n      e1 := e2\n      e2 := r\n    end if\n    if (e3 > e2) then\n      r := e2\n      e2 := e3\n      e3 := r\n    end if\n    if (e2 > e1) then\n      r := e1\n      e1 := e2\n      e2 := r\n    end if\n    w[0] := e1\n    w[1] := e2\n    w[2] := e3\n    ! eigenvectors for diagonal: identity (re-ordered to match eigenvalue order)\n    ! Find which diagonal entry maps to which eigenvalue\n    ! For simplicity with the sorted eigenvalues, compute eigenvectors below\n  else\n    q := m\n    p2 := (a00 - q) * (a00 - q) + (a11 - q) * (a11 - q) + (a22 - q) * (a22 - q) + 2.0 * p1\n    p := sqrt(p2 / 6.0)\n\n    b00 := (a00 - q) / p\n    b11 := (a11 - q) / p\n    b22 := (a22 - q) / p\n    det_b := b00 * (b11 * b22 - (a12 / p) * (a12 / p))\n           - (a01 / p) * ((a01 / p) * b22 - (a12 / p) * (a02 / p))\n           + (a02 / p) * ((a01 / p) * (a12 / p) - b11 * (a02 / p))\n    half_det := det_b / 2.0\n\n    if (half_det <= -1.0) then\n      phi := pi / 3.0\n    else if (half_det >= 1.0) then\n      phi := 0.0\n    else\n      phi := atan2(sqrt(1.0 - half_det * half_det), half_det) / 3.0\n    end if\n\n    e1 := q + 2.0 * p * cos(phi)\n    e3 := q + 2.0 * p * cos(phi + 2.0 * pi / 3.0)\n    e2 := 3.0 * q - e1 - e3\n\n    w[0] := e1\n    w[1] := e2\n    w[2] := e3\n  end if\n\n  ! ── compute eigenvectors via cross-product null-space ──\n  ! For each eigenvalue w[k], form B = A - w[k]*I, take cross product\n  ! of two rows with largest cross-product norm\n  for k := 0, 3\n    r0x := a00 - w[k]\n    r0y := a01\n    r0z := a02\n    r1x := a01\n    r1y := a11 - w[k]\n    r1z := a12\n    r2x := a02\n    r2y := a12\n    r2z := a22 - w[k]\n\n    ! cross products of row pairs\n    ! r0 x r1\n    cx := r0y * r1z - r0z * r1y\n    cy := r0z * r1x - r0x * r1z\n    cz := r0x * r1y - r0y * r1x\n    n01 := cx * cx + cy * cy + cz * cz\n\n    nmax := n01\n    ! store best cross product\n    v[0, 3, k] := cx\n    v[1, 3, k] := cy\n    v[2, 3, k] := cz\n\n    ! r1 x r2\n    cx := r1y * r2z - r1z * r2y\n    cy := r1z * r2x - r1x * r2z\n    cz := r1x * r2y - r1y * r2x\n    n12 := cx * cx + cy * cy + cz * cz\n    if (n12 > nmax) then\n      nmax := n12\n      v[0, 3, k] := cx\n      v[1, 3, k] := cy\n      v[2, 3, k] := cz\n    end if\n\n    ! r0 x r2\n    cx := r0y * r2z - r0z * r2y\n    cy := r0z * r2x - r0x * r2z\n    cz := r0x * r2y - r0y * r2x\n    n02 := cx * cx + cy * cy + cz * cz\n    if (n02 > nmax) then\n      nmax := n02\n      v[0, 3, k] := cx\n      v[1, 3, k] := cy\n      v[2, 3, k] := cz\n    end if\n\n    ! normalize\n    nrm := sqrt(nmax)\n    if (nrm > 1e-30) then\n      v[0, 3, k] := v[0, 3, k] / nrm\n      v[1, 3, k] := v[1, 3, k] / nrm\n      v[2, 3, k] := v[2, 3, k] / nrm\n    else\n      ! degenerate: use canonical basis vector\n      v[0, 3, k] := 0.0\n      v[1, 3, k] := 0.0\n      v[2, 3, k] := 0.0\n      v[k, 3, k] := 1.0\n    end if\n  end for\nend";

export const alpack_dsyev = "subroutine alpack.dsyev(\n  a: array f64; w: array f64;\n  n: i32; info: array i32\n)\nvar\n  i, j, p, q, iter, maxIter: i32\n  off, thresh, app, aqq, apq: f64\n  tau, t, c, s, tmp: f64\nbegin\n  info[0] := 0\n  maxIter := 100\n\n  ! initialize w to diagonal of a\n  for i := 0, n\n    w[i] := a[i, n, i]\n  end for\n\n  for iter := 0, maxIter\n    ! compute off-diagonal norm\n    off := 0.0\n    for p := 0, n\n      for q := p + 1, n\n        off := off + a[p, n, q] * a[p, n, q]\n      end for\n    end for\n    if (off < 1e-28) then\n      call return()\n    end if\n\n    thresh := if (iter < 4) then 0.2 * off / f64(n * n) else 0.0\n\n    for p := 0, n\n      for q := p + 1, n\n        apq := a[p, n, q]\n        if (abs(apq) <= thresh) then\n          ! skip small elements in early sweeps\n        else\n          app := w[p]\n          aqq := w[q]\n          ! Jacobi rotation angle\n          tau := (aqq - app) / (2.0 * apq)\n          if (tau >= 0.0) then\n            t := 1.0 / (tau + sqrt(1.0 + tau * tau))\n          else\n            t := 0.0 - 1.0 / (0.0 - tau + sqrt(1.0 + tau * tau))\n          end if\n          c := 1.0 / sqrt(1.0 + t * t)\n          s := t * c\n\n          ! update eigenvalues\n          w[p] := app - t * apq\n          w[q] := aqq + t * apq\n          a[p, n, q] := 0.0\n\n          ! rotate rows/columns p and q\n          for i := 0, p\n            tmp := a[i, n, p]\n            a[i, n, p] := c * tmp - s * a[i, n, q]\n            a[i, n, q] := s * tmp + c * a[i, n, q]\n          end for\n          for i := p + 1, q\n            tmp := a[p, n, i]\n            a[p, n, i] := c * tmp - s * a[i, n, q]\n            a[i, n, q] := s * tmp + c * a[i, n, q]\n          end for\n          for i := q + 1, n\n            tmp := a[p, n, i]\n            a[p, n, i] := c * tmp - s * a[q, n, i]\n            a[q, n, i] := s * tmp + c * a[q, n, i]\n          end for\n        end if\n      end for\n    end for\n  end for\n  info[0] := 1\nend";

export const alpack_dsyevv = "subroutine alpack.dsyevv(\n  a: array f64; w: array f64; v: array f64;\n  n: i32; info: array i32\n)\nvar\n  i, j, p, q, iter, maxIter: i32\n  off, thresh, app, aqq, apq: f64\n  tau, t, c, s, tmp: f64\nbegin\n  info[0] := 0\n  maxIter := 100\n\n  ! initialize V = I\n  for i := 0, n\n    for j := 0, n\n      if (i == j) then\n        v[i, n, j] := 1.0\n      else\n        v[i, n, j] := 0.0\n      end if\n    end for\n  end for\n\n  ! initialize w to diagonal of a\n  for i := 0, n\n    w[i] := a[i, n, i]\n  end for\n\n  for iter := 0, maxIter\n    ! compute off-diagonal norm\n    off := 0.0\n    for p := 0, n\n      for q := p + 1, n\n        off := off + a[p, n, q] * a[p, n, q]\n      end for\n    end for\n    if (off < 1e-28) then\n      call return()\n    end if\n\n    thresh := if (iter < 4) then 0.2 * off / f64(n * n) else 0.0\n\n    for p := 0, n\n      for q := p + 1, n\n        apq := a[p, n, q]\n        if (abs(apq) <= thresh) then\n          ! skip small elements in early sweeps\n        else\n          app := w[p]\n          aqq := w[q]\n          tau := (aqq - app) / (2.0 * apq)\n          if (tau >= 0.0) then\n            t := 1.0 / (tau + sqrt(1.0 + tau * tau))\n          else\n            t := 0.0 - 1.0 / (0.0 - tau + sqrt(1.0 + tau * tau))\n          end if\n          c := 1.0 / sqrt(1.0 + t * t)\n          s := t * c\n\n          w[p] := app - t * apq\n          w[q] := aqq + t * apq\n          a[p, n, q] := 0.0\n\n          ! rotate rows/columns p and q\n          for i := 0, p\n            tmp := a[i, n, p]\n            a[i, n, p] := c * tmp - s * a[i, n, q]\n            a[i, n, q] := s * tmp + c * a[i, n, q]\n          end for\n          for i := p + 1, q\n            tmp := a[p, n, i]\n            a[p, n, i] := c * tmp - s * a[i, n, q]\n            a[i, n, q] := s * tmp + c * a[i, n, q]\n          end for\n          for i := q + 1, n\n            tmp := a[p, n, i]\n            a[p, n, i] := c * tmp - s * a[q, n, i]\n            a[q, n, i] := s * tmp + c * a[q, n, i]\n          end for\n\n          ! accumulate into eigenvector matrix V\n          for i := 0, n\n            tmp := v[i, n, p]\n            v[i, n, p] := c * tmp - s * v[i, n, q]\n            v[i, n, q] := s * tmp + c * v[i, n, q]\n          end for\n        end if\n      end for\n    end for\n  end for\n  info[0] := 1\nend";

export const sources = {
  "alas.dscal": "subroutine alas.dscal(x: array f64; n: i32; alpha: f64)\nvar i: i32\nbegin\n  for i := 0, n\n    x[i] := alpha * x[i]\n  end for\nend",
  "alas.dcopy": "subroutine alas.dcopy(x: array f64; y: array f64; n: i32)\nvar i: i32\nbegin\n  for i := 0, n\n    y[i] := x[i]\n  end for\nend",
  "alas.daxpy": "subroutine alas.daxpy(x: array f64; y: array f64; n: i32; alpha: f64)\nvar\n  i, n2: i32\n  va, vx, vy: f64x2\nbegin\n  ! scalar version (for reference):\n  !   for i := 0, n\n  !     y[i] := alpha * x[i] + y[i]\n  !   end for\n  va := f64x2.splat(alpha)\n  n2 := n / 2\n  for i := 0, n2\n    vx := v128.load(x, i)\n    vy := v128.load(y, i)\n    vy := va * vx + vy\n    call v128.store(y, i, vy)\n  end for\n  ! scalar tail for odd element\n  if (n2 * 2 < n) then\n    i := n2 * 2\n    y[i] := alpha * x[i] + y[i]\n  end if\nend",
  "alas.ddot": "function alas.ddot(x: array f64; y: array f64; n: i32): f64\nvar\n  i, n2: i32\n  vx, vy, vs: f64x2\nbegin\n  ! scalar version:\n  !   alas.ddot := 0.0\n  !   for i := 0, n\n  !     alas.ddot := alas.ddot + x[i] * y[i]\n  !   end for\n  vs := f64x2.splat(0.0)\n  n2 := n / 2\n  for i := 0, n2\n    vx := v128.load(x, i)\n    vy := v128.load(y, i)\n    vs := vs + vx * vy\n  end for\n  alas.ddot := f64x2.extract_lane(vs, 0) + f64x2.extract_lane(vs, 1)\n  ! scalar tail\n  if (n2 * 2 < n) then\n    i := n2 * 2\n    alas.ddot := alas.ddot + x[i] * y[i]\n  end if\nend",
  "alas.dnrm2": "function alas.dnrm2(x: array f64; n: i32): f64\nvar\n  i, n2: i32\n  vx, vs: f64x2\nbegin\n  vs := f64x2.splat(0.0)\n  n2 := n / 2\n  for i := 0, n2\n    vx := v128.load(x, i)\n    vs := vs + vx * vx\n  end for\n  alas.dnrm2 := f64x2.extract_lane(vs, 0) + f64x2.extract_lane(vs, 1)\n  if (n2 * 2 < n) then\n    i := n2 * 2\n    alas.dnrm2 := alas.dnrm2 + x[i] * x[i]\n  end if\n  alas.dnrm2 := sqrt(alas.dnrm2)\nend",
  "alas.dswap": "subroutine alas.dswap(x: array f64; y: array f64; n: i32)\nvar i: i32; t: f64\nbegin\n  for i := 0, n\n    t := x[i]\n    x[i] := y[i]\n    y[i] := t\n  end for\nend",
  "alas.dasum": "function alas.dasum(x: array f64; n: i32): f64\nvar i: i32\nbegin\n  alas.dasum := 0.0\n  for i := 0, n\n    alas.dasum := alas.dasum + abs(x[i])\n  end for\nend",
  "alas.drot": "subroutine alas.drot(x: array f64; y: array f64; n: i32; c, s: f64)\nvar i: i32; t: f64\nbegin\n  for i := 0, n\n    t := c * x[i] + s * y[i]\n    y[i] := c * y[i] - s * x[i]\n    x[i] := t\n  end for\nend",
  "alas.drotg": "function alas.drotg(a, b: f64; cs: array f64): f64\nvar r, z: f64\nbegin\n  r := sqrt(a * a + b * b)\n  if (r == 0.0) then\n    cs[0] := 1.0\n    cs[1] := 0.0\n    alas.drotg := 0.0\n  else\n    cs[0] := a / r\n    cs[1] := b / r\n    alas.drotg := r\n  end if\nend",
  "alas.idamax": "function alas.idamax(x: array f64; n: i32): i32\nvar i: i32; mx: f64; v: f64\nbegin\n  alas.idamax := 0\n  mx := abs(x[0])\n  for i := 1, n\n    v := abs(x[i])\n    if (v > mx) then\n      mx := v\n      alas.idamax := i\n    end if\n  end for\nend",
  "alas.dgemv": "subroutine alas.dgemv(\n  a: array f64; x: array f64; y: array f64;\n  m, n: i32; alpha, beta: f64\n)\nvar i, j: i32; s: f64\nbegin\n  for i := 0, m\n    s := 0.0\n    for j := 0, n\n      s := s + a[i, n, j] * x[j]\n    end for\n    y[i] := alpha * s + beta * y[i]\n  end for\nend",
  "alas.dtrsv": "subroutine alas.dtrsv(\n  a: array f64; x: array f64;\n  n, uplo, trans: i32\n)\nvar i, j: i32; s: f64\nbegin\n  if (uplo == 0 and trans == 0) then\n    ! lower, no transpose: forward substitution\n    for i := 0, n\n      s := x[i]\n      for j := 0, i\n        s := s - a[i, n, j] * x[j]\n      end for\n      x[i] := s / a[i, n, i]\n    end for\n  else if (uplo == 0 and trans == 1) then\n    ! lower, transpose (= upper): back substitution\n    for i := n - 1, -1, -1\n      s := x[i]\n      for j := i + 1, n\n        s := s - a[j, n, i] * x[j]\n      end for\n      x[i] := s / a[i, n, i]\n    end for\n  else if (uplo == 1 and trans == 0) then\n    ! upper, no transpose: back substitution\n    for i := n - 1, -1, -1\n      s := x[i]\n      for j := i + 1, n\n        s := s - a[i, n, j] * x[j]\n      end for\n      x[i] := s / a[i, n, i]\n    end for\n  else\n    ! upper, transpose (= lower): forward substitution\n    for i := 0, n\n      s := x[i]\n      for j := 0, i\n        s := s - a[j, n, i] * x[j]\n      end for\n      x[i] := s / a[i, n, i]\n    end for\n  end if\nend",
  "alas.dger": "subroutine alas.dger(\n  a: array f64; x: array f64; y: array f64;\n  m, n: i32; alpha: f64\n)\nvar i, j: i32; t: f64\nbegin\n  for i := 0, m\n    t := alpha * x[i]\n    for j := 0, n\n      a[i, n, j] := a[i, n, j] + t * y[j]\n    end for\n  end for\nend",
  "alas.dsymv": "subroutine alas.dsymv(\n  a: array f64; x: array f64; y: array f64;\n  n: i32; alpha, beta: f64\n)\nvar i, j: i32; s, t: f64\nbegin\n  ! scale y by beta\n  for i := 0, n\n    y[i] := beta * y[i]\n  end for\n  ! accumulate: diagonal + off-diagonal (symmetric)\n  for i := 0, n\n    s := 0.0\n    for j := 0, i\n      t := alpha * a[i, n, j]\n      s := s + t * x[j]\n      y[j] := y[j] + t * x[i]\n    end for\n    y[i] := y[i] + s + alpha * a[i, n, i] * x[i]\n  end for\nend",
  "alas.dsyr": "subroutine alas.dsyr(\n  a: array f64; x: array f64;\n  n: i32; alpha: f64\n)\nvar i, j: i32; t: f64\nbegin\n  for i := 0, n\n    t := alpha * x[i]\n    for j := 0, i + 1\n      a[i, n, j] := a[i, n, j] + t * x[j]\n    end for\n  end for\nend",
  "alas.dsyr2": "subroutine alas.dsyr2(\n  a: array f64; x: array f64; y: array f64;\n  n: i32; alpha: f64\n)\nvar i, j: i32; tx, ty: f64\nbegin\n  for i := 0, n\n    tx := alpha * x[i]\n    ty := alpha * y[i]\n    for j := 0, i + 1\n      a[i, n, j] := a[i, n, j] + tx * y[j] + ty * x[j]\n    end for\n  end for\nend",
  "alas.dtrmv": "subroutine alas.dtrmv(\n  a: array f64; x: array f64;\n  n, uplo, trans, diag: i32\n)\nvar i, j: i32; s: f64\nbegin\n  if (uplo == 1 and trans == 0) then\n    ! upper, no transpose: forward\n    for i := 0, n\n      s := 0.0\n      if (diag == 1) then\n        s := x[i]\n      else\n        s := a[i, n, i] * x[i]\n      end if\n      for j := i + 1, n\n        s := s + a[i, n, j] * x[j]\n      end for\n      x[i] := s\n    end for\n  else if (uplo == 0 and trans == 0) then\n    ! lower, no transpose: backward\n    for i := n - 1, -1, -1\n      s := 0.0\n      for j := 0, i\n        s := s + a[i, n, j] * x[j]\n      end for\n      if (diag == 1) then\n        s := s + x[i]\n      else\n        s := s + a[i, n, i] * x[i]\n      end if\n      x[i] := s\n    end for\n  else if (uplo == 1 and trans == 1) then\n    ! upper, transpose (= lower): backward\n    for i := n - 1, -1, -1\n      s := 0.0\n      for j := 0, i\n        s := s + a[j, n, i] * x[j]\n      end for\n      if (diag == 1) then\n        s := s + x[i]\n      else\n        s := s + a[i, n, i] * x[i]\n      end if\n      x[i] := s\n    end for\n  else\n    ! lower, transpose (= upper): forward\n    for i := 0, n\n      s := 0.0\n      if (diag == 1) then\n        s := x[i]\n      else\n        s := a[i, n, i] * x[i]\n      end if\n      for j := i + 1, n\n        s := s + a[j, n, i] * x[j]\n      end for\n      x[i] := s\n    end for\n  end if\nend",
  "alas.dgemm": "subroutine alas.dgemm(\n  a: array f64; b: array f64; c: array f64;\n  m, n, k: i32; alpha, beta: f64\n)\nvar\n  i, j, p: i32\n  s: f64\nbegin\n  for i := 0, m\n    for j := 0, n\n      s := 0.0\n      for p := 0, k\n        s := s + a[i, k, p] * b[p, n, j]\n      end for\n      c[i, n, j] := alpha * s + beta * c[i, n, j]\n    end for\n  end for\nend",
  "alpack.dpotrf": "subroutine alpack.dpotrf(a: array f64; n: i32; info: array i32)\nvar i, j, k: i32; s: f64\nbegin\n  info[0] := 0\n  for j := 0, n\n    s := a[j, n, j]\n    for k := 0, j\n      s := s - a[j, n, k] * a[j, n, k]\n    end for\n    if (s <= 0.0) then\n      info[0] := j + 1\n      call return()\n    end if\n    a[j, n, j] := sqrt(s)\n    for i := j + 1, n\n      s := a[i, n, j]\n      for k := 0, j\n        s := s - a[i, n, k] * a[j, n, k]\n      end for\n      a[i, n, j] := s / a[j, n, j]\n    end for\n  end for\nend",
  "alpack.dpotrs": "subroutine alpack.dpotrs(\n  l: array f64; b: array f64;\n  n, nrhs: i32\n)\nvar rhs, i, j: i32; s: f64\nbegin\n  for rhs := 0, nrhs\n    ! forward substitution: L * y = b\n    for i := 0, n\n      s := b[i, nrhs, rhs]\n      for j := 0, i\n        s := s - l[i, n, j] * b[j, nrhs, rhs]\n      end for\n      b[i, nrhs, rhs] := s / l[i, n, i]\n    end for\n    ! back substitution: L^T * x = y\n    for i := n - 1, -1, -1\n      s := b[i, nrhs, rhs]\n      for j := i + 1, n\n        s := s - l[j, n, i] * b[j, nrhs, rhs]\n      end for\n      b[i, nrhs, rhs] := s / l[i, n, i]\n    end for\n  end for\nend",
  "alpack.dgetrf": "subroutine alpack.dgetrf(\n  a: array f64; n: i32;\n  ipiv: array i32; info: array i32\n)\nvar i, j, k, pivot: i32; t, inv: f64\nbegin\n  info[0] := 0\n  for k := 0, n\n    ! find pivot in column k from row k..n-1\n    ! use inline search (idamax operates on contiguous vector)\n    pivot := k\n    t := abs(a[k, n, k])\n    for i := k + 1, n\n      if (abs(a[i, n, k]) > t) then\n        pivot := i\n        t := abs(a[i, n, k])\n      end if\n    end for\n    ipiv[k] := pivot\n\n    ! swap rows k and pivot\n    if (pivot /= k) then\n      for j := 0, n\n        t := a[k, n, j]\n        a[k, n, j] := a[pivot, n, j]\n        a[pivot, n, j] := t\n      end for\n    end if\n\n    if (a[k, n, k] == 0.0) then\n      info[0] := k + 1\n      call return()\n    end if\n\n    ! eliminate below diagonal\n    inv := 1.0 / a[k, n, k]\n    for i := k + 1, n\n      a[i, n, k] := a[i, n, k] * inv\n      for j := k + 1, n\n        a[i, n, j] := a[i, n, j] - a[i, n, k] * a[k, n, j]\n      end for\n    end for\n  end for\nend",
  "alpack.dgetrs": "subroutine alpack.dgetrs(\n  lu: array f64; ipiv: array i32;\n  b: array f64; n, nrhs: i32\n)\nvar rhs, i, j, p: i32; s, t: f64\nbegin\n  for rhs := 0, nrhs\n    ! apply row permutation\n    for i := 0, n\n      p := ipiv[i]\n      if (p /= i) then\n        t := b[i, nrhs, rhs]\n        b[i, nrhs, rhs] := b[p, nrhs, rhs]\n        b[p, nrhs, rhs] := t\n      end if\n    end for\n    ! forward substitution (L with unit diagonal)\n    for i := 1, n\n      s := b[i, nrhs, rhs]\n      for j := 0, i\n        s := s - lu[i, n, j] * b[j, nrhs, rhs]\n      end for\n      b[i, nrhs, rhs] := s\n    end for\n    ! back substitution (U)\n    for i := n - 1, -1, -1\n      s := b[i, nrhs, rhs]\n      for j := i + 1, n\n        s := s - lu[i, n, j] * b[j, nrhs, rhs]\n      end for\n      b[i, nrhs, rhs] := s / lu[i, n, i]\n    end for\n  end for\nend",
  "alpack.dgesv": "subroutine alpack.dgesv(\n  a: array f64; b: array f64;\n  n, nrhs: i32;\n  ipiv: array i32; info: array i32\n)\nbegin\n  call alpack.dgetrf(a, n, ipiv, info)\n  if (info[0] /= 0) then\n    call return()\n  end if\n  call alpack.dgetrs(a, ipiv, b, n, nrhs)\nend",
  "alpack.dtrtri": "subroutine alpack.dtrtri(a: array f64; n: i32; info: array i32)\nvar i, j, k: i32; s: f64\nbegin\n  info[0] := 0\n  for j := 0, n\n    if (a[j, n, j] == 0.0) then\n      info[0] := j + 1\n      call return()\n    end if\n    a[j, n, j] := 1.0 / a[j, n, j]\n    for i := j + 1, n\n      s := 0.0\n      for k := j, i\n        s := s - a[i, n, k] * a[k, n, j]\n      end for\n      a[i, n, j] := s / a[i, n, i]\n    end for\n  end for\nend",
  "alpack.dsyev3": "subroutine alpack.dsyev3(a: array f64; w: array f64)\nvar\n  a00, a01, a02, a11, a12, a22: f64\n  p1, q, p2, p, b00, b11, b22, det_b, half_det: f64\n  phi, r, e1, e2, e3: f64\n  m: f64\n  pi: f64\nbegin\n  pi := 3.14159265358979323846\n\n  a00 := a[0, 3, 0]\n  a01 := a[0, 3, 1]\n  a02 := a[0, 3, 2]\n  a11 := a[1, 3, 1]\n  a12 := a[1, 3, 2]\n  a22 := a[2, 3, 2]\n\n  ! trace / 3\n  m := (a00 + a11 + a22) / 3.0\n\n  ! sum of squares of off-diagonal elements\n  p1 := a01 * a01 + a02 * a02 + a12 * a12\n\n  if (p1 <= 1e-30) then\n    ! diagonal matrix — eigenvalues are the diagonal entries, sort descending\n    e1 := a00\n    e2 := a11\n    e3 := a22\n    ! sort 3 values descending (bubble sort)\n    if (e2 > e1) then\n      r := e1\n      e1 := e2\n      e2 := r\n    end if\n    if (e3 > e2) then\n      r := e2\n      e2 := e3\n      e3 := r\n    end if\n    if (e2 > e1) then\n      r := e1\n      e1 := e2\n      e2 := r\n    end if\n    w[0] := e1\n    w[1] := e2\n    w[2] := e3\n    call return()\n  end if\n\n  q := m\n  p2 := (a00 - q) * (a00 - q) + (a11 - q) * (a11 - q) + (a22 - q) * (a22 - q) + 2.0 * p1\n  p := sqrt(p2 / 6.0)\n\n  ! B = (A - q*I) / p  — only need determinant\n  b00 := (a00 - q) / p\n  b11 := (a11 - q) / p\n  b22 := (a22 - q) / p\n  ! det(B) for symmetric 3x3\n  det_b := b00 * (b11 * b22 - (a12 / p) * (a12 / p))\n         - (a01 / p) * ((a01 / p) * b22 - (a12 / p) * (a02 / p))\n         + (a02 / p) * ((a01 / p) * (a12 / p) - b11 * (a02 / p))\n  half_det := det_b / 2.0\n\n  ! clamp to [-1, 1] for acos\n  if (half_det <= -1.0) then\n    phi := pi / 3.0\n  else if (half_det >= 1.0) then\n    phi := 0.0\n  else\n    phi := atan2(sqrt(1.0 - half_det * half_det), half_det) / 3.0\n  end if\n\n  ! eigenvalues in descending order\n  e1 := q + 2.0 * p * cos(phi)\n  e3 := q + 2.0 * p * cos(phi + 2.0 * pi / 3.0)\n  e2 := 3.0 * q - e1 - e3\n\n  w[0] := e1\n  w[1] := e2\n  w[2] := e3\nend",
  "alpack.dsyev3v": "subroutine alpack.dsyev3v(a: array f64; w: array f64; v: array f64)\nvar\n  a00, a01, a02, a11, a12, a22: f64\n  p1, q, p2, p, b00, b11, b22, det_b, half_det: f64\n  phi, r, e1, e2, e3: f64\n  m: f64\n  pi: f64\n  ! eigenvector computation\n  k, best: i32\n  r0x, r0y, r0z, r1x, r1y, r1z, r2x, r2y, r2z: f64\n  cx, cy, cz: f64\n  n01, n12, n02, nmax, nrm: f64\nbegin\n  pi := 3.14159265358979323846\n\n  a00 := a[0, 3, 0]\n  a01 := a[0, 3, 1]\n  a02 := a[0, 3, 2]\n  a11 := a[1, 3, 1]\n  a12 := a[1, 3, 2]\n  a22 := a[2, 3, 2]\n\n  ! ── compute eigenvalues (same as dsyev3) ──\n  m := (a00 + a11 + a22) / 3.0\n  p1 := a01 * a01 + a02 * a02 + a12 * a12\n\n  if (p1 <= 1e-30) then\n    ! diagonal matrix\n    e1 := a00\n    e2 := a11\n    e3 := a22\n    if (e2 > e1) then\n      r := e1\n      e1 := e2\n      e2 := r\n    end if\n    if (e3 > e2) then\n      r := e2\n      e2 := e3\n      e3 := r\n    end if\n    if (e2 > e1) then\n      r := e1\n      e1 := e2\n      e2 := r\n    end if\n    w[0] := e1\n    w[1] := e2\n    w[2] := e3\n    ! eigenvectors for diagonal: identity (re-ordered to match eigenvalue order)\n    ! Find which diagonal entry maps to which eigenvalue\n    ! For simplicity with the sorted eigenvalues, compute eigenvectors below\n  else\n    q := m\n    p2 := (a00 - q) * (a00 - q) + (a11 - q) * (a11 - q) + (a22 - q) * (a22 - q) + 2.0 * p1\n    p := sqrt(p2 / 6.0)\n\n    b00 := (a00 - q) / p\n    b11 := (a11 - q) / p\n    b22 := (a22 - q) / p\n    det_b := b00 * (b11 * b22 - (a12 / p) * (a12 / p))\n           - (a01 / p) * ((a01 / p) * b22 - (a12 / p) * (a02 / p))\n           + (a02 / p) * ((a01 / p) * (a12 / p) - b11 * (a02 / p))\n    half_det := det_b / 2.0\n\n    if (half_det <= -1.0) then\n      phi := pi / 3.0\n    else if (half_det >= 1.0) then\n      phi := 0.0\n    else\n      phi := atan2(sqrt(1.0 - half_det * half_det), half_det) / 3.0\n    end if\n\n    e1 := q + 2.0 * p * cos(phi)\n    e3 := q + 2.0 * p * cos(phi + 2.0 * pi / 3.0)\n    e2 := 3.0 * q - e1 - e3\n\n    w[0] := e1\n    w[1] := e2\n    w[2] := e3\n  end if\n\n  ! ── compute eigenvectors via cross-product null-space ──\n  ! For each eigenvalue w[k], form B = A - w[k]*I, take cross product\n  ! of two rows with largest cross-product norm\n  for k := 0, 3\n    r0x := a00 - w[k]\n    r0y := a01\n    r0z := a02\n    r1x := a01\n    r1y := a11 - w[k]\n    r1z := a12\n    r2x := a02\n    r2y := a12\n    r2z := a22 - w[k]\n\n    ! cross products of row pairs\n    ! r0 x r1\n    cx := r0y * r1z - r0z * r1y\n    cy := r0z * r1x - r0x * r1z\n    cz := r0x * r1y - r0y * r1x\n    n01 := cx * cx + cy * cy + cz * cz\n\n    nmax := n01\n    ! store best cross product\n    v[0, 3, k] := cx\n    v[1, 3, k] := cy\n    v[2, 3, k] := cz\n\n    ! r1 x r2\n    cx := r1y * r2z - r1z * r2y\n    cy := r1z * r2x - r1x * r2z\n    cz := r1x * r2y - r1y * r2x\n    n12 := cx * cx + cy * cy + cz * cz\n    if (n12 > nmax) then\n      nmax := n12\n      v[0, 3, k] := cx\n      v[1, 3, k] := cy\n      v[2, 3, k] := cz\n    end if\n\n    ! r0 x r2\n    cx := r0y * r2z - r0z * r2y\n    cy := r0z * r2x - r0x * r2z\n    cz := r0x * r2y - r0y * r2x\n    n02 := cx * cx + cy * cy + cz * cz\n    if (n02 > nmax) then\n      nmax := n02\n      v[0, 3, k] := cx\n      v[1, 3, k] := cy\n      v[2, 3, k] := cz\n    end if\n\n    ! normalize\n    nrm := sqrt(nmax)\n    if (nrm > 1e-30) then\n      v[0, 3, k] := v[0, 3, k] / nrm\n      v[1, 3, k] := v[1, 3, k] / nrm\n      v[2, 3, k] := v[2, 3, k] / nrm\n    else\n      ! degenerate: use canonical basis vector\n      v[0, 3, k] := 0.0\n      v[1, 3, k] := 0.0\n      v[2, 3, k] := 0.0\n      v[k, 3, k] := 1.0\n    end if\n  end for\nend",
  "alpack.dsyev": "subroutine alpack.dsyev(\n  a: array f64; w: array f64;\n  n: i32; info: array i32\n)\nvar\n  i, j, p, q, iter, maxIter: i32\n  off, thresh, app, aqq, apq: f64\n  tau, t, c, s, tmp: f64\nbegin\n  info[0] := 0\n  maxIter := 100\n\n  ! initialize w to diagonal of a\n  for i := 0, n\n    w[i] := a[i, n, i]\n  end for\n\n  for iter := 0, maxIter\n    ! compute off-diagonal norm\n    off := 0.0\n    for p := 0, n\n      for q := p + 1, n\n        off := off + a[p, n, q] * a[p, n, q]\n      end for\n    end for\n    if (off < 1e-28) then\n      call return()\n    end if\n\n    thresh := if (iter < 4) then 0.2 * off / f64(n * n) else 0.0\n\n    for p := 0, n\n      for q := p + 1, n\n        apq := a[p, n, q]\n        if (abs(apq) <= thresh) then\n          ! skip small elements in early sweeps\n        else\n          app := w[p]\n          aqq := w[q]\n          ! Jacobi rotation angle\n          tau := (aqq - app) / (2.0 * apq)\n          if (tau >= 0.0) then\n            t := 1.0 / (tau + sqrt(1.0 + tau * tau))\n          else\n            t := 0.0 - 1.0 / (0.0 - tau + sqrt(1.0 + tau * tau))\n          end if\n          c := 1.0 / sqrt(1.0 + t * t)\n          s := t * c\n\n          ! update eigenvalues\n          w[p] := app - t * apq\n          w[q] := aqq + t * apq\n          a[p, n, q] := 0.0\n\n          ! rotate rows/columns p and q\n          for i := 0, p\n            tmp := a[i, n, p]\n            a[i, n, p] := c * tmp - s * a[i, n, q]\n            a[i, n, q] := s * tmp + c * a[i, n, q]\n          end for\n          for i := p + 1, q\n            tmp := a[p, n, i]\n            a[p, n, i] := c * tmp - s * a[i, n, q]\n            a[i, n, q] := s * tmp + c * a[i, n, q]\n          end for\n          for i := q + 1, n\n            tmp := a[p, n, i]\n            a[p, n, i] := c * tmp - s * a[q, n, i]\n            a[q, n, i] := s * tmp + c * a[q, n, i]\n          end for\n        end if\n      end for\n    end for\n  end for\n  info[0] := 1\nend",
  "alpack.dsyevv": "subroutine alpack.dsyevv(\n  a: array f64; w: array f64; v: array f64;\n  n: i32; info: array i32\n)\nvar\n  i, j, p, q, iter, maxIter: i32\n  off, thresh, app, aqq, apq: f64\n  tau, t, c, s, tmp: f64\nbegin\n  info[0] := 0\n  maxIter := 100\n\n  ! initialize V = I\n  for i := 0, n\n    for j := 0, n\n      if (i == j) then\n        v[i, n, j] := 1.0\n      else\n        v[i, n, j] := 0.0\n      end if\n    end for\n  end for\n\n  ! initialize w to diagonal of a\n  for i := 0, n\n    w[i] := a[i, n, i]\n  end for\n\n  for iter := 0, maxIter\n    ! compute off-diagonal norm\n    off := 0.0\n    for p := 0, n\n      for q := p + 1, n\n        off := off + a[p, n, q] * a[p, n, q]\n      end for\n    end for\n    if (off < 1e-28) then\n      call return()\n    end if\n\n    thresh := if (iter < 4) then 0.2 * off / f64(n * n) else 0.0\n\n    for p := 0, n\n      for q := p + 1, n\n        apq := a[p, n, q]\n        if (abs(apq) <= thresh) then\n          ! skip small elements in early sweeps\n        else\n          app := w[p]\n          aqq := w[q]\n          tau := (aqq - app) / (2.0 * apq)\n          if (tau >= 0.0) then\n            t := 1.0 / (tau + sqrt(1.0 + tau * tau))\n          else\n            t := 0.0 - 1.0 / (0.0 - tau + sqrt(1.0 + tau * tau))\n          end if\n          c := 1.0 / sqrt(1.0 + t * t)\n          s := t * c\n\n          w[p] := app - t * apq\n          w[q] := aqq + t * apq\n          a[p, n, q] := 0.0\n\n          ! rotate rows/columns p and q\n          for i := 0, p\n            tmp := a[i, n, p]\n            a[i, n, p] := c * tmp - s * a[i, n, q]\n            a[i, n, q] := s * tmp + c * a[i, n, q]\n          end for\n          for i := p + 1, q\n            tmp := a[p, n, i]\n            a[p, n, i] := c * tmp - s * a[i, n, q]\n            a[i, n, q] := s * tmp + c * a[i, n, q]\n          end for\n          for i := q + 1, n\n            tmp := a[p, n, i]\n            a[p, n, i] := c * tmp - s * a[q, n, i]\n            a[q, n, i] := s * tmp + c * a[q, n, i]\n          end for\n\n          ! accumulate into eigenvector matrix V\n          for i := 0, n\n            tmp := v[i, n, p]\n            v[i, n, p] := c * tmp - s * v[i, n, q]\n            v[i, n, q] := s * tmp + c * v[i, n, q]\n          end for\n        end if\n      end for\n    end for\n  end for\n  info[0] := 1\nend",
};

export const deps = {
  "alas.dscal": [],
  "alas.dcopy": [],
  "alas.daxpy": [],
  "alas.ddot": [],
  "alas.dnrm2": [],
  "alas.dswap": [],
  "alas.dasum": [],
  "alas.drot": [],
  "alas.drotg": [],
  "alas.idamax": [],
  "alas.dgemv": [],
  "alas.dtrsv": [],
  "alas.dger": [],
  "alas.dsymv": [],
  "alas.dsyr": [],
  "alas.dsyr2": [],
  "alas.dtrmv": [],
  "alas.dgemm": [],
  "alpack.dpotrf": [],
  "alpack.dpotrs": [],
  "alpack.dgetrf": [],
  "alpack.dgetrs": [],
  "alpack.dgesv": ["alpack.dgetrf","alpack.dgetrs"],
  "alpack.dtrtri": [],
  "alpack.dsyev3": [],
  "alpack.dsyev3v": [],
  "alpack.dsyev": [],
  "alpack.dsyevv": [],
};
