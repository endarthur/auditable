#!/usr/bin/env node
// atrac — atra compiler CLI + library
// Compiles .atra source to Wasm (raw bytes), JS bundles, or source distributions.

import { atra } from './index.js';
import fs from 'node:fs';
import path from 'node:path';

// ── Library API ─────────────────────────────────────────────────────

/**
 * Compile atra source to raw Wasm bytes.
 * @param {string} source — atra source code
 * @returns {Uint8Array}
 */
export function compile(source) {
  return atra.compile(source);
}

/**
 * Extract routines and dependency map from atra source.
 * @param {string} source — atra source code
 * @returns {{ sources: Object<string,string>, deps: Object<string,string[]>, all: string }}
 */
export function buildSrc(source) {
  const lines = source.split('\n');
  const routines = {};
  let current = null, name = null;

  for (const line of lines) {
    const m = line.match(/^\s*(?:subroutine|function)\s+([\w.]+)\s*\(/);
    if (m) {
      name = m[1];
      current = [line];
    } else if (current) {
      current.push(line);
      if (/^\s*end\s*$/.test(line)) {
        routines[name] = current.join('\n');
        current = null;
        name = null;
      }
    }
  }

  // Build dependency map: for each routine, find calls to other routines
  const routineNames = Object.keys(routines);
  const deps = {};
  for (const [rname, src] of Object.entries(routines)) {
    deps[rname] = routineNames.filter(other =>
      other !== rname && new RegExp(`\\b${other.replace(/\./g, '\\.')}\\s*\\(`).test(src)
    );
  }

  return { sources: routines, deps, all: source };
}

/**
 * Generate .src.js file content from buildSrc() output.
 * @param {{ sources: Object, deps: Object, all: string }} lib
 * @returns {string}
 */
export function formatSrcJs(lib) {
  const routineNames = Object.keys(lib.sources);
  let out = '// Generated by atrac — do not edit\n\n';
  out += `export const all = ${JSON.stringify(lib.all)};\n\n`;

  // Individual routine exports (flat names: alas.ddot → alas_ddot)
  for (const [name, src] of Object.entries(lib.sources)) {
    const jsName = name.replace(/\./g, '_');
    out += `export const ${jsName} = ${JSON.stringify(src)};\n\n`;
  }

  // Library object for std.include(): { sources, deps }
  out += `export const sources = {\n`;
  for (const rname of routineNames) {
    out += `  ${JSON.stringify(rname)}: ${JSON.stringify(lib.sources[rname])},\n`;
  }
  out += `};\n\n`;
  out += `export const deps = {\n`;
  for (const rname of routineNames) {
    out += `  ${JSON.stringify(rname)}: ${JSON.stringify(lib.deps[rname])},\n`;
  }
  out += `};\n`;
  return out;
}

const RUNTIME_TEMPLATE = `
const _math = {
  sin: Math.sin, cos: Math.cos, ln: Math.log,
  exp: Math.exp, pow: Math.pow, atan2: Math.atan2,
};

export function instantiate(imports = {}) {
  const importObj = { math: _math, host: {} };
  for (const [k, v] of Object.entries(imports)) {
    if (k === 'memory' || k === '__memory') {
      if (!importObj.env) importObj.env = {};
      importObj.env.memory = v;
    } else if (typeof v === 'function') {
      importObj.host[k] = v;
    } else if (v && typeof v === 'object') {
      for (const [k2, fn] of Object.entries(v)) {
        if (typeof fn === 'function') importObj.host[k + '.' + k2] = fn;
      }
    }
  }
  const mod = new WebAssembly.Module(_bytes);
  const inst = new WebAssembly.Instance(mod, importObj);
  const exports = {};
  for (const [key, val] of Object.entries(inst.exports)) {
    if (!key.includes('.')) { exports[key] = val; continue; }
    const parts = key.split('.');
    let obj = exports;
    for (let i = 0; i < parts.length - 1; i++) {
      if (!obj[parts[i]] || typeof obj[parts[i]] !== 'object') obj[parts[i]] = {};
      obj = obj[parts[i]];
    }
    obj[parts[parts.length - 1]] = val;
  }
  return exports;
}
`;

/**
 * Compile atra source and wrap in a standalone JS module with embedded Wasm.
 * @param {string} source — atra source code
 * @param {{ name?: string }} [opts]
 * @returns {string} — JS module source
 */
export function bundle(source, opts = {}) {
  const bytes = atra.compile(source);
  const arr = Array.from(bytes);
  const name = opts.name || 'atra module';
  return `// ${name} — compiled by atrac\n`
    + `const _bytes = new Uint8Array([${arr.join(',')}]);\n`
    + RUNTIME_TEMPLATE;
}

// ── CLI ─────────────────────────────────────────────────────────────

function usage() {
  console.log(`atrac — atra compiler

Usage:
  atrac <file.atra> [...]            Compile to JS bundle (embedded Wasm)
  atrac --src <file.atra> [...]      Generate source distribution (.src.js)
  atrac -o <output> <file.atra>      Explicit output path (.js, .wasm, .src.js)

Options:
  --src         Source distribution mode
  -o <path>     Output file path (extension determines format for raw .wasm)
  -h, --help    Show this help`);
}

function main(args) {
  let outPath = null, srcMode = false;
  const inputs = [];

  for (let i = 0; i < args.length; i++) {
    if (args[i] === '-o' && i + 1 < args.length) outPath = args[++i];
    else if (args[i] === '--src') srcMode = true;
    else if (args[i] === '--help' || args[i] === '-h') { usage(); process.exit(0); }
    else inputs.push(args[i]);
  }

  if (!inputs.length) { usage(); process.exit(1); }

  const source = inputs.map(f => fs.readFileSync(f, 'utf8')).join('\n\n');
  const baseName = path.basename(inputs[0], '.atra');

  if (srcMode) {
    const lib = buildSrc(source);
    const out = formatSrcJs(lib);
    const dest = outPath || baseName + '.src.js';
    fs.writeFileSync(dest, out);
    console.log(`${dest} (${(out.length / 1024).toFixed(1)} KB)`);
  } else if (outPath && outPath.endsWith('.wasm')) {
    const bytes = compile(source);
    fs.writeFileSync(outPath, bytes);
    console.log(`${outPath} (${bytes.length} bytes)`);
  } else {
    const out = bundle(source, { name: baseName });
    const dest = outPath || baseName + '.js';
    fs.writeFileSync(dest, out);
    console.log(`${dest} (${(out.length / 1024).toFixed(1)} KB)`);
  }
}

// ── Dual-use detection ──────────────────────────────────────────────

const __filename = new URL(import.meta.url).pathname;
// On Windows, pathname starts with /C:/... — normalize for comparison
const argv1 = process.argv[1] ? path.resolve(process.argv[1]) : '';
const self = path.resolve(__filename.replace(/^\/([A-Z]:)/, '$1'));
if (argv1 === self) main(process.argv.slice(2));
