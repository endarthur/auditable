#!/usr/bin/env node
// atrac — atra compiler CLI + library
// Compiles .atra source to Wasm (raw bytes), JS bundles, or source distributions.

import { atra } from './index.js';
import fs from 'node:fs';
import path from 'node:path';

// ── Library API ─────────────────────────────────────────────────────

/**
 * Compile atra source to raw Wasm bytes.
 * @param {string} source — atra source code
 * @returns {Uint8Array}
 */
export function compile(source) {
  return atra.compile(source);
}

/**
 * Extract routines and dependency map from atra source.
 * @param {string} source — atra source code
 * @returns {{ sources: Object<string,string>, deps: Object<string,string[]>, all: string }}
 */
export function buildSrc(source) {
  const lines = source.split('\n');
  const routines = {};
  const layoutBlocks = {};
  let current = null, name = null, kind = null;

  for (const line of lines) {
    const lm = line.match(/^\s*layout\s+(?:packed\s+)?(\w+)\s*$/);
    if (lm && !current) {
      name = lm[1];
      current = [line];
      kind = 'layout';
      continue;
    }
    const m = line.match(/^\s*(?:subroutine|function)\s+([\w.]+)\s*\(/);
    if (m && !current) {
      name = m[1];
      current = [line];
      kind = 'routine';
      continue;
    }
    if (current) {
      current.push(line);
      const isEnd = kind === 'layout'
        ? /^\s*end\s*(?:layout)?\s*$/.test(line)
        : /^\s*end\s*$/.test(line);
      if (isEnd) {
        if (kind === 'layout') layoutBlocks[name] = current.join('\n');
        else routines[name] = current.join('\n');
        current = null;
        name = null;
        kind = null;
      }
    }
  }

  // Build dependency map: for each routine, find calls to other routines
  const routineNames = Object.keys(routines);
  const deps = {};
  for (const [rname, src] of Object.entries(routines)) {
    deps[rname] = routineNames.filter(other =>
      other !== rname && new RegExp(`\\b${other.replace(/\./g, '\\.')}\\s*\\(`).test(src)
    );
  }

  const result = { sources: routines, deps, all: source };
  if (Object.keys(layoutBlocks).length > 0) result.layouts = layoutBlocks;
  return result;
}

/**
 * Generate .src.js file content from buildSrc() output.
 * @param {{ sources: Object, deps: Object, all: string }} lib
 * @returns {string}
 */
export function formatSrcJs(lib) {
  const routineNames = Object.keys(lib.sources);
  let out = '// Generated by atrac — do not edit\n\n';
  out += `export const all = ${JSON.stringify(lib.all)};\n\n`;

  // Individual routine exports (flat names: alas.ddot → alas_ddot)
  for (const [name, src] of Object.entries(lib.sources)) {
    const jsName = name.replace(/\./g, '_');
    out += `export const ${jsName} = ${JSON.stringify(src)};\n\n`;
  }

  // Library object for std.include(): { sources, deps }
  out += `export const sources = {\n`;
  for (const rname of routineNames) {
    out += `  ${JSON.stringify(rname)}: ${JSON.stringify(lib.sources[rname])},\n`;
  }
  out += `};\n\n`;
  out += `export const deps = {\n`;
  for (const rname of routineNames) {
    out += `  ${JSON.stringify(rname)}: ${JSON.stringify(lib.deps[rname])},\n`;
  }
  out += `};\n`;

  if (lib.layouts && Object.keys(lib.layouts).length > 0) {
    out += `\nexport const layouts = {\n`;
    for (const [lname, lsrc] of Object.entries(lib.layouts)) {
      out += `  ${JSON.stringify(lname)}: ${JSON.stringify(lsrc)},\n`;
    }
    out += `};\n`;
  }

  return out;
}

const RUNTIME_TEMPLATE = `
const _math = {
  sin: Math.sin, cos: Math.cos, ln: Math.log,
  exp: Math.exp, pow: Math.pow, atan2: Math.atan2,
};

export function instantiate(imports = {}) {
  const importObj = { math: _math, host: {} };
  let mem = null;
  for (const [k, v] of Object.entries(imports)) {
    if (k === 'memory' || k === '__memory') {
      mem = v;
    } else if (typeof v === 'function') {
      importObj.host[k] = v;
    } else if (v && typeof v === 'object') {
      for (const [k2, fn] of Object.entries(v)) {
        if (typeof fn === 'function') importObj.host[k + '.' + k2] = fn;
      }
    }
  }
  if (!mem) mem = new WebAssembly.Memory({ initial: 1 });
  importObj.env = { memory: mem };
  const mod = new WebAssembly.Module(_bytes);
  const inst = new WebAssembly.Instance(mod, importObj);
  const exports = {};
  for (const [key, val] of Object.entries(inst.exports)) {
    if (!key.includes('.')) { exports[key] = val; continue; }
    const parts = key.split('.');
    let obj = exports;
    for (let i = 0; i < parts.length - 1; i++) {
      if (!obj[parts[i]] || typeof obj[parts[i]] !== 'object') obj[parts[i]] = {};
      obj = obj[parts[i]];
    }
    obj[parts[parts.length - 1]] = val;
  }
  if (typeof _layouts !== 'undefined') exports.__layouts = _layouts;
  return exports;
}

// ── Memory helpers ──
// Bump allocator and typed read/write for Wasm linear memory.
// Caller manages offset via state = { off: 0 }.

export function alloc(state, nf64 = 0, ni32 = 0) {
  const o = state.off;
  state.off += nf64 * 8 + ni32 * 4;
  state.off = (state.off + 7) & ~7;  // align to 8 bytes (f64 boundary)
  return o;
}

export function writeF64(mem, off, vals) {
  const f = new Float64Array(mem.buffer);
  for (let i = 0; i < vals.length; i++) f[off / 8 + i] = vals[i];
}

export function writeI32(mem, off, vals) {
  const v = new Int32Array(mem.buffer);
  for (let i = 0; i < vals.length; i++) v[off / 4 + i] = vals[i];
}

// read* return copies (.slice), safe across memory.grow
export function readF64(mem, off, n) {
  return new Float64Array(mem.buffer.slice(off, off + n * 8));
}

export function readI32(mem, off, n) {
  return new Int32Array(mem.buffer.slice(off, off + n * 4));
}

// Grow memory if allocator offset exceeds current size (64KB pages)
export function growMemory(mem, off) {
  const needed = Math.ceil(off / 65536);
  const current = mem.buffer.byteLength / 65536;
  if (current < needed) mem.grow(needed - current + 1);
}
`;

/**
 * Compile atra source and wrap in a standalone JS module with embedded Wasm.
 * @param {string} source — atra source code
 * @param {{ name?: string }} [opts]
 * @returns {string} — JS module source
 */
export function bundle(source, opts = {}) {
  const bytes = atra.compile(source, { __memory: true });
  const arr = Array.from(bytes);
  const name = opts.name || 'atra module';

  // Extract layout metadata via atra.parse()
  const ast = atra.parse(source);
  const layoutsMeta = ast.layouts;

  let result = `// ${name} — compiled by atrac\n`
    + `const _bytes = new Uint8Array([${arr.join(',')}]);\n`;

  if (layoutsMeta) {
    result += `const _layouts = ${JSON.stringify(layoutsMeta)};\n`;
  }

  result += RUNTIME_TEMPLATE;

  return result;
}

// ── CLI ─────────────────────────────────────────────────────────────

function usage() {
  console.log(`atrac — atra compiler

Usage:
  atrac <file.atra> [...]            Compile to JS bundle (embedded Wasm)
  atrac --src <file.atra> [...]      Generate source distribution (.src.js)
  atrac -o <output> <file.atra>      Explicit output path (.js, .wasm, .src.js)

Options:
  --src         Source distribution mode
  -o <path>     Output file path (extension determines format for raw .wasm)
  -h, --help    Show this help`);
}

function main(args) {
  let outPath = null, srcMode = false;
  const inputs = [];

  for (let i = 0; i < args.length; i++) {
    if (args[i] === '-o' && i + 1 < args.length) outPath = args[++i];
    else if (args[i] === '--src') srcMode = true;
    else if (args[i] === '--help' || args[i] === '-h') { usage(); process.exit(0); }
    else inputs.push(args[i]);
  }

  if (!inputs.length) { usage(); process.exit(1); }

  const source = inputs.map(f => fs.readFileSync(f, 'utf8')).join('\n\n');
  const baseName = path.basename(inputs[0], '.atra');

  if (srcMode) {
    const lib = buildSrc(source);
    const out = formatSrcJs(lib);
    const dest = outPath || baseName + '.src.js';
    fs.writeFileSync(dest, out);
    console.log(`${dest} (${(out.length / 1024).toFixed(1)} KB)`);
  } else if (outPath && outPath.endsWith('.wasm')) {
    const bytes = compile(source);
    fs.writeFileSync(outPath, bytes);
    console.log(`${outPath} (${bytes.length} bytes)`);
  } else {
    const out = bundle(source, { name: baseName });
    const dest = outPath || baseName + '.js';
    fs.writeFileSync(dest, out);
    console.log(`${dest} (${(out.length / 1024).toFixed(1)} KB)`);
  }
}

// ── Dual-use detection ──────────────────────────────────────────────

const __filename = new URL(import.meta.url).pathname;
// On Windows, pathname starts with /C:/... — normalize for comparison
const argv1 = process.argv[1] ? path.resolve(process.argv[1]) : '';
const self = path.resolve(__filename.replace(/^\/([A-Z]:)/, '$1'));
if (argv1 === self) main(process.argv.slice(2));
